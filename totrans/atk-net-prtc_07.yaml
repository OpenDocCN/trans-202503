- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**  '
- en: '**NETWORK PROTOCOL SECURITY**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络协议安全**  '
- en: Network protocols transfer information between participants in a network, and
    there’s a good chance that information is sensitive. Whether the information includes
    credit card details or top secret information from government systems, it’s important
    to provide security. Engineers consider many requirements for security when they
    initially design a protocol, but vulnerabilities often surface over time, especially
    when a protocol is used on public networks where anyone monitoring traffic can
    attack it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络协议在网络中的参与者之间传输信息，这些信息很可能是敏感的。无论信息是否包含信用卡详细信息或政府系统中的机密信息，都需要提供安全保护。在最初设计协议时，工程师会考虑很多安全要求，但漏洞往往会随着时间的推移显现，特别是在协议被用于公共网络上时，任何监控流量的人都可以对其进行攻击。
- en: 'All secure protocols should do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '所有安全协议应当做到以下几点：  '
- en: • Maintain data confidentiality by protecting data from being read
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '• 通过保护数据不被读取来保持数据机密性  '
- en: • Maintain data integrity by protecting data from being modified
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '• 通过保护数据不被篡改来保持数据完整性  '
- en: • Prevent an attacker from impersonating the server by implementing server authentication
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '• 通过实现服务器认证，防止攻击者冒充服务器  '
- en: • Prevent an attacker from impersonating the client by implementing client authentication
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '• 通过实现客户端认证，防止攻击者冒充客户端  '
- en: In this chapter, I’ll discuss ways in which these four requirements are met
    in common network protocols, address potential weaknesses to look out for when
    analyzing a protocol, and describe how these requirements are implemented in a
    real-world secure protocol. I’ll cover how to identify which protocol encryption
    is in use or what flaws to look for in subsequent chapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我将讨论这些四个要求如何在常见的网络协议中得到满足，分析在检查协议时需要注意的潜在弱点，并描述这些要求如何在现实世界中的安全协议中得以实现。我还将讨论如何识别正在使用的协议加密或在后续章节中寻找潜在缺陷。  '
- en: 'The field of cryptography includes two important techniques many network protocols
    use, both of which protect data or a protocol in some way: *encryption* provides
    data confidentiality, and *signing* provides data integrity and authentication.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '密码学领域包括两种许多网络协议使用的重要技术，它们以某种方式保护数据或协议：*加密*提供数据机密性，*签名*提供数据完整性和认证。  '
- en: 'Secure network protocols heavily use encryption and signing, but cryptography
    can be difficult to implement correctly: it’s common to find implementation and
    design mistakes that lead to vulnerabilities that can break a protocol’s security.
    When analyzing a protocol, you should have a solid understanding of the technologies
    and algorithms involved so you can spot and even exploit serious weaknesses. Let’s
    look at encryption first to see how mistakes in the implementation can compromise
    the security of an application.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '安全的网络协议高度依赖加密和签名，但加密技术的正确实现可能很困难：常常会发现实现和设计上的错误，这些错误会导致漏洞，进而破坏协议的安全性。在分析一个协议时，你应该对所涉及的技术和算法有充分的了解，以便能够发现甚至利用严重的弱点。我们先来看加密，了解实现上的错误如何影响应用的安全性。  '
- en: '**Encryption Algorithms**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**加密算法**  '
- en: The history of encryption goes back thousands of years, and as electronic communications
    have become easier to monitor, encryption has become considerably more important.
    Modern encryption algorithms often rely on very complex mathematical models. However,
    just because a protocol uses complex algorithms doesn’t mean it’s secure.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '加密的历史可以追溯到数千年前，随着电子通信变得越来越容易被监控，加密的重要性也大大增加。现代加密算法通常依赖于非常复杂的数学模型。然而，仅仅因为一个协议使用复杂的算法并不意味着它是安全的。  '
- en: We usually refer to an encryption algorithm as a *cipher* or *code* depending
    on how it’s structured. When discussing the encrypting operation, the original,
    unencrypted message is referred to as *plaintext.* The output of the encryption
    algorithm is an encrypted message called *cipher text*. The majority of algorithms
    also need a *key* for encryption and decryption. The effort to break or weaken
    an encryption algorithm is called *cryptanalysis*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '我们通常将加密算法称为*密码*或*编码*，这取决于它的结构。讨论加密操作时，原始的、未加密的信息被称为*明文*。加密算法的输出是一个加密信息，称为*密文*。大多数算法还需要一个*密钥*来进行加密和解密。破解或削弱加密算法的努力被称为*密码分析*。  '
- en: Many algorithms that were once thought to be secure have shown numerous weaknesses
    and even backdoors. In part, this is due to the massive increase in computing
    performance since the invention of such algorithms (some of which date back to
    the 1970s), making feasible attacks that we once thought possible only in theory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多曾经被认为安全的算法已经显示出许多弱点，甚至后门。这部分是因为自这些算法发明以来，计算性能的大幅提升（其中一些算法可以追溯到1970年代），使得曾经只在理论上可行的攻击变得现实可行。
- en: If you want to break secure network protocols, you need to understand some of
    the well-known cryptographic algorithms and where their weaknesses lie. Encryption
    doesn’t have to involve complex mathematics. Some algorithms are only used to
    obfuscate the structure of the protocol on the network, such as strings or numbers.
    Of course, if an algorithm is simple, its security is generally low. Once the
    mechanism of obfuscation is discovered, it provides no real security.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想破解安全网络协议，你需要了解一些知名的密码学算法以及它们的弱点所在。加密不一定需要复杂的数学。有些算法仅用于混淆网络上协议的结构，如字符串或数字。当然，如果一个算法很简单，它的安全性通常较低。一旦混淆机制被发现，它就不再提供真正的安全性。
- en: Here I’ll provide an overview some common encryption algorithms, but I won’t
    cover the construction of these ciphers in depth because in protocol analysis,
    we only need to understand the algorithm in use.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将提供一些常见加密算法的概述，但我不会深入讲解这些密码的构造，因为在协议分析中，我们只需要理解当前使用的算法。
- en: '***Substitution Ciphers***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***替换密码***'
- en: 'A substitution cipher is the simplest form of encryption. Substitution ciphers
    use an algorithm to encrypt a value based on a substitution table that contains
    one-to-one mapping between the plaintext and the corresponding cipher text value,
    as shown in [Figure 7-1](../Text/ch07.xhtml#ch7fig1). To decrypt the cipher text,
    the process is reversed: the cipher value is looked up in a table (that has been
    reversed), and the original plaintext value is reproduced. [Figure 7-1](../Text/ch07.xhtml#ch7fig1)
    shows an example substitution cipher.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 替换密码是最简单的加密形式。替换密码使用一种算法，通过一个替换表加密一个值，该替换表包含明文和对应的密文值之间的一对一映射，如[图7-1](../Text/ch07.xhtml#ch7fig1)所示。要解密密文，过程是反向的：查找密文值在表中的对应值（该表已被反转），并恢复原始明文值。[图7-1](../Text/ch07.xhtml#ch7fig1)展示了一个示例替换密码。
- en: '![image](../Images/f07-01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-01.jpg)'
- en: '*Figure 7-1: Substitution cipher encryption*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：替换密码加密*'
- en: In [Figure 7-1](../Text/ch07.xhtml#ch7fig1), the substitution table (meant as
    just a simple example) has six defined substitutions shown to the right. In a
    full substitution cipher, many more substitutions would typically be defined.
    During encryption, the first letter is chosen from the plaintext, and the plaintext
    letter’s substitution is then looked up in the substitution table. Here, *H* in
    HELLO is replaced with the letter *X*. This process continues until all the letters
    are encrypted.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7-1](../Text/ch07.xhtml#ch7fig1)中，替换表（仅作为一个简单示例）显示了右侧的六个定义的替换。在完整的替换密码中，通常会定义更多的替换。在加密过程中，首先从明文中选择一个字母，然后在替换表中查找该明文字母的替换。这里，*H*在“HELLO”中被替换为字母*X*。这个过程持续进行，直到所有字母都被加密。
- en: Although substitution can provide adequate protection against casual attacks,
    it fails to withstand cryptanalysis. *Frequency analysis* is commonly used to
    crack substitution ciphers by correlating the frequency of symbols found in the
    cipher text with those typically found in plaintext data sets. For example, if
    the cipher protects a message written in English, frequency analysis might determine
    the frequency of certain common letters, punctuation, and numerals in a large
    body of written works. Because the letter *E* is the most common in the English
    language, in all probability the most frequent character in the enciphered message
    will represent *E*. By following this process to its logical conclusion, it’s
    possible to build the original substitution table and decipher the message.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管替换可以有效防御一般攻击，但它无法抵挡密码分析。*频率分析*通常用于通过将密文中符号的频率与明文数据集中的常见符号频率进行比较，破解替换密码。例如，如果密文保护的是一条用英语写的消息，频率分析可以通过分析大量书面作品中常见字母、标点符号和数字的频率来揭示规律。因为字母*E*在英语中是最常见的字母，所以密文中最常见的字符很可能代表*E*。通过将这一过程推向逻辑结论，就可以构建出原始替换表并破解消息。
- en: '***XOR Encryption***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***异或加密***'
- en: The XOR encryption algorithm is a very simple technique for encrypting and decrypting
    data. It works by applying the bitwise XOR operation between a byte of plaintext
    and a byte of the key, which results in the cipher text. For example, given the
    byte 0x48 and the key byte 0x82, the result of XORing them would be 0xCA.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 异或加密算法是一种非常简单的数据加密和解密技术。它通过将明文字节和密钥字节之间进行逐位异或操作，得到密文。例如，给定字节0x48和密钥字节0x82，对它们进行异或操作的结果将是0xCA。
- en: Because the XOR operation is symmetric, applying that same key byte to the cipher
    text returns the original plaintext. [Figure 7-2](../Text/ch07.xhtml#ch7fig2)
    shows the XOR encryption operation with a single-byte key.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于异或操作是对称的，将相同的密钥字节应用于密文将返回原始明文。[图 7-2](../Text/ch07.xhtml#ch7fig2)展示了使用单字节密钥的异或加密操作。
- en: '![image](../Images/f07-02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-02.jpg)'
- en: '*Figure 7-2: An XOR cipher operation with a single-byte key*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：使用单字节密钥的异或加密操作*'
- en: Specifying a single-byte key makes the encryption algorithm very simple and
    not very secure. It wouldn’t be difficult for an attacker to try all 256 possible
    values for the key to decrypt the cipher text into plaintext, and increasing the
    size of the key wouldn’t help. As the XOR operation is symmetric, the cipher text
    can be XORed with the known plaintext to determine the key. Given enough known
    plaintext, the key could be calculated and applied to the rest of the cipher text
    to decrypt the entire message.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 指定一个单字节密钥使得加密算法非常简单，但安全性较差。对于攻击者来说，尝试所有256个可能的密钥值来解密密文为明文并不难，增加密钥大小也无济于事。由于异或操作是对称的，密文可以与已知明文进行异或操作，从而确定密钥。给定足够的已知明文，密钥可以被计算出来，并应用于其余的密文，解密整个消息。
- en: The only way to securely use XOR encryption is if the key is the same size as
    the message and the values in the key are chosen completely at random. This approach
    is called *one-time pad encryption* and is quite difficult to break. If an attacker
    knows even a small part of the plaintext, they won’t be able to determine the
    complete key. The only way to recover the key would be to know the entire plaintext
    of the message; in that case, obviously, the attacker wouldn’t need to recover
    the key.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 安全地使用异或加密的唯一方法是密钥与消息大小相同，并且密钥中的值完全随机选择。这种方法被称为*一次性密码本加密*，并且相当难以破解。如果攻击者知道明文的任何一小部分，他们也无法确定完整的密钥。恢复密钥的唯一方法是知道整个消息的明文；在那种情况下，显然攻击者就不需要恢复密钥了。
- en: Unfortunately, the one-time pad encryption algorithm has significant problems
    and is rarely used in practice. One problem is that when using a one-time pad,
    the size of the key material you send must be the same size as any message to
    the sender and recipient. The only way a one time pad can be secure is if every
    byte in the message is encrypted with a completely random value. Also, you can
    never reuse a one-time pad key for different messages, because if an attacker
    can decrypt your message one time, then they can recover the key, and then subsequent
    messages encrypted with the same key are compromised.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，一次性密码本加密算法存在显著问题，在实际中很少使用。一个问题是，当使用一次性密码本时，发送方和接收方必须发送与消息大小相同的密钥材料。一次性密码本能够安全的唯一方式是，如果消息中的每个字节都用完全随机的值进行加密。而且，你不能将一次性密码本密钥用于不同的消息，因为如果攻击者能够解密你的一条消息，那么他们就能恢复密钥，然后，使用相同密钥加密的后续消息就会受到威胁。
- en: If XOR encryption is so inferior, why even mention it? Well, even though it
    isn’t “secure,” developers still use it out of laziness because it’s easy to implement.
    XOR encryption is also used as a primitive to build more secure encryption algorithms,
    so it’s important to understand how it works.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果异或加密如此劣质，为什么还要提它呢？嗯，尽管它并不“安全”，开发者还是出于懒惰而使用它，因为它实现起来很简单。异或加密也作为构建更安全加密算法的基础原语，因此理解它的工作原理是很重要的。
- en: '**Random Number Generators**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**随机数生成器**'
- en: 'Cryptographic systems heavily rely on good quality random numbers. In this
    chapter, you’ll see them used as per-session keys, initialization vectors, and
    the large primes *p* and *q* for the RSA algorithm. However, getting truly random
    data is difficult because computers are by nature deterministic: any given program
    should produce the same output when given the same input and state.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 加密系统严重依赖高质量的随机数。在本章中，你将看到它们被用作每会话密钥、初始化向量以及RSA算法中的大素数*p*和*q*。然而，获得真正随机的数据是困难的，因为计算机天生是确定性的：任何给定的程序在相同输入和状态下应该产生相同的输出。
- en: One way to generate relatively unpredictable data is by sampling physical processes.
    For example, you could time a user’s key presses on the keyboard or sample a source
    of electrical noise, such as the thermal noise in a resistor. The trouble with
    these sorts of sources is they don’t provide much data—perhaps only a few hundred
    bytes every second at best, which isn’t enough for a general purpose cryptographic
    system. A simple 4096-bit RSA key requires at least two random 256-byte numbers,
    which would take several seconds to generate.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 生成相对不可预测的数据的一种方法是通过采样物理过程。例如，你可以计时用户在键盘上的按键，或者采样电气噪声源，例如电阻器中的热噪声。这些源的问题是它们提供的数据量很少——最多每秒几百字节，这对于通用加密系统来说是不够的。一个简单的4096位RSA密钥至少需要两个随机的256字节数字，这些数字需要几秒钟才能生成。
- en: 'To make this sampled data go further, cryptographic libraries implement *pseudorandom
    number generators (PRNGs)*, which use an initial seed value and generate a sequence
    of numbers that, in theory, shouldn’t be predictable without knowledge of the
    internal state of the generator. The quality of PRNGs varies wildly between libraries:
    the C library function *rand()*, for instance, is completely useless for cryptographically
    secure protocols. A common mistake is to use a weak algorithm to generate random
    numbers for cryptographic uses.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些采样数据更有用，加密库实现了*伪随机数生成器（PRNG）*，它使用一个初始种子值，并生成一系列数字，理论上，在不知道生成器内部状态的情况下，应该无法预测这些数字。PRNG的质量在不同的库中差异巨大：例如，C语言库函数*rand()*对于加密安全协议完全没用。一个常见的错误是使用弱算法生成用于加密的随机数。
- en: '**Symmetric Key Cryptography**'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**对称密钥加密**'
- en: The only secure way to encrypt a message is to send a completely random key
    that’s the same size as the message before the encryption can take place as a
    one-time pad. Of course, we don’t want to deal with such large keys. Fortunately,
    we can instead construct a symmetric key algorithm that uses mathematical constructs
    to make a secure cipher. Because the key size is considerably shorter than the
    message you want to send and doesn’t depend on how much needs to be encrypted,
    it’s easier to distribute.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 加密消息的唯一安全方法是在加密之前发送一个与消息大小相同的完全随机密钥作为一次性密钥。当然，我们不希望处理如此大的密钥。幸运的是，我们可以构建一个对称密钥算法，利用数学构造来创建一个安全的加密算法。由于密钥的大小比要发送的消息小得多，并且不依赖于需要加密的内容量，因此它更容易分发。
- en: If the algorithm used has no obvious weakness, the limiting factor for security
    is the key size. If the key is short, an attacker could brute-force the key until
    they find the correct one.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用的算法没有明显的弱点，那么安全性的限制因素就是密钥的大小。如果密钥较短，攻击者可以通过暴力破解密钥，直到找到正确的密钥。
- en: 'There are two main types of symmetric ciphers: block and stream ciphers. Each
    has its advantages and disadvantages, and choosing the wrong cipher to use in
    a protocol can seriously impact the security of network communications.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密算法主要有两种类型：分组密码和流密码。每种都有其优缺点，选择错误的加密算法会严重影响网络通信的安全性。
- en: '***Block Ciphers***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分组密码***'
- en: Many well-known symmetric key algorithms, such as the *Advanced Encryption Standard
    (AES)* and the *Data Encryption Standard (DES)*, encrypt and decrypt a fixed number
    of bits (known as a *block*) every time the encryption algorithm is applied. To
    encrypt or decrypt a message, the algorithm requires a key. If the message is
    longer than the size of a block, it must be split into smaller blocks and the
    algorithm applied to each in turn. Each application of the algorithm uses the
    same key, as shown in [Figure 7-3](../Text/ch07.xhtml#ch7fig3). Notice that the
    same key is used for encryption and decryption.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 许多著名的对称密钥算法，如*高级加密标准（AES）*和*数据加密标准（DES）*，每次应用加密算法时都会加密和解密固定数量的位（称为*块*）。要加密或解密一条消息，算法需要一个密钥。如果消息比一个块的大小要长，则必须将其拆分成更小的块，然后依次对每个块应用算法。每次应用算法时都使用相同的密钥，如[图7-3](../Text/ch07.xhtml#ch7fig3)所示。请注意，使用的是相同的密钥进行加密和解密。
- en: '![image](../Images/f07-03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-03.jpg)'
- en: '*Figure 7-3: Block cipher encryption*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：分组密码加密*'
- en: When a symmetric key algorithm is used for encryption, the plaintext block is
    combined with the key as described by the algorithm, resulting in the generation
    of the cipher text. If we then apply the decryption algorithm combined with the
    key to the cipher text, we recover the original plaintext.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用对称密钥算法进行加密时，明文块与密钥按照算法描述的方式结合，生成密文。然后，如果我们将结合密钥的解密算法应用于密文，我们就能恢复原始明文。
- en: '**DES**'
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**DES**'
- en: Probably the oldest block cipher still used in modern applications is the DES,
    which was originally developed by IBM (under the name Lucifer) and was published
    as a *Federal Information Processing Standard (FIPS)* in 1979\. The algorithm
    uses a *Feistel network* to implement the encryption process. A Feistel network,
    which is common in many block ciphers, operates by repeatedly applying a function
    to the input for a number of *rounds*. The function takes as input the value from
    the previous round (the original plaintext) as well as a specific subkey that
    is derived from the original key using a *key-scheduling* algorithm.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可能仍在现代应用中使用的最古老的块加密算法是 DES，它最初由 IBM 开发（名为 Lucifer），并于 1979 年作为 *联邦信息处理标准（FIPS）*
    发布。该算法使用 *费斯特尔网络* 实现加密过程。费斯特尔网络在许多块加密算法中都很常见，它通过反复应用一个函数到输入中，执行若干 *轮* 的操作。该函数以上一轮的值（原始明文）以及通过
    *密钥调度* 算法从原始密钥派生的特定子密钥作为输入。
- en: The DES algorithm uses a 64-bit block size and a 64-bit key. However, DES requires
    that 8 bits of the key be used for error checking, so the effective key is only
    56 bits. The result is a very small key that is unsuitable for modern applications,
    as was proven in 1998 by the Electronic Frontier Foundation’s DES cracker—a hardware-key
    brute-force attacker that was able to discover an unknown DES key in about 56
    hours. At the time, the custom hardware cost about $250,000; today’s cloud-based
    cracking tools can crack a key in less than a day far more cheaply.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: DES 算法使用 64 位的块大小和 64 位的密钥。然而，DES 要求 8 位密钥用于错误检查，因此有效密钥长度仅为 56 位。结果是一个非常小的密钥，已经不适合现代应用，正如
    1998 年电子前沿基金会的 DES 破解器所证明的那样——这是一种硬件密钥暴力破解攻击工具，能够在约 56 小时内破解一个未知的 DES 密钥。当时，这种定制硬件的成本大约为
    25 万美元；今天，基于云的破解工具可以以更低的成本在不到一天的时间内破解密钥。
- en: '**Triple DES**'
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**三重 DES**'
- en: Rather than throwing away DES completely, cryptographers developed a modified
    form that applies the algorithm three times. The algorithm in *Triple DES (TDES
    or 3DES)* uses three separate DES keys, providing an effective key size of 168
    bits (although it can be proven that the security is actually lower than the size
    would suggest). As shown in [Figure 7-4](../Text/ch07.xhtml#ch7fig4), in Triple
    DES, the DES encrypt function is first applied to the plaintext using the first
    key. Next, the output is decrypted using the second key. Then the output is encrypted
    again using the third key, resulting in the final cipher text. The operations
    are reversed to perform decryption.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学家没有完全放弃 DES，而是开发了一种修改版，将该算法应用三次。*三重DES（TDES 或 3DES）*算法使用三个独立的 DES 密钥，提供 168
    位的有效密钥长度（尽管可以证明其安全性实际上低于预期的大小）。如[图 7-4](../Text/ch07.xhtml#ch7fig4)所示，在三重 DES
    中，首先使用第一个密钥对明文应用 DES 加密函数。接下来，使用第二个密钥对输出进行解密。然后，再使用第三个密钥对输出进行加密，最终得到密文。解密时，操作则是反向进行的。
- en: '![image](../Images/f07-04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-04.jpg)'
- en: '*Figure 7-4: The Triple DES encryption process*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：三重 DES 加密过程*'
- en: '**AES**'
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**AES**'
- en: 'A far more modern encryption algorithm is AES, which is based on the algorithm
    Rijndael. AES uses a fixed block size of 128 bits and can use three different
    key lengths: 128, 192, and 256 bits; they are sometimes referred to as AES128,
    AES192, and AES256, respectively. Rather than using a Feistel network, AES uses
    a *substitution-permutation network*, which consists of two main components: *substitution
    boxes (S-Box)* and *permutation boxes (P-Box)*. The two components are chained
    together to form a single round of the algorithm. As with the Feistel network,
    this round can be applied multiple times with different values of the S-Box and
    P-Box to produce the encrypted output.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更现代的加密算法是 AES，它基于 Rijndael 算法。AES 使用固定的 128 位块大小，并可以使用三种不同的密钥长度：128 位、192
    位和 256 位；它们分别被称为 AES128、AES192 和 AES256。与使用费斯特尔网络不同，AES 使用 *代换-置换网络*，该网络由两个主要组件组成：*代换盒（S-Box）*
    和 *置换盒（P-Box）*。这两个组件链式连接，形成算法的单轮操作。与费斯特尔网络类似，这一轮操作可以多次应用，并使用不同的 S-Box 和 P-Box
    值来生成加密输出。
- en: An S-Box is a basic mapping table not unlike a simple substitution cipher. The
    S-Box takes an input, looks it up in a table, and produces output. As an S-Box
    uses a large, distinct lookup table, it’s very helpful in identifying particular
    algorithms. The distinct lookup table provides a very large fingerprint, which
    can be discovered in application executables. I explained this in more depth in
    [Chapter 6](../Text/ch06.xhtml#ch06) when I discussed techniques to find unknown
    cryptographic algorithms by reverse engineering binaries.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: S-Box是一种基本的映射表，类似于简单的替换密码。S-Box接收输入，查表并生成输出。由于S-Box使用一个大型的、独特的查找表，它在识别特定算法时非常有用。这个独特的查找表提供了一个非常大的指纹，可以在应用程序的可执行文件中被发现。我在[第6章](../Text/ch06.xhtml#ch06)中详细解释了这一点，当时我讨论了通过逆向工程二进制文件来寻找未知加密算法的技术。
- en: '**Other Block Ciphers**'
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**其他块加密算法**'
- en: DES and AES are the block ciphers that you’ll most commonly encounter, but there
    are others, such as those listed in [Table 7-1](../Text/ch07.xhtml#ch7tab1) (and
    still others in commercial products).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: DES和AES是你最常遇到的块加密算法，但还有其他算法，如[表7-1](../Text/ch07.xhtml#ch7tab1)中列出的（以及商业产品中的其他算法）。
- en: '**Table 7-1:** Common Block Cipher Algorithms'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-1：** 常见的块加密算法'
- en: '| **Cipher name** | **Block size (bits)** | **Key size (bits)** | **Year introduced**
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **密码名称** | **块大小（位）** | **密钥大小（位）** | **引入年份** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Data Encryption Standard (DES) | 64 | 56 | 1979 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 数据加密标准（DES） | 64 | 56 | 1979 |'
- en: '| Blowfish | 64 | 32–448 | 1993 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| Blowfish | 64 | 32–448 | 1993 |'
- en: '| Triple Data Encryption Standard (TDES/3DES) | 64 | 56, 112, 168 | 1998 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 三重数据加密标准（TDES/3DES） | 64 | 56, 112, 168 | 1998 |'
- en: '| Serpent | 128 | 128, 192, 256 | 1998 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 蛇形算法 | 128 | 128, 192, 256 | 1998 |'
- en: '| Twofish | 128 | 128, 192, 256 | 1998 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| Twofish | 128 | 128, 192, 256 | 1998 |'
- en: '| Camellia | 128 | 128, 192, 256 | 2000 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| Camellia | 128 | 128, 192, 256 | 2000 |'
- en: '| Advanced Encryption Standard (AES) | 128 | 128, 192, 256 | 2001 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 高级加密标准（AES） | 128 | 128, 192, 256 | 2001 |'
- en: The block and key size help you determine which cipher a protocol is using based
    on the way the key is specified or how the encrypted data is divided into blocks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 块和密钥大小帮助你根据密钥的指定方式或加密数据如何被划分成块，来确定协议使用的是哪种加密算法。
- en: '***Block Cipher Modes***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***块加密模式***'
- en: The algorithm of a block cipher defines how the cipher operates on blocks of
    data. Alone, a block-cipher algorithm has some weaknesses, as you’ll soon see.
    Therefore, in a real-world protocol, it is common to use the block cipher in combination
    with another algorithm called a *mode of operation*. The mode provides additional
    security properties, such as making the output of the encryption less predictable.
    Sometimes the mode also changes the operation of the cipher by, for example, converting
    a block cipher into a stream cipher (which I’ll explain in more detail in “[Stream
    Ciphers](../Text/ch07.xhtml#ch00lev1sec194)” on [page 158](../Text/ch07.xhtml#page_158)).
    Let’s take a look at some of the more common modes as well as their security properties
    and weaknesses.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 块加密算法定义了加密如何在数据块上操作。单独来看，块加密算法有一些弱点，正如你很快会看到的那样。因此，在实际协议中，通常会将块加密与另一种称为*操作模式*的算法结合使用。操作模式提供了额外的安全特性，例如使加密输出更难预测。有时，操作模式还会改变加密算法的运作方式，例如将块加密转换为流加密（我将在[第158页](../Text/ch07.xhtml#page_158)的“[流加密](../Text/ch07.xhtml#ch00lev1sec194)”中详细解释）。让我们看看一些常见的模式，以及它们的安全特性和弱点。
- en: '**Electronic Code Book**'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**电子代码本**'
- en: The simplest and default mode of operation for block ciphers is *Electronic
    Code Book (ECB)*. In ECB, the encryption algorithm is applied to each fixed-size
    block from the plaintext to generate a series of cipher text blocks. The size
    of the block is defined by the algorithm in use. For example, if AES is the cipher,
    each block in ECB mode must be 16 bytes in size. The plaintext is divided into
    individual blocks, and the cipher algorithm applied. ([Figure 7-3](../Text/ch07.xhtml#ch7fig3)
    showed the ECB mode at work.)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 块加密的最简单和默认的操作模式是*电子代码本（ECB）*。在ECB模式中，加密算法会应用于明文的每一个固定大小的数据块，生成一系列的密文数据块。数据块的大小由所使用的算法定义。例如，如果使用AES作为加密算法，在ECB模式下每个数据块的大小必须为16字节。明文被分为单独的块，并应用加密算法。（[图7-3](../Text/ch07.xhtml#ch7fig3)展示了ECB模式的工作原理。）
- en: Because each plaintext block is encrypted independently in ECB, it will always
    encrypt to the same block of cipher text. As a consequence, ECB doesn’t always
    hide large-scale structures in the plaintext, as in the bitmap image shown in
    [Figure 7-5](../Text/ch07.xhtml#ch7fig5). In addition, an attacker can corrupt
    or manipulate the decrypted data in independent-block encryption by shuffling
    around blocks of the cipher text before it is decrypted.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在ECB中每个明文块是独立加密的，所以它将始终加密为相同的密文块。因此，ECB并不总是能隐藏明文中的大规模结构，如[图7-5](../Text/ch07.xhtml#ch7fig5)所示的位图图像。此外，攻击者可以通过在解密之前对密文块进行重新排列，来破坏或操纵独立块加密的解密数据。
- en: '![image](../Images/f07-05.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-05.jpg)'
- en: '*Figure 7-5: ECB encryption of a bitmap image*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：对位图图像的ECB加密*'
- en: '**Cipher Block Chaining**'
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**密码块链接**'
- en: Another common mode of operation is *Cipher Block Chaining (CBC)*, which is
    more complex than ECB and avoids its pitfalls. In CBC, the encryption of a single
    plaintext block depends on the encrypted value of the previous block. The previous
    encrypted block is XORed with the current plaintext block, and then the encryption
    algorithm is applied to this combined result. [Figure 7-6](../Text/ch07.xhtml#ch7fig6)
    shows an example of CBC applied to two blocks.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的操作模式是*密码块链接（CBC）*，它比ECB更复杂，并且避免了ECB的缺陷。在CBC模式中，单个明文块的加密依赖于前一个块的加密值。前一个加密块与当前明文块进行异或操作，然后将加密算法应用于这个组合结果。[图7-6](../Text/ch07.xhtml#ch7fig6)展示了将CBC应用于两个块的示例。
- en: At the top of [Figure 7-6](../Text/ch07.xhtml#ch7fig6) are the original plaintext
    blocks. At the bottom is the resulting cipher text generated by applying the block-cipher
    algorithm as well as the CBC mode algorithm. Before each plaintext block is encrypted,
    the plaintext is XORed with the previous encrypted block. After the blocks have
    been XORed together, the encryption algorithm is applied. This ensures that the
    output cipher text is dependent on the plaintext as well as the previous encrypted
    blocks.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7-6](../Text/ch07.xhtml#ch7fig6)的顶部是原始的明文块，底部是通过应用块加密算法以及CBC模式算法生成的结果密文。在每个明文块加密之前，明文会与前一个加密块进行异或操作。将块进行异或后，再应用加密算法。这样可以确保输出的密文不仅依赖于明文，还依赖于前一个加密块。
- en: '![image](../Images/f07-06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-06.jpg)'
- en: '*Figure 7-6: The CBC mode of operation*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：CBC操作模式*'
- en: Because the first block of plaintext has no previous cipher text block with
    which to perform the XOR operation, you combine it with a manually chosen or randomly
    generated block called an *initialization vector (IV)*. If the IV is randomly
    generated, it must be sent with the encrypted data, or the receiver will not be
    able to decrypt the first block of the message. (Using a fixed IV is an issue
    if the same key is used for all communications, because if the same message is
    encrypted multiple times, it will always encrypt to the same cipher text.)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因为第一个明文块没有前一个密文块可以执行异或（XOR）操作，所以你需要将它与一个手动选择或随机生成的块结合，这个块被称为*初始化向量（IV）*。如果IV是随机生成的，它必须与加密数据一起发送，否则接收方将无法解密消息的第一个块。（如果使用固定的IV，并且相同的密钥用于所有通信，就会存在问题，因为如果相同的消息被多次加密，它将始终加密为相同的密文。）
- en: 'To decrypt CBC, the encryption operations are performed in reverse: decryption
    happens from the end of the message to the front, decrypting each cipher text
    block with the key and at each step XORing the decrypted block with the encrypted
    block that precedes it in the cipher text.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密CBC，加密操作按相反顺序执行：解密从消息的末尾到前端进行，每次用密钥解密一个密文块，并在每一步将解密后的块与前面一个加密块进行异或操作。
- en: '**Alternative Modes**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**替代模式**'
- en: Other modes of operation for block ciphers are available, including those that
    can convert a block cipher into a stream cipher, and special modes, such as *Galois
    Counter Mode (GCM)*, which provide data integrity and confidentiality. [Table
    7-2](../Text/ch07.xhtml#ch7tab2) lists several common modes of operation and indicates
    whether they generate a block or stream cipher (which I’ll discuss in the section
    “[Stream Ciphers](../Text/ch07.xhtml#ch00lev1sec194)” on [page 158](../Text/ch07.xhtml#page_158)).
    To describe each in detail would be outside the scope of this book, but this table
    provides a rough guide for further research.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 块密码的其他操作模式包括那些可以将块密码转换为流密码的模式，以及一些特殊模式，如*Galois 计数器模式（GCM）*，它们提供数据完整性和保密性。[表
    7-2](../Text/ch07.xhtml#ch7tab2)列出了几种常见的操作模式，并指示它们是生成块密码还是流密码（我将在“[流密码](../Text/ch07.xhtml#ch00lev1sec194)”一节中进一步讨论，见[第
    158 页](../Text/ch07.xhtml#page_158)）。详细描述每个模式超出了本书的范围，但此表提供了进一步研究的粗略指南。
- en: '**Table 7-2:** Common Block Cipher Modes of Operation'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-2：** 常见块密码操作模式'
- en: '| **Mode name** | **Abbreviation** | **Mode type** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **模式名称** | **缩写** | **模式类型** |'
- en: '| --- | --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Electronic Code Book | ECB | Block |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 电子密码本 | ECB | 块模式 |'
- en: '| Cipher Block Chaining | CBC | Block |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 密码块链接 | CBC | 块模式 |'
- en: '| Output Feedback | OFB | Stream |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 输出反馈 | OFB | 流模式 |'
- en: '| Cipher Feedback | CFB | Stream |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 密码反馈 | CFB | 流模式 |'
- en: '| Counter | CTR | Stream |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 计数器 | CTR | 流模式 |'
- en: '| Galois Counter Mode | GCM | Stream with data integrity |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| Galois 计数器模式 | GCM | 带数据完整性的流模式 |'
- en: '***Block Cipher Padding***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***块密码填充***'
- en: 'Block ciphers operate on a fixed-size message unit: a block. But what if you
    want to encrypt a single byte of data and the block size is 16 bytes? This is
    where *padding* schemes come into play. Padding schemes determine how to handle
    the unused remainder of a block during encryption and decryption.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 块密码在固定大小的消息单元上进行操作：一个块。但是，如果你想加密一个字节的数据，而块大小是 16 字节，该怎么办？这时，*填充*方案就派上用场了。填充方案决定了在加密和解密过程中如何处理块中未使用的剩余部分。
- en: The simplest approach to padding is to pad the extra block space with a specific
    known value, such as a repeating-zero byte. But when you decrypt the block, how
    do you distinguish between padding bytes and meaningful data? Some network protocols
    specify an explicit-length field, which you can use to remove the padding, but
    you can’t always rely on this.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 填充的最简单方法是用特定已知的值填充额外的块空间，如重复的零字节。但是，当你解密这个块时，如何区分填充字节和有意义的数据呢？一些网络协议指定了一个显式长度字段，你可以用它来去除填充，但你不能总是依赖这个方法。
- en: 'One padding scheme that solves this problem is defined in the *Public Key Cryptography
    Standard #7 (PKCS#7).* In this scheme, all the padded bytes are set to a value
    that represents how many padded bytes are present. For example, if three bytes
    of padding are present, each byte is set to the value 3, as shown in [Figure 7-7](../Text/ch07.xhtml#ch7fig7).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '一种解决这个问题的填充方案在*公钥密码学标准 #7（PKCS#7）*中定义。在这种方案中，所有填充的字节都设置为表示填充字节数量的值。例如，如果有三个字节的填充，每个字节都设置为值
    3，如[图 7-7](../Text/ch07.xhtml#ch7fig7)所示。'
- en: '![image](../Images/f07-07.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-07.jpg)'
- en: '*Figure 7-7: Examples of PKCS#7 padding*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：PKCS#7 填充示例*'
- en: What if you don’t need padding? For instance, what if the last block you’re
    encrypting is already the correct length? If you simply encrypt the last block
    and transmit it, the decryption algorithm will interpret legitimate data as part
    of a padded block. To remove this ambiguity, the encryption algorithm must send
    a final dummy block that only contains padding in order to signal to the decryption
    algorithm that the last block can be discarded.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要填充怎么办？例如，如果你正在加密的最后一个块已经是正确的长度呢？如果你只是加密最后一个块并传输它，解密算法会将合法数据解释为填充块的一部分。为了解除这种歧义，加密算法必须发送一个只包含填充的虚拟块，以便向解密算法指示最后一个块可以被丢弃。
- en: When the padded block is decrypted, the decryption process can easily verify
    the number of padding bytes present. The decryption process reads the last byte
    in the block to determine the expected number of padding bytes. For example, if
    the decryption process reads a value of 3, it knows that three bytes of padding
    should be present. The decryption process then reads the other two bytes of expected
    padding, verifying that each byte also has a value of 3\. If padding is incorrect,
    either because all the expected padding bytes are not the same value or the padding
    value is out of range (the value must be less than or equal to the size of a block
    and greater than 0), an error occurs that could cause the decryption process to
    fail. The manner of failure is a security consideration in itself.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当填充的块被解密时，解密过程可以轻松验证填充字节的数量。解密过程读取块中的最后一个字节，以确定预期的填充字节数量。例如，如果解密过程读取到值为 3，它知道应该有三个填充字节。然后，解密过程会读取另外两个预期的填充字节，验证每个字节的值是否也为
    3。如果填充不正确，可能是因为所有预期的填充字节的值不相同，或者填充值超出范围（值必须小于或等于块的大小且大于 0），则会发生错误，可能导致解密过程失败。失败的方式本身就是一个安全考虑。
- en: '***Padding Oracle Attack***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***填充 oracle 攻击***'
- en: A serious security hole, known as the *padding oracle attack*, occurs when the
    CBC mode of operation is combined with the PKCS#7 padding scheme. The attack allows
    an attacker to decrypt data and in some cases encrypt their own data (such as
    a session token) when sent via this protocol, even if they don’t know the key.
    If an attacker can decrypt a session token, they might recover sensitive information.
    But if they can encrypt the token, they might be able to do something like circumvent
    access controls on a website.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个严重的安全漏洞，被称为*填充 oracle 攻击*，当 CBC 模式与 PKCS#7 填充方案结合使用时发生。此攻击允许攻击者解密数据，在某些情况下，当数据通过此协议发送时，即使攻击者不知道密钥，也能加密自己的数据（例如会话令牌）。如果攻击者能够解密会话令牌，他们可能会恢复敏感信息。但如果他们能够加密令牌，他们可能会绕过网站的访问控制。
- en: For example, consider [Listing 7-1](../Text/ch07.xhtml#ch7list1), which decrypts
    data from the network using a private DES key.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑[清单 7-1](../Text/ch07.xhtml#ch7list1)，它使用私有 DES 密钥解密来自网络的数据。
- en: '[PRE0]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 7-1: A simple DES decryption from the network*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-1：来自网络的简单 DES 解密*'
- en: The code reads the IV and the encrypted data from the network ➊ and passes it
    to a DES CBC decryption routine using an internal application key ➋. In this case,
    it decrypts a client session token. This use case is common in web application
    frameworks, where the client is effectively stateless and must send a token with
    each request to verify its identity.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码从网络读取 IV 和加密数据 ➊，并将其传递给使用内部应用密钥的 DES CBC 解密程序 ➋。在这种情况下，它解密客户端会话令牌。这个用例在 Web
    应用程序框架中很常见，在这种情况下，客户端实际上是无状态的，每次请求都必须发送令牌来验证其身份。
- en: The decryption function returns an error condition that signals whether the
    decryption failed. If so, it sends the string `ERROR` to the client ➌; otherwise,
    it sends the string `SUCCESS` ➍. Consequently, this code provides an attacker
    with information about the success or failure of decrypting an arbitrary encrypted
    block from a client. In addition, if the code uses PKCS#7 for padding and an error
    occurs (because the padding doesn’t match the correct pattern in the last decrypted
    block), an attacker could use this information to perform the padding oracle attack
    and then decrypt the block of data the attacker sent to a vulnerable service.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 解密函数返回一个错误条件，指示解密是否失败。如果失败，它会将字符串 `ERROR` 发送到客户端 ➌；否则，它会发送字符串 `SUCCESS` ➍。因此，代码为攻击者提供了有关解密客户端任意加密块成功或失败的信息。此外，如果代码使用
    PKCS#7 进行填充，并且发生错误（因为填充与最后解密块中的正确模式不匹配），攻击者可以利用这些信息执行填充 oracle 攻击，然后解密攻击者发送到易受攻击服务的数据块。
- en: 'This is the essence of the padding oracle attack: by paying attention to whether
    the network service successfully decrypted the CBC-encrypted block, the attacker
    can infer the block’s underlying unencrypted value. (The term *oracle* refers
    to the fact that the attacker can ask the service a question and receive a true
    or false answer. Specifically, in this case, the attacker can ask whether the
    padding for the encrypted block they sent to the service is valid.)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是填充 Oracle 攻击的本质：通过关注网络服务是否成功解密了 CBC 加密块，攻击者可以推测出该块的原始未加密值。（术语 *oracle* 指的是攻击者可以向服务提出问题并获得真假答案。具体来说，在这种情况下，攻击者可以询问他们发送到服务的加密块的填充是否有效。）
- en: To better understand how the padding oracle attack works, let’s return to how
    CBC decrypts a single block. [Figure 7-8](../Text/ch07.xhtml#ch7fig8) shows the
    decryption of a block of CBC-encrypted data. In this example, the plaintext is
    the string `Hello` with three bytes of PKCS#7 padding after it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解填充 Oracle 攻击是如何工作的，让我们回顾一下 CBC 解密单个块的过程。[图 7-8](../Text/ch07.xhtml#ch7fig8)展示了一个
    CBC 加密数据块的解密过程。在这个例子中，明文是字符串 `Hello`，后面有三个字节的 PKCS#7 填充。
- en: By querying the web service, the attacker has direct control over the original
    cipher text and the IV. Because each plaintext byte is XORed with an IV byte during
    the final decryption step, the attacker can directly control the plaintext output
    by changing the corresponding byte in the IV. In the example shown in [Figure
    7-8](../Text/ch07.xhtml#ch7fig8), the last byte of the decrypted block is 0x2B,
    which gets XORed with the IV byte 0x28 and outputs 0x03, a padding byte. But if
    you change the last IV byte to 0xFF, the last byte of the cipher text decrypts
    to 0xD4, which is no longer a valid padding byte, and the decryption service returns
    an error.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查询网络服务，攻击者可以直接控制原始密文和 IV。因为在最终解密步骤中，每个明文字节都会与一个 IV 字节进行异或运算，攻击者可以通过改变 IV 中相应字节来直接控制明文输出。在[图
    7-8](../Text/ch07.xhtml#ch7fig8)中，解密块的最后一个字节是 0x2B，它与 IV 字节 0x28 进行异或运算，输出 0x03，这是一个填充字节。但如果将最后一个
    IV 字节更改为 0xFF，密文的最后一个字节解密为 0xD4，这不再是有效的填充字节，解密服务将返回错误。
- en: '![image](../Images/f07-08.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f07-08.jpg)'
- en: '*Figure 7-8: CBC decryption with IV*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-8：带 IV 的 CBC 解密*'
- en: Now the attacker has everything they need to figure out the padding value. They
    query the web service with dummy cipher texts, trying all possible values for
    the last byte in the IV. Whenever the resulting decrypted value is not equal to
    0x01 (or by chance another valid padding arrangement), the decryption returns
    an error. But once padding is valid, the decryption will return success.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，攻击者已经拥有了破解填充值所需的一切。他们通过查询网络服务并发送虚假的密文，尝试所有可能的 IV 最后一个字节值。每当解密后的值不等于 0x01（或者恰好是其他有效的填充方式）时，解密返回错误。但一旦填充有效，解密将返回成功。
- en: With this information, the attacker can determine the value of that byte in
    the decrypted block, even though they don’t have the key. For example, say the
    attacker sends the last IV byte as 0x2A. The decryption returns success, which
    means the decrypted byte XORed with 0x2A should equal 0x01\. Now the attacker
    can calculate the decrypted value by XORing 0x2A with 0x01, yielding 0x2B; if
    the attacker XORs this value with the original IV byte (0x28), the result is 0x03,
    the original padding value, as expected.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，攻击者即使没有密钥，也能确定解密块中该字节的值。例如，假设攻击者将最后一个 IV 字节发送为 0x2A。解密返回成功，这意味着解密字节与
    0x2A 异或后应等于 0x01。现在，攻击者可以通过将 0x2A 与 0x01 异或来计算解密值，得到 0x2B；如果攻击者将该值与原始 IV 字节（0x28）异或，结果就是
    0x03，原始填充值，符合预期。
- en: The next step in the attack is to use the IV to generate a value of 0x02 in
    the lowest two bytes of the plaintext. In the same manner that the attacker used
    brute force on the lowest byte earlier, now they can brute force the second-to-lowest
    byte. Next, because the attacker knows the value of the lowest byte, it’s possible
    to set it to 0x02 with the appropriate IV value. Then, they can perform brute
    force on the second-to-lowest byte until the decryption is successful, which means
    the second byte now equals 0x02 when decrypted. By repeating this process until
    *all* bytes have been calculated, an attacker could use this technique to decrypt
    any block.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击的下一步是使用初始化向量（IV）在明文的最低两个字节中生成0x02的值。与攻击者之前在最低字节上使用暴力破解的方法相同，现在他们可以对倒数第二个字节进行暴力破解。接下来，由于攻击者知道最低字节的值，他们可以使用合适的IV值将其设置为0x02。然后，他们可以对倒数第二个字节进行暴力破解，直到解密成功，这意味着解密后的第二个字节现在等于0x02。通过重复这个过程直到*所有*字节都被计算出来，攻击者可以使用这种技术来解密任何块。
- en: '***Stream Ciphers***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***流密码***'
- en: Unlike block ciphers, which encrypt blocks of a message, stream ciphers work
    at the individual bit level. The most common algorithm used for stream ciphers
    generates a pseudorandom stream of bits, called the *key stream*, from an initial
    key. This key stream is then arithmetically applied to the message, typically
    using the XOR operation, to produce the cipher text, as shown in [Figure 7-9](../Text/ch07.xhtml#ch7fig9).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与加密消息块的块密码不同，流密码在单个比特级别进行工作。流密码中最常用的算法通过初始密钥生成伪随机的比特流，称为*密钥流*。然后，该密钥流通过算术运算应用于消息，通常使用异或操作（XOR），从而生成密文，如[图
    7-9](../Text/ch07.xhtml#ch7fig9)所示。
- en: '![image](../Images/f07-09.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-09.jpg)'
- en: '*Figure 7-9: A stream cipher operation*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：流密码操作*'
- en: As long as the arithmetic operation is reversible, all it takes to decrypt the
    message is to generate the same key stream used for encryption and perform the
    reverse arithmetic operation on the cipher text. (In the case of XOR, the reverse
    operation is actually XOR.) The key stream can be generated using a completely
    custom algorithm, such as in RC4, or by using a block cipher and an accompanying
    mode of operation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 只要算术操作是可逆的，解密消息所需的就是生成与加密时相同的密钥流，并对密文执行逆算术操作。（在异或操作的情况下，逆操作实际上也是异或。）密钥流可以使用完全自定义的算法生成，如RC4，或者通过使用块密码及其配套的操作模式生成。
- en: '[Table 7-3](../Text/ch07.xhtml#ch7tab3) lists some common algorithms that you
    might find in real-world applications.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7-3](../Text/ch07.xhtml#ch7tab3)列出了一些你可能在现实世界应用中遇到的常见算法。'
- en: '**Table 7-3:** Common Stream Ciphers'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-3：** 常见流密码'
- en: '| **Cipher name** | **Key size (bits)** | **Year introduced** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **密码名称** | **密钥大小（位）** | **引入年份** |'
- en: '| --- | --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| A5/1 and A5/2 (used in GSM voice encryption) | 54 or 64 | 1989 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| A5/1 和 A5/2（用于GSM语音加密） | 54 或 64 | 1989 |'
- en: '| RC4 | Up to 2048 | 1993 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| RC4 | 最大 2048 | 1993 |'
- en: '| Counter mode (CTR) | Dependent on block cipher | N/A |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 计数器模式（CTR） | 依赖于块密码 | 不适用 |'
- en: '| Output Feedback mode (OFB) | Dependent on block cipher | N/A |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 输出反馈模式（OFB） | 依赖于块密码 | 不适用 |'
- en: '| Cipher Feedback mode (CFB) | Dependent on block cipher | N/A |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 密码反馈模式（CFB） | 依赖于块密码 | 不适用 |'
- en: '**Asymmetric Key Cryptography**'
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**非对称密钥加密**'
- en: 'Symmetric key cryptography strikes a good balance between security and convenience,
    but it has a significant problem: participants in the network need to physically
    exchange secret keys. This is tough to do when the network spans multiple geographical
    regions. Fortunately, *asymmetric key cryptography* (commonly called *public key
    encryption*) can mitigate this issue.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对称密钥加密在安全性和便利性之间取得了良好的平衡，但它有一个显著的问题：网络中的参与者需要物理交换秘密密钥。当网络跨越多个地理区域时，这一点尤其困难。幸运的是，*非对称密钥加密*（通常称为*公钥加密*）可以缓解这个问题。
- en: 'An asymmetric algorithm requires two types of keys: *public* and *private*.
    The public key encrypts a message, and the private key decrypts it. Because the
    public key *cannot* decrypt a message, it can be given to anyone, even over a
    public network, without fear of its being captured by an attacker and used to
    decrypt traffic, as shown in [Figure 7-10](../Text/ch07.xhtml#ch7fig10).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称算法需要两种类型的密钥：*公钥*和*私钥*。公钥用于加密消息，私钥用于解密消息。由于公钥*不能*解密消息，因此它可以安全地分发给任何人，即使通过公共网络，也无需担心被攻击者捕获并用来解密流量，如[图
    7-10](../Text/ch07.xhtml#ch7fig10)所示。
- en: '![image](../Images/f07-10.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-10.jpg)'
- en: '*Figure 7-10: Asymmetric key encryption and decryption*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-10：非对称密钥加密与解密*'
- en: Although the public and private keys are related mathematically, asymmetric
    key algorithms are designed to make retrieving a private key from a public key
    very time consuming; they’re built upon mathematical primitives known as *trapdoor
    functions*. (The name is derived from the concept that it’s easy to go through
    a trapdoor, but if it shuts behind you, it’s difficult to go back.) These algorithms
    rely on the assumption that there is no workaround for the time-intensive nature
    of the underlying mathematics. However, future advances in mathematics or computing
    power might disprove such assumptions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管公钥和私钥在数学上是相关的，但非对称密钥算法的设计目的是让从公钥获取私钥变得非常耗时；它们是基于一种称为 *陷门函数* 的数学原语。（这一名称源自一个概念，即通过陷门很容易，但如果它在你之后关闭，你就很难再回去了。）这些算法依赖于一个假设：对于底层数学的时间消耗性没有任何绕过的办法。然而，未来数学或计算能力的进步可能会证明这一假设是错误的。
- en: '***RSA Algorithm***'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***RSA 算法***'
- en: Surprisingly, not many unique asymmetric key algorithms are in common use, especially
    compared to symmetric ones. The *RSA* algorithm is currently the most widely used
    to secure network traffic and will be for the foreseeable future. Although newer
    algorithms are based on mathematical constructs called *elliptic curves*, they
    share many general principles with RSA.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，常用的唯一非对称密钥算法并不多，尤其是与对称算法相比。*RSA* 算法目前是最广泛用于保护网络流量的算法，预计在可预见的未来仍将是主流。尽管较新的算法基于一种称为
    *椭圆曲线* 的数学结构，它们与 RSA 算法有许多共同的基本原理。
- en: The RSA algorithm, first published in 1977, is named after its original developers—Ron
    Rivest, Adi Shamir, and Leonard Adleman. Its security relies on the assumption
    that it’s difficult to factor large integers that are the product of two prime
    numbers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 算法首次发布于 1977年，以其原始开发者——Ron Rivest、Adi Shamir 和 Leonard Adleman 的名字命名。其安全性依赖于一个假设，即将由两个素数相乘得到的大整数进行因式分解是非常困难的。
- en: '[Figure 7-11](../Text/ch07.xhtml#ch7fig11) shows the RSA encryption and decryption
    process. To generate a new key pair using RSA, you generate two large, random
    prime numbers, *p* and *q*, and then choose a *public exponent* (*e*). (It’s common
    to use the value 65537, because it has mathematical properties that help ensure
    the security of the algorithm.) You must also calculate two other numbers: the
    *modulus* (*n*), which is the product of *p* and *q*, and a *private exponent*
    (*d*), which is used for decryption. (The process to generate *d* is rather complicated
    and beyond the scope of this book.) The public exponent combined with the modulus
    constitutes the *public key*, and the private exponent and modulus form the *private
    key*.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-11](../Text/ch07.xhtml#ch7fig11) 展示了 RSA 的加密和解密过程。为了使用 RSA 生成新的密钥对，你需要生成两个大的随机素数
    *p* 和 *q*，然后选择一个 *公共指数* (*e*)。（通常使用值 65537，因为它具有确保算法安全性的数学特性。）你还需要计算另外两个数字：*模数*
    (*n*)，即 *p* 和 *q* 的乘积，以及一个 *私有指数* (*d*)，用于解密。（生成 *d* 的过程相当复杂，超出了本书的讨论范围。）公共指数和模数组成了
    *公钥*，私有指数和模数组成了 *私钥*。'
- en: For the private key to remain private, the private exponent must be kept secret.
    And because the private exponent is generated from the original primes, *p* and
    *q*, these two numbers must also be kept secret.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保证私钥的保密性，私有指数必须保持秘密。并且由于私有指数是由原始素数 *p* 和 *q* 生成的，这两个数字也必须保密。
- en: '![image](../Images/f07-11.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-11.jpg)'
- en: '*Figure 7-11: A simple example of RSA encryption and decryption*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-11：RSA 加密与解密的简单示例*'
- en: The first step in the encryption process is to convert the message to an integer,
    typically by assuming the bytes of the message actually represent a variable-length
    integer. This integer, *m*, is raised to the power of the public exponent. The
    modulo operation, using the value of the public modulus *n*, is then applied to
    the raised integer *m^e*. The resulting cipher text is now a value between zero
    and *n*. (So if you have a 1024-bit key, you can only ever encrypt a maximum of
    1024 bits in a message.) To decrypt the message, you apply the same process, substituting
    the public exponent for the private one.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 加密过程的第一步是将消息转换为一个整数，通常通过假设消息的字节实际上表示一个可变长度的整数来实现。这个整数 *m* 会被提升到公共指数的幂。然后，使用公共模数
    *n* 进行模运算，作用于提升后的整数 *m^e*。生成的密文是一个介于零和 *n* 之间的值。（因此，如果你有一个1024位的密钥，消息中最多只能加密1024位。）为了解密消息，你需要应用相同的过程，只需将公共指数替换为私有指数。
- en: 'RSA is very computationally expensive to perform, especially relative to symmetric
    ciphers like AES. To mitigate this expense, very few applications use RSA directly
    to encrypt a message. Instead, they generate a random *session key* and use this
    key to encrypt the message with a symmetric cipher, such as AES. Then, when the
    application wants to send a message to another participant on the network, it
    encrypts only the session key using RSA and sends the RSA-encrypted key along
    with the AES-encrypted message. The recipient decrypts the message first by decrypting
    the session key, and then uses the session key to decrypt the actual message.
    Combining RSA with a symmetric cipher like AES provides the best of both worlds:
    fast encryption with public key security.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 的计算开销非常大，尤其是与像 AES 这样的对称加密算法相比。为了减少这一开销，极少有应用直接使用 RSA 加密消息。相反，它们会生成一个随机的*会话密钥*，并用这个密钥通过对称加密算法（例如
    AES）加密消息。然后，当应用程序想要向网络上的另一方发送消息时，它只加密会话密钥，并通过 RSA 加密这个密钥，再将 RSA 加密的密钥和 AES 加密的消息一起发送。接收方首先通过解密会话密钥来解密消息，然后使用会话密钥解密实际的消息。将
    RSA 与像 AES 这样的对称加密算法结合使用，提供了两者的最佳优势：快速加密和公钥安全。
- en: '***RSA Padding***'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***RSA 填充***'
- en: 'One weakness of this basic RSA algorithm is that it is deterministic: if you
    encrypt the same message multiple times using the same public key, RSA will always
    produce the same encrypted result. This allows an attacker to mount what is known
    as a *chosen plaintext attack* in which the attacker has access to the public
    key and can therefore encrypt any message. In the most basic version of this attack,
    the attacker simply guesses the plaintext of an encrypted message. They continue
    encrypting their guesses using the public key, and if any of the encrypted guesses
    match the value of the original encrypted message, they know they’ve successfully
    guessed the target plaintext, meaning they’ve effectively decrypted the message
    without private key access.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基本 RSA 算法的一个弱点是它是确定性的：如果使用相同的公钥多次加密相同的消息，RSA 总是产生相同的加密结果。这使得攻击者可以发起所谓的*选择明文攻击*，在这种攻击中，攻击者可以访问公钥，因此可以加密任何消息。在这种攻击的最基本版本中，攻击者只需猜测加密消息的明文。他们继续使用公钥加密他们的猜测，如果任何一个加密后的猜测与原始加密消息的值匹配，他们就知道自己成功地猜中了目标明文，也就相当于在没有私钥访问权限的情况下解密了消息。
- en: 'To counter chosen plaintext attacks, RSA uses a form of padding during the
    encryption process that ensures the encrypted output is nondeterministic. (This
    “padding” is different from the block cipher padding discussed earlier. There,
    padding fills the plaintext to the next block boundary so the encryption algorithm
    has a full block to work with.) Two padding schemes are commonly used with RSA:
    one is specified in the Public Key Cryptography Standard #1.5; the other is called
    *Optimal Asymmetric Encryption Padding (OAEP)*. OAEP is recommended for all new
    applications, but both schemes provide enough security for typical use cases.
    Be aware that not using padding with RSA is a serious security vulnerability.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '为了防止选择明文攻击，RSA 在加密过程中使用一种填充方式，确保加密输出是不可预测的。（这种“填充”不同于之前讨论的分组密码填充。分组密码填充是为了填充明文至下一个分组边界，以便加密算法有一个完整的分组来处理。）RSA
    通常使用两种填充方案：一种是公钥密码学标准 #1.5 中规定的；另一种被称为*最优非对称加密填充（OAEP）*。OAEP 被推荐用于所有新的应用程序，但这两种方案都能为典型的使用案例提供足够的安全性。需要注意的是，不使用填充的
    RSA 是一个严重的安全漏洞。'
- en: '***Diffie–Hellman Key Exchange***'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Diffie–Hellman 密钥交换***'
- en: RSA isn’t the only technique used to exchange keys between network participants.
    Several algorithms are dedicated to that purpose; foremost among them is the *Diffie–Hellman
    Key Exchange (DH)* algorithm.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 并不是唯一用于网络参与者之间交换密钥的技术。还有几种算法专门用于此目的，其中最重要的就是*Diffie–Hellman 密钥交换（DH）*算法。
- en: The DH algorithm was developed by Whitfield Diffie and Martin Hellman in 1976
    and, like RSA, is built upon the mathematical primitives of exponentiation and
    modular arithmetic. DH allows two participants in a network to exchange keys and
    prevents anyone monitoring the network from being able to determine what that
    key is. [Figure 7-12](../Text/ch07.xhtml#ch7fig12) shows the operation of the
    algorithm.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: DH 算法由 Whitfield Diffie 和 Martin Hellman 于 1976 年开发，和 RSA 一样，它也建立在指数运算和模算术的数学原理之上。DH
    允许网络中的两个参与者交换密钥，并防止任何监控网络的人能够确定该密钥是什么。[图 7-12](../Text/ch07.xhtml#ch7fig12) 展示了该算法的操作。
- en: '![image](../Images/f07-12.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f07-12.jpg)'
- en: '*Figure 7-12: The Diffie–Hellman Key Exchange algorithm*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-12：Diffie–Hellman 密钥交换算法*'
- en: 'The participant initiating the exchange determines a parameter, which is a
    large prime number, and sends it to the other participant: the chosen value is
    not a secret and can be sent in the clear. Then each participant generates their
    own private key value—usually using a cryptographically secure random number generator—and
    computes a public key using this private key and a selected group parameter that
    is requested by the client. The public keys can safely be sent between the participants
    without the risk of revealing the private keys. Finally, each participant calculates
    a *shared* key by combining the other’s public key with their own private key.
    Both participants now have the shared key without ever having directly exchanged
    it.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 发起交换的参与者确定一个参数，这是一个大质数，并将其发送给另一个参与者：所选择的值不是秘密，可以明文传输。然后每个参与者生成自己的私钥值——通常使用加密安全的随机数生成器——并利用此私钥和客户端请求的选定群体参数计算公钥。公钥可以安全地在参与者之间传输，而不会泄露私钥。最后，每个参与者通过将对方的公钥与自己的私钥结合，计算出*共享*密钥。现在两个参与者都拥有共享密钥，且从未直接交换过密钥。
- en: DH isn’t perfect. For example, this basic version of the algorithm can’t handle
    an attacker performing a man-in-the-middle attack against the key-exchange. The
    attacker can impersonate the server on the network and exchange one key with the
    client. Next, the attacker exchanges a different key with the server, resulting
    in the attacker now having two separate keys for the connection. Then the attacker
    can decrypt data from the client and forward it on to the server, and vice versa.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: DH并不完美。例如，这种基本版本的算法无法应对攻击者对密钥交换实施中间人攻击。攻击者可以在网络上冒充服务器与客户端交换一个密钥。接下来，攻击者与服务器交换一个不同的密钥，导致攻击者现在拥有连接的两个独立密钥。然后，攻击者可以解密来自客户端的数据并转发给服务器，反之亦然。
- en: '**Signature Algorithms**'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**签名算法**'
- en: Encrypting a message prevents attackers from viewing the information being sent
    over the network, but it doesn’t identify *who* sent it. Just because someone
    has the encryption key doesn’t mean they are who they say they are. With asymmetric
    encryption, you don’t even need to manually exchange the key ahead of time, so
    anyone can encrypt data with your public key and send it to you.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 加密消息可以防止攻击者查看通过网络发送的信息，但它无法识别*发送者*是谁。仅仅因为某人拥有加密密钥，并不意味着他们就是他们所声称的人。通过非对称加密，你甚至不需要事先手动交换密钥，因此任何人都可以使用你的公钥加密数据并发送给你。
- en: '*Signature algorithms* solve this problem by generating a unique *signature*
    for a message. The message recipient can use the same algorithm used to generate
    the signature to prove the message came from the signer. As an added advantage,
    adding a signature to a message protects it against tampering if it’s being transmitted
    over an untrusted network. This is important, because encrypting data does not
    provide any guarantee of data *integrity*; that is, an encrypted message can still
    be modified by an attacker with knowledge of the underlying network protocol.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*签名算法*通过为消息生成唯一的*签名*来解决这个问题。消息接收方可以使用与生成签名时相同的算法来证明消息确实来自签名者。附加的好处是，给消息添加签名可以防止在不可信的网络上传输时被篡改。这一点非常重要，因为加密数据并不保证数据的*完整性*；也就是说，攻击者可以在了解底层网络协议的情况下修改加密消息。'
- en: All signature algorithms are built upon *cryptographic hashing algorithms*.
    First, I’ll describe hashing in more detail, and then I’ll explain some of the
    most common signature algorithms.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所有签名算法都建立在*加密哈希算法*之上。首先，我将更详细地描述哈希，然后解释一些最常见的签名算法。
- en: '***Cryptographic Hashing Algorithms***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加密哈希算法***'
- en: Cryptographic hashing algorithms are functions that are applied to a message
    to generate a fixed-length summary of that message, which is usually much shorter
    than the original message. These algorithms are also called *message digest algorithms*.
    The purpose of hashing in signature algorithms is to generate a relatively unique
    value to verify the integrity of a message and to reduce the amount of data that
    needs to be signed and verified.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 加密哈希算法是应用于消息的函数，用于生成该消息的固定长度摘要，通常比原始消息要短得多。这些算法也称为*消息摘要算法*。在签名算法中，哈希的目的是生成一个相对唯一的值，用以验证消息的完整性，并减少需要签名和验证的数据量。
- en: 'For a hashing algorithm to be suitable for cryptographic purposes, it has to
    fulfill three requirements:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要使哈希算法适合加密用途，它必须满足三个要求：
- en: '**Pre-image resistance** Given a hash value, it should be difficult (such as
    by requiring a massive amount of computing power) to recover a message.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**前像抗性** 给定一个哈希值，应该很难（例如需要大量计算能力）恢复出原始消息。'
- en: '**Collision resistance** It should be difficult to find two different messages
    that hash to the same value.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**碰撞抗性** 应该很难找到两个不同的消息，它们的哈希值相同。'
- en: '**Nonlinearity** It should be difficult to create a message that hashes to
    any given value.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**非线性** 应该很难创造出一个哈希值为任何给定值的消息。'
- en: A number of hashing algorithms are available, but the most common are members
    of either the *Message Digest (MD)* or *Secure Hashing Algorithm (SHA)* families.
    The Message Digest family includes the MD4 and MD5 algorithms, which were developed
    by Ron Rivest. The SHA family, which contains the SHA-1 and SHA-2 algorithms,
    among others, is published by NIST.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种哈希算法可用，但最常见的是*消息摘要（MD）*或*安全哈希算法（SHA）*系列的成员。消息摘要系列包括 MD4 和 MD5 算法，它们由 Ron
    Rivest 开发。SHA 系列包括 SHA-1 和 SHA-2 等算法，由美国国家标准与技术研究院（NIST）发布。
- en: Other simple hashing algorithms, such as checksums and cyclic redundancy checks
    (CRC), are useful for detecting changes in a set of data; however, they are not
    very useful for secure protocols. An attacker can easily change the checksum,
    as the linear behavior of these algorithms makes it trivial to determine how the
    checksum changes, and this modification of the data is protected so the target
    has no knowledge of the change.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 其他简单的哈希算法，如校验和和循环冗余校验（CRC），对于检测数据集的变化很有用；然而，它们对于安全协议并不是特别有用。攻击者可以轻松地更改校验和，因为这些算法的线性行为使得确定校验和的变化变得非常简单，而这种数据修改是受保护的，因此目标方无法知道更改内容。
- en: '***Asymmetric Signature Algorithms***'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***非对称签名算法***'
- en: Asymmetric signature algorithms use the properties of asymmetric cryptography
    to generate a message signature. Some algorithms, such as RSA, can be used to
    provide the signature and the encryption, whereas others, such as the *Digital
    Signature Algorithm (DSA),* are designed for signatures only. In both cases, the
    message to be signed is hashed, and a signature is generated from that hash.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称签名算法利用非对称密码学的属性来生成消息签名。一些算法，如 RSA，可以同时用于提供签名和加密，而另一些，如*数字签名算法（DSA）*，则专门用于签名。在这两种情况下，待签名的消息都会先经过哈希处理，然后从哈希值生成签名。
- en: Earlier you saw how RSA can be used for encryption, but how can it be used to
    sign a message? The RSA signature algorithm relies on the fact that it’s possible
    to encrypt a message using the *private* key and decrypt it with the *public*
    one. Although this “encryption” is no longer secure (the key to decrypt the message
    is now public), it can be used to sign a message.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 之前你看到 RSA 如何用于加密，那么它如何用于签名消息呢？RSA 签名算法依赖于这样一个事实：可以使用*私钥*加密消息，然后用*公钥*解密。尽管这种“加密”不再安全（解密消息的密钥现在是公开的），它仍然可以用于签名消息。
- en: For example, the signer hashes the message and applies the RSA decryption process
    to the hash using their private key; this encrypted hash is the signature. The
    recipient of the message can convert the signature using the signer’s public key
    to get the original hash value and compare it against their own hash of the message.
    If the two hashes match, the sender must have used the correct private key to
    encrypt the hash; if the recipient trusts that the only person with the private
    key is the signer, the signature is verified. [Figure 7-13](../Text/ch07.xhtml#ch7fig13)
    shows this process.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，签名者对消息进行哈希处理，并使用其私钥对哈希值进行 RSA 解密；这个加密后的哈希就是签名。消息接收方可以使用签名者的公钥解密签名，得到原始的哈希值，并与自己对消息进行哈希得到的值进行比较。如果两者哈希值相同，则表明发送者一定使用了正确的私钥加密该哈希值；如果接收者相信只有签名者拥有私钥，那么签名就被验证通过。[图
    7-13](../Text/ch07.xhtml#ch7fig13) 展示了这一过程。
- en: '![image](../Images/f07-13.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-13.jpg)'
- en: '*Figure 7-13: RSA signature processing*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-13：RSA 签名处理*'
- en: '***Message Authentication Codes***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***消息认证码***'
- en: Unlike RSA, which is an asymmetric algorithm, *Message Authentication Codes
    (MACs)* are *symmetric* signature algorithms. As with symmetric encryption, symmetric
    signature algorithms rely on sharing a key between the sender and recipient.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于 RSA 这种非对称算法，*消息认证码（MAC）*是*对称*签名算法。与对称加密一样，对称签名算法依赖于发送方和接收方之间共享密钥。
- en: 'For example, say you want to send me a signed message and we both have access
    to a shared key. First, you’d combine the message with the key in some way. (I’ll
    discuss how to do this in more detail in a moment.) Then you’d hash the combination
    to produce a value that couldn’t easily be reproduced without the original message
    and the shared key. When you sent me the message, you’d also send this hash as
    the signature. I could verify that the signature is valid by performing the same
    algorithm as you did: I’d combine the key and message, hash the combination, and
    compare the resulting value against the signature you sent. If the two values
    were the same, I could be sure you’re the one who sent the message.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想发送一条签名消息，我们都有一个共享密钥。首先，你将某种方式将消息与密钥结合起来。（稍后我会更详细地讨论如何做到这一点。）然后，你将组合后的结果进行哈希，生成一个没有原始消息和共享密钥就难以重现的值。当你发送消息时，你还会将这个哈希值作为签名发送给我。我可以通过执行与你相同的算法来验证签名是否有效：我会将密钥和消息结合起来，进行哈希，并将生成的值与你发送的签名进行比较。如果这两个值相同，我就可以确定是你发送了这条消息。
- en: How would you combine the key and the message? You might be tempted to try something
    simple, such as just prefixing the message with the key and hashing to the combined
    result, as in [Figure 7-14](../Text/ch07.xhtml#ch7fig14).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何将密钥与消息结合呢？你可能会试图做一些简单的操作，例如将密钥作为前缀添加到消息中，并将组合后的结果进行哈希，就像在[图 7-14](../Text/ch07.xhtml#ch7fig14)中所示。
- en: '![image](../Images/f07-14.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-14.jpg)'
- en: '*Figure 7-14: A simple MAC implementation*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-14：简单的 MAC 实现*'
- en: But with many common hashing algorithms (including MD5 and SHA-1), this would
    be a serious security mistake, because it opens a vulnerability known as the *length-extension
    attack*. To understand why, you need to know a bit about the construction of hashing
    algorithms.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于许多常见的哈希算法（包括 MD5 和 SHA-1），这将是一个严重的安全漏洞，因为它会打开一个已知的漏洞，称为 *长度扩展攻击*。要理解为什么如此，你需要了解一些哈希算法的构造原理。
- en: '**Length-Extension and Collision Attacks**'
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**长度扩展攻击与碰撞攻击**'
- en: Many common hashing algorithms, including MD5 and SHA-1, consist of a block
    structure. When hashing a message, the algorithm must first split the message
    into equal-sized blocks to process. (MD5, for example, uses a block size of 64
    bytes.)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 许多常见的哈希算法，包括 MD5 和 SHA-1，都采用块结构。当哈希消息时，算法必须首先将消息拆分成等大小的块进行处理。（例如，MD5 使用 64 字节的块大小。）
- en: As the hashing algorithm proceeds, the only state it maintains between each
    block is the hash value of the previous block. For the first block, the previous
    hash value is a set of well-chosen constants. The well-chosen constants are specified
    as part of the algorithm and are generally important for the secure operation.
    [Figure 7-15](../Text/ch07.xhtml#ch7fig15) shows an example of how this works
    in MD5.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在哈希算法的执行过程中，算法在每个块之间维护的唯一状态就是前一个块的哈希值。对于第一个块，前一个哈希值是一组精心选择的常数。这些精心选择的常数是算法的一部分，通常对安全操作至关重要。[图
    7-15](../Text/ch07.xhtml#ch7fig15) 显示了 MD5 中如何实现这一点的示例。
- en: '![image](../Images/f07-15.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-15.jpg)'
- en: '*Figure 7-15: The block structure of MD5*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-15：MD5 的块结构*'
- en: It’s important to note that the final output from the block-hashing process
    depends only on the previous block hash and the current block of the message.
    No permutation is applied to the final hash value. Therefore, it’s possible to
    extend the hash value by starting the algorithm at the last hash instead of the
    predefined constants and then running through blocks of data you want to add to
    the final hash.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，块哈希过程的最终输出仅取决于前一个块的哈希值和当前消息块。最终的哈希值并没有应用任何置换操作。因此，可以通过从最后一个哈希值开始算法，而不是从预定义的常数开始，然后处理你想要添加到最终哈希中的数据块，从而扩展哈希值。
- en: In the case of a MAC in which the key has been prefixed at the start of the
    message, this structure might allow an attacker to alter the message in some way,
    such as by appending extra data to the end of an uploaded file. If the attacker
    can append more blocks to the end of the message, they can calculate the corresponding
    value of the MAC without knowing the key because the key has already been hashed
    into the state of the algorithm by the time the attacker has control.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用密钥作为消息开始部分的 MAC 中，这种结构可能会让攻击者以某种方式篡改消息，例如通过在上传的文件末尾附加额外的数据。如果攻击者能够将更多的数据块附加到消息末尾，他们就可以在不知道密钥的情况下计算出相应的
    MAC 值，因为在攻击者控制之前，密钥已经被哈希到算法的状态中。
- en: What if you move the key to the end of the message rather than attaching it
    to the front? Such an approach certainly prevents the length-extension attack,
    but there’s still a problem. Instead of an extension, the attacker needs to find
    a hash collision—that is, a message with the same hash value as the real message
    being sent. Because many hashing algorithms (including MD5) are not collision
    resistant, the MAC may be open to this kind of collision attack. (One hashing
    algorithm that’s *not* vulnerable to this attack is SHA-3.)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将密钥移到消息的末尾，而不是将其附加到消息前面，结果会如何？这种方法确实可以防止长度扩展攻击，但仍然存在问题。攻击者需要找到一个哈希碰撞，即找到一个与真实发送的消息具有相同哈希值的消息。由于许多哈希算法（包括
    MD5）并不具备抗碰撞性，MAC 可能会受到这种碰撞攻击的威胁。（一种*不*易受此攻击的哈希算法是 SHA-3。）
- en: '**Hashed Message Authentication Codes**'
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**散列消息认证码**'
- en: You can use a *Hashed Message Authentication Code (HMAC)* to counter the attacks
    described in the previous section. Instead of directly appending the key to the
    message and using the hashed output to produce a signature, an HMAC splits the
    process into two parts.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*散列消息认证码（HMAC）*来应对上一节中描述的攻击。HMAC 并不是直接将密钥附加到消息上，并使用哈希输出生成签名，而是将过程分为两个部分。
- en: First, the key is XORed with a padding block equal to the block size of the
    hashing algorithm. This first padding block is filled with a repeating value,
    typically the byte 0x36\. The combined result is the first key, sometimes called
    the *inner padding block*. This is prefixed to the message, and the hashing algorithm
    is applied. The second step takes the hash value from the first step, prefixes
    the hash with a new key (called the *outer padding block*, which typically uses
    the constant 0x5C), and applies the hash algorithm again. The result is the final
    HMAC value. [Figure 7-16](../Text/ch07.xhtml#ch7fig16) diagrams this process.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将密钥与一个填充块进行异或操作，填充块的大小等于哈希算法的块大小。这个填充块填充有一个重复的值，通常是字节 0x36。组合的结果是第一个密钥，有时称为*内部填充块*。将其添加到消息前面，然后应用哈希算法。第二步将第一步得到的哈希值与一个新的密钥进行拼接（这个新的密钥称为*外部填充块*，通常使用常量
    0x5C），并再次应用哈希算法。最终结果就是最终的 HMAC 值。[图 7-16](../Text/ch07.xhtml#ch7fig16) 展示了这个过程。
- en: '![image](../Images/f07-16.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-16.jpg)'
- en: '*Figure 7-16: HMAC construction*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-16：HMAC 构造*'
- en: This construction is resistant to length-extension and collision attacks because
    the attacker can’t easily predict the final hash value without the key.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构造能抵抗长度扩展攻击和碰撞攻击，因为攻击者在没有密钥的情况下很难预测最终的哈希值。
- en: '**Public Key Infrastructure**'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**公钥基础设施**'
- en: How do you verify the identity of the owner of a public key in public key encryption?
    Simply because a key is published with an associated identity—say, Bob Smith from
    London—doesn’t mean it really comes from Bob Smith from London. For example, if
    I’ve managed to make you trust my public key as coming from Bob, anything you
    encrypt to him will be readable only by me, because I own the private key.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如何验证公钥加密中公钥所有者的身份？仅仅因为一个密钥与一个相关的身份（例如，伦敦的 Bob Smith）一起发布，并不意味着它真的是来自伦敦的 Bob
    Smith。例如，如果我成功地让你相信我的公钥是来自 Bob，那么你加密给他的任何信息将只有我能读取，因为我拥有私钥。
- en: To mitigate this threat, you implement a *Public Key Infrastructure (PKI)*,
    which refers to the combined set of protocols, encryption key formats, user roles,
    and policies used to manage asymmetric public key information across a network.
    One model of PKI, the *web of trust (WOT)*, is used by such applications as *Pretty
    Good Privacy (PGP)*. In the WOT model, the identity of a public key is attested
    to by someone you trust, perhaps someone you’ve met in person. Unfortunately,
    although the WOT works well for email, where you’re likely to know who you’re
    communicating with, it doesn’t work as well for automated network applications
    and business processes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这种威胁，你可以实现*公钥基础设施（PKI）*，它指的是用于在网络中管理非对称公钥信息的一套协议、加密密钥格式、用户角色和政策的集合。PKI 的一种模型——*信任网（WOT）*，被像
    *Pretty Good Privacy (PGP)* 这样的应用程序使用。在 WOT 模型中，公钥的身份由你信任的人证明，可能是你亲自见过的人。不幸的是，尽管
    WOT 在电子邮件中效果很好（你可能知道你正在与谁通信），但对于自动化网络应用和商业流程，它的效果就不那么理想了。
- en: '***X.509 Certificates***'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***X.509 证书***'
- en: When a WOT won’t do, it’s common to use a more centralized trust model, such
    as X.509 certificates, which generate a strict hierarchy of trust rather than
    rely on directly trusting peers. X.509 certificates are used to verify web servers,
    sign executable programs, or authenticate to a network service. Trust is provided
    through a hierarchy of certificates using asymmetric signature algorithms, such
    as RSA and DSA.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当 WOT（Web of Trust）无法使用时，通常会采用更为集中化的信任模型，比如 X.509 证书，它通过生成严格的信任层级来取代直接信任对等方。X.509
    证书用于验证 Web 服务器、签名可执行程序或对网络服务进行身份验证。信任是通过使用非对称签名算法（如 RSA 和 DSA）建立的证书层级提供的。
- en: 'To complete this hierarchy, valid certificates must contain at least four pieces
    of information:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个层级，有效的证书必须至少包含四个信息：
- en: • The *subject*, which specifies the identity for the certificate
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: • *主题*，指定证书的身份
- en: • The subject’s public key
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: • 主题的公钥
- en: • The *issuer*, which identifies the signing certificate
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: • *颁发者*，用于标识签名证书
- en: • A valid signature applied over the certificate and authenticated by the issuer’s
    private key
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: • 证书上应用的有效签名，并由颁发者的私钥进行认证
- en: These requirements create a hierarchy called a *chain of trust* between certificates,
    as shown in [Figure 7-17](../Text/ch07.xhtml#ch7fig17). One advantage to this
    model is that because only public key information is ever distributed, it’s possible
    to provide component certificates to users via public networks.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求创建了一个称为*信任链*的证书层级，如[图 7-17](../Text/ch07.xhtml#ch7fig17)所示。这种模型的一个优点是，因为只分发公钥信息，所以可以通过公共网络将组件证书提供给用户。
- en: '![image](../Images/f07-17.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-17.jpg)'
- en: '*Figure 7-17: The X.509 certificate chain of trust*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-17：X.509 证书信任链*'
- en: Note that there is usually more than one level in the hierarchy, because it
    would be unusual for the root certificate issuer to directly sign certificates
    used by an application. The root certificate is issued by an entity called a *certificate
    authority (CA)*, which might be a public organization or company (such as Verisign)
    or a private entity that issues certificates for use on internal networks. The
    CA’s job is to verify the identity of anyone it issues certificates to.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，层级中通常有不止一个级别，因为根证书颁发者直接签发应用程序使用的证书是不常见的。根证书由一个称为*证书颁发机构（CA）*的实体颁发，这个机构可能是一个公共组织或公司（如
    Verisign），也可能是一个私人实体，为内部网络上的使用颁发证书。CA 的职责是验证它为谁颁发证书。
- en: Unfortunately, the amount of *actual* checking that occurs is not always clear;
    often, CAs are more interested in selling signed certificates than in doing their
    jobs, and some CAs do little more than check whether they’re issuing a certificate
    to a registered business address. Most diligent CAs should at least refuse to
    generate certificates for known companies, such as Microsoft or Google, when the
    certificate request doesn’t come from the company in question. By definition,
    the root certificate can’t be signed by another certificate. Instead, the root
    certificate is a *self-signed certificate* where the private key associated with
    the certificate’s public key is used to sign itself.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，实际执行的*检查*数量并不总是很清楚；通常，证书授权中心（CA）更关心的是销售签名证书，而不是履行他们的职责，一些 CA 做的事情无非就是检查它们是否正在向一个已注册的商业地址颁发证书。大多数尽职的
    CA 至少会拒绝为已知公司（如微软或谷歌）生成证书，特别是当证书请求并非来自这些公司时。根据定义，根证书不能被另一个证书签名。相反，根证书是一个*自签名证书*，它使用与证书公钥相关联的私钥来签名自己。
- en: '***Verifying a Certificate Chain***'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***验证证书链***'
- en: To verify a certificate, you follow the issuance chain back to the root certificate,
    ensuring at each step that every certificate has a valid signature that hasn’t
    expired. At this point, you decide whether you trust the root certificate—and,
    by extension, the identity of the certificate at the end of the chain. Most applications
    that handle certificates, like web browsers and operating systems, have a trusted
    root certificate database.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证证书，你需要追溯到根证书的颁发链，确保在每一步中每个证书都有有效且未过期的签名。此时，你决定是否信任根证书——从而信任证书链末尾的身份。大多数处理证书的应用程序，如
    Web 浏览器和操作系统，都有一个受信任的根证书数据库。
- en: What’s to stop someone who gets a web server certificate from signing their
    own fraudulent certificate using the web server’s private key? In practice, they
    can do just that. From a cryptography perspective, one private key is the same
    as any other. If you based the trust of a certificate on the chain of keys, the
    fraudulent certificate would chain back to a trusted root and appear to be valid.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么可以阻止获得 web 服务器证书的人，使用该 web 服务器的私钥签署他们自己的伪造证书吗？实际上，他们完全可以这样做。从加密学的角度来看，一个私钥与任何其他私钥是相同的。如果你将证书的信任建立在密钥链上，伪造的证书就会链回一个可信的根证书，看起来是有效的。
- en: To protect against this attack, the X.509 specification defines the *basic constraints*
    parameter, which can be optionally added to a certificate. This parameter is a
    flag that indicates the certificate can be used to sign another certificate and
    thus act as a CA. If a certificate’s CA flag is set to false (or if the basic
    constraints parameter is missing), the verification of the chain should fail if
    that certificate is ever used to sign another certificate. [Figure 7-18](../Text/ch07.xhtml#ch7fig18)
    shows this basic constraint parameter in a real certificate that says this certificate
    should be valid to act as a certificate authority.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防范这种攻击，X.509 规范定义了 *基本约束* 参数，可以选择性地添加到证书中。该参数是一个标志，指示该证书可以用于签署另一个证书，从而充当证书授权中心（CA）。如果证书的
    CA 标志被设置为 false（或者基本约束参数缺失），如果该证书被用于签署另一个证书，验证链应该失败。[图 7-18](../Text/ch07.xhtml#ch7fig18)
    展示了一个真实证书中的基本约束参数，表明该证书应有效地充当证书授权中心。
- en: But what if a certificate issued for verifying a web server is used instead
    to sign application code? In this situation, the X.509 certificate can specify
    a *key usage* parameter, which indicates what uses the certificate was generated
    for. If the certificate is ever used for something it was not designed to certify,
    the verification chain should fail.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果用于验证 web 服务器的证书被用来签署应用程序代码怎么办？在这种情况下，X.509 证书可以指定一个 *密钥使用* 参数，表示证书是为哪些用途生成的。如果证书被用于它原本不被设计来认证的用途，验证链应该失败。
- en: Finally, what happens if the private key associated with a given certificate
    is stolen or a CA accidentally issues a fraudulent certificate (as has happened
    a few times)? Even though each certificate has an expiration date, this date might
    be many years in the future. Therefore, if a certificate needs to be revoked,
    the CA can publish a *certificate revocation list (CRL)*. If any certificate in
    the chain is on the revocation list, the verification process should fail.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果与某个证书关联的私钥被盗，或者证书授权中心（CA）错误地颁发了伪造的证书（这种情况已经发生过几次）会怎样呢？即使每个证书都有到期日期，这个日期可能是在未来很多年。因此，如果需要撤销证书，CA
    可以发布一个 *证书撤销列表（CRL）*。如果链中的任何证书在撤销列表上，验证过程应该失败。
- en: '![image](../Images/f07-18.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-18.jpg)'
- en: '*Figure 7-18: X.509 certificate basic constraints*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-18：X.509 证书基本约束*'
- en: As you can see, the certificate chain verification could potentially fail in
    a number of places.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，证书链验证可能会在多个地方失败。
- en: '**Case Study: Transport Layer Security**'
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**案例研究：传输层安全性**'
- en: 'Let’s apply some of the theory behind protocol security and cryptography to
    a real-world protocol. *Transport Layer Security (TLS)*, formerly called *Secure
    Sockets Layer (SSL)*, is the most common security protocol in use on the internet.
    TLS was originally developed as SSL by Netscape in the mid-1990s for securing
    HTTP connections. The protocol has gone through multiple revisions: SSL versions
    1.0 through 3.0 and TLS versions 1.0 through 1.2\. Although it was originally
    designed for HTTP, you can use TLS for any TCP protocol. There’s even a variant,
    the *Datagram Transport Layer Security (DTLS)* protocol, to use with unreliable
    protocols, such as UDP.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一些协议安全和加密学的理论应用到一个现实世界的协议中。*传输层安全性（TLS）*，前身为 *安全套接字层（SSL）*，是目前互联网上最常用的安全协议。TLS
    最初是由 Netscape 在 1990 年代中期为保障 HTTP 连接的安全性而开发的 SSL 协议。该协议经历了多次修订：SSL 版本 1.0 到 3.0
    以及 TLS 版本 1.0 到 1.2。虽然它最初是为 HTTP 设计的，但你可以将 TLS 应用于任何 TCP 协议。甚至还有一个变体，*数据报传输层安全性（DTLS）*
    协议，用于与不可靠协议（如 UDP）一起使用。
- en: TLS uses many of the constructs described in this chapter, including symmetric
    and asymmetric encryption, MACs, secure key exchange, and PKI. I’ll discuss the
    role each of these cryptographic tools plays in the security of a TLS connection
    and touch on some attacks against the protocol. (I’ll only discuss TLS version
    1.0, because it’s the most commonly supported version, but be aware that versions
    1.1 and 1.2 are slowly becoming more common due to a number of security issues
    with version 1.0.)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 使用本章中描述的许多构造，包括对称和非对称加密、MAC、密钥交换和 PKI。我将讨论这些加密工具在 TLS 连接安全性中的作用，并简要介绍一些针对该协议的攻击。（我将只讨论
    TLS 1.0 版本，因为这是最常见的支持版本，但请注意，由于 1.0 版本存在一些安全问题，1.1 和 1.2 版本正在慢慢变得更为普及。）
- en: '***The TLS Handshake***'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***TLS 握手***'
- en: The most important part of establishing a new TLS connection is the *handshake*,
    where the client and server negotiate the type of encryption they’ll use, exchange
    a unique key for the connection, and verify each other’s identity. All communication
    uses a *TLS Record* protocol—a predefined tag-length-value structure that allows
    the protocol parser to extract individual records from the stream of bytes. All
    handshake packets are assigned a tag value of 22 to distinguish them from other
    packets. [Figure 7-19](../Text/ch07.xhtml#ch7fig19) shows the flow of these handshake
    packets in a simplified form. (Some packets are optional, as indicated in the
    figure.)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 建立新 TLS 连接最重要的部分是 *握手*，在握手过程中，客户端和服务器协商将使用的加密类型，交换唯一的连接密钥，并验证彼此的身份。所有通信都使用 *TLS
    Record* 协议——一种预定义的标签长度值结构，允许协议解析器从字节流中提取单个记录。所有握手数据包都分配一个标签值为 22，用以将其与其他数据包区分开来。[图
    7-19](../Text/ch07.xhtml#ch7fig19) 显示了这些握手数据包的简化流程。（如图所示，一些数据包是可选的。）
- en: 'As you can see from all the data being sent back and forth, the handshake process
    can be time-intensive: sometimes it can be truncated or bypassed entirely by caching
    a previously negotiated session key or by the client’s asking the server to resume
    a previous session by providing a unique session identifier. This isn’t a security
    issue because, although a malicious client could request the resumption of a session,
    the client still won’t know the private negotiated session key.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，所有数据来回传输，握手过程可能非常耗时：有时可以通过缓存先前协商的会话密钥或客户端通过提供唯一的会话标识符请求服务器恢复先前会话，从而省略或完全绕过握手过程。这并不是一个安全问题，因为尽管恶意客户端可能请求恢复会话，但客户端仍然不知道私密的协商会话密钥。
- en: '![image](../Images/f07-19.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-19.jpg)'
- en: '*Figure 7-19: The TLS handshake process*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-19：TLS 握手过程*'
- en: '***Initial Negotiation***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***初始协商***'
- en: As the first step in the handshake, the client and server negotiate the security
    parameters they want to use for the TLS connection using a *HELLO message*. One
    of the pieces of information in a HELLO message is the *client random*, a random
    value that ensures the connection process cannot be easily replayed. The HELLO
    message also indicates what types of ciphers the client supports. Although TLS
    is designed to be flexible with regard to what encryption algorithms it uses,
    it only supports symmetric ciphers, such as RC4 or AES, because using public key
    encryption would be too expensive from a computational perspective.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在握手的第一步中，客户端和服务器通过 *HELLO 消息* 协商他们想要用于 TLS 连接的安全参数。HELLO 消息中的一项信息是 *客户端随机数*，这是一种随机值，确保连接过程无法轻易被重放。HELLO
    消息还指示客户端支持的加密算法类型。尽管 TLS 设计上具有灵活性，能够使用多种加密算法，但它仅支持对称加密算法，如 RC4 或 AES，因为使用公钥加密在计算上成本过高。
- en: The server responds with its own HELLO message that indicates what cipher it
    has chosen from the available list provided by the client. (The connection ends
    if the pair cannot negotiate a common cipher.) The server HELLO message also contains
    the *server random*, another random value that adds additional replay protection
    to the connection. Next, the server sends its X.509 certificate, as well as any
    necessary intermediate CA certificates, so the client can make an informed decision
    about the identity of the server. Then the server sends a *HELLO Done* packet
    to inform the client it can proceed to authenticate the connection.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应它自己的HELLO消息，指示它从客户端提供的可用列表中选择了哪个密码套件。（如果双方无法协商出共同的密码套件，连接将结束。）服务器的HELLO消息还包含*服务器随机数*，这是另一个随机值，为连接提供额外的重放保护。接下来，服务器发送其X.509证书，以及任何必要的中间CA证书，以便客户端可以做出关于服务器身份的知情决定。然后，服务器发送*HELLO完成*数据包，通知客户端它可以继续进行连接验证。
- en: '***Endpoint Authentication***'
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***端点认证***'
- en: The client must verify that the server certificates are legitimate and that
    they meet the client’s own security requirements. First, the client must verify
    the identity in the certificate by matching the certificate’s *Subject* field
    to the server’s domain name. For example, [Figure 7-20](../Text/ch07.xhtml#ch7fig20)
    shows a certificate for the domain *[www.domain.com](http://www.domain.com)*.
    The Subject contains a *Common Name (CN)* ➊ field that matches this domain.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端必须验证服务器证书的合法性，并确保它们符合客户端自己的安全要求。首先，客户端必须通过将证书的*主题*字段与服务器的域名进行匹配来验证证书中的身份。例如，[图7-20](../Text/ch07.xhtml#ch7fig20)显示了一个用于
    *[www.domain.com](http://www.domain.com)* 的证书。该主题包含一个*通用名称（CN）* ➊字段，该字段与此域名匹配。
- en: '![image](../Images/f07-20.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-20.jpg)'
- en: '*Figure 7-20: The Certificate Subject for* [www.domain.com](http://www.domain.com)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-20：* [www.domain.com](http://www.domain.com) 的证书主题'
- en: A certificate’s Subject and Issuer fields are not simple strings but *X.500
    names*, which contain other fields, such as the *Organization* (typically the
    name of the company that owns the certificate) and *Email* (an arbitrary email
    address). However, only the CN is ever checked during the handshake to verify
    an identity, so don’t be confused by the extra data. It’s also possible to have
    wildcards in the CN field, which is useful for sharing certificates with multiple
    servers running on a subdomain name. For example, a CN set to **.domain.com* would
    match both *[www.domain.com](http://www.domain.com)* and *blog.domain.com*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 证书的主题和颁发者字段不是简单的字符串，而是*X.500名称*，包含其他字段，例如*组织*（通常是拥有证书的公司名称）和*电子邮件*（一个任意的电子邮件地址）。然而，在握手过程中只有CN字段会被检查来验证身份，因此不要被额外的数据所迷惑。CN字段中也可能包含通配符，这对于共享证书给多个运行在子域名上的服务器非常有用。例如，CN设置为**.domain.com**
    将同时匹配 *[www.domain.com](http://www.domain.com)* 和 *blog.domain.com*。
- en: After the client has checked the identity of the endpoint (that is, the server
    at the other end of the connection), it must ensure that the certificate is trusted.
    It does so by building the chain of trust for the certificate and any intermediate
    CA certificates, checking to make sure none of the certificates appear on any
    certificate revocation lists. If the root of the chain is not trusted by the client,
    it can assume the certificate is suspect and drop the connection to the server.
    [Figure 7-21](../Text/ch07.xhtml#ch7fig21) shows a simple chain with an intermediate
    CA for *[www.domain.com](http://www.domain.com)*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端检查了端点的身份（即连接另一端的服务器）后，必须确保证书是受信任的。它通过构建证书的信任链以及任何中间CA证书来做到这一点，并检查确保这些证书没有出现在任何证书撤销列表中。如果信任链的根证书不被客户端信任，客户端可以假设证书是可疑的，并断开与服务器的连接。[图7-21](../Text/ch07.xhtml#ch7fig21)显示了一个简单的信任链，其中包含一个用于
    *[www.domain.com](http://www.domain.com)* 的中间CA。
- en: '![image](../Images/f07-21.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-21.jpg)'
- en: '*Figure 7-21: The chain of trust for* [www.domain.com](http://www.domain.com)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-21：* [www.domain.com](http://www.domain.com) 的信任链'
- en: TLS also supports an optional *client certificate* that allows the server to
    authenticate the client. If the server requests a client certificate, it sends
    a list of acceptable root certificates to the client during its HELLO phase. The
    client can then search its available certificates and choose the most appropriate
    one to send back to the server. It sends the certificate—along with a verification
    message containing a hash of all the handshake messages sent and received up to
    this point—signed with the certificate’s private key. The server can verify that
    the signature matches the key in the certificate and grant the client access;
    however, if the match fails, the server can close the connection. The signature
    proves to the server that the client possesses the private key associated with
    the certificate.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 还支持一个可选的*客户端证书*，它允许服务器对客户端进行身份验证。如果服务器请求客户端证书，它会在 HELLO 阶段向客户端发送一份可接受根证书的列表。客户端随后可以搜索其可用的证书，并选择最合适的证书返回给服务器。客户端会将证书与包含所有已发送和接收的握手消息哈希值的验证信息一并发送，并使用证书的私钥对其进行签名。服务器可以验证签名是否与证书中的密钥匹配，并授予客户端访问权限；但是，如果匹配失败，服务器可以关闭连接。签名向服务器证明客户端拥有与证书相关联的私钥。
- en: '***Establishing Encryption***'
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***建立加密连接***'
- en: When the endpoint has been authenticated, the client and server can finally
    establish an encrypted connection. To do so, the client sends a randomly generated
    *pre-master secret* to the server encrypted with the server’s certificate public
    key. Next, both client and server combine the pre-master secret with the client
    and server randoms, and they use this combined value to seed a random number generator
    that generates a 48-byte *master secret*, which will be the session key for the
    encrypted connection. (The fact that both the server and the client generate the
    master key provides replay protection for the connection, because if either endpoint
    sends a different random during negotiation, the endpoints will generate different
    master secrets.)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当端点已被认证后，客户端和服务器最终可以建立加密连接。为此，客户端会发送一个随机生成的*预主密钥*，并用服务器证书的公钥加密发送给服务器。接下来，客户端和服务器将预主密钥与客户端和服务器的随机值结合，并使用这个组合值为随机数生成器提供种子，从而生成一个
    48 字节的*主密钥*，该主密钥将作为加密连接的会话密钥。（服务器和客户端都生成主密钥这一事实为连接提供了重放保护，因为如果任一端在协商过程中发送了不同的随机数，双方将生成不同的主密钥。）
- en: 'When both endpoints have the master secret, or session key, an encrypted connection
    is possible. The client issues a *change cipher spec* packet to tell the server
    it will only send encrypted messages from here on. However, the client needs to
    send one final message to the server before normal traffic can be transmitted:
    the *finished* packet. This packet is encrypted with the session key and contains
    a hash of all the handshake messages sent and received during the handshake process.
    This is a crucial step in protecting against a *downgrade attack*, in which an
    attacker modifies the handshake process to try to reduce the security of the connection
    by selecting weak encryption algorithms. Once the server receives the finished
    message, it can validate that the negotiated session key is correct (otherwise,
    the packet wouldn’t decrypt) and check that the hash is correct. If not, it can
    close the connection. But if all is correct, the server will send its own change
    cipher spec message to the client, and encrypted communications can begin.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当双方都拥有主密钥或会话密钥时，就可以建立加密连接。客户端会发送一个*更改密码规范*数据包，告诉服务器从此只发送加密消息。然而，客户端在正常流量传输之前还需要向服务器发送最后一条消息：*完成*数据包。该数据包使用会话密钥加密，并包含所有在握手过程中发送和接收的握手消息的哈希值。这是防止*降级攻击*的关键步骤，在降级攻击中，攻击者会修改握手过程，试图通过选择弱加密算法来降低连接的安全性。一旦服务器接收到完成消息，它可以验证协商的会话密钥是否正确（否则该数据包无法解密），并检查哈希值是否正确。如果不正确，服务器可以关闭连接。但如果一切正确，服务器将向客户端发送自己的更改密码规范消息，之后加密通信即可开始。
- en: Each encrypted packet is also verified using an HMAC, which provides data authentication
    and ensures data integrity. This verification is particularly important if a stream
    cipher, such as RC4, has been negotiated; otherwise, the encrypted blocks could
    be trivially modified.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 每个加密的数据包还会使用 HMAC 进行验证，这提供了数据认证并确保数据完整性。如果协商使用了流密码（例如 RC4），则此验证尤为重要；否则，加密数据块可能会被轻易篡改。
- en: '***Meeting Security Requirements***'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***满足安全要求***'
- en: The TLS protocol successfully meets the four security requirements listed at
    the beginning of this chapter and summarized in [Table 7-4](../Text/ch07.xhtml#ch7tab4).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: TLS协议成功地满足了本章开头列出的四项安全要求，具体总结在[表 7-4](../Text/ch07.xhtml#ch7tab4)中。
- en: '**Table 7-4:** How TLS Meets Security Requirements'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-4：** TLS如何满足安全要求'
- en: '| **Security requirement** | **How it’s met** |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **安全要求** | **如何满足** |'
- en: '| --- | --- |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Data confidentiality | Selectable strong cipher suites Secure key exchange
    |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 数据机密性 | 可选择的强加密套件 安全的密钥交换 |'
- en: '| Data integrity | Encrypted data is protected by an HMAC Handshake packets
    are verified by final hash verification |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 数据完整性 | 加密数据通过HMAC保护，握手数据包通过最终哈希验证 |'
- en: '| Server authentication | The client can choose to verify the server endpoint
    using the PKI and the issued certificate |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 服务器认证 | 客户端可以选择使用公钥基础设施（PKI）和颁发的证书验证服务器端点 |'
- en: '| Client authentication | Optional certificate-based client authentication
    |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 客户端认证 | 可选的基于证书的客户端认证 |'
- en: But there are problems with TLS. The most significant one, which as of this
    writing has not been corrected in the latest versions of the protocol, is its
    reliance on certificate-based PKI. The protocol depends entirely on trust that
    certificates are issued to the correct people and organizations. If the certificate
    for a network connection indicates the application is communicating to a Google
    server, you assume that only Google would be able to purchase the required certificate.
    Unfortunately, this isn’t always the case. Situations in which corporations and
    governments have subverted the CA process to generate certificates have been documented.
    In addition, mistakes have been made when CAs didn’t perform their due diligence
    and issued bad certificates, such as the Google certificate shown in [Figure 7-22](../Text/ch07.xhtml#ch7fig22)
    that eventually had to be revoked.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 但TLS协议仍然存在问题。最重要的问题是，截至本文撰写时，最新版本的协议尚未解决的问题：它依赖于基于证书的公钥基础设施（PKI）。该协议完全依赖于证书是颁发给正确的人和组织的信任。如果某个网络连接的证书表明该应用程序正在与Google服务器通信，你会假设只有Google能够购买所需的证书。不幸的是，这并非总是如此。有文件记录了企业和政府通过篡改CA过程生成证书的情况。此外，当CA没有尽到应有的尽职调查而颁发了错误证书时，也发生过错误，例如[图
    7-22](../Text/ch07.xhtml#ch7fig22)中显示的Google证书，最终被撤销。
- en: '![image](../Images/f07-22.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f07-22.jpg)'
- en: '*Figure 7-22: A certificate for Google “wrongly” issued by CA TÜRKTRUST*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-22：由CA TÜRKTRUST“错误”颁发的Google证书*'
- en: One partial fix to the certificate model is a process called *certificate pinning*.
    Pinning means that an application restricts acceptable certificates and CA issuers
    for certain domains. As a result, if someone manages to fraudulently obtain a
    valid certificate for *[www.google.com](http://www.google.com)*, the application
    will notice that the certificate doesn’t meet the CA restrictions and will fail
    the connection.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 解决证书模型部分问题的一种方法是一个叫做*证书固定*的过程。固定意味着应用程序限制某些域名可接受的证书和证书颁发机构（CA）。因此，如果有人设法欺诈性地获得了一个有效的证书用于*[www.google.com](http://www.google.com)*，应用程序将会发现该证书不符合CA的限制，并会导致连接失败。
- en: Of course, certificate pinning has its downsides and so is not applicable to
    every scenario. The most prevalent issue is the management of the pinning list;
    specifically, building an initial list might not be too challenging a task, but
    updating the list adds additional burdens. Another issue is that a developer cannot
    easily migrate the certificates to another CA or easily change certificates without
    also having to issue updates to all clients.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，证书固定（certificate pinning）也有其缺点，因此并不适用于所有场景。最常见的问题是固定列表的管理；具体来说，构建初始列表可能并不太具挑战性，但更新列表会增加额外的负担。另一个问题是，开发者无法轻松地将证书迁移到另一个证书颁发机构（CA），或在不同时更新所有客户端的情况下更换证书。
- en: Another problem with TLS, at least when it comes to network surveillance, is
    that a TLS connection can be captured from the network and stored by an attacker
    until it’s needed. If that attacker ever obtains the server’s private key, all
    historical traffic could be decrypted. For this reason, a number of network applications
    are moving toward exchanging keys using the DH algorithm in addition to using
    certificates for identity verification. This allows for *perfect forward secrecy*—even
    if the private key is compromised, it shouldn’t be easy to also calculate the
    DH-generated key.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 的另一个问题，至少在网络监控方面，是 TLS 连接可以从网络中捕获并由攻击者存储，直到需要时再使用。如果攻击者获得了服务器的私钥，那么所有历史流量都可能被解密。因此，许多网络应用程序正在转向使用
    DH 算法交换密钥，并且除了使用证书进行身份验证之外。这种做法可以实现*完美前向保密*——即使私钥被泄露，也不容易计算出由 DH 生成的密钥。
- en: '**Final Words**'
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter focused on the basics of protocol security. Protocol security has
    many aspects and is a very complex topic. Therefore, it’s important to understand
    what could go wrong and identify the problem during any protocol analysis.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要关注协议安全的基础知识。协议安全涉及许多方面，是一个非常复杂的主题。因此，了解可能出现的问题并在进行协议分析时识别这些问题是非常重要的。
- en: Encryption and signatures make it difficult for an attacker to capture sensitive
    information being transmitted over a network. The process of encryption converts
    plaintext (the data you want to hide) into cipher text (the encrypted data). Signatures
    are used to verify that the data being transmitted across a network hasn’t been
    compromised. An appropriate signature can also be used to verify the identity
    of the sender. The ability to verify the sender is very useful for authenticating
    users and computers over an untrusted network.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 加密和签名使得攻击者难以捕获在网络上传输的敏感信息。加密过程将明文（你想隐藏的数据）转换为密文（加密后的数据）。签名用于验证通过网络传输的数据是否已经被篡改。适当的签名也可以用来验证发送者的身份。验证发送者的能力对于在不可信的网络上验证用户和计算机身份非常有用。
- en: Also described in this chapter are some possible attacks against cryptography
    as used in protocol security, including the well-known padding oracle attack,
    which could allow an attack to decrypt traffic being sent to and from a server.
    In later chapters, I’ll explain in more detail how to analyze a protocol for its
    security configuration, including the encryption algorithms used to protect sensitive
    data.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还描述了一些针对协议安全中使用的加密技术的可能攻击，包括著名的填充 oracle 攻击，该攻击可能允许攻击者解密发送到服务器的流量以及从服务器发送回来的流量。在后续章节中，我将更详细地解释如何分析协议的安全配置，包括用于保护敏感数据的加密算法。
