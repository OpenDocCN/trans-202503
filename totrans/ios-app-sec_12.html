<html><head></head><body>
<h2 class="h2" id="ch09"><a id="page_147"/><strong><span class="big">9</span></strong><br/><strong>IOS-TARGETED WEB APPS</strong></h2>
<p class="noindent">Since the introduction of third-party developer APIs for iOS, the Web has been an important component of iOS applications. Originally, the APIs were entirely web-based. While this potentially made life easier for people with no Objective-C or Cocoa experience, it severely limited what non-Apple applications could do and relegated them to a second-class status. They had no access to native capabilities of the phone, such as geolocation, and were available only within the browser instead of on the home screen.</p>
<p class="indent">While things have changed drastically since that time, the need to integrate with web applications from iOS has not. In this chapter, you’ll take a closer look at the connections between native iOS applications and web applications: how web applications are interacted with, what native iOS APIs can be exposed to web apps, and the risks of various approaches.</p>
<h3 class="h3" id="ch09lev1sec01"><strong>Using (and Abusing) UIWebViews</strong></h3>
<p class="noindent">Developers use web views to render and interact with web content in iOS applications because they are simple to implement and provide browser-like functionality. Most web views are instances of the <code>UIWebView</code> class, which uses <a id="page_148"/>the WebKit rendering engine<sup><a href="footnote.html#fn77" id="fn_77">1</a></sup> to display web content. Web views are often used either to abstract portions of the application so they can be shared between different mobile app platforms or simply to offload more logic to the web application, often because of more in-house expertise in web application programming than iOS. They’re also frequently used as a way to view links to third-party web content without having to leave the application and spawn Safari. For example, when you click an article in a Facebook feed, the content is rendered in the Facebook app.</p>
<p class="indent">Starting with iOS 8, the <code>WKWebView</code> framework was introduced. This framework gives developers some additional flexibility as well as access to Apple’s high-performance Nitro JavaScript engine, which increases the performance of apps that use web views significantly. Since you’ll be seeing <code>UIWebView</code> for some time to come, you’ll examine both APIs in this chapter, beginning with <code>UIWebView</code>.</p>
<h4 class="h4" id="ch09lev2sec01"><em><strong>Working with UIWebViews</strong></em></h4>
<p class="noindent">Web views shift some portion of the application logic to a remote web API or application. As such, developers have less control over the behavior of web views than a fully native iOS application would allow, but there are a few controls you can put in place to bend web views to your will.</p>
<p class="indent">By implementing the <code>shouldStartLoadWithRequest</code> method of the protocol <code>UIWebViewDelegate</code>,<sup><a href="footnote.html#fn78" id="fn_78">2</a></sup> you can make decisions about all the URLs opened via web views before actually allowing them to be opened. For example, to limit the attack surface, you can limit all requests so that they go only to HTTPS URLs or only to particular domains. If you want to ensure that your application will never load non-HTTPS URLs, you can do something like the example shown in <a href="ch09.html#ch9ex1">Listing 9-1</a>.</p>
<pre>   - (<span class="rose">BOOL</span>)webView:(<span class="violet1">UIWebView*</span>)webView shouldStartLoadWithRequest:(<span class="violet1">NSURLRequest*)</span><br/>        <span class="violet1">request</span><br/>    navigationType:(<span class="violet1">UIWebViewNavigationType)navigationType {</span><br/><br/>       <span class="violet1">NSURL *</span>url = [request URL];<br/><br/><span class="ent">➊</span>     <span class="rose">if</span> ([[url scheme] <span class="violet">isEqualToString</span>:<span class="red">@"https"</span>]) {<br/><br/>           <span class="rose">if</span> ([url host] != nil) {<br/>               <span class="violet1">NSString</span> *goodHost = <span class="red">@"happy.fluffy.bunnies.com"</span>;<br/><br/><span class="ent">➋</span>             <span class="rose">if</span> ([[url host] <span class="violet">isEqualToString</span>:goodHost]) {<br/>                   <span class="rose">return</span> YES;<br/>               }<br/>           }<br/>       }<br/>       <span class="rose">return</span> NO;<br/>   }</pre>
<p class="listcap"><a id="ch9ex1"/><em>Listing 9-1: Rejecting non-HTTPS URLs and unknown hostnames</em></p>
<p class="indent"><a id="page_149"/>This example uses two different attributes of the <code>NSURL</code> associated with the <code>NSURLRequest</code> being loaded. At <span class="ent">➊</span>, the <code>scheme</code> property of the URL is checked to see whether it matches the specified scheme, <code>https</code>. At <span class="ent">➋</span>, the <code>host</code> property is compared to a single whitelisted domain: <em>happy.fluffy.bunnies.com</em>. These two restrictions limit the application’s web views access to only your domain—rather than anything that might be attacker-controlled—and ensure that requests are always transmitted over HTTPS, keeping their contents safe from network attackers.</p>
<p class="indent">Web views may seem like the way to go because you can reuse codebases across platforms and still have some level of control over the local system. However, web views do have some serious security implications. One limitation is the inability to upgrade the WebKit binary shipped with <code>UIWebView</code>. WebKit is prepackaged with new versions of iOS and does not get updated out-of-band from the main OS. This means that any WebKit vulnerabilities that are discovered remain exploitable until a new version of iOS is released.</p>
<p class="indent">Another major part of using web views securely involves handling your cached data properly, which I’ll discuss in the next section.</p>
<h4 class="h4" id="ch09lev2sec02"><em><strong>Executing JavaScript in UIWebViews</strong></em></h4>
<p class="noindent">The web view JavaScript engine is known as JavaScriptCore, also marketed as Nitro by Apple. While the new <code>WKWebView</code> class improves JavaScript support (see “<a href="ch09.html#ch09lev1sec03">Enter WKWebView</a>” on <a href="ch09.html#page_158">page 158</a>), the implementation of JavaScript-Core as used in <code>UIWebView</code> has a couple of shortcomings when compared with JavaScript engines in modern browsers. The main limitation is the lack of just-in-time (JIT) compilation.</p>
<p class="indent"><code>UIWebView</code> JavaScript execution also limits total allocations to 10MB and runtime to 10 seconds, at which point execution will be immediately and unequivocally halted. Despite these shortcomings, applications can execute a limited amount of JavaScript by passing the script to <code>stringByEvaluatingJavaScriptFromString</code>, as illustrated in <a href="ch09.html#ch9ex2">Listing 9-2</a>.</p>
<pre>[webView <span class="violet">stringByEvaluatingJavaScriptFromString</span>:<span class="red">@"var elem =</span><br/>    <span class="red">document.createElement('script');"</span><br/>        <span class="red">"elem.type = 'text/javascript';"</span><br/>        <span class="red">"elem.text = 'aUselessFunc(name) {"</span><br/>        <span class="red">"       alert('Ohai!'+name);"</span><br/>        <span class="red">"};"</span><br/>        <span class="red">"document.getElementById('head').appendChild(elem);"</span>];<br/>[webView <span class="violet">stringByEvaluatingJavaScriptFromString</span>:<span class="red">@"aUselessFunc('Mitch');"</span>];</pre>
<p class="listcap"><a id="ch9ex2"/><em>Listing 9-2: Injecting JavaScript into the web view</em></p>
<p class="indent"><a id="page_150"/>The <code>stringByEvaluatingJavaScriptFromString</code> method takes a single argument, which is a blob of JavaScript, to insert into the view. Here, the element <code>elem</code> is created, a simple function to spawn an alert box is defined, and the function is inserted into the web view. Now, the newly defined function can be called with subsequent calls to <code>stringByEvaluatingJavaScriptFromString</code>.</p>
<p class="indent">Do note, however, that allowing dynamic JavaScript execution within your apps exposes your users to the JavaScript injection attacks. As such, this functionality should be used judiciously, and developers should never reflect untrusted input into dynamically generated scripts.</p>
<p class="indent">You’ll learn more about JavaScriptCore in the next section, where I discuss ways to get around the <code>UIWebView</code> shortcomings I’ve described so far.</p>
<h3 class="h3" id="ch09lev1sec02"><strong>Rewards and Risks of JavaScript-Cocoa Bridges</strong></h3>
<p class="noindent">To overcome the limitations of <code>UIWebView</code>, various workarounds have been used to expose more native functionality to web-based applications. For example, the Cordova development framework uses a clever (or dangerous) web view implementation to access Cocoa APIs that allow the use of the camera, accelerometer, geolocation capabilities, address book, and more.</p>
<p class="indent">In this section, I’ll introduce you to some popular JavaScript-Cocoa bridges, provide examples of how you’d see them used in the wild, and discuss some security risks they pose.</p>
<h4 class="h4" id="ch09lev2sec03"><em><strong>Interfacing Apps with JavaScriptCore</strong></em></h4>
<p class="noindent">Prior to iOS 7, <code>[UIWebView stringByEvaluatingJavaScriptFromString:]</code> was the only way to invoke JavaScript from inside an application. However, iOS 7 shipped with the JavaScriptCore framework, which has full support for bridging communications between native Objective-C and a JavaScript runtime. The bridge is created via the new <code>JSContext</code> global object, which provides access to a JavaScript virtual machine for evaluating code. The Objective-C runtime can also obtain strong references to JavaScript values via <code>JSValue</code> objects.</p>
<p class="indent">You can use JavaScriptCore to interface with the JavaScript runtime in two fundamental ways: by using inline blocks or by directly exposing Objective-C objects with the <code>JSExport</code> protocol. I’ll briefly cover how both methods work and then discuss security concerns introduced by this new attack surface.</p>
<h5 class="h5" id="ch09lev3sec01"><strong>Directly Exposing Objective-C Blocks</strong></h5>
<p class="noindent">One use of Objective-C blocks is to provide a simple mechanism to expose Objective-C code to JavaScript. When you expose an Objective-C block to <a id="page_151"/>JavaScript, the framework automatically wraps it with a callable JavaScript function, which allows you to then call the Objective-C code directly from JavaScript. Let’s look at an example—albeit a contrived one—in <a href="ch09.html#ch9ex3">Listing 9-3</a>.</p>
<pre>   JSContext *context = [[JSContext <span class="violet">alloc</span>] <span class="violet">init</span>];<br/><span class="ent">➊</span> context[<span class="red">@"shasum"</span>] = ^(<span class="violet1">NSString</span> *data, <span class="violet1">NSString</span> *salt) {<br/>       <span class="rose">const char</span> *cSalt = [salt <span class="violet">cStringUsingEncoding</span>:<span class="violet1">NSUTF8StringEncoding];</span><br/>       <span class="rose">const char</span> *cData = [data <span class="violet">cStringUsingEncoding</span>:<span class="violet1">NSUTF8StringEncoding];</span><br/>       <span class="rose">unsigned char</span> digest[CC_SHA256_DIGEST_LENGTH];<br/>       CCHmac(kCCHmacAlgSHA256, cSalt, strlen(cSalt), cData, strlen(cData),<br/>        digest);<br/>       <span class="violet1">NSMutableString</span> *hash = [<span class="violet1">NSMutableString</span> stringWithCapacity:<br/>        CC_SHA256_DIGEST_LENGTH];<br/>       <span class="rose">for</span> (<span class="rose">int</span> i = 0; i &lt; CC_SHA256_DIGEST_LENGTH; i++) {<br/>           [hash <span class="violet">appendFormat</span>:<span class="red">@"%02x"</span>, digest[i]];<br/>       }<br/>       <span class="rose">return</span> hash;<br/>   };</pre>
<p class="listcap"><a id="ch9ex3"/><em>Listing 9-3: Exposing an Objective-C block to JavaScript</em></p>
<p class="indent">Here, a block (you can see it defined by the <code>^</code> operator at <span class="ent">➊</span>) is exposed that accepts a password and a salt from JavaScript and uses the Common-Crypto framework to create a hash. This block can then be accessed directly from JavaScript to create the user’s password hash, as shown in <a href="ch09.html#ch9ex4">Listing 9-4</a>.</p>
<pre>var password = document.getElementById(<span class="red">'password</span>');<br/>var salt = document.getElementById(<span class="red">'salt</span>');<br/>var pwhash = shasum(password, salt);</pre>
<p class="listcap"><a id="ch9ex4"/><em>Listing 9-4: JavaScript call to exposed Objective-C block</em></p>
<p class="indent">This technique lets you utilize the Cocoa Touch APIs and avoid re-implementing difficult and easily botched operations such as encryption or hashing.</p>
<p class="indent">Blocks are the simplest way to expose Objective-C code to JavaScript, but they have a few drawbacks. For instance, all the bridged objects are immutable, so changing the value of an Objective-C variable won’t affect the JavaScript variable that it is mapped to. However, if you do need to share objects between both execution contexts, you can also expose custom classes using the <code>JSExport</code> protocol.</p>
<h5 class="h5" id="ch09lev3sec02"><strong>Connecting Objective-C and JavaScript with JSExport</strong></h5>
<p class="noindent">The <code>JSExport</code> protocol allows applications to expose entire Objective-C classes and instances to JavaScript and operate on them as if they were JavaScript objects. Additionally, the references to their Objective-C counterparts <a id="page_152"/>are strong, meaning modifications to an object in one environment are reflected in the other. Defining variables and methods within a protocol that inherits <code>JSExport</code> signals to JavaScriptCore that those elements can be accessed from JavaScript, as illustrated in <a href="ch09.html#ch9ex5">Listing 9-5</a>.</p>
<pre><span class="rose">@protocol</span> UserExports &lt;JSExport&gt;<br/><br/><span class="green1"><span class="codeitalic">//exported variables</span></span><br/><span class="rose">@property</span> <span class="violet1">NSString</span> *name;<br/><span class="rose">@property</span> <span class="violet1">NSString</span> *address;<br/><br/><span class="green1"><span class="codeitalic">//exported functions</span></span><br/>- (<span class="violet1">NSString</span> *) updateUser:(<span class="violet1">NSDictionary</span> *)info;<br/><span class="rose">@end</span></pre>
<p class="listcap"><a id="ch9ex5"/><em>Listing 9-5: Exposing variables and methods using a whitelist approach</em></p>
<p class="indent">Thanks to that <code>JSExport</code> protocol declaration, JavaScript has access to the variables <code>name</code> and <code>address</code> and the function <code>updateUser</code>. Apple has made exposing such objects to JavaScriptCore extremely easy, which means it can also be extremely easy for developers to inadvertently expose all kinds of unintended functionality. Luckily, this bridge follows an entirely opt-in model: only members you actually define in the protocol itself are exposed. Unless explicitly whitelisted in the protocol definition, any additional declarations made in the class interface are hidden, as in <a href="ch09.html#ch9ex6">Listing 9-6</a>.</p>
<pre><span class="rose">@interface</span> User : <span class="violet1">NSObject</span> &lt;UserExports&gt; <span class="ent">➊</span><br/><br/><span class="green1"><span class="codeitalic">// non-exported variable</span></span><br/><span class="rose">@property</span> <span class="violet1">NSString</span> *password;<br/><br/><span class="green1"><span class="codeitalic">// non-exported method declaration</span></span><br/>- (<span class="rose">BOOL</span>) resetPassword;<br/><span class="rose">@end</span></pre>
<p class="listcap"><a id="ch9ex6"/><em>Listing 9-6: Elements declared outside the protocol definition are inacessible in JavaScript</em></p>
<p class="indent">The <code>User</code> interface inherits from <code>UserExports</code> at <span class="ent">➊</span>, so it also inherits from <code>JSExport</code>. But the <code>password</code> property and the <code>resetPassword</code> method aren’t declared inside <code>UserExports</code>, so they won’t be exposed to JavaScript.</p>
<p class="indent">Now that JavaScriptCore knows about your <code>UserExports</code> protocol, it can create an appropriate wrapper object when you add an instance of it to a <code>JSContext</code>, as in the next listing:</p>
<pre><span class="ent">➊</span> JSContext *context = [[JSContext <span class="violet">alloc</span>] <span class="violet">init</span>];<br/><span class="ent">➋</span> User *user= [[User <span class="violet">alloc</span>] <span class="violet">init</span>];<br/>   [user <span class="violet">setName</span>:<span class="red">@"Winston Furchill"</span>];<br/>   [user setValue:24011965];<br/>   [user setHiddenName:<span class="red">@"Enigma"</span>];<br/><span class="ent">➌</span> context<span class="red">[@"user"</span>] = user;<br/><span class="ent">➍</span> JSValue val = [context evaluateScript:<span class="red">@"user.value"</span>];<br/><span class="ent">➎</span> JSValue val = [context evaluateScript:<span class="red">@"user.hiddenName"</span>];<br/>   <span class="violet1">NSLog(</span><span class="red">@"value: %d"</span><span class="violet1">,</span> [val toInt32]); <span class="green1"><span class="codeitalic">// =&gt; 23011965</span></span><br/>   <span class="violet1">NSLog(</span><span class="red">@"hiddenName: %@"</span><span class="violet1">,</span> [val toString]); <span class="green1"><span class="codeitalic">// =&gt; undefined</span></span></pre>
<p class="indent"><a id="page_153"/>Here, a <code>JSContext</code> is set up at <span class="ent">➊</span>, an instance of a <code>User</code> class is set up at <span class="ent">➋</span>, and some values are assigned to three of the new user’s properties. One of those properties, <code>hiddenName</code>, was defined only in the <code>@implementation</code> instead of the protocol—the same thing that happened in <a href="ch09.html#ch9ex6">Listing 9-6</a> with the <code>password</code> property. At <span class="ent">➌</span>, the newly created user is bridged to the <code>JSContext</code>. When the code subsequently tries to access the values of the user object from JavaScript, the <code>value</code> property is successfully accessed at <span class="ent">➍</span>, while the attempt to access <code>hiddenName</code> fails <span class="ent">➎</span>.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>Use discretion when exporting objects to JavaScriptCore. An attacker who exploits a script injection flaw will be able to run any exported functions, essentially turning the script injection into native remote code execution on users’ devices.</em></p>
</div>
<p class="indent">One additional interesting point is that JavaScriptCore disallows calling exported class constructors. (This is a bug in iOS that, as of iOS 8, has yet to be resolved.) So even if you add <code>[User class]</code> to your context, you won’t be able to create new objects using <code>new</code>. As I discovered through some testing, however, it’s possible to work around that limitation. You can essentially implement an exported Objective-C block that accepts a class name and then creates and returns an instance of an arbitrary class to JavaScript, as I’ve done here:</p>
<pre><span class="rose">self</span>.context[<span class="red">@"newInstance"</span>] = ^(<span class="violet1">NSString</span> *className) {<br/>    Class clazz = <span class="violet1">NSClassFromString(className);</span><br/>    <span class="rose">id</span> inst = [clazz <span class="violet">alloc</span>];<br/>    <span class="rose">return</span> inst;<br/>};<br/><br/>[<span class="rose">self</span>.context evaluateScript:<span class="red">@"var u = newInstance('User');"</span>];<br/>JSValue *val = <span class="rose">self</span>.context[<span class="red">@"u"</span>];<br/>User *user = [val toObject];<br/><span class="violet1">NSLog(</span><span class="red">@"%@"</span><span class="violet1">,</span> [user class]); <span class="green1"><span class="codeitalic">// =&gt; User</span></span></pre>
<p class="indent">This technique bypasses the need to explicitly export any classes and allows you to instantiate an object of any type and expose it to JavaScript-Core. However, no members have been whitelisted to be exported, so there are no strong references to any methods or variables of the class object. Clearly, there’s plenty of room for more security research into bypassing <a id="page_154"/>the restrictions implemented by JavaScriptCore because the Objective-C runtime is such a dynamic and powerful beast.</p>
<p class="indent">One common complaint about the JavaScriptCore framework is that there is no documented way to access the <code>JSContext</code> of a <code>UIWebView</code>. I’ll discuss some potential ways around this next.</p>
<h5 class="h5" id="ch09lev3sec03"><strong>Manipulating JavaScript in Web Views</strong></h5>
<p class="noindent">Why expose this <code>JSContext</code> functionality without a way to access it within a web view? It’s not clear what Apple’s intentions were, but the developers did only half the job of documenting the JavaScriptCore APIs. As of yet, there’s no official Apple way to manipulate a <code>UIWebView</code>’s <code>JSContext</code>, but several people have discovered methods to do so. Most of them involve using the <code>valueForKeyPath</code> method, as in <a href="ch09.html#ch9ex7">Listing 9-7</a>.</p>
<pre>- (<span class="rose">void</span>)webViewDidFinishLoad:(<span class="violet1">UIWebView *</span>)webView {<br/>      JSContext *context = [webView <span class="violet">valueForKeyPath</span>:<span class="red">@"documentView.webView.</span><br/>     <span class="red">mainFrame.javaScriptContext"</span>];<br/><br/>      context[<span class="red">@"document"</span>][<span class="red">@"cookie"</span>] = <span class="red">@"hello, I'm messing with cookies"</span>;<br/>    }</pre>
<p class="listcap"><a id="ch9ex7"/><em>Listing 9-7: Manipulating a DOM via Objective-C</em></p>
<p class="indent">Since this isn’t an officially Apple-sanctioned approach, there’s no guarantee that this kind of code will make it into the App Store, but it’s worth being aware of the ways developers may try to communicate between JavaScript and Objective-C and the pitfalls it poses.</p>
<p class="indent">Of course, the <code>JSContext</code> isn’t the only way to connect JavaScript to Objective-C. I describe Cordova, another popular bridge, in the next section.</p>
<h4 class="h4" id="ch09lev2sec04"><em><strong>Executing JavaScript with Cordova</strong></em></h4>
<p class="noindent">Cordova (known as PhoneGap before Adobe acquired the development firm Nitobi) is an SDK that provides native mobile APIs to a web view’s JavaScript execution environment in a platform-agnostic manner. This allows mobile applications to be developed like standard web applications using HTML, CSS, and JavaScript. Those applications then work across all platforms Cordova supports. This can significantly reduce lead time and do away with the need for development firms to hire platform-specific engineers, but Cordova’s implementation increases the application attack surface significantly.</p>
<h5 class="h5" id="ch09lev3sec04"><a id="page_155"/><strong>How Cordova Works</strong></h5>
<p class="noindent">Cordova bridges JavaScript and Objective-C by implementing an <code>NSURLProtocol</code> to handle any JavaScript-initiated <code>XmlHttpRequest</code> to <em>file://!gap_exec</em>. If the native Cordova library detects a call to this URI, it attempts to pull class, method, argument, and callback information out of the request headers, as evidenced in <a href="ch09.html#ch9ex8">Listing 9-8</a>.</p>
<pre>   + (<span class="rose">BOOL</span>)canInitWithRequest:(<span class="violet1">NSURLRequest*)theRequest</span> {<br/>       <span class="violet1">NSURL*</span> theUrl = [theRequest URL];<br/>       CDVViewController* viewController = viewControllerForRequest(theRequest);<br/><br/>       <span class="rose">if</span> ([[theUrl absoluteString] hasPrefix:kCDVAssetsLibraryPrefixs]) {<br/>           <span class="rose">return</span> YES;<br/>       } <span class="rose">else if</span> (viewController != nil) {<br/><span class="ent">➊</span>          <span class="rose">if</span> ([[theUrl path] <span class="violet">isEqualToString</span>:<span class="red">@"/!gap_exec"</span>]) {<br/><span class="ent">➋</span>              <span class="violet1">NSString*</span> queuedCommandsJSON = [theRequest <span class="violet">valueForHTTPHeaderField</span>:<span class="red">@"</span><br/>        <span class="red">cmds"</span>];<br/>               <span class="violet1">NSString*</span> requestId = [theRequest <span class="violet">valueForHTTPHeaderField</span>:<span class="red">@"rc"</span>];<br/>               <span class="rose">if</span> (requestId == nil) {<br/>                   <span class="violet1">NSLog(</span><span class="red">@"!cordova request missing rc header"</span><span class="violet1">);</span><br/>                   <span class="rose">return</span> NO;<br/>               }<br/>               <span class="rose">BOOL</span> hasCmds = [queuedCommandsJSON length] &gt; 0;<br/>               <span class="rose">if</span> (hasCmds) {<br/>                   SEL sel = <span class="rose">@selector</span>(enqueCommandBatch:);<br/><span class="ent">➌</span>                 [viewController.commandQueue performSelectorOnMainThread:sel<br/>       withObject:queuedCommandsJSON waitUntilDone:NO];</pre>
<p class="listcap"><a id="ch9ex8"/><em>Listing 9-8: Detecting native library calls in</em> CDVURLProtocol.m<sup><a href="footnote.html#fn79" id="fn_79">3</a></sup></p>
<p class="indent">At <span class="ent">➊</span>, the request URL is checked for a path component of <em>/!gap_exec</em>, and at <span class="ent">➋</span>, the value of the <code>cmds</code> HTTP header is extracted. Cordova then passes these commands to the command queue <span class="ent">➌</span>, where they will be executed if possible. When these commands are queued, Cordova looks up the information in a map of available Cordova plug-ins, which essentially just expose various portions of the native functionality and can be extended arbitrarily. If a particular plug-in is enabled and the class in the request can be instantiated, then the method is called with the supplied arguments using the all-powerful <code>objc_msgSend</code>.</p>
<p class="indent">When the call completes, the native code calls back to the JavaScript runtime via <code>[UIWebView stringByEvaluatingJavaScriptFromString]</code>, calling the <code>cordova.require('cordova/exec').nativeCallback</code> method defined in <em>cordova.js</em>, and provides the original callback ID as well as the return value of the native code execution.</p>
<p class="indent"><a id="page_156"/>This exports an unprecedented amount of native object control to the JavaScript runtime, allowing applications to read and write files, read and write Keychain storage, upload local files to a remote server via FTP, and so on. But with this increased functionality comes potential pitfalls.</p>
<h5 class="h5" id="ch09lev3sec05"><strong>Risks of Using Cordova</strong></h5>
<p class="noindent">If your app contains any script injection vulnerabilities and if your users can influence application navigation, an attacker could obtain remote code execution. They would just have to inject callback functions combined with a call to initiate communication with native code. For instance, an attacker might inject a call to access Keychain items, grab a copy of all the user’s contacts, or read out a file and feed it into a JavaScript function of their choosing, as demonstrated in <a href="ch09.html#ch9ex9">Listing 9-9</a>.</p>
<pre>&lt;script type="text/javascript"&gt;<br/>    var exec = cordova.require('cordova/exec');<br/>    function callback(msg) {<br/>        console.log(msg);<br/>    }<br/>    exec(callback, callback, "File", "readAsText", ["/private/var/mobile/Library/<br/>     Preferences/com.apple.MobileSMS.plist", "UTF-8",<br/>        0, 2048]);<br/>&lt;/script&gt;</pre>
<p class="listcap"><a id="ch9ex9"/><em>Listing 9-9: Using Cordova to make Objective-C calls to read the contents of a file</em></p>
<p class="indent">This attacker-supplied JavaScript reads the device’s <em>com.apple.MobileSMS.plist</em>, which, in iOS 8, is accessible to all applications on the device.<sup><a href="footnote.html#fn80" id="fn_80">4</a></sup> This gives the attacker the ability to examine the user’s contacts, as well as determine the owner of the device in question.</p>
<p class="indent">One reasonable bit of built-in security that can significantly reduce the risks of script injection is <em>domain whitelisting</em>.<sup><a href="footnote.html#fn81" id="fn_81">5</a></sup> Cordova’s default security policy blocks all network access and allows interaction only with domains that are whitelisted under the <code>&lt;access&gt;</code> element in the app configuration. The whitelist does allow access to all domains via a wildcard (<sub>*</sub>) entry, but don’t be lazy—ensure that only the domains your app needs to talk to in order to function properly are in the whitelist. You can configure this through Xcode by adding values to the <code>ExternalHosts</code> key in <code>Cordova.plist</code>, as shown in <a href="ch09.html#ch9fig1">Figure 9-1</a>.</p>
<div class="image"><a id="page_157"/><img alt="image" src="graphics/f09-01.jpg"/></div>
<p class="figcap"><a id="ch9fig1"/><em>Figure 9-1: Whitelisting domains in Cordova using the</em> <code>ExternalHosts</code> <em>key</em></p>
<p class="indent">Besides exposing native code objects to the web view, there are many other drawbacks to implementing mobile applications using a web platform wrapper such as Cordova. Mainly, each mobile platform has its own security model predicated on specific assumptions, APIs, and functionality to protect users and secure local storage. One platform’s security model just won’t make sense on other platforms. Providing a one-size-fits-all implementation is, necessarily, going to exclude some of these platform-specific security benefits for the sake of usability.</p>
<p class="indent">For example, iOS provides secure storage through the Data Protection APIs (as I describe in <a href="ch13.html#ch13">Chapter 13</a>), which require specific arguments that don’t lend themselves to a cross-platform implementation. As such, these APIs are not supported by Cordova, preventing fine-grained control over when file data is encrypted at rest. To solve this problem, you can enable entitlement-level data protection (refer to “<a href="ch13.html#ch13lev2sec08">The DataProtectionClass Entitlement</a>” on <a href="ch13.html#page_223">page 223</a>), which will apply a default protection level ubiquitously for all data written to disk by the application.</p>
<p class="indent">Another common issue is the lack of a similar secure storage element across platforms. This removes direct Keychain access on iOS, although Adobe ultimately developed an open source plug-in<sup><a href="footnote.html#fn82" id="fn_82">6</a></sup> to address the problem.</p>
<p class="indent">That ends the tour of <code>UIWebView</code> and JavaScript bridges, but new applications (for iOS 8 and newer) will increasingly be using the <code>WKWebView</code> API. I’ll cover how to wrangle <code>WKWebView</code> in the following section.</p>
<h3 class="h3" id="ch09lev1sec03"><a id="page_158"/><strong>Enter WKWebView</strong></h3>
<p class="noindent">As I mentioned previously, a newer interface to WebKit was introduced with iOS 8 to supplant <code>UIWebView</code>. <code>WKWebView</code> addresses several of the shortcomings of <code>UIWebView</code>, including access to the Nitro JavaScript engine, which greatly increases performance on JavaScript-heavy tasks. Let’s look at how apps would create <code>WKWebView</code>s and how <code>WKWebView</code>s can improve your app’s security.</p>
<h4 class="h4" id="ch09lev2sec05"><em><strong>Working with WKWebViews</strong></em></h4>
<p class="noindent">A <code>WKWebView</code> is instantiated in essentially the same way as a <code>UIWebView</code>, as shown here:</p>
<pre>CGRect webFrame = CGRectMake(0, 0, width, height);<br/>WKWebViewConfiguration *conf = [[WKWebViewConfiguration <span class="violet">alloc</span>] <span class="violet">init</span>];<br/>WKWebView *webView =[[WKWebView <span class="violet">alloc</span>] <span class="violet">initWithFrame</span>:webFrame<br/>                                       configuration:conf];<br/><span class="violet1">NSURL</span> *url = [<span class="violet1">NSURL</span> URLWithString:<span class="red">@"http://www.nostarch.com"</span>];<br/><span class="violet1">NSURLRequest</span> *request = [<span class="violet1">NSURLRequest</span> <span class="violet">requestWithURL</span>:url];<br/>[webView <span class="violet">loadRequest</span>:request];</pre>
<p class="indent">This just allocates a new <code>WKWebView</code> instance and then initializes it with the <code>initWithFrame</code> method.</p>
<p class="indent">To customize behavior, <code>WKWebView</code>s can also be instantiated with user-supplied JavaScript, as in <a href="ch09.html#ch9ex10">Listing 9-10</a>. This allows you to load a third-party website but with your own custom JavaScript that executes upon page load.</p>
<pre>   CGRect webFrame = CGRectMake(0, 0, width, height);<br/><span class="ent">➊</span> <span class="violet1">NSString</span> *src = <span class="red">@"alert('Welcome to my WKWebView!')"</span>;<br/><span class="ent">➋</span> WKWebViewConfiguration *conf = [[WKWebViewConfiguration <span class="violet">alloc</span>] <span class="violet">init</span>];<br/><span class="ent">➌</span> WKUserScript *script = [[WKUserScript <span class="violet">alloc</span>] <span class="violet">initWithSource</span>:src<br/>           injectionTime:WKUserScriptInjectionTimeAtDocumentStart<br/>        forMainFrameOnly:YES];<br/><span class="ent">➍</span> WKUserContentController *controller = [[WKUserContentController <span class="violet">alloc</span>] <span class="violet">init</span>];<br/><span class="ent">➎</span> [conf <span class="violet">setUserContentController</span>:controller];<br/><span class="ent">➏</span> [controller <span class="violet">addUserScript</span>:script];<br/><span class="ent">➐</span> WKWebView *webView =[[WKWebView <span class="violet">alloc</span>] <span class="violet">initWithFrame</span>:webFrame<br/>                                              configuration:conf];</pre>
<p class="listcap"><a id="ch9ex10"/><em>Listing 9-10: Instantiating a</em> <code>WKWebView</code> <em>with custom JavaScript</em></p>
<p class="indent">At <span class="ent">➊</span>, a simple <code>NSString</code> that consists of a single JavaScript command is created. At <span class="ent">➋</span>, a configuration object is created that will hold the configuration parameters for the web view that will be created later. At <span class="ent">➌</span>, a <code>WKUserScript</code> object is created and initialized with the <code>src</code> that contains the JavaScript you want to execute. Then a <code>WKUserContentController</code> is made at <span class="ent">➍</span>, <a id="page_159"/>which is set in the configuration object at <span class="ent">➎</span>. Finally, the script is added to the controller with the <code>addUserScript</code> method at <span class="ent">➏</span>, and the web view is instantiated at <span class="ent">➐</span>.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>As with other methods of injecting JavaScript, be careful not to interpolate content provided by third parties without strict sanitization.</em></p>
</div>
<h4 class="h4" id="ch09lev2sec06"><em><strong>Security Benefits of WKWebViews</strong></em></h4>
<p class="noindent">Using <code>WKWebView</code>s has a couple security advantages. First, you can set preferences that disable loading JavaScript with the method <code>setJavaScriptEnabled</code> if the pages you plan to load don’t require it; if the remote site has malicious script, this will prevent that script from executing. You can also leave JavaScript enabled but disable the opening of new windows from JavaScript using the <code>setJavaScriptCanOpenWindowsAutomatically</code> method—this will prevent most pop-ups from opening, which can be quite irritating in web views.</p>
<p class="indent">Lastly, and perhaps most importantly, you can actually detect whether the contents of the web view were loaded over HTTPS, giving you the ability to ensure that no parts of the page were loaded over insecure channels. For <code>UIWebView</code>s, there is no indication to the user or developer when the web view loads mixed content—the <code>hasOnlySecureContent</code> method of <code>WKWebView</code> resolves this problem. <a href="ch09.html#ch9ex11">Listing 9-11</a> shows a way to implement a somewhat hardened <code>WKWebView</code>.</p>
<pre>   <span class="rose">@interface</span> ViewController ()<br/>   <span class="rose">@property</span> (strong, nonatomic) WKWebView *webView;<br/><br/>   <span class="rose">@end</span><br/><br/>   <span class="rose">@implementation</span> ViewController<br/><br/>   - (<span class="rose">void</span>)viewDidLoad {<br/>       [<span class="rose">super</span> viewDidLoad];<br/><br/><span class="ent">➊</span>     WKPreferences *pref = [[WKPreferences <span class="violet">alloc</span>] <span class="violet">init</span>];<br/>       [pref <span class="violet">setJavaScriptEnabled</span>:NO];<br/>       [pref <span class="violet">setJavaScriptCanOpenWindowsAutomatically</span>:NO];<br/><br/><span class="ent">➋</span>     WKWebViewConfiguration *conf = [[WKWebViewConfiguration <span class="violet">alloc</span>] <span class="violet">init</span>];<br/>       [conf setPreferences:pref];<br/><br/><span class="ent">➌</span>     <span class="violet1">NSURL</span> *myURL = [<span class="violet1">NSURL</span> URLWithString:<span class="red">@"https://people.mozilla.org/~mkelly/</span><br/>       <span class="red">mixed_test.html"</span>];<br/><br/><span class="ent">➍</span>     _webView = [[WKWebView <span class="violet">alloc</span>] <span class="violet">initWithFrame</span>:[[<span class="rose">self</span> view] frame]<br/>                                     configuration:conf];<br/><br/>       [_webView <span class="violet">setNavigationDelegate</span>:<span class="rose">self</span>];<br/><span class="ent">➎</span>     [_webView <span class="violet">loadRequest</span>:[<span class="violet1">NSURLRequest</span> <span class="violet">requestWithURL</span>:myURL]];<br/>       [[<span class="rose">self</span> view] <span class="violet">addSubview</span>:_webView];<br/>   }<br/><br/><span class="ent">➏</span> - (<span class="rose">void</span>)webView:(WKWebView *)webView <span class="violet">didFinishNavigation</span>:(WKNavigation *)navigation<br/>   {<br/>       <span class="rose">if</span> (![webView <span class="violet">hasOnlySecureContent</span>]) {<br/><br/>           <span class="violet1">NSString</span> *title = <span class="red">@"Ack! Mixed content!"</span>;<br/>           <span class="violet1">NSString</span> *message = <span class="red">@"Not all content on this page was loaded securely."</span>;<br/>           <span class="violet1">UIAlertView *</span>alert = [[<span class="violet1">UIAlertView</span> <span class="violet">alloc</span><span class="violet1">]</span> <span class="violet">initWithTitle</span><span class="violet1">:title</span><br/>                                                            <span class="violet1">message:message</span><br/>                                                           <span class="violet1">delegate:</span><span class="rose">self</span><br/>                                                  <span class="violet1">cancelButtonTitle:</span><span class="red">@"OK"</span><br/>                                                  <span class="violet1">otherButtonTitles:nil];</span><br/>           <span class="violet1">[alert show];</span><br/>       <span class="violet1">}</span><br/>   <span class="violet1">}</span></pre>
<p class="listcap"><a id="ch9ex11"/><em>Listing 9-11: A nice, safe</em> <code>WKWebView</code></p>
<p class="indent"><a id="page_160"/>This code uses a couple of extra security mechanisms that <code>WKWebView</code> provides. At <span class="ent">➊</span>, a <code>WKPreferences</code> instance is instantiated, and the <code>setJavaScriptEnabled</code> and <code>setJavaScriptCanOpenWindowsAutomatically</code> properties are set on it. (These are redundant, of course, but you can pick whichever property best suits your needs.) Then, a <code>WKWebViewConfiguration</code> object is instantiated at <span class="ent">➋</span> and the <code>WKPreferences</code> already created are passed in. At <span class="ent">➌</span>, a URL to load is defined; in this case, it’s simply an example page that includes mixed content. At <span class="ent">➍</span>, the <code>WKWebView</code> itself is made, using the configuration created previously. The code then requests that the web view load a given URL at <span class="ent">➎</span>. Finally, the <code>didFinishNavigation</code> delegate is implemented at <span class="ent">➏</span>, which in turn calls <code>hasOnlySecureContent</code> on the web view. If the content is mixed, the user is alerted.</p>
<h3 class="h3" id="ch09lev1sec04"><strong>Closing Thoughts</strong></h3>
<p class="noindent">While modern versions of iOS have made great strides in allowing developers control over the interactions between native code and web content, there is a legacy of hacks to bridge the two, with their own idiosyncrasies. At this point, you should be aware of the main bridging mechanisms, as well as where to look for potentially malicious externally supplied data.</p>
<p class="indent">I also briefly covered some of the caching that takes place when working with web content. In <a href="ch10.html#ch10">Chapter 10</a>, you’ll dig in to the many ways that data can leak to the local filesystem and be recovered by attackers.</p>
</body></html>