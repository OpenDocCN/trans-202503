- en: '**10'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REQUIREMENTS DOCUMENTATION**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/com.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Requirements state what the software must do in order to satisfy the customer’s
    needs, specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: What functions the system must carry out (a *functional requirement*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How well the system must perform them (a *nonfunctional requirement*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resource or design parameters in which the software must operate (*constraints*,
    which are also nonfunctional requirements)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a piece of software does not fulfill a particular requirement, you cannot
    consider the software complete or correct. A set of software requirements, therefore,
    is the fundamental starting point for software development.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.1 Requirement Origins and Traceability**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every software requirement must have an origin. This could be a higher-level
    requirements document (for example, a requirement in a Software Requirements Specification
    [SRS] might originate from a System Requirements Specification [SyRS], or a requirement
    in the SyRS might originate from a customer-supplied functional requirements document),
    a specific use case document, a customer “statement of work to be done,” a customer’s
    verbal communication, or a brainstorming meeting. You should be able to trace
    any requirement to its origin; if you can’t, it probably isn’t necessary and should
    be removed.
  prefs: []
  type: TYPE_NORMAL
- en: '*Reverse traceability* is the ability to trace a requirement back to its origin.
    As discussed in [Chapter 9](ch09.xhtml), the Reverse Traceability Matrix (RTM)
    is a document or database that lists all requirements and their origins. With
    an RTM, you can easily identify the origin of a requirement to determine its importance
    (see “[The Requirements/Reverse Traceability Matrix](ch09.xhtml#lev-9.2.3)” on
    [page 178](ch09.xhtml#page_178) for an in-depth description of the RTM).'
  prefs: []
  type: TYPE_NORMAL
- en: '***10.1.1 A Suggested Requirements Format***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A written requirement should take one of the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[***Trigger***] **Actor** shall **Action Object** [***Condition***]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[***Trigger***] **Actor** must **Action Object** [***Condition***]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'where the items inside the square brackets are optional. The word *shall* indicates
    a functional requirement; the word *must* indicates a nonfunctional requirement.
    Each item is described as follows, based on this sample requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: When the pool temperature is in the range 40 degrees F to 65 degrees F the pool
    monitor shall turn off the “good” indication unless the atmospheric temperature
    is above 90 degrees F.
  prefs: []
  type: TYPE_NORMAL
- en: '**Trigger** A trigger is a phrase indicating when the requirement applies.
    The absence of a trigger implies that the requirement always applies. In the example,
    the trigger is “When the pool temperature is in the range 40 degrees F to 65 degrees
    F.”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Actor** The actor is the person or thing that is performing the action—in
    this case, “the pool monitor.”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Action** The action is the activity that the requirement causes (“turn off”).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object** The object is the thing being acted upon (“the ‘good’ indication”).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Condition** The condition is typically a negative contingency that stops
    the action (if a positive condition causes the action, it’s a trigger). In the
    example, the condition is “unless the atmospheric temperature is above 90 degrees
    F.”'
  prefs: []
  type: TYPE_NORMAL
- en: Some authors allow the words *should* or *may* in place of *shall* or *must*;
    however, these terms suggest that the requirement is optional. This book subscribes
    to the view that all requirements are necessary and therefore should not include
    the words *should* or *may*.
  prefs: []
  type: TYPE_NORMAL
- en: '***10.1.2 Characteristics of Good Requirements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section discusses the attributes that characterize good requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.1.2.1 Correct**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: That requirements must be correct should go without saying, but research shows
    that about 40 percent of a project’s cost is due to errors in requirements. Therefore,
    taking time to review requirements and correct any mistakes is one of the most
    cost-efficient ways to ensure quality software.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.1.2.2 Consistent**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Requirements must be consistent with one another; that is, one requirement cannot
    contradict another. For example, if a pool temperature monitor states that an
    alarm must be triggered if the temperature falls below 70 degrees and another
    says that the same alarm must be triggered when the temperature falls below 65
    degrees, the two requirements are inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: Note that consistency refers to requirements within the same document. If a
    requirement is not consistent with a requirement in a higher-level document, then
    that requirement is *incorrect*—never mind inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.1.2.3 Feasible**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you can’t feasibly implement a software requirement, then you don’t have
    a requirement. After all, requirements state what must be done in order to provide
    a satisfactory software solution; if the requirement is not viable, then it’s
    likewise impossible to provide the software solution.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.1.2.4 Necessary**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: By definition, if a software requirement is not necessary, it is not a requirement.
    Requirements are costly to implement—they require documentation, code, test procedures,
    and maintenance—so you do not want to include a requirement unless it is necessary.
    Unnecessary requirements are often the result of “gold plating,” or adding features
    simply because somebody thought they would be cool, without regard to the costs
    involved in implementing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A requirement is necessary if it:'
  prefs: []
  type: TYPE_NORMAL
- en: makes the product market competitive;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: addresses a need expressed by a customer, end user, or other stakeholder;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: differentiates the product or usage model; or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: is dictated by a business strategy, roadmap, or a sustainability need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**10.1.2.5 Prioritized**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Software requirements specify everything you must do to produce the desired
    application. However, given various constraints (time, budget, and so on), you
    may not be able to implement every requirement in the first release of the software.
    Furthermore, as time passes (and dollars are spent), some requirements may be
    abandoned because things change. Therefore, a good requirement will have an associated
    priority. This can help drive the schedule, as teams implement the most critical
    features first and relegate the less important ones to the end of the project
    development cycle. Typically, three or four levels of priority should be sufficient:
    critical/mandatory, important, desirable, and optional are good examples.'
  prefs: []
  type: TYPE_NORMAL
- en: '**10.1.2.6 Complete**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A good requirement will be complete; that is, it will not contain any *TBD*
    (to be determined) items.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.1.2.7 Unambiguous**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Requirements must not be open to interpretation (note that TBD is a special
    case of this). Unambiguous means that a requirement has exactly one interpretation.
  prefs: []
  type: TYPE_NORMAL
- en: Because most requirements are written in a natural language (such as English)
    and natural languages are ambiguous, you must take special care when writing requirements
    to avoid ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example of an ambiguous requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: When the pool temperature is too cold the software shall signal an alarm.
  prefs: []
  type: TYPE_NORMAL
- en: 'An unambiguous example:'
  prefs: []
  type: TYPE_NORMAL
- en: When the pool temperature is below 65 degrees (F) the software shall signal
    an alarm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ambiguity results whenever the following natural language features appear in
    a requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vagueness** Results when you use *weak words*—those without a precise meaning—in
    a requirement. This section will discuss weak words shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subjectivity** Refers to the fact that different people will assign a different
    meaning for a term (a weak word) based on their own personal experiences or opinion.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Incompleteness** Results from using TBD items, partial specifications, or
    unbounded lists in a requirement. Unbounded lists will be discussed in this section
    a little later.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optionality** Occurs when you use phrases that make a requirement optional
    rather than required (for example, *is caused by*, *use of*, *should*, *may*,
    *if possible*, *when appropriate*, *as desired*).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Underspecification** Occurs when a requirement does not fully specify the
    requirement, often as a result of using weak words (such as *support*, *analyzed*,
    *respond*, and *based on*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor shall support Fahrenheit and Celsius scales.
  prefs: []
  type: TYPE_NORMAL
- en: 'What exactly does *support* mean in this context? One developer could interpret
    it to mean that the end user can select the input and output to be in degrees
    F or C (fixed), while another developer could interpret it to mean that both scales
    are used for output and that input allows either scale to be used. A better requirement
    might be:'
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor setup shall allow the user to select either the Fahrenheit
    or Celsius temperature scale.
  prefs: []
  type: TYPE_NORMAL
- en: '**Underreference** Refers to when a requirement provides an incomplete or missing
    reference to another document (such as a requirement’s origin).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overgeneralization** Occurs when a requirement contains universal qualifiers
    such as *any*, *all*, *always*, and *every*, or, in the negative sense, *none*,
    *never*, and *only*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nonintelligibility** Results from poor writing (grammar), undefined terms,
    convoluted logic (for example, double negation), and incompleteness.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Passive voice** Refers to when the requirement does not assign an actor to
    an action. For example, a bad requirement using the passive voice might be:'
  prefs: []
  type: TYPE_NORMAL
- en: An alarm shall be raised if the temperature drops below 65 degrees F.
  prefs: []
  type: TYPE_NORMAL
- en: 'Who is responsible for raising the alarm? Different people could interpret
    this differently. A better requirement might be:'
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor software shall raise an alarm if the temperature drops below
    65 degrees F.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using weak words in requirements often results in ambiguity. Examples of weak
    words include: *support*, *generally*, *kind of*, *mostly*, *pretty*, *slightly*,
    *somewhat*, *sort of*, *various*, *virtually*, *quickly*, *easy*, *timely*, *before*,
    *after*, *user-friendly*, *effective*, *multiple*, *as possible*, *appropriate*,
    *normal*, *capability*, *reliable*, *state-of-the-art*, *effortless*, and *multi.*'
  prefs: []
  type: TYPE_NORMAL
- en: For example, a requirement such as “The pool monitor shall provide multiple
    sensors” is ambiguous because *multiple* is a weak word. What does it mean? Two?
    Three? A dozen?
  prefs: []
  type: TYPE_NORMAL
- en: Another way to create an ambiguous requirement is by using an unbounded list—a
    list missing a starting point, an ending point, or both. Typical examples include
    phrasing like *at least*; *including, but not limited to*; *or later*; *or more*;
    *such as*; *and so on*; and *etc.*
  prefs: []
  type: TYPE_NORMAL
- en: 'For example: “The pool monitor shall support three or more sensors.” Does it
    have to support four sensors? Ten sensors? An infinite number of sensors? This
    requirement doesn’t make it clear what the maximum number of supported sensors
    is. A better requirement might be:'
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor must support between three and six sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Unbounded lists are impossible to design and test against (so they fail both
    the feasible and verifiable attributes).
  prefs: []
  type: TYPE_NORMAL
- en: '**10.1.2.8 Implementation-Independent**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Requirements must be based solely on the inputs and outputs of a system. They
    should not delve into the implementation details of the application (that’s the
    purpose of the Software Design Description [SDD] document). Requirements must
    view the system as a black box into which inputs are fed and from which outputs
    are produced.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a requirement might state that an input to the system is a list
    of numbers that produce a sorted list as output. The requirement should not state
    something like “A quicksort algorithm shall be used.” There may be good reasons
    why the software designer would want to use a different algorithm; the requirements
    should not force the software designer’s or programmer’s hand.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.1.2.9 Verifiable**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: “If it isn’t testable, it isn’t a requirement” is the mantra by which a requirements
    author should live. If you can’t create a test for it, you also can’t verify that
    the requirement has been fulfilled in the final product. Indeed, the requirement
    might very well be impossible to implement if you can’t come up with a way to
    test it.
  prefs: []
  type: TYPE_NORMAL
- en: If you can’t create a physical test that can be run on the final software product,
    there’s a good chance that your requirement is not based solely on system inputs
    and outputs. For example, if you have a requirement that states “The system shall
    use the quicksort algorithm to sort the data,” how do you test for this? If you
    have to resort to “This requirement is tested by reviewing the code,” then you
    may not have a good requirement. That’s not to say that requirements can’t be
    verified by inspection or analysis, but an actual test is always the best way
    to verify a requirement, especially if you can automate that test.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.1.2.10 Atomic**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A good requirement statement must not contain multiple requirements—that is,
    it must not be a compound requirement. Requirements should also be as independent
    as possible; their implementation should not rely on other requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some authors claim that the words *and* and *or* must never appear in a requirement.
    Strictly speaking, this isn’t true. You simply want to avoid using the *fanboys*
    conjunctions (*for*, *and*, *nor*, *but*, *or*, *yet*, *so*) to combine separate
    requirements into a single statement. For example, the following is not a compound
    requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor shall set the “good” indication when the temperature is between
    70 degrees F *and* 85 degrees F.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a single requirement, not two. The presence of the word *and* does
    not produce two requirements. If you really want to be a stickler and eliminate
    the word *and*, you could rewrite the requirement thusly:'
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor shall set the “good” indication when the temperature is in
    the range from 70 degrees F to 85 degrees F.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there’s really nothing wrong with the first version. Here’s an example
    of a compound requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor shall clear the “good” indication when the temperature is below
    70 degrees F *or* above 85 degrees F.
  prefs: []
  type: TYPE_NORMAL
- en: This should be rewritten as two separate requirements:^([1](ch19_footnote.xhtml#ch10fn1))
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor shall clear the “good” indication when the temperature is below
    70 degrees F.
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor shall clear the “good” indication when the temperature is above
    85 degrees F.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that compound requirements will create problems later when you’re constructing
    traceability matrices, as this chapter will discuss in “Updating the Traceability
    Matrix with Requirement Information” on [page 222](ch10.xhtml#page_222). Compound
    requirements also create testing problems. The test for a requirement must produce
    a single answer: pass or fail. You cannot have part of a requirement pass and
    another part fail. That’s a sure sign of a compound requirement.'
  prefs: []
  type: TYPE_NORMAL
- en: '**10.1.2.11 Unique**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A requirements specification must not contain any duplicate requirements. Duplication
    makes the document much more difficult to maintain, particularly if you ever modify
    requirements and forget to modify the duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.1.2.12 Modifiable**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'It would be unreasonable to expect the requirements of a project to remain
    constant over its lifetime. Expectations change, technology changes, the market
    changes, and the competition changes. During product development, you’ll likely
    want to revise some requirements to adapt to evolving conditions. In particular,
    you don’t want to choose requirements that enforce certain system constraints
    that other requirements will be based on. For example, consider the following
    requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor shall use an Arduino Mega 2560 single-board computer as the
    control module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this requirement, other requirements might be “The pool monitor shall
    use the A8 pin for the pool level indication” and “The pool monitor shall use
    the D0 pin as the low temperature output.” The problem with such requirements,
    which are based on the use of the Mega 2560 board, is that if a new board comes
    along (say, a Teensy 4.0 module), then changing the first requirement necessitates
    also changing all the other requirements that depend on it. A better set of requirements
    might be:'
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor shall use a single-board computer that supports 8 analog inputs,
    4 digital outputs, and 12 digital inputs.
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor shall use one of the digital output pins as the low temperature
    alarm.
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor shall use one of the analog input pins as the pool level input.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.1.2.13 Traceable**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: All requirements must be forward- and reverse-traceable. *Reverse traceability*
    means that the requirement can be traced to its origin. To be traceable to some
    other object, the requirement must have a *tag* (a unique identifier, as introduced
    in [Chapter 4](ch04.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: Each requirement must include the origin as part of the requirement text or
    tag; otherwise, you must provide a separate RTM document (or database) that provides
    that information. In general, you should explicitly list a requirement’s origin
    within the requirement itself.
  prefs: []
  type: TYPE_NORMAL
- en: '*Forward traceability* provides a link to all documents based on (or spawned
    by) the requirements document. Most of the time, forward traceability is handled
    via an RTM document; it would be too much work to maintain this information in
    each requirements document (there would be too much duplicate information, which,
    as previously noted, makes document maintenance difficult).'
  prefs: []
  type: TYPE_NORMAL
- en: '**10.1.2.14 Positively Stated**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A requirement should state what must be true, not what must *not* happen. Most
    negatively stated requirements are impossible to verify. For example, the following
    is a bad requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor shall not operate at atmospheric temperatures below freezing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This requirement suggests that the pool monitor must stop operation once the
    temperature drops below freezing. Does this mean that the system will sense the
    temperature and shut down below freezing? Or does it simply mean that the system
    cannot be expected to produce reasonable values below freezing? Better requirements
    might be:'
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor shall automatically shut off if the temperature falls below
    freezing.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, there is a requirement that discusses what should happen when the
    temperature rises back above freezing. If the pool monitor has been shut off,
    can it sense this change?
  prefs: []
  type: TYPE_NORMAL
- en: '**10.2 Design Goals**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although requirements can’t be optional, it’s sometimes beneficial to be able
    to list optional items in a requirements document. Such items are known as design
    goals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Design goals violate many of the attributes of good requirements. Obviously,
    they are not necessary, but they can also be incomplete, be slightly ambiguous,
    specify implementation, or not be testable. For example, a design goal might be
    to use the C standard library’s built-in `sort()` function (an implementation
    detail) in order to reduce development time. Another design goal might be something
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor should support as many sensors as possible.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this is both optional and open-ended. A design goal is a suggestion
    that a developer can use to guide development choices. It should not involve extra
    design work or testing that leads to further development expenses. It should simply
    help a developer make certain developmental choices when designing the system.
  prefs: []
  type: TYPE_NORMAL
- en: Like requirements, design goals can have tags, though there’s little need to
    trace design goals through the documentation system. However, because they might
    be elevated to requirement status at some point, it’s nice to have a tag associated
    with them so they can serve as an origin for a requirement in a spawned document.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.3 The System Requirements Specification Document**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The System Requirements Specification document collects all the requirements
    associated with a complete system. This may include business requirements, legislative/political
    requirements, hardware requirements, and software requirements. The SyRS is usually
    a very high-level document, though internal to an organization. Its purpose is
    to provide a *single-source* origin for all requirements appearing in an organization’s
    subservient documents (such as the SRS).
  prefs: []
  type: TYPE_NORMAL
- en: The SyRS takes the same form as the SRS (described in the next section), so
    I won’t further elaborate on its contents other than to point out that the SyRS
    spawns the SRS (and Hardware Requirements Specifications, or HRS, if appropriate).
    The SyRS is optional and typically absent in small software-only projects.
  prefs: []
  type: TYPE_NORMAL
- en: SyRS requirements typically state “The *system* shall” or “The *system* must.”
    This is in contrast to requirements in the SRS that typically state “The *software*
    shall” or “The *software* must.”
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4 The Software Requirements Specification Document**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Software Requirements Specification is a document that contains all the
    requirements and design goals for a given software project. There are (literally)
    hundreds, if not thousands, of examples of SRS documents scattered across the
    internet. Many sites seem to have their own ideas about what constitutes an SRS.
    Rather than introduce yet another new template into the cacophony, this book will
    elect to use the template defined by the IEEE: the IEEE 830-1998 Recommended Practice
    for Software Requirements Specifications.'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, using the IEEE 830-1998 recommended practice is a safe decision,
    but note that the standard is by no means perfect. It was created by a committee
    and, as a result, it contains a lot of bloat (extraneous information). The problem
    with committee-designed standards is that the only way to get them approved is
    by letting everyone inject their own pet ideas into the document, even if those
    ideas conflict with others in the document. Nevertheless, the IEEE 830-1998 recommendation
    is a good starting point. You need not feel compelled to implement everything
    in it, but you should use it as a guideline when creating your SRS.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical SRS uses an outline similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table of Contents**'
  prefs: []
  type: TYPE_NORMAL
- en: 1 Introduction
  prefs: []
  type: TYPE_NORMAL
- en: 1.1 Purpose
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 Scope
  prefs: []
  type: TYPE_NORMAL
- en: 1.3 Definitions, Acronyms, and Abbreviations
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 References
  prefs: []
  type: TYPE_NORMAL
- en: 1.5 Overview
  prefs: []
  type: TYPE_NORMAL
- en: 2 Overall Description
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Product Perspective
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.1 System Interfaces
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.2 User Interfaces
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.3 Hardware Interfaces
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.4 Software Interfaces
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.5 Communication Interfaces
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.6 Memory Constraints
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.7 Operations
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Site Adaptation Requirements
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Product Functions
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 User Characteristics
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 Constraints
  prefs: []
  type: TYPE_NORMAL
- en: 2.6 Assumptions and Dependencies
  prefs: []
  type: TYPE_NORMAL
- en: 2.7 Apportioning of Requirements
  prefs: []
  type: TYPE_NORMAL
- en: 3 Specific Requirements
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 External Interfaces
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Functional Requirements
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Performance Requirements
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 Logical Database Requirements
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Design Constraints
  prefs: []
  type: TYPE_NORMAL
- en: 3.6 Standards Compliance
  prefs: []
  type: TYPE_NORMAL
- en: 3.7 Software System Attributes
  prefs: []
  type: TYPE_NORMAL
- en: 3.7.1 Reliability
  prefs: []
  type: TYPE_NORMAL
- en: 3.7.2 Availability
  prefs: []
  type: TYPE_NORMAL
- en: 3.7.3 Security
  prefs: []
  type: TYPE_NORMAL
- en: 3.7.4 Maintainability
  prefs: []
  type: TYPE_NORMAL
- en: 3.7.5 Portability
  prefs: []
  type: TYPE_NORMAL
- en: 3.8 Design Goals
  prefs: []
  type: TYPE_NORMAL
- en: 4 Appendixes
  prefs: []
  type: TYPE_NORMAL
- en: 5 Index
  prefs: []
  type: TYPE_NORMAL
- en: Section 3 is the most important—this is where you will place all of your requirements
    as well as your design goals.
  prefs: []
  type: TYPE_NORMAL
- en: '***10.4.1 Introduction***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Introduction contains an overview of the entire SRS. The following subsections
    describe the suggested contents of the Introduction.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.1.1 Purpose**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the Purpose section, you should state the purpose of the SRS and who the
    intended audience is. For an SRS, the intended audience is probably the customers
    who will need to validate the SRS and the developers/designers who will create
    the SDD, software test cases, and software test procedures, and will write the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.1.2 Scope**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Scope section describes the software product by name (for example, Plantation
    Productions Pool Monitor), explains what the product will do, and, if necessary,
    states what it will *not* do. (Don’t worry that this doesn’t adhere to the “positively
    stated” rule, since this is a scope declaration, not a requirement statement.)
    The Scope section also outlines the objectives of the project, the benefits and
    goals of the product, and the application software being written for the product.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.1.3 Definitions, Acronyms, and Abbreviations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Definitions section provides a glossary of all terms, acronyms, and abbreviations
    the SRS uses.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.1.4 References**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The References section provides a link to all external documents that the SRS
    references. If your SRS relies on an external RTM document, you should reference
    that document here. If the documents are internal to the organization, you should
    provide their internal document numbers/references. If the SRS references a document
    that is external to the organization, the SRS should list the document’s title,
    author, publisher, and date as well as information on how to obtain the document.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.1.5 Overview**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Overview section describes the format of the rest of the SRS and the information
    it contains (this section is particularly important if you’ve omitted items from
    the IEEE recommendation).
  prefs: []
  type: TYPE_NORMAL
- en: '***10.4.2 Overall Description***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Overall Description section specifies the requirements of the following
    aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.2.1 Product Perspective**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The Product Perspective section contextualizes the product with respect to
    other (possibly competing) products. If this product is part of a larger system,
    the product perspective should point this out (and describe how the requirements
    in this document relate to the larger system). This section might also describe
    various constraints on the product, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.2.1.1 System Interfaces**'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This section describes how the software will interface with the rest of the
    system. This would typically include any APIs, such as how the software interfaces
    with a Wi-Fi adapter in order to view pool readings remotely.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.2.1.2 User Interfaces**'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This section lists all user interface (UI) elements needed to meet the requirements.
    For example, in the pool monitor scenario, this section could describe how the
    user interacts with the device via an LCD display and various push buttons on
    the device.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.2.1.3 Hardware Interfaces**'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This section could describe how the software interacts with the underlying hardware.
    For example, the pool monitor SRS could state that the software will be running
    on an Arduino Mega 2560, using the A8 through A15 analog inputs to connect to
    the sensors and the D0 through D7 digital lines as inputs connected to buttons.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.2.1.4 Software Interfaces**'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This section describes any additional/external software needed to implement
    the system. This might include operating systems, third-party libraries, database
    management systems, or other application systems. For example, the pool monitor
    SRS might describe the use of vendor-supplied libraries needed to read data from
    various sensors. For each software item, you should include the following information
    in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specification number (a vendor-supplied value, if any)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Purpose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference to pertinent documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**10.4.2.1.5 Communication Interfaces**'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This section lists any communication interfaces, such as Ethernet, Wi-Fi, Bluetooth,
    and RS-232 serial that the product will use. For example, the pool monitor SRS
    might describe the Wi-Fi interface in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.2.1.6 Memory Constraints**'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This section describes all the constraints on memory and data storage. For the
    pool monitor running on an Arduino Mega 2560, SRS might state that there is a
    limitation in program storage of 1K EEPROM and 8K RAM plus 64K to 128K Flash.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.2.1.7 Operations**'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This section (often folded into the UI section) describes various operations
    on the product. It might detail the various modes of operation—such as normal,
    reduced power, maintenance, or installation modes—and describe interactive sessions,
    unattended sessions, and communication features.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.2.2 Site Adaptation Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This section describes any site-specific adaptations. For example, the pool
    monitor SRS might describe optional sensors for pools with spas in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.2.3 Product Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Product Functions section describes the software’s (major) functionality.
    For example, the pool monitor SRS might use this section to describe how the software
    monitors pool levels, pool temperatures, atmospheric temperature, water conductivity
    (for saltwater pools), water flow though the filtration system, and filtration
    time since the last filter cleaning.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.2.4 User Characteristics**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The User Characteristics section describes the people that will use the product.
    For example, the pool monitor SRS might define a factory test technician (responsible
    for testing and repairing the unit), a field installation technician, an advanced
    end user, and an average end user. There may be different requirements for the
    software that apply only to certain types of users.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.2.5 Constraints**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The Constraints section describes any limitations that may affect the developer’s
    choices when designing and implementing the software, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Regulatory policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware limitations (for example, signal timing requirements)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces to other applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audit functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-level language requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal handshake protocols (for example, XON-XOFF)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reliability requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Criticality of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safety and security considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**10.4.2.6 Assumptions and Dependencies**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The items listed in the Assumptions and Dependencies section apply only to the
    requirements; they do not present constraints on the design. If an assumption
    were to change, it would require changing requirements rather than the design
    (though changing requirements will likely affect the design as well). For example,
    in the pool monitor SRS an assumption might be that the Arduino Mega 2560 will
    provide sufficient computing power, ports, and memory to complete the task. If
    this assumption is incorrect, it may affect some requirements with respect to
    port usage, available memory, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.2.7 Apportioning of Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The Apportioning of Requirements section divides the requirements and features
    into two or more groups: those to be implemented in the current release, and those
    planned for future versions of the software.'
  prefs: []
  type: TYPE_NORMAL
- en: '***10.4.3 Specific Requirements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Specific Requirements section should list all the requirements and supporting
    documentation. This documentation should be written such that a system designer
    can construct a design for the software from the requirements documented.
  prefs: []
  type: TYPE_NORMAL
- en: All requirements should possess the characteristics discussed earlier in this
    chapter. They should also have a tag and a cross-reference (trace) to their origin.
    Because the requirements documentation will be read far more times than it is
    written, you should take special care to make this document as readable as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.3.1 External Interfaces**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The External Interfaces section should describe all the inputs and outputs
    of the software system in great detail but without replicating the information
    in the interface subsections of the Product Perspective section. Each listing
    should contain the following information (as appropriate for the system):'
  prefs: []
  type: TYPE_NORMAL
- en: Tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input source or output destination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Valid range of values plus necessary accuracy/precision/tolerance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measurement units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timing and tolerances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relationship to other input/output items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen/window formats (but list only screen requirements that are actual requirements—don’t
    design the user interface here)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command formats, protocols, and any necessary sentinel messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many SRS authors will pull this section out of the Specific Requirements section
    and place it in the Product Perspective section in order to avoid redundancy,
    though the IEEE 830-1998 standard suggests that this section be part of the Specific
    Requirements section. However, the IEEE document is only a *recommended* practice,
    so the choice is really yours. What matters most is that the information appears
    in the SRS.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.3.2 Functional Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Functional Requirements section contains those items that most people immediately
    recognize as requirements. This section lists the fundamental activities that
    take place on inputs and describes how the system uses the inputs to produce outputs.
    By convention, functional requirements always contain the auxiliary verb *shall*.
    For example, “The software *shall* raise an alarm when the pool low input is active.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Typical functional requirements include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Input validity checks and responses to invalid inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operation sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Abnormal condition responses, including: overflow, underflow, arithmetic exceptions,
    communication failures, resource overruns, error handling and recovery, and protocol
    errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistence of data across executions of the software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effect of parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Input/output relationships, including: legal and illegal input patterns, relationship
    of inputs to output, and how outputs are computed from inputs (but be careful
    not to incorporate software design into the requirements)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**10.4.3.3 Performance Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Performance Requirements section lists nonfunctional requirements that specify
    either static or dynamic performance targets that the software must hit. Like
    most nonfunctional requirements, performance requirements usually contain the
    auxiliary verb *must*—for example, “The software *must* be able to control an
    internal display and a remote display.”
  prefs: []
  type: TYPE_NORMAL
- en: Static performance requirements are those that are defined for the system as
    a whole and do not depend on the software’s capabilities. A good example for the
    pool monitor is “The pool monitor must be able to read sensor input data from
    between 5 and 10 analog sensors.” This is a static requirement because the number
    of sensors is static for a given installation (it isn’t going to change because
    the software is written more efficiently, for example).
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic performance requirements are those that the software must meet during
    execution. A good example might be “The software must read each sensor between
    10 and 20 times per second.”
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.3.4 Logical Database Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Logical Database Requirements section describes nonfunctional requirements
    that specify the record and field formats for databases that the application must
    access. Typically, these requirements deal with externally accessed databases.
    Databases internal to the application (that is, not visible to the outside world)
    are generally outside the domain of the software requirements, although the SDD
    might cover these.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.3.5 Design Constraints**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Standards compliance is an example of a *design constraint*. Any limitation
    that prevents the software designer from using an arbitrary implementation should
    be listed in the Design Constraints section. One example might be limiting readings
    from a 16-bit A/D converter to 13 bits because the A/D chip/circuit is noisy and
    the low-order 3 bits may not be reliable.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.3.6 Standards Compliance**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Standards Compliance section should describe, and provide links to, all
    standards to which the software must adhere. Standards numbers and document descriptions
    should allow the reader to research the standards as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.3.7 Software System Attributes**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The Software System Attributes section lists characteristics for the software
    system, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.3.7.1 Reliability**'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Requirements section will specify the expected uptime requirements for the
    software system. Reliability is a nonfunctional requirement that describes, usually
    as a percentage, the amount of time that the system will operate without a failure.
    A typical example is “an expected reliability of 99.99 percent,” meaning that
    the software will fail no more than 0.01 percent of the time. As with many nonfunctional
    requirements, it can be difficult to provide tests to ensure that reliability
    targets are met.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.3.7.2 Availability**'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The availability attribute specifies the amount of *downtime* that is acceptable
    in the final application (actually, it specifies the *inverse* of downtime). Availability
    specifies the ability of the user to access the software system at any time. When
    the system is *down*, it is not available to the user. This nonfunctional requirement
    might differentiate between scheduled downtime and unscheduled downtime (for example,
    a hardware failure that forces a restart of the system).
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.3.7.3 Security**'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The security attribute is a nonfunctional requirement that specifies the expected
    system security, which could include items such as encryption expectations and
    network socket types.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.3.7.4 Maintainability**'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Maintainability is another nonfunctional requirement that can be hard to specify
    and test. In most specifications, there is a nebulous statement like “the software
    shall be easy to maintain.” This is unhelpful. Instead, this attribute should
    state, “It must take an experienced maintenance programmer no more than a week
    to come up to speed on this system and make changes to it.”
  prefs: []
  type: TYPE_NORMAL
- en: REQUIREMENT ORGANIZATION
  prefs: []
  type: TYPE_NORMAL
- en: Any sufficiently complex system will have a large number of requirements, so
    the SRS can become unwieldy if it is not organized properly. There are many different
    application types, and an equally large number of ways to organize their requirements.
    No particular organization is correct; you’ll have to choose one of the following
    options based on the audience for your SRS.
  prefs: []
  type: TYPE_NORMAL
- en: '**Organizing by system mode**'
  prefs: []
  type: TYPE_NORMAL
- en: Some systems operate in various modes—for example, an embedded system might
    have a low-power mode and a regular mode. In that case, you could organize the
    system requirements into those two groups.
  prefs: []
  type: TYPE_NORMAL
- en: '**Organizing by user class**'
  prefs: []
  type: TYPE_NORMAL
- en: Some systems support different classes of users (for example, beginners, power
    users, and system administrators). In a complex system, you might have normal
    users, power users, maintenance workers, and programmers accessing the system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Organizing by object class**'
  prefs: []
  type: TYPE_NORMAL
- en: Objects are entities in the software system that correspond to real-world objects.
    You could organize your requirements based on the types or classes of these objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Organizing by feature**'
  prefs: []
  type: TYPE_NORMAL
- en: One of the more common ways to organize SRS requirements is by the features
    they implement. This is a particularly useful method of organization when the
    application provides a user interface for all the features in the system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Organizing by input stimulus**'
  prefs: []
  type: TYPE_NORMAL
- en: If processing different inputs is a primary activity of the application, then
    you might consider organizing your SRS by the type of inputs the application processes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Organizing by output response**'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if producing a wide range of outputs is a primary activity of the
    application, then it might make sense to organize the requirements by output response.
  prefs: []
  type: TYPE_NORMAL
- en: '**Organizing by functional hierarchy**'
  prefs: []
  type: TYPE_NORMAL
- en: Another common SRS organization approach is by functionality. This is often
    the fallback position SRS authors use when no other organization seems appropriate.
    Grouping the requirements by common inputs, command outputs, common database operations,
    and data flow through the program are all reasonable ways to organize the SRS.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.3.7.5 Portability**'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Portability describes what is involved in moving the software to a different
    environment. This section should include a discussion of portability across CPUs,
    operating systems, and programming language dialects.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4.3.8 Design Goals**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Often it is tempting to put so-called optional requirements into an SRS. However,
    as noted earlier in this chapter, requirements by definition cannot be optional.
    Nevertheless, there will be times when you might wish to say, “If possible, add
    this feature.” You can state such requests as design goals and leave it up to
    the designer or software engineer to decide if the feature is worth having. Place
    design goals in a separate section and clearly state “*As a design goal*, the
    software should . . . ” in your SRS.
  prefs: []
  type: TYPE_NORMAL
- en: '***10.4.4 Supporting Information***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Any good software requirements specification will contain supporting information
    such as a table of contents, appendixes, glossaries, and an index. There should
    also be a table of requirement tags (sorted numerically or lexicographically)
    that lists each tag, a short description of the requirement, and the page number
    where it appears in the document (this could also be placed in the RTM rather
    than in the SRS).
  prefs: []
  type: TYPE_NORMAL
- en: '***10.4.5 A Sample Software Requirements Specification***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section provides a sample SRS for a swimming pool monitor similar to the
    examples given thus far in this chapter. For space reasons, this swimming pool
    monitor SRS is greatly simplified; the purpose is not to provide a complete specification,
    but rather to provide an illustrative outline.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table of Contents**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 Introduction**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.1 Purpose**'
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor device will track pool water levels and automatically refill
    the pool when levels are low.
  prefs: []
  type: TYPE_NORMAL
- en: '**1.2 Scope**'
  prefs: []
  type: TYPE_NORMAL
- en: The pool monitor software will be produced from this specification.
  prefs: []
  type: TYPE_NORMAL
- en: The objectives of the hardware and software development are to provide functions,
    status information, monitor and control hardware, communications, and self-test
    functions per the requirements that have been allocated to the pool monitor system.
  prefs: []
  type: TYPE_NORMAL
- en: '**1.3 Definitions, Acronyms, and Abbreviations**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Term** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Accuracy | The degree of agreement with the true value of the measured input,
    expressed as percent of reading for digital readouts (ANSI N42.18-1980). |'
  prefs: []
  type: TYPE_TB
- en: '| Anomaly | Anything observed in the documentation or operation of software
    that deviates from expectations. (Derived from IEEE Std 610.12-1990.) |'
  prefs: []
  type: TYPE_TB
- en: '| Catastrophic event | An event without warning from which recovery is impossible.
    Catastrophic events include hardware or software failures resulting in computation
    and processing errors. The processor will halt or reset, based on a configuration
    item, after a catastrophic event. |'
  prefs: []
  type: TYPE_TB
- en: '| Handled conditions | Conditions that the system is designed to handle and
    continue processing. These conditions include anomalies, faults, and failures.
    |'
  prefs: []
  type: TYPE_TB
- en: '| SBC | Single-board computer |'
  prefs: []
  type: TYPE_TB
- en: '| Software Requirements Specification (SRS) | Documentation of the essential
    requirements (functions, performance, design constraints, and attributes) of the
    software and its external interfaces (IEEE Std 610.12-1990). |'
  prefs: []
  type: TYPE_TB
- en: '| SPM | Swimming pool monitor |'
  prefs: []
  type: TYPE_TB
- en: '| System Requirements Specification (SyRS) | A structured collection of information
    that embodies the requirements of the system (IEEE Std 1233-1998). A specification
    that documents the requirements to establish a design basis and the conceptual
    design for a system or subsystem. |'
  prefs: []
  type: TYPE_TB
- en: '**1.4 References**'
  prefs: []
  type: TYPE_NORMAL
- en: '[None]'
  prefs: []
  type: TYPE_NORMAL
- en: '**1.5 Overview**'
  prefs: []
  type: TYPE_NORMAL
- en: Section 2 provides an overall description of the swimming pool monitor (hardware
    and software).
  prefs: []
  type: TYPE_NORMAL
- en: Section 3 lists the specific requirements for the swimming pool monitor system.
  prefs: []
  type: TYPE_NORMAL
- en: Sections 4 and 5 provide any necessary appendixes and an index.
  prefs: []
  type: TYPE_NORMAL
- en: 'In section 3, requirements tags take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '| <whitespace> | [POOL_SRS_*xxx*] |'
  prefs: []
  type: TYPE_TB
- en: '| <whitespace> | [POOL_SRS_*xxx.yy*] |'
  prefs: []
  type: TYPE_TB
- en: '| <whitespace> | [POOL_SRS_*xxx.yy.zz*] |'
  prefs: []
  type: TYPE_TB
- en: '| <and so on>. |  |'
  prefs: []
  type: TYPE_TB
- en: where *xxx* is a three- or four-digit SRS requirement number.
  prefs: []
  type: TYPE_NORMAL
- en: Should the need arise to insert a new SRS requirement tag between two other
    values (for example, add a requirement between POOL_SRS_040 and POOL_SRS_041),
    then a decimal fractional number shall be appended to the SRS tag number (for
    example, POOL_SRS_040.5). Any number of decimal point suffixes can be added, if
    needed (for example, POOL_SRS_40.05.02).
  prefs: []
  type: TYPE_NORMAL
- en: '**2 Overall Description**'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose behind the swimming pool monitor (SPM) is to provide an automatic
    system for maintaining water level in the pool. This task is sufficiently simple
    to allow the creation of an SRS that is short enough to fit within this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**2.1 Product Perspective**'
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, an SPM would probably provide many additional features; adding
    those features here would only increase the size of the SRS without providing
    much additional educational benefit. This specification is intentionally simplified
    in order to fit within the editorial requirements of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**2.1.1 System Interfaces**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM design assumes the use of an Arduino-compatible SBC. Accordingly, the
    software will interface to the hardware using Arduino-compatible libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '**2.1.2 User Interfaces**'
  prefs: []
  type: TYPE_NORMAL
- en: The user interface shall consist of a small four-line display (minimum 20 characters/line),
    six push buttons (up, down, left, right, cancel/back, and select/enter), and a
    rotary encoder (rotating knob).
  prefs: []
  type: TYPE_NORMAL
- en: '**2.1.3 Hardware Interfaces**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This document doesn’t specify a particular SBC to use. However, the SBC must
    provide at least the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 16 digital inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 analog input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 digital outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A small amount of nonvolatile, writable memory (for example, EEPROM) to store
    configuration values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A real-time clock (RTC; this can be an external module)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A watchdog timer to monitor the system’s software operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SPM provides pool sensors to determine when the pool level is high or low.
    It also provides a solenoid interface to a water valve, allowing the SPM to turn
    on or off a water source for the pool.
  prefs: []
  type: TYPE_NORMAL
- en: '**2.1.4 Software Interfaces**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM software is self-contained and provides no external interfaces, nor
    does it require any external software interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '**2.1.5 Communication Interfaces**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM is self-contained and does not communicate with the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: '**2.1.6 Memory Constraints**'
  prefs: []
  type: TYPE_NORMAL
- en: As the SPM is running on an Arduino-compatible SBC, there will be (severe) memory
    constraints, depending on the exact model chosen (for example, an Arduino Mega
    2560 SBC provides only 8KB of static RAM on board).
  prefs: []
  type: TYPE_NORMAL
- en: '**2.1.7 Operations**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM operates in an *always-on* mode, monitoring the pool 24/7/365\. Therefore,
    the module itself should not consume excessive electrical power. It will, however,
    be connected to line voltage via a power supply, so extreme low-power operation
    is unnecessary. It will constantly monitor the pool’s water level and automatically
    turn on a water source if the pool level is low. To avoid flooding if there is
    a sensor failure, the SPM will limit the amount of water introduced to the pool
    on a daily basis (time limit is user-selectable).
  prefs: []
  type: TYPE_NORMAL
- en: '**2.2 Site Adaptation Requirements**'
  prefs: []
  type: TYPE_NORMAL
- en: For this particular variant of the SPM, there is little in the way of site adaptation
    requirements. There are no optional sensors or operations and the only interfaces
    outside the SPM itself is a source of power for the system and a water source
    (interfaced via the solenoid valve).
  prefs: []
  type: TYPE_NORMAL
- en: '**2.3 Product Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The product shall use seven water-level sensors to determine the pool level:
    three digital sensors that provide a *low-pool* indication, three digital sensors
    that provide a *high-pool* indication, and an analog sensor that provides a pool
    level depth indication (perhaps only a couple inches or centimeters in range).
    The three low-pool digital sensors are active when the water level is at the level
    of the sensor. The system will begin filling the pool when there is a low-pool
    indication. To avoid flooding when a sensor fails, the three sensors operate in
    a *two out of three* configuration, meaning at least two sensors must indicate
    a low-pool condition before the SPM will attempt to fill the pool. The three high-pool
    sensors work in a likewise fashion when the SPM should stop filling the pool (water
    level is high). The analog sensor provides a small range of depth; the SPM will
    use the analog sensor as a backup to verify that the pool level is low prior to
    filling the pool. The SPM will also use the analog sensor to determine that the
    pool is actually filling while the SPM has turned on the water source.'
  prefs: []
  type: TYPE_NORMAL
- en: '**2.4 User Characteristics**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of SPM users: technicians and end users. A technician is
    responsible for installing and adjusting the SPM. An end user is the pool’s owner
    who uses the SPM on a day-to-day basis.'
  prefs: []
  type: TYPE_NORMAL
- en: '**2.5 Constraints**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM should be carefully designed to prevent inadvertent flooding and excessive
    water use. In particular, the software must be robust enough to determine that
    the pool is not being properly filled and to cease attempting to fill the pool
    if the sensors do not indicate proper operation. Should any sensor fail, the software
    should be smart enough to avoid blindly keeping the water turned on (which could
    lead to flood damage). For example, if the SPM is attached to an aboveground pool
    and that pool has a leak, it might not ever be possible to fill the pool. The
    software should handle such situations.
  prefs: []
  type: TYPE_NORMAL
- en: The system should be fail-safe insofar as a power failure should automatically
    shut off the water valve. A watchdog timer of some sort should also check that
    the software is operating properly and turn off the water valve if a timeout occurs
    (for example, should the software hang up).
  prefs: []
  type: TYPE_NORMAL
- en: To avoid flooding because of a malfunctioning relay, the SPM should use two
    relays in series to open the water valve. Both relays must be actuated by the
    software in order to turn on the solenoid valve.
  prefs: []
  type: TYPE_NORMAL
- en: '**2.6 Assumptions and Dependencies**'
  prefs: []
  type: TYPE_NORMAL
- en: The requirements in this document assume that the SBC contains sufficient resources
    (computing power) to handle the task and that the device can reasonably operate
    in a 24/7/365 real-time environment.
  prefs: []
  type: TYPE_NORMAL
- en: '**2.7 Apportioning of Requirements**'
  prefs: []
  type: TYPE_NORMAL
- en: These requirements define a very simple swimming pool monitor for the purposes
    of demonstrating a complete SRS. As this is a minimal requirement set for a very
    small SPM, the assumption is that a product built around these requirements would
    implement all of them. A real product would probably include many additional features
    beyond those listed here, with a corresponding increase in the number of requirements
    appearing in this document.
  prefs: []
  type: TYPE_NORMAL
- en: '**3 Specific Requirements**'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1 External Interfaces**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_001]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall provide a digital input for the navigation *up* button.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_002]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall provide a digital input for the navigation *down* button.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_003]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall provide a digital input for the navigation *left* button.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_004]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall provide a digital input for the navigation *right* button.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_005]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall provide a digital input for the *cancel/back* button.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_006]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall provide a digital input for the *select/enter* button.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_007]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall provide four digital inputs for the rotary encoder (quadrature)
    input.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_008.01]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall provide a digital input for the primary *water level low* sensor.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_008.02]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall provide a digital input for the secondary *water level low* sensor.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_008.03]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall provide a digital input for the tertiary *water level low* sensor.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_009.01]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall provide a digital input for the primary *water level high* sensor.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_009.02]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall provide a digital input for the secondary *water level high* sensor.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_009.03]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall provide a digital input for the tertiary *water level high* sensor.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_011]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall provide an analog input (minimum 8-bit resolution) for the water
    level sensor.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_012]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall provide two digital outputs to control the water source solenoid
    valve.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.2 Functional Requirements**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_013]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall allow the user to set the RTC date and time via the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_014]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall have a maximum fill time, specifying the maximum amount of time
    (hours:mins) that the water valve can be actuated during a 24-hour period.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_015]**'
  prefs: []
  type: TYPE_NORMAL
- en: The user shall be able to set the maximum fill time from the SPM user interface
    (using the navigation and enter buttons).
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_015.01]**'
  prefs: []
  type: TYPE_NORMAL
- en: Once the user has selected the maximum fill time from the user interface, the
    user shall be able to select the hours or minutes fields using the navigation
    buttons.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_015.02]**'
  prefs: []
  type: TYPE_NORMAL
- en: The user shall be able to independently set the maximum fill-time hours value
    using the rotary encoder after selecting the hours field.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_015.03]**'
  prefs: []
  type: TYPE_NORMAL
- en: The user shall be able to independently set the maximum fill-time minutes value
    using the rotary encoder after selecting the minutes field.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_015.04]**'
  prefs: []
  type: TYPE_NORMAL
- en: The software shall not allow a maximum fill time of greater than 12 hours.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_016]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall check the pool level once every 24 hours, at a specific time,
    to determine if it needs to add water to the pool.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_017]**'
  prefs: []
  type: TYPE_NORMAL
- en: The user shall be able to set the time the SPM checks the pool level (and, therefore,
    when the SPM fills the pool) from the SPM user interface.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_017.01]**'
  prefs: []
  type: TYPE_NORMAL
- en: Once the user has selected the pool-level check time from the user interface,
    the user shall be able to select the hours or minutes fields using the navigation
    buttons.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_017.02]**'
  prefs: []
  type: TYPE_NORMAL
- en: The user shall be able to independently set the pool-level check-time hours
    value using the rotary encoder after selecting the hours field.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_017.03]**'
  prefs: []
  type: TYPE_NORMAL
- en: The user shall be able to independently set the pool-level check-time minutes
    value using the rotary encoder after selecting the minutes field.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_017.04]**'
  prefs: []
  type: TYPE_NORMAL
- en: The default (factory reset) pool check time shall be 1:00 AM.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_018]**'
  prefs: []
  type: TYPE_NORMAL
- en: At the pool check time each day, the system shall read the three *pool level
    low* sensors and begin a pool fill operation if at least two of the three sensors
    indicate a pool low condition.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_018.01]**'
  prefs: []
  type: TYPE_NORMAL
- en: During a pool fill operation the software shall accumulate a running *fill time*.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_018.02]**'
  prefs: []
  type: TYPE_NORMAL
- en: During a pool fill operation if the running fill time exceeds the maximum fill
    time, the software shall cease the pool fill operation.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_018.03]**'
  prefs: []
  type: TYPE_NORMAL
- en: During a pool fill operation the software shall read the *pool level high* sensors
    and cease the pool fill operation if at least two of the three sensors indicate
    a high pool level.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_018.04]**'
  prefs: []
  type: TYPE_NORMAL
- en: During a pool fill operation the software shall read the analog pool-level sensor
    and shut off the water flow if the level isn’t increasing after each half-hour
    of operation.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_019]**'
  prefs: []
  type: TYPE_NORMAL
- en: The software shall allow the user to select a *manual pool* fill mode that turns
    on the water source to the pool.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_019.01]**'
  prefs: []
  type: TYPE_NORMAL
- en: The software shall allow the user to select an *auto pool* fill mode that turns
    off the manual pool fill mode.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_019.02]**'
  prefs: []
  type: TYPE_NORMAL
- en: In the manual pool fill mode, the software shall ignore the maximum fill time.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_019.03]**'
  prefs: []
  type: TYPE_NORMAL
- en: In the manual pool fill mode, the software shall ignore the *pool level high*
    and *pool level low* sensors (filling stops when the user turns off the manual
    fill mode).
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_020]**'
  prefs: []
  type: TYPE_NORMAL
- en: The software shall update the system watchdog timer at least twice as frequently
    as the watchdog timeout period.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_020.01]**'
  prefs: []
  type: TYPE_NORMAL
- en: The watchdog timeout period shall be no less than 5 seconds and no greater than
    60 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3 Performance Requirements**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_001.00.01]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall debounce all button inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_007.00.01]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall be capable of reading the rotary encoder inputs without losing
    any changes on the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_015.00.01]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall maintain an accuracy of at least one minute for the maximum pool
    fill time.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_017.00.01]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall maintain an accuracy of at least one minute for the pool level
    check time.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.4 Logical Database Requirements**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_014.00.01]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall store the maximum fill time in nonvolatile memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SRS_016.00.01]**'
  prefs: []
  type: TYPE_NORMAL
- en: The SPM shall store the pool check time in nonvolatile memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.5 Design Constraints**'
  prefs: []
  type: TYPE_NORMAL
- en: '[None]'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.6 Standards Compliance**'
  prefs: []
  type: TYPE_NORMAL
- en: '[None]'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.7 Software System Attributes**'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.7.1 Reliability**'
  prefs: []
  type: TYPE_NORMAL
- en: The software will run 24/7/365\. Therefore, robustness is a critical factor
    in system design. In particular, the system should be fail-safe insofar as a software
    or other failure should result in the closure of the water valve.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.7.2 Availability**'
  prefs: []
  type: TYPE_NORMAL
- en: The software should be running continuously (24/7/365). The software must not
    be subject to counter overflows or other problems associated with long-term execution.
    The end user should expect at least 99.99 percent uptime.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.7.3 Security**'
  prefs: []
  type: TYPE_NORMAL
- en: There are no security requirements for the system (closed, disconnected, air-gapped
    system).
  prefs: []
  type: TYPE_NORMAL
- en: '**3.7.4 Maintainability**'
  prefs: []
  type: TYPE_NORMAL
- en: There are no maintainability requirements other than those customarily expected
    of a professional software engineering project.
  prefs: []
  type: TYPE_NORMAL
- en: That said, this is a bare-bones requirements document. Should someone actually
    build this system, one would expect future enhancements. Thus, the system should
    be designed and implemented with such expectations in mind.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.7.5 Portability**'
  prefs: []
  type: TYPE_NORMAL
- en: The software is expected to run on an Arduino-class device. No portability requirements
    exist other than the possibility of selecting different Arduino-compatible modules
    (for example, Arduino Mega 2560 versus Teensy 4.0) during implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.8 Design Goals**'
  prefs: []
  type: TYPE_NORMAL
- en: None for this project.
  prefs: []
  type: TYPE_NORMAL
- en: '**4 Appendixes**'
  prefs: []
  type: TYPE_NORMAL
- en: '[None]'
  prefs: []
  type: TYPE_NORMAL
- en: '**5 Index**'
  prefs: []
  type: TYPE_NORMAL
- en: Given the (small) size of this SRS, no index appears here in order to reduce
    page count for this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.5 Creating Requirements**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up to this point this chapter has defined requirements as well as requirements
    documentation. But you might be asking, “How does someone come up with the requirements
    in the first place?” This section will provide some insight into that question.
  prefs: []
  type: TYPE_NORMAL
- en: The modern approach to requirements creation involves use cases, which were
    introduced in [Chapter 4](ch04.xhtml). The system architect studies how an end
    user would use a system (the user story) and creates a set of scenarios (use cases)
    from that study. Each use case becomes the basis for a set of one or more requirements.
    This section departs from the swimming pool monitor scenario to consider an example
    from a real-world system, the Plantation Productions *digital data acquisition
    and control (DAQ) system*.^([2](ch19_footnote.xhtml#ch10fn2))
  prefs: []
  type: TYPE_NORMAL
- en: The DAQ system consists of multiple interconnecting circuit boards, including
    analog I/O boards, digital I/O boards, digital output boards (relay boards), and
    an SBC, the Netburner MOD54415, that runs the system firmware. These components
    allow a system designer to read various analog and digital inputs, compute results
    and make decisions based on those inputs, and then control external devices by
    sending digital and analog output values to those devices. For example, the DAQ
    system was originally designed to control a TRIGA^([3](ch19_footnote.xhtml#ch10fn3))
    research reactor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The firmware requirements for the DAQ system are too large to duplicate here,
    so this chapter will limit the discussion to certain I/O initialization that must
    take place when the system first powers up. The Netburner MOD54415 includes a
    set of eight DIP switches, which the DAQ system uses to initialize various system
    components. These DIP switches do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable/disable RS-232 port command processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable/disable USB port command processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable/disable Ethernet port command processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify one Ethernet connection or five simultaneous Ethernet connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify one of four different Ethernet addresses using two DIP switches; see
    [Table 10-1](ch10.xhtml#ch10tab1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable/disable test mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable/disable debug output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Table 10-1:** Ethernet Address Selection'
  prefs: []
  type: TYPE_NORMAL
- en: '| **DIP switch A** | **DIP switch A + 1** | **Ethernet address** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 192.168.2.70 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 192.168.2.71 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 192.168.2.72 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 192.168.2.73 |'
  prefs: []
  type: TYPE_TB
- en: 'One final thing to note about the DAQ software initialization: debug output
    uses the Netburner COM1: port. The Netburner shares this serial port hardware
    with the USB port. There is a conflict if the user enables both the debug output
    and the USB command ports. Therefore, to enable the debug port, two conditions
    must be met: debug output must be enabled and USB port command processing must
    be disabled.'
  prefs: []
  type: TYPE_NORMAL
- en: To enable commands from the RS-232 or USB ports, the software must read the
    switches. If the particular switch indicates that the command stream is active,
    then the software must create a new task^([4](ch19_footnote.xhtml#ch10fn4)) to
    handle input from that port. The newly created task is responsible for reading
    characters from the given port and sending entire lines of text to the system’s
    command processor upon receiving a newline character. If the corresponding DIP
    switches are in the disabled position, the software won’t create the RS-232 or
    USB tasks, and the system will ignore these ports.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Ethernet commands is slightly more complicated. There are four DIP
    switches associated with the Ethernet port. The Ethernet initialization operation
    must consider the settings for all four DIP switches.
  prefs: []
  type: TYPE_NORMAL
- en: One DIP switch controls the number of concurrent clients the DAQ software supports.
    In one position, the DAQ software supports only a single Ethernet client; in the
    other position, the software supports up to five Ethernet clients. In some environments,
    you might need to allow multiple host computers to access the data acquisition
    and control hardware; for example, while debugging you may want to have a test
    computer monitoring the operations. In some secure applications (after deployment),
    you may want to limit access to the DAQ system to a single computer.
  prefs: []
  type: TYPE_NORMAL
- en: The third and fourth Ethernet DIP switches allow an operator to select one of
    four separate IP/Ethernet addresses. This allows control of up to four separate
    Netburner modules in the same system. As noted in [Table 10-1](ch10.xhtml#ch10tab1),
    the four selectable Ethernet addresses are 192.168.2.70 through 192.168.2.73 (the
    requirements could be changed to support different IP addresses, of course, but
    these were convenient addresses for the initial DAQ system that was built).
  prefs: []
  type: TYPE_NORMAL
- en: '**10.6 Use Cases**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given the preceding user story, the next step is to build a set of use cases
    that describe these operations. Remember, use cases are more than a few UML diagrams—they
    also include a descriptive narrative (see “[Use Case Narratives](ch04.xhtml#lev-4.2.6)”
    on [page 80](ch04.xhtml#page_80)).
  prefs: []
  type: TYPE_NORMAL
- en: '**Actors** There is a single actor in the following use cases, the *System
    User*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Triggers** In all of the following use cases, the trigger that activates
    each use case is system boot. The system reads the DIP switch settings at boot
    time and initializes based on those settings (see [Figure 10-1](ch10.xhtml#ch10fig1)).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenarios/Flow of Events** These are the activities that occur for a given
    use case.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Associated Requirements** The Associated Requirements provide cross-references
    to the DAQ System SRS. The requirements appear in the following sections (see
    “(Selected) DAQ Software Requirements (from SRS)” on [page 219](ch10.xhtml#page_219)).
    You must create the requirements *before* filling in this section; otherwise,
    you’d simply be guessing at the requirements you’ll need.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-1: Read DIP switches use case*'
  prefs: []
  type: TYPE_NORMAL
- en: '***10.6.1 Enable/Disable Debug Mode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Goal** Enabling and disabling debug output on DAQ system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Precondition** System has booted.'
  prefs: []
  type: TYPE_NORMAL
- en: '**End condition** Debug mode is active or inactive, as appropriate.'
  prefs: []
  type: TYPE_NORMAL
- en: '**10.6.1.1 Scenarios/Flow of Events**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Enable/Disable Debug Mode
  prefs: []
  type: TYPE_NORMAL
- en: During system initialization, read DIP switches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the value of DIP switch 8 (`on` = debug mode on, `off` = debug mode off).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Debug mode is enabled if DIP switch 8 is `on` and DIP switch 2 (USB mode) is
    `off`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the `maintPrintf` task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**10.6.1.2 Associated Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'DAQ_SRS_721_001: PPDAQ Debug Mode Enabled'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAQ_SRS_721_002: PPDAQ Debug Mode Disabled'
  prefs: []
  type: TYPE_NORMAL
- en: '***10.6.2 Enable/Disable Ethernet***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Goal** Enabling and disabling Ethernet command processing on DAQ system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Precondition** System has booted.'
  prefs: []
  type: TYPE_NORMAL
- en: '**End condition** Ethernet communication is active or inactive, as appropriate.
    If active, Ethernet input processing tasks are running.'
  prefs: []
  type: TYPE_NORMAL
- en: '**10.6.2.1 Scenarios/Flow of Events**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Enable/Disable Ethernet
  prefs: []
  type: TYPE_NORMAL
- en: 1\. During system initialization, read DIP switches.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Use the value of DIP switch 3 to determine if Ethernet is enabled (switch
    is `on`) or disabled (switch is `off`).
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Save the value of DIP switch 4 to determine if the system supports one connection
    (switch is `off`) or five concurrent connections (switch is `on`).
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Use the values of DIP switches 5 and 6 to determine the IP address.
  prefs: []
  type: TYPE_NORMAL
- en: '5\. If Ethernet is enabled (DIP switch 3 is `on`), then:'
  prefs: []
  type: TYPE_NORMAL
- en: '5.1 Set the Ethernet address based on the value of DIP switches 5 and 6 as:'
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.1 192.168.2.70
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.2 192.168.2.71
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.3 192.168.2.72
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4 192.168.2.73
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Start the `ethernetListenTask` task with priority `ETHL_PRIO`.
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Else (if Ethernet is not enabled):'
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 Do not start the `ethernetListenTask`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ethernetListenTask`'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Initialize an array of five descriptors with zero elements (empty descriptor
    slots).
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Wait for an external connection request on Ethernet socket 0x5050.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. If a connection request is made:'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Search for an empty slot (array element containing zero) in the descriptor
    array.
  prefs: []
  type: TYPE_NORMAL
- en: '3.2 If there are no slots available:'
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.1 Refuse connection.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.2 Go to step 2.
  prefs: []
  type: TYPE_NORMAL
- en: '3.3 Else if a slot is available:'
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.1 Accept connection and store its file descriptor in the available slot.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.2 Create a new Ethernet command task associated with the new connection;
    the priority of the new task shall be `ETH1_PRIO` through `ETH5_PRIO`, selected
    by the index into the descriptor slot array; note that `SER_PRIO` < `ETHL_PRIO`
    < `ETH1_PRIO` to `ETH5_PRIO` < `USB_PRIO` (where smaller numbers mean the task
    has a higher priority in the task queue).
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.3 Go to step 2.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Else if the listen connection is broken, terminate listen task.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.6.2.2 Associated Requirements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'DAQ_SRS_708_000: PPDAQ Ethernet IP Address'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAQ_SRS_709_000: PPDAQ Ethernet IP Address 192.168.2.70'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAQ_SRS_710_000: PPDAQ Ethernet IP Address 192.168.2.71'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAQ_SRS_711_000: PPDAQ Ethernet IP Address 192.168.2.72'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAQ_SRS_712_000: PPDAQ Ethernet IP Address 192.168.2.73'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAQ_SRS_716_000: PPDAQ Ethernet Enabled'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAQ_SRS_716.5_000: PDAQ Ethernet Disabled'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAQ_SRS_716_001: PPDAQ Ethernet Task'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAQ_SRS_716_002: PPDAQ Ethernet Task Priority'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAQ_SRS_717_000: PPDAQ Ethernet Port'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAQ_SRS_718_000: PPDAQ Ethernet Multiple Clients Enabled'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAQ_SRS_718_001: PPDAQ Ethernet Multiple Clients Disabled'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAQ_SRS_728_000: PPDAQ Command Source #3'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAQ_SRS_737_000: PPDAQ Maximum Ethernet Connections #1'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAQ_SRS_738_000: PPDAQ Maximum Ethernet Connections #2'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAQ_SRS_738_001: PPDAQ Ethernet Command Processing Tasks'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAQ_SRS_738_002: PPDAQ Ethernet Command Task Priorities'
  prefs: []
  type: TYPE_NORMAL
- en: '***10.6.3 Enable/Disable RS-232***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: (Similar to the previous use cases; deleted for brevity.)
  prefs: []
  type: TYPE_NORMAL
- en: '***10.6.4 Enable/Disable Test Mode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: (Similar to the previous use cases; deleted for brevity.)
  prefs: []
  type: TYPE_NORMAL
- en: '***10.6.5 Enable/Disable USB***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: (Similar to the previous use cases; deleted for brevity.)
  prefs: []
  type: TYPE_NORMAL
- en: '***10.6.6 Read DIP Switches***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: (Similar to the previous use cases; deleted for brevity.)
  prefs: []
  type: TYPE_NORMAL
- en: '**10.7 Creating DAQ Software Requirements from the Use Cases**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Converting an informal use case to a formal requirement consists of extracting
    the information from a use case, filling in missing details, and structuring the
    result in the form of a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the use case for “Enable/Disable Debug Mode.” You might be tempted
    into thinking this use case generates a single requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall operate in a special debug mode if the Netburner DIP
    switch 8 is set to the ON position and USB (DIP switch 2) is not enabled; it shall
    operate in a non-debug mode if switch 8 is in the OFF position or DIP switch 2
    is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that this is actually two separate requirements—not because
    of the “and” and “or” components (you’ll see why in a moment), but because of
    the semicolon separating the two clauses. The two separate requirements are:'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall operate in a special debug mode if the Netburner DIP
    switch 8 is set to the ON position and USB (DIP switch 2) is not enabled.
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall operate in a non-debug mode if switch 8 is in the OFF
    position or DIP switch 2 is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the “and USB” and “or DIP switch 2” phrases do not imply that these
    requirements must be split into two separate requirements each. The clause “if
    the Netburner DIP switch 8 is set to the ON position and USB (DIP switch 2) is
    not enabled” is actually a logical phrase that is part of the *trigger* for this
    requirement. Technically, the requirement should probably be reworded.
  prefs: []
  type: TYPE_NORMAL
- en: If the Netburner DIP switch 8 is set to the ON position and USB (DIP switch
    2) is not enabled, then the PPDAQ software shall operate in a special debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: This moves the trigger clause to the beginning of the requirement, as suggested
    in section “[A Suggested Requirements Format](ch10.xhtml#lev-10.1.1)” on [page
    186](ch10.xhtml#page_186). Note, however, that this is simply a suggested format;
    it’s not unreasonable to place the trigger condition after the actor (PPDAQ software),
    action (operate), and object (debug mode).
  prefs: []
  type: TYPE_NORMAL
- en: The next section provides a listing of various requirements from the DAQ software
    system. It gives an example of how the DAQ requirements were generated from the
    use cases. You should be able to fill in the details for the remaining requirements
    on your own.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.8 (Selected) DAQ Software Requirements (from SRS)**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The actual DAQ SRS (not the `POOL_SRS` presented in “A Sample Software Requirements
    Specification” on [page 203](ch10.xhtml#page_203)) contains hundreds of requirements;
    to keep the size of this chapter reasonable, I’ve selected the following requirements
    as they are representative of those needed to support the DIP switch use cases
    shown earlier. Note that the tags for these SRS requirements take the form [DAQ_SRS_*xxx_yyy*]
    because the actual DAQ system requirements have an SyRS as well as an SRS.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The DAQ SRS document puts all requirements in section 3, as is the case for
    all SRSes. That is why the following section numbers revert to 3 rather than continuing
    the paragraph numbering of this chapter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.1 PPDAQ Standard Software Platform**'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.15 PPDAQ Ethernet IP Address**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_708_000]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall set the Ethernet IP address to a value in the range
    192.168.2.70–192.168.2.73 based on DIP switch 5–6 settings on the Netburner.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.16 PPDAQ Ethernet IP Address 192.168.2.70**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_709_000]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall set the Ethernet IP address to 192.168.2.70 if the
    Netburner DIP switches 5–6 are set to (OFF, OFF).
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.17 PPDAQ Ethernet IP Address 192.168.2.71**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_710_000]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall set the Ethernet IP address to 192.168.2.71 if the
    Netburner DIP switches 5–6 are set to (ON, OFF).
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.18 PPDAQ Ethernet IP Address 192.168.2.72**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_711_000]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall set the Ethernet IP address to 192.168.2.72 if the
    Netburner DIP switches 5–6 are set to (OFF, ON).
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.19 PPDAQ Ethernet IP Address 192.168.2.73**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_712_000]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall set the Ethernet IP address to 192.168.2.73 if the
    Netburner DIP switches 5–6 are set to (ON, ON).
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.20 PPDAQ Ethernet Enabled**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_716_000]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall enable Ethernet operation if the Netburner DIP switch
    3 is in the ON position.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.21 PPDAQ Ethernet Disabled**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_716.5_000]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall disable Ethernet operation if the Netburner DIP switch
    3 is in the OFF position.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.22 PPDAQ Ethernet Task**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_716_001]**'
  prefs: []
  type: TYPE_NORMAL
- en: The Ethernet listening task shall be started if Ethernet communications are
    enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.23 PPDAQ Ethernet Task Priority**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_716_002]**'
  prefs: []
  type: TYPE_NORMAL
- en: The Ethernet listening task shall have a priority lower than the USB task but
    higher than the serial task.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.24 PPDAQ Ethernet Port**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_717_000]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall communicate via Ethernet using socket port 0x5050 (decimal
    20560, ASCII *PP*, for *Plantation Productions*).
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.25 PPDAQ Ethernet Multiple Clients Enabled**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_718_000]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall allow up to five Ethernet clients if the Netburner
    DIP switch 4 is set to the ON position.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.26 PPDAQ Ethernet Multiple Clients Disabled**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_718_001]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall allow only a single Ethernet client if the Netburner
    DIP switch 4 is set to the OFF position.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.29 PPDAQ Unit Test Mode I/O**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_721_000]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall utilize the UART0 serial port on the Netburner MOD54415
    MOD-70 evaluation board for unit test communication unless USB commands are enabled
    (USB commands share the same serial port [UART0] as the test mode output).
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.30 PPDAQ Debug Mode Enabled**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_721_001]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall operate in a special *debug* mode if the Netburner
    DIP switch 8 is set to the ON position and USB (DIP switch 2) is not enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.31 PPDAQ Debug Mode Disabled**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_721_002]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall operate in the normal (nondebug) mode if the Netburner
    DIP switch 8 is set to the OFF position.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.38 PPDAQ Command Source #3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_728_000]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall accept commands from the Ethernet port on the Netburner
    MOD54415 MOD-70 evaluation board if Ethernet communications are enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.40 PPDAQ Maximum Ethernet Connections #1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_737_000]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall only recognize a single connection on the Ethernet
    port if the Netburner DIP switch 4 is in the OFF position.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.41 PPDAQ Maximum Ethernet Connections #2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_738_000]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall only recognize up to five connections on the Ethernet
    port if the Netburner DIP switch 4 is in the ON position.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.42 PPDAQ Ethernet Command Processing Tasks**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_738_001]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall start a new process to handle command processing for
    each connection.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.1.1.43 PPDAQ Ethernet Command Task Priorities**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_738_002]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ command processing tasks shall each have a different priority that
    is higher than the priority of the Ethernet listening task and less than the priority
    of the USB command task.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.9 Updating the Traceability Matrix with Requirement Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The SyRS and SRS requirements typically add four to six columns to the RTM:
    Description, SyRS tag (if you have an SyRS), Allocations, SRS tag, and Test/verification
    type. The Description column provides a brief description of the requirement,
    such as *PPDAQ Standard Software Platform* from requirement DAQ_SRS_700_000 in
    the previous section. (Note that this does *not* refer to the POOL_SRS tag presented
    in “A Sample Software Requirements Specification” on [page 203](ch10.xhtml#page_203).)'
  prefs: []
  type: TYPE_NORMAL
- en: The SyRS and SRS tag columns contain the actual SyRS (if present) and SRS tag
    identifiers. Generally, you would sort the rows in the RTM by SyRS (primary key)
    and then SRS (secondary key) unless there are no SyRS tags, in which case you’d
    simply sort the rows by the SRS tag.
  prefs: []
  type: TYPE_NORMAL
- en: The Allocations column specifies whether the requirement is hardware (*H*),
    software (*S*), other (*O*), or a combination of these. Typically, only SyRS requirements
    have hardware-only allocations; after all, SRS requirements are *software* requirements.
    It is possible, however, for an SRS requirement to have an *HS* allocation if
    it covers both software and hardware aspects of the system. The *other* designation
    is a catch-all to cover requirements that don’t clearly fit into a hardware or
    software category (this could describe a manual process, for example).
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you don’t have an SyRS, or all of your requirement allocations
    are software allocations, you can eliminate the Allocations column; this can help
    reduce the size and complexity of the RTM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Verification type column in the RTM specifies how you will verify (test)
    this requirement in the system. Possible entries are: *by test* (*T*); *by review*
    (*R*); *by inspection* (*I*; the “by review” variant for hardware designs); *by
    design* (*D*; usually applies to hardware, not software); *by analysis* (*A*);
    *other* (*O*); and *no test, or no test possible* (*N*).'
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, requirements that have a *T* verification method will have some associated
    test to run to verify the requirement. This generally means that you will have
    a corresponding test case for this requirement and a test procedure to execute
    it.
  prefs: []
  type: TYPE_NORMAL
- en: It may be difficult, impractical, or dangerous to test certain requirements.^([5](ch19_footnote.xhtml#ch10fn5))
    In these situations it may be much easier to carefully review the code to verify
    that it will behave properly. For such requirements, the verification method would
    be *R*, by review.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *by analysis* (*A*) verification method means that somewhere you are offering
    a formal (mathematical) proof that the software meets the formal requirement.
    This is a much more stringent process than *by review* and a subject that is well
    beyond the scope of this book. Nevertheless, this type of verification may be
    necessary for certain requirements whose failure could lead to catastrophic events
    (such as death). Consider the very first requirement from “(Selected) DAQ Software
    Requirements (from SRS)” on [page 219](ch10.xhtml#page_219):'
  prefs: []
  type: TYPE_NORMAL
- en: '**[DAQ_SRS_700_000]**'
  prefs: []
  type: TYPE_NORMAL
- en: The PPDAQ software shall run on a Netburner MOD54415 MOD-70 evaluation board
    connected to a DAQ_IF interface board.
  prefs: []
  type: TYPE_NORMAL
- en: It would be somewhat difficult to come up with an actual test that proves this
    requirement is being met (other than installing the software on a Netburner MOD54415
    and verifying that it actually runs). On the other hand, it’s nearly trivial to
    look at the source code (and the build files) and verify that this code was written
    for the Netburner MOD54415\. A *test by review* is easily the most appropriate
    way to handle this particular requirement.
  prefs: []
  type: TYPE_NORMAL
- en: The *other* verification method is a catch-all category that implies you’re
    going to provide the documentation to justify either the lack of a testing method
    or the verification approach you plan to use.
  prefs: []
  type: TYPE_NORMAL
- en: The *no test* or *no test possible* verification requires you to justify why
    a test is not needed. If you are specifying *N* to represent *no test possible*,
    you should carefully consider whether the requirement is valid (is an actual requirement).
    Remember, if it can’t be tested, it isn’t a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: These are the four column entries that [DAQ_SRS_700_000] would add to the RTM.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Description** | **SRS tag** | **Allocation** | **Verification** |'
  prefs: []
  type: TYPE_TB
- en: '| PPDAQ Standard Software Platform | DAQ_SRS_700_000 | HS | R |'
  prefs: []
  type: TYPE_TB
- en: 'Given the requirements in “(Selected) DAQ Software Requirements (from SRS)”
    on [page 219](ch10.xhtml#page_219), we can divide the requirements into two groups:
    those whose verification type should be *by test* and those whose verification
    type should be *by review* (because an actual test for them might be difficult
    to perform or awkward to create).'
  prefs: []
  type: TYPE_NORMAL
- en: '***10.9.1 Requirements to Be Verified by Review***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Table 10-2](ch10.xhtml#ch10tab2) shows a list of the requirements from “(Selected)
    DAQ Software Requirements (from SRS)” on [page 219](ch10.xhtml#page_219) that
    should be verified by review and should provide a justification for the choice
    that has been made.^([6](ch19_footnote.xhtml#ch10fn6))'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 10-2:** DAQ Software Requirement Justifications'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Requirement** | **Justification** |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_700_000 | Although you could argue that running the software on a
    Netburner verifies that it runs on a Netburner, reviewing the make/build files
    is an easier and more practical way to verify this requirement. |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_700_000.01 | Although you could argue that running the software on
    a μC/OS verifies that it runs under μC/OS, reviewing the make/build files is an
    easier and more practical way to verify this requirement. |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_702_001 | Writing a test to show that a separate process is running
    would be difficult without actually changing the code (i.e., to print some output
    to show this). However, reviewing the code to see that it is starting a new task
    to handle RS-232 communication isn’t that difficult. |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_702_002 | Writing a test to show that the RS-232 process is running
    at a particular priority level would require modifying the code; reviewing the
    code is easier. |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_703_001 | Making this one by review is arguable. You could argue
    that if the system is accepting RS-232 commands, the task is running. However,
    this does not prove that a separate task is running or not running (the main task
    could be processing the commands). Hence, this should probably be a by review
    verification. |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_705_001 | The same argument applies as for DAQ_SRS_702_001 (just
    applied to the USB input task). |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_705_002 | Same justification as for DAQ_SRS_702_002. |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_706_001 | Same argument as for DAQ_SRS_705_001 (just the complement
    of that requirement). |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_716_001 | Same argument as for DAQ_SRS_702_001 (just applied to the
    Ethernet listen task). |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_716_002 | Same argument as for DAQ_SRS_702_002 (just applied to the
    Ethernet listen task priority). |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_719_000 | Currently, unit test mode is undefined on the DAQ system
    so there is no way to test that the system has entered this mode. Reviewing the
    code verifies that the internal variable is properly set up (the only effect the
    DIP switch will have). |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_720_000 | See DAQ_SRS_719_000. |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_723_000 | Another arguable case. The fact that the system is reading
    the DIP switches (to handle other tests) should be enough to show that the software
    is reading the Netburner switches. However, this requirement is sufficiently unimportant
    that the choice of review/test doesn’t really matter. |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_723_000.01 | See DAQ_SRS_723_000. |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_723_000.02 | See DAQ_SRS_723_000. |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_725_000 | Checking to see that the DAQ responds to a command is no
    big deal (easily testable); however, this requirement states that the DAQ does
    not initiate communication on its own (that is, it’s negatively stated, which,
    in general, is bad in a requirement). Reviewing code is the only proper way to
    handle negative requirements (which is why you want to avoid them). |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_738_001 | Similar justification to DAQ_SRS_702_001. |'
  prefs: []
  type: TYPE_TB
- en: '| DAQ_SRS_738_002 | Similar justification to DAQ_SRS_702_002. |'
  prefs: []
  type: TYPE_TB
- en: '***10.9.2 Requirements to Be Verified by Testing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All requirements in “(Selected) DAQ Software Requirements (from SRS)” on [page
    219](ch10.xhtml#page_219) that are not also listed in “Requirements to Be Verified
    by Review” on [page 223](ch10.xhtml#page_223) will be verified using test cases
    and test procedures.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.10 For More Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'IEEE. “IEEE Standard 830-1998: IEEE Recommended Practice for Software Requirements
    Specifications.” October 20, 1998\. *[https://doi.org/10.1109/IEEESTD.1998.88286](https://doi.org/10.1109/IEEESTD.1998.88286)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Leffingwell, Dean, and Don Widrig. *Managing Software Requirements*. Boston:
    Addison-Wesley Professional, 2003.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wiegers, Karl E. *Software Requirements*. Redmond, WA: Microsoft Press, 2009.'
  prefs: []
  type: TYPE_NORMAL
- en: '———. “Writing Quality Requirements.” *Software Development* 7, no. 5 (May 1999):
    44–48.'
  prefs: []
  type: TYPE_NORMAL
