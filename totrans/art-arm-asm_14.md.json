["```\nmov v0, v1  // Generates a syntax error\n```", "```\nmov V`n`.B[`i`], W`m`  // Inserts LO byte of W`m` into V`n`[`i`] (`i` = 0 to 15)\nmov V`n`.H[`i`], W`m`  // Inserts LO hword of W`m` into V`n`[`i`] (`i` = 0 to 7)\nmov V`n`.S[`i`], W`m`  // Inserts W`m` into V`n`[`i`] (`i` = 0 to 3)\n```", "```\nmov v0.b[15], w0  // Copy LO byte of W0 into lane 15 of V0.\nmov v1.h[0], w2   // Copy LO hword of W2 into lane 0 of W1.\nmov v2.s[2], w1   // Copy W1 into lane 2 of V2.\n```", "```\nmov V`n`.D[`i`], X`m`   // Inserts X`m` into V`n`[`i`] (`i` = 0 to 1)\n```", "```\nmov v0.b[4], w0\n```", "```\nmov V`m`.8B, V`n`.8B    // Copy 64 bits.\nmov V`m`.16B, V`n`.16B  // Copy 128 bits.\n```", "```\nmov v0.16b, v1.16b  // Copies V1 to V2\n```", "```\nmov V`m`.B[`i1`], V`n`.B[`i2`]\n```", "```\nmov V`m`.H[`i1`], V`n`.H[`i2`]\n```", "```\nmov V`m`.S[`i1`], V`n`.S[`i2`]  // i1 and i2 must be in range 0 to 3.\nmov V`m`.D[`i3`], V`n`.D[`i4`]  // i3 and i4 must be in range 0 to 1.\n```", "```\nmov v2.d[0], v0.d[0]\nmov v2.d[1], v1.d[0]\n```", "```\nmov  W`n`, V`m`.S[`i0`]  // Copies 32 bits\nmov  X`n`, V`m`.D[`i1`]  // Copies 64 bits\n\numov W`n`, V`m`.B[`i1`]  // Zero-extends byte to 32 bits\numov W`n`, V`m`.H[`i2`]  // Zero-extends hword to 32 bits\numov X`n`, V`m`.D[`i3`]  // Copies 64 bits\n\nsmov W`n`, V`m`.B[`i5`]  // Sign-extends byte to 32 bits\nsmov W`n`, V`m`.H[`i6`]  // Sign-extends hword to 32 bits\nsmov X`n`, V`m`.B[`i5`]  // Sign-extends byte to 64 bits\nsmov X`n`, V`m`.H[`i6`]  // Sign-extends hword to 64 bits\nsmov X`n`, V`m`.S[`i7`]  // Sign-extends word to 64 bits\n```", "```\nmov  w0, v0.s[0]  // Copy lane 0 (word) of V0 to W0.\nmov  x1, v7.d[1]  // Copy lane 1 (dword) of V7 to X1.\numov w0, v1.b[2]  // Copy and zero-extend V1[2] byte to W0.\nsmov x1, v0.s[3]  // Copy and sign-extend V0[3] (word) to X1.\n```", "```\nmovi V`n`.`size`, #`uimm8`\nmovi V`n`.`size`, #`uimm8`, lsl #`c` // `size` = 4H, 8H, 2S, or 4S\nmovi V`n`.`size`, #`uimm8`, msl #`c` // `size` = 2S or 4S\nmovi V`n`.2D, #`uimm64`\nmovi D`n`, #`uimm64`\n```", "```\nmovi v0.8b, #0x80\n```", "```\nmovi v1.4h, #1\n```", "```\nmovi v1.4h, #1, lsl #8\n```", "```\nmovi v3.2s, #1          // Loads 0x0000000100000001 into V3\nmovi v4.2s, #1, lsl #8  // Loads 0x0000010000000100 into V4\nmovi v5.2s, #1, lsl #16 // Loads 0x0001000000010000 into V5\nmovi v6.2s, #1, lsl #24 // Loads 0x0100000001000000 into V6\n```", "```\nmovi v5.2s, #1, msl #16\n```", "```\nmvni V`n`.`size`, #`uimm8` {, (lsl | msl) #`c`}\n```", "```\nmvni v2.4h, #1, lsl #8  // Loads 0xFEFFfeffFEFFfeff into V2\nmvni v4.2s, #2, msl #8  // Loads 0xFFFFFD00fffffd00 into V4\n```", "```\nfmov V`n`.2S, #`fimm`\nfmov V`n`.4S, #`fimm`\nfmov V`n`.2D, #`fimm`\n```", "```\nfmov v0.2s, #1.0  // Loads [0.0, 0.0, 1.0, 1.0] into V0\nfmov v0.2d, #2.0  // Loads [2.0, 2.0] into V0\n```", "```\n 0.1250000  0.1328125   0.1406250   0.1484375\n 0.1562500  0.1640625   0.1718750   0.1796875\n 0.1875000  0.1953125   0.2031250   0.2109375\n 0.2187500  0.2265625   0.2343750   0.2421875\n 0.2500000  0.2656250   0.2812500   0.2968750\n 0.3125000  0.3281250   0.3437500   0.3593750\n 0.3750000  0.3906250   0.4062500   0.4218750\n 0.4375000  0.4531250   0.4687500   0.4843750\n 0.5000000  0.5312500   0.5625000   0.5937500\n 0.6250000  0.6562500   0.6875000   0.7187500\n 0.7500000  0.7812500   0.8125000   0.8437500\n 0.8750000  0.9062500   0.9375000   0.9687500\n 1.00       1.0625      1.125       1.1875\n 1.25       1.3125      1.375       1.4375\n 1.50       1.5625      1.625       1.6875\n 1.75       1.8125      1.875       1.9375\n 2.00       2.1250      2.250       2.3750\n 2.50       2.6250      2.750       2.8750\n 3.00       3.1250      3.250       3.3750\n 3.50       3.6250      3.750       3.8750\n 4.00       4.2500      4.500       4.7500\n 5.00       5.2500      5.500       5.7500\n 6.00       6.2500      6.500       6.7500\n 7.00       7.2500      7.500       7.7500\n 8.0        8.5         9.0         9.5\n10.0       10.5        11.0        11.5\n12.0       12.5        13.0        13.5\n14.0       14.5        15.0        15.5\n16.0       17.0        18.0        19.0\n20.0       21.0        22.0        23.0\n24.0       25.0        26.0        27.0\n28.0       29.0        30.0        31.0\n```", "```\ndup V`n`.2D, X`m`        // Copy X`m` into lanes 0-1 (64 bits each) in V`n`.\n\ndup V`n`.8B, W`m`        // LO 8 bits of W`m` to lanes 0-7 in V`n`\ndup V`n`.16B, W`m`       // LO 8 bits of W`m` to lanes 0-15 in V`n`\n\ndup V`n`.4H, W`m`        // LO 16 bits of W`m` to lanes 0-3 in V`n`\ndup V`n`.8H, W`m`        // LO 16 bits of W`m` to lanes 0-7 in V`n`\n\ndup V`n`.2S, W`m`        // W`m` to lanes 0-1 in V`n`\ndup V`n`.4S, W`m`        // W`m` to lanes 0-3 in V`n`\n\ndup V`n`.8B, V`m`.B[`i1`]  // Dup V`m` lane `i1` through lanes 0-7 in V`n`.\ndup V`n`.16B, V`m`.B[`i2`] // Dup V`m` lane `i2` through lanes 0-15 in V`n`.\n\ndup V`n`.4H, V`m`.H[`i3`]  // Dup V`m` lane `i3` through lanes 0-3 in V`n`.\ndup V`n`.8H, V`m`.H[`i4`]  // Dup V`m` lane `i4` through lanes 0-7 in V`n`.\n\ndup V`n`.2S, V`m`.S[`i5`]  // Dup V`m` lane `i5` through lanes 0-1 in V`n`.\ndup V`n`.4S, V`m`.S[`i6`]  // Dup V`m` lane `i6` through lanes 0-3 in V`n`.\n\ndup V`n`.2D, V`m`.D[`i7`]  // Dup V`m` lane `i7` through lanes 0-1 in V`n`.\n```", "```\nldr Q`n`, `memory`\nstr Q`n`, `memory`\n```", "```\nldp Q`n`, Q`m`, `memory`\nstp Q`n`, Q`m`, `memory`\n```", "```\n`instr`  {`register_list`}, [X`n`]\n`instr`  {`register_list`}, [X`n`], X`m`\n`instr`  {`register_list`}, [X`n`], #`imm`\n```", "```\nld1 {V`n.`8B}, `memory`\nld1 {V`n.`16B}, `memory`\nld1 {V`n.`B}[`index`], `memory`\n\nld1 {V`n.`4H}, `memory`\nld1 {V`n.`8H}, `memory`\nld1 {V`n.`H}[`index`], `memory`\n\nld1 {V`n.`2S}, `memory`\nld1 {V`n.`4S}, `memory`\nld1 {V`n.`S}[`index`], `memory`\n\nld1 {V`n.`2D}, `memory`\nld1 {V`n.`D}[`index`], `memory`\n```", "```\nld1 {v1.8b}, [x0]\nld1 {v1.8b, v2.8b}, [x0]\nld1 {v1.8b, v2.8b, v3.8b}, [x0]\nld1 {v1.8b, v2.8b, v3.8b, v4.8b}, [x0]\n```", "```\n{V`n`.`t` - V(`n` + `m`).t}\n```", "```\nld1 {v1.8b}, [x0]\nld1 {v1.8b - v2.8b}, [x0]\nld1 {v1.8b - v3.8b}, [x0]\nld1 {v1.8b - v4.8b}, [x0]\n```", "```\nld1 {v0.16b, v1.16b, v2.16b}, [x0]\n```", "```\nst1 {v0.16b, v1.16b}, [x0]\n```", "```\nld2 {V`n`.`t1`, V`(n + 1)`.`t1`}, `memory`\nld2 {V`n`.`t2`, V`(n + 1)`.`t2`}[`index`], `memory`\nst2 {V`n`.`t1`, V`(n + 1)`.`t1`}, `memory`\nst2 {V`n`.`t2`, V`(n + 1)`.`t2`}[`index`], `memory`\n```", "```\nld2 {v0.8b, v1.8b}, [x0]\n```", "```\nld4 {v4.d, v5.d, v6.d, v7.d}[0], [x0]\n```", "```\nld4 {v0.b - v3.b}[0], [x0]\n```", "```\nld4 {v0.16b - v3.16b}, [x0]\n```", "```\nld1r {V`n`.`t`}, `memory`\nld2r {V`n`.`t,` V`(n + 1)`.`t`}, `memory`\nld3r {V`n`.`t,` V`(n + 1)`.`t,` V`(n + 2)`.`t`}, `memory`\nld4r {V`n`.`t,` V`(n + 1)`.`t,` V`(n + 2)`.`t,` V`(n + 3)`.`t`}, `memory`\n```", "```\nV`n`.`t -` V(`n` + `m`).`t`\n```", "```\ntrn1 V`d`.`t`, V`a`.`t`, V`b`.`t`\ntrn2 V`d`.`t`, V`a`.`t`, V`b`.`t`\n```", "```\ntrn1 v0.4s, v2.4s, v4.4s\n```", "```\ntrn1 v0.2d, v2.2d, v3.2d\ntrn2 v1.2d, v2.2d, v3.2d\n```", "```\nzip1 V`d`.`t`, V`a`.`t`, V`b`.`t`\nzip2 V`d`.`t`, V`a`.`t`, V`b`.`t`\n```", "```\nuzp1 V`d`.`t`, V`a`.`t`, V`b`.`t`\nuzp2 V`d`.`t`, V`a`.`t`, V`b`.`t`\n```", "```\next V`d`.8B, V`s`1.8B, V`s`2.8B, #`n`\next V`d`.16B, V`s`1.16B, V`s`2.16B, #`n`\n```", "```\ntbl V`d`.8B, {`table_list`}, V`s`.8B\ntbl V`d`.16B, {`table_list`}, V`s`.16B\ntbx V`d`.8B, {`table_list`}, V`s`.8B\ntbl V`d`.16B, {`table_list`}, V`s`.16B\n```", "```\n0x000102030405060708090a0b0c0d0e0f\n```", "```\ntbl v2.16b, {v1.16b}, v0.16b\n```", "```\nrev16 V`d.t1`, V`s.t1`  // Swap the bytes in the half-word lanes.\nrev32 V`d.t2`, V`s.``t2`  // Swap the bytes in the word lanes.\nrev64 V`d.t1`, V`s.t3`  // Swap the bytes in the double-word lanes.\n```", "```\nadd v0.16b, v1.16b, v2.16b\n```", "```\norr V`d.t`, #`imm`\norr V`d.t`, #`imm,` lsl  #`shift`\nbic V`d.t`, #`imm`\nbic V`d.t`, #`imm,` lsl #`shift`\n```", "```\nshl V`d`.8B, V`s`.8B, #`imm`\nshl V`d`.16B, V`s`.16B, #`imm`\nshl V`d`.4H, V`s`.4H, #`imm`\nshl V`d`.8H, V`s`.8H, #`imm`\nshl V`d`.2S, V`s`.2S, #`imm`\nshl V`d`.4S, V`s`.4S, #`imm`\nshl V`d`.2D, V`s`.2D, #`imm`\n```", "```\nshl D`d`, D`s`, #`imm`\n```", "```\nuqshl  V`d.t`, V`s.t`, #`imm`\nuqshl  V`d.t`, V`s.t`, V`c.t`\nsqshl  V`d.t`, V`s.t`, #`imm`\nsqshl  V`d.t`, V`s.t`, V`c.t`\nsqshlu V`d.t`, V`s.t`, #`imm`\nsqshlu V`d.t`, V`s.t`, V`c.t`\n```", "```\nuqshl v0.16b, v1.16b, #1\n```", "```\nuqshl  R`d`, R`s`, #`imm`\nsqshl  R`d`, R`s`, #`imm`\nsqshlu R`d`, R`s`, #`imm`\n```", "```\nushll  V`d.t2`, V`s`.`t`, #`imm`\nsshll  V`d.t2`, V`s`.`t`, #`imm`\n```", "```\nushll2 V`d.t4`, V`s.t3`, #`imm`\nsshll2 V`d.t4`, V`s.t3`, #`imm`\n```", "```\nsli V`d.t`, V`s.t`, #`imm`\nsri V`d.t`, V`s.t`, #`imm`\n```", "```\nmovi    v0.16b, #0xff\nmovi    v1.4s, #0x1\nsli     v0.4s, v1.4s, #4\n```", "```\nsli D`d`, D`s`, #`imm`  // `imm` = 0 to 63\nsri D`d`, D`s`, #`imm`  // `imm` = 1 to 64\n```", "```\nasr  x0, x0, #1\nadc  x0, x0, xzr // -1 -> 0 and 1 -> 1\n```", "```\nushr  V`d`.`t`, V`s`.`t`, #`imm`  // Unsigned (logical) shift right\nurshr V`d`.`t`, V`s`.`t`, #`imm`  // Unsigned rounding shift right\nsshr  V`d`.`t`, V`s`.`t`, #`imm`  // Signed (arithmetic) shift right\nsrshr V`d`.`t`, V`s`.`t`, #`imm`  // Signed rounding shift right\n```", "```\nsshr  D`d`, D`s`, #`imm`\nsrshr D`d`, D`s`, #`imm`\nushr  D`d`, D`s`, #`imm`\nurshr D`d`, D`s`, #`imm`\n```", "```\nusra  V`d.t`, V`s.t`, #`imm`\nursra V`d.t`, V`s.t`, #`imm`\nssra  V`d.t`, V`s.t`, #`imm`\nsrsra V`d.t`, V`s.t`, #`imm`\n```", "```\nshrn   V`d.t1`, V`s.t2`, #`imm`\nshrn2  V`d.t3`, V`s.t4`, #`imm`\nrshrn  V`d.t1`, V`s.t2`, #`imm`\nrshrn2 V`d.t3`, V`s.t4`, #`imm`\n```", "```\nsqshrn B`d`, H`s`, #`imm`\nsqshrn H`d`, S`s`, #`imm`\nsqshrn S`d`, D`s`, #`imm`\n\nuqshrn B`d`, H`s`, #`imm`\nuqshrn H`d`, S`s`, #`imm`\nuqshrn S`d`, D`s`, #`imm`\n\nsqrshrn B`d`, H`s`, #`imm`\nsqrshrn H`d`, S`s`, #`imm`\nsqrshrn S`d`, D`s`, #`imm`\n\nuqrshrn B`d`, H`s`, #`imm`\nuqrshrn H`d`, S`s`, #`imm`\nuqrshrn S`d`, D`s`, #`imm`\n\nsqshrun B`d`, H`s`, #`imm`\nsqshrun H`d`, S`s`, #`imm`\nsqshrun S`d`, D`s`, #`imm`\n\nsqrshrun B`d`, H`s`, #`imm`\nsqrshrun H`d`, S`s`, #`imm`\nsqrshrun S`d`, D`s`, #`imm`\n```", "```\nsshl   V`d.t`, V`s.t`, V`c.t`\nushl   V`d.t`, V`s.t`, V`c.t`\nsqshl  V`d.t`, V`s.t`, V`c.t`\nuqshl  V`d.t`, V`s.t`, V`c.t`\nsrshl  V`d.t`, V`s.t`, V`c.t`\nurshl  V`d.t`, V`s.t`, V`c.t`\nsqrshl V`d.t`, V`s.t`, V`c.t`\nuqrshl V`d.t`, V`s.t`, V`c.t`\n```", "```\nsqshl    R`d`, R`s`, R`c`\nuqshl    R`d`, R`s`, R`c`\nsqrshl   R`d`, R`s`, R`c`\nuqrshl   R`d`, R`s`, R`c`\n```", "```\nraddhn  v0.8b, v1.8h, v2.8h\n```", "```\naddhn2  v0.16b, v1.8h, v2.8h\n```", "```\naddp  v0.4s, v2.4s, v1.4s\n```", "```\nfaddp  v0.4s, v1.4s, v2.4s\n```", "```\nsaddlp  v0.2d, v1.4s\n```", "```\nusqadd  V`d`.t, V`s`.t  // Add lanes of V`s` to V`d`.\nsuqadd  V`d`.t, V`s`.t  // Add lanes of V`s` to V`d`.\n```", "```\nusqadd  `Rd`, `Rs`   // Add `Rs` to `Rd`.\nsuqadd  `Rd`, `Rs`   // Add `Rs` to `Rd`.\n```", "```\naddv `Rd`, V`s.t`\n```", "```\nsqadd  `Rd`, `Rs`1, `Rs`2\nuqadd  `Rd`, `Rs`1, `Rs`2\n```", "```\naddp   D`d`, V`s`.2D\nfaddp  S`d`, V`s`.2S\nfaddp  D`d`, V`s`.2D\n```", "```\nsqsub  R`d`, R`s`1, R`s`2\nuqsub  R`d`, R`s`1, R`s`2\n```", "```\nsqdmulh h0, h1, h2\n```", "```\nfdiv V`d.t`, V`l.t`, V`r.t`  // Computes V`d` = V`l` / V`r` (lane by lane)\n```", "```\nfrecpe V`d.t`, V`s.t`\n```", "```\nfrecpe `Rd`, `Rs`\n```", "```\n// Compute V0.4S = V1.4S / V2.4S by computing the reciprocal\n// of V2 and multiplying V1 by this reciprocal value:\n\n    frecpe  v3.4s, v2.4s         // Get first approximation.\n    frecps  v0.4s, v1.4s, v3.4s  // *** Refinement step\n    fmul    v3.4s, v3.4s, v0.4s  // *** Refinement step (cont.)\n\n// Repeat \"Refinement step\" as many times as desired here.\n\n    fmul    v0.4s, v1.4s, v3.4s  // Compute quotient.\n```", "```\nabs   V`d.t1`, V`s.t1`\nneg   V`d.t1`, V`s.t1`\nsqabs V`d.t1`, V`s.t1`\nsqneg V`d.t1`, V`s.t1`\nfabs  V`d.t2`, V`s.t2`\nfneg  V`d.t2`, V`s.t2`\n```", "```\nfcvtzs V`d.t`, V`s.t`, #`imm`\nfcvtzu V`d.t`, V`s.t`, #`imm`\n```", "```\nscvtf V`d.t`, V`s.t`\nucvtf V`d.t`, V`s.t`\n```", "```\nfsqrt   R`d`, R`s`\nfrsqrte R`d`, R`s`\nfrsqrts R`d`, R`s1,` R`s2`\n```", "```\ncmtst V`d.t`, V`l.t`, V`r.t`\n```", "```\ncmtst D`d,` D`l,` D`r`\n```", "```\n(V1 > V2) AND (V3 < V4)  // Assume unsigned 8H lanes.\n```", "```\ncmhi v0.4h, v1.4h, v2.4h\ncmhi v5.4h, v4.4h, v3.4h  // Same as cmlo v5.4h, v3.4h, v4.4h\nand  v0.8b, v0.8b, v5.8b  // (assuming cmlo existed)\n```", "```\ncmeq v0.4h, v1.4h, v2.4h\n```", "```\nldr     q3, mask             // mask: .hword 0b1000, 0b100, 0b10, 0b1\ncmeq    v0.4h, v1.4h, v2.4h\nand     v0.8b, v0.8b, v3.8b  // Keep 1 bit of each lane.\naddv    h0, v0.4h            // Merge the bits into H0.\numov    w0, v0.h[0]\nadr     x1, JmpTbl\nldr     x0, [x1, x0, lsl #3]\nadd     x0, x0, x1\nbr      x0\n```", "```\nmask:   .dword  0x0008000400020001\n```", "```\ncmeq  v0.16b, v1.16b, #0  // Assume V1 contains 16 chars.\n```", "```\ncmeq v0.16b, v1.16b, #0  // Check for a 0 byte.\naddv b0, v0.16b          // Sum comparison bytes.\numov w0, v0.b[0]         // Put sum where you can compare it.\ncmp  w0, #0              // See if there were any 0 bytes.\nbeq  noZeroBytes         // No 0s, go fetch 16 more bytes.\n```", "```\n// Add V1.S to V0.S, but don't add a value to a particular\n// lane in V0 if its value exceeds 0xFFFF.\n//\n// Note: Assume V2 contains 0x0000FFFF0000ffff0000FFFF0000ffff.\n\n        // no cmls v3.4s, v0.4s, v2.4s, so use the following:\n\n        cmhi    v3.4s, v2.4s, v0.4s\n\n        and     v4.16b, v1.16b, v3.16b\n        add     v0.4s, v0.4s, v4.4s\n```", "```\n// Listing11-1.S\n//\n// Demonstrates a simple bitonic sort\n// of eight elements, using vector instructions\n\n        #include    \"aoaa.inc\"\n        .text\n\n        .pool\nttlStr: wastr  \"Listing 11-1\"\n\n// Format strings for printf:\n\nfmtPV:  wastr   \" %016llx %016llx\"\nnl:     wastr   \"\\n\"\n\n// Sample data to sort\n// (eight unsigned 32-bit integers\n// to be loaded into vector\n// registers):\n\nqval1:  .word   8, 7, 6, 4\nqval2:  .word   3, 2, 1, 0\n\n// Lookup tables for TBL instruction,\n// used to move around integers\n// within the vector registers\n//\n// TBL works with bytes; the following\n// constants map 32-bit integers to\n// a block of 4 bytes in the\n// vector registers:\n\n_a = 0x03020100\n_b = 0x07060504\n_c = 0x0b0a0908\n_d = 0x0f0e0d0c\n\n_e = 0x13121110\n_f = 0x17161514\n_g = 0x1b1a1918\n_h = 0x1f1e1d1c\n\n_e1 = 0x03020100    // Special case\n_f1 = 0x07060504    // for single-\n_g1 = 0x0b0a0908    // register lists\n_h1 = 0x0f0e0d0c\n\nlut1:   .word   _f1, _e1, _h1, _g1\nlut2:   .word   _a, _f, _c, _h\nlut3:   .word   _b, _e, _d, _g\nlut4:   .word   _h1, _g1, _f1, _e1\nlut5:   .word   _a, _b, _g, _h\nlut6:   .word   _c, _d, _f, _e\nlut7:   .word   _a, _e, _b, _f\nlut8:   .word   _c, _g, _d, _h\nlut9:   .word   _a, _e, _b, _f\nlut10:  .word   _c, _g, _d, _h\n\n// Usual function that returns\n// a pointer to the name of this\n// program in the X0 register:\n\n        proc    getTitle, public\n        lea     x0, ttlStr\n        ret\n        endp    getTitle\n\n// printV\n//\n// Prints the two 128-bit values sitting\n// on the top of the stack (prior to call)\n// as hexadecimal values:\n\n        proc    printV\n\n        locals  p\n        qword   p.v0\n        qword   p.v1\n        qword   p.v2\n        qword   p.v3\n        qword   p.v4\n        byte    p.stk, 64\n        endl    p\n\n        enter   p.size\n\n        // Preserve vector registers\n        // (this program uses them):\n\n        str     q0, [fp, #p.v0]\n        str     q1, [fp, #p.v1]\n        str     q2, [fp, #p.v2]\n        str     q3, [fp, #p.v3]\n        str     q4, [fp, #p.v4]\n\n        // Print the first value on\n        // the stack:\n\n        ldr     w1, [fp, #16]\n        ldr     w2, [fp, #20]\n        ldr     w3, [fp, #24]\n        ldr     w4, [fp, #28]\n        lea     x0, fmtPV\n        mstr    x1, [sp]\n mstr    x2, [sp, #8]\n        mstr    x3, [sp, #16]\n        mstr    x4, [sp, #24]\n        bl      printf\n\n        // Print the second value on\n        // the stack:\n\n        ldr     w1, [fp, #32]\n        ldr     w2, [fp, #36]\n        ldr     w3, [fp, #40]\n        ldr     w4, [fp, #44]\n        lea     x0, fmtPV\n        mstr    x1, [sp]\n        mstr    x2, [sp, #8]\n        mstr    x3, [sp, #16]\n        mstr    x4, [sp, #24]\n        bl      printf\n\n        lea     x0, nl\n        bl      printf\n\n        ldr     q0, [fp, #p.v0]\n        ldr     q1, [fp, #p.v1]\n        ldr     q2, [fp, #p.v2]\n        ldr     q3, [fp, #p.v3]\n        ldr     q4, [fp, #p.v4]\n        leave\n        endp    printV\n\n// Here's the main program:\n\n        proc    asmMain, public\n\n        // Reserve stack space for parameters:\n\n        locals  am\n        byte    am.stk, 64\n        endl    am\n\n        enter   am.size\n\n        // Load the values to sort\n        // into V0 and V1:\n\n        ldr     q0, qval1\n        ldr     q1, qval2\n\n        // Bitonic sort of eight\n        // elements:\n\n        // Step 1:\n\n        umin    v2.4s, v0.4s, v1.4s\n        umax    v3.4s, v0.4s, v1.4s\n\n // Step 2:\n\n        ldr     q4, lut1\n        tbl     v3.16b, {v3.16b}, v4.16b\n\n        umin    v0.4s, v2.4s, v3.4s\n        umax    v1.4s, v2.4s, v3.4s\n        ldr     q4, lut2\n        tbl     v2.16b, {v0.16b, v1.16b}, v4.16b\n        ldr     q4, lut3\n        tbl     v3.16b, {v0.16b, v1.16b}, v4.16b\n\n        // Step 3:\n\n        umin    v0.4s, v2.4s, v3.4s\n        umax    v1.4s, v2.4s, v3.4s\n\n        // Step 4:\n\n        ldr     q4, lut4\n        tbl     v1.16b, {v1.16b}, v4.16b\n\n        umin    v2.4s, v0.4s, v1.4s\n        umax    v3.4s, v0.4s, v1.4s\n\n        ldr     q4, lut5\n        tbl     v0.16b, {v2.16b, v3.16b}, v4.16b\n        ldr     q4, lut6\n        tbl     v1.16b, {v2.16b, v3.16b}, v4.16b\n\n        uminp   v2.4s, v0.4s, v1.4s\n        umaxp   v3.4s, v0.4s, v1.4s\n\n        ldr     q4, lut7\n        tbl     v0.16b, {v2.16b, v3.16b}, v4.16b\n        ldr     q4, lut8\n        tbl     v1.16b, {v2.16b, v3.16b}, v4.16b\n\n        umin    v2.4s, v0.4s, v1.4s\n        umax    v3.4s, v0.4s, v1.4s\n\n        // Merge results:\n\n        ldr     q4, lut9\n        tbl     v0.16b, {v2.16b, v3.16b}, v4.16b\n        ldr     q4, lut10\n        tbl     v1.16b, {v2.16b, v3.16b}, v4.16b\n\n        str     q0, [sp]\n        str     q1, [sp, #16]\n        bl      printV\n\n        leave                       // Return to caller.\n        endp    asmMain\n```", "```\n% ./build Listing11-1\n% ./Listing11-1\nCalling Listing11-1:\n00000000 00000001 00000002 00000003 00000004 00000006 00000007 00000008\nListing11-1 terminated\n```", "```\n// Listing11-2.S\n\n`Usual source file information at the beginning of the file,`\n`deleted for brevity`\n\n// dtoStr\n//\n//  Converts the dword passed in X1 to 16\n//  hexadecimal digits (stored into buffer pointed\n//  at by X0; buffer must have at least 24 bytes\n//  available)\n\n    .equ    convert0toA, 'A' - ('0' + 10)    // val + '0' to val + 'A'\n    .equ    invert0ToA,  ~convert0toA & 0xFF // Invert the bits for BIC.\n\n    proc    dtoStr\n    stp     q0, q1, [sp, #-32]!     // Preserve registers.\n\n    rev     x1, x1                  // Reverse bytes (for output).\n    mov     v0.d[0], x1             // Set V0 to the LO nibbles\n    rev     x1, x1                  // and V1 to the HO nibbles,\n    ushr    v1.8b, v0.8b, #4        // also, restore X1.\n    bic     v0.4h, #0xf0\n    bic     v0.4h, #0xf0, lsl #8\n\n    zip1    v0.16b, v1.16b, v0.16b  // Interleave the HO and LO nibbles.\n\n    orr     v0.8h, #0x30            // Convert binary to ASCII,\n    orr     v0.8h, #0x30, lsl #8    // note only 0-9 will be correct.\n\n    movi    v1.16b, #'9'            // Determine which bytes\n    cmgt    v1.16b, v0.16b, v1.16b  // should be A-F.\n\n    bic     v1.8h, #invert0ToA      // Update bytes that should be A-F.\n    bic     v1.8h, #invert0ToA, lsl #8\n    add     v0.16b, v0.16b, v1.16b\n\n str     q0, [x0]                // Output the string.\n    strb    wzr, [x0, #16]\n\n    ldp     q0, q1, [sp], #32       // Restore registers.\n    ret\n    endp    dtoStr\n```", "```\n% ./build Listing11-2\n% ./Listing11-2\nCalling Listing11-2:\nValue(fedcba9876543210) = string(FEDCBA9876543210)\nListing11-2 terminated\n```"]