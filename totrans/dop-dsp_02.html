<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="3" id="Page_3"/>1</span><br/>
<span class="ChapterTitle">Setting Up a Virtual Machine</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro"><em>Provisioning</em> (that is, setting up) a virtual machine (VM) is the act of configuring a VM for a specific purpose. Such a purpose could be running an application, testing software across a different platform, or applying updates.</p>
<p>Setting up a VM requires two steps: creating and then configuring it. For this example, you’ll use Vagrant and Ansible to build and configure a VM. Vagrant automates the process of creating the VM, while Ansible configures the VM once it’s running. You’ll set up and test your VM locally, on VirtualBox. This process is similar to creating and provisioning servers in the cloud. The VM you set up now will be the foundation of all the examples in the first section of this book.</p>
<h2 id="h1-502482c01-0001">Why Use Code to Build Infrastructure?</h2>
<p class="BodyFirst">Using code to build and provision infrastructure lets you consistently, quickly, and efficiently manage and deploy applications. This allows your <span epub:type="pagebreak" title="4" id="Page_4"/>infrastructure and services to scale. It also can reduce operating costs, decrease time for recovery during a disaster, and minimize the chance of configuration errors.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	In the DevOps field, you’ll often hear two terms that relate to creating and configuring infrastructure: <em>infrastructure as code (</em><em>IaC</em><em>)</em> and <em>c</em><em>onfiguration </em><em>m</em><em>anagement (CM)</em>. Treating infrastructure as code is the process of using code to describe and manage infrastructure like VMs, network switches, and cloud resources such as Amazon Relational Database Service (RDS). CM is the process of configuring those resources for a specific purpose in a predictable, repeatable manner. The two tools we are using, Vagrant and Ansible, are considered IaC and CM, respectively. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Another benefit of treating your infrastructure as code is ease of deployment. Applications are built and tested the same way in a delivery pipeline. For example, artifacts like Docker images are created and deployed consistently, using the same versions of libraries and programs. Treating your infrastructure as code allows you to build reusable components, use test frameworks, and apply standard software engineering best practices. </p>
<p>There are times when treating your infrastructure as code may be overkill, however. For example, if you have only one VM to stand up or a simple Bash script to run, it may not be worth the time and effort to create all the infrastructure and CM code to accomplish something you can do in five minutes. Use your best judgment when deciding on the route to take.</p>
<h2 id="h1-502482c01-0002">Getting Started with Vagrant</h2>
<p class="BodyFirst"><em>Vagrant</em> is a framework that makes it easy to create and manage VMs. It supports multiple operating systems (OSs) that can run on multiple platforms. Vagrant uses a single configuration file, called a <em>Vagrantfile</em>, to describe the virtual environment in code. You’ll use this to create your local infrastructure.</p>
<h3 id="h2-502482c01-0001">Installation</h3>
<p class="BodyFirst">To install Vagrant, visit Vagrant’s website at <a href="https://www.vagrantup.com/downloads.html" class="LinkURL">https://www.vagrantup.com/downloads.html</a>. Choose the correct OS and architecture for your host. To complete the installation, download the binary and follow the instructions specific to your OS. For example, since I am on a Mac, I would choose the macOS 64-bit link to download the latest version. </p>
<p>When your VM comes up, you’ll also need to make sure that it has VirtualBox’s guest additions installed on it. (You should have installed VirtualBox when following along with this book’s <span class="xref" itemid="xref_target_Introduction.">Introduction.</span>) <em>Guest additions</em> provide better driver support, port forwarding, and host-only networking. They help your VM run faster and have more options available. <span epub:type="pagebreak" title="5" id="Page_5"/>After you have finished installing Vagrant, enter the following command in your terminal to install the Vagrant plug-in for guest additions:</p>
<pre><code>$ <b>vagrant plugin install vagrant-vbguest</b>
Installing the 'vagrant-vbguest' plugin. This can take a few minutes...
Fetching vagrant-vbguest-0.30.0.gem
Installed the plugin 'vagrant-vbguest (0.30.0)'!</code></pre>
<p>The output above shows a successful installation of the <code>vbguest</code> plug-in for Vagrant. Your version of the plug-in will most likely be different since new versions come out periodically. It is good practice to update this plug-in anytime you upgrade Vagrant and VirtualBox.</p>
<h3 id="h2-502482c01-0002">Anatomy of a Vagrantfile</h3>
<p class="BodyFirst">A Vagrantfile describes how to build and provision a VM. It’s best practice to use one Vagrantfile per project so you can add the configuration file to your project’s version control and share it with your team. The configuration file’s syntax is in the Ruby programming language, but you just need to understand a few basic principles to get started. </p>
<p>The Vagrantfile provided with this book contains documentation and sensible options to save you time. This file is too large to include here, so I’ll discuss only the sections I changed from the Vagrant defaults. You’ll start at the top of the file and work your way down to the bottom, so feel free to open it and follow along. It is located under the <em>vagrant/</em> directory in the repository you cloned from the <span class="xref" itemid="xref_target_Introduction">Introduction</span>. Later in this chapter, you’ll use this file to create your VM.</p>
<h4 id="h3-502482c01-0001">Operating System</h4>
<p class="BodyFirst">Vagrant supports many OS base images, called <em>boxes</em>, by default. You can search the list of boxes that Vagrant supports at <a href="https://app.vagrantup.com/boxes/search/" class="LinkURL">https://app.vagrantup.com/boxes/search/</a>. Once you find the one you want, set it near the top of the Vagrantfile using the <code>vm.box</code> option, as shown below:</p>
<pre><code>config.<b>vm.box</b> = <b>"ubuntu/focal64"</b></code></pre>
<p>In this case, I’ve set the <code>vm.box</code> identifier to <code>ubuntu/focal64</code>.</p>
<h4 id="h3-502482c01-0002">Networking</h4>
<p class="BodyFirst">You can configure the VM’s network options for different network scenarios, like <em>static IP</em> or <em>Dynamic Host Configuration Protocol (DHCP)</em>. To do this, modify the <code>vm.network</code> option near the middle of the file:</p>
<pre><code>config.<b>vm.network</b> <b>"private_network"</b>,<em> </em>type:<em> </em><b>"dhcp"</b></code></pre>
<p>For this example, you’ll want the VM to obtain its IP address from a private network using DHCP. That way, it’ll be easy to access resources like a web server on the VM from your local host. </p>
<h4 id="h3-502482c01-0003"><span epub:type="pagebreak" title="6" id="Page_6"/>Providers</h4>
<p class="BodyFirst">A <em>provider</em> is a plug-in that knows how to create and manage a VM. Vagrant supports multiple providers to manage different types of machines. Each provider has common options like CPU, disk, and memory. Vagrant will use the provider’s application programming interface (API) or command line options to create the VM. You can find a list of supported providers at <a href="https://www.vagrantup.com/docs/providers/" class="LinkURL">https://www.vagrantup.com/docs/providers/</a>. The provider is set near the bottom of the file and looks like this:</p>
<pre><code>  config.vm.provider "virtualbox" do |vb|
    vb.memory = "1024"
    vb.name = "dftd"
    <var>--snip--</var>
  end</code></pre>
<h3 id="h2-502482c01-0003">Basic Vagrant Commands</h3>
<p class="BodyFirst">Now that you know how a Vagrantfile is laid out, let’s look at some basic Vagrant commands. The four you’ll use most often are <code>vagrant up</code>, <code>vagrant destroy</code>, <code>vagrant status</code>, and <code>vagrant ssh</code>: </p>
<ol class="none">
<li><code class="bold">vagrant up</code>  Creates a VM using the Vagrantfile as a guide</li>
<li><code class="bold">vagrant destroy</code>  Destroys the running VM</li>
<li><code class="bold">vagrant status</code>  Checks the running status of a VM</li>
<li><code class="bold">vagrant ssh</code>  Accesses the VM over Secure Shell</li>
</ol>
<p>Each of these commands has additional options. To see what they are, enter a command and then add the <code>--help</code> flag for more information. To learn more about Vagrant’s features, visit the documentation at <a href="https://www.vagrantup.com/docs/" class="LinkURL">https://www.vagrantup.com/docs/</a>.</p>
<p>Once you create the VM by running <code class="bold">vagrant up</code>, you’ll have a core Linux system with all the OS defaults. Next, let’s look at how you can apply your own configuration to the system by provisioning it.</p>
<h2 id="h1-502482c01-0003">Getting Started with Ansible</h2>
<p class="BodyFirst"><em>Ansible</em> is a CM tool that can orchestrate the provisioning of infrastructure like VMs. Ansible uses a <em>declarative configuration style</em>, which means it allows you to describe what the desired state of infrastructure should look like. This is different from an <em>imperative configuration style</em>, which requires you to supply all the minute details on your desired state of infrastructure. Because of its declarative style, Ansible is a great tool for software engineers who are not well versed in system administration. Ansible is also open-source software and free to use. </p>
<p>Ansible is written in Python, but you don’t need to understand Python to use it. The one dependency you will need to understand is <em>Yet Another Markup Language (YAML)</em>, which is a data serialization language that <span epub:type="pagebreak" title="7" id="Page_7"/>Ansible uses to describe complex data structures and tasks. It’s easy to pick up simply by looking at some basic examples, and I’ll provide a few when I review the Ansible playbook and tasks later. Two important things worth noting here are that YAML uses indentation to organize elements like Python, and it is also case sensitive. You can read more about YAML at <a href="https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html" class="LinkURL">https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html</a>. </p>
<p>Ansible applies its configuration changes over <em>Secure Shell (SSH)</em>, which is a secure protocol to communicate with remote hosts. The most common use of SSH is to gain access to the command line on a remote host, but users can also deploy it to forward network traffic and copy files securely. By using SSH, Ansible can provision a single host or a group of hosts over the network. </p>
<h3 id="h2-502482c01-0004">Installation</h3>
<p class="BodyFirst">Now, you should install Ansible so Vagrant can use it for provisioning. Head over to Ansible’s documentation at <a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html" class="LinkURL">https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html</a>. Locate the documentation for your specific OS and follow the steps to install Ansible. For example, I am using macOS, and the preferred way to install Ansible on macOS is to use <em>pip</em>, which is a Python package manager used to install applications and dependencies. I found this information under the Installing Ansible on macOS link, which eventually directed me to install Ansible using pip under the Installing Ansible with pip link. Since Ansible is written in Python, using pip is an effective way to install the latest version.</p>
<h3 id="h2-502482c01-0005">Key Ansible Concepts</h3>
<p class="BodyFirst">Now that you’ve installed Ansible, you’ll need to know these terms and concepts to have it up and running quickly:</p>
<ol class="none">
<li><span class="RunInHead">Playbook</span>  A <em>playbook</em> is a collection of ordered tasks or roles that you can use to configure hosts.</li>
<li><span class="RunInHead">Control node</span>  A <em>control node</em> is any Unix machine that has Ansible installed on it. You will run your playbooks or commands from a control node, and you can have as many control nodes as you like. </li>
<li><span class="RunInHead">Inventory</span>  An <em>inventory</em> is a file that contains a list of hosts or groups of hosts that Ansible can communicate with.</li>
<li><span class="RunInHead">Module</span>  A <em>module</em> encapsulates the details of how to perform certain actions across operating systems, such as how to install a software package. Ansible comes preloaded with many modules.</li>
<li><span class="RunInHead">Task</span>  A <em>task</em> is a command or action (such as installing software or adding a user) that is executed on the managed host.</li>
<li><span class="RunInHead">Role</span>  A <em>role</em> is a group of tasks and variables that is organized in a standardized directory structure, defines a particular purpose for the server, and can be shared with other users for a common goal. A typical role could configure a host to be a database server. This role would include all the files and instructions necessary to install the database application, configure user permissions, and apply seed data. </li>
</ol>
<h3 id="h2-502482c01-0006"><span epub:type="pagebreak" title="8" id="Page_8"/>Ansible Playbook</h3>
<p class="BodyFirst">To configure the VM, you’ll use the Ansible playbook I have provided. This file, named <em>site.yml</em>, is located in the <em>ansible/</em> directory you cloned from the <span class="xref" itemid="xref_target_Introduction">Introduction</span>. Think of the playbook as an instruction manual on how to assemble a host. Now, take a look at the playbook file itself. Navigate to the <em>ansible/</em> directory and open the <em>site.yml </em>file in your editor. </p>
<p>You can break up playbook files into different sections. The first section functions as the header, which is a good place to set global variables to use throughout the playbook. In the header, you’ll set things like the <code>name</code> of the play, the <code>hosts</code>, the <code>remote_user</code>, and the privileged escalation method:</p>
<pre><code>---
- name: Provision VM
  hosts: all
  become: yes
  become_method: sudo
  remote_user: ubuntu
<var>--snip--</var></code></pre>
<p>These settings are mostly boilerplate, but let’s focus on a few points. Be sure to give each play a <code>name</code> so it’s easier to find and debug if things go wrong. The <code>name</code> of the play in the example above is set to <code>Provision VM</code>. You could have multiple plays in a single playbook, but for this example, you’ll need only one. Next, the <code>hosts</code> option is set to <code>all</code> to match any Vagrant-built VMs because Vagrant will autogenerate the Ansible inventory file dynamically. Some operations on a host will require elevated privileges, so Ansible allows you to <em>become</em>, or activate privilege escalation for, a specific user. Since you’re using Ubuntu, the default user with escalated privileges is <code>ubuntu</code>. You also can set the different methods to use for authorization, and you’ll use <code>sudo</code> for this example.</p>
<p>The next section is where you’ll list all the tasks for the host. This is where the actual work is being done. If you think of the playbook as an instruction manual, the <em>tasks</em> are just the separate steps in that manual. The <code>tasks</code> section looks like this:</p>
<pre><code><var>--snip--</var>
  tasks:
   <b>#- import_tasks: chapter2/pam_pwquality.yml</b>
   <b>#- import_tasks: chapter2/user_and_group.yml</b>
<var>--snip--</var></code></pre>
<p>The built-in Ansible <code>import_tasks</code> function is loading tasks from two separate files: <em>pam_pwquality.yml</em> and <em>user_and_group.yml</em>. The <code>import_tasks</code> function allows you to organize the tasks better and avoid a large, cluttered playbook. Each of these files can have one or many individual tasks.<em> </em>I’ll discuss tasks and other parts of the playbook in future chapters. For now, note that these tasks are commented out with the hash mark (<code>#</code>) symbol and will not change anything until you uncomment them.</p>
<h3 id="h2-502482c01-0007"><span epub:type="pagebreak" title="9" id="Page_9"/>Basic Ansible Commands</h3>
<p class="BodyFirst">The Ansible application comes with multiple commands, but you’ll mostly use these two: <code>ansible</code> and <code>ansible-playbook</code>.</p>
<p>You’ll primarily use the <code>ansible</code> command for running ad hoc or one-time commands that you execute from the command line. For example, to instruct a group of web servers to restart Nginx, you would enter the following command:</p>
<pre><code>$ <b>ansible</b> <b>webservers-m service -a "name=nginx state=restarted" --become</b></code></pre>
<p>This instructs Ansible to restart Nginx on a group of hosts called <em>webservers</em>. Note that the mapping for the <em>webservers</em> group would be located in the inventory file. The Ansible <code>service</code> module interacts with the OS to perform the restart. The <code>service </code>module requires some extra arguments, and they are passed with the <code>-a</code> flag. In this case, both the name of the <code>service</code> (<code>nginx</code>) and the fact that it should restart are indicated. You need <em>root</em> privileges to restart a <code>service</code>, so you’ll use the <code>--become</code> flag to ask for privilege escalation.</p>
<p>The <code>ansible-playbook</code> command runs playbooks. In fact, this is the command Vagrant will use during the provisioning phase. To instruct <code>ansible-playbook</code> to execute the <em>aws-cloudwatch.yml</em> playbook against a group of hosts called <em>dockerhosts</em>, you would enter the following command in your terminal:</p>
<pre><code>$ <b>ansible-playbook -l dockerhosts aws-cloudwatch.yml</b></code></pre>
<p>The <code>dockerhosts</code> need to be listed in the inventory file for the command to succeed. Note that if you do not provide a subset of hosts with the <code>-l</code> flag, Ansible will assume you want to run the playbook on all the hosts found in your inventory file.</p>
<h2 id="h1-502482c01-0004">Creating an Ubuntu VM</h2>
<p class="BodyFirst">Up to this point, we’ve been discussing concepts and configuration files. Now, let’s put that knowledge to use and stand up and provision some infrastructure. To create the Ubuntu VM, make sure you are in the same directory as the Vagrantfile. This is because Vagrant needs to reference the configuration file while creating the VM. You’ll use the <code>vagrant up</code> command to create the VM, but before running the command, you should know that it produces a lot of output and may take a few minutes. Therefore, I’m focusing on only the relevant parts here. Enter the following command in your terminal:</p>
<pre><code>$ <b>vagrant up</b></code></pre>
<p><span epub:type="pagebreak" title="10" id="Page_10"/>The first section of the output to look at is Vagrant downloading the base image: </p>
<pre><code><var>--snip--</var>
Bringing machine 'default' up with 'virtualbox' provider...
==&gt; default: <b>Importing base box 'ubuntu/focal64'</b>...
<var>--snip--</var></code></pre>
<p>Here, Vagrant is downloading the <code>ubuntu</code> image, as expected. The image download may take a few minutes, depending on your internet connection.</p>
<p>Next, Vagrant will configure a public/private key pair to provide SSH access to the VM. (We’ll discuss key pairs in more detail in <span class="xref" itemid="xref_target_Chapter 3.">Chapter 3.</span>)</p>
<pre><code><var>--snip--    </var>
default: Vagrant insecure key detected. Vagrant will automatically replace
default: this with a newly generated keypair for better security.
default:
default: Inserting generated public key within guest...
default: Removing insecure key from the guest if it's present...
default: Key inserted! Disconnecting and reconnecting using new SSH key...
<var>--snip--</var></code></pre>
<p>Vagrant stores the private key locally on your host (<em>.vagrant/</em>) and then adds the public key to the <em>~/.ssh/authorized_keys</em> file on the VM. Without these keys, you would not be able to connect to the VM over SSH.</p>
<p>By default, Vagrant and VirtualBox will mount a shared directory inside the VM. This shared directory will give you access to a host directory from within the VM:</p>
<pre><code><var>--snip--</var>
==&gt; default: Mounting shared folders...
   default: /vagrant =&gt; /Users/bradleyd/devops_for_the_desperate/vagrant
<var>--snip--</var></code></pre>
<p>You can see that my local host directory <em>Users/bradleyd/devops_for_the_desperate/</em> is mounted at the <em>vagrant/</em> directory inside the VM. Your directory will be different. You can use this shared directory for transferring files like source code between host and VM. If you don’t need the shared directory, Vagrant provides a configuration option to turn it off. See Vagrant’s documentation for further details.</p>
<p>Finally, the following shows the Ansible <code>provisioner</code> output:</p>
<pre><code><var>--snip--</var>
==&gt; default: Running provisioner: ansible...
    default: Running <span class="CodeAnnotation" aria-label="annotation1">1</span>ansible-playbook...

PLAY [Provision VM] *******************************
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> TASK [Gathering Facts] ****************************
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> ok:  [default]

PLAY RECAP *******************************
<span epub:type="pagebreak" title="11" id="Page_11"/><var>--snip--</var>
default	   : ok=1    <span class="CodeAnnotation" aria-label="annotation4">4</span>changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</code></pre>
<p>This shows that the Ansible <code>provisioner</code> is run using the <code>ansible-playbook</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> command. Ansible logs each <code>TASK</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and whether anything was changed on the host <span class="CodeAnnotation" aria-label="annotation3">3</span>. In this case, all the <code>tasks</code> are commented out, so nothing was <code>changed</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> on the VM. This output is the first place to look when gauging success or failure.</p>
<p>Let’s perform a sanity check and see whether the VM is actually running. Enter the following command in your terminal to show the VM’s current status:</p>
<pre><code>$ <b>vagrant status</b>
Current machine states:
default    running (virtualbox)
<code>--snip--</code></code></pre>
<p>Here, you can see that the status of the VM is <code>running</code>. This means you created the VM, and it should be accessible over SSH.</p>
<p>If your output looks different, make sure there are no errors from the <code>vagrant up</code> command before continuing. If you need more information, add the <code>debug</code> flag to the <code>up</code> command to make Vagrant increase the output verbosity: <code class="bold">vagrant up --debug</code>. You’ll need to have a successful provision at this point, or it will be difficult to follow along with the remaining chapters.</p>
<h2 id="h1-502482c01-0005">Summary</h2>
<p class="BodyFirst">In this chapter, you installed Vagrant and Ansible to create and configure a VM. You learned how to configure Vagrant using its Vagrantfile, and you gained basic knowledge of how to provision a VM using Ansible playbooks and tasks. Now that you understand these basic concepts, you should be able to create and provision any type of infrastructure, not just VMs. </p>
<p>In the next chapter, you’ll use two provided Ansible tasks to create a user and group. You’ll need to have a foundation in user and group management when configuring a host.</p>
</section>
</body></html>