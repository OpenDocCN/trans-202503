<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;CLASSES AND OBJECTS"><div class="titlepage"><div><div><h1 class="title"><a id="classes_and_objects"/>Chapter 12. CLASSES AND OBJECTS</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject12_d1e52966"/><img alt="CLASSES AND OBJECTS" src="tagoreillycom20100401nostarchimages577853.png.jpg"/></div></div><p>Many modern high-level languages support the notion of classes and objects. C++ (an object-oriented version of C), Java, and Delphi (an object-oriented version of Pascal) are good examples. Of course, these high-level language compilers translate their source code into low-level machine code, so it should be pretty obvious that some mechanism exists in machine code for implementing classes and objects.<a class="indexterm" id="IDX-CHP-12-0001"/></p><p>Although it has always been possible to implement classes and objects in machine code, most assemblers provide poor support for writing object-oriented assembly language programs. HLA does not suffer from this drawback because it provides good support for writing object-oriented assembly language programs. This chapter discusses the general principles behind object-oriented programming (OOP) and how HLA supports OOP.<a class="indexterm" id="IDX-CHP-12-0002"/></p><div class="sect1" title="12.1 General Principles"><div class="titlepage"><div><div><h1 class="title"><a id="general_principles"/>12.1 General Principles</h1></div></div></div><p>Before discussing the mechanisms behind OOP, it is probably a good idea to take a step back and explore the benefits of using OOP (especially in assembly language programs). Most texts that describe the benefits of OOP will use buzzwords like <span class="emphasis"><em>code reuse</em></span>, <span class="emphasis"><em>abstract data types</em></span>, <span class="emphasis"><em>improved development efficiency</em></span>, and so on. While all of these features are nice and are good attributes for a programming paradigm, a good software engineer would question the use of assembly language in an environment where "improved development efficiency" is an important goal. After all, you can probably obtain far better efficiency by using a high-level language (even in a non-OOP fashion) than you can by using objects in assembly language. If the purported features of OOP don't seem to apply to assembly language programming, then why bother using OOP in assembly? This section will explore some of those reasons.<a class="indexterm" id="IDX-CHP-12-0003"/><a class="indexterm" id="IDX-CHP-12-0004"/><a class="indexterm" id="IDX-CHP-12-0005"/></p><p>The first thing you should realize is that the use of assembly language does not negate the aforementioned OOP benefits. OOP in assembly language does promote code reuse. It provides a good method for implementing abstract data types, and it can improve development efficiency <span class="emphasis"><em>in assembly language</em></span>. In other words, if you're dead set on using assembly language, there are benefits to using OOP.</p><p>To understand one of the principle benefits of OOP, consider the concept of a global variable. Most programming texts strongly recommend against the use of global variables in a program (as does this text). Interprocedural communication through global variables is dangerous because it is difficult to keep track of all the possible places in a large program that modify a given global object. Worse, it is very easy when making enhancements to accidentally reuse a global object for something other than its intended purpose; this tends to introduce defects into the system.<a class="indexterm" id="IDX-CHP-12-0006"/></p><p>Despite the well-understood problems with global variables, the semantics of global objects (extended lifetimes and accessibility from different procedures) are absolutely necessary in various situations. Objects solve this problem by letting the programmer determine the lifetime of an object<sup>[<a class="footnote" href="#ftn.CHP-12-FN-1" id="CHP-12-FN-1">132</a>]</sup> as well as allowing access to data fields from different procedures. Objects have several advantages over simple global variables insofar as objects can control access to their data fields (making it difficult for procedures to accidentally access the data), and you can also create multiple instances of an object, allowing separate sections of your program to use their own unique "global" object without interference from other sections.</p><p>Of course, objects have many other valuable attributes. One could write several volumes on the benefits of objects and OOP; this single chapter cannot do the subject justice. This chapter presents objects with an eye toward using them in HLA/assembly programs. However, if you are new to OOP or wish more information about the object-oriented paradigm, you should consult other texts on this subject.</p><p>An important use for classes and objects is to create <span class="emphasis"><em>abstract data types (ADTs)</em></span>. An abstract data type is a collection of data objects and the functions (which we'll call <span class="emphasis"><em>methods</em></span>) that operate on the data. In a pure abstract data type, the ADT's methods are the only code that has access to the data fields of the ADT; external code may access the data only by using function calls to get or set data field values (these are the ADT's <span class="emphasis"><em>accessor</em></span> methods). In real life, for efficiency reasons, most languages that support ADTs allow at least limited access to the data fields of an ADT by external code.<a class="indexterm" id="IDX-CHP-12-0007"/><a class="indexterm" id="IDX-CHP-12-0008"/></p><p>Assembly language is not a language most people associate with ADTs. Nevertheless, HLA provides several features to allow the creation of rudimentary ADTs. While some might argue that HLA's facilities are not as complete as those in a language such as C++ or Java, keep in mind that these differences exist because HLA is an assembly language.</p><p>True ADTs should support <span class="emphasis"><em>information hiding</em></span>. This means that the ADT does not allow the user of an ADT access to internal data structures and routines that manipulate those structures. In essence, information hiding restricts ADT access to the ADT's accessor methods. Assembly language, of course, provides very few restrictions. If you are dead set on accessing an object directly, there is very little HLA can do to prevent you from doing this. However, HLA has some facilities that will provide a limited form of information hiding. Combining these with some care on your part, you will be able to enjoy many of the benefits of information hiding within your programs.<a class="indexterm" id="IDX-CHP-12-0009"/><a class="indexterm" id="IDX-CHP-12-0010"/><a class="indexterm" id="IDX-CHP-12-0011"/></p><p>The primary facilities HLA provides to support information hiding are separate compilation, linkable modules, and the <code class="literal">#include/#includeonce</code> directives. For our purposes, an abstract data type definition will consist of two sections: an <span class="emphasis"><em>interface</em></span> section and an <span class="emphasis"><em>implementation</em></span> section.<a class="indexterm" id="IDX-CHP-12-0012"/></p><p>The interface section contains the definitions that must be visible to the application program. In general, it should not contain any specific information that would allow the application program to violate the information-hiding principle, but this is often impossible given the nature of assembly language. Nevertheless, you should attempt to reveal only what is absolutely necessary within the interface section.</p><p>The implementation section contains the code, data structures, and so on to actually implement the ADT. While some of the methods and data types appearing in the implementation section may be public (by virtue of appearance within the interface section), many of the subroutines, data items, and so on will be private to the implementation code. The implementation section is where you hide all the details from the application program.</p><p>If you wish to modify the abstract data type at some point in the future, you will only have to change the interface and implementation sections. Unless you delete some previously visible object that the applications use, there will be no need to modify the applications at all.</p><p>Although you could place the interface and implementation sections directly in an application program, this would not promote information hiding or maintainability, especially if you have to include the code in several different applications. The best approach is to place the implementation section in an include file that any interested application reads using the HLA <code class="literal">#include</code> directive and to place the implementation section in a separate module that you link with your applications.<a class="indexterm" id="IDX-CHP-12-0013"/><a class="indexterm" id="IDX-CHP-12-0014"/></p><p>The include file would contain <code class="literal">external</code> directives, any necessary macros, and other definitions you want made public. It generally would not contain 80x86 code except, perhaps, in some macros. When an application wants to make use of an ADT, it would include this file.</p><p>The separate assembly file containing the implementation section would contain all the procedures, functions, data objects, and so on to actually implement the ADT. Those names that you want to be public should appear in the interface include file and have the <code class="literal">external</code> attribute. You should also include the interface include file in the implementation file so you do not have to maintain two sets of <code class="literal">external</code> directives.</p><p>One problem with using procedures for data access methods is the fact that many accessor methods are especially trivial (e.g., just a <code class="literal">mov</code> instruction), and the overhead of the call and return instructions is expensive for such trivial operations. For example, suppose you have an ADT whose data object is a structure, but you do not want to make the field names visible to the application and you really do not want to allow the application to access the fields of the data structure directly (because the data structure may change in the future). The normal way to handle this is to supply a <code class="literal">GetField</code> method that returns the value of the desired field. However, as pointed out above, this can be very slow. An alternative for simple access methods is to use a macro to emit the code to access the desired field. Although code to directly access the data object appears in the application program (via macro expansion), a recompile will automatically update it if you ever change the macro in the interface section.</p><p>Although it is quite possible to create ADTs using nothing more than separate compilation and, perhaps, records, HLA does provide a better solution: the class. Read on to find out about HLA's support for classes and objects as well as how to use these to create ADTs.<a class="indexterm" id="IDX-CHP-12-0015"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-1" id="ftn.CHP-12-FN-1">132</a>] </sup>Lifetime means the time during which the system allocates memory for an object.</p></div></div></div>
<div class="sect1" title="12.2 Classes in HLA"><div class="titlepage"><div><div><h1 class="title"><a id="classes_in_hla"/>12.2 Classes in HLA</h1></div></div></div><p>Fundamentally, a <span class="emphasis"><em>class</em></span> is a record declaration that allows the definition of non-data fields (e.g., procedures, constants, and macros). The inclusion of other objects in the class definition dramatically expands the capabilities of a class. For example, with a class it is now possible to easily define an ADT because classes may include data and methods (procedures) that operate on that data.</p><p>The principle way to create an abstract data type in HLA is to declare a class data type. Classes in HLA always appear in the <code class="literal">type</code> section and use the following syntax:<a class="indexterm" id="IDX-CHP-12-0016"/></p><a id="I_programlisting12_d1e53145"/><pre class="programlisting">classname : class

               &lt;&lt; Class declaration section &gt;&gt;

          endclass;</pre><p>The class declaration section is very similar to the local declaration section for a procedure insofar as it allows <code class="literal">const</code>, <code class="literal">val</code>, <code class="literal">var</code>, <code class="literal">storage</code>, <code class="literal">readonly</code>, <code class="literal">static</code>, and <code class="literal">proc</code> variable declaration sections. Classes also let you define macros and specify procedure, iterator,<sup>[<a class="footnote" href="#ftn.CHP-12-FN-2" id="CHP-12-FN-2">133</a>]</sup> and <span class="emphasis"><em>method</em></span> prototypes (method declarations are legal only in classes). Conspicuously absent from this list is the type declaration section. You cannot declare new types within a class.</p><p>A <span class="emphasis"><em>method</em></span> is a special type of procedure that appears only within a class. A little later you will see the difference between procedures and methods; for now you can treat them as being the same. Other than a few subtle details regarding class initialization and the use of pointers to classes, their semantics are identical.<sup>[<a class="footnote" href="#ftn.CHP-12-FN-3" id="CHP-12-FN-3">134</a>]</sup> Generally, if you don't know whether to use a procedure or method in a class, the safest bet is to use a method.<a class="indexterm" id="IDX-CHP-12-0017"/></p><p>You do not place procedure/iterator/method code within a class. Instead you simply supply <span class="emphasis"><em>prototypes</em></span> for these routines. A routine prototype consists of the <code class="literal">procedure</code>, <code class="literal">iterator</code>, or <code class="literal">method</code> reserved word, the routine name, any parameters, and a couple of optional procedure attributes (<code class="literal">@use</code>, <code class="literal">@returns</code>, and <code class="literal">external</code>). The actual routine definition (the body of the routine and any local declarations it needs) appears outside the class.</p><p>The following example demonstrates a typical class declaration appearing in the <code class="literal">type</code> section:</p><a id="I_programlisting12_d1e53219"/><pre class="programlisting">TYPE
     TypicalClass:  class

          Const
               TCconst := 5;

          Val
               TCval := 6;

          var
               TCvar : uns32; // Private field used only by TCproc.

          static
               TCstatic : int32;

          procedure TCproc( u:uns32 ); @returns( "eax" );
          iterator TCiter( i:int32 ); external;

          method TCmethod( c:char );

     endclass;</pre><p>As you can see, classes are very similar to records in HLA. Indeed, you can think of a record as being a class that allows only <code class="literal">var</code> declarations. HLA implements classes in a fashion quite similar to records insofar as it allocates sequential data fields in sequential memory locations. In fact, with only one minor exception, there is almost no difference between a <code class="literal">record</code> declaration and a <code class="literal">class</code> declaration that has only a <code class="literal">var</code> declaration section. Later you'll see exactly how HLA implements classes, but for now you can assume that HLA implements them the same as it does records, and you won't be too far off the mark.<a class="indexterm" id="IDX-CHP-12-0018"/><a class="indexterm" id="IDX-CHP-12-0019"/></p><p>You can access the <code class="literal">TCvar</code> and <code class="literal">TCstatic</code> fields (in the class above) just like a record's fields. You access the <code class="literal">const</code> and <code class="literal">val</code> fields in a similar manner. If a variable of type <code class="literal">TypicalClass</code> has the name <code class="literal">obj</code>, you can access the fields of <code class="literal">obj</code> as follows:</p><a id="I_programlisting12_d1e53270"/><pre class="programlisting">mov ( obj.TCconst, eax );
    mov( obj.TCval, ebx );
    add( obj.TCvar, eax );
    add( obj.TCstatic, ebx );
    obj.TCproc( 20 );  // Calls the TCproc procedure in TypicalClass.
    etc.</pre><p>If an application program includes the class declaration above, it can create variables using the <code class="literal">TypicalClass</code> type and perform operations using the mentioned methods. Unfortunately, the application program can also access the fields of the ADT with impunity. For example, if a program created a variable <code class="literal">MyClass</code> of type <code class="literal">TypicalClass</code>, then it could easily execute instructions like <code class="literal">mov( MyClass.TCvar, eax );</code> even though this field might be private to the implementation section. Unfortunately, if you are going to allow an application to declare a variable of type <code class="literal">TypicalClass</code>, the field names will have to be visible. While there are some tricks we could play with HLA's class definitions to help hide the private fields, the best solution is to thoroughly comment the private fields and then exercise some restraint when accessing the fields of that class. Specifically, this means that ADTs you create using HLA's classes cannot be "pure" ADTs because HLA allows direct access to the data fields. However, with a little discipline, you can simulate a pure ADT by simply electing not to access such fields outside the class's methods, procedures, and iterators.</p><p>Prototypes appearing in a class are effectively forward declarations. Like normal forward declarations, all procedures, iterators, and methods you define in a class must have an actual implementation later in the code. Alternately, you may attach the <code class="literal">external</code> option to the end of a procedure, iterator, or method declaration within a class to inform HLA that the actual code appears in a separate module. As a general rule, class declarations appear in header files and represent the interface section of an ADT. The procedure, iterator, and method bodies appear in the implementation section, which is usually a separate source file that you compile separately and link with the modules that use the class.<a class="indexterm" id="IDX-CHP-12-0020"/><a class="indexterm" id="IDX-CHP-12-0021"/><a class="indexterm" id="IDX-CHP-12-0022"/><a class="indexterm" id="IDX-CHP-12-0023"/><a class="indexterm" id="IDX-CHP-12-0024"/><a class="indexterm" id="IDX-CHP-12-0025"/><a class="indexterm" id="IDX-CHP-12-0026"/><a class="indexterm" id="IDX-CHP-12-0027"/><a class="indexterm" id="IDX-CHP-12-0028"/><a class="indexterm" id="IDX-CHP-12-0029"/><a class="indexterm" id="IDX-CHP-12-0030"/><a class="indexterm" id="IDX-CHP-12-0031"/><a class="indexterm" id="IDX-CHP-12-0032"/><a class="indexterm" id="IDX-CHP-12-0033"/><a class="indexterm" id="IDX-CHP-12-0034"/><a class="indexterm" id="IDX-CHP-12-0035"/><a class="indexterm" id="IDX-CHP-12-0036"/><a class="indexterm" id="IDX-CHP-12-0037"/><a class="indexterm" id="IDX-CHP-12-0038"/><a class="indexterm" id="IDX-CHP-12-0039"/><a class="indexterm" id="IDX-CHP-12-0040"/><a class="indexterm" id="IDX-CHP-12-0041"/><a class="indexterm" id="IDX-CHP-12-0042"/><a class="indexterm" id="IDX-CHP-12-0043"/><a class="indexterm" id="IDX-CHP-12-0044"/><a class="indexterm" id="IDX-CHP-12-0045"/><a class="indexterm" id="IDX-CHP-12-0046"/><a class="indexterm" id="IDX-CHP-12-0047"/><a class="indexterm" id="IDX-CHP-12-0048"/><a class="indexterm" id="IDX-CHP-12-0049"/><a class="indexterm" id="IDX-CHP-12-0050"/></p><p>The following is an example of a sample class procedure implementation:</p><a id="I_programlisting12_d1e53448"/><pre class="programlisting">procedure TypicalClass.TCproc( u:uns32 ); @nodisplay;
     &lt;&lt; Local declarations for this procedure &gt;&gt;
begin TCproc;

     &lt;&lt; Code to implement whatever this procedure does &gt;&gt;

end TCProc;</pre><p>There are several differences between a standard procedure declaration and a class procedure declaration. First, and most obvious, the procedure name includes the class name (e.g., <code class="literal">TypicalClass.TCproc</code>). This differentiates this class procedure definition from a regular procedure that just happens to have the name <code class="literal">TCproc</code>. Note, however, that you do not have to repeat the class name before the procedure name in the <code class="literal">begin</code> and <code class="literal">end</code> clauses of the procedure (this is similar to procedures you define in HLA namespaces).<a class="indexterm" id="IDX-CHP-12-0051"/></p><p>A second difference between class procedures and nonclass procedures is not obvious. Some procedure attributes (<code class="literal">@use</code>, <code class="literal">external</code>, <code class="literal">@returns</code>, <code class="literal">@cdecl</code>, <code class="literal">@pascal</code>, and <code class="literal">@stdcall</code>) are legal only in the prototype declaration appearing within the class, while other attributes (<code class="literal">@noframe</code>, <code class="literal">@nodisplay</code>, <code class="literal">@noalignstack</code>, and <code class="literal">@align</code>) are legal only within the procedure definition and not within the class. Fortunately, HLA provides helpful error messages if you stick the option in the wrong place, so you don't have to memorize this rule.</p><p>If a class routine's prototype does not have the <code class="literal">external</code> option, the compilation unit (that is, the program or unit) containing the class declaration must also contain the routine's definition or HLA will generate an error at the end of the compilation. For small, local classes (that is, when you're embedding the class declaration and routine definitions in the same compilation unit) the convention is to place the class's procedure, iterator, and method definitions in the source file shortly after the class declaration. For larger systems (that is, when separately compiling a class's routines), the convention is to place the class declaration in a header file by itself and place all the procedure, iterator, and method definitions in a separate HLA unit and compile them by themselves.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-2" id="ftn.CHP-12-FN-2">133</a>] </sup>This text does not discuss iterators. See the HLA reference manual for details on this type of function.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-3" id="ftn.CHP-12-FN-3">134</a>] </sup>Note, however, that the difference between procedures and methods makes all the difference in the world to the object-oriented programming paradigm, hence the inclusion of methods in HLA's class definitions.</p></div></div></div>
<div class="sect1" title="12.3 Objects"><div class="titlepage"><div><div><h1 class="title"><a id="objects"/>12.3 Objects</h1></div></div></div><p>Remember, a class definition is just a type. Therefore, when you declare a class type you haven't created a variable whose fields you can manipulate. An <span class="emphasis"><em>object</em></span> is an <span class="emphasis"><em>instance</em></span> of a class; that is, an object is a variable whose type is some class. You declare objects (i.e., class variables) the same way you declare other variables: in a <code class="literal">var</code>, <code class="literal">static</code>, or <code class="literal">storage</code> section.<sup>[<a class="footnote" href="#ftn.CHP-12-FN-4" id="CHP-12-FN-4">135</a>]</sup> Here is a pair of sample object declarations:</p><a id="I_programlisting12_d1e53538"/><pre class="programlisting">var
     T1: TypicalClass;
     T2: TypicalClass;</pre><p>For a given class object, HLA allocates storage for each variable appearing in the <code class="literal">var</code> section of the class declaration. If you have two objects, <code class="literal">T1</code> and <code class="literal">T2</code>, of type <code class="literal">TypicalClass</code>, then <code class="literal">T1.TCvar</code> is unique, as is <code class="literal">T2.TCvar</code>. This is the intuitive result (similar to <code class="literal">record</code> declarations); most data fields you define in a class will appear in the <code class="literal">var</code> declaration section of the class.</p><p>Static data objects (for example, those you declare in the <code class="literal">static</code> or <code class="literal">storage</code> sections of a class declaration) are not unique among the objects of that class; that is, HLA allocates only a single static variable that all variables of that class share. For example, consider the following (partial) class declaration and object declarations:</p><a id="I_programlisting12_d1e53575"/><pre class="programlisting">type
     sc: class

          var
               i:int32;

          static
               s:int32;
               .
               .
               .
     endclass;

var
     s1: sc;
     s2: sc;</pre><p>In this example, <code class="literal">s1.i</code> and <code class="literal">s2.i</code> are different variables. However, <code class="literal">s1.s</code> and <code class="literal">s2.s</code> are aliases of one another. Therefore, an instruction like <code class="literal">mov(5, s1.s);</code> also stores 5 into <code class="literal">s2.s</code>. Generally you use static class variables to maintain information about the whole class, while you use class <code class="literal">var</code> objects to maintain information about the specific object. Because keeping track of class information is relatively rare, you will probably declare most class data fields in a <code class="literal">var</code> section.</p><p>You can also create dynamic instances of a class and refer to those dynamic objects via pointers. In fact, this is probably the most common form of object storage and access. The following code shows how to create pointers to objects and how you can dynamically allocate storage for an object:<a class="indexterm" id="IDX-CHP-12-0052"/><a class="indexterm" id="IDX-CHP-12-0053"/></p><a id="I_programlisting12_d1e53614"/><pre class="programlisting">var
     pSC: pointer to sc;
          .
          .
          .
     mem.alloc( @size( sc ) );
     mov( eax, pSC );
          .
          .
          .
     mov( pSC, ebx );
     mov( (type sc [ebx]).i, eax );</pre><p>Note the use of type coercion to cast the pointer in EBX as type <code class="literal">sc</code>.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-4" id="ftn.CHP-12-FN-4">135</a>] </sup>Technically, you could also declare an object in a <code class="literal">readonly</code> section, but HLA does not allow you to define class constants, so there is little utility in declaring class objects in the <code class="literal">readonly</code> section.</p></div></div></div>
<div class="sect1" title="12.4 Inheritance"><div class="titlepage"><div><div><h1 class="title"><a id="inheritance"/>12.4 Inheritance</h1></div></div></div><p>Inheritance is one of the most fundamental ideas behind object-oriented programming. The basic idea is that a class inherits, or copies, all the fields from some class and then possibly expands the number of fields in the new data type. For example, suppose you created a data type <code class="literal">point</code> that describes a point in the planar (two-dimensional) space. The class for this <code class="literal">point</code> might look like the following:<a class="indexterm" id="IDX-CHP-12-0054"/></p><a id="I_programlisting12_d1e53635"/><pre class="programlisting">type
     point: class

          var
               x:int32;
               y:int32;

          method distance;

     endclass;</pre><p>Suppose you want to create a <code class="literal">point</code> in 3D space rather than 2D space. You can easily build such a data type as follows:</p><a id="I_programlisting12_d1e53642"/><pre class="programlisting">type
     point3D: class inherits( point )

          var
               z:int32;

     endclass;</pre><p>The <code class="literal">inherits</code> option on the <code class="literal">class</code> declaration tells HLA to insert the fields of <code class="literal">point</code> at the beginning of the class. In this case, <code class="literal">point3D</code> inherits the fields of <code class="literal">point</code>. HLA always places the inherited fields at the beginning of a class object. The reason for this will become clear a little later. If you have an instance of <code class="literal">point3D</code>, which you call <code class="literal">P3</code>, then the following 80x86 instructions are all legal:<a class="indexterm" id="IDX-CHP-12-0055"/></p><a id="I_programlisting12_d1e53671"/><pre class="programlisting">mov( P3.x, eax );
     add( P3.y, eax );
     mov( eax, P3.z );
     P3.distance();</pre><p>Note that the <code class="literal">p3.distance</code> method invocation in this example calls the <code class="literal">point.distance</code> method. You do not have to write a separate <code class="literal">distance</code> method for the <code class="literal">point3D</code> class unless you really want to do so (see the next section for details). Just like the <code class="literal">x</code> and <code class="literal">y</code> fields, <code class="literal">point3D</code> objects inherit <code class="literal">point</code>'s methods.</p></div>
<div class="sect1" title="12.5 Overriding"><div class="titlepage"><div><div><h1 class="title"><a id="overriding"/>12.5 Overriding</h1></div></div></div><p><span class="emphasis"><em>Overriding</em></span> is the process of replacing an existing method in an inherited class with one more suitable for the new class. In the <code class="literal">point</code> and <code class="literal">point3D</code> examples appearing in the previous section, the <code class="literal">distance</code> method (presumably) computes the distance from the origin to the specified point. For a point on a two-dimensional plane, you can compute the distance using the following function:</p><table border="0" class="simplelist" summary="Simple list"><tr><td><span class="emphasis"><em>d = √ x<sup>2</sup> + y<sup>2</sup></em></span></td></tr></table><p>However, the distance for a point in 3D space is given by this equation:</p><table border="0" class="simplelist" summary="Simple list"><tr><td><span class="emphasis"><em>d = √ x<sup>2</sup> + y<sup>2</sup> + z<sup>2</sup></em></span></td></tr></table><p>Clearly, if you call the <code class="literal">distance</code> function for <code class="literal">point</code> for a <code class="literal">point3D</code> object, you will get an incorrect answer. In the previous section, however, you saw that the <code class="literal">P3</code> object calls the <code class="literal">distance</code> function inherited from the <code class="literal">point</code> class. Therefore, this would produce an incorrect result.</p><p>In this situation the <code class="literal">point3D</code> data type must override the <code class="literal">distance</code> method with one that computes the correct value. You cannot simply redefine the <code class="literal">point3D</code> class by adding a <code class="literal">distance</code> method prototype:</p><a id="I_programlisting12_d1e53774"/><pre class="programlisting">type
     point3D:     class inherits( point )

          var
               z:int32;
          method distance; // This doesn't work!
     endclass;</pre><p>The problem with the <code class="literal">distance</code> method declaration above is that <code class="literal">point3D</code> already has a <code class="literal">distance</code> method—the one that it inherits from the <code class="literal">point</code> class. HLA will complain because it doesn't like two methods with the same name in a single class.<a class="indexterm" id="IDX-CHP-12-0056"/><a class="indexterm" id="IDX-CHP-12-0057"/></p><p>To solve this problem, we need some mechanism by which we can override the declaration of <code class="literal">point.distance</code> and replace it with a declaration for <code class="literal">point3D.distance</code>. To do this, you use the <code class="literal">override</code> keyword before the method declaration:</p><a id="I_programlisting12_d1e53809"/><pre class="programlisting">type
     point3D: class inherits( point )

          var
               z:int32;

          override method distance; // This will work!

     endclass;</pre><p>The <code class="literal">override</code> prefix tells HLA to ignore the fact that <code class="literal">point3D</code> inherits a method named <code class="literal">distance</code> from the <code class="literal">point</code> class. Now, any call to the <code class="literal">distance</code> method via a <code class="literal">point3D</code> object will call the <code class="literal">point3D.distance</code> method rather than <code class="literal">point.distance</code>. Of course, once you override a method using the <code class="literal">override</code> prefix, you must supply the method in the implementation section of your code. For example:</p><a id="I_programlisting12_d1e53842"/><pre class="programlisting">method point3D.distance; @nodisplay;

     &lt;&lt; Local declarations for the distance function &gt;&gt;

begin distance;

     &lt;&lt; Code to implement the distance function &gt;&gt;

end distance;</pre></div>
<div class="sect1" title="12.6 Virtual Methods vs. Static Procedures"><div class="titlepage"><div><div><h1 class="title"><a id="virtual_methods_vs._static_procedures"/>12.6 Virtual Methods vs. Static Procedures</h1></div></div></div><p>A little earlier, this chapter suggested that you could treat class methods and class procedures the same. There are, in fact, some major differences between the two (after all, why have methods if they're the same as procedures?). As it turns out, the differences between methods and procedures are crucial if you want to develop object-oriented programs. Methods provide the second feature necessary to support true polymorphism: virtual procedure calls.<sup>[<a class="footnote" href="#ftn.CHP-12-FN-5" id="CHP-12-FN-5">136</a>]</sup> A virtual procedure call is just a fancy name for an indirect procedure call (using a pointer associated with the object). The key benefit of virtual procedures is that the system automatically calls the right method when using pointers to generic objects.<a class="indexterm" id="IDX-CHP-12-0058"/><a class="indexterm" id="IDX-CHP-12-0059"/></p><p>Consider the following declarations using the <code class="literal">point</code> class from the previous sections:</p><a id="I_programlisting12_d1e53871"/><pre class="programlisting">var
     P2: point;
     P:  pointer to point;</pre><p>Given the declarations above, the following assembly statements are all legal:</p><a id="I_programlisting12_d1e53875"/><pre class="programlisting">mov( P2.x, eax );
     mov( P2.y, ecx );
     P2.distance();       // Calls point3D.distance.

     lea( ebx, P2 );      // Store address of P2 into P.
     mov( ebx, P );
     P.distance();        // Calls point.distance.</pre><p>Note that HLA lets you call a method via a pointer to an object rather than directly via an object variable. This is a crucial feature of objects in HLA and a key to implementing <span class="emphasis"><em>virtual method calls</em></span>.</p><p>The magic behind polymorphism and inheritance is that object pointers are <span class="emphasis"><em>generic</em></span>. In general, when your program references data indirectly through a pointer, the value of the pointer should be the address of some value of the underlying data type associated with that pointer. For example, if you have a pointer to a 16-bit unsigned integer, you wouldn't normally use that pointer to access a 32-bit signed integer value. Similarly, if you have a pointer to some record, you would not normally cast that pointer to some other record type and access the fields of that other type.<sup>[<a class="footnote" href="#ftn.CHP-12-FN-6" id="CHP-12-FN-6">137</a>]</sup> With pointers to class objects, however, we can lift this restriction a little. Pointers to objects may legally contain the address of the object's type <span class="emphasis"><em>or the address of any object that inherits the fields of that type</em></span>. Consider the following declarations that use the <code class="literal">point</code> and <code class="literal">point3D</code> types from the previous examples:</p><a id="I_programlisting12_d1e53900"/><pre class="programlisting">var
     P2: point;
     P3: point3D;
     p:  pointer to point;
          .
          .
          .

     lea( ebx, P2 );
     mov( ebx, p );
     p.distance();         // Calls the point.distance method.
          .
          .
          .
     lea( ebx, P3 );
     mov( ebx, p );        // Yes, this is semantically legal.
     p.distance();         // Surprise, this calls point3D.distance.</pre><p>Because <code class="literal">p</code> is a pointer to a <code class="literal">point</code> object, it might seem intuitive for <code class="literal">p.distance</code> to call the <code class="literal">point.distance</code> method. However, methods are <span class="emphasis"><em>polymorphic</em></span>. If you have a pointer to an object and you call a method associated with that object, the system will call the actual (overridden) method associated with the object, not the method specifically associated with the pointer's class type.<a class="indexterm" id="IDX-CHP-12-0060"/><a class="indexterm" id="IDX-CHP-12-0061"/></p><p>Class procedures behave differently than methods with respect to overridden procedures. When you call a class procedure indirectly through an object pointer, the system will always call the procedure associated with the underlying class. So had <code class="literal">distance</code> been a procedure rather than a method in the previous examples, the <code class="literal">p.distance()</code>; invocation would always call <code class="literal">point.distance</code>, even if <code class="literal">p</code> were pointing at a <code class="literal">point3D</code> object. <a class="xref" href="ch12s09.html" title="12.9 Constructors and Object Initialization">12.9 Constructors and Object Initialization</a> explains why methods and procedures are different.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-5" id="ftn.CHP-12-FN-5">136</a>] </sup><span class="emphasis"><em>Polymorphism</em></span> literally means "many-faced." In the context of object-oriented programming, polymorphism means that the same method name, for example, <code class="literal">distance</code>, refers to one of several different methods.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-6" id="ftn.CHP-12-FN-6">137</a>] </sup>Of course, assembly language programmers break rules like this all the time. For now, let's assume we're playing by the rules and access the data using only the data type associated with the pointer.</p></div></div></div>
<div class="sect1" title="12.7 Writing Class Methods and Procedures"><div class="titlepage"><div><div><h1 class="title"><a id="writing_class_methods_and_procedures"/>12.7 Writing Class Methods and Procedures</h1></div></div></div><p>For each class procedure and method prototype appearing in a class definition, there must be a corresponding procedure or method appearing within the program (for the sake of brevity, this section will use the term <span class="emphasis"><em>routine</em></span> to mean procedure or method from this point forward). If the prototype does not contain the <code class="literal">external</code> option, then the code must appear in the same compilation unit as the class declaration. If the <code class="literal">external</code> option does follow the prototype, then the code may appear in the same compilation unit or a different compilation unit (as long as you link the resulting object file with the code containing the class declaration). Like external (non-class) procedures, if you fail to provide the code, the linker will complain when you attempt to create an executable file. To reduce the size of the following examples, they will all define their routines in the same source file as the class declaration.</p><p>HLA class routines must always follow the class declaration in a compilation unit. If you are compiling your routines in a separate unit, the class declarations must still precede the implementation of the routines from the class (usually via an <code class="literal">#include</code> file). If you haven't defined the class by the time you define a routine like <code class="literal">point.distance</code>, HLA doesn't know that <code class="literal">point</code> is a class and, therefore, doesn't know how to handle the routine's definition.</p><p>Consider the following declarations for a <code class="literal">point2D</code> class:</p><a id="I_programlisting12_d1e53980"/><pre class="programlisting">type
     point2D: class
         const
              UnitDistance: real32 := 1.0;

         var
              x: real32;
              y: real32;

         static
              LastDistance: real32;

         method distance
         (
             fromX: real32;
             fromY: real32
         ); @returns( "st0" );
         procedure InitLastDistance;

     endclass;</pre><p>The <code class="literal">distance</code> function for this class should compute the distance from the object's point to <code class="literal">(fromX,fromY)</code>. The following formula describes this computation:</p><div class="informalequation"><div class="mediaobject"><a id="I_mediaobject12_d1e53991"/><img alt="12.7 Writing Class Methods and Procedures" src="tagoreillycom20100401nostarchimages578079.png"/></div></div><p>A first pass at writing the <code class="literal">distance</code> method might produce the following code:</p><a id="I_programlisting12_d1e54001"/><pre class="programlisting">method point2D.distance( fromX:real32; fromY:real32 ); @nodisplay;
begin distance;

     fld( x );       // Note: this doesn't work!
     fld( fromX );   // Compute (x-fromX)
     fsubp();
     fld( st0 );     // Duplicate value on TOS.
     fmulp();        // Compute square of difference.

     fld( y );       // This doesn't work either.
     fld( fromY );   // Compute (y-fromY)
     fsubp();
     fld( st0 );     // Compute the square of the difference.
     fmulp();
     faddp();
     fsqrt();

end distance;</pre><p>This code probably looks like it should work to someone who is familiar with an object-oriented programming language like C++ or Delphi. However, as the comments indicate, the instructions that push the <code class="literal">x</code> and <code class="literal">y</code> variables onto the FPU stack don't work; HLA doesn't automatically define the symbols associated with the data fields of a class within that class's routines.</p><p>To learn how to access the data fields of a class within that class's routines, we need to back up a moment and discuss some very important implementation details concerning HLA's classes. To do this, consider the following variable declarations:</p><a id="I_programlisting12_d1e54014"/><pre class="programlisting">var
     Origin:    point2D;
     PtInSpace: point2D;</pre><p>Remember, whenever you create two objects like <code class="literal">Origin</code> and <code class="literal">PtInSpace</code>, HLA reserves storage for the <code class="literal">x</code> and <code class="literal">y</code> data fields for both of these objects. However, there is only one copy of the <code class="literal">point2D.distance</code> method in memory. Therefore, were you to call <code class="literal">Origin.distance</code> and <code class="literal">PtInSpace.distance</code>, the system would call the same routine for both method invocations. Once inside that method, one has to wonder what an instruction like <code class="literal">fld( x );</code> would do. How does it associate <code class="literal">x</code> with <code class="literal">Origin.x</code> or <code class="literal">PtInSpace.x</code>? Worse still, how would this code differentiate between the data field <code class="literal">x</code> and a global object <code class="literal">x</code>? In HLA, the answer is, it doesn't. You do not specify the data field names within a class routine by simply using their names as though they were common variables.</p><p>To differentiate <code class="literal">Origin.x</code> from <code class="literal">PtInSpace.x</code> within class routines, HLA automatically passes a pointer to an object's data fields whenever you call a class routine. Therefore, you can reference the data fields indirectly off this pointer. HLA passes this object pointer in the ESI register. This is one of the few places where HLA-generated code will modify one of the 80x86 registers behind your back: <span class="emphasis"><em>Anytime you call a class routine, HLA automatically loads the ESI register with the object's address</em></span>. Obviously, you cannot count on ESI's value being preserved across class routine calls, nor can you pass parameters to the class routine in the ESI register (though it is perfectly reasonable to specify <code class="literal">@use esi;</code> to allow HLA to use the ESI register when setting up other parameters). For class methods (but not procedures), HLA will also load the EDI register with the address of the classes' <span class="emphasis"><em>virtual method table</em></span>. While the virtual method table address isn't as interesting as the object address, keep in mind that <span class="emphasis"><em>HLA-generated code will overwrite any value in the EDI register when you call a class method or an iterator</em></span>. Again, "EDI" is a good choice for the <code class="literal">@use</code> operand for methods because HLA will wipe out the value in EDI anyway.</p><p>Upon entry into a class routine, ESI contains a pointer to the (nonstatic) data fields associated with the class. Therefore, to access fields like <code class="literal">x</code> and <code class="literal">y</code> (in our <code class="literal">point2D</code> example), you could use an address expression like the following:</p><a id="I_programlisting12_d1e54094"/><pre class="programlisting">(type point2D [esi]).x</pre><p>Because you use ESI as the base address of the object's data fields, it's a good idea not to disturb ESI's value within the class routines (or, at least, preserve ESI's value across the code where you must use ESI for some other purpose). Note that within a method you do not have to preserve EDI (unless, for some reason, you need access to the virtual method table, which is unlikely).</p><p>Accessing the fields of a data object within a class's routines is such a common operation that HLA provides a shorthand notation for casting ESI as a pointer to the class object: <code class="literal">this</code>. Within a class in HLA, the reserved word <code class="literal">this</code> automatically expands to a string of the form <code class="literal">(type</code> <em class="replaceable"><code>classname</code></em> <code class="literal">[esi])</code>, substituting, of course, the appropriate class name for <em class="replaceable"><code>classname</code></em>. Using the this keyword, we can (correctly) rewrite the previous distance method as follows:</p><a id="I_programlisting12_d1e54119"/><pre class="programlisting">method point2D.distance( fromX:real32; fromY:real32 ); @nodisplay;
begin distance;

          fld( this.x );
          fld( fromX );     // Compute (x-fromX).
          fsubp();
          fld( st0 );       // Duplicate value on TOS.
          fmulp();          // Compute square of difference.

          fld( this.y );
          fld( fromY );     // Compute (y-fromY).
          fsubp();
          fld( st0 );       // Compute the square of the difference.
          fmulp();
          faddp();
          fsqrt();

end distance;</pre><p>Don't forget that calling a class routine wipes out the value in the ESI register. This isn't obvious from the syntax of the routine's invocation. It is especially easy to forget this when calling some class routine from inside some other class routine; remember that if you do this, the internal call wipes out the value in ESI and on return from that call ESI no longer points at the original object. Always push and pop ESI (or otherwise preserve ESI's value) in this situation. For example:</p><a id="I_programlisting12_d1e54123"/><pre class="programlisting">.
      .
      .
      fld( this.x );         // esi points at current object.
      .
      .
      .
      push( esi );           // Preserve esi across this method call.
      <em class="replaceable"><code>SomeObject</code></em>.<em class="replaceable"><code>SomeMethod</code></em>();
      pop( esi );
      .
      .
      .
      lea( ebx, this.x );    // esi points at original object here.</pre><p>The <code class="literal">this</code> keyword provides access to the class variables you declare in the <code class="literal">var</code> section of a class. You can also use <code class="literal">this</code> to call other class routines associated with the current object. For example:</p><a id="I_programlisting12_d1e54143"/><pre class="programlisting">this.distance( 5.0, 6.0 );</pre><p>To access class constants and <code class="literal">static</code> data fields, you generally do not use the <code class="literal">this</code> pointer. HLA associates constant and static data fields with the whole class, not a specific object ( just like <code class="literal">static</code> fields in a class). To access these class members, use the class name in place of the object name. For example, to access the <code class="literal">UnitDistance</code> constant in the <code class="literal">point2d</code> class you could use a statement like the following:</p><a id="I_programlisting12_d1e54162"/><pre class="programlisting">fld( point2D.UnitDistance );</pre><p>As another example, if you wanted to update the <code class="literal">LastDistance</code> field in the <code class="literal">point2D</code> class each time you computed a distance, you could rewrite the <code class="literal">point2D.distance</code> method as follows:</p><a id="I_programlisting12_d1e54175"/><pre class="programlisting">method point2D.distance( fromX:real32; fromY:real32 ); @nodisplay;
begin distance;

      fld( this.x );
      fld( fromX );        // Compute (x-fromX).
      fsubp();
      fld( st0 );          // Duplicate value on TOS.
      fmulp();             // Compute square of difference.

      fld( this.y );
      fld( fromY );        // Compute (y-fromY).
      fsubp();
      fld( st0 );          // Compute the square of the difference.
      fmulp();
      faddp();
      fsqrt();

      fst( point2D.LastDistance ); // Update shared (STATIC) field.

end distance;</pre><p>The next section will explain why you use the class name when referring to constants and static objects but you use <code class="literal">this</code> to access <code class="literal">var</code> objects.</p><p>Class procedures are also static objects, so it is possible to call a class procedure by specifying the class name rather than an object name in the procedure invocation; for example, both of the following are legal:</p><a id="I_programlisting12_d1e54187"/><pre class="programlisting">Origin.InitLastDistance();
      point2D.InitLastDistance();</pre><p>There is, however, a subtle difference between these two class procedure calls. The first call above loads ESI with the address of the <code class="literal">origin</code> object prior to actually calling the <code class="literal">InitLastDistance</code> procedure. The second call, however, is a direct call to the class procedure without referencing an object; therefore, HLA doesn't know what object address to load into the ESI register. In this case, HLA loads NULL (0) into ESI prior to calling the <code class="literal">InitLastDistance</code> procedure. Because you can call class procedures in this manner, it's always a good idea to check the value in ESI within your class procedures to verify that HLA contains a valid object address. Checking the value in ESI is a good way to determine which calling mechanism is in use. <a class="xref" href="ch12s09.html" title="12.9 Constructors and Object Initialization">12.9 Constructors and Object Initialization</a> discusses constructors and object initialization; then you will see a good use for static procedures and calling those procedures directly (rather than through the use of an object).</p></div>
<div class="sect1" title="12.8 Object Implementation"><div class="titlepage"><div><div><h1 class="title"><a id="object_implementation"/>12.8 Object Implementation</h1></div></div></div><p>In a high-level object-oriented language like C++ or Delphi, it is quite possible to master the use of objects without really understanding how the machine implements them. One of the reasons for learning assembly language programming is to fully comprehend low-level implementation details so you can make educated decisions concerning the use of programming constructs like objects. Further, because assembly language allows you to poke around with data structures at a very low level, knowing how HLA implements objects can help you create certain algorithms that would not be possible without a detailed knowledge of object implementation. Therefore, this section and its corresponding subsections explain the low-level implementation details you will need to know in order to write object-oriented HLA programs.<a class="indexterm" id="IDX-CHP-12-0062"/></p><p>HLA implements objects in a manner quite similar to records. In particular, HLA allocates storage for all <code class="literal">var</code> objects in a class in a sequential fashion, just like records. Indeed, if a class consists of only <code class="literal">var</code> data fields, the memory representation of that class is nearly identical to that of a corresponding <code class="literal">record</code> declaration. Consider the <code class="literal">student</code> record declaration taken from <a class="xref" href="ch04.html" title="Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES">Chapter 4</a> and the corresponding class (see <a class="xref" href="ch12s08.html#student_record_implementation_in_memory" title="Figure 12-1. student record implementation in memory">Figure 12-1</a> and <a class="xref" href="ch12s08.html#student_class_implementation_in_memory" title="Figure 12-2. student class implementation in memory">Figure 12-2</a>, respectively).</p><a id="I_programlisting12_d1e54234"/><pre class="programlisting">type
     student: record
          Name:     char[65];
          Major:    int16;
          SSN:      char[12];
          Midterm1: int16;
          Midterm2: int16;
          Final:    int16;
          Homework: int16;
          Projects: int16;
     endrecord;
     student2: class
          var
               Name:     char[65];
               Major:    int16;
               SSN:      char[12];
               Midterm1: int16;
               Midterm2: int16;
               Final:    int16;
               Homework: int16;
               Projects: int16;
     endclass;</pre><div class="figure"><a id="student_record_implementation_in_memory"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject12_d1e54241"/><img alt="student record implementation in memory" src="tagoreillycom20100401nostarchimages578081.png"/></div></div><p class="title">Figure 12-1. <code class="literal">student</code> record implementation in memory</p></div><div class="figure"><a id="student_class_implementation_in_memory"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject12_d1e54251"/><img alt="student class implementation in memory" src="tagoreillycom20100401nostarchimages578083.png"/></div></div><p class="title">Figure 12-2. <code class="literal">student</code> class implementation in memory</p></div><p>If you look carefully at <a class="xref" href="ch12s08.html#student_record_implementation_in_memory" title="Figure 12-1. student record implementation in memory">Figure 12-1</a> and <a class="xref" href="ch12s08.html#student_class_implementation_in_memory" title="Figure 12-2. student class implementation in memory">Figure 12-2</a>, you'll discover that the only difference between the class and the record implementations is the inclusion of the <code class="literal">VMT</code> (virtual method table) pointer field at the beginning of the class object. This field, which is always present in a class, contains the address of the class's virtual method table that, in turn, contains the addresses of all the class's methods and iterators. The <code class="literal">VMT</code> field, by the way, is present even if a class doesn't contain any methods or iterators.</p><p>As pointed out in previous sections, HLA does not allocate storage for <code class="literal">static</code> objects within the object. Instead, HLA allocates a single instance of each <code class="literal">static</code> data field that all objects share. As an example, consider the following class and object declarations:</p><a id="I_programlisting12_d1e54276"/><pre class="programlisting">type
     tHasStatic: class


          var
               i:int32;
               j:int32;
               r:real32;

          static
               c:char[2];
               b:byte;

     endclass;

var
     hs1: tHasStatic;
     hs2: tHasStatic;</pre><p><a class="xref" href="ch12s08.html#object_allocation_with_static_data_field" title="Figure 12-3. Object allocation with static data fields">Figure 12-3</a> shows the storage allocation for these two objects in memory.</p><div class="figure"><a id="object_allocation_with_static_data_field"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject12_d1e54287"/><img alt="Object allocation with static data fields" src="tagoreillycom20100401nostarchimages578085.png"/></div></div><p class="title">Figure 12-3. Object allocation with <code class="literal">static</code> data fields</p></div><p>Of course, <code class="literal">const</code>, <code class="literal">val</code>, and <code class="literal">#macro</code> objects do not have any runtime memory requirements associated with them, so HLA does not allocate any storage for these fields. Like the <code class="literal">static</code> data fields, you may access <code class="literal">const</code>, <code class="literal">val</code>, and <code class="literal">#macro</code> fields using the class name as well as an object name. Hence, even if <code class="literal">tHasStatic</code> has these types of fields, the memory organization for <code class="literal">tHasStatic</code> objects would still be the same as shown in <a class="xref" href="ch12s08.html#object_allocation_with_static_data_field" title="Figure 12-3. Object allocation with static data fields">Figure 12-3</a>.</p><p>Other than the presence of the virtual method table (<code class="literal">VMT</code>) pointer, the presence of methods and procedures has no impact on the storage allocation of an object. Of course, the machine instructions associated with these routines do appear somewhere in memory. So in a sense the code for the routines is quite similar to <code class="literal">static</code> data fields insofar as all the objects share a single instance of the routine.<a class="indexterm" id="IDX-CHP-12-0063"/><a class="indexterm" id="IDX-CHP-12-0064"/><a class="indexterm" id="IDX-CHP-12-0065"/><a class="indexterm" id="IDX-CHP-12-0066"/><a class="indexterm" id="IDX-CHP-12-0067"/></p><div class="sect2" title="12.8.1 Virtual Method Tables"><div class="titlepage"><div><div><h2 class="title"><a id="virtual_method_tables"/>12.8.1 Virtual Method Tables</h2></div></div></div><p>When HLA calls a class procedure, it directly calls that procedure using a <code class="literal">call</code> instruction, just like any normal procedure call. Methods are another story altogether. Each object in the system carries a pointer to a virtual method table, which is an array of pointers to all the methods and iterators appearing within the object's class (see <a class="xref" href="ch12s08.html#virtual_method_table_organization" title="Figure 12-4. Virtual method table organization">Figure 12-4</a>).</p><div class="figure"><a id="virtual_method_table_organization"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject12_d1e54367"/><img alt="Virtual method table organization" src="tagoreillycom20100401nostarchimages578087.png"/></div></div><p class="title">Figure 12-4. Virtual method table organization</p></div><p>Each iterator or method you declare in a class has a corresponding entry in the virtual method table. That double-word entry contains the address of the first instruction of that iterator or method. Calling a class method or iterator is a bit more work than calling a class procedure (it requires one additional instruction plus the use of the EDI register). Here is a typical calling sequence for a method:</p><a id="I_programlisting12_d1e54374"/><pre class="programlisting">mov( <em class="replaceable"><code>ObjectAdrs</code></em>, ESI );       // All class routines do this.
mov( [esi], edi );            // Get the address of the VMT into edi
call( (type dword [edi+n]));  // "n" is the offset of the method's
                              // entry in the VMT.</pre><p>For a given class there is only one copy of the virtual method table in memory. This is a static object, so all objects of a given class type share the same virtual method table. This is reasonable because all objects of the same class type have exactly the same methods and iterators (see <a class="xref" href="ch12s08.html#all_objects_that_are_the_same_class_type" title="Figure 12-5. All objects that are the same class type share the same VMT.">Figure 12-5</a>).</p><p>Although HLA builds the <code class="literal">VMT</code> record structure as it encounters methods and iterators within a class, HLA does not automatically create the virtual method table for you. You must explicitly declare this table in your program. To do this, you include a statement like the following in a <code class="literal">static</code> or <code class="literal">readonly</code> declaration section of your program. For example:<a class="indexterm" id="IDX-CHP-12-0068"/></p><a id="I_programlisting12_d1e54399"/><pre class="programlisting">readonly
     VMT( <em class="replaceable"><code>classname</code></em> );</pre><div class="figure"><a id="all_objects_that_are_the_same_class_type"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject12_d1e54407"/><img alt="All objects that are the same class type share the same VMT." src="tagoreillycom20100401nostarchimages578089.png"/></div></div><p class="title">Figure 12-5. All objects that are the same class type share the same VMT.</p></div><p>Because the addresses in a virtual method table should never change during program execution, the <code class="literal">readonly</code> section is probably the best choice for declaring virtual method tables. It should go without saying that changing the pointers in a virtual method table is, in general, a really bad idea. So putting <code class="literal">VMT</code>s in a <code class="literal">static</code> section is usually not a good idea.<a class="indexterm" id="IDX-CHP-12-0069"/><a class="indexterm" id="IDX-CHP-12-0070"/><a class="indexterm" id="IDX-CHP-12-0071"/><a class="indexterm" id="IDX-CHP-12-0072"/><a class="indexterm" id="IDX-CHP-12-0073"/><a class="indexterm" id="IDX-CHP-12-0074"/></p><p>A declaration like the one above defines the variable <em class="replaceable"><code>classname</code></em><code class="literal">._VMT_</code>. In <a class="xref" href="ch12s09.html" title="12.9 Constructors and Object Initialization">12.9 Constructors and Object Initialization</a>, you will see that you need this name when initializing object variables. The class declaration automatically defines the <em class="replaceable"><code>classname</code></em><code class="literal">._VMT_</code> symbol as an external static variable. The declaration above just provides the actual definition for this external symbol.</p><p>The declaration of a <code class="literal">VMT</code> uses a somewhat strange syntax because you aren't actually declaring a new symbol with this declaration; you're simply supplying the data for a symbol that you previously declared implicitly by defining a class. That is, the class declaration defines the static table variable <em class="replaceable"><code>classname</code></em><code class="literal">._VMT_</code>; all you're doing with the <code class="literal">VMT</code> declaration is telling HLA to emit the actual data for the table. If, for some reason, you would like to refer to this table using a name other than <em class="replaceable"><code>classname</code></em><code class="literal">._VMT_</code>, HLA does allow you to prefix the declaration above with a variable name. For example:</p><a id="I_programlisting12_d1e54479"/><pre class="programlisting">readonly
     myVMT: VMT( <em class="replaceable"><code>classname</code></em> );</pre><p>In this declaration, <code class="literal">myVMT</code> is an alias of <em class="replaceable"><code>classname</code></em><code class="literal">._VMT_</code>. As a general rule, you should avoid using aliases in a program because they make the program more difficult to read and understand. Therefore, it is unlikely that you would ever need to use this type of declaration.</p><p>As with any other global static variable, there should be only one instance of a virtual method table for a given class in a program. The best place to put the <code class="literal">VMT</code> declaration is in the same source file as the class's method, iterator, and procedure code (assuming they all appear in a single file). This way you will automatically link in the virtual method table whenever you link in the routines for a given class.<a class="indexterm" id="IDX-CHP-12-0075"/><a class="indexterm" id="IDX-CHP-12-0076"/></p></div><div class="sect2" title="12.8.2 Object Representation with Inheritance"><div class="titlepage"><div><div><h2 class="title"><a id="object_representation_with_inheritance"/>12.8.2 Object Representation with Inheritance</h2></div></div></div><p>Up to this point, the discussion of the implementation of class objects has ignored the possibility of inheritance. Inheritance affects the memory representation of an object only by adding fields that are not explicitly stated in the class declaration.</p><p>Adding inherited fields from a <span class="emphasis"><em>base class</em></span> to another class must be done carefully. Remember, an important attribute of a class that inherits fields from a base class is that you can use a pointer to the base class to access the inherited fields from that base class, even if the pointer contains the address of some other class (that inherits the fields from the base class). As an example, consider the following classes:</p><a id="I_programlisting12_d1e54517"/><pre class="programlisting">type
     tBaseClass: class
          var
               i:uns32;
               j:uns32;
               r:real32;

          method mBase;
     endclass;

     tChildClassA: class inherits( tBaseClass )
          var
               c:char;
               b:boolean;
               w:word;

          method mA;
     endclass;

     tChildClassB: class inherits( tBaseClass )
          var
               d:dword;
               c:char;
               a:byte[3];

     endclass;</pre><p>Because both <code class="literal">tChildClassA</code> and <code class="literal">tChildClassB</code> inherit the fields of <code class="literal">tBaseClass</code>, these two child classes include the <code class="literal">i</code>, <code class="literal">j</code>, and <code class="literal">r</code> fields as well as their own specific fields. Furthermore, whenever you have a pointer variable whose base type is <code class="literal">tBaseClass</code>, it is legal to load this pointer with the address of any child class of <code class="literal">tBaseClass</code>; therefore, it is perfectly reasonable to load such a pointer with the address of a <code class="literal">tChildClassA</code> or <code class="literal">tChildClassB</code> variable. For example:<a class="indexterm" id="IDX-CHP-12-0077"/></p><a id="I_programlisting12_d1e54557"/><pre class="programlisting">var
     B1:  tBaseClass;
     CA:  tChildClassA;
     CB:  tChildClassB;
     ptr: pointer to tBaseClass;
          .
          .
          .
     lea( ebx, B1 );
     mov( ebx, ptr );
     &lt;&lt; Use ptr &gt;&gt;
          .
          .
          .
     lea( eax, CA );
     mov( ebx, ptr );
     &lt;&lt; Use ptr &gt;&gt;
          .
          .
          .
     lea( eax, CB );
     mov( eax, ptr );
     &lt;&lt; Use ptr &gt;&gt;</pre><p>Because <code class="literal">ptr</code> points at an object of type <code class="literal">tBaseClass</code>, you may legally (from a semantic sense) access the <code class="literal">i</code>, <code class="literal">j</code>, and <code class="literal">r</code> fields of the object where <code class="literal">ptr</code> is pointing. It is not legal to access the <code class="literal">c</code>, <code class="literal">b</code>, <code class="literal">w</code>, or <code class="literal">d</code> field of the <code class="literal">tChildClassA</code> or <code class="literal">tChildClassB</code> objects because at any one given moment the program may not know exactly what object type <code class="literal">ptr</code> references.</p><p>In order for inheritance to work properly, the <code class="literal">i</code>, <code class="literal">j</code>, and <code class="literal">r</code> fields must appear at the same offsets in all child classes as they do in <code class="literal">tBaseClass</code>. This way, an instruction of the form <code class="literal">mov((type tBaseClass [ebx]).i, eax)</code>; will correctly access the <code class="literal">i</code> field even if EBX points at an object of type <code class="literal">tChildClassA</code> or <code class="literal">tChildClassB</code>. <a class="xref" href="ch12s08.html#layout_of_base_and_child_class_objects_i" title="Figure 12-6. Layout of base and child class objects in memory">Figure 12-6</a> shows the layout of the child and base classes.</p><p>Note that the new fields in the two child classes bear no relation to one another, even if they have the same name (for example, the <code class="literal">c</code> fields in the two child classes do not lie at the same offset). Although the two child classes share the fields they inherit from their common base class, any new fields they add are unique and separate. Two fields in different classes share the same offset only by coincidence if those fields are not inherited from a common base class.</p><div class="figure"><a id="layout_of_base_and_child_class_objects_i"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject12_d1e54639"/><img alt="Layout of base and child class objects in memory" src="tagoreillycom20100401nostarchimages578091.png"/></div></div><p class="title">Figure 12-6. Layout of base and child class objects in memory</p></div><p>All classes (even those that aren't related to one another) place the pointer to the virtual method table at offset 0 within the object. There is a single virtual method table associated with each class in a program; even classes that inherit fields from some base class have a virtual method table that is (generally) different than the base class's table. <a class="xref" href="ch12s08.html#virtual_method_table_references_from_obj" title="Figure 12-7. Virtual method table references from objects">Figure 12-7</a> shows how objects of type <code class="literal">tBaseClass</code>, <code class="literal">tChildClassA</code>, and <code class="literal">tChildClassB</code> point at their specific virtual method tables.</p><div class="figure"><a id="virtual_method_table_references_from_obj"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject12_d1e54661"/><img alt="Virtual method table references from objects" src="tagoreillycom20100401nostarchimages578093.png"/></div></div><p class="title">Figure 12-7. Virtual method table references from objects</p></div><p>A virtual method table is nothing more than an array of pointers to the methods and iterators associated with a class. The address of the first method or iterator that appears in a class is at offset 0, the address of the second appears at offset 4, and so on. You can determine the offset value for a given iterator or method by using the <code class="literal">@offset</code> function. If you want to call a method directly (using 80x86 syntax rather than HLA's high-level syntax), you could use code like the following:</p><a id="I_programlisting12_d1e54671"/><pre class="programlisting">var
     sc: tBaseClass;
          .
          .
          .
     lea( esi, sc );     // Get the address of the object (&amp; VMT).
     mov( [esi], edi );  // Put address of VMT into edi.
     call( (type dword [edi+@offset( tBaseClass.mBase )] );</pre><p>Of course, if the method has any parameters, you must push them onto the stack before executing the code above. Don't forget when making direct calls to a method, you must load ESI with the address of the object. Any field references within the method will probably depend on ESI containing this address. The choice of EDI to contain the <code class="literal">VMT</code> address is nearly arbitrary. Unless you're doing something tricky (like using EDI to obtain runtime type information), you could use any register you please here. As a general rule, you should use EDI when simulating class method calls because this is the convention that HLA employs, and most programmers will expect this usage.</p><p>Whenever a child class inherits fields from some base class, the child class's virtual method table also inherits entries from the base class's table. For example, the virtual method table for class <code class="literal">tBaseClass</code> contains only a single entry—a pointer to method <code class="literal">tBaseClass.mBase</code>. The virtual method table for class <code class="literal">tChildClassA</code> contains two entries: a pointer to <code class="literal">tBaseClass.mBase</code> and <code class="literal">tChildClassA.mA</code>. Because <code class="literal">tChildClassB</code> doesn't define any new methods or iterators, <code class="literal">tChildClassB</code>'s virtual method table contains only a single entry, a pointer to the <code class="literal">tBaseClass.mBase</code> method. Note that <code class="literal">tChildClassB</code>'s virtual method table is identical to <code class="literal">tBaseclass</code>'s table. Nevertheless, HLA produces two distinct virtual method tables. This is a critical fact that we will make use of a little later. <a class="xref" href="ch12s08.html#virtual_method_tables_for_inherited_clas" title="Figure 12-8. Virtual method tables for inherited classes">Figure 12-8</a> shows the relationship between these virtual method tables.</p><div class="figure"><a id="virtual_method_tables_for_inherited_clas"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject12_d1e54716"/><img alt="Virtual method tables for inherited classes" src="tagoreillycom20100401nostarchimages578095.png.jpg"/></div></div><p class="title">Figure 12-8. Virtual method tables for inherited classes</p></div><p>Although the virtual method table pointer always appears at offset 0 in an object (and, therefore, you can access the pointer using the address expression <code class="literal">[ESI]</code> if ESI points at an object), HLA actually inserts a symbol into the symbol table so you may refer to the virtual method table pointer symbolically. The symbol <code class="literal">_pVMT_</code> (pointer to virtual method table) provides this capability. So a more readable way to access the pointer (as in the previous code example) is:<a class="indexterm" id="IDX-CHP-12-0078"/><a class="indexterm" id="IDX-CHP-12-0079"/><a class="indexterm" id="IDX-CHP-12-0080"/><a class="indexterm" id="IDX-CHP-12-0081"/><a class="indexterm" id="IDX-CHP-12-0082"/></p><a id="I_programlisting12_d1e54752"/><pre class="programlisting">lea( esi, sc );
     mov( (type tBaseClass [esi])._pVMT_, edi );
     call( (type dword [edi+@offset( tBaseClass.mBase )] );</pre><p>If you need to access the virtual method table directly, there are a couple of ways to do this. Whenever you declare a class object, HLA automatically includes a field named <code class="literal">_VMT_</code> as part of that class. <code class="literal">_VMT_</code> is a static array of double-word objects. Therefore, you may refer to the virtual method table using an identifier of the form <em class="replaceable"><code>classname</code></em><code class="literal">._VMT_</code>. Generally, you shouldn't access the virtual method table directly, but as you'll see shortly, there are some good reasons why you need to know the address of this object in memory.</p></div></div>
<div class="sect1" title="12.9 Constructors and Object Initialization"><div class="titlepage"><div><div><h1 class="title"><a id="constructors_and_object_initialization"/>12.9 Constructors and Object Initialization</h1></div></div></div><p>If you've tried to get a little ahead of the game and write a program that uses objects prior to this point, you've probably discovered that the program inexplicably crashes whenever you attempt to run it. We've covered a lot of material in this chapter thus far, but you are still missing one crucial piece of information—how to properly initialize objects prior to use. This section will put the final piece into the puzzle and allow you to begin writing programs that use classes.</p><p>Consider the following object declaration and code fragment:</p><a id="I_programlisting12_d1e54774"/><pre class="programlisting">var
     bc: tBaseClass;
          .
          .
          .
     bc.mBase();</pre><p>Remember that variables you declare in the <code class="literal">var</code> section are uninitialized at runtime. Therefore, when the program containing these statements gets around to executing <code class="literal">bc.mBase</code>, it executes the three-statement sequence you've seen several times already:</p><a id="I_programlisting12_d1e54784"/><pre class="programlisting">lea( esi, bc);
     mov( [esi], edi );
     call( (type dword [edi+@offset( tBaseClass.mBase )] );</pre><p>The problem with this sequence is that it loads EDI with an undefined value assuming you haven't previously initialized the <code class="literal">bc</code> object. Because EDI contains a garbage value, attempting to call a subroutine at address <code class="literal">[EDI+@offset(tBaseClass.mBase)]</code> will likely crash the system. Therefore, before using an object, you must initialize the <code class="literal">_pVMT_</code> field with the address of that object's virtual method table. One easy way to do this is with the following statement:<a class="indexterm" id="IDX-CHP-12-0083"/><a class="indexterm" id="IDX-CHP-12-0084"/><a class="indexterm" id="IDX-CHP-12-0085"/><a class="indexterm" id="IDX-CHP-12-0086"/></p><a id="I_programlisting12_d1e54811"/><pre class="programlisting">mov( &amp;tBaseClass._VMT_, bc._pVMT_ );</pre><p>Always remember, before using an object, be sure to initialize the virtual method table pointer for that object.</p><p>Although you must initialize the virtual method table pointer for all objects you use, this may not be the only field you need to initialize in those objects. Each specific class may have its own application-specific initialization. Although the initialization may vary by class, you need to perform the same initialization on each object of a specific class that you use. If you ever create more than a single object from a given class, it is probably a good idea to create a procedure to do this initialization for you. This is such a common operation that object-oriented programmers have given these initialization procedures a special name: <span class="emphasis"><em>constructors</em></span>.<a class="indexterm" id="IDX-CHP-12-0087"/></p><p>Some object-oriented languages (e.g., C++) use a special syntax to declare a constructor. Others (e.g., Delphi) simply use existing procedure declarations to define a constructor. One advantage to employing a special syntax is that the language knows when you define a constructor and can automatically generate code to call that constructor for you (whenever you declare an object). Languages like Delphi require that you explicitly call the constructor; this can be a minor inconvenience and a source of defects in your programs. HLA does not use a special syntax to declare constructors: you define constructors using standard class procedures. Thus, you will need to explicitly call the constructors in your program; however, you'll see an easy method for automating this in <a class="xref" href="ch12s11.html" title="12.11 HLA's _initialize_ and _finalize_ Strings">12.11 HLA's _initialize_ and _finalize_ Strings</a>.</p><p>Perhaps the most important fact you must remember is that <span class="emphasis"><em>constructors must be class procedures</em></span>. You must not define constructors as methods. The reason is quite simple: one of the tasks of the constructor is to initialize the pointer to the virtual method table, and you cannot call a class method or iterator until after you've initialized the <code class="literal">VMT</code> pointer. Because class procedures don't use the virtual method table, you can call a class procedure prior to initializing the <code class="literal">VMT</code> pointer for an object.</p><p>By convention, HLA programmers use the name <code class="literal">create</code> for the class constructor. There is no requirement that you use this name, but by doing so you will make your programs easier to read and follow by other programmers.</p><p>As you may recall, you can call a class procedure via an object reference or a class reference. For example, if <code class="literal">clsProc</code> is a class procedure of class <code class="literal">tClass</code> and <code class="literal">Obj</code> is an object of type <code class="literal">tClass</code>, then the following two class procedure invocations are both legal.</p><a id="I_programlisting12_d1e54858"/><pre class="programlisting">tClass.clsProc();
     Obj.clsProc();</pre><p>There is a big difference between these two calls. The first one calls <code class="literal">clsProc</code> with ESI containing 0 (NULL), while the second invocation loads the address of <code class="literal">Obj</code> into ESI before the call. We can use this fact to determine within a method the particular calling mechanism.</p><div class="sect2" title="12.9.1 Dynamic Object Allocation Within the Constructor"><div class="titlepage"><div><div><h2 class="title"><a id="dynamic_object_allocation_within_the_con"/>12.9.1 Dynamic Object Allocation Within the Constructor</h2></div></div></div><p>As it turns out, most programs allocate objects dynamically using <code class="literal">mem.alloc</code> and refer to those objects indirectly using pointers. This adds one more step to the initialization process—allocating storage for the object. The constructor is the perfect place to allocate this storage. Because you probably won't need to allocate all objects dynamically, you'll need two types of constructors: one that allocates storage and then initializes the object, and another that simply initializes an object that already has storage.</p><p>Another constructor convention is to merge these two constructors into a single constructor and differentiate the type of constructor call by the value in ESI. On entry into the class's <code class="literal">create</code> procedure, the program checks the value in ESI to see if it contains NULL (0). If so, the constructor calls <code class="literal">mem.alloc</code> to allocate storage for the object and returns a pointer to the object in ESI. If ESI does not contain NULL upon entry into the procedure, then the constructor assumes that ESI points at a valid object and skips over the memory allocation statements. At the very least, a constructor initializes the pointer to the virtual method table; therefore, the minimalist constructor will look like the following:<a class="indexterm" id="IDX-CHP-12-0088"/></p><a id="I_programlisting12_d1e54889"/><pre class="programlisting">procedure tBaseClass.create; @nodisplay;
begin create;

  if( ESI = 0 ) then

      push( eax );      // mem.alloc returns its result here, so save it.
      mem.alloc( @size( tBaseClass ));
      mov( eax, esi );  // Put pointer into esi.
      pop( eax );

  endif;

  // Initialize the pointer to the VMT:
  // Remember, "this" is shorthand for "(type tBaseClass [esi])".

  mov( &amp;tBaseClass._VMT_, this._pVMT_ );

  // Other class initialization would go here.

end create;</pre><p>After you write a constructor like the preceding, you choose an appropriate calling mechanism based on whether your object's storage is already allocated. For preallocated objects (such as those you've declared in <code class="literal">var</code>, <code class="literal">static</code>, or <code class="literal">storage</code> sections<sup>[<a class="footnote" href="#ftn.CHP-12-FN-7" id="CHP-12-FN-7">138</a>]</sup> or those you've previously allocated storage for via <code class="literal">mem.alloc</code>), you simply load the address of the object into ESI and call the constructor. For those objects you declare as a variable, this is very easy; just call the appropriate <code class="literal">create</code> constructor:</p><a id="I_programlisting12_d1e54916"/><pre class="programlisting">var
     bc0: tBaseClass;
     bcp: pointer to tBaseClass;
          .
          .
          .
     bc0.create();  // Initializes preallocated bc0 object.
          .
          .
          .
     // Allocate storage for bcp object.

     mem.alloc( @size( tBaseClass ));
     mov( eax, bcp );
          .
          .
          .
     bcp.create();  // Initializes preallocated bcp object.</pre><p>Note that although <code class="literal">bcp</code> is a pointer to a <code class="literal">tBaseClass</code> object, the create method does not automatically allocate storage for this object. The program already allocated the storage earlier. Therefore, when the program calls <code class="literal">bcp.create</code>, it loads ESI with the address contained within <code class="literal">bcp</code>; because this is not NULL, the <code class="literal">tBaseClass.create</code> procedure does not allocate storage for a new object. By the way, the call to <code class="literal">bcp.create</code> emits the following sequence of machine instructions:</p><a id="I_programlisting12_d1e54939"/><pre class="programlisting">mov( bcp, esi );
     call tBaseClass.create;</pre><p>Until now, the code examples for a class procedure call always began with an <code class="literal">lea</code> instruction. This is because all the examples to this point have used object variables rather than pointers to object variables. Remember, a class procedure (method) call passes the address of the object in the ESI register. For object variables HLA emits an <code class="literal">lea</code> instruction to obtain this address. For pointers to objects, however, the actual object address is the <span class="emphasis"><em>value</em></span> of the pointer variable; therefore, to load the address of the object into ESI, HLA emits a <code class="literal">mov</code> instruction that copies the value of the pointer into the ESI register.</p><p>In the preceding example, the program preallocates the storage for an object prior to calling the object constructor. While there are several reasons for preallocating object storage (for example, you're creating a dynamic array of objects), you can achieve most simple object allocations like the one above by calling a standard <code class="literal">create</code> procedure (such as one that allocates storage for an object if ESI contains <code class="literal">NULL</code>). The following example demonstrates this:<a class="indexterm" id="IDX-CHP-12-0089"/></p><a id="I_programlisting12_d1e54968"/><pre class="programlisting">var
     bcp2: pointer to tBaseClass;
          .
          .
          .
   tBaseClass.create(); // Calls create with esi=NULL.
   mov( esi, bcp2 );    // Save pointer to new class object in bcp2.</pre><p>Remember, a call to a <code class="literal">tBaseClass.create</code> constructor returns a pointer to the new object in the ESI register. It is the caller's responsibility to save the pointer this function returns into the appropriate pointer variable; the constructor does not automatically do this for you. Likewise, it is the caller's responsibility to free the storage associated with this object when the application has finished using the object (see the discussion of destructors in <a class="xref" href="ch12s10.html" title="12.10 Destructors">12.10 Destructors</a>).</p></div><div class="sect2" title="12.9.2 Constructors and Inheritance"><div class="titlepage"><div><div><h2 class="title"><a id="constructors_and_inheritance"/>12.9.2 Constructors and Inheritance</h2></div></div></div><p>Constructors for derived (child) classes that inherit fields from a base class represent a special case. Each class must have its own constructor but needs the ability to call the base class constructor. This section explains the reasons for this and how to do it.</p><p>A derived class inherits the <code class="literal">create</code> procedure from its base class. However, you must override this procedure in a derived class because the derived class probably requires more storage than the base class, and therefore you will probably need to use a different call to <code class="literal">mem.alloc</code> to allocate storage for a dynamic object. Hence, it is very unusual for a derived class not to override the definition of the <code class="literal">create</code> procedure.</p><p>However, overriding a base class's <code class="literal">create</code> procedure has problems of its own. When you override the base class's <code class="literal">create</code> procedure, you take the full responsibility of initializing the (entire) object, including all the initialization required by the base class. At the very least, this involves putting duplicate code in the overridden procedure to handle the initialization usually done by the base class constructor. In addition to making your program larger (by duplicating code already present in the base class constructor), this also violates information-hiding principles because the derived class must be aware of all the fields in the base class (including those that are logically private to the base class). What we need here is the ability to call a base class's constructor from within the derived class's constructor and let that call do the lower-level initialization of the base class's fields. Fortunately, this is an easy thing to do in HLA.</p><p>Consider the following class declarations (which do things the hard way):</p><a id="I_programlisting12_d1e55004"/><pre class="programlisting">type
     tBase: class
          var
               i:uns32;
               j:int32;

          procedure create(); @returns( "esi" );
     endclass;

     tDerived: class inherits( tBase );
          var
               r: real64;
          override procedure create(); @returns( "esi" );
     endclass;

     procedure tBase.create; @nodisplay;
     begin create;

          if( esi = 0 ) then

               push( eax );
               mov( mem.alloc( @size( tBase )), esi );
               pop( eax );

          endif;
          mov( &amp;tBase._VMT_, this._pVMT_ );
          mov( 0, this.i );
          mov( −1, this.j );

     end create;

     procedure tDerived.create; @nodisplay;
     begin create;

          if( esi = 0 ) then

               push( eax );
               mov( mem.alloc( @size( tDerived )), esi );
               pop( eax );

          endif;

          // Initialize the VMT pointer for this object:

          mov( &amp;tDerived._VMT_, this._pVMT_ );

          // Initialize the "r" field of this particular object:

     fldz();
     fstp( this.r );

     // Duplicate the initialization required by tBase.create:

     mov( 0, this.i );
     mov( −1, this.j );

     end create;</pre><p>Let's take a closer look at the <code class="literal">tDerived.create</code> procedure above. Like a conventional constructor, it begins by checking ESI and allocates storage for a new object if ESI contains NULL. Note that the size of a <code class="literal">tDerived</code> object includes the size required by the inherited fields, so this properly allocates the necessary storage for all fields in a <code class="literal">tDerived</code> object.<a class="indexterm" id="IDX-CHP-12-0090"/></p><p>Next, the <code class="literal">tDerived.create</code> procedure initializes the <code class="literal">VMT</code> pointer field of the object. Remember, each class has its own <code class="literal">virtual method table</code> and, specifically, derived classes do not use the <code class="literal">virtual method table</code> of their base class. Therefore, this constructor must initialize the <code class="literal">_pVMT_</code> field with the address of the <code class="literal">tDerived virtual method table</code>.</p><p>After initializing the <code class="literal">virtual method table</code> pointer, the <code class="literal">tDerived</code> constructor initializes the value of the <code class="literal">r</code> field to 0.0 (remember, <code class="literal">fldz</code> loads 0 onto the FPU stack). This concludes the <code class="literal">tDerived</code>-specific initialization.</p><p>The remaining instructions in <code class="literal">tDerived.create</code> are the problem. These statements duplicate some of the code appearing in the <code class="literal">tBase.create</code> procedure. The problem with code duplication becomes apparent when you decide to modify the initial values of these fields; if you've duplicated the initialization code in derived classes, you will need to change the initialization code in more than one <code class="literal">create</code> procedure. More often than not, however, this results in defects in the derived class <code class="literal">create</code> procedures, especially if those derived classes appear in different source files than the base class.</p><p>Another problem with burying base class initialization in derived class constructors is the violation of the information-hiding principle. Some fields of the base class may be <span class="emphasis"><em>logically private</em></span>. Although HLA does not explicitly support the concept of public and private fields in a class (as, say, C++ does), well-disciplined programmers will still partition the fields as private or public and then use the private fields only in class routines belonging to that class. Initializing these private fields in derived classes is not acceptable to such programmers. Doing so will make it very difficult to change the definition and implementation of some base class at a later date.</p><p>Fortunately, HLA provides an easy mechanism for calling the inherited constructor within a derived class's constructor. All you have to do is call the base constructor using the class name syntax; for example, you could call <code class="literal">tBase.create</code> directly from within <code class="literal">tDerived.create</code>. By calling the base class constructor, your derived class constructors can initialize the base class fields without worrying about the exact implementation (or initial values) of the base class.</p><p>Unfortunately, there are two types of initialization that every (conventional) constructor does that will affect the way you call a base class constructor: All conventional constructors allocate memory for the class if ESI contains 0, and all conventional constructors initialize the <code class="literal">VMT</code> pointer. Fortunately, it is very easy to deal with these two problems.</p><p>The memory required by an object of some base class is usually less than the memory required for an object of a class you derive from that base class (because the derived classes usually add more fields). Therefore, you cannot allow the base class constructor to allocate the storage when you call it from inside the derived class's constructor. You can easily solve this problem by checking ESI within the derived class constructor and allocating any necessary storage for the object <span class="emphasis"><em>before</em></span> calling the base class constructor.</p><p>The second problem is the initialization of the <code class="literal">VMT</code> pointer. When you call the base class's constructor, it will initialize the <code class="literal">VMT</code> pointer with the address of the base class's virtual method table. A derived class object's <code class="literal">_pVMT_</code> field, however, must point at the virtual method table for the derived class. Calling the base class constructor will always initialize the <code class="literal">_pVMT_</code> field with the wrong pointer. To properly initialize the <code class="literal">_pVMT_</code> field with the appropriate value, the derived class constructor must store the address of the derived class's virtual method table into the <code class="literal">_pVMT_</code> field <span class="emphasis"><em>after</em></span> the call to the base class constructor (so that it overwrites the value written by the base class constructor).</p><p>The <code class="literal">tDerived.create</code> constructor, rewritten to call the <code class="literal">tBase.create</code> constructors, follows:</p><a id="I_programlisting12_d1e55130"/><pre class="programlisting">procedure tDerived.create; @nodisplay;
     begin create;

        if( esi = 0 ) then

             push( eax );
             mov( mem.alloc( @size( tDerived )), esi );
             pop( eax );

        endif;

        // Call the base class constructor to do any initialization
        // needed by the base class. Note that this call must follow
        // the object allocation code above (so esi will always contain
        // a pointer to an object at this point and tBase.create will
        // never allocate storage).

        (type tBase [esi]).create();

        // Initialize the VMT pointer for this object. This code
        // must always follow the call to the base class constructor
        // because the base class constructor also initializes this
        // field and we don't want the initial value supplied by
        // tBase.create.

        mov( &amp;tDerived._VMT_, this._pVMT_ );

        // Initialize the "r" field of this particular object:

        fldz();
        fstp( this.r );

     end create;</pre><p>This solution solves all the above concerns with derived class constructors. Note that the call to the base constructor uses the syntax <code class="literal">(type tBase [esi]).create();</code> rather than <code class="literal">tBase.create();</code>. The problem with calling <code class="literal">tBase.create</code> directly is that it will load <code class="literal">NULL</code> into ESI and overwrite the pointer to the storage allocated in <code class="literal">tDerived.create</code>. The scheme above uses the existing value in ESI when calling <code class="literal">tBase.create</code>.<a class="indexterm" id="IDX-CHP-12-0091"/></p></div><div class="sect2" title="12.9.3 Constructor Parameters and Procedure Overloading"><div class="titlepage"><div><div><h2 class="title"><a id="constructor_parameters_and_procedure_ove"/>12.9.3 Constructor Parameters and Procedure Overloading</h2></div></div></div><p>None of the constructor examples to this point have had any parameters. However, there is nothing special about constructors that prevents the use of parameters. Constructors are procedures; therefore, you can specify any number and any type of parameters you choose. You can use these parameter values to initialize certain fields or control how the constructor initializes the fields. Of course, you may use constructor parameters for any purpose you'd use parameters for in any other procedure. In fact, about the only issue you need concern yourself with is the use of parameters whenever you have a derived class. This section deals with those issues.<a class="indexterm" id="IDX-CHP-12-0092"/></p><p>The first, and probably most important, problem with parameters in derived class constructors actually applies to all overridden procedures and methods: The parameter list of an overridden routine must exactly match the parameter list of the corresponding routine in the base class. In fact, HLA doesn't even give you the chance to violate this rule because <code class="literal">override</code> routine prototypes don't allow parameter list declarations: They automatically inherit the parameter list of the base routine. Therefore, you cannot use a special parameter list in the constructor prototype for one class and a different parameter list for the constructors appearing in base or derived classes. Sometimes it would be nice if this weren't the case, but there are some sound and logical reasons why HLA does not support this.<sup>[<a class="footnote" href="#ftn.CHP-12-FN-8" id="CHP-12-FN-8">139</a>]</sup></p><p>HLA supports a special <code class="literal">overloads</code> declaration that lets you call one of several different procedures, methods, or iterators using a single identifier (with the number of types of parameters specifying which function to call). This would allow you, for example, to create multiple constructors for a given class (or derived class) and invoke the desired constructor using a matching parameter list for that constructor. Interested readers should consult the chapter on procedures in the HLA documentation for more details concerning the <code class="literal">overloads</code> declaration.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-7" id="ftn.CHP-12-FN-7">138</a>] </sup>You generally do not declare objects in <code class="literal">readonly</code> sections because you cannot initialize them.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-8" id="ftn.CHP-12-FN-8">139</a>] </sup>Calling virtual methods and iterators would be a real problem because you don't really know which routine a pointer references. Therefore, you couldn't know the proper parameter list. While the problems with procedures aren't quite as drastic, there are some subtle problems that could creep into your code if base or derived classes allowed overridden procedures with different parameter lists.</p></div></div></div>
<div class="sect1" title="12.10 Destructors"><div class="titlepage"><div><div><h1 class="title"><a id="destructors"/>12.10 Destructors</h1></div></div></div><p>A <span class="emphasis"><em>destructor</em></span> is a class routine that cleans up an object once a program finishes using that object. As for constructors, HLA does not provide a special syntax for creating destructors, nor does HLA automatically call a destructor. Unlike constructors, a destructor is usually a method rather than a procedure (because virtual destructors make a lot of sense, whereas virtual constructors do not).<a class="indexterm" id="IDX-CHP-12-0093"/></p><p>A typical destructor might close any files opened by the object, free the memory allocated during the use of the object, and, finally, free the object itself if it was created dynamically. The destructor also handles any other cleanup chores the object may require before it ceases to exist.</p><p>By convention, most HLA programmers name their destructors <code class="literal">destroy</code>. About the only code that most destructors have in common is the code to free the storage associated with the object. The following destructor demonstrates how to do this:</p><a id="I_programlisting12_d1e55202"/><pre class="programlisting">procedure tBase.destroy; @nodisplay;
begin destroy;

     push( eax );   // isInHeap uses this.

     // Place any other cleanup code here.
     // The code to free dynamic objects should always appear last
     // in the destructor.

          /*************/

     // The following code assumes that esi still contains the address
     // of the object.

     if( mem.isInHeap( esi )) then

          free( esi);

     endif;
     pop( eax );

end destroy;</pre><p>The HLA Standard Library routine <code class="literal">mem.isInHeap</code> returns true if its parameter is an address that <code class="literal">mem.alloc</code> returned. Therefore, this code automatically frees the storage associated with the object if the program originally allocated storage for the object by calling <code class="literal">mem.alloc</code>. Obviously, on return from this method call, ESI will no longer point at a legal object in memory if you allocated it dynamically. Note that this code will not affect the value in ESI nor will it modify the object if the object wasn't one you've previously allocated via a call to <code class="literal">mem.alloc</code>.<a class="indexterm" id="IDX-CHP-12-0094"/><a class="indexterm" id="IDX-CHP-12-0095"/></p></div>
<div class="sect1" title="12.11 HLA's _initialize_ and _finalize_ Strings"><div class="titlepage"><div><div><h1 class="title"><a id="hla_apostrophy_s_underscore_initialize_u"/>12.11 HLA's _initialize_ and _finalize_ Strings</h1></div></div></div><p>Although HLA does not automatically call constructors and destructors associated with your classes, HLA does provide a mechanism whereby you can force HLA to automatically emit these calls: by using the <code class="literal">_initialize_</code> and <code class="literal">_finalize_</code> compile-time string variables (i.e., <code class="literal">val</code> constants) that HLA automatically declares in every procedure.<a class="indexterm" id="IDX-CHP-12-0096"/><a class="indexterm" id="IDX-CHP-12-0097"/></p><p>Whenever you write a procedure, iterator, or method, HLA automatically declares several local symbols in that routine. Two such symbols are <code class="literal">_initialize_</code> and <code class="literal">_finalize_</code>. HLA declares these symbols as follows:</p><a id="I_programlisting12_d1e55256"/><pre class="programlisting">val
     _initialize_: string := "";
     _finalize_: string := "";</pre><p>HLA emits the <code class="literal">_initialize_</code> string as text at the very beginning of the routine's body, that is, immediately after the routine's <code class="literal">begin</code> clause.<sup>[<a class="footnote" href="#ftn.CHP-12-FN-9" id="CHP-12-FN-9">140</a>]</sup> Similarly, HLA emits the <code class="literal">_finalize_</code> string at the very end of the routine's body, just before the <code class="literal">end</code> clause. This is comparable to the following:</p><a id="I_programlisting12_d1e55279"/><pre class="programlisting">procedure <em class="replaceable"><code>SomeProc</code></em>;
     &lt;&lt; declarations &gt;&gt;
begin <em class="replaceable"><code>SomeProc</code></em>;

     @text( _initialize_ );

          &lt;&lt; Procedure body &gt;&gt;

     @text( _finalize_ );

end <em class="replaceable"><code>SomeProc</code></em>;</pre><p>Because <code class="literal">_initialize_</code> and <code class="literal">_finalize_</code> initially contain the empty string, these expansions have no effect on the code that HLA generates unless you explicitly modify the value of <code class="literal">_initialize_</code> prior to the <code class="literal">begin</code> clause or you modify <code class="literal">_finalize_</code> prior to the <code class="literal">end</code> clause of the procedure. So if you modify either of these string objects to contain a machine instruction, HLA will compile that instruction at the beginning or end of the procedure. The following example demonstrates how to use this technique:</p><a id="I_programlisting12_d1e55311"/><pre class="programlisting">procedure <em class="replaceable"><code>SomeProc</code></em>;
     ?_initialize_ := "mov( 0, eax );";
     ?_finalize_ := "stdout.put( eax );";
begin <em class="replaceable"><code>SomeProc</code></em>;

     // HLA emits "mov( 0, eax );" here in response to the _initialize_
     // string constant.

     add( 5, eax );

     // HLA emits "stdout.put( eax );" here.

end <em class="replaceable"><code>SomeProc</code></em>;</pre><p>Of course, these examples don't save you much. It would be easier to type the actual statements at the beginning and end of the procedure than to assign a string containing these statements to the <code class="literal">_initialize_</code> and <code class="literal">_finalize_</code> compile-time variables. However, if we could automate the assignment of some string to these variables, so that we don't have to explicitly assign them in each procedure, then this feature might be useful. In a moment, you'll see how we can automate the assignment of values to the <code class="literal">_initialize_</code> and <code class="literal">_finalize_</code> strings. For the time being, consider the case where we load the name of a constructor into the <code class="literal">_initialize_</code> string and we load the name of a destructor in to the <code class="literal">_finalize_</code> string. By doing this, the routine will "automatically" call the constructor and destructor for that particular object.</p><p>The previous example has a minor problem. If we can automate the assignment of some value to <code class="literal">_initialize_</code> or <code class="literal">_finalize_</code>, what happens if these variables already contain some value? For example, suppose we have two objects we use in a routine, and the first one loads the name of its constructor into the <code class="literal">_initialize_</code> string; what happens when the second object attempts to do the same thing? The solution is simple: Don't directly assign any string to the <code class="literal">_initialize_</code> or <code class="literal">_finalize_</code> compile-time variables; instead, always concatenate your strings to the end of the existing string in these variables. The following is a modification to the above example that demonstrates how to do this:</p><a id="I_programlisting12_d1e55360"/><pre class="programlisting">procedure <em class="replaceable"><code>SomeProc</code></em>;
     ?_initialize_ := _initialize_  + "mov( 0, eax );";
     ?_finalize_ := _finalize_ + "stdout.put( eax );";
begin <em class="replaceable"><code>SomeProc</code></em>;

     // HLA emits "mov( 0, eax );" here in response to the _initialize_
     // string constant.

     add( 5, eax );

     // HLA emits "stdout.put( eax );" here.

end <em class="replaceable"><code>SomeProc</code></em>;</pre><p>When you assign values to the <code class="literal">_initialize_</code> and <code class="literal">_finalize_</code> strings, HLA guarantees that the <code class="literal">_initialize_</code> sequence will execute upon entry into the routine. Sadly, the same is not true for the <code class="literal">_finalize_</code> string upon exit. HLA simply emits the code for the <code class="literal">_finalize_</code> string at the end of the routine, immediately before the code that cleans up the activation record and returns. Unfortunately, "falling off the end of the routine" is not the only way that you could return from that routine. You could explicitly return from somewhere in the middle of the code by executing a <code class="literal">ret</code> instruction. Because HLA emits the <code class="literal">_finalize_</code> string only at the very end of the routine, returning from that routine in this manner bypasses the <code class="literal">_finalize_</code> code. Unfortunately, other than manually emitting the <code class="literal">_finalize_</code> code, there is nothing you can do about this.<sup>[<a class="footnote" href="#ftn.CHP-12-FN-10" id="CHP-12-FN-10">141</a>]</sup> Fortunately, this mechanism for exiting a routine is completely under your control. If you never exit a routine except by "falling off the end," then you won't have to worry about this problem (note that you can use the <code class="literal">exit</code> control structure to transfer control to the end of a routine if you really want to return from that routine from somewhere in the middle of the code).</p><p>Another way to prematurely exit a routine, over which, unfortunately, you don't have any control, is by raising an exception. Your routine could call some other routine (e.g., a Standard Library routine) that raises an exception and then transfers control immediately to whomever called your routine. Fortunately, you can easily trap and handle exceptions by putting a <code class="literal">try..endtry</code> block in your procedure. Here is an example that demonstrates this:</p><a id="I_programlisting12_d1e55420"/><pre class="programlisting">procedure <em class="replaceable"><code>SomeProc</code></em>;
     &lt;&lt; Declarations that modify _initialize_ and _finalize_ &gt;&gt;
begin <em class="replaceable"><code>SomeProc</code></em>;

     &lt;&lt; HLA emits the code for the _initialize_ string here. &gt;&gt;

     try   // Catch any exceptions that occur:

          &lt;&lt; Procedure body goes here. &gt;&gt;

     anyexception

          push( eax );             // Save the exception #.
          @text( _finalize_ );     // Execute the _finalize_ code here.
          pop( eax );              // Restore the exception #.
          raise( eax );            // Reraise the exception.

     endtry;

     &lt;&lt; HLA automatically emits the _finalize_ code here. &gt;&gt;

end <em class="replaceable"><code>SomeProc</code></em>;</pre><p>Although the previous code handles some problems that exist with <code class="literal">_finalize_</code>, by no means does it handle every possible case. Always be on the lookout for ways your program could inadvertently exit a routine without executing the code found in the <code class="literal">_finalize_</code> string. You should explicitly expand <code class="literal">_finalize_</code> if you encounter such a situation.</p><p>There is one important place you can get into trouble with respect to exceptions: within the code the routine emits for the <code class="literal">_initialize_</code> string. If you modify the <code class="literal">_initialize_</code> string so that it contains a constructor call and the execution of that constructor raises an exception, this will probably force an exit from that routine without executing the corresponding <code class="literal">_finalize_</code> code. You could bury the <code class="literal">try..endtry</code> statement directly into the <code class="literal">_initialize_</code> and <code class="literal">_finalize_</code> strings, but this approach has several problems, not the least of which is the fact that one of the first constructors you call might raise an exception that transfers control to the exception handler that calls the destructors for all objects in that routine (including those objects whose constructors you have yet to call). Although no single solution that handles all problems exists, probably the best approach is to put a <code class="literal">try..endtry</code> block within each constructor call if it is possible for that constructor to raise some exception that is possible to handle (that is, doesn't require the immediate termination of the program).</p><p>Thus far this discussion of <code class="literal">_initialize_</code> and <code class="literal">_finalize_</code> has failed to address one important point: Why use this feature to implement the "automatic" calling of constructors and destructors, because it apparently involves more work than simply calling the constructors and destructors directly? Clearly there must be a way to automate the assignment of the <code class="literal">_initialize_</code> and <code class="literal">_finalize_</code> strings or this section wouldn't exist. The way to accomplish this is by using a macro to define the class type. So now it's time to take a look at another HLA feature that makes it possible to automate this activity: the <code class="literal">forward</code> keyword.</p><p>You've seen how to use the <code class="literal">forward</code> reserved word to create procedure prototypes (see the discussion in <a class="xref" href="ch05s09.html" title="5.9 Forward Procedures">5.9 Forward Procedures</a>); it turns out that you can declare forward <code class="literal">const</code>, <code class="literal">val</code>, <code class="literal">type</code>, and variable declarations as well. The syntax for such declarations takes the following form:</p><a id="I_programlisting12_d1e55499"/><pre class="programlisting"><em class="replaceable"><code>ForwardSymbolName</code></em>: forward( <em class="replaceable"><code>undefinedID</code></em> );</pre><p>This declaration is completely equivalent to the following:</p><a id="I_programlisting12_d1e55508"/><pre class="programlisting">?<em class="replaceable"><code>undefinedID</code></em>: text := "<em class="replaceable"><code>ForwardSymbolName</code></em>";</pre><p>Especially note that this expansion does not actually define the symbol <em class="replaceable"><code>ForwardSymbolName</code></em>. It just converts this symbol to a string and assigns this string to the specified <code class="literal">text</code> object <em class="replaceable"><code>undefinedID</code></em>.</p><p>Now you're probably wondering how something like the above is equivalent to a forward declaration. The truth is, it isn't. However, forward declarations let you create macros that simulate type names by allowing you to defer the actual declaration of an object's type until some later point in the code. Consider the following example:</p><a id="I_programlisting12_d1e55530"/><pre class="programlisting">type
     myClass: class
          var
               i:int32;

          procedure create; @returns( "esi" );
               procedure destroy;
          endclass;

#macro _myClass: varID;
     forward( varID );
     ?_initialize_ := _initialize_ + @string:varID + ".create(); ";
     ?_finalize_ := _finalize_ + @string:varID + ".destroy(); ";
     varID: myClass
#endmacro;</pre><p>Note, and this is very important, that a semicolon does not follow the <code class="literal">varID: myClass</code> declaration at the end of this macro. You'll find out why this semicolon is missing in a little while.</p><p>If you have the above class and macro declarations in your program, you can now declare variables of type <code class="literal">_myClass</code> that automatically invoke the constructor and destructor upon entry and exit of the routine containing the variable declarations. To see how, take a look at the following procedure shell:</p><a id="I_programlisting12_d1e55542"/><pre class="programlisting">procedure HasmyClassObject;
var
     mco: _myClass;
begin HasmyClassObject;

     &lt;&lt; Do stuff with mco here. &gt;&gt;

end HasmyClassObject;</pre><p>Because <code class="literal">_myClass</code> is a macro, the procedure above expands to the following text during compilation:</p><a id="I_programlisting12_d1e55549"/><pre class="programlisting">procedure HasmyClassObject;
var
     mco:                 // Expansion of the _myClass macro:
       forward( _0103_ ); // _0103_ symbol is an HLA-supplied text
                          // symbol that expands to "mco".

     ?_initialize_ := _initialize_ + "mco" + ".create(); ";
     ?_finalize_ := _finalize_ + "mco" + ".destroy(); ";
     mco: myClass;

begin HasmyClassObject;

     mco.create();  // Expansion of the _initialize_ string.

     &lt;&lt; Do stuff with mco here. &gt;&gt;

     mco.destroy(); // Expansion of the _finalize_ string.

end HasmyClassObject;</pre><p>You might notice that a semicolon appears after the <code class="literal">mco: myClass</code> declaration in the example above. This semicolon is not actually a part of the macro; instead it is the semicolon that follows the <code class="literal">mco: _myClass;</code> declaration in the original code.<a class="indexterm" id="IDX-CHP-12-0098"/></p><p>If you want to create an array of objects, you could legally declare that array as follows:</p><a id="I_programlisting12_d1e55564"/><pre class="programlisting">var
     mcoArray: _myClass[10];</pre><p>Because the last statement in the <code class="literal">_myClass</code> macro doesn't end with a semicolon, the declaration above will expand to something like the following (almost correct) code:</p><a id="I_programlisting12_d1e55572"/><pre class="programlisting">mcoArray:              // Expansion of the _myClass macro:
         forward( _0103_ ); // _0103_ symbol is an HLA-supplied text
                            // symbol that expands to "mcoArray".

     ?_initialize_ := _initialize_ + "mcoArray" + ".create(); ";
     ?_finalize_ := _finalize_ + "mcoArray" + ".Destroy(); ";
     mcoArray: myClass[10];</pre><p>The only problem with this expansion is that it calls the constructor only for the first object of the array. There are several ways to solve this problem; one is to append a macro name to the end of <code class="literal">_initialize_</code> and <code class="literal">_finalize_</code> rather than the constructor name. That macro would check the object's name (<code class="literal">mcoArray</code> in this example) to determine if it is an array. If so, that macro could expand to a loop that calls the constructor for each element of the array.</p><p>Another solution to this problem is to use a macro parameter to specify the dimensions for arrays of <code class="literal">myClass</code>. This scheme is easier to implement than the one above, but it does have the drawback of requiring a different syntax for declaring object arrays (you have to use parentheses rather than square brackets around the array dimension).</p><p>The <code class="literal">forward</code> directive is quite powerful and lets you achieve all kinds of tricks. However, there are a few problems of which you should be aware. First, because HLA emits the <code class="literal">_initialize_</code> and <code class="literal">_finalize_</code> code transparently, you can be easily confused if there are any errors in the code appearing within these strings. If you start getting error messages associated with the <code class="literal">begin</code> or <code class="literal">end</code> statements in a routine, you might want to take a look at the <code class="literal">_initialize_</code> and <code class="literal">_finalize_</code> strings within that routine. The best defense here is to always append very simple statements to these strings so that you reduce the likelihood of an error.<a class="indexterm" id="IDX-CHP-12-0099"/></p><p>Fundamentally, HLA doesn't support automatic constructor and destructor calls. This section has presented several tricks to attempt to automate the calls to these routines. However, the automation isn't perfect and, indeed, the aforementioned problems with the <code class="literal">_finalize_</code> strings limit the applicability of this approach. The mechanism this section presents is probably fine for simple classes and simple programs. One piece of advice is probably worth following: If your code is complex or correctness is critical, it's probably a good idea to explicitly call the constructors and destructors manually.<a class="indexterm" id="IDX-CHP-12-0100"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-9" id="ftn.CHP-12-FN-9">140</a>] </sup>If the routine automatically emits code to construct the activation record, HLA emits <code class="literal">_initialize_</code>'s text after the code that builds the activation record.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-10" id="ftn.CHP-12-FN-10">141</a>] </sup>Note that you can manually emit the <code class="literal">_finalize_</code> code using the statement <code class="literal">@text( _finalize_ );</code>.</p></div></div></div>
<div class="sect1" title="12.12 Abstract Methods"><div class="titlepage"><div><div><h1 class="title"><a id="abstract_methods"/>12.12 Abstract Methods</h1></div></div></div><p>An <span class="emphasis"><em>abstract base class</em></span> is one that exists solely to supply a set of common fields to its derived classes. You never declare variables whose type is an abstract base class; you always use one of the derived classes. The purpose of an abstract base class is to provide a template for creating other classes, nothing more. As it turns out, the only difference in syntax between a standard base class and an abstract base class is the presence of at least one <span class="emphasis"><em>abstract method</em></span> declaration. An abstract method is a special method that does not have an actual implementation in the abstract base class. Any attempt to call that method will raise an exception. If you're wondering what possible good an abstract method could be, keep on reading.<a class="indexterm" id="IDX-CHP-12-0101"/><a class="indexterm" id="IDX-CHP-12-0102"/></p><p>Suppose you want to create a set of classes to hold numeric values. One class could represent unsigned integers, another class could represent signed integers, a third could implement BCD values, and a fourth could support <code class="literal">real64</code> values. While you could create four separate classes that function independently of one another, doing so passes up an opportunity to make this set of classes more convenient to use. To understand why, consider the following possible class declarations:</p><a id="I_programlisting12_d1e55653"/><pre class="programlisting">type
     uint: class
          var
               TheValue: dword;

          method put;
          &lt;&lt; Other methods for this class &gt;&gt;
     endclass;

     sint: class
          var
               TheValue: dword;

          method put;
          &lt;&lt; Other methods for this class &gt;&gt;
     endclass;

     r64: class
          var
               TheValue: real64;

          method put;
          &lt;&lt; Other methods for this class &gt;&gt;
     endclass;</pre><p>The implementation of these classes is not unreasonable. They have fields for the data and they have a <code class="literal">put</code> method (which, presumably, writes the data to the standard output device). They probably have other methods and procedures to implement various operations on the data. There are, however, two problems with these classes, one minor and one major, both occurring because these classes do not inherit any fields from a common base class.</p><p>The first problem, which is relatively minor, is that you have to repeat the declaration of several common fields in these classes. For example, the <code class="literal">put</code> method declaration appears in each of these classes.<sup>[<a class="footnote" href="#ftn.CHP-12-FN-11" id="CHP-12-FN-11">142</a>]</sup> This duplication of effort results in a harder-to-maintain program because it doesn't encourage you to use a common name for a common function since it's easy to use a different name in each of the classes.</p><p>A bigger problem with this approach is that it is not generic. That is, you can't create a generic pointer to a "numeric" object and perform operations like addition, subtraction, and output on that value (regardless of the underlying numeric representation).</p><p>We can easily solve these two problems by turning the previous class declarations into a set of derived classes. The following code demonstrates an easy way to do this:</p><a id="I_programlisting12_d1e55679"/><pre class="programlisting">type
     numeric: class
          method put;
          &lt;&lt; Other common methods shared by all the classes &gt;&gt;
     endclass;

     uint: class inherits( numeric )
          var
               TheValue: dword;

          override method put;
          &lt;&lt; Other methods for this class &gt;&gt;
     endclass;

     sint: class inherits( numeric )
          var
               TheValue: dword;

          override method put;
          &lt;&lt; Other methods for this class &gt;&gt;
     endclass;

     r64: class inherits( numeric )
          var
               TheValue: real64;

          override method put;
          &lt;&lt; Other methods for this class &gt;&gt;
endclass;</pre><p>This scheme solves both the problems. First, by inheriting the <code class="literal">put</code> method from numeric, this code encourages the derived classes to always use the name <em class="replaceable"><code>put</code></em>, thereby making the program easier to maintain. Second, because this example uses derived classes, it's possible to create a pointer to the <code class="literal">numeric</code> type and load this pointer with the address of a <code class="literal">uint</code>, <code class="literal">sint</code>, or <code class="literal">r64</code> object. That pointer can invoke the methods found in the <code class="literal">numeric</code> class to do functions like addition, subtraction, or numeric output. Therefore, the application that uses this pointer doesn't need to know the exact data type; it deals with numeric values only in a generic fashion.</p><p>One problem with this scheme is that it's possible to declare and use variables of type <code class="literal">numeric</code>. Unfortunately, such numeric variables don't have the ability to represent any type of number (notice that the data storage for the numeric fields actually appears in the derived classes). Worse, because you've declared the <code class="literal">put</code> method in the <code class="literal">numeric</code> class, you actually have to write some code to implement that method even though you should never really call it; the actual implementation should occur only in the derived classes. While you could write a dummy method that prints an error message (or, better yet, raises an exception), there shouldn't be any need to write "dummy" procedures like this. Fortunately, there is no reason to do so—if you use <span class="emphasis"><em>abstract</em></span> methods.</p><p>The <code class="literal">abstract</code> keyword, when it follows a method declaration, tells HLA that you are not going to provide an implementation of the method for this class. Instead, it is the responsibility of all derived classes to provide a concrete implementation for the abstract method. HLA will raise an exception if you attempt to call an abstract method directly. The following is the modification to the <code class="literal">numeric</code> class to convert <code class="literal">put</code> to an abstract method:<a class="indexterm" id="IDX-CHP-12-0103"/></p><a id="I_programlisting12_d1e55736"/><pre class="programlisting">type
     numeric: class
          method put; abstract;
          &lt;&lt; Other common methods shared by all the classes &gt;&gt;
     endclass;</pre><p>An abstract base class is a class that has at least one abstract method. Note that you don't have to make all methods abstract in an abstract base class; it is perfectly legal to declare some standard methods (and, of course, provide their implementation) within the abstract base class.</p><p>Abstract method declarations provide a mechanism by which a base class can specify some generic methods that the derived classes must implement. In theory, all derived classes must provide concrete implementations of all abstract methods, or those derived classes are themselves abstract base classes. In practice, it's possible to bend the rules a little and use abstract methods for a slightly different purpose.</p><p>A little earlier, you read that you should never create variables whose type is an abstract base class. If you attempt to execute an abstract method, the program would immediately raise an exception to complain about this illegal method call. In practice, you actually can declare variables of an abstract base type and get away with this as long as you don't call any abstract methods in that class.<a class="indexterm" id="IDX-CHP-12-0104"/><a class="indexterm" id="IDX-CHP-12-0105"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-12-FN-11" id="ftn.CHP-12-FN-11">142</a>] </sup>Note, by the way, that <code class="literal">TheValue</code> is not a common field because this field has a different type in the <code class="literal">r64</code> class.</p></div></div></div>
<div class="sect1" title="12.13 Runtime Type Information"><div class="titlepage"><div><div><h1 class="title"><a id="runtime_type_information"/>12.13 Runtime Type Information</h1></div></div></div><p>When working with an object variable (as opposed to a pointer to an object), the type of that object is obvious: It's the variable's declared type. Therefore, at both compile time and runtime the program knows the type of the object. When working with pointers to objects you cannot, in the general case, determine the type of an object a pointer references. However, at runtime it is possible to determine the object's actual type. This section discusses how to detect the underlying object's type and how to use this information.</p><p>If you have a pointer to an object and that pointer's type is some base class, at runtime the pointer could point at an object of the base class or any derived type. At compile time it is not possible to determine the exact type of an object at any instant. To see why, consider the following short example:</p><a id="I_programlisting12_d1e55759"/><pre class="programlisting"><em class="replaceable"><code>ReturnSomeObject</code></em>(); // Returns a pointer to some class in esi.
     mov( esi, <em class="replaceable"><code>ptrToObject</code></em> );</pre><p>The routine <em class="replaceable"><code>ReturnSomeObject</code></em> returns a pointer to an object in ESI. This could be the address of some base class object or a derived class object. At compile time there is no way for the program to know what type of object this function returns. For example, <em class="replaceable"><code>ReturnSomeObject</code></em> could ask the user what value to return so the exact type could not be determined until the program actually runs and the user makes a selection.</p><p>In a perfectly designed program, there probably is no need to know a generic object's actual type. After all, the whole purpose of object-oriented programming and inheritance is to produce general programs that work with lots of different objects without having to make substantial changes to the program. In the real world, however, programs may not have a perfect design, and sometimes it's nice to know the exact object type a pointer references. Runtime type information, or RTTI, gives you the capability of determining an object's type at runtime, even if you are referencing that object using a pointer to some base class of that object.</p><p>Perhaps the most fundamental RTTI operation you need is the ability to ask if a pointer contains the address of some specific object type. Many object-oriented languages (e.g., Delphi) provide an <code class="literal">is</code> operator that provides this functionality. <code class="literal">is</code> is a boolean operator that returns true if its left operand (a pointer) points at an object whose type matches the right operand (which must be a type identifier). The typical syntax is generally the following:</p><a id="I_programlisting12_d1e55784"/><pre class="programlisting"><em class="replaceable"><code>ObjectPointerOrVar</code></em> is <em class="replaceable"><code>ClassType</code></em></pre><p>This operator returns true if the variable is of the specified class; it returns false otherwise. Here is a typical use of this operator (in the Delphi language):</p><a id="I_programlisting12_d1e55792"/><pre class="programlisting">if( <em class="replaceable"><code>ptrToNumeric</code></em> is uint ) then begin
     .
     .
     .
     end;</pre><p>It's actually quite simple to implement this functionality in HLA. As you may recall, each class is given its own virtual method table. Whenever you create an object, you must initialize the pointer to the virtual method table with the address of that class's virtual method table. Therefore, the <code class="literal">VMT</code> pointer field of all objects of a given class type contains the same pointer value, and this pointer value is different from the <code class="literal">VMT</code> pointer field of all other classes. We can use this fact to see if an object is some specific type. The following code demonstrates how to implement the Delphi statement above in HLA:</p><a id="I_programlisting12_d1e55806"/><pre class="programlisting">mov( <em class="replaceable"><code>ptrToNumeric</code></em>, esi );
     if( (type uint [esi])._pVMT_ = &amp;uint._VMT_  ) then
          .
          .
          .
     endif;</pre><p>This <code class="literal">if</code> statement simply compares the object's <code class="literal">_pVMT_</code> field (the pointer to the virtual method table) against the address of the desired classes' virtual method table. If they are equal, then the <em class="replaceable"><code>ptrToNumeric</code></em> variable points at an object of type <code class="literal">uint</code>.</p><p>Within the body of a class method or iterator, there is a slightly easier way to see if the object is a certain class. Remember, upon entry into a method or an iterator, the EDI register contains the address of the virtual method table. Therefore, assuming you haven't modified EDI's value, you can easily test to see if the method or iterator is a specific class type using an <code class="literal">if</code> statement like the following:</p><a id="I_programlisting12_d1e55830"/><pre class="programlisting">if( edi = &amp;uint._VMT_  ) then
          .
          .
          .
     endif;</pre><p>Remember, however, that EDI will contain a pointer to the virtual method table only when you call a class method. This is not the case when calling a class procedure.</p></div>
<div class="sect1" title="12.14 Calling Base Class Methods"><div class="titlepage"><div><div><h1 class="title"><a id="calling_base_class_methods"/>12.14 Calling Base Class Methods</h1></div></div></div><p>In the section on constructors you saw that it is possible to call an ancestor class's procedure within the derived class's overridden procedure. To do this, all you need to do is to invoke the procedure using the call <code class="literal">(type</code> <em class="replaceable"><code>classname</code></em> <code class="literal">[esi]).</code><em class="replaceable"><code>procedureName</code></em><code class="literal">(</code> <em class="replaceable"><code>parameters</code></em> <code class="literal">);</code>. On occasion you may want to do this same operation with a class's methods as well as its procedures (that is, have an overridden method call the corresponding base class method in order to do some computation you'd rather not repeat in the derived class's method). Unfortunately, HLA does not let you directly call methods as it does procedures. You will need to use an indirect mechanism to achieve this; specifically, you will have to call the method using the address in the base class's virtual method table. This section describes how to do this.<a class="indexterm" id="IDX-CHP-12-0106"/><a class="indexterm" id="IDX-CHP-12-0107"/></p><p>Whenever your program calls a method it does so indirectly, using the address found in the virtual method table for the method's class. The virtual method table is nothing more than an array of 32-bit pointers, with each entry containing the address of one of that class's methods. So to call a method, all you need is the index into this array (or, more properly, the offset into the array) of the address of the method you wish to call. The HLA compile-time function <code class="literal">@offset</code> comes to the rescue: It will return the offset into the virtual method table of the method whose name you supply as a parameter. Combined with the <code class="literal">call</code> instruction, you can easily call any method associated with a class. Here's an example of how you would do this:</p><a id="I_programlisting12_d1e55873"/><pre class="programlisting">type
     <em class="replaceable"><code>myCls</code></em>: class
          .
          .
          .
          method m;
          .
          .
          .
     endclass;
          .
          .
          .
     call( <em class="replaceable"><code>myCls</code></em>._VMT_[ @offset( <em class="replaceable"><code>myCls</code></em>.m )]);</pre><p>The <code class="literal">call</code> instruction above calls the method whose address appears at the specified entry in the virtual method table for <em class="replaceable"><code>myCls</code></em>. The <code class="literal">@offset</code> function call returns the offset (i.e., index times 4) of the address of <code class="literal">myCls.m</code> within the virtual method table. Hence, this code indirectly calls the <code class="literal">m</code> method by using the virtual method table entry for <code class="literal">m</code>.</p><p>There is one major drawback to calling methods using this scheme: You don't get to use the high-level syntax for procedure/method calls. Instead, you must use the low-level <code class="literal">call</code> instruction. In the example above, this isn't much of an issue because the <code class="literal">m</code> procedure doesn't have any parameters. If it did have parameters, you would have to manually push those parameters onto the stack yourself. Fortunately, you'll rarely need to call ancestor class methods from a derived class, so this won't be much of an issue in real-world programs.</p></div>
<div class="sect1" title="12.15 For More Information"><div class="titlepage"><div><div><h1 class="title"><a id="for_more_information-id11"/>12.15 For More Information</h1></div></div></div><p>The HLA reference manual at <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a> or <a class="ulink" href="http://www.artofasm.com/">http://www.artofasm.com/</a> contains additional information about HLA's class implementation. Check out this document for additional low-level implementation features. This chapter hasn't really attempted to teach the object-oriented programming paradigm. See a generic text on object-oriented design for more details about this subject.</p></div></body></html>