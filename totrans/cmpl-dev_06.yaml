- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NEXT.JS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NEXT.JS</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/Drop-image.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Drop-image.jpg)'
- en: In [Chapter 4](chapter4.xhtml), you used React to create responsive user interface
    components. But because React is just a library, building a full-stack application
    requires additional tools. In this chapter, we use Next.js, the leading web application
    framework built on top of React. To create an app with Next.js, you need to know
    only a few essential concepts. This chapter covers them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](chapter4.xhtml)中，你使用了 React 来创建响应式用户界面组件。但是，由于 React 只是一个库，构建全栈应用程序需要额外的工具。在本章中，我们将使用
    Next.js，这是一个构建在 React 之上的领先 Web 应用程序框架。要使用 Next.js 创建应用程序，你只需要了解几个基本概念。本章将介绍这些概念。
- en: Next.js streamlines the creation of an application’s frontend, middleware, and
    backend. On the frontend, it uses React. It also adds native CSS modules to define
    styles, and custom Next.js modules to perform routing, image handling, and additional
    frontend tasks. When it comes to the middleware and the backend, Next.js uses
    a built-in server to provide the entry points for HTTP requests and a clean API
    in which to work with request and response objects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 简化了应用程序前端、中间件和后端的创建。在前端，它使用 React。它还添加了本地的 CSS 模块来定义样式，并使用自定义的 Next.js
    模块来执行路由、图像处理和其他前端任务。至于中间件和后端，Next.js 使用内置服务器来提供 HTTP 请求的入口点，并提供一个干净的 API 以便处理请求和响应对象。
- en: We’ll cover its filesystem-based approach to routing, discuss ways to build
    and render the web pages we deliver to clients, explore adding CSS files to style
    pages, and refactor our Express.js server to work with Next.js. This chapter uses
    the traditional *pages* directory to teach you these basic concepts. To learn
    about Next.js’s alternative *app* directory, see [Appendix B](appendix-B.xhtml).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论其基于文件系统的路由方法，讨论构建和渲染交付给客户端的网页的方式，探索如何添加 CSS 文件来为页面添加样式，并重构我们的 Express.js
    服务器以与 Next.js 一起使用。本章使用传统的*pages*目录来教授这些基本概念。要了解 Next.js 的替代*app*目录，请参见[附录 B](appendix-B.xhtml)。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setting Up Next.js</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">设置 Next.js</samp>
- en: 'Next.js is part of the npm ecosystem. While you could manually install all
    of its required modules by running <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    install next react react-dom</samp> and subsequently create all of your project’s
    files and folders by yourself, there is a much simpler way to set things up: running
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">create-next-app</samp> command.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 是 npm 生态系统的一部分。虽然你可以通过运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    install next react react-dom</samp> 手动安装所有必需的模块，并随后自己创建项目的所有文件和文件夹，但有一个更简单的方式来设置：运行
    <samp class="SANS_TheSansMonoCd_W5Regular_11">create-next-app</samp> 命令。
- en: 'Let’s create a sample application to use throughout this chapter. Follow these
    steps to set up a new empty folder called *sample-next* and build your first Next.js
    application inside it. Keep the default answers from the setup wizard, and choose
    to use the traditional *pages* directory instead of the *app* directory:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个示例应用程序，以便在本章中使用。按照以下步骤设置一个名为*sample-next*的新空文件夹，并在其中构建你的第一个 Next.js 应用程序。保持设置向导中的默认答案，并选择使用传统的*pages*目录，而不是*app*目录：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We create a new folder, switch to it, and then initialize a new Next.js project.
    We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">npx</samp> command instead
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">npm</samp> because, as you learned
    in [Chapter 1](chapter1.xhtml), npx doesn’t require us to install anything as
    a dependency or development dependency. We mentioned that a typical use case for
    it is scaffolding, which is precisely what we’re doing here.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新文件夹，切换到该文件夹，然后初始化一个新的 Next.js 项目。我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">npx</samp>
    命令，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">npm</samp>，因为正如你在[第1章](chapter1.xhtml)中学到的，npx
    不需要我们安装任何东西作为依赖项或开发依赖项。我们提到过它的典型用途是脚手架工具，这正是我们在这里所做的。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp> command
    has a few options, of which only two are relevant to us: the <samp class="SANS_TheSansMonoCd_W5Regular_11">--typescript</samp>
    option creates a Next.js project that supports TypeScript, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">--use-npm</samp>
    flag selects npm as a package manager.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp> 命令有几个选项，其中只有两个与我们相关：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">--typescript</samp> 选项创建一个支持 TypeScript
    的 Next.js 项目，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">--use-npm</samp>
    标志选择 npm 作为包管理器。
- en: We accept the default project name, <samp class="SANS_TheSansMonoCd_W5Regular_11">my-app</samp>,
    and all the other default settings. The script creates a folder based on the project
    name containing the *package.json* file and a complete sample project with all
    necessary files and folders. Finally, it installs the dependencies and development
    dependencies through npm.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接受默认的项目名称 <samp class="SANS_TheSansMonoCd_W5Regular_11">my-app</samp>，以及所有其他默认设置。脚本会根据项目名称创建一个包含*package.json*文件和一个完整示例项目的文件夹，里面有所有必需的文件和文件夹。最后，脚本通过
    npm 安装依赖和开发依赖。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Instead of setting up a new project, you can use the online playgrounds at*
    [https://<wbr>codesandbox<wbr>.io<wbr>/s<wbr>/](https://codesandbox.io/s/) *or*
    [https://<wbr>stackblitz<wbr>.com](https://stackblitz.com) *to run the Next.js
    code examples from this chapter. Just opt for the* pages *directory setup instead
    of* app *there as well.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果不想设置一个新项目，你可以使用在线的沙盒环境，如* [https://<wbr>codesandbox<wbr>.io<wbr>/s<wbr>/](https://codesandbox.io/s/)
    *或者* [https://<wbr>stackblitz<wbr>.com](https://stackblitz.com) *来运行本章的 Next.js
    代码示例。只需选择* pages *目录设置，而不是* app *目录即可。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Project Structure</samp>
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">项目结构</samp>
- en: 'Let’s explore the boilerplate Next.js app’s project structure. Enter the following
    commands to run it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探索一下 Next.js 应用程序的项目结构。输入以下命令来运行它：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Visit the provided URL in your browser. You should see a default page similar
    to the one in [Figure 5-1](chapter5.xhtml#fig5-1) (this welcome page could change
    depending on your Next.js version).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中访问提供的 URL。你应该能看到一个默认页面，类似于[图 5-1](chapter5.xhtml#fig5-1)中所示的页面（这个欢迎页面可能会根据你的
    Next.js 版本有所不同）。
- en: '![](../images/Figure5-1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 5-1: The boilerplate
    Next.js app viewed in a browser</samp>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 5-1：在浏览器中查看的 Next.js 基本应用</samp>
- en: 'Now open the *my-app* folder that the scaffolding script created, and look
    around. The *my-app* folder contains a lot of folders, but only three are currently
    important to you: *public*, *styles*, and *pages*.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开*my-app*文件夹，这是脚手架脚本创建的，并浏览其中的内容。*my-app*文件夹包含了许多文件夹，但目前只有三个对你来说比较重要：*public*、*styles*
    和 *pages*。
- en: The *public* folder holds all static assets, such as custom font files, all
    images, and files the app makes available for download. We’ll link to these assets
    from the app’s HTML and CSS files. The *pages* folder contains all of the app’s
    routes. Each of its files is an endpoint belonging to a page route or an API route
    (in the *api* subfolder).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*public* 文件夹保存所有静态资源，如自定义字体文件、所有图像以及应用程序提供下载的文件。我们将在应用程序的 HTML 和 CSS 文件中链接这些资源。*pages*
    文件夹包含了应用程序的所有路由。它的每个文件都是一个属于页面路由或 API 路由（在 *api* 子文件夹中的）端点。'
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Recent versions of Next.js additionally include an* app *directory that you
    can choose to use for routing as an alternative to the* pages *directory. Because
    the* app *directory uses more advanced concepts, this chapter covers the simpler*
    pages *architectural style. However, you can learn more about the* app *directory
    in [Appendix B](appendix-B.xhtml), where we’ll cover its use in detail.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*Next.js 的最新版本还包含了一个* app *目录，你可以选择使用它进行路由设置，作为* pages *目录的替代方案。由于* app *目录使用了更先进的概念，本章将讲解更简单的*
    pages *架构风格。不过，你可以在[附录 B](appendix-B.xhtml)中进一步了解* app *目录，我们将在那里详细介绍它的使用。*'
- en: In the *my-app* folder, we also find the *_app.tsx* file, which is Next.js’s
    equivalent to the *App.tsx* file we used in [Chapter 4](chapter4.xhtml). This
    is the entry point for the whole application and the place where we’ll add our
    global styles, components, and context providers. Finally, the *styles* folder
    contains the global CSS files and modules for locally scoped, component-specific
    files.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *my-app* 文件夹中，我们还可以找到 *_app.tsx* 文件，这是 Next.js 对我们在[第4章](chapter4.xhtml)中使用的
    *App.tsx* 文件的等价物。它是整个应用程序的入口点，也是我们将添加全局样式、组件和上下文提供者的地方。最后，*styles* 文件夹包含全局 CSS
    文件以及用于本地作用域、组件特定的模块文件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Development Scripts</samp>
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">开发脚本</samp>
- en: The technologies our app uses, including TypeScript, React, and JSX, don’t run
    directly in the browser. They all require a build pipeline with a reasonably complex
    transpiler. Next.js provides four command line scripts to simplify development.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序使用的技术，包括 TypeScript、React 和 JSX，并不能直接在浏览器中运行。它们都需要一个包含合理复杂转译器的构建管道。Next.js
    提供了四个命令行脚本，以简化开发过程。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">npx next dev</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp> commands starts the
    application at *http://localhost:3000* in development mode. As a result, Next.js
    rebuilds and reloads the rendered application in the browser window as soon as
    we change a file. In addition to this *hot-code* reloading, the development server
    also displays errors and warning messages to aid the application’s development.
    The installation wizard adds the server to *package.json*’s script section, so
    we can start it with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp>
    as well.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">npx next dev</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    run dev</samp> 命令以开发模式启动应用程序，地址是 *http://localhost:3000*。因此，每当我们更改一个文件时，Next.js
    会在浏览器窗口中重新构建并重新加载渲染后的应用程序。除了这种 *热代码* 重载外，开发服务器还会显示错误和警告信息，以帮助应用程序的开发。安装向导会将服务器添加到
    *package.json* 的脚本部分，因此我们也可以通过运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    run dev</samp> 来启动它。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">npx next build</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run build</samp> commands create
    the optimized build of our application. They remove unused code and reduce the
    file size of our scripts, styles, and all other assets. You’ll use them for the
    live deployment. The <samp class="SANS_TheSansMonoCd_W5Regular_11">npx next start</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run start</samp> commands
    run the optimized application at *http://localhost:3000* in production mode on
    the built-in server or in a serverless environment. This production build relies
    on a previously created build. Hence, we must have first run the <samp class="SANS_TheSansMonoCd_W5Regular_11">build</samp>
    command.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">npx next build</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">npm run build</samp> 命令创建了我们应用程序的优化构建版本。它们会移除未使用的代码，并减少脚本、样式和其他资源文件的大小。你将在实时部署时使用这些命令。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">npx next start</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    run start</samp> 命令将在内置服务器或无服务器环境中，以生产模式运行优化后的应用程序，地址是 *http://localhost:3000*。此生产构建依赖于之前创建的构建版本，因此，我们必须首先运行
    <samp class="SANS_TheSansMonoCd_W5Regular_11">build</samp> 命令。
- en: Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">npx next export</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run export</samp> commands
    create a stand-alone version of your application that is independent of the built-in
    Next.js server and can run on any infrastructure. This version of your app won’t
    be able to use features that require Next.js on the server side, however. Consult
    the official Next.js documentation at [*https://<wbr>nextjs<wbr>.org*](https://nextjs.org)
    for a guide to using it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，<samp class="SANS_TheSansMonoCd_W5Regular_11">npx next export</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">npm run export</samp> 命令创建了一个独立版本的应用程序，该版本不依赖于内置的
    Next.js 服务器，可以在任何基础设施上运行。然而，此版本的应用程序将无法使用需要 Next.js 服务器端功能的特性。请参考官方 Next.js 文档
    [*https://<wbr>nextjs<wbr>.org*](https://nextjs.org)，获取使用指南。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Routing the Application</samp>
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">路由应用程序</samp>
- en: When we built our sample Express.js server, we created an explicit routing file
    that mapped each of the app’s endpoints to distinct functions that performed corresponding
    behavior. Next.js offers a different, perhaps simpler, routing system; it automatically
    creates the app’s routes based on the files in the *pages* directory. If a file
    in this folder exports a React component (in the case of a web page) or an async
    function (in the case of an API), it becomes a valid endpoint, as either an HTML
    page or an API.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建我们的示例 Express.js 服务器时，我们创建了一个明确的路由文件，将应用程序的每个端点映射到执行相应行为的不同函数。Next.js 提供了一个不同的、也许更简单的路由系统；它基于
    *pages* 目录中的文件自动创建应用程序的路由。如果该文件导出了一个 React 组件（对于网页）或一个异步函数（对于 API），它就成为一个有效的端点，既可以是一个
    HTML 页面，也可以是一个 API。
- en: In this section, we’ll revisit the routes we created in our Express.js server
    and remake them using Next.js’s routing technique.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重新审视我们在 Express.js 服务器中创建的路由，并使用 Next.js 的路由技术重新构建它们。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Simple Page Routes</samp>
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">简单页面路由</samp>
- en: For our Express.js server, we manually created a */hello* route in the *index.ts*
    file. When visited, it returned <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello
    World!</samp> Let’s convert this route to a page-based one in Next.js. The simplest
    kind of page route consists of a file placed directly in the *pages* directory.
    For example, the *pages/index.tsx* file, created by default, maps to *http://localhost:3000*.
    To create a simple */hello* route, make a new file, *hello.tsx*, in that directory.
    Now add to it the code from [Listing 5-1](chapter5.xhtml#Lis5-1).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 Express.js 服务器，我们在 *index.ts* 文件中手动创建了一个 */hello* 路由。当访问该路由时，它返回了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp>。现在让我们将此路由转换为 Next.js
    中基于页面的路由。最简单的页面路由类型是将文件直接放置在 *pages* 目录中。例如，默认创建的 *pages/index.tsx* 文件映射到 *http://localhost:3000*。要创建一个简单的
    */hello* 路由，只需在该目录下创建一个新文件 *hello.tsx*。然后，将[列表 5-1](chapter5.xhtml#Lis5-1)中的代码添加到该文件中。
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 5-1: The pages/hello.tsx file'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-1：pages/hello.tsx 文件
- en: Our Express.js server used the <samp class="SANS_TheSansMonoCd_W5Regular_11">routeHello</samp>
    function to return the <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp>
    string. Here we need to add a little more code to export a React component. First
    we import the custom type <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>
    from the Next.js module and use it to create a constant, <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello</samp>.
    We assign the constant a fat arrow function that returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>,
    which is nothing but a custom wrapper for React components. In this case, we return
    JSX that renders the <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp>
    string. Finally, we export the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>
    as the file’s default export.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Express.js 服务器使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">routeHello</samp>
    函数返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp> 字符串。在这里，我们需要添加更多代码来导出一个
    React 组件。首先，我们从 Next.js 模块导入自定义类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>，并用它创建一个常量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello</samp>。我们将常量赋值为一个返回 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp> 的箭头函数，<samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>
    实际上是 React 组件的一个自定义包装器。在这种情况下，我们返回 JSX 渲染 <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello
    World!</samp> 字符串。最后，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>
    作为文件的默认导出。
- en: Run the server and navigate to *http://localhost:3000/hello*. The page you see
    should show <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp>
    as its content.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行服务器并导航到 *http://localhost:3000/hello*。您看到的页面应该显示 <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello
    World!</samp> 作为其内容。
- en: The page looks different from the one in the sample Express.js server. That’s
    because Next.js automatically renders all global styles defined in the *_app.tsx*
    file to each page. Hence, the font looks different, even though we didn’t explicitly
    define any styles in the *hello.tsx* file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该页面与示例 Express.js 服务器中的页面看起来不同。这是因为 Next.js 会自动将 *_app.tsx* 文件中定义的所有全局样式应用到每个页面。因此，即使我们在
    *hello.tsx* 文件中没有显式定义任何样式，字体看起来也会不同。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nested Page Routes</samp>
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">嵌套路由页面</samp>
- en: '*Nested* routes, such as */components/weather* from the sample Express.js server,
    are logical subroutes of other routes. In other words, *weather* is nested inside
    the *components* entry point. You’ve probably already guessed how we create a
    nested route with Next.js’s page-routing pattern. Yes, we merely create a subfolder,
    and Next.js maps the folder structure to the URL schema.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*嵌套路由*，如示例中的*/components/weather*，是其他路由的逻辑子路由。换句话说，*weather*是嵌套在*components*入口点下的。你可能已经猜到我们如何使用Next.js的页面路由模式来创建嵌套路由了。没错，我们只需要创建一个子文件夹，Next.js会将文件夹结构映射到URL模式。'
- en: Create a new folder, *components*, inside the *pages* folder and add a new file,
    *weather.tsx*, there. [Figure 5-2](chapter5.xhtml#fig5-2) depicts the relationship
    between the URL *components/weather* and the file structure *pages/components/weather.tsx*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在*pages*文件夹内创建一个新的文件夹*components*，并在其中添加一个新的文件*weather.tsx*。[图5-2](chapter5.xhtml#fig5-2)展示了URL
    *components/weather* 与文件结构 *pages/components/weather.tsx* 之间的关系。
- en: '![](../images/Figure5-2.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 5-2: The relationship
    between the URL</samp> <samp class="SANS_Futura_Std_Book_11">components/weather</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_BI_11">and the file structure</samp>
    <samp class="SANS_Futura_Std_Book_11">pages/components/weather.tsx</samp>'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图5-2：URL</samp> <samp class="SANS_Futura_Std_Book_11">components/weather</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_BI_11">与文件结构之间的关系</samp> <samp class="SANS_Futura_Std_Book_11">pages/components/weather.tsx</samp>
- en: Our *pages* folder is the root of the URL, and each nested folder becomes a
    URL segment. The file that exports the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>
    is the *leaf segment*, or the final part of the URL. For this file, we reuse the
    weather component code we wrote in [Chapter 4](chapter4.xhtml), shown in [Listing
    5-2](chapter5.xhtml#Lis5-2).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的*pages*文件夹是URL的根目录，每个嵌套文件夹都成为URL的一部分。导出<samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>的文件是*叶子节点*，即URL的最终部分。对于这个文件，我们重用了在[第4章](chapter4.xhtml)中编写的天气组件代码，见[清单5-2](chapter5.xhtml#Lis5-2)。
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 5-2: The pages/components/weather.tsx file'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5-2：pages/components/weather.tsx 文件
- en: The only difference from the functional component created in [Chapter 4](chapter4.xhtml)
    is that we wrap the code in a function that returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>,
    which we then export as the default export. This is consistent with the page we
    created in [Listing 5-1](chapter5.xhtml#Lis5-1) and follows Next.js’s pattern
    requirement.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第4章](chapter4.xhtml)中创建的功能组件的唯一区别是，我们将代码包装在一个返回<samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>的函数中，然后将其作为默认导出。这与我们在[清单5-1](chapter5.xhtml#Lis5-1)中创建的页面一致，并遵循Next.js的模式要求。
- en: Visit the new page at *http://localhost:3000/components/weather* in the browser.
    It should look similar to [Figure 5-3](chapter5.xhtml#fig5-3).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中访问新的页面 *http://localhost:3000/components/weather*，它应该与[图5-3](chapter5.xhtml#fig5-3)相似。
- en: '![](../images/Figure5-3.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 5-3: The</samp> <samp
    class="SANS_Futura_Std_Book_11">pages/components/weather.tsx</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">file
    is rendered at the</samp> <samp class="SANS_Futura_Std_Book_11">/components/weather</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_BI_11">URL in the browser.</samp>'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图5-3：该</samp> <samp class="SANS_Futura_Std_Book_11">pages/components/weather.tsx</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_BI_11">文件在</samp> <samp class="SANS_Futura_Std_Book_11">/components/weather</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_BI_11">URL中渲染。</samp>
- en: You should recognize the click-handler functionality you saw in [Chapter 4](chapter4.xhtml).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能认出在[第4章](chapter4.xhtml)中看到的点击处理器功能。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">API Routes</samp>
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">API 路由</samp>
- en: In addition to a user-friendly interface, a full-stack application might also
    need a machine-readable interface. For example, the Food Finder application you’ll
    create in [Part II](part2.xhtml) will provide an API to external services so that
    a mobile app or a third-party widget can display our wish list. As JavaScript-driven
    full-stack developers, the most common API formats we’ll use are GraphQL and REST,
    and we talk about these in depth in [Chapter 6](chapter6.xhtml). Here we will
    create REST APIs, which we like for their simplicity.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用户友好的界面外，完整栈应用程序可能还需要一个机器可读的接口。例如，在[第二部分](part2.xhtml)中，你将创建的 Food Finder
    应用程序将为外部服务提供一个 API，以便移动应用或第三方小部件可以显示我们的愿望清单。作为 JavaScript 驱动的全栈开发者，我们最常用的 API
    格式是 GraphQL 和 REST，我们将在[第六章](chapter6.xhtml)中深入讨论这两种格式。在这里，我们将创建 REST API，因为它们简洁易用。
- en: With Next.js, we can design and create APIs via the same patterns we use for
    pages. Each file in the *pages/api/* folder is a single API endpoint, and we can
    define nested API routes in the same way we define nested page routes. However,
    unlike page routes, API routes are not React components. Instead, they are async
    functions that take two parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">NextApiRequest</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NextApiResponse</samp>, and
    return a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextApiResponse</samp>
    and JSON data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Next.js，我们可以通过与页面相同的模式设计和创建 API。*pages/api/* 文件夹中的每个文件都是一个单独的 API 端点，我们可以像定义嵌套路由一样定义嵌套的
    API 路由。然而，与页面路由不同，API 路由不是 React 组件。相反，它们是异步函数，接受两个参数，<samp class="SANS_TheSansMonoCd_W5Regular_11">NextApiRequest</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">NextApiResponse</samp>，并返回一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NextApiResponse</samp> 和 JSON 数据。
- en: There are two caveats you need to remember when it comes to API routes. First,
    they do not specify a *Cross-Origin Resource Sharing (CORS)* header by default.
    This set of HTTP headers, most notably the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access
    -Control-Allow-Origin</samp> header, lets a server define the origins from which
    client-side scripts can request resources. If you want client-side scripts running
    in websites on third-party domains to access your API endpoints, you’ll need to
    add additional middleware to enable CORS directly in the Next.js server. Otherwise,
    external requests will prompt a CORS error. This isn’t specific to Next.js; Express.js
    and most other server frameworks require you to do the same.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 API 路由时，有两个需要记住的注意事项。首先，默认情况下，它们不会指定 *跨域资源共享（CORS）* 头部。这组 HTTP 头部，尤其是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Access-Control-Allow-Origin</samp> 头部，允许服务器定义客户端脚本可以请求资源的源。如果你希望在第三方域名上的网站中的客户端脚本访问你的
    API 端点，你需要添加额外的中间件，在 Next.js 服务器中直接启用 CORS。否则，外部请求将触发 CORS 错误。这不仅仅是 Next.js 的问题；Express.js
    和大多数其他服务器框架也要求你做同样的事情。
- en: The second caveat is that static exports done by running <samp class="SANS_TheSansMonoCd_W5Regular_11">next
    export</samp> do not support API routes. They rely on the built-in Next.js server
    and cannot run as static files.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个注意事项是，通过运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">next export</samp>
    进行的静态导出不支持 API 路由。它们依赖于内置的 Next.js 服务器，无法作为静态文件运行。
- en: We used one API route, *api/names*, in the Express.js server. Now let’s refactor
    the code and convert it to a Next.js API route. As before, create a new file,
    *names.ts*, and place it in the *api* folder. Because API routes return an async
    function instead of JSX, we use the *.ts* extension, not the *.tsx* extension
    used for JSX code. Paste the code from [Listing 5-3](chapter5.xhtml#Lis5-3) into
    the file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Express.js 服务器中使用了一个 API 路由，*api/names*。现在，让我们重构代码并将其转换为 Next.js API 路由。如之前所述，创建一个新文件，*names.ts*，并将其放置在
    *api* 文件夹中。因为 API 路由返回的是一个异步函数，而不是 JSX，所以我们使用 *.ts* 扩展名，而不是用于 JSX 代码的 *.tsx* 扩展名。将[列表
    5-3](chapter5.xhtml#Lis5-3)中的代码粘贴到该文件中。
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 5-3: The pages/api/names.ts file'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-3：pages/api/names.ts 文件
- en: First we import the custom types for the API request and response from the Next.js
    package. Then we define the custom type for the API response. In [Chapter 3](chapter3.xhtml),
    we created the same type for typing the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    call in the *routes.ts* file. We’re using the same code and <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    call here, so we’ve reused the type as well. We then create and directly export
    the API handler function mentioned earlier. You learned in [Chapter 2](chapter2.xhtml)
    that async functions need to return a promise as their return type. Therefore,
    we wrap this API response in a promise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从 Next.js 包中导入 API 请求和响应的自定义类型。然后，我们定义 API 响应的自定义类型。在[第 3 章](chapter3.xhtml)中，我们为
    *routes.ts* 文件中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> 调用创建了相同的类型。我们在这里也使用相同的代码和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> 调用，因此我们也复用了该类型。接着，我们创建并直接导出前面提到的
    API 处理函数。你在[第 2 章](chapter2.xhtml)中学到，异步函数需要返回一个 promise 作为返回类型。因此，我们将这个 API 响应包装在一个
    promise 中。
- en: The code in the function’s body is similar to the code in the <samp class="SANS_TheSansMonoCd_W5Regular_11">routeAPINames</samp>
    function from [Chapter 4](chapter4.xhtml). It makes an API request to fetch the
    user data, converts the received data into the desired return format, and finally
    returns the data. However, we need to make a few modifications. First, instead
    of returning an error string, we return an API response with no content and a
    generic status code of *500*, for an *Internal Server Error*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 函数主体中的代码与[第 4 章](chapter4.xhtml)中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">routeAPINames</samp>
    函数中的代码类似。它发出 API 请求来获取用户数据，将接收到的数据转换为所需的返回格式，最后返回数据。然而，我们需要做一些修改。首先，我们不再返回一个错误字符串，而是返回一个没有内容的
    API 响应，并附上通用的状态码 *500*，表示 *内部服务器错误*。
- en: 'The second adjustment involves the data mapping. Previously, we returned a
    string that rendered in the browser. Now, instead of this string, we return a
    JSON object. Therefore, we modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>
    function to create an array of objects. Finally, we change the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement to return the API response with the <samp class="SANS_TheSansMonoCd_W5Regular_11">names</samp>
    object as JSON and a status code of *200: OK*.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '第二个调整涉及数据映射。之前，我们返回的是一个在浏览器中呈现的字符串。现在，我们不再返回这个字符串，而是返回一个 JSON 对象。因此，我们修改了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp> 函数，以创建一个对象数组。最后，我们修改
    <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句，将 API 响应以 JSON
    格式返回，并附上状态码 *200: OK*。'
- en: Now open the new API route in the browser at *http://localhost:3000/api/names*.
    You should see the API response shown in [Figure 5-4](chapter5.xhtml#fig5-4).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在浏览器中打开新的 API 路径 *http://localhost:3000/api/names*。你应该能看到在[图 5-4](chapter5.xhtml#fig5-4)中显示的
    API 响应。
- en: '![](../images/Figure5-4.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 5-4: The</samp> <samp
    class="SANS_Futura_Std_Book_11">pages/api/names.ts</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">file
    rendered from</samp> <samp class="SANS_Futura_Std_Book_11">/api/names</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_BI_11">in the browser</samp>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 5-4：从</samp> <samp class="SANS_Futura_Std_Book_11">pages/api/names.ts</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_BI_11">文件在浏览器中呈现的</samp> <samp class="SANS_Futura_Std_Book_11">/api/names</samp> '
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dynamic URLs</samp>
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">动态 URL</samp>
- en: You now know how to create page and API routes, which are the foundation of
    any full-stack application. However, you might be wondering how to create *dynamic*
    URLs, which change based on input. We often use dynamic URLs for profile pages,
    where the user’s name becomes part of the URL. In fact, we implemented a dynamic
    URL in the Express.js server’s weather API when we defined the route */api/weather/:zipcode*
    in the *index.ts* file. There, *zipcode* was a dynamic parameter, or a dynamic
    leaf segment, whose value was provided by the <samp class="SANS_TheSansMonoCd_W5Regular_11">req.params.zipcode</samp>
    function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何创建页面和 API 路径，这些是任何全栈应用的基础。然而，你可能在想如何创建 *动态* URL，它们会根据输入发生变化。我们通常使用动态
    URL 来展示个人资料页面，其中用户的姓名成为 URL 的一部分。事实上，当我们在 *index.ts* 文件中定义路由 */api/weather/:zipcode*
    时，我们就实现了一个动态 URL。在那里，*zipcode* 是一个动态参数，或者说是一个动态叶子段，其值是由 <samp class="SANS_TheSansMonoCd_W5Regular_11">req.params.zipcode</samp>
    函数提供的。
- en: Next.js uses a slightly different pattern for dynamic URLs. Because it creates
    the routes based on folders and files, we need to define dynamic segments through
    their filenames by wrapping the variable portion in square brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>).
    The dynamic route */api/weather/:zipcode* from the Express.js server would thus
    translate to the file */api/weather/[zipcode].ts*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 对动态 URL 使用了稍有不同的模式。由于它是基于文件夹和文件来创建路由的，我们需要通过将变量部分包裹在方括号（<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>）中来定义动态片段。Express.js
    服务器中的动态路由 */api/weather/:zipcode* 因此会转化为文件 */api/weather/[zipcode].ts*。
- en: Let’s create a dynamic route in our sample Next.js application that mimics the
    */api/weather/:zipcode* route from the Express.js server. Make a new folder, *weather*,
    in the *api* folder, and place a file named *[zipcode].ts* in it. Then paste the
    code from [Listing 5-4](chapter5.xhtml#Lis5-4) into the file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在示例 Next.js 应用程序中创建一个动态路由，模拟来自 Express.js 服务器的 */api/weather/:zipcode* 路由。在
    *api* 文件夹中创建一个新的文件夹 *weather*，并在其中放置一个名为 *[zipcode].ts* 的文件。然后将[列表 5-4](chapter5.xhtml#Lis5-4)中的代码粘贴到该文件中。
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 5-4: The api/weather/[zipcode].ts file'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-4：api/weather/[zipcode].ts 文件
- en: 'This code should be familiar to you, as it follows the basic outline of an
    API route in Next.js. We import the necessary types, then define a custom type,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherDetailType</samp>, and use
    it as the type for the data returned by the function. (By the way, this is the
    same type definition we created in [Chapter 3](chapter3.xhtml).) In the function’s
    body, we return the response with a status code of *200: OK* and a JSON object.
    We fill the <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp> property
    with the ZIP code from the dynamic URL parameter, retrieved with <samp class="SANS_TheSansMonoCd_W5Regular_11">req.query
    .zipcode</samp>.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '这段代码应该对你来说很熟悉，因为它遵循了 Next.js 中 API 路由的基本框架。我们导入了必要的类型，然后定义了一个自定义类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherDetailType</samp>，并将其用作函数返回数据的类型。（顺便说一下，这正是我们在[第
    3 章](chapter3.xhtml)中创建的类型定义。）在函数的主体中，我们返回状态码为 *200: OK* 的响应和一个 JSON 对象。我们用从动态
    URL 参数中获取的邮政编码填充 <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp>
    属性，获取方式为 <samp class="SANS_TheSansMonoCd_W5Regular_11">req.query .zipcode</samp>。'
- en: When you run the server, the browser should show the JSON response with the
    dynamic URL parameter in the response type. If you navigate to *http://localhost:3000/api/weather/12345*,
    you should see the API response. If you change the “12345” part of the URL and
    request the data again, the response data should change accordingly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行服务器时，浏览器应显示带有动态 URL 参数的 JSON 响应。如果你访问 *http://localhost:3000/api/weather/12345*，你应该能看到
    API 响应。如果你更改 URL 中的“12345”部分并重新请求数据，响应数据应相应地变化。
- en: Note that the dynamic route */api/weather/[zipcode].ts* matches */api/weather/12345*
    and */api/weather/54321* but not sub-paths of those routes, such as */api/weather/location/12345*
    or */api/weather/location/54321*. For this, you’ll need to use a *catch all* API
    route, which includes all paths that are inside the current path. You can create
    a catch all route by adding three dots (<samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>)
    in front of the filename. For example, the catch all route */api/weather/[...zipcode].ts*
    could handle all four API endpoints mentioned in this paragraph.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，动态路由 */api/weather/[zipcode].ts* 匹配 */api/weather/12345* 和 */api/weather/54321*，但不匹配这些路由的子路径，例如
    */api/weather/location/12345* 或 */api/weather/location/54321*。为此，你需要使用 *catch
    all* API 路由，它包括当前路径内的所有路径。你可以通过在文件名前添加三个点（<samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>）来创建一个
    catch all 路由。例如，catch all 路由 */api/weather/[...zipcode].ts* 可以处理本文中提到的所有四个 API
    端点。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Styling the Application</samp>
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">样式化应用程序</samp>
- en: 'To add styles to our Next.js application, we create regular CSS files, written
    without the vendor prefixes used in other frameworks. Later, Next.js’s postprocessor
    will add necessary properties to generate backward-compatible styles. While CSS
    syntax is beyond the scope of this book, this section describes how to use Next.js’s
    two kinds of CSS styles: global styles and locally scoped component styles, defined
    in CSS modules.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向我们的 Next.js 应用程序添加样式，我们创建常规的 CSS 文件，这些文件没有使用其他框架中常见的供应商前缀。稍后，Next.js 的后处理器将添加必要的属性，以生成向后兼容的样式。虽然
    CSS 语法超出了本书的范围，但本节将介绍如何使用 Next.js 的两种 CSS 样式：全局样式和在 CSS 模块中定义的局部作用域组件样式。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Global Styles</samp>
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">全局样式</samp>
- en: Global styles affect all pages of an app. We stumbled across this behavior when
    we rendered the *hello.tsx* file; the page used CSS even though we hadn’t added
    any style information ourselves.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 全球样式影响应用的所有页面。当我们渲染 *hello.tsx* 文件时，我们遇到了这种行为；尽管我们没有自己添加任何样式信息，页面还是使用了 CSS。
- en: Practically speaking, global styles are just regular CSS files. They aren’t
    modified during the build, and their class names are guaranteed to stay the same.
    Therefore, we can use them as regular CSS classes across the application. We import
    these CSS files in the app’s entry point, the *pages/_app.tsx* file. Take a look
    at those in the boilerplate project. You should see a line of code similar to
    [Listing 5-5](chapter5.xhtml#Lis5-5).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际角度来看，全球样式只是常规的 CSS 文件。它们在构建过程中不会被修改，并且它们的类名保证保持不变。因此，我们可以在整个应用程序中将它们作为常规
    CSS 类使用。我们将这些 CSS 文件导入到应用的入口文件 *pages/_app.tsx* 中。看看模板项目中的代码，你应该能看到类似于 [Listing
    5-5](chapter5.xhtml#Lis5-5) 的一行代码。
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 5-5: Importing global styles in the _app.tsx file'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 5-5：在 _app.tsx 文件中导入全球样式
- en: Of course, you can adjust the filename and location of the imported styles or
    import multiple files. Try playing around by adding a few styles in the *global.css*
    file and some regular CSS classes to the HTML elements in the *hello.tsx* file.
    Then visit the page at *htttp://localhost:3000/hello* to see how it changed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以调整导入样式的文件名和位置，或者导入多个文件。试着通过在 *global.css* 文件中添加一些样式，并在 *hello.tsx* 文件中的
    HTML 元素上添加一些常规 CSS 类来进行实验。然后访问 *htttp://localhost:3000/hello* 页面，看看它的变化。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Component Styles</samp>
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">组件样式</samp>
- en: In [Chapter 4](chapter4.xhtml), you saw that React lets us create user interfaces
    out of independent, reusable components. Global styles aren’t the best approach
    for styling independent components, as they require us to keep track of the names
    we’ve already used in various components, and if we import components from a previous
    project, we risk having the CSS classes collide with one another.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 4 章](chapter4.xhtml) 中，你看到 React 允许我们通过独立的、可重用的组件来创建用户界面。全球样式并不是为独立组件提供样式的最佳方法，因为它们要求我们跟踪已经在各种组件中使用过的类名，如果我们从先前的项目中导入组件，还可能会导致
    CSS 类名发生冲突。
- en: We need the CSS classes to be scoped to individual modules to work efficiently
    with modularized components. There are multiple architectural patterns for implementing
    this. For example, using the Block Element Modifier methodology, you can manually
    scope the styles to a component or a user interface block.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将 CSS 类作用域限定到单独的模块，以便与模块化组件高效协作。实现这一目标有多种架构模式。例如，使用块元素修饰符（Block Element
    Modifier）方法，你可以手动将样式作用域限定到某个组件或用户界面块。
- en: Luckily, we don’t need to bother with such a clumsy solution. Next.js lets us
    use CSS modules that are scoped during the build process. These CSS modules follow
    the naming convention <*component*>.*module.css*. The compiler automatically prefixes
    each CSS class name inside the module with the component’s name and a unique identifier.
    This enables you to use the same style names for multiple components without issue.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要为这种笨重的解决方案烦恼。Next.js 允许我们使用在构建过程中作用域限定的 CSS 模块。这些 CSS 模块遵循命名约定 <*component*>.*module.css*。编译器会自动在模块内部的每个
    CSS 类名上添加组件的名称和唯一标识符前缀。这使得我们能够在多个组件中使用相同的样式名称而不会出现问题。
- en: The actual CSS you write won’t have these prefixes. For example, look at the
    *Home.module.css* file inside the *styles* folder, shown in [Listing 5-6](chapter5.xhtml#Lis5-6).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 实际编写的 CSS 不会包含这些前缀。例如，查看 *styles* 文件夹中的 *Home.module.css* 文件，见 [Listing 5-6](chapter5.xhtml#Lis5-6)。
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 5-6: Regular CSS code in styles/Home.module.css'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 5-6：styles/Home.module.css 中的常规 CSS 代码
- en: One problem is that, because the build process modifies the class names and
    prefixes them, we can’t directly use these styles in our other files. Instead,
    we must import the styles and treat them like a JavaScript object. Then we can
    refer to them as a property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">styles</samp>
    object. For example, the *pages/index.tsx* file in [Listing 5-7](chapter5.xhtml#Lis5-7)
    uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">container</samp> class
    from [Listing 5-6](chapter5.xhtml#Lis5-6), providing an example of how to use
    scoped styles.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题是，由于构建过程会修改类名并为其添加前缀，我们不能直接在其他文件中使用这些样式。相反，我们必须导入样式，并将其当作 JavaScript 对象来处理。然后，我们可以将其作为
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">styles</samp>` 对象的属性来引用。例如，[列表
    5-7](chapter5.xhtml#Lis5-7) 中的 *pages/index.tsx* 文件使用了来自[列表 5-6](chapter5.xhtml#Lis5-6)
    的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">container</samp>` 类，展示了如何使用作用域样式的示例。
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 5-7: Using styles from the CSS module styles/Home.module.css in the
    index.tsx file'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-7：在 index.tsx 文件中使用来自 CSS 模块样式/Home.module.css 的样式
- en: This code imports the CSS file into a constant called <samp class="SANS_TheSansMonoCd_W5Regular_11">styles</samp>.
    Now all the CSS class names will be available as properties of the <samp class="SANS_TheSansMonoCd_W5Regular_11">styles</samp>
    object. In JSX, we use variables wrapped in curly brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>),
    so we add a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">container</samp>
    class as <samp class="SANS_TheSansMonoCd_W5Regular_11">{styles.container}</samp>.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将 CSS 文件导入到一个名为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">styles</samp>`
    的常量中。现在，所有的 CSS 类名都可以作为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">styles</samp>`
    对象的属性使用。在 JSX 中，我们使用被大括号包裹的变量（`<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>`），因此我们将对
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">container</samp>` 类的引用写为 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{styles.container}</samp>`。
- en: You can now build APIs and custom-styled pages out of React components. The
    next section introduces useful custom components that Next.js provides to enhance
    your full-stack application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以根据 React 组件构建 API 和自定义样式页面。下一部分介绍了 Next.js 提供的一些有用的自定义组件，帮助增强你的全栈应用程序。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Built-in Next.js Components</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">内置的 Next.js 组件</samp>
- en: 'Next.js provides a set of custom components. Each of these addresses one specific
    use case: for example, accessing internal page properties such as the page title
    or SEO metadata (<samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp>),
    improving the app’s overall rendering performance and user experience (<samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp>),
    or enabling the application’s routing (<samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp>).
    We’ll use the Next.js components covered in this chapter in the full-stack application
    in [Part II](part2.xhtml), where you can see them applied in practice. For additional
    attributes and niche use cases, refer to the Next.js documentation.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 提供了一组自定义组件。每个组件针对一个特定的使用场景：例如，访问内部页面属性，如页面标题或 SEO 元数据（`<samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp>`），提升应用程序整体渲染性能和用户体验（`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp>`），或启用应用程序的路由功能（`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp>`）。我们将在[第二部分](part2.xhtml)的全栈应用程序中使用本章涉及的
    Next.js 组件，你可以在实际应用中看到它们的使用。有关其他属性和细分的使用案例，请参考 Next.js 文档。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The next/head Component</samp>
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">next/head 组件</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp> component
    exports a custom Next.js-specific <samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp>
    component. We use it to set a page’s HTML title and meta elements, which are found
    inside an HTML <samp class="SANS_TheSansMonoCd_W5Regular_11">head</samp> component.
    To improve SEO ranking and enhance usability, each page should have its own metadata.
    [Listing 5-8](chapter5.xhtml#Lis5-8) shows an example of the *hello.tsx* page
    from [Listing 5-1](chapter5.xhtml#Lis5-1) with a customized title and meta element.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp>` 组件导出了一个自定义的
    Next.js 特有的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp>` 组件。我们使用它来设置页面的
    HTML 标题和 meta 元素，这些元素位于 HTML 的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">head</samp>`
    组件内。为了提高 SEO 排名和增强可用性，每个页面都应该拥有自己的元数据。[列表 5-8](chapter5.xhtml#Lis5-8) 显示了来自[列表
    5-1](chapter5.xhtml#Lis5-1)的 *hello.tsx* 页面示例，包含了自定义的标题和 meta 元素。'
- en: It is important to remember that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp>
    elements are not merged across pages. Next.js’s client-side routing removes the
    content of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp> element
    during the page transition.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，<samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp> 元素不会跨页面合并。Next.js
    的客户端路由在页面过渡时会移除 <samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp> 元素的内容。
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 5-8: The pages/hello.tsx file with a customized title and meta element'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-8：包含自定义标题和 meta 元素的 pages/hello.tsx 文件
- en: We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp> element
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp> component
    and add it to the returned JSX element, placing it above the existing content
    and wrapping both in another <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>
    element because we need to return one element instead of two.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 <samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp> 组件中导入 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Head</samp> 元素，并将其添加到返回的 JSX 元素中，将其放置在现有内容之上，并将两者包裹在另一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp> 元素中，因为我们需要返回一个元素而不是两个。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The next/link Component</samp>
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">next/link 组件</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp> component
    exports a <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> component.
    This component is built on top of the React <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp>
    element. We use it instead of an HTML anchor tag when we want to link to another
    page in the application, enabling client-side transitions between pages. When
    clicked, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> component
    updates the browser DOM with the new DOM, scrolls to the top of the new page,
    and adjusts the browser history. Furthermore, it provides built-in performance
    optimizations, prefetching the linked page and its data as soon as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp>
    component enters the *viewport* (the currently visible part of the website). This
    background prefetch enables smooth page transitions. [Listing 5-9](chapter5.xhtml#Lis5-9)
    adds the Next.js <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> element
    to the page from the previous listing.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp> 组件导出了一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> 组件。这个组件是建立在 React 的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> 元素之上的。当我们想要在应用中链接到另一个页面时，我们使用它来替代
    HTML 锚点标签，从而启用客户端之间的页面过渡。点击时，<samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp>
    组件会更新浏览器 DOM，显示新的 DOM，滚动到新页面的顶部，并调整浏览器历史记录。此外，它提供了内置的性能优化，当 <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp>
    组件进入 *视口*（网站当前可见部分）时，会预取链接的页面及其数据。这种后台预取使得页面过渡更加流畅。[清单 5-9](chapter5.xhtml#Lis5-9)
    将上一个清单中的 Next.js <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> 元素添加到页面中。
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 5-9: The pages/hello.tsx file with an external link and an internal
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">next/link</samp> element'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-9：包含外部链接和内部 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">next/link</samp>
    元素的 pages/hello.tsx 文件
- en: We import the component, then add it to the returned JSX element. For comparison
    purposes, we use a regular HTML anchor to link to the No Starch Press home page
    and the custom <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> to connect
    to the weather component page in our Next.js application. In the app, try clicking
    both links to see the difference.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入该组件，然后将其添加到返回的 JSX 元素中。为了进行比较，我们使用常规的 HTML 锚点链接到 No Starch Press 首页，并使用自定义的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> 连接到我们的 Next.js 应用中的天气组件页面。在应用中，尝试点击这两个链接，看看它们的区别。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The next/image Component</samp>
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">next/image 组件</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp> component
    exports an <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp> component
    used to display images. This component is built on top of the native HTML <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><img></samp> element. It handles common
    layout requirements, such as filling all available space and scaling images. The
    component can load modern image formats, such as *AVIF* and *WebP*, and serve
    the image with the correct size for the client’s screen. Furthermore, you have
    the option to use blurred placeholder images and lazy-load the actual image as
    soon as it enters the viewport; this enforces the visual stability of your website
    by preventing *cumulative layout shifts*, which occur when an image renders after
    the page, causing the page content to shift down. Cumulative layout shifts are
    considered a bad user experience, and they can make the user lose their focus.
    [Listing 5-10](chapter5.xhtml#Lis5-10) provides a basic example of the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp>
    component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp> 组件导出了一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Image</samp> 组件，用于显示图像。该组件是基于原生 HTML 中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><img></samp> 元素构建的。它处理常见的布局需求，如填充所有可用空间和缩放图像。该组件可以加载现代图像格式，如
    *AVIF* 和 *WebP*，并根据客户端的屏幕显示合适大小的图像。此外，你可以选择使用模糊的占位图像，并在图像进入视口时延迟加载实际图像；这可以通过防止
    *累积布局位移* 来强制网站的视觉稳定性，累积布局位移发生在图像在页面之后渲染时，导致页面内容向下移动。累积布局位移被认为是糟糕的用户体验，它会使用户失去注意力。[Listing
    5-10](chapter5.xhtml#Lis5-10) 提供了 <samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp>
    组件的基本示例。
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 5-10: The pages/hello.tsx file using the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">next/image</samp>
    element'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-10: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">next/image</samp>
    元素的 pages/hello.tsx 文件'
- en: Here we display the Vercel logo from our application’s *public* folder. First
    we import the component from the *next/image* package. Then we add it to the page
    content. The syntax and the properties of our minimal example are similar to the
    HTML <samp class="SANS_TheSansMonoCd_W5Regular_11">img</samp> element. You can
    read more about the component’s advanced properties in the official documentation
    at [*https://<wbr>nextjs<wbr>.org<wbr>/docs<wbr>/api<wbr>-reference<wbr>/next<wbr>/image*](https://nextjs.org/docs/api-reference/next/image).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了来自应用程序的 Vercel logo，它位于 *public* 文件夹中。首先，我们从 *next/image* 包中导入该组件。然后我们将其添加到页面内容中。我们的最小示例的语法和属性类似于
    HTML 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">img</samp> 元素。你可以在官方文档中了解更多关于该组件的高级属性，链接为
    [*https://<wbr>nextjs<wbr>.org<wbr>/docs<wbr>/api<wbr>-reference<wbr>/next<wbr>/image*](https://nextjs.org/docs/api-reference/next/image)。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Pre-rendering and Publishing</samp>
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">预渲染和发布</samp>
- en: 'While you can start building full-stack Next.js applications with the information
    you’ve learned so far, you’ll find it useful to know one more advanced topic:
    the different ways to render and publish your application and their implications
    for its performance.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以根据目前所学的内容开始构建全栈的 Next.js 应用程序，但了解一个更高级的话题会很有帮助：不同的渲染和发布方式及其对性能的影响。
- en: Next.js provides three options for pre-rendering your app with its built-in
    server. The first, *static site generation (SSG)*, generates the HTML at build
    time. Thus, each request will always return the same HTML, which remains static
    and is never re-created. The second option, *server-side rendering (SSR)*, generates
    new HTML files on each request, and the third, *incremental static regeneration
    (ISR)*, combines both approaches.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 提供了三种预渲染应用程序的选项，利用其内置的服务器。第一种，*静态网站生成（SSG）*，在构建时生成 HTML。因此，每次请求都会返回相同的
    HTML，它是静态的且永远不会被重新创建。第二种选项，*服务器端渲染（SSR）*，在每次请求时生成新的 HTML 文件，第三种，*增量静态再生（ISR）*，将两者的优点结合起来。
- en: Next.js lets us choose our pre-rendering option on a per-page basis, meaning
    the full-stack application can contain pages with SSG, SSR, and ISR, as well as
    client-side rendering for some React components. You can also create a complete
    static export of your site by running <samp class="SANS_TheSansMonoCd_W5Regular_11">next
    export</samp>. The exported application will run independently on all infrastructures,
    as it doesn’t need the built-in Next.js server.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: To gain experience with these rendering approaches, we’ll create a new page
    that displays the data from our names API for each rendering option. Create a
    new folder, *utils*, next to the *pages* folder and add an empty file, *fetch-names.ts*,
    to it. Then add the code in [Listing 5-11](chapter5.xhtml#Lis5-11). This utility
    function calls the remote API and returns the dataset.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 5-11: The async utility in utils/fetch-names.ts'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining a custom type, we create a function and directly export it.
    This function contains the code from the previously created *names.ts* file, with
    two adjustments: first we need to define the data array as possibly empty; next,
    we return an empty array instead of an error string if the API call fails. This
    change means that we don’t need to verify the type before iterating over the array
    when we generate the JSX string.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Server-Side Rendering</samp>
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using SSR, Next.js’s built-in Node.js server creates an application’s HTML in
    response to each request. You should use this technique if your page depends on
    fresh data from an external API. Unfortunately, SSR is slower in production, because
    the pages aren’t easily cacheable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: To use SSR for a page, export an additional async function, <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>,
    from that page. Next.js calls this function on every request and passes the fetched
    data to the page’s <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    argument to pre-render it before sending it to the client.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Try this out by creating a new file, *names-ssr.tsx*, in the *pages* folder.
    Paste the code from [Listing 5-12](chapter5.xhtml#Lis5-12) into the file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 5-12: A basic page that displays data with SSR, page/names-ssr.tsx'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: To use Next.js’s SSR, we export the additional async function, <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>.
    We also import necessary functionality from the *next* and *querystring* packages
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetchNames</samp> function
    we created earlier. Then we define the custom type for the response to the API
    request. It’s the same custom type we used in [Chapter 3](chapter3.xhtml).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create the page and store the export as the default one. The page returns
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp> and takes the
    default properties for this page type. We iterate over the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    parameter’s <samp class="SANS_TheSansMonoCd_W5Regular_11">names</samp> array and
    create a JSX string that we render and return to the browser. Then we define the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp> function,
    which gets the data from the API. We return the created dataset from the async
    function and pass it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>
    inside the page properties.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建页面并将导出作为默认选项。页面返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>
    并采用该页面类型的默认属性。我们遍历 <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    参数的 <samp class="SANS_TheSansMonoCd_W5Regular_11">names</samp> 数组，创建一个 JSX 字符串并将其渲染返回到浏览器。然后我们定义
    <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp> 函数，它从
    API 获取数据。我们从异步函数返回创建的数据集，并将其传递给页面属性中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>。
- en: Navigate to the new page at *http://localhost:3000/names-ssr*. You should see
    the list of the usernames.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到新页面 *http://localhost:3000/names-ssr*。你应该能够看到用户名列表。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static Site Generation</samp>
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">静态站点生成</samp>
- en: SSG creates the HTML files only once and reuses them for every request. It is
    the recommended option, because pre-rendered pages are easy to cache and fast
    to deliver. For example, a content delivery network can easily pick up your static
    files.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: SSG 只创建一次 HTML 文件，并在每个请求中重复使用它们。这是推荐的选项，因为预渲染的页面易于缓存并且传递速度快。例如，内容分发网络可以轻松获取你的静态文件。
- en: Usually, SSG applications have a lower *time to first paint*, or the time it
    takes after a user requests the page (by, for example, clicking a link) until
    the content appears in the browser. SSG also reduces *blocking time*, or the time
    it takes until the user can actually interact with the page’s content. Good scores
    in these metrics indicate a responsive website, and they are part of Google’s
    scoring algorithm. Hence, these pages have increased SEO rankings.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，SSG 应用程序具有更低的 *首次绘制时间*，即用户请求页面（例如，通过点击链接）到内容在浏览器中出现之间的时间。SSG 还可以减少 *阻塞时间*，即用户实际与页面内容交互前的时间。这些指标的良好得分表明网站响应迅速，且它们是
    Google 打分算法的一部分。因此，这些页面的 SEO 排名更高。
- en: If your page relies on external data, you can still use SSG by exporting an
    additional async function, <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp>,
    from the page’s file. Next.js calls this function at build time, passes the fetched
    data to the page’s <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    argument, and pre-renders the page with SSG. Of course, this works only if the
    external data isn’t dynamic.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的页面依赖外部数据，你仍然可以通过从页面文件中导出一个额外的异步函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp>
    来使用 SSG。Next.js 会在构建时调用此函数，将获取的数据传递给页面的 <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    参数，并使用 SSG 预渲染页面。当然，只有在外部数据不是动态的情况下，这种方法才有效。
- en: Try creating the same page as in the SSR example, this time with SSG. Add a
    new file, *names-ssg.tsx*, in the *pages* folder and then paste in the code shown
    in [Listing 5-13](chapter5.xhtml#Lis5-13).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建与 SSR 示例中相同的页面，这次使用 SSG。首先在 *pages* 文件夹中添加一个新文件，*names-ssg.tsx*，然后粘贴 [示例
    5-13](chapter5.xhtml#Lis5-13) 中显示的代码。
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 5-13: A page that displays data with SSG, page/names-ssg.tsx'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-13：使用 SSG 显示数据的页面，page/names-ssg.tsx
- en: The code is mostly identical to [Listing 5-9](chapter5.xhtml#Lis5-9). We just
    need to change the SSR-specific code to use SSG. Therefore, we export <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>
    and adjust the types accordingly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与 [示例 5-9](chapter5.xhtml#Lis5-9) 基本相同。我们只需要将特定于 SSR 的代码更改为使用 SSG。因此，我们导出
    <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp> 而不是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>，并相应调整类型。
- en: When you visit the page, it should look similar to the SSR page. But instead
    of requesting fresh data on each visit to *http://localhost:3000/names-ssg*, the
    data is requested only once, on page build.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你访问该页面时，它应该与 SSR 页面类似。但与每次访问 *http://localhost:3000/names-ssg* 都请求新数据不同，数据只在页面构建时请求一次。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Incremental Static
    Regeneration</samp>
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">增量静态再生</samp>
- en: ISR is a hybrid of SSG and SSR that runs purely on the server side. It generates
    the HTML on the server during the initial build and sends this pre-generated HTML
    the first time a page is requested. After a specified time has passed, Next.js
    will fetch the data and regenerate the page on the server in the background. In
    the process, it invalidates the internal server cache and updates it with the
    new page. Every subsequent request will receive the up-to-date page. Like SSG,
    ISR is less costly than SSR and increases a page’s SEO ranking.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ISR 是 SSG 和 SSR 的混合体，完全在服务器端运行。在初次构建时，它在服务器上生成 HTML，并在第一次请求页面时发送这个预生成的 HTML。在指定时间过后，Next.js
    会获取数据并在后台重新生成页面。在此过程中，它会使内部服务器缓存失效，并用新页面更新缓存。每个后续请求将收到最新的页面。与 SSG 类似，ISR 比 SSR
    成本更低，并能提升页面的 SEO 排名。
- en: To enable ISR in SSG pages, we need to add a property to revalidate <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProp</samp>’s
    return object. We define the validity of the data in seconds, as shown in [Listing
    5-14](chapter5.xhtml#Lis5-14).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 SSG 页面中启用 ISR，我们需要向 `getStaticProp` 的返回对象添加一个属性以重新验证。我们以秒为单位定义数据的有效性，如 [列表
    5-14](chapter5.xhtml#Lis5-14) 所示。
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 5-14: Changing <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">getServerSideProps</samp>
    to enable ISR'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-14：更改 `<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">getServerSideProps</samp>`
    以启用 ISR
- en: We add the <samp class="SANS_TheSansMonoCd_W5Regular_11">revalidate</samp> property
    with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">30</samp>. As a
    result, the custom Next.js server will invalidate the current HTML 30 seconds
    after the first page request.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了 `<samp class="SANS_TheSansMonoCd_W5Regular_11">revalidate</samp>` 属性，值为
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">30</samp>`。因此，定制的 Next.js 服务器将在第一次页面请求后
    30 秒使当前 HTML 失效。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Client-Side Rendering</samp>
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">客户端渲染</samp>
- en: A completely different approach, *client-side rendering* involves first generating
    the HTML with SSR or SSG and sending it to the client. The client then fetches
    additional data at runtime and renders it in the browser DOM. Client-side rendering
    is a good choice when working with highly flexible, constantly changing datasets,
    such as real-time stock market or currency prices. Other sites use it to send
    a skeleton version of the page to the client and later enhance it with more content.
    However, client-side rendering lowers your SEO performance, as its data can’t
    be indexed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 完全不同的方法，*客户端渲染* 首先使用 SSR 或 SSG 生成 HTML 并发送到客户端。然后客户端在运行时获取额外的数据，并在浏览器的 DOM 中渲染。客户端渲染是处理高度灵活、不断变化的数据集（如实时股票市场或货币价格）的好选择。其他网站使用它将页面的骨架版本发送到客户端，然后用更多内容进行增强。然而，客户端渲染会降低你的
    SEO 性能，因为其数据无法被索引。
- en: '[Listing 5-15](chapter5.xhtml#Lis5-15) shows the page we created earlier, configured
    for client-side rendering. Create a new file, *names-csr.tsx*, in the *pages*
    folder and then add the code to it.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-15](chapter5.xhtml#Lis5-15) 显示了我们之前创建的页面，已配置为客户端渲染。请在 *pages* 文件夹中创建一个新文件，命名为
    *names-csr.tsx*，然后将代码添加到其中。'
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 5-15: The client-side rendered page, page/names-csr.tsx'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-15：客户端渲染页面，page/names-csr.tsx
- en: This code differs significantly from the previous examples. Here we import the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hooks. The latter one will fetch the data after the page is already available.
    As soon as the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetchNames</samp>
    function returns the data, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp>
    hook and the reactive <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    state variable to update the browser DOM.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前的示例有很大不同。这里我们导入了 `<samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp>`
    和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>` 钩子。后者会在页面可用后获取数据。一旦
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">fetchNames</samp>` 函数返回数据，我们使用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp>` 钩子和响应式的 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">data</samp>` 状态变量来更新浏览器的 DOM。
- en: We cannot declare the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hook as an async function, because it returns either an undefined value or a function,
    whereas an async function returns a promise, and therefore TSC would throw an
    error. To avoid this, we need to wrap the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    call in an async function, <samp class="SANS_TheSansMonoCd_W5Regular_11">fetchData</samp>,
    and then call that function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The page configured for client-side rendering should look similar to the other
    versions. But when you visit *http://localhost:3000/names-csr*, you might see
    a white flash. This is the page waiting for the asynchronous API request.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: To get a better feel for the different rendering types, modify the code for
    each example in this section to use the API *[https://www.usemodernfullstack.dev/api/v1/now](https://www.usemodernfullstack.dev/api/v1/now)*,
    which returns an object with the timestamp of the request.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static HTML Exporting</samp>
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">next export</samp> command
    generates a static HTML version of your web application. This version is independent
    of the built-in Node.js-based Next.js web server and can run on any infrastructure,
    such as an Apache, NGINX, or IIS server.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: To use this command, your page must implement <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp>,
    as in SSG. This command won’t support the <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>
    function, ISR, or API routes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 5: Refactor Express.js and
    React to Next.js</samp>'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Let’s refactor the React and Express.js applications from the previous chapters
    into a Next.js application that we’ll expand in the upcoming chapters. As a first
    step, we’ll summarize the functionality we need to build. Our application has
    an API route, *api/names*, that returns usernames, and another API route, *api/weather/:zipcode*,
    that returns a static JSON object and the URL parameter. We used it to understand
    dynamic URLs. In addition, we created pages at */hello* and *component/weather*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ve already refactored these various elements to
    work with Next.js’s routing style. In this exercise, we’ll put it all together.
    Follow the steps in “Setting Up Next.js” on page 70 to initialize the Next.js
    application. Within the *sample-next* folder, name your application *refactored-app*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Storing Custom Interfaces
    and Types</samp>
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We create a new file, *custom.d.ts*, in the root of the project to store our
    custom interface and type definitions ([Listing 5-16](chapter5.xhtml#Lis5-16)).
    It is similar to the one we used in [Chapters 3](chapter3.xhtml) and [4](chapter4.xhtml).
    The main difference is that we add custom types for the Next.js application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 5-16: The custom.d.ts file'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the custom interface <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherProps</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> argument of
    the page that displays the weather components, *components/weather*. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WeatherDetailType</samp> is for the API
    route *api/weather/:zipcode*, which uses a dynamically fetched ZIP code. Finally,
    we use <samp class="SANS_TheSansMonoCd_W5Regular_11">responseItemType</samp> in
    the API route *api/names* to type the fetch response.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the API
    Routes</samp>
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we re-create the two API routes from the Express.js server. Earlier sections
    of this chapter showed this refactored code. For the *api/names* route, create
    a new file, *names.ts*, in the *api* folder, then add the code from [Listing 5-3](chapter5.xhtml#Lis5-3).
    Refer to that section for a detailed explanation of the code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Migrate the dynamic route *api/weather/:zipcode* from the Express.js server
    to the Next.js application by creating a *[zipcode].js* file in the *api* folder
    and adding the code from [Listing 5-4](chapter5.xhtml#Lis5-4), shown in “Dynamic
    URLs” on page 77. You can refer to that section for more details.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Page
    Routes</samp>
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we work on the pages. First, for the simple page *hello.tsx*, we create
    a new file in the *pages* folder and add the code from [Listing 5-10](chapter5.xhtml#Lis5-10).
    This code renders the <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp>
    example and uses the custom Next.js components <samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp>,
    all of which are explained in detail in “Built-in Next.js Components” on page
    80.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The second page is the nested route *pages/components/weather.tsx*. As before,
    we create a new file, *weather.tsx*, in a folder called *components*, within the
    *pages* folder. Add the code from [Listing 5-2](chapter5.xhtml#Lis5-2). This listing
    uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> hooks to create a reactive
    user interface. We can remove the custom interface definition for the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherProps</samp>
    from this file. The *custom.d.ts* file already adds them to TSC.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Application</samp>
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Start the application with the <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    run dev</samp> command. Now you can visit the same routes we created for the Express.js
    server and see that they are functionally the same. Congratulations! You created
    your first Next.js-based full-stack application. Play around with the code and
    try using global and component CSS to style your pages.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp> 命令启动应用程序。现在，你可以访问我们为
    Express.js 服务器创建的相同路由，并看到它们在功能上完全相同。恭喜！你创建了第一个基于 Next.js 的全栈应用程序。可以尝试修改代码，使用全局
    CSS 和组件 CSS 来为页面添加样式。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: Next.js adds the missing functionality needed to create full-stack applications
    with React. After scaffolding a sample project and exploring the default file
    structure, you learned how to create page and API routes in the framework. You
    also learned about global- and component-level CSS, Next.js’s four built-in command
    line scripts, and its most useful custom components.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 增加了创建全栈应用所需的缺失功能，帮助你与 React 一起构建应用。在搭建一个示例项目并探索默认文件结构后，你学习了如何在框架中创建页面和
    API 路由。你还了解了全局和组件级 CSS、Next.js 的四个内置命令行脚本以及它的最有用的自定义组件。
- en: We also discussed the different ways to render content and pages with Next.js
    and when to choose each option. Finally, you used the code from this chapter to
    quickly migrate the Express.js application you built in the previous chapters
    to Next.js. To continue your adventures in this useful framework, I recommend
    the official tutorials at [*https://<wbr>nextjs<wbr>.org*](https://nextjs.org).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了使用 Next.js 渲染内容和页面的不同方式，以及何时选择每种选项。最后，你使用本章的代码将之前章节中构建的 Express.js 应用程序快速迁移到
    Next.js。为了继续探索这个有用的框架，我推荐访问官方教程：[*https://<wbr>nextjs<wbr>.org*](https://nextjs.org)。
- en: 'In the next chapter, we’ll explore two types of web APIs: the standard RESTful
    APIs and modern GraphQL.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨两种类型的 Web API：标准的 RESTful API 和现代的 GraphQL。
