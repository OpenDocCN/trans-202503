- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NEXT.JS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Drop-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 4](chapter4.xhtml), you used React to create responsive user interface
    components. But because React is just a library, building a full-stack application
    requires additional tools. In this chapter, we use Next.js, the leading web application
    framework built on top of React. To create an app with Next.js, you need to know
    only a few essential concepts. This chapter covers them.
  prefs: []
  type: TYPE_NORMAL
- en: Next.js streamlines the creation of an application’s frontend, middleware, and
    backend. On the frontend, it uses React. It also adds native CSS modules to define
    styles, and custom Next.js modules to perform routing, image handling, and additional
    frontend tasks. When it comes to the middleware and the backend, Next.js uses
    a built-in server to provide the entry points for HTTP requests and a clean API
    in which to work with request and response objects.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover its filesystem-based approach to routing, discuss ways to build
    and render the web pages we deliver to clients, explore adding CSS files to style
    pages, and refactor our Express.js server to work with Next.js. This chapter uses
    the traditional *pages* directory to teach you these basic concepts. To learn
    about Next.js’s alternative *app* directory, see [Appendix B](appendix-B.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setting Up Next.js</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next.js is part of the npm ecosystem. While you could manually install all
    of its required modules by running <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    install next react react-dom</samp> and subsequently create all of your project’s
    files and folders by yourself, there is a much simpler way to set things up: running
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">create-next-app</samp> command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a sample application to use throughout this chapter. Follow these
    steps to set up a new empty folder called *sample-next* and build your first Next.js
    application inside it. Keep the default answers from the setup wizard, and choose
    to use the traditional *pages* directory instead of the *app* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We create a new folder, switch to it, and then initialize a new Next.js project.
    We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">npx</samp> command instead
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">npm</samp> because, as you learned
    in [Chapter 1](chapter1.xhtml), npx doesn’t require us to install anything as
    a dependency or development dependency. We mentioned that a typical use case for
    it is scaffolding, which is precisely what we’re doing here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">create-react-app</samp> command
    has a few options, of which only two are relevant to us: the <samp class="SANS_TheSansMonoCd_W5Regular_11">--typescript</samp>
    option creates a Next.js project that supports TypeScript, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">--use-npm</samp>
    flag selects npm as a package manager.'
  prefs: []
  type: TYPE_NORMAL
- en: We accept the default project name, <samp class="SANS_TheSansMonoCd_W5Regular_11">my-app</samp>,
    and all the other default settings. The script creates a folder based on the project
    name containing the *package.json* file and a complete sample project with all
    necessary files and folders. Finally, it installs the dependencies and development
    dependencies through npm.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Instead of setting up a new project, you can use the online playgrounds at*
    [https://<wbr>codesandbox<wbr>.io<wbr>/s<wbr>/](https://codesandbox.io/s/) *or*
    [https://<wbr>stackblitz<wbr>.com](https://stackblitz.com) *to run the Next.js
    code examples from this chapter. Just opt for the* pages *directory setup instead
    of* app *there as well.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Project Structure</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s explore the boilerplate Next.js app’s project structure. Enter the following
    commands to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Visit the provided URL in your browser. You should see a default page similar
    to the one in [Figure 5-1](chapter5.xhtml#fig5-1) (this welcome page could change
    depending on your Next.js version).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 5-1: The boilerplate
    Next.js app viewed in a browser</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open the *my-app* folder that the scaffolding script created, and look
    around. The *my-app* folder contains a lot of folders, but only three are currently
    important to you: *public*, *styles*, and *pages*.'
  prefs: []
  type: TYPE_NORMAL
- en: The *public* folder holds all static assets, such as custom font files, all
    images, and files the app makes available for download. We’ll link to these assets
    from the app’s HTML and CSS files. The *pages* folder contains all of the app’s
    routes. Each of its files is an endpoint belonging to a page route or an API route
    (in the *api* subfolder).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Recent versions of Next.js additionally include an* app *directory that you
    can choose to use for routing as an alternative to the* pages *directory. Because
    the* app *directory uses more advanced concepts, this chapter covers the simpler*
    pages *architectural style. However, you can learn more about the* app *directory
    in [Appendix B](appendix-B.xhtml), where we’ll cover its use in detail.*'
  prefs: []
  type: TYPE_NORMAL
- en: In the *my-app* folder, we also find the *_app.tsx* file, which is Next.js’s
    equivalent to the *App.tsx* file we used in [Chapter 4](chapter4.xhtml). This
    is the entry point for the whole application and the place where we’ll add our
    global styles, components, and context providers. Finally, the *styles* folder
    contains the global CSS files and modules for locally scoped, component-specific
    files.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Development Scripts</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The technologies our app uses, including TypeScript, React, and JSX, don’t run
    directly in the browser. They all require a build pipeline with a reasonably complex
    transpiler. Next.js provides four command line scripts to simplify development.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">npx next dev</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp> commands starts the
    application at *http://localhost:3000* in development mode. As a result, Next.js
    rebuilds and reloads the rendered application in the browser window as soon as
    we change a file. In addition to this *hot-code* reloading, the development server
    also displays errors and warning messages to aid the application’s development.
    The installation wizard adds the server to *package.json*’s script section, so
    we can start it with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp>
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">npx next build</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run build</samp> commands create
    the optimized build of our application. They remove unused code and reduce the
    file size of our scripts, styles, and all other assets. You’ll use them for the
    live deployment. The <samp class="SANS_TheSansMonoCd_W5Regular_11">npx next start</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run start</samp> commands
    run the optimized application at *http://localhost:3000* in production mode on
    the built-in server or in a serverless environment. This production build relies
    on a previously created build. Hence, we must have first run the <samp class="SANS_TheSansMonoCd_W5Regular_11">build</samp>
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">npx next export</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run export</samp> commands
    create a stand-alone version of your application that is independent of the built-in
    Next.js server and can run on any infrastructure. This version of your app won’t
    be able to use features that require Next.js on the server side, however. Consult
    the official Next.js documentation at [*https://<wbr>nextjs<wbr>.org*](https://nextjs.org)
    for a guide to using it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Routing the Application</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we built our sample Express.js server, we created an explicit routing file
    that mapped each of the app’s endpoints to distinct functions that performed corresponding
    behavior. Next.js offers a different, perhaps simpler, routing system; it automatically
    creates the app’s routes based on the files in the *pages* directory. If a file
    in this folder exports a React component (in the case of a web page) or an async
    function (in the case of an API), it becomes a valid endpoint, as either an HTML
    page or an API.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll revisit the routes we created in our Express.js server
    and remake them using Next.js’s routing technique.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Simple Page Routes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For our Express.js server, we manually created a */hello* route in the *index.ts*
    file. When visited, it returned <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello
    World!</samp> Let’s convert this route to a page-based one in Next.js. The simplest
    kind of page route consists of a file placed directly in the *pages* directory.
    For example, the *pages/index.tsx* file, created by default, maps to *http://localhost:3000*.
    To create a simple */hello* route, make a new file, *hello.tsx*, in that directory.
    Now add to it the code from [Listing 5-1](chapter5.xhtml#Lis5-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-1: The pages/hello.tsx file'
  prefs: []
  type: TYPE_NORMAL
- en: Our Express.js server used the <samp class="SANS_TheSansMonoCd_W5Regular_11">routeHello</samp>
    function to return the <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp>
    string. Here we need to add a little more code to export a React component. First
    we import the custom type <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>
    from the Next.js module and use it to create a constant, <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello</samp>.
    We assign the constant a fat arrow function that returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>,
    which is nothing but a custom wrapper for React components. In this case, we return
    JSX that renders the <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp>
    string. Finally, we export the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>
    as the file’s default export.
  prefs: []
  type: TYPE_NORMAL
- en: Run the server and navigate to *http://localhost:3000/hello*. The page you see
    should show <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp>
    as its content.
  prefs: []
  type: TYPE_NORMAL
- en: The page looks different from the one in the sample Express.js server. That’s
    because Next.js automatically renders all global styles defined in the *_app.tsx*
    file to each page. Hence, the font looks different, even though we didn’t explicitly
    define any styles in the *hello.tsx* file.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nested Page Routes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Nested* routes, such as */components/weather* from the sample Express.js server,
    are logical subroutes of other routes. In other words, *weather* is nested inside
    the *components* entry point. You’ve probably already guessed how we create a
    nested route with Next.js’s page-routing pattern. Yes, we merely create a subfolder,
    and Next.js maps the folder structure to the URL schema.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder, *components*, inside the *pages* folder and add a new file,
    *weather.tsx*, there. [Figure 5-2](chapter5.xhtml#fig5-2) depicts the relationship
    between the URL *components/weather* and the file structure *pages/components/weather.tsx*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 5-2: The relationship
    between the URL</samp> <samp class="SANS_Futura_Std_Book_11">components/weather</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_BI_11">and the file structure</samp>
    <samp class="SANS_Futura_Std_Book_11">pages/components/weather.tsx</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Our *pages* folder is the root of the URL, and each nested folder becomes a
    URL segment. The file that exports the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>
    is the *leaf segment*, or the final part of the URL. For this file, we reuse the
    weather component code we wrote in [Chapter 4](chapter4.xhtml), shown in [Listing
    5-2](chapter5.xhtml#Lis5-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-2: The pages/components/weather.tsx file'
  prefs: []
  type: TYPE_NORMAL
- en: The only difference from the functional component created in [Chapter 4](chapter4.xhtml)
    is that we wrap the code in a function that returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>,
    which we then export as the default export. This is consistent with the page we
    created in [Listing 5-1](chapter5.xhtml#Lis5-1) and follows Next.js’s pattern
    requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Visit the new page at *http://localhost:3000/components/weather* in the browser.
    It should look similar to [Figure 5-3](chapter5.xhtml#fig5-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 5-3: The</samp> <samp
    class="SANS_Futura_Std_Book_11">pages/components/weather.tsx</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">file
    is rendered at the</samp> <samp class="SANS_Futura_Std_Book_11">/components/weather</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_BI_11">URL in the browser.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You should recognize the click-handler functionality you saw in [Chapter 4](chapter4.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">API Routes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to a user-friendly interface, a full-stack application might also
    need a machine-readable interface. For example, the Food Finder application you’ll
    create in [Part II](part2.xhtml) will provide an API to external services so that
    a mobile app or a third-party widget can display our wish list. As JavaScript-driven
    full-stack developers, the most common API formats we’ll use are GraphQL and REST,
    and we talk about these in depth in [Chapter 6](chapter6.xhtml). Here we will
    create REST APIs, which we like for their simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: With Next.js, we can design and create APIs via the same patterns we use for
    pages. Each file in the *pages/api/* folder is a single API endpoint, and we can
    define nested API routes in the same way we define nested page routes. However,
    unlike page routes, API routes are not React components. Instead, they are async
    functions that take two parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">NextApiRequest</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NextApiResponse</samp>, and
    return a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextApiResponse</samp>
    and JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: There are two caveats you need to remember when it comes to API routes. First,
    they do not specify a *Cross-Origin Resource Sharing (CORS)* header by default.
    This set of HTTP headers, most notably the <samp class="SANS_TheSansMonoCd_W5Regular_11">Access
    -Control-Allow-Origin</samp> header, lets a server define the origins from which
    client-side scripts can request resources. If you want client-side scripts running
    in websites on third-party domains to access your API endpoints, you’ll need to
    add additional middleware to enable CORS directly in the Next.js server. Otherwise,
    external requests will prompt a CORS error. This isn’t specific to Next.js; Express.js
    and most other server frameworks require you to do the same.
  prefs: []
  type: TYPE_NORMAL
- en: The second caveat is that static exports done by running <samp class="SANS_TheSansMonoCd_W5Regular_11">next
    export</samp> do not support API routes. They rely on the built-in Next.js server
    and cannot run as static files.
  prefs: []
  type: TYPE_NORMAL
- en: We used one API route, *api/names*, in the Express.js server. Now let’s refactor
    the code and convert it to a Next.js API route. As before, create a new file,
    *names.ts*, and place it in the *api* folder. Because API routes return an async
    function instead of JSX, we use the *.ts* extension, not the *.tsx* extension
    used for JSX code. Paste the code from [Listing 5-3](chapter5.xhtml#Lis5-3) into
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-3: The pages/api/names.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: First we import the custom types for the API request and response from the Next.js
    package. Then we define the custom type for the API response. In [Chapter 3](chapter3.xhtml),
    we created the same type for typing the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    call in the *routes.ts* file. We’re using the same code and <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    call here, so we’ve reused the type as well. We then create and directly export
    the API handler function mentioned earlier. You learned in [Chapter 2](chapter2.xhtml)
    that async functions need to return a promise as their return type. Therefore,
    we wrap this API response in a promise.
  prefs: []
  type: TYPE_NORMAL
- en: The code in the function’s body is similar to the code in the <samp class="SANS_TheSansMonoCd_W5Regular_11">routeAPINames</samp>
    function from [Chapter 4](chapter4.xhtml). It makes an API request to fetch the
    user data, converts the received data into the desired return format, and finally
    returns the data. However, we need to make a few modifications. First, instead
    of returning an error string, we return an API response with no content and a
    generic status code of *500*, for an *Internal Server Error*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second adjustment involves the data mapping. Previously, we returned a
    string that rendered in the browser. Now, instead of this string, we return a
    JSON object. Therefore, we modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>
    function to create an array of objects. Finally, we change the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement to return the API response with the <samp class="SANS_TheSansMonoCd_W5Regular_11">names</samp>
    object as JSON and a status code of *200: OK*.'
  prefs: []
  type: TYPE_NORMAL
- en: Now open the new API route in the browser at *http://localhost:3000/api/names*.
    You should see the API response shown in [Figure 5-4](chapter5.xhtml#fig5-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 5-4: The</samp> <samp
    class="SANS_Futura_Std_Book_11">pages/api/names.ts</samp> <samp class="SANS_Futura_Std_Book_Oblique_BI_11">file
    rendered from</samp> <samp class="SANS_Futura_Std_Book_11">/api/names</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_BI_11">in the browser</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dynamic URLs</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You now know how to create page and API routes, which are the foundation of
    any full-stack application. However, you might be wondering how to create *dynamic*
    URLs, which change based on input. We often use dynamic URLs for profile pages,
    where the user’s name becomes part of the URL. In fact, we implemented a dynamic
    URL in the Express.js server’s weather API when we defined the route */api/weather/:zipcode*
    in the *index.ts* file. There, *zipcode* was a dynamic parameter, or a dynamic
    leaf segment, whose value was provided by the <samp class="SANS_TheSansMonoCd_W5Regular_11">req.params.zipcode</samp>
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Next.js uses a slightly different pattern for dynamic URLs. Because it creates
    the routes based on folders and files, we need to define dynamic segments through
    their filenames by wrapping the variable portion in square brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">[]</samp>).
    The dynamic route */api/weather/:zipcode* from the Express.js server would thus
    translate to the file */api/weather/[zipcode].ts*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a dynamic route in our sample Next.js application that mimics the
    */api/weather/:zipcode* route from the Express.js server. Make a new folder, *weather*,
    in the *api* folder, and place a file named *[zipcode].ts* in it. Then paste the
    code from [Listing 5-4](chapter5.xhtml#Lis5-4) into the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-4: The api/weather/[zipcode].ts file'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code should be familiar to you, as it follows the basic outline of an
    API route in Next.js. We import the necessary types, then define a custom type,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherDetailType</samp>, and use
    it as the type for the data returned by the function. (By the way, this is the
    same type definition we created in [Chapter 3](chapter3.xhtml).) In the function’s
    body, we return the response with a status code of *200: OK* and a JSON object.
    We fill the <samp class="SANS_TheSansMonoCd_W5Regular_11">zipcode</samp> property
    with the ZIP code from the dynamic URL parameter, retrieved with <samp class="SANS_TheSansMonoCd_W5Regular_11">req.query
    .zipcode</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: When you run the server, the browser should show the JSON response with the
    dynamic URL parameter in the response type. If you navigate to *http://localhost:3000/api/weather/12345*,
    you should see the API response. If you change the “12345” part of the URL and
    request the data again, the response data should change accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the dynamic route */api/weather/[zipcode].ts* matches */api/weather/12345*
    and */api/weather/54321* but not sub-paths of those routes, such as */api/weather/location/12345*
    or */api/weather/location/54321*. For this, you’ll need to use a *catch all* API
    route, which includes all paths that are inside the current path. You can create
    a catch all route by adding three dots (<samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>)
    in front of the filename. For example, the catch all route */api/weather/[...zipcode].ts*
    could handle all four API endpoints mentioned in this paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Styling the Application</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add styles to our Next.js application, we create regular CSS files, written
    without the vendor prefixes used in other frameworks. Later, Next.js’s postprocessor
    will add necessary properties to generate backward-compatible styles. While CSS
    syntax is beyond the scope of this book, this section describes how to use Next.js’s
    two kinds of CSS styles: global styles and locally scoped component styles, defined
    in CSS modules.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Global Styles</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Global styles affect all pages of an app. We stumbled across this behavior when
    we rendered the *hello.tsx* file; the page used CSS even though we hadn’t added
    any style information ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Practically speaking, global styles are just regular CSS files. They aren’t
    modified during the build, and their class names are guaranteed to stay the same.
    Therefore, we can use them as regular CSS classes across the application. We import
    these CSS files in the app’s entry point, the *pages/_app.tsx* file. Take a look
    at those in the boilerplate project. You should see a line of code similar to
    [Listing 5-5](chapter5.xhtml#Lis5-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-5: Importing global styles in the _app.tsx file'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can adjust the filename and location of the imported styles or
    import multiple files. Try playing around by adding a few styles in the *global.css*
    file and some regular CSS classes to the HTML elements in the *hello.tsx* file.
    Then visit the page at *htttp://localhost:3000/hello* to see how it changed.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Component Styles</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Chapter 4](chapter4.xhtml), you saw that React lets us create user interfaces
    out of independent, reusable components. Global styles aren’t the best approach
    for styling independent components, as they require us to keep track of the names
    we’ve already used in various components, and if we import components from a previous
    project, we risk having the CSS classes collide with one another.
  prefs: []
  type: TYPE_NORMAL
- en: We need the CSS classes to be scoped to individual modules to work efficiently
    with modularized components. There are multiple architectural patterns for implementing
    this. For example, using the Block Element Modifier methodology, you can manually
    scope the styles to a component or a user interface block.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we don’t need to bother with such a clumsy solution. Next.js lets us
    use CSS modules that are scoped during the build process. These CSS modules follow
    the naming convention <*component*>.*module.css*. The compiler automatically prefixes
    each CSS class name inside the module with the component’s name and a unique identifier.
    This enables you to use the same style names for multiple components without issue.
  prefs: []
  type: TYPE_NORMAL
- en: The actual CSS you write won’t have these prefixes. For example, look at the
    *Home.module.css* file inside the *styles* folder, shown in [Listing 5-6](chapter5.xhtml#Lis5-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-6: Regular CSS code in styles/Home.module.css'
  prefs: []
  type: TYPE_NORMAL
- en: One problem is that, because the build process modifies the class names and
    prefixes them, we can’t directly use these styles in our other files. Instead,
    we must import the styles and treat them like a JavaScript object. Then we can
    refer to them as a property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">styles</samp>
    object. For example, the *pages/index.tsx* file in [Listing 5-7](chapter5.xhtml#Lis5-7)
    uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">container</samp> class
    from [Listing 5-6](chapter5.xhtml#Lis5-6), providing an example of how to use
    scoped styles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-7: Using styles from the CSS module styles/Home.module.css in the
    index.tsx file'
  prefs: []
  type: TYPE_NORMAL
- en: This code imports the CSS file into a constant called <samp class="SANS_TheSansMonoCd_W5Regular_11">styles</samp>.
    Now all the CSS class names will be available as properties of the <samp class="SANS_TheSansMonoCd_W5Regular_11">styles</samp>
    object. In JSX, we use variables wrapped in curly brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>),
    so we add a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">container</samp>
    class as <samp class="SANS_TheSansMonoCd_W5Regular_11">{styles.container}</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: You can now build APIs and custom-styled pages out of React components. The
    next section introduces useful custom components that Next.js provides to enhance
    your full-stack application.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Built-in Next.js Components</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next.js provides a set of custom components. Each of these addresses one specific
    use case: for example, accessing internal page properties such as the page title
    or SEO metadata (<samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp>),
    improving the app’s overall rendering performance and user experience (<samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp>),
    or enabling the application’s routing (<samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp>).
    We’ll use the Next.js components covered in this chapter in the full-stack application
    in [Part II](part2.xhtml), where you can see them applied in practice. For additional
    attributes and niche use cases, refer to the Next.js documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The next/head Component</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp> component
    exports a custom Next.js-specific <samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp>
    component. We use it to set a page’s HTML title and meta elements, which are found
    inside an HTML <samp class="SANS_TheSansMonoCd_W5Regular_11">head</samp> component.
    To improve SEO ranking and enhance usability, each page should have its own metadata.
    [Listing 5-8](chapter5.xhtml#Lis5-8) shows an example of the *hello.tsx* page
    from [Listing 5-1](chapter5.xhtml#Lis5-1) with a customized title and meta element.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp>
    elements are not merged across pages. Next.js’s client-side routing removes the
    content of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp> element
    during the page transition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-8: The pages/hello.tsx file with a customized title and meta element'
  prefs: []
  type: TYPE_NORMAL
- en: We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp> element
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/head</samp> component
    and add it to the returned JSX element, placing it above the existing content
    and wrapping both in another <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>
    element because we need to return one element instead of two.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The next/link Component</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp> component
    exports a <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> component.
    This component is built on top of the React <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp>
    element. We use it instead of an HTML anchor tag when we want to link to another
    page in the application, enabling client-side transitions between pages. When
    clicked, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> component
    updates the browser DOM with the new DOM, scrolls to the top of the new page,
    and adjusts the browser history. Furthermore, it provides built-in performance
    optimizations, prefetching the linked page and its data as soon as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp>
    component enters the *viewport* (the currently visible part of the website). This
    background prefetch enables smooth page transitions. [Listing 5-9](chapter5.xhtml#Lis5-9)
    adds the Next.js <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> element
    to the page from the previous listing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-9: The pages/hello.tsx file with an external link and an internal
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">next/link</samp> element'
  prefs: []
  type: TYPE_NORMAL
- en: We import the component, then add it to the returned JSX element. For comparison
    purposes, we use a regular HTML anchor to link to the No Starch Press home page
    and the custom <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> to connect
    to the weather component page in our Next.js application. In the app, try clicking
    both links to see the difference.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The next/image Component</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp> component
    exports an <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp> component
    used to display images. This component is built on top of the native HTML <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><img></samp> element. It handles common
    layout requirements, such as filling all available space and scaling images. The
    component can load modern image formats, such as *AVIF* and *WebP*, and serve
    the image with the correct size for the client’s screen. Furthermore, you have
    the option to use blurred placeholder images and lazy-load the actual image as
    soon as it enters the viewport; this enforces the visual stability of your website
    by preventing *cumulative layout shifts*, which occur when an image renders after
    the page, causing the page content to shift down. Cumulative layout shifts are
    considered a bad user experience, and they can make the user lose their focus.
    [Listing 5-10](chapter5.xhtml#Lis5-10) provides a basic example of the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/image</samp>
    component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-10: The pages/hello.tsx file using the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">next/image</samp>
    element'
  prefs: []
  type: TYPE_NORMAL
- en: Here we display the Vercel logo from our application’s *public* folder. First
    we import the component from the *next/image* package. Then we add it to the page
    content. The syntax and the properties of our minimal example are similar to the
    HTML <samp class="SANS_TheSansMonoCd_W5Regular_11">img</samp> element. You can
    read more about the component’s advanced properties in the official documentation
    at [*https://<wbr>nextjs<wbr>.org<wbr>/docs<wbr>/api<wbr>-reference<wbr>/next<wbr>/image*](https://nextjs.org/docs/api-reference/next/image).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Pre-rendering and Publishing</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While you can start building full-stack Next.js applications with the information
    you’ve learned so far, you’ll find it useful to know one more advanced topic:
    the different ways to render and publish your application and their implications
    for its performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Next.js provides three options for pre-rendering your app with its built-in
    server. The first, *static site generation (SSG)*, generates the HTML at build
    time. Thus, each request will always return the same HTML, which remains static
    and is never re-created. The second option, *server-side rendering (SSR)*, generates
    new HTML files on each request, and the third, *incremental static regeneration
    (ISR)*, combines both approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Next.js lets us choose our pre-rendering option on a per-page basis, meaning
    the full-stack application can contain pages with SSG, SSR, and ISR, as well as
    client-side rendering for some React components. You can also create a complete
    static export of your site by running <samp class="SANS_TheSansMonoCd_W5Regular_11">next
    export</samp>. The exported application will run independently on all infrastructures,
    as it doesn’t need the built-in Next.js server.
  prefs: []
  type: TYPE_NORMAL
- en: To gain experience with these rendering approaches, we’ll create a new page
    that displays the data from our names API for each rendering option. Create a
    new folder, *utils*, next to the *pages* folder and add an empty file, *fetch-names.ts*,
    to it. Then add the code in [Listing 5-11](chapter5.xhtml#Lis5-11). This utility
    function calls the remote API and returns the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-11: The async utility in utils/fetch-names.ts'
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining a custom type, we create a function and directly export it.
    This function contains the code from the previously created *names.ts* file, with
    two adjustments: first we need to define the data array as possibly empty; next,
    we return an empty array instead of an error string if the API call fails. This
    change means that we don’t need to verify the type before iterating over the array
    when we generate the JSX string.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Server-Side Rendering</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using SSR, Next.js’s built-in Node.js server creates an application’s HTML in
    response to each request. You should use this technique if your page depends on
    fresh data from an external API. Unfortunately, SSR is slower in production, because
    the pages aren’t easily cacheable.
  prefs: []
  type: TYPE_NORMAL
- en: To use SSR for a page, export an additional async function, <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>,
    from that page. Next.js calls this function on every request and passes the fetched
    data to the page’s <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    argument to pre-render it before sending it to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Try this out by creating a new file, *names-ssr.tsx*, in the *pages* folder.
    Paste the code from [Listing 5-12](chapter5.xhtml#Lis5-12) into the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-12: A basic page that displays data with SSR, page/names-ssr.tsx'
  prefs: []
  type: TYPE_NORMAL
- en: To use Next.js’s SSR, we export the additional async function, <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>.
    We also import necessary functionality from the *next* and *querystring* packages
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetchNames</samp> function
    we created earlier. Then we define the custom type for the response to the API
    request. It’s the same custom type we used in [Chapter 3](chapter3.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create the page and store the export as the default one. The page returns
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp> and takes the
    default properties for this page type. We iterate over the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    parameter’s <samp class="SANS_TheSansMonoCd_W5Regular_11">names</samp> array and
    create a JSX string that we render and return to the browser. Then we define the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp> function,
    which gets the data from the API. We return the created dataset from the async
    function and pass it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextPage</samp>
    inside the page properties.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the new page at *http://localhost:3000/names-ssr*. You should see
    the list of the usernames.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static Site Generation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SSG creates the HTML files only once and reuses them for every request. It is
    the recommended option, because pre-rendered pages are easy to cache and fast
    to deliver. For example, a content delivery network can easily pick up your static
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, SSG applications have a lower *time to first paint*, or the time it
    takes after a user requests the page (by, for example, clicking a link) until
    the content appears in the browser. SSG also reduces *blocking time*, or the time
    it takes until the user can actually interact with the page’s content. Good scores
    in these metrics indicate a responsive website, and they are part of Google’s
    scoring algorithm. Hence, these pages have increased SEO rankings.
  prefs: []
  type: TYPE_NORMAL
- en: If your page relies on external data, you can still use SSG by exporting an
    additional async function, <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp>,
    from the page’s file. Next.js calls this function at build time, passes the fetched
    data to the page’s <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    argument, and pre-renders the page with SSG. Of course, this works only if the
    external data isn’t dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Try creating the same page as in the SSR example, this time with SSG. Add a
    new file, *names-ssg.tsx*, in the *pages* folder and then paste in the code shown
    in [Listing 5-13](chapter5.xhtml#Lis5-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-13: A page that displays data with SSG, page/names-ssg.tsx'
  prefs: []
  type: TYPE_NORMAL
- en: The code is mostly identical to [Listing 5-9](chapter5.xhtml#Lis5-9). We just
    need to change the SSR-specific code to use SSG. Therefore, we export <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>
    and adjust the types accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: When you visit the page, it should look similar to the SSR page. But instead
    of requesting fresh data on each visit to *http://localhost:3000/names-ssg*, the
    data is requested only once, on page build.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Incremental Static
    Regeneration</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: ISR is a hybrid of SSG and SSR that runs purely on the server side. It generates
    the HTML on the server during the initial build and sends this pre-generated HTML
    the first time a page is requested. After a specified time has passed, Next.js
    will fetch the data and regenerate the page on the server in the background. In
    the process, it invalidates the internal server cache and updates it with the
    new page. Every subsequent request will receive the up-to-date page. Like SSG,
    ISR is less costly than SSR and increases a page’s SEO ranking.
  prefs: []
  type: TYPE_NORMAL
- en: To enable ISR in SSG pages, we need to add a property to revalidate <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProp</samp>’s
    return object. We define the validity of the data in seconds, as shown in [Listing
    5-14](chapter5.xhtml#Lis5-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-14: Changing <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">getServerSideProps</samp>
    to enable ISR'
  prefs: []
  type: TYPE_NORMAL
- en: We add the <samp class="SANS_TheSansMonoCd_W5Regular_11">revalidate</samp> property
    with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">30</samp>. As a
    result, the custom Next.js server will invalidate the current HTML 30 seconds
    after the first page request.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Client-Side Rendering</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A completely different approach, *client-side rendering* involves first generating
    the HTML with SSR or SSG and sending it to the client. The client then fetches
    additional data at runtime and renders it in the browser DOM. Client-side rendering
    is a good choice when working with highly flexible, constantly changing datasets,
    such as real-time stock market or currency prices. Other sites use it to send
    a skeleton version of the page to the client and later enhance it with more content.
    However, client-side rendering lowers your SEO performance, as its data can’t
    be indexed.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-15](chapter5.xhtml#Lis5-15) shows the page we created earlier, configured
    for client-side rendering. Create a new file, *names-csr.tsx*, in the *pages*
    folder and then add the code to it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-15: The client-side rendered page, page/names-csr.tsx'
  prefs: []
  type: TYPE_NORMAL
- en: This code differs significantly from the previous examples. Here we import the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hooks. The latter one will fetch the data after the page is already available.
    As soon as the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetchNames</samp>
    function returns the data, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp>
    hook and the reactive <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    state variable to update the browser DOM.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot declare the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hook as an async function, because it returns either an undefined value or a function,
    whereas an async function returns a promise, and therefore TSC would throw an
    error. To avoid this, we need to wrap the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    call in an async function, <samp class="SANS_TheSansMonoCd_W5Regular_11">fetchData</samp>,
    and then call that function.
  prefs: []
  type: TYPE_NORMAL
- en: The page configured for client-side rendering should look similar to the other
    versions. But when you visit *http://localhost:3000/names-csr*, you might see
    a white flash. This is the page waiting for the asynchronous API request.
  prefs: []
  type: TYPE_NORMAL
- en: To get a better feel for the different rendering types, modify the code for
    each example in this section to use the API *[https://www.usemodernfullstack.dev/api/v1/now](https://www.usemodernfullstack.dev/api/v1/now)*,
    which returns an object with the timestamp of the request.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static HTML Exporting</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">next export</samp> command
    generates a static HTML version of your web application. This version is independent
    of the built-in Node.js-based Next.js web server and can run on any infrastructure,
    such as an Apache, NGINX, or IIS server.
  prefs: []
  type: TYPE_NORMAL
- en: To use this command, your page must implement <samp class="SANS_TheSansMonoCd_W5Regular_11">getStaticProps</samp>,
    as in SSG. This command won’t support the <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>
    function, ISR, or API routes.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 5: Refactor Express.js and
    React to Next.js</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s refactor the React and Express.js applications from the previous chapters
    into a Next.js application that we’ll expand in the upcoming chapters. As a first
    step, we’ll summarize the functionality we need to build. Our application has
    an API route, *api/names*, that returns usernames, and another API route, *api/weather/:zipcode*,
    that returns a static JSON object and the URL parameter. We used it to understand
    dynamic URLs. In addition, we created pages at */hello* and *component/weather*.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ve already refactored these various elements to
    work with Next.js’s routing style. In this exercise, we’ll put it all together.
    Follow the steps in “Setting Up Next.js” on page 70 to initialize the Next.js
    application. Within the *sample-next* folder, name your application *refactored-app*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Storing Custom Interfaces
    and Types</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We create a new file, *custom.d.ts*, in the root of the project to store our
    custom interface and type definitions ([Listing 5-16](chapter5.xhtml#Lis5-16)).
    It is similar to the one we used in [Chapters 3](chapter3.xhtml) and [4](chapter4.xhtml).
    The main difference is that we add custom types for the Next.js application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-16: The custom.d.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the custom interface <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherProps</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> argument of
    the page that displays the weather components, *components/weather*. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WeatherDetailType</samp> is for the API
    route *api/weather/:zipcode*, which uses a dynamically fetched ZIP code. Finally,
    we use <samp class="SANS_TheSansMonoCd_W5Regular_11">responseItemType</samp> in
    the API route *api/names* to type the fetch response.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the API
    Routes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we re-create the two API routes from the Express.js server. Earlier sections
    of this chapter showed this refactored code. For the *api/names* route, create
    a new file, *names.ts*, in the *api* folder, then add the code from [Listing 5-3](chapter5.xhtml#Lis5-3).
    Refer to that section for a detailed explanation of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Migrate the dynamic route *api/weather/:zipcode* from the Express.js server
    to the Next.js application by creating a *[zipcode].js* file in the *api* folder
    and adding the code from [Listing 5-4](chapter5.xhtml#Lis5-4), shown in “Dynamic
    URLs” on page 77. You can refer to that section for more details.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Page
    Routes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we work on the pages. First, for the simple page *hello.tsx*, we create
    a new file in the *pages* folder and add the code from [Listing 5-10](chapter5.xhtml#Lis5-10).
    This code renders the <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp>
    example and uses the custom Next.js components <samp class="SANS_TheSansMonoCd_W5Regular_11">Head</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp>,
    all of which are explained in detail in “Built-in Next.js Components” on page
    80.
  prefs: []
  type: TYPE_NORMAL
- en: The second page is the nested route *pages/components/weather.tsx*. As before,
    we create a new file, *weather.tsx*, in a folder called *components*, within the
    *pages* folder. Add the code from [Listing 5-2](chapter5.xhtml#Lis5-2). This listing
    uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> hooks to create a reactive
    user interface. We can remove the custom interface definition for the <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherProps</samp>
    from this file. The *custom.d.ts* file already adds them to TSC.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Application</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Start the application with the <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    run dev</samp> command. Now you can visit the same routes we created for the Express.js
    server and see that they are functionally the same. Congratulations! You created
    your first Next.js-based full-stack application. Play around with the code and
    try using global and component CSS to style your pages.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next.js adds the missing functionality needed to create full-stack applications
    with React. After scaffolding a sample project and exploring the default file
    structure, you learned how to create page and API routes in the framework. You
    also learned about global- and component-level CSS, Next.js’s four built-in command
    line scripts, and its most useful custom components.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the different ways to render content and pages with Next.js
    and when to choose each option. Finally, you used the code from this chapter to
    quickly migrate the Express.js application you built in the previous chapters
    to Next.js. To continue your adventures in this useful framework, I recommend
    the official tutorials at [*https://<wbr>nextjs<wbr>.org*](https://nextjs.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll explore two types of web APIs: the standard RESTful
    APIs and modern GraphQL.'
  prefs: []
  type: TYPE_NORMAL
