<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_207"/><strong><span class="big">9</span></strong><br/><strong>THE ROOT CAUSES OF VULNERABILITIES</strong></h2>&#13;
<p class="noindent_first">This chapter describes the common root causes of security vulnerabilities that result from the implementation of a protocol. These causes are distinct from vulnerabilities that derive from a protocol’s specification (as discussed in <a href="../Text/ch07.xhtml#ch07">Chapter 7</a>). A vulnerability does not have to be directly exploitable for it to be considered a vulnerability. It might weaken the security stance of the protocol, making other attacks easier. Or it might allow access to more serious vulnerabilities.</p>&#13;
<p class="indent">After reading this chapter, you’ll begin to see patterns in protocols that will help you identify security vulnerabilities during your analysis. (I won’t discuss how to exploit the different classes until <a href="../Text/ch10.xhtml#ch10">Chapter 10</a>.)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_208"/>In this chapter, I’ll assume you are investigating the protocol using all means available to you, including analyzing the network traffic, reverse engineering the application’s binaries, reviewing source code, and manually testing the client and servers to determine actual vulnerabilities. Some vulnerabilities will always be easier to find using techniques such as <em>fuzzing</em> (a technique by which network protocol data is mutated to uncover issues) whereas others will be easier to find by reviewing code.</p>&#13;
<h3 class="h3" id="ch00lev1sec241"><strong>Vulnerability Classes</strong></h3>&#13;
<p class="noindent">When you’re dealing with security vulnerabilities, it’s useful to categorize them into a set of distinct classes to assess the risk posed by the exploitation of the vulnerability. As an example, consider a vulnerability that, when exploited, allows an attack to compromise the system an application is running on.</p>&#13;
<h4 class="h4" id="ch00lev1sec242"><strong><em>Remote Code Execution</em></strong></h4>&#13;
<p class="noindent"><em>Remote code execution</em> is a catchall term for any vulnerability that allows an attacker to run arbitrary code in the context of the application that implements the protocol. This could occur through hijacking the logic of the application or influencing the command line of subprocesses created during normal operation.</p>&#13;
<p class="indent">Remote code execution vulnerabilities are usually the most security critical because they allow an attacker to compromise the system on which the application is executing. Such a compromise would provide the attacker with access to anything the application can access and might even allow the hosting network to be compromised.</p>&#13;
<h4 class="h4" id="ch00lev1sec243"><strong><em>Denial-of-Service</em></strong></h4>&#13;
<p class="noindent">Applications are generally designed to provide a service. If a vulnerability exists that when exploited causes an application to crash or become unresponsive, an attacker can use that vulnerability to deny legitimate users access to a particular application and the service it provides. Commonly referred to as a <em>denial-of-service</em> vulnerability, it requires few resources, sometimes as little as a single network packet, to bring down the entire application. Without a doubt, this can be quite detrimental in the wrong hands.</p>&#13;
<p class="indent">We can categorize denial-of-service vulnerabilities as either <em>persistent</em> or <em>nonpersistent</em>. A persistent vulnerability permanently prevents legitimate users from accessing the service (at least until an administrator corrects the issue). The reason is that exploiting the vulnerability corrupts some stored state that ensures the application crashes when it’s restarted. A nonpersistent vulnerability lasts only as long as an attacker is sending data to cause the denial-of-service condition. Usually, if the application is allowed to restart on its own or given sufficient time, service will be restored.</p>&#13;
<h4 class="h4" id="ch00lev1sec244"><span epub:type="pagebreak" id="page_209"/><strong><em>Information Disclosure</em></strong></h4>&#13;
<p class="noindent">Many applications are black boxes, which in normal operation provide you with only certain information over the network. An <em>information disclosure</em> vulnerability exists if there is a way to get an application to provide information it wasn’t originally designed to provide, such as the contents of memory, filesystem paths, or authentication credentials. Such information might be directly useful to an attacker because it could aid further exploitation. For example, the information could disclose the location of important in-memory structures that could help in remote code execution.</p>&#13;
<h4 class="h4" id="ch00lev1sec245"><strong><em>Authentication Bypass</em></strong></h4>&#13;
<p class="noindent">Many applications require users to supply authentication credentials to access an application completely. Valid credentials might be a username and password or a more complex verification, like a cryptographically secure exchange. Authentication limits access to resources, but it can also reduce an application’s attack surface when an attacker is unauthenticated.</p>&#13;
<p class="indent">An <em>authentication bypass</em> vulnerability exists in an application if there is a way to authenticate to the application without providing all the authentication credentials. Such vulnerabilities might be as simple as an application incorrectly checking a password—for example, because it compares a simple checksum of the password, which is easy to brute force. Or vulnerabilities could be due to more complex issues, such as SQL injection (discussed later in “<a href="../Text/ch09.xhtml#ch00lev1sec268">SQL Injection</a>” on <a href="../Text/ch09.xhtml#page_228">page 228</a>).</p>&#13;
<h4 class="h4" id="ch00lev1sec246"><strong><em>Authorization Bypass</em></strong></h4>&#13;
<p class="noindent">Not all users are created equal. Applications may support different types of users, such as read-only, low-privilege, or administrator, through the same interface. If an application provides access to resources like files, it might need to restrict access based on authentication. To allow access to secured resources, an authorization process must be built in to determine which rights and resources have been assigned to a user.</p>&#13;
<p class="indent">An <em>authorization bypass</em> vulnerability occurs when an attacker can gain extra rights or access to resources they are not privileged to access. For example, an attacker might change the authenticated user or user privileges directly, or a protocol might not correctly check user permissions.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Don’t confuse authorization bypass with authentication bypass vulnerabilities. The major difference between the two is that an authentication bypass allows you to authenticate as a specific user from the system’s point of view; an authorization bypass allows an attacker to access a resource from an incorrect authentication state (which might in fact be unauthenticated).</em></p>&#13;
</div>&#13;
<p class="indent">Having defined the vulnerability classes, let’s look at their causes in more detail and explore some of the protocol structures in which you’ll find them. <span epub:type="pagebreak" id="page_210"/>Each type of root cause contains a list of the possible vulnerability classes that it might lead to. Although this is not an exhaustive list, I cover those you are most likely to encounter regularly.</p>&#13;
<h3 class="h3" id="ch00lev1sec247"><strong>Memory Corruption Vulnerabilities</strong></h3>&#13;
<p class="noindent">If you’ve done any analysis, memory corruption is most likely the primary security vulnerability you’ll have encountered. Applications store their current state in memory, and if that memory can be corrupted in a controlled way, the result can cause any class of security vulnerability. Such vulnerabilities can simply cause an application to crash (resulting in a denial-of-service condition) or be more dangerous, such as allowing an attacker to run executable code on the target system.</p>&#13;
<h4 class="h4" id="ch00lev1sec248"><strong><em>Memory-Safe vs. Memory-Unsafe Programming Languages</em></strong></h4>&#13;
<p class="noindent">Memory corruption vulnerabilities are heavily dependent on the programming language the application was developed in. When it comes to memory corruption, the biggest difference between languages is tied to whether a language (and its hosting environment) is <em>memory safe</em> or <em>memory unsafe</em>. Memory-safe languages, such as Java, C#, Python, and Ruby, do not normally require the developer to deal with low-level memory management. They sometimes provide libraries or constructs to perform unsafe operations (such as C#’s <code>unsafe</code> keyword). But using these libraries or constructs requires developers to make their use explicit, which allows that use to be audited for safety. Memory-safe languages will also commonly perform bounds checking for in-memory buffer access to prevent out-of-bounds reads and writes. Just because a language is memory safe doesn’t mean it’s completely immune to memory corruption. However, corruption is more likely to be a bug in the language runtime than a mistake by the original developer.</p>&#13;
<p class="indent">On the other hand, memory-unsafe languages, such as C and C++, perform very little memory access verification and lack robust mechanisms for automatically managing memory. As a result, many types of memory corruption can occur. How exploitable these vulnerabilities are depends on the operating system, the compiler used, and how the application is structured.</p>&#13;
<p class="indent">Memory corruption is one of the oldest and best known root causes of vulnerabilities; therefore, considerable effort has been made to eliminate it. (I’ll discuss some of the mitigation strategies in more depth in <a href="../Text/ch10.xhtml#ch10">Chapter 10</a> when I detail how you might exploit these vulnerabilities.)</p>&#13;
<h4 class="h4" id="ch00lev1sec249"><strong><em>Memory Buffer Overflows</em></strong></h4>&#13;
<p class="noindent">Perhaps the best known memory corruption vulnerability is a <em>buffer overflow</em>. This vulnerability occurs when an application tries to put more data into a region of memory than that region was designed to hold. Buffer overflows <span epub:type="pagebreak" id="page_211"/>may be exploited to get arbitrary programs to run or to bypass security restrictions, such as user access controls. <a href="../Text/ch09.xhtml#ch9fig1">Figure 9-1</a> shows a simple buffer overflow caused by input data that is too large for the allocated buffer, resulting in memory corruption.</p>&#13;
<div class="image"><img alt="image" src="../Images/f09-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch9fig1"/><em>Figure 9-1: Buffer overflow memory corruption</em></p>&#13;
<p class="indent">Buffer overflows can occur for either of two reasons: Commonly referred to as a <em>fixed-length buffer overflow</em>, an application incorrectly assumes the input buffer will fit into the allocated buffer. A <em>variable-length buffer overflow</em> occurs because the size of the allocated buffer is incorrectly calculated.</p>&#13;
<h5 class="h5" id="ch00lev1sec250"><strong>Fixed-Length Buffer Overflows</strong></h5>&#13;
<p class="noindent">By far, the simplest buffer overflow occurs when an application incorrectly checks the length of an external data value relative to a fixed-length buffer in memory. That buffer might reside on the stack, be allocated on a heap, or exist as a global buffer defined at compile time. The key is that the memory length is determined prior to knowledge of the actual data length.</p>&#13;
<p class="indent">The cause of the overflow depends on the application, but it can be as simple as the application not checking length at all or checking length incorrectly. <a href="../Text/ch09.xhtml#ch9list1">Listing 9-1</a> is an example.</p>&#13;
<pre> def read_string()<br/> {<br/><span class="ent">➊</span> byte str[32];<br/>  int i  = 0;<br/><br/>  do<br/>  {<br/>  <span class="ent">➋</span> str[i] = read_byte();<br/>     i = i + 1;<br/>  }<br/><span class="ent">➌</span> while(str[i-1] != 0);<br/>  printf("Read String: %s\n", str);<br/>}</pre>&#13;
<p class="listing"><a id="ch9list1"/><em>Listing 9-1: A simple fixed-length buffer overflow</em></p>&#13;
<p class="indent">This code first allocates the buffer where it will store the string (on the stack) and allocates 32 bytes of data <span class="ent">➊</span>. Next, it goes into a loop that reads a <span epub:type="pagebreak" id="page_212"/>byte from the network and stores it an incrementing index in the buffer <span class="ent">➋</span>. The loop exits when the last byte read from the network is equal to zero, which indicates that the value has been sent <span class="ent">➌</span>.</p>&#13;
<p class="indent">In this case, the developer has made a mistake: the loop doesn’t verify the current length at <span class="ent">➌</span> and therefore reads as much data as available from the network, leading to memory corruption. Of course, this problem is due to the fact that unsafe programming languages do not perform bounds checks on arrays. This vulnerability might be very simple to exploit if no compiler mitigations are in place, such as stack cookies to detect the corruption.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart" id="ch00sbsec1"><strong>UNSAFE STRING FUNCTIONS</strong></p>&#13;
<p class="noindent">The C programming language does not define a string type. Instead, it uses memory pointers to a list of <em>char</em> types. The end of the string is indicated by a zero-value character. This isn’t a security problem directly. However, when the built-in libraries to manipulate strings were developed, safety was not considered. Consequently, many of these string functions are very dangerous to use in a security-critical application.</p>&#13;
<p class="indent">To understand how dangerous these functions can be, let’s look at an example using <code>strcpy</code>, the function that copies strings. This function takes only two arguments: a pointer to the source string and a pointer to the destination memory buffer to store the copy. Notice that nothing indicates the length of the destination memory buffer. And as you’ve already seen, a memory-unsafe language like C doesn’t keep track of buffer sizes. If a programmer tries to copy a string that is longer than the destination buffer, especially if it’s from an external untrusted source, memory corruption will occur.</p>&#13;
<p class="indent">More recent C compilers and standardizations of the language have added more secure versions of these functions, such as <code>strcpy_s</code>, which adds a destination length argument. But if an application uses an older string function, such as <code>strcpy</code>, <code>strcat</code>, or <code>sprintf</code>, then there’s a good chance of a serious memory corruption vulnerability.</p>&#13;
</div>&#13;
<p class="indent">Even if a developer performs a length check, that check may not be done correctly. Without automatic bounds checking on array access, it is up to the developer to verify all reads and writes. <a href="../Text/ch09.xhtml#ch9list2">Listing 9-2</a> shows a corrected version of <a href="../Text/ch09.xhtml#ch9list1">Listing 9-1</a> that takes into account strings that are longer than the buffer size. Still, even with the fix, a vulnerability is lurking in the code.</p>&#13;
<pre> def read_string_fixed()<br/> {<br/><span class="ent">➊</span> byte str[32];<br/>  int i = 0;<br/><span epub:type="pagebreak" id="page_213"/><br/>  do<br/>  {<br/>  <span class="ent">➋</span> str[i] = read_byte();<br/>     i = i + 1;<br/>  }<br/><span class="ent">➌</span> while((str[i-1] != 0) &amp;&amp; (i &lt; 32));<br/><br/>  /* Ensure zero terminated if we ended because of length */<br/><span class="ent">➍</span> str[i] = 0;<br/><br/>  printf("Read String: %s\n", str);<br/>}</pre>&#13;
<p class="listing"><a id="ch9list2"/><em>Listing 9-2: An off-by-one buffer overflow</em></p>&#13;
<p class="indent">As in <a href="../Text/ch09.xhtml#ch9list1">Listing 9-1</a>, at <span class="ent">➊</span> and <span class="ent">➋</span>, the code allocates a fixed-stack buffer and reads the string in a loop. The first difference is at <span class="ent">➌</span>. The developer has added a check to make sure to exit the loop if it has already read 32 bytes, the maximum the stack buffer can hold. Unfortunately, to ensure that the string buffer is suitably terminated, a zero byte is written to the last position available in the buffer <span class="ent">➍</span>. At this point, <code>i</code> has the value of 32. But because languages like C start buffer indexing from 0, this actually means it will write 0 to the 33rd element of the buffer, thereby causing corruption, as shown in <a href="../Text/ch09.xhtml#ch9fig2">Figure 9-2</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f09-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch9fig2"/><em>Figure 9-2: An off-by-one error memory corruption</em></p>&#13;
<p class="indent">This results in an <em>off-by-one</em> error (due to the shift in index position), a common error in memory-unsafe languages with zero-based buffer indexing. If the overwritten value is important—for example, if it is the return address for the function—this vulnerability can be exploitable.</p>&#13;
<h5 class="h5" id="ch00lev1sec251"><strong>Variable-Length Buffer Overflows</strong></h5>&#13;
<p class="noindent">An application doesn’t have to use fixed-length buffers to stored protocol data. In most situations, it’s possible for the application to allocate a buffer of the correct size for the data being stored. However, if the application incorrectly calculates the buffer size, a variable-length buffer overflow can occur.</p>&#13;
<p class="indent">As the length of the buffer is calculated at runtime based on the length of the protocol data, you might think a variable-length buffer overflow is unlikely to be a real-world vulnerability. But this vulnerability can still occur <span epub:type="pagebreak" id="page_214"/>in a number of ways. For one, an application might simply incorrectly calculate the buffer length. (Applications should be rigorously tested prior to being made generally available, but that’s not always the case.)</p>&#13;
<p class="indent">A bigger issue occurs if the calculation induces undefined behavior by the language or platform. For example, <a href="../Text/ch09.xhtml#ch9list3">Listing 9-3</a> demonstrates a common way in which the length calculation is incorrect.</p>&#13;
<pre>   def read_uint32_array()<br/>   {<br/>     uint32 len;<br/>     uint32[] buf;<br/><br/>     // Read the number of words from the network<br/><span class="ent">➊</span>   len = read_uint32();<br/><br/>     // Allocate memory buffer<br/><span class="ent">➋</span>   buf = malloc(len * sizeof(uint32));<br/><br/>     // Read values<br/>     for(uint32 i = 0; i &lt; len; ++i)<br/>     {<br/><span class="ent">➌</span>     buf[i] = read_uint32();<br/>     }<br/>     printf("Read in %d uint32 values\n", len);<br/>   }</pre>&#13;
<p class="listing"><a id="ch9list3"/><em>Listing 9-3: An incorrect allocation length calculation</em></p>&#13;
<p class="indent">Here the memory buffer is dynamically allocated at runtime to contain the total size of the input data from the protocol. First, the code reads a 32-bit integer, which it uses to determine the number of following 32-bit values in the protocol <span class="ent">➊</span>. Next, it determines the total allocation size and then allocates a buffer of a corresponding size <span class="ent">➋</span>. Finally, the code starts a loop that reads each value from the protocol into the allocated buffer <span class="ent">➌</span>.</p>&#13;
<p class="indent">What could possibly go wrong? To answer, let’s take a quick look at <em>integer overflows</em>.</p>&#13;
<h5 class="h5" id="ch00lev1sec252"><strong>Integer Overflows</strong></h5>&#13;
<p class="noindent">At the processor instruction level, integer arithmetic operations are commonly performed using <em>modulo arithmetic</em>. Modulo arithmetic allows values to wrap if they go above a certain value, which is called the <em>modulus</em>. A processor uses modulo arithmetic if it supports only a certain native integer size, such as 32 or 64 bits. This means that the result of any arithmetic operation must always be within the ranges allowed for the fixed-size integer value. For example, an 8-bit integer can take only the values between 0 and 255; it cannot possibly represent any other values. <a href="../Text/ch09.xhtml#ch9fig3">Figure 9-3</a> shows what happens when you multiply a value by 4, causing the integer to overflow.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_215"/><img alt="image" src="../Images/f09-03.jpg"/></div>&#13;
<p class="figcap"><a id="ch9fig3"/><em>Figure 9-3: A simple integer overflow</em></p>&#13;
<p class="indent">Although this figure shows 8-bit integers for the sake of brevity, the same logic applies to 32-bit integers. When we multiply the original length 0x41 or 65 by 4, the result is 0x104 or 260. That result can’t possibly fit into an 8-bit integer with a range of 0 to 255. So the processor drops the overflowed bit (or more likely stores it in a special flag indicating that an overflow has occurred), and the result is the value 4—not what we expected. The processor might issue an error to indicate that an overflow has occurred, but memory-unsafe programming languages typically ignore this sort of error. In fact, the act of wrapping the integer value is used in architectures such as x86 to indicate the signed result of an operation. Higher-level languages might indicate the error, or they might not support integer overflow at all, for instance, by extending the size of the integer on demand.</p>&#13;
<p class="indent">Returning to <a href="../Text/ch09.xhtml#ch9list3">Listing 9-3</a>, you can see that if an attacker supplies a suitably chosen value for the buffer length, the multiplication by 4 will overflow. This results in a smaller number being allocated to memory than is being transmitted over the network. When the values are being read from the network and inserted into the allocated buffer, the parser uses the original length. Because the original length of the data doesn’t match up to the size of the allocation, values will be written outside of the buffer, causing memory corruption.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart" id="ch00sbsec2"><strong>WHAT HAPPENS IF WE ALLOCATE ZERO BYTES?</strong></p>&#13;
<p class="noindent">Consider what happens when we calculate an allocation length of zero bytes. Would the allocation simply fail because you can’t allocate a zero-length buffer? As with many issues in languages like C, it is up to the implementation to determine what occurs (the dreaded implementation-defined behavior). In the case of the C allocator function, <code>malloc</code>, passing zero as the requested size can return a failure, or it can return a buffer of indeterminate size, which hardly instills confidence.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec253"><span epub:type="pagebreak" id="page_216"/><strong><em>Out-of-Bounds Buffer Indexing</em></strong></h4>&#13;
<p class="noindent">You’ve already seen that memory-unsafe languages do not perform bounds checks. But sometimes a vulnerability occurs because the size of the buffer is incorrect, leading to memory corruption. Out-of-bounds indexing stems from a different root cause: instead of incorrectly specifying the size of a data value, we’ll have some control over the position in the buffer we’ll access. If incorrect bounds checking is done on the access position, a vulnerability exists. The vulnerability can in many cases be exploited to write data outside the buffer, leading to selective memory corruption. Or it can be exploited by reading a value outside the buffer, which could lead to information disclosure or even remote code execution. <a href="../Text/ch09.xhtml#ch9list4">Listing 9-4</a> shows an example that exploits the first case—writing data outside the buffer.</p>&#13;
<pre><span class="ent">➊</span> byte app_flags[32];<br/><br/>   def update_flag_value()<br/>   {<br/>  <span class="ent">➋</span> byte index = read_byte();<br/>     byte value = read_byte();<br/><br/>     printf("Writing %d to index %d\n", value, index);<br/><br/>  <span class="ent">➌</span> app_flags[index] = value;<br/>   }</pre>&#13;
<p class="listing"><a id="ch9list4"/><em>Listing 9-4: Writing to an out-of-bound buffer index</em></p>&#13;
<p class="indent">This short example shows a protocol with a common set of flags that can be updated by the client. Perhaps it’s designed to control certain server properties. The listing defines a fixed buffer of 32 flags at <span class="ent">➊</span>. At <span class="ent">➋</span> it reads a byte from the network, which it will use as the index (with a range of 0 to 255 possible values), and then it writes the byte to the flag buffer <span class="ent">➌</span>. The vulnerability in this case should be obvious: an attacker can provide values outside the range of 0 to 32 with the index, leading to selective memory corruption.</p>&#13;
<p class="indent">Out-of-bounds indexing doesn’t just have to involve writing. It works just as well when values are read from a buffer with an incorrect index. If the index were used to read a value and return it to the client, a simple information disclosure vulnerability would exist.</p>&#13;
<p class="indent">A particularly critical vulnerability could occur if the index were used to identify functions within an application to run. This usage could be something simple, such as using a command identifier as the index, which would usually be programmed by storing memory pointers to functions in a buffer. The index is then used to look up the function used to handle the specified command from the network. Out-of-bounds indexing would result in reading an unexpected value from memory that would be interpreted as a pointer to a function. This issue can easily result in exploitable remote <span epub:type="pagebreak" id="page_217"/>code execution vulnerabilities. Typically, all that is required is finding an index value that, when read as a function pointer, would cause execution to transfer to a memory location an attacker can easily control.</p>&#13;
<h4 class="h4" id="ch00lev1sec254"><strong><em>Data Expansion Attack</em></strong></h4>&#13;
<p class="noindent">Even modern, high-speed networks compress data to reduce the number of raw octets being sent, whether to improve performance by reducing data transfer time or to reduce bandwidth costs. At some point, that data must be decompressed, and if compression is done by an application, data expansion attacks are possible, as shown in <a href="../Text/ch09.xhtml#ch9list5">Listing 9-5</a>.</p>&#13;
<pre>   void read_compressed_buffer()<br/>   {<br/>     byte buf[];<br/>     uint32 len;<br/>     int i = 0;<br/><br/>     // Read the decompressed size<br/><span class="ent">➊</span>   len = read_uint32();<br/><br/>     // Allocate memory buffer<br/><span class="ent">➋</span>   buf = malloc(len);<br/><br/><span class="ent">➌</span>   gzip_decompress_data(buf)<br/><br/>     printf("Decompressed in %d bytes\n", len);<br/>   }</pre>&#13;
<p class="listing"><a id="ch9list5"/><em>Listing 9-5: Example code vulnerable to a data expansion attack</em></p>&#13;
<p class="indent">Here, the compressed data is prefixed with the total size of the decompressed data. The size is read from the network <span class="ent">➊</span> and is used to allocate the required buffer <span class="ent">➋</span>. After that, a call is made to decompress the data to the buffer <span class="ent">➌</span> using a streaming algorithm, such as gzip. The code does not check the decompressed data to see if it will actually fit into the allocated buffer.</p>&#13;
<p class="indent">Of course, this attack isn’t limited to compression. Any data transformation process, whether it’s encryption, compression, or text encoding conversions, can change the data size and lead to an expansion attack.</p>&#13;
<h4 class="h4" id="ch00lev1sec255"><strong><em>Dynamic Memory Allocation Failures</em></strong></h4>&#13;
<p class="noindent">A system’s memory is finite, and when the memory pool runs dry, a dynamic memory allocation pool must handle situations in which an application needs more. In the C language, this usually results in an error value being returned from the allocation functions (usually a NUL pointer); in other languages, it might result in the termination of the environment or the generation of an exception.</p>&#13;
<p class="indent">Several possible vulnerabilities may arise from not correctly handling a dynamic memory allocation failure. The most obvious is an application crash, which can lead to a denial-of-service condition.</p>&#13;
<h3 class="h3" id="ch00lev1sec256"><span epub:type="pagebreak" id="page_218"/><strong>Default or Hardcoded Credentials</strong></h3>&#13;
<p class="noindent">When one is deploying an application that uses authentication, default credentials are commonly added as part of the installation process. Usually, these accounts have a default username and password associated with them. The defaults create a problem if the administrator deploying the application does not reconfigure the credentials for these accounts prior to making the service available.</p>&#13;
<p class="indent">A more serious problem occurs when an application has hardcoded credentials that can be changed only by rebuilding the application. These credentials may have been added for debugging purposes during development and not removed before final release. Or they could be an intentional backdoor added with malicious intent. <a href="../Text/ch09.xhtml#ch9list6">Listing 9-6</a> shows an example of authentication compromised by hardcoded credentials.</p>&#13;
<pre> def process_authentication()<br/> {<br/><span class="ent">➊</span> string username = read_string();<br/>   string password = read_string();<br/><br/>   // Check for debug user, don't forget to remove this before release<br/><span class="ent">➋</span> if(username == "debug")<br/>   {<br/>     return true;<br/>   }<br/>   else<br/>   {<br/>  <span class="ent">➌</span> return check_user_password(username, password);<br/>   }<br/>}</pre>&#13;
<p class="listing"><a id="ch9list6"/><em>Listing 9-6: An example of default credentials</em></p>&#13;
<p class="indent">The application first reads the username and password from the network <span class="ent">➊</span> and then checks for a hardcoded username, <em>debug</em> <span class="ent">➋</span>. If the application finds username <em>debug</em>, it automatically passes the authentication process; otherwise, it follows the normal checking process <span class="ent">➌</span>. To exploit such a default username, all you’d need to do is log in as the <em>debug</em> user. In a real-world application, the credentials might not be that simple to use. The login process might require you to have an accepted source IP address, send a magic string to the application prior to login, and so on.</p>&#13;
<h3 class="h3" id="ch00lev1sec257"><strong>User Enumeration</strong></h3>&#13;
<p class="noindent">Most user-facing authentication mechanisms use usernames to control access to resources. Typically, that username will be combined with a token, such as a password, to complete authentication. The user identity doesn’t have to be a secret: usernames are often a publicly available email address.</p>&#13;
<p class="indent">There are still some advantages to not allowing someone, especially unauthenticated users, to gain access to this information. By identifying <span epub:type="pagebreak" id="page_219"/>valid user accounts, it is more likely that an attacker could brute force passwords. Therefore, any vulnerability that discloses the existence of valid usernames or provides access to the user list is an issue worth identifying. A vulnerability that discloses the existence of users is shown in <a href="../Text/ch09.xhtml#ch9list7">Listing 9-7</a>.</p>&#13;
<pre> def process_authentication()<br/> {<br/>   string username = read_string();<br/>   string password = read_string();<br/><br/><span class="ent">➊</span> if(user_exists(username) == false)<br/>   {<br/>  <span class="ent">➋</span> write_error("User " + username " doesn't exist");<br/>   }<br/>   else<br/>   {<br/>  <span class="ent">➌</span> if(check_user_password(username, password))<br/>     {<br/>       write_success("User OK");<br/>     }<br/>     else<br/>     {<br/>    <span class="ent">➍</span> write_error("User " + username " password incorrect");<br/>     }<br/>   }<br/>}</pre>&#13;
<p class="listing"><a id="ch9list7"/><em>Listing 9-7: Disclosing the existence of users in an application</em></p>&#13;
<p class="indent">The listing shows a simple authentication process where the username and password are read from the network. It first checks for the existence of a user <span class="ent">➊</span>; if the user doesn’t exist, an error is returned <span class="ent">➋</span>. If the user exists, the listing checks the password for that user <span class="ent">➌</span>. Again, if this fails, an error is written <span class="ent">➍</span>. You’ll notice that the two error messages in <span class="ent">➋</span> and <span class="ent">➍</span> are different depending on whether the user does not exist or only the password is incorrect. This information is sufficient to determine which usernames are valid.</p>&#13;
<p class="indent">By knowing a username, an attacker can more easily brute force valid authentication credentials. (It’s simpler to guess only a password rather than both a password and username.) Knowing a username can also give an attacker enough information to mount a successful social-engineering attack that would convince a user to disclose their password or other sensitive information.</p>&#13;
<h3 class="h3" id="ch00lev1sec258"><strong>Incorrect Resource Access</strong></h3>&#13;
<p class="noindent">Protocols that provide access to resources, such as HTTP or other file-sharing protocols, use an identifier for the resource you want to access. That identifier could be a file path or other unique identifier. The application <span epub:type="pagebreak" id="page_220"/>must resolve that identifier in order to access the target resource. On success, the contents of the resource are accessed; otherwise, the protocol throws an error.</p>&#13;
<p class="indent">Several vulnerabilities can affect such protocols when they’re processing resource identifiers. It’s worth testing for all possible vulnerabilities and carefully observing the response from the application.</p>&#13;
<h4 class="h4" id="ch00lev1sec259"><strong><em>Canonicalization</em></strong></h4>&#13;
<p class="noindent">If the resource identifier is a hierarchical list of resources and directories, it’s normally referred to as a <em>path</em>. Operating systems typically define the way to specify relative path information is to use two dots (..) to indicate a parent directory relationship. Before a file can be accessed, the OS must find it using this relative path information. A very naive remote file protocol could take a path supplied by a remote user, concatenate it with a base directory, and pass that directly to the OS, as shown in <a href="../Text/ch09.xhtml#ch9list8">Listing 9-8</a>. This is known as a <em>canonicalization</em> vulnerability.</p>&#13;
<pre>   def send_file_to_client()<br/>   {<br/><span class="ent">➊</span>   string name = read_string();<br/>    // Concatenate name from client with base path<br/><span class="ent">➋</span>   string fullPath = "/files" + name;<br/><br/><span class="ent">➌</span>   int fd = open(fullPath, READONLY);<br/><br/>    // Read file to memory<br/><span class="ent">➍</span>   byte data[] read_to_end(fd);<br/><br/>    // Send to client<br/><span class="ent">➎</span>   write_bytes(data, len(data));<br/>   }</pre>&#13;
<p class="listing"><a id="ch9list8"/><em>Listing 9-8: A path canonicalization vulnerability</em></p>&#13;
<p class="indent">This listing reads a string from the network that represents the name of the file to access <span class="ent">➊</span>. This string is then concatenated with a fixed base path into the full path <span class="ent">➋</span> to allow access only to a limited area of the filesystem. The file is then opened by the operating system <span class="ent">➌</span>, and if the path contains relative components, they are resolved. Finally, the file is read into memory <span class="ent">➍</span> and returned to the client <span class="ent">➎</span>.</p>&#13;
<p class="indent">If you find code that performs this same sequence of operations, you’ve identified a canonicalization vulnerability. An attacker could send a relative path that is resolved by the OS to a file outside the base directory, resulting in sensitive files being disclosed, as shown in <a href="../Text/ch09.xhtml#ch9fig4">Figure 9-4</a>.</p>&#13;
<p class="indent">Even if an application does some checking on the path before sending it to the OS, the application must correctly match how the OS will interpret the string. For example, on Microsoft Windows backslashes (\) and forward slashes (/) are acceptable as path separators. If an application checks only backslashes, the standard for Windows, there might still be a vulnerability.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_221"/><img alt="image" src="../Images/f09-04.jpg"/></div>&#13;
<p class="figcap"><a id="ch9fig4"/><em>Figure 9-4: A normal path canonicalization operation versus a vulnerable one</em></p>&#13;
<p class="indent">Although having the ability to download files from a system might be enough to compromise it, a more serious issue results if the canonicalization vulnerability occurs in file upload protocols. If you can upload files to the application-hosting system and specify an arbitrary path, it’s much easier to compromise a system. You could, for example, upload scripts or other executable content to the system and get the system to execute that content, leading to remote code execution.</p>&#13;
<h4 class="h4" id="ch00lev1sec260"><strong><em>Verbose Errors</em></strong></h4>&#13;
<p class="noindent">If, when an application attempts to retrieve a resource, the resource is not found, applications typically return some error information. That error can be as simple as an error code or a full description of what doesn’t exist; however, it should not disclose any more information than required. Of course, that’s not always the case.</p>&#13;
<p class="indent">If an application returns an error message when requesting a resource that doesn’t exist and inserts local information about the resource being <span epub:type="pagebreak" id="page_222"/>accessed into the error, a simple vulnerability is present. If a file was being accessed, the error might contain the local path to the file that was passed to the OS: this information might prove useful for someone trying to get further access to the hosting system, as shown in <a href="../Text/ch09.xhtml#ch9list9">Listing 9-9</a>.</p>&#13;
<pre> def send_file_to_client_with_error()<br/> {<br/><span class="ent">➊</span> string name = read_string();<br/><br/>   // Concatenate name from client with base path<br/><span class="ent">➋</span> string fullPath = "/files" + name;<br/><br/><span class="ent">➌</span> if(!exist(fullPath))<br/>   {<br/>  <span class="ent">➍</span> write_error("File " + fullPath + " doesn't exist");<br/>   }<br/>   else<br/>   {<br/>  <span class="ent">➎</span> write_file_to_client(fullPath);<br/>   }<br/>}</pre>&#13;
<p class="listing"><a id="ch9list9"/><em>Listing 9-9: An error message information disclosure</em></p>&#13;
<p class="indent">This listing shows a simple example of an error message being returned to a client when a requested file doesn’t exist. At <span class="ent">➊</span> it reads a string from the network that represents the name of the file to access. This string is then concatenated with a fixed base path into the full path at <span class="ent">➋</span>. The existence of the file is checked with the operating system at <span class="ent">➌</span>. If the file doesn’t exist, the full path to the file is added to an error string and returned to the client <span class="ent">➍</span>; otherwise, the data is returned <span class="ent">➎</span>.</p>&#13;
<p class="indent">The listing is vulnerable to disclosing the location of the base path on the local filesystem. Furthermore, the path could be used with other vulnerabilities to get more access to the system. It could also disclose the current user running the application if, for example, the resource directory was in the user’s home directory.</p>&#13;
<h3 class="h3" id="ch00lev1sec261"><strong>Memory Exhaustion Attacks</strong></h3>&#13;
<p class="noindent">The resources of the system on which an application runs are finite: available disk space, memory, and processing power have limits. Once a critical system resource is exhausted, the system might start failing in unexpected ways, such as by no longer responding to new network connections.</p>&#13;
<p class="indent">When dynamic memory is used to process a protocol, the risk of overallocating memory or forgetting to free the allocated blocks always exists, resulting in <em>memory exhaustion</em>. The simplest way in which a protocol can be susceptible to a memory exhaustion vulnerability is if it allocates memory dynamically based on an absolute value transmitted in the protocol. For example, consider <a href="../Text/ch09.xhtml#ch9list10">Listing 9-10</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_223"/><br/> def read_buffer()<br/> {<br/>   byte buf[];<br/>   uint32 len;<br/>   int i = 0;<br/><br/>   // Read the number of bytes from the network<br/><span class="ent">➊</span> len = read_uint32();<br/><br/>   // Allocate memory buffer<br/><span class="ent">➋</span> buf = malloc(len);<br/><br/>   // Allocate bytes from network<br/><span class="ent">➌</span> read_bytes(buf, len);<br/><br/>   printf("Read in %d bytes\n", len);<br/> }</pre>&#13;
<p class="listing"><a id="ch9list10"/><em>Listing 9-10: A memory exhaustion attack</em></p>&#13;
<p class="indent">This listing reads a variable-length buffer from the protocol. First, it reads in the length in bytes <span class="ent">➊</span> as an unsigned 32-bit integer. Next, it tries to allocate a buffer of that length, prior to reading it from the network <span class="ent">➋</span>. Finally, it reads the data from the network <span class="ent">➌</span>. The problem is that an attacker could easily specify a very large length, say 2 gigabytes, which when allocated would block out a large region of memory that no other part of the application could access. The attacker could then slowly send data to the server (to try to prevent the connection from closing due to a timeout) and, by repeating this multiple times, eventually starve the system of memory.</p>&#13;
<p class="indent">Most systems would not allocate physical memory until it was used, thereby limiting the general impact on the system as a whole. However, this attack would be more serious on dedicated embedded systems where memory is at a premium and virtual memory is nonexistent.</p>&#13;
<h3 class="h3" id="ch00lev1sec262"><strong>Storage Exhaustion Attacks</strong></h3>&#13;
<p class="noindent">Storage exhaustion attacks are less likely to occur with today’s multi-terabyte hard disks but can still be a problem for more compact embedded systems or devices without storage. If an attacker can exhaust a system’s storage capacity, the application or others on that system could begin failing. Such an attack might even prevent the system from rebooting. For example, if an operating system needs to write certain files to disk before starting but can’t, a permanent denial-of-service condition can occur.</p>&#13;
<p class="indent">The most common cause of this type of vulnerability is in the logging of operating information to disk. For example, if logging is very verbose, generating a few hundred kilobytes of data per connection, and the maximum log size has no restrictions, it would be fairly simple to flood storage by making repeated connections to a service. Such an attack might be <span epub:type="pagebreak" id="page_224"/>particularly effective if an application logs data sent to it remotely and supports compressed data. In such a case, an attacker could spend very little network bandwidth to cause a large amount of data to be logged.</p>&#13;
<h3 class="h3" id="ch00lev1sec263"><strong>CPU Exhaustion Attacks</strong></h3>&#13;
<p class="noindent">Even though today’s average smartphone has multiple CPUs at its disposal, CPUs can do only a certain number of tasks at one time. It is possible to cause a denial-of-service condition if an attacker can consume CPU resources with a minimal amount of effort and bandwidth. Although this can be done in several ways, I’ll discuss only two: exploiting algorithmic complexity and identifying external controllable parameters to cryptographic systems.</p>&#13;
<h4 class="h4" id="ch00lev1sec264"><strong><em>Algorithmic Complexity</em></strong></h4>&#13;
<p class="noindent">All computer algorithms have an associated computational cost that represents how much work needs to be performed for a particular input to get the desired output. The more work an algorithm requires, the more time it needs from the system’s processor. In an ideal world, an algorithm should take a constant amount of time, no matter what input it receives. But that is rarely the case.</p>&#13;
<p class="indent">Some algorithms become particularly expensive as the number of input parameters increases. For example, consider the sorting algorithm <em>Bubble Sort</em>. This algorithm inspects each value pair in a buffer and swaps them if the left value of the pair is greater than the right. This has the effect of bubbling the higher values to the end of the buffer until the entire buffer is sorted. <a href="../Text/ch09.xhtml#ch9list11">Listing 9-11</a> shows a simple implementation.</p>&#13;
<pre>def bubble_sort(int[] buf)<br/>{<br/>  do<br/>  {<br/>    bool swapped = false;<br/>    int N = len(buf);<br/>    for(int i = 1; i &lt; N - 1; ++i)<br/>    {<br/>      if(buf[i-1] &gt; buf[i])<br/>      {<br/>        // Swap values<br/>        swap( buf[i-1], buf[i] );<br/>        swapped = true;<br/>      }<br/>    }<br/>  } while(swapped == false);<br/>}</pre>&#13;
<p class="listing"><a id="ch9list11"/><em>Listing 9-11: A simple Bubble Sort implementation</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_225"/>The amount of work this algorithm requires is proportional to the number of elements (let’s call the number <em>N</em>) in the buffer you need to sort. In the best case, this necessitates a single pass through the buffer, requiring <em>N</em> iterations, which occurs when all elements are already sorted. In the worst case, when the buffer is sorted in reverse, the algorithm needs to repeat the sort process <em>N</em> <sup>2</sup> times. If an attacker could specify a large number of reverse-sorted values, the computational cost of doing this sort becomes significant. As a result, the sort could consume 100 percent of a CPU’s processing time and lead to denial-of-service.</p>&#13;
<p class="indent">In a real-world example of this, it was discovered that some programming environments, including PHP and Java, used an algorithm for the hash table implementations that took <em>N</em> <sup>2</sup> operations in the worst case. A <em>hash table</em> is a data structure that holds values keyed to another value, such as a textual name. The keys are first hashed using a simple algorithm, which then determines a <em>bucket</em> into which the value is placed. The <em>N</em> <sup>2</sup> algorithm is used when inserting the new value into the bucket; ideally, there should be few collisions between the hash values of keys so the size of the bucket is small. But by crafting a set of keys with the same hash (but, crucially, different key values), an attacker could cause a denial-of-service condition on a network service (such as a web server) by sending only a few requests.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart" id="ch00sbsec3"><strong>BIG-O NOTATION</strong></p>&#13;
<p class="noindent"><em>Big-O</em> notation, a common representation of computational complexity, represents the upper bound for an algorithm’s complexity. <a href="../Text/ch09.xhtml#ch9tab1">Table 9-1</a> lists some common Big-O notations for various algorithms, from least to most complex.</p>&#13;
<p class="tabcap"><a id="ch9tab1"/><strong>Table 9-1:</strong> Big-O Notation for Worst-Case Algorithm Complexity</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr class="table_w">&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Notation</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Description</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">O(1)</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Constant time; the algorithm always takes the same amount of time.</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">O(log <em>N</em>)</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Logarithmic; the worst case is proportional to the logarithm of the number of inputs.</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">O(<em>N</em>)</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Linear time; the worst case is proportional to the number of inputs.</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">O(<em>N</em> <sup>2</sup>)</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Quadratic; the worst case is proportional to the square of the number of inputs.</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table">O(2<em><sup>N</sup></em>)</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Exponential; the worst case is proportional to 2 raised to the power <em>N</em>.</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Bear in mind that these are worst-case values that don’t necessarily represent real-world complexity. That said, with knowledge of a specific algorithm, such as the Bubble Sort, there is a good chance that an attacker could intentionally trigger the worst case.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec265"><span epub:type="pagebreak" id="page_226"/><strong><em>Configurable Cryptography</em></strong></h4>&#13;
<p class="noindent">Cryptographic primitives processing, such as hashing algorithms, can also create a significant amount of computational workload, especially when dealing with authentication credentials. The rule in computer security is that passwords should always be hashed using a cryptographic digest algorithm before they are stored. This converts the password into a hash value, which is virtually impossible to reverse into the original password. Even if the hash was disclosed, it would be difficult to get the original password. But someone could still guess the password and generate the hash. If the guessed password matches when hashed, then they’ve discovered the original password. To mitigate this problem, it’s typical to run the hashing operation multiple times to increase an attacker’s computational requirement. Unfortunately, this process also increases computational cost for the application, which might be a problem when it comes to a denial-of-service condition.</p>&#13;
<p class="indent">A vulnerability can occur if either the hashing algorithm takes an exponential amount of time (based on the size of the input) or the algorithm’s number of iterations can be specified externally. The relationship between the time required by most cryptographic algorithms and a given input is fairly linear. However, if you can specify the algorithm’s number of iterations without any sensible upper bound, processing could take as long as the attacker desired. Such a vulnerable application is shown in <a href="../Text/ch09.xhtml#ch9list12">Listing 9-12</a>.</p>&#13;
<pre>   def process_authentication()<br/>   {<br/><span class="ent">➊</span>   string username = read_string();<br/>     string password = read_string();<br/><span class="ent">➋</span>   int iterations = read_int();<br/><br/>     for(int i = 0; i &lt; interations; ++i)<br/>     {<br/><span class="ent">➌</span>     password = hash_password(password);<br/>     }<br/><br/><span class="ent">➍</span>   return check_user_password(username, password);<br/>   }</pre>&#13;
<p class="listing"><a id="ch9list12"/><em>Listing 9-12: Checking a vulnerable authentication</em></p>&#13;
<p class="indent">First, the username and password are read from the network <span class="ent">➊</span>. Next, the hashing algorithm’s number of iterations is read <span class="ent">➋</span>, and the hashing process is applied that number of times <span class="ent">➌</span>. Finally, the hashed password is checked against one stored by the application <span class="ent">➍</span>. Clearly, an attacker could supply a very large value for the iteration count that would likely consume a significant amount of CPU resources for an extended period of time, especially if the hashing algorithm is computationally complex.</p>&#13;
<p class="indent">A good example of a cryptographic algorithm that a client can configure is the handling of public/private keys. Algorithms such as RSA rely on the computational cost of factoring a large public key value. The larger the key value, the more time it takes to perform encryption/decryption and the longer it takes to generate a new key pair.</p>&#13;
<h3 class="h3" id="ch00lev1sec266"><span epub:type="pagebreak" id="page_227"/><strong>Format String Vulnerabilities</strong></h3>&#13;
<p class="noindent">Most programming languages have a mechanism to convert arbitrary data into a string, and it’s common to define some formatting mechanism to specify how the developer wants the output. Some of these mechanisms are quite powerful and privileged, especially in memory-unsafe languages.</p>&#13;
<p class="indent">A <em>format string</em> vulnerability occurs when the attacker can supply a string value to an application that is then used directly as the format string. The best-known, and probably the most dangerous, formatter is used by the C language’s <code>printf</code> and its variants, such as <code>sprintf</code>, which print to a string. The <code>printf</code> function takes a format string as its first argument and then a list of the values to format. <a href="../Text/ch09.xhtml#ch9list13">Listing 9-13</a> shows such a vulnerable application.</p>&#13;
<pre>def process_authentication()<br/>{<br/>      string username = read_string();<br/>      string password = read_string();<br/><br/>      // Print username and password to terminal<br/>      printf(username);<br/>      printf(password);<br/><br/>      return check_user_password(username, password))<br/>}</pre>&#13;
<p class="listing"><a id="ch9list13"/><em>Listing 9-13: The <code><span class="codeitalic">printf</code></span> format string vulnerability</em></p>&#13;
<p class="indent">The format string for <code>printf</code> specifies the position and type of data using a <code>%?</code> syntax where the question mark is replaced by an alphanumeric character. The format specifier can also include formatting information, such as the number of decimal places in a number. An attacker who can directly control the format string could corrupt memory or disclose information about the current stack that might prove useful for further attacks. <a href="../Text/ch09.xhtml#ch9tab2">Table 9-2</a> shows a list of common <code>printf</code> format specifiers that an attacker could abuse.</p>&#13;
<p class="tabcap"><a id="ch9tab2"/><strong>Table 9-2:</strong> List of Commonly Exploitable <code>printf</code> Format Specifiers</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr class="table_w">&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Format specifier</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Description</strong></p>&#13;
</td>&#13;
<td class="table_th" style="vertical-align: top;"><p class="table"><strong>Potential vulnerabilities</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><code>%d</code>, <code>%p</code>, <code>%u</code>, <code>%x</code></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Prints integers</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Can be used to disclose information from the stack if returned to an attacker</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_w">&#13;
<td style="vertical-align: top;"><p class="table"><code>%s</code></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Prints a zero terminated string</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Can be used to disclose information from the stack if returned to an attacker or cause invalid memory accesses to occur, leading to denial-of-service</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table_a">&#13;
<td style="vertical-align: top;"><p class="table"><code>%n</code></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Writes the current number of printed characters to a pointer specified in the arguments</p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="table">Can be used to cause selective memory corruption or application crashes</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch00lev1sec267"><span epub:type="pagebreak" id="page_228"/><strong>Command Injection</strong></h3>&#13;
<p class="noindent">Most OSes, especially Unix-based OSes, include a rich set of utilities designed for various tasks. Sometimes developers decide that the easiest way to execute a particular task, say password updating, is to execute an external application or operating system utility. Although this might not be a problem if the command line executed is entirely specified by the developer, often some data from the network client is inserted into the command line to perform the desired operation. <a href="../Text/ch09.xhtml#ch9list14">Listing 9-14</a> shows such a vulnerable application.</p>&#13;
<pre> def update_password(string username)<br/> {<br/><span class="ent">➊</span> string oldpassword = read_string();<br/>   string newpassword = read_string();<br/><br/>   if(check_user_password(username, oldpassword))<br/>   {<br/>     // Invoke update_password command<br/>  <span class="ent">➋</span> system("/sbin/update_password -u " + username + " -p " + newpassword);<br/>   }<br/> }</pre>&#13;
<p class="listing"><a id="ch9list14"/><em>Listing 9-14: A password update vulnerable to command injection</em></p>&#13;
<p class="indent">The listing updates the current user’s password as long as the original password is known <span class="ent">➊</span>. It then builds a command line and invokes the Unix-style <code>system</code> function <span class="ent">➋</span>. Although we don’t control the <code>username</code> or <code>oldpassword</code> parameters (they must be correct for the <code>system</code> call to be made), we do have complete control over <code>newpassword</code>. Because no sanitization is done, the code in the listing is vulnerable to command injection because the system function uses the current Unix shell to execute the command line. For example, we could specify a value for <code>newpassword</code> such as <code>password; xcalc</code>, which would first execute the password update command. Then the shell could execute <code>xcalc</code> as it treats the semicolon as a separator in a list of commands to execute.</p>&#13;
<h3 class="h3" id="ch00lev1sec268"><strong>SQL Injection</strong></h3>&#13;
<p class="noindent">Even the simplest application might need to persistently store and retrieve data. Applications can do this in a number of ways, but one of the most common is to use a relational database. Databases offer many advantages, not least of which is the ability to issue queries against the data to perform complex grouping and analysis.</p>&#13;
<p class="indent">The de facto standard for defining queries to relational databases is the <em>Structured Query Language (SQL)</em>. This text-based language defines what data tables to read and how to filter that data to get the results the application wants. When using a text-based language there is a temptation is to build queries using string operations. However, this can easily result in a vulnerability like command injection: instead of inserting untrusted data into a <span epub:type="pagebreak" id="page_229"/>command line without appropriately escaping, the attacker inserts data into a SQL query, which is executed on the database. This technique can modify the operation of the query to return known results. For example, what if the query extracted the current password for the authenticating user, as shown in <a href="../Text/ch09.xhtml#ch9list15">Listing 9-15</a>?</p>&#13;
<pre>   def process_authentication()<br/>   {<br/><span class="ent">➊</span>   string username = read_string();<br/>     string password = read_string();<br/><br/><span class="ent">➋</span>   string sql = "SELECT password FROM user_table WHERE user = '" + username "'";<br/><br/><span class="ent">➌</span>   return run_query(sql) == password;<br/>   }</pre>&#13;
<p class="listing"><a id="ch9list15"/><em>Listing 9-15: An example of authentication vulnerable to SQL injection</em></p>&#13;
<p class="indent">This listing reads the username and password from the network <span class="ent">➊</span>. Then it builds a new SQL query as a string, using a <code>SELECT</code> statement to extract the password associated with the user from the user table <span class="ent">➋</span>. Finally, it executes that query on the database and checks that the password read from the network matches the one in the database <span class="ent">➌</span>.</p>&#13;
<p class="indent">The vulnerability in this listing is easy to exploit. In SQL, the strings need to be enclosed in single quotes to prevent them from being interpreted as commands in the SQL statement. If a username is sent in the protocol with an embedded single quote, an attacker could terminate the quoted string early. This would lead to an injection of new commands into the SQL query. For example, a <code>UNION SELECT</code> statement would allow the query to return an arbitrary password value. An attacker could use the SQL injection to bypass the authentication of an application.</p>&#13;
<p class="indent">SQL injection attacks can even result in remote code execution. For example, although disabled by default, Microsoft’s SQL Server’s database function <code>xp_cmdshell</code> allows you to execute OS commands. Oracle’s database even allows uploading arbitrary Java code. And of course, it’s also possible to find applications that pass raw SQL queries over the network. Even if a protocol is not intended for controlling the database, there’s still a good chance that it can be exploited to access the underlying database engine.</p>&#13;
<h3 class="h3" id="ch00lev1sec269"><strong>Text-Encoding Character Replacement</strong></h3>&#13;
<p class="noindent">In an ideal world, everyone would be able to use one type of text encoding for all different languages. But we don’t live in an ideal world, and we use multiple text encodings as discussed in <a href="../Text/ch03.xhtml#ch03">Chapter 3</a>, such as ASCII and variants of Unicode.</p>&#13;
<p class="indent">Some conversions between text encodings cannot be round-tripped: converting from one encoding to another loses important information such that if the reverse process is applied, the original text can’t be restored. This <span epub:type="pagebreak" id="page_230"/>is especially problematic when converting from a wide character set such as Unicode to a narrow one such as ASCII. It’s simply impossible to encode the entire Unicode character set in 7 bits.</p>&#13;
<p class="indent">Text-encoding conversions manage this problem in one of two ways. The simplest approach replaces the character that cannot be represented with a placeholder, such as the question mark (?) character. This might be a problem if the data value refers to something where the question mark is used as a delimiter or as a special character, for example, as in URL parsing where it represents the beginning of a query string.</p>&#13;
<p class="indent">The other approach is to apply a best-fit mapping. This is used for characters for which there is a similar character in the new encoding. For example, the quotation mark characters in Unicode have left-facing and right-facing forms that are mapped to specific code points, such as U+201C and U+201D for left and right double quotation marks. These are outside the ASCII range, but in a conversion to ASCII, they’re commonly replaced with the equivalent character, such as U+0022 or the quotation mark. Best-fit mapping can become a problem when the converted text is processed by the application. Although slightly corrupted text won’t usually cause much of a problem for a user, the automatic conversion process could cause the application to mishandle the data.</p>&#13;
<p class="indent">The important implementation issue is that the application first verifies the security condition using one encoded form of a string. Then it uses the other encoded form of a string for a specific action, such as reading a resource or executing a command, as shown in <a href="../Text/ch09.xhtml#ch9list16">Listing 9-16</a>.</p>&#13;
<pre> def add_user()<br/> {<br/><span class="ent">➊</span> string username = read_unicode_string();<br/><br/>   // Ensure username doesn't contain any single quotes<br/><span class="ent">➋</span> if(username.contains("'") == false)<br/>   {<br/>     // Add user, need to convert to ASCII for the shell<br/>  <span class="ent">➌</span> system("/sbin/add_user '" + username.toascii() + "'");<br/>   }<br/> }</pre>&#13;
<p class="listing"><a id="ch9list16"/><em>Listing 9-16: A text conversion vulnerability</em></p>&#13;
<p class="indent">In this listing, the application reads in a Unicode string representing a user to add to the system <span class="ent">➊</span>. It will pass the value to the <code>add_user</code> command, but it wants to avoid a command injection vulnerability; therefore, it first ensures that the username doesn’t contain any single quote characters that could be misinterpreted <span class="ent">➋</span>. Once satisfied that the string is okay, it converts it to ASCII (Unix systems typically work on a narrow character set, although many support UTF-8) and ensures that the value is enclosed with single quotes to prevent spaces from being misinterpreted <span class="ent">➌</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_231"/>Of course, if the best-fit mapping rules convert other characters back to a single quote, it would be possible to prematurely terminate the quoted string and return to the same sort of command injection vulnerabilities discussed earlier.</p>&#13;
<h3 class="h3" id="ch00lev1sec270"><strong>Final Words</strong></h3>&#13;
<p class="noindent">This chapter showed you that many possible root causes exist for vulnerabilities, with a seemingly limitless number of variants in the wild. Even if something doesn’t immediately look vulnerable, persist. Vulnerabilities can appear in the most surprising places.</p>&#13;
<p class="indent">I’ve covered vulnerabilities ranging from memory corruptions, causing an application to behave in a different manner than it was originally designed, to preventing legitimate users from accessing the services provided. It can be a complex process to identify all these different issues.</p>&#13;
<p class="indent">As a protocol analyzer, you have a number of possible angles. It is also vital that you change your strategy when looking for implementation vulnerabilities. Take into account whether the application is written in memory-safe or unsafe languages, keeping in mind that you are less likely to find memory corruption in, for example, a Java application.<span epub:type="pagebreak" id="page_232"/></p>&#13;
</body></html>