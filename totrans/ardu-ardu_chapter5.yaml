- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CONTROLLING
    LEDS WITH CHARLIEPLEXING</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: It’s easy to control many LEDs with one Arduino board. However, you can also
    use the *Charlieplexing* method in the Arduino environment to control multiple
    LEDs one at a time without external display driver ICs. This is a great way to
    reduce part count (and expenses) in a project involving numeric or character displays.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Charlieplexing with an Arduino Uno or compatible board or an ATtiny85 microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Charlieplexing with 6 and 12 LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplify planning Charlieplexed circuits with the help of logic tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll also build a 30-LED matrix display for alphanumeric data that you can
    use for your own projects
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Introduction to Charlieplexing</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term *Charlieplexing* is named after Charlie Allen, who originally proposed
    the idea during his time at Maxim Integrated (now part of Analog Devices), which
    produced integrated circuits such as the popular MAX7219 LED display driver. The
    word is a portmanteau composed of “Charlie” and “multiplexing,” the latter being
    a method of controlling many LEDs with few I/O pins on a microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Charlieplexing is a type of multiplexing that relies on the *tri-state* capability
    of microcontroller I/O pins to control the required current to activate multiple
    LEDs in circuits. You can set each pin to be in one of three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**High**    Current flows from an I/O pin, such as when using a <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp>
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Low**    Current does not flow from an I/O pin, when the pin can also sink
    (receive current).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input state (or high-Z)**    The pin is set to a digital input. In this state,
    little to no current will flow in either direction. This is also known as the
    *high impedance* or *high-Z* state.'
  prefs: []
  type: TYPE_NORMAL
- en: You can set these I/O pins to different states to direct current through a circuit
    and create a controllable matrix of LEDs. Only one LED may be turned on at any
    given time, and all the LEDs used in one circuit must be the same specification—that
    is, they must all have the same forward voltage and operating current.
  prefs: []
  type: TYPE_NORMAL
- en: To help understand Charlieplexing, let’s work through some small examples. First,
    consider the schematic in [Figure 5-1](chapter5.xhtml#fig5-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC OF TWO LEDS IN THE CHARLIEPLEXING ARRANGEMENT](../images/fig5-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: The schematic for
    two LEDs connected to the Arduino outputs</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If pin D13 is HIGH and pin D12 is LOW, current flows from pin D13 through R[1],
    through D[2], through R[2], and into D12, meaning LED D[2] will turn on. If you
    reverse the outputs so pin D12 is HIGH and pin D13 is LOW, current flows from
    pin D12 through D[1], through R[1], and into D13, meaning LED D[1] will turn on.
    Current will always flow through both resistors, so the sum of their values should
    be suitable for running an LED from a digital output. With a 5 V output, values
    of 270 Ω through around 510 Ω would enable sufficient brightness.
  prefs: []
  type: TYPE_NORMAL
- en: To test Charlieplexing, build the circuit in [Figure 5-1](chapter5.xhtml#fig5-1);
    then run the sketch in [Listing 5-1](#LiT-5-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: Two-LED demonstration</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This sketch shows how to direct current to control one of two LEDs without a
    GND pin. It’s intended only as a basic introduction to the concept of Charlieplexing;
    there’s no real benefit to Charlieplexing two LEDs, as it doesn’t reduce the number
    of I/O pins used. However, the possibilities of Charlieplexing become obvious
    once you add another I/O pin to the circuit, as shown in the next project.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #15: Charlieplexing with Six
    LEDs</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll control six LEDs with only three digital output pins,
    demonstrating the benefits of Charlieplexing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three 270 Ω, 0.25 W, 1 percent resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Six LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two solderless breadboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Male-to-male jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 5-2](chapter5.xhtml#fig5-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #15](../images/fig5-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: The schematic for
    Project #15</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: For easy assembly, use two solderless breadboards side by side, as shown in
    [Figure 5-3](chapter5.xhtml#fig5-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF PROJECT #15 ON A SOLDERLESS BREADBOARD, WITH THE UPPER RIGHT
    LIGHT IN A SET OF FOUR BEING THE ONLY ONE LIT UP](../images/fig5-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-3: The assembled Project
    #15</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now enter and upload the following sketch to your Arduino. A moment after uploading
    the sketch, each LED from 1 through 6 should light in turn.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first few moments of operation may seem like magic if you’re accustomed
    to using one LED per digital output pin, but you can achieve these effects simply
    by carefully directing current through the appropriate pins and resistors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the first LED in the schematic, D[1], controlled by the function <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LED1()</samp> ❷. Trace the path through
    the schematic as follows: current needs to flow from pin D12 through R[2], through
    the LED itself, then through R[1], and into pin D13\. You don’t want current to
    flow through D[4], so you set pin D11 to an input, blocking current flow. Although
    D[4] and D[5] are in the current’s path, they will not activate, as the resistor
    and their forward operating voltage reduce the current’s voltage so greatly.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using lots of <samp class="SANS_TheSansMonoCd_W5Regular_11">pinMode()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp> functions,
    this sketch uses port manipulation (covered in [Chapter 2](chapter2.xhtml)) to
    control the digital pins. This greatly reduces the amount of required code, which
    also frees up more memory for the rest of your project.
  prefs: []
  type: TYPE_NORMAL
- en: To turn on D[1] in the code, the sketch turns on LED D[1] and sets pin D13 to
    HIGH and D12 to LOW using port manipulation. The sketch first activates PORTB
    pin types D13 to D8 ❸, setting D13 to output, setting D12 to output, setting D11
    to input, and leaving the unused pins at 0\. It then activates the output pins
    ❹, setting D13 to LOW, setting D12 to HIGH, and leaving input as 0\. This turns
    on LED D[1].
  prefs: []
  type: TYPE_NORMAL
- en: For another example in the project, consider LED D[5]. To turn it on, current
    must flow from pin D11 through R[3], D[4], and R[1], and then into D13\. The sketch
    sets pin D11 to HIGH, pin D13 to LOW, and pin D12 as an input ❺ to stop current
    flowing in that direction.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch sets the flow of current in this way for each LED in turn, within
    a function for each LED from ❶ onward. Unlike using conventional <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp>
    functions where you need to first use <samp class="SANS_TheSansMonoCd_W5Regular_11">pinMode()</samp>
    functions to configure a pin as an output or input, nothing is required in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, so the code then
    lights each LED in turn from ❻.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can adjust the amount of time between each LED being switched on by changing
    the defined value of <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> ❶.
    Although the sketch doesn’t use this option, you can also turn off all the LEDs
    at once at any point in the code with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Keep this project’s hardware together to use in the following project. In the
    next section, I’ll show you a more systematic way of determining which pins to
    set as HIGH or LOW.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Larger Charlieplexing Displays</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When building larger Charlieplexing circuits, creating a logic table with the
    LEDs and their required pin types and outputs can help you plan how to write your
    code. This makes it easier to create the required <samp class="SANS_TheSansMonoCd_W5Regular_11">DDRB</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTB</samp> functions to control
    the LEDs. To do this, trace the current path you require for each LED and then
    determine the pin status for each LED. For example, [Table 5-1](chapter5.xhtml#tab5-1)
    is the logic table for Project #15, where L stands for LOW, H for HIGH, and Z
    for input.'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_11">Table 5-1:</samp> <samp class="SANS_Futura_Std_Book_11">Logic
    Table for Project #15</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">LED#</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Pin
    D13</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Pin D12</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Pin
    D11</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">L</samp>
    | <samp class="SANS_Futura_Std_Book_11">H</samp> | <samp class="SANS_Futura_Std_Book_11">Z</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">H</samp>
    | <samp class="SANS_Futura_Std_Book_11">L</samp> | <samp class="SANS_Futura_Std_Book_11">Z</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">Z</samp>
    | <samp class="SANS_Futura_Std_Book_11">L</samp> | <samp class="SANS_Futura_Std_Book_11">H</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">Z</samp>
    | <samp class="SANS_Futura_Std_Book_11">H</samp> | <samp class="SANS_Futura_Std_Book_11">L</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_Futura_Std_Book_11">L</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> | <samp class="SANS_Futura_Std_Book_11">H</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">H</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> | <samp class="SANS_Futura_Std_Book_11">L</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: 'Creating such a table simplifies the process of determining the port manipulation
    commands, as you can just match each letter with its respective ones, zeros, and
    inputs. To make your own table, trace the current flow in the schematic required
    for each LED and then note the status required for each I/O pin. For example,
    to activate LED 4 in Project #15, current must flow out from pin D12 (so it’s
    HIGH) through R[2], through LED D[4], then through R[3], and back to D11 (so it’s
    LOW). You don’t want current to flow in or out of D13, so it will be Z. You can
    then use this HIGH, LOW, and Z information to create the required <samp class="SANS_TheSansMonoCd_W5Regular_11">DDR</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTB</samp> functions in your
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have more than two I/O pins in use, you can connect a pair of LEDs
    to each of the other I/O lines. To determine how many LEDs you can control with
    any number of available I/O pins on your Arduino, use the formula *L* = *n*² −
    *n*, where *L* is the number of LEDs and *n* is the number of I/O pins. For example,
    if you have 4 pins, you can use 12 LEDs (4² − 4 = 12).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try this in the next project.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #16: Charlieplexing with 12
    LEDs</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, you’ll practice using Charlieplexing to control an even larger
    LED display with only four digital output pins. You’ll need the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four 270 Ω, 0.25 W, 1 percent resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12 LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two solderless breadboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Male-to-male jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 5-4](chapter5.xhtml#fig5-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #16](../images/fig5-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-4: The schematic for
    Project #16</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can build this project by expanding on the hardware setup from Project
    #15, using two solderless breadboards side by side, as shown in [Figure 5-5](chapter5.xhtml#fig5-5).'
  prefs: []
  type: TYPE_NORMAL
- en: '![AN IMAGE OF THE ASSEMBLED PROJECT #15](../images/fig5-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-5: The assembled Project
    #16</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 5-2](chapter5.xhtml#tab5-2) is Project #16’s logic table. You can compare
    this with the port manipulations in the subsequent sketch to increase your familiarity
    with controlling the LEDs. For practice, trace the current for various LEDs through
    the schematic and compare with the table.'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_11">Table 5-2:</samp> <samp class="SANS_Futura_Std_Book_11">Logic
    Table for Project #16</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">LED#</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Pin
    D13</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Pin D12</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Pin
    D11</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Pin D10</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">L</samp>
    | <samp class="SANS_Futura_Std_Book_11">H</samp> | <samp class="SANS_Futura_Std_Book_11">Z</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">H</samp>
    | <samp class="SANS_Futura_Std_Book_11">L</samp> | <samp class="SANS_Futura_Std_Book_11">Z</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">Z</samp>
    | <samp class="SANS_Futura_Std_Book_11">L</samp> | <samp class="SANS_Futura_Std_Book_11">H</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">Z</samp>
    | <samp class="SANS_Futura_Std_Book_11">H</samp> | <samp class="SANS_Futura_Std_Book_11">L</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_Futura_Std_Book_11">L</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> | <samp class="SANS_Futura_Std_Book_11">H</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">H</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> | <samp class="SANS_Futura_Std_Book_11">L</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">Z</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> | <samp class="SANS_Futura_Std_Book_11">L</samp>
    | <samp class="SANS_Futura_Std_Book_11">H</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_Futura_Std_Book_11">Z</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> | <samp class="SANS_Futura_Std_Book_11">H</samp>
    | <samp class="SANS_Futura_Std_Book_11">L</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">9</samp> | <samp class="SANS_Futura_Std_Book_11">Z</samp>
    | <samp class="SANS_Futura_Std_Book_11">L</samp> | <samp class="SANS_Futura_Std_Book_11">Z</samp>
    | <samp class="SANS_Futura_Std_Book_11">H</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">10</samp> | <samp class="SANS_Futura_Std_Book_11">Z</samp>
    | <samp class="SANS_Futura_Std_Book_11">H</samp> | <samp class="SANS_Futura_Std_Book_11">Z</samp>
    | <samp class="SANS_Futura_Std_Book_11">L</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">11</samp> | <samp class="SANS_Futura_Std_Book_11">L</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> | <samp class="SANS_Futura_Std_Book_11">Z</samp>
    | <samp class="SANS_Futura_Std_Book_11">H</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">12</samp> | <samp class="SANS_Futura_Std_Book_11">H</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> | <samp class="SANS_Futura_Std_Book_11">Z</samp>
    | <samp class="SANS_Futura_Std_Book_11">L</samp> |'
  prefs: []
  type: TYPE_TB
- en: 'Enter and upload the Project #16 sketch to your Arduino. Once again, a moment
    or two after uploading the sketch, each LED should illuminate in turn.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As with Project #15, each LED is activated by its own function from ❷ onward.
    After <samp class="SANS_TheSansMonoCd_W5Regular_11">void LED1()</samp>, I’ve compressed
    each function into one line of code to save space. Again, port manipulation greatly
    improves the sketch’s efficiency.'
  prefs: []
  type: TYPE_NORMAL
- en: You can change the delay between each LED’s turning on and off ❶. The sketch
    includes a function to turn off all the LEDs if required for other future projects
    ❸. Once again, to save space, I’ve placed multiple functions on one line ❹, where
    each LED is turned on after a preset delay.
  prefs: []
  type: TYPE_NORMAL
- en: 'The placement of the LEDs in this project may seem random, but you now have
    the skills to create more useful, complicated displays with Charlieplexing, which
    you’ll do in Project #18\. First, however, I’ll show you how to use Charlieplexing
    with an ATtiny85.'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #17: Charlieplexing with the
    ATtiny85</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Using Charlieplexing with an ATtiny85 microcontroller gives you a cheaper and
    smaller-circuit solution for controlling lots of LEDs without external devices.
    This project demonstrates how to control 12 LEDs using the ATtiny85.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the assembled LED circuit from Project #16, as well as either the
    ATtiny85 programming shield from Project #13 in [Chapter 3](chapter3.xhtml) or
    the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ATtiny85 microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 10 µF electrolytic capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two solderless breadboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Male-to-male jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, assemble your ATtiny85 programming setup using the instructions from
    [Chapter 3](chapter3.xhtml) (using Project #13 if you built it), using the programming
    shield or the parts listed for this project, and then upload the code. Next, connect
    your ATtiny85 to the LED circuit, as shown in [Figure 5-6](chapter5.xhtml#fig5-6).
    The LED circuit has different pin connections from those in Project #16 but is
    otherwise the same.'
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #17](../images/fig5-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-6: The schematic for
    Project #17</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, upload the sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once uploaded, this sketch should operate in the same manner as Project #16,
    with each of 12 LEDs lighting up in turn. However, the code sets up the port manipulation
    differently. Since you’re using <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTB</samp>
    pins 3, 2, 1, and 0 (digital D3 to D0) on the ATtiny85, your <samp class="SANS_TheSansMonoCd_W5Regular_11">DDRB</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTB</samp> functions need
    to address bits 0 to 3.'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #18: Building a 30-LED Matrix
    Display</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This project takes Charlieplexing to the next level with a larger, 30-LED circuit
    you can use to display digits or characters of your own design.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s theoretically possible but extremely difficult to build the circuit for
    this project on a pair of solderless breadboards, so I highly recommend downloading
    the PCB files for this project and having your own PCB manufactured. You’ll need
    the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Six 270 Ω, 0.25 W, 1 percent resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thirty 5 mm LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two solderless breadboards or Project #18 PCB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 × 40 2.54 mm inline header pins (if using PCB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 5-7](chapter5.xhtml#fig5-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #18](../images/fig5-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-7: The schematic for
    Project #18</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If you ordered the PCB, assembly is simple. You can see from the layout on the
    board that all the LEDs have the anode pin pointing toward the top and the cathodes
    (the flat side) toward the bottom, as shown in [Figure 5-8](chapter5.xhtml#fig5-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![AN UNPOPULATED PCB FOR PROJECT #18](../images/fig5-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-8: The PCB for Project
    #18</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the resistors first, then the LEDs, followed by the inline header
    pins. Place the pins so they emerge from the rear, and then prop the PCB up with
    jumper wires to the Arduino, or just place the PCB directly into the Arduino itself,
    as shown in [Figure 5-9](chapter5.xhtml#fig5-9). The pins on the PCB are labeled
    with matching Arduino pin numbers on the rear of the PCB.
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE PROJECT #18 PCB COMPLETED AND INSERTED INTO THE ARDUINO UNO](../images/fig5-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-9: The completed Project
    #18 circuit</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 5-3](chapter5.xhtml#tab5-3) is the logic table for Project #18, which
    you can compare with the port manipulations in the sketches for [Listing 5-2](#LiT-5-2)
    and that for Project #18 listed shortly afterward or the schematic in [Figure
    5-7](chapter5.xhtml#fig5-7). Again, for practice, trace the current for various
    LEDs through the schematic and compare with the table to increase your familiarity
    with controlling the LEDs.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/table5-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Before moving on, please make sure your LEDs are working correctly by entering
    and uploading the sketch from [Listing 5-2](#LiT-5-2), which should make each
    LED turn on and off in succession.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-2: Testing the 30-LED
    matrix display</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The sketch sets the delay between each LED lighting up and turning off by defining
    <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> ❶. From ❷ onward, functions
    set the GPIO pin port to control each required pin to activate the LEDs in turn.
    The function ❸ turns all the LEDs off. After that, the main loop endlessly activates
    each LED in turn. I’ve minimized the code spacing for display efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve tested the LEDs, you’re ready to enter and upload the project
    sketch itself. (Rather than typing the code yourself, I recommend you download
    it from the book’s web page, [*https://<wbr>nostarch<wbr>.com<wbr>/arduino<wbr>-arduinians*](https://nostarch.com/arduino-arduinians),
    if you haven’t already done so.) The digits 0 through 9 should appear on the LED
    display in succession and then start again at 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The two-dimensional array ❶ contains 10 arrays, one for each digit from 0 through
    9\. Each digit array has 30 elements, to match the 30 LEDs on the display board.
    The display board’s LEDs are arranged from 1 at the top left to 30 at the bottom
    right. In the arrays, each <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    represents the LEDs that need to turn on in quick succession for each number to
    be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">displayDigits()</samp>
    function ❷ accepts the digit you want to display and the number of times the function
    will display the LEDs required in turn to show the digit. The greater the number
    in the second parameter, the longer the digit will appear on the display. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">displayDigits()</samp> function
    uses another custom function, <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOnLED()</samp>
    ❸, to turn on the required LED. The <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOnLED()</samp>
    function, in turn, uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>
    ❻ to call the appropriate function from the list ❺ and turn on each individual
    LED.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">delay()</samp> function ❹
    within <samp class="SANS_TheSansMonoCd_W5Regular_11">displayDigits()</samp> is
    set to keep each LED on for 1 millisecond before the next is illuminated. Because
    the LEDs flip on and off so quickly, the human eye perceives all the LEDs required
    for a given digit as on at the same time, as shown in [Figure 5-10](chapter5.xhtml#fig5-10).
    You can alter the length of the delay to tailor the display to your own preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>,
    the digits 0 through 9 are displayed in order ❼, with a short delay in between.
    Each digit is displayed using 50 refreshes of the digit ❽.
  prefs: []
  type: TYPE_NORMAL
- en: '![EXAMPLE DISPLAYS WITH PROJECT #18, SHOWING THE NUMERALS 0, 4, AND 7](../images/fig5-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-10: Examples of Project
    #18</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This sketch displays digits using the Monomin font, as shown in [Figure 5-11](chapter5.xhtml#fig5-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![A DEMONSTRATION OF MONOMIN 6X5 PIXEL FONT DIGITS, 0 THROUGH 9](../images/fig5-11.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-11: The Monomin 6×5
    font digits</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about this font by visiting [*https://<wbr>fontstruct<wbr>.com*](https://fontstruct.com)
    and searching for the Monomin 6 × 5 font.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Making Custom Character Displays</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s possible to create display types beyond just the numbers shown in Project
    #18\. To make your own characters, first draw how you would like them to appear
    using some grid paper or a spreadsheet. For example, to create a boundary rectangle,
    draw the diagram shown in [Figure 5-12](chapter5.xhtml#fig5-12).'
  prefs: []
  type: TYPE_NORMAL
- en: '![SPREADSHEET CELLS SHOWING A 5X6 RECTANGLE OF X’S](../images/fig5-12.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-12: Planning the character
    to display</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-left X represents LED 1, and the bottom-right X represents LED 30\.
    You then create your own array that represents the status of each LED. For this
    example, the array would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then add or swap this array into the sketch in the same way as for
    the other digits in Project #18 and use the <samp class="SANS_TheSansMonoCd_W5Regular_11">displayDigits()</samp>
    function to show your custom character on the display, as demonstrated in [Figure
    5-13](chapter5.xhtml#fig5-13).'
  prefs: []
  type: TYPE_NORMAL
- en: '![THE CUSTOM CHARACTER SHOWN ON THE DISPLAY BOARD](../images/fig5-13.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-13: The custom character</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When designing your own custom characters, it can help to use a spreadsheet
    or graph paper to plan the layout of the LEDs you’d like to turn on and off.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Charlieplexing in your toolbox, you can now control multiple LEDs with
    minimal I/O pins and without using external ICs. You learned how to control 2,
    6, 12, or 30 LEDs with a minimum of digital output pins, as well as how to use
    Charlieplexing with the compact ATtiny microcontrollers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn to give your Arduino the power to turn itself
    off.
  prefs: []
  type: TYPE_NORMAL
