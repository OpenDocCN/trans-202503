<html><head></head><body>
<h2 class="h2" id="ch01"><a id="page_1"/><strong><span class="big">1</span></strong><br/><strong>Encryption</strong></h2>
<div class="image1"><img alt="image" src="graphics/common-01.jpg"/></div>
<p class="noindent">We rely on software to protect our data every day, but most of us know little about how this protection works. Why does a “lock” icon in the corner of your browser mean it’s safe to enter your credit card number? How does creating a password for your phone actually protect the data inside? What really prevents other people from logging into your online accounts?</p>
<p class="indent"><em>Computer security</em> is the science of protecting data. In a way, computer security represents technology solving a problem that technology created. Not that long ago, most data wasn’t stored digitally. We had filing cabinets in our offices and shoeboxes of photographs under our beds. Of course, back then you couldn’t easily share your photographs with friends around the world or check your bank balance from a mobile phone, but neither could anyone steal your private data without physically taking it. Today, not only <a id="page_2"/>can you be robbed at a distance, but you might not even know you’ve been robbed—that is, until your bank calls to ask why you are buying thousands of dollars in gift cards.</p>
<p class="indent">Over these first three chapters, we’ll discuss the most important concepts behind computer security. In this chapter, we talk about encryption. By itself, encryption provides us with the capability to lock our data so only <em>we</em> can unlock it. Additional techniques, discussed in the next two chapters, are needed to provide the full security suite that we depend on, but encryption is the core of computer security.</p>
<h3 class="h3" id="ch01lev1sec01"><strong>The Goal of Encryption</strong></h3>
<p class="noindent">Think of a file on your computer: it might contain text, a photograph, a spreadsheet, audio, or video. You want to access the file but keep it secret from everyone else. This is the fundamental problem of computer security. To keep the file secret, you can use <em>encryption</em> to transform it into a new format that is unreadable until the file has been returned to its original form using <em>decryption</em>. The original file is the <em>plaintext</em> (even if the file isn’t text), and the encrypted file is the <em>ciphertext</em>.</p>
<p class="indent">An <em>attacker</em> is someone who attempts to decrypt the ciphertext without authorization. The goal of encryption is to create a ciphertext that is easy for authorized users to decrypt, while practically impossible for attackers to decrypt. “Practically” is the source of many headaches for security researchers. Just as no lock is absolutely unbreakable, no encryption can be absolutely impossible to decrypt. With enough time and enough computing power, any encryption scheme can be broken in theory. The goal of computer security is to make an attacker’s job so difficult that successful attacks are impossible in practice, requiring computing resources beyond an attacker’s means.</p>
<p class="indent">Rather than jump headfirst into the intricacies of software-based encryption, I’ll start this chapter with some simple examples from the pre-software days of codes and spies. Although the strength of encryption has vastly improved over the years, these same classic techniques form the basis of all encryption. Later, you’ll see how these ideas are combined in a modern digital encryption scheme.</p>
<h3 class="h3" id="ch01lev1sec02"><strong>Transposition: Same Data, Different Order</strong></h3>
<p class="noindent">One of the simplest ways to encrypt data is called <em>transposition</em>, which simply means “changing position.” Transposition is the kind of encryption my friends and I used when passing notes in grade school. Because these notes were passed through untrustworthy hands, it was imperative the notes were unintelligible to anyone but us.</p>
<p class="indent">To keep messages secret, we rearranged the order of the letters using a simple, easy-to-reverse scheme. Suppose I needed to share the vital intelligence that CATHY LIKES KEITH (the names have been changed to protect <a id="page_3"/>the innocent). To encrypt the message, I copied every third letter of the plaintext (ignoring any spaces). During the first pass through the message, I copied five letters, as shown in <a href="ch01.html#ch1fig1">Figure 1-1</a>.</p>
<div class="image"><img alt="image" src="graphics/f01-01.jpg"/></div>
<p class="figuret"><a id="ch1fig1"/><em>Figure 1-1: The first pass in the transposition of the sample message</em></p>
<p class="indent">Having reached the end of the message, I started back at the beginning and continued selecting every third remaining letter. The second pass got me to the state shown in <a href="ch01.html#ch1fig2">Figure 1-2</a>.</p>
<div class="image"><img alt="image" src="graphics/f01-02.jpg"/></div>
<p class="figuret"><a id="ch1fig2"/><em>Figure 1-2: The second transposition pass</em></p>
<p class="indent">On the last pass I copied the remaining letters, as shown in <a href="ch01.html#ch1fig3">Figure 1-3</a>.</p>
<div class="image"><img alt="image" src="graphics/f01-03.jpg"/></div>
<p class="figuret"><a id="ch1fig3"/><em>Figure 1-3: The final transposition pass</em></p>
<p class="indent">The resulting ciphertext is CHISIAYKKTTLEEH. My friends could read the message by reversing the transposition process. The first step is shown in <a href="ch01.html#ch1fig4">Figure 1-4</a>. Returning all the letters to their original position reveals the plaintext.</p>
<div class="image"><a id="page_4"/><img alt="image" src="graphics/f01-04.jpg"/></div>
<p class="figuret"><a id="ch1fig4"/><em>Figure 1-4: The first pass in reversing the transposition for decryption</em></p>
<p class="indent">This basic transposition method was fun to use, but it’s terribly weak encryption. The biggest concern is a leak—one of my friends blabbing about the encryption method to someone outside the circle. Once that happens, sending encrypted messages won’t be secure anymore; it will just be more work. Leaks are sadly inevitable—and not just with schoolchildren. Every encryption method is vulnerable to leaks, and the more people use a particular method, the more likely it will leak.</p>
<p class="indent">For this reason, all good encryption systems follow a rule formulated by early Dutch cryptographer Auguste Kerckhoffs, known as <em>Kerckhoffs’s principle</em>: the security of data should not depend on the encryption method remaining a secret.</p>
<h4 class="h4" id="ch01lev2sec01"><strong><em>Cipher Keys</em></strong></h4>
<p class="noindent">This raises an obvious question. If the encryption method is not a secret, how do we securely encrypt data? The answer lies in following a general, publically disclosed encryption method, but varying the encryption of individual messages using a <em>cipher key</em> (or just <em>key</em>). To understand what a key is, let’s examine a more general transposition method.</p>
<p class="indent">In this method, senders and receivers share a secret number prior to sending any messages. Let’s say my friends and I agree on 374. We’ll use this number to alter the transposition pattern in our ciphertexts. This pattern is shown in <a href="ch01.html#ch1fig5">Figure 1-5</a> for the message CATHY LIKES KEITH. The digits of our secret number dictate which letter should be copied from the plaintext to the ciphertext. Because the first digit is 3, the third letter of the plaintext, <em>T</em>, becomes the first letter of the ciphertext. The next digit is 7, so the next letter is the seventh letter after the <em>T</em>, which is <em>S</em>. Next, we select the fourth letter from the <em>S</em>. The first three letters of the ciphertext are <em>TST</em>.</p>
<p class="indent"><a href="ch01.html#ch1fig6">Figure 1-6</a> shows how the next two letters are copied to the ciphertext. Starting from where we left off (indicated by the circled 1 in the figure), we count three positions, returning to the beginning of the plaintext when we reach the end, to select <em>A</em> as the fourth letter of the ciphertext. The next letter chosen is seven positions after the <em>A</em>, skipping letters that have already been copied: the <em>K</em>. The process continues until all of the letters of the plaintext have been transposed.</p>
<div class="image"><a id="page_5"/><img alt="image" src="graphics/f01-05.jpg"/></div>
<p class="figuret"><a id="ch1fig5"/><em>Figure 1-5: The first pass in transposing using the key 374</em></p>
<div class="image"><img alt="image" src="graphics/f01-06.jpg"/></div>
<p class="figuret"><a id="ch1fig6"/><em>Figure 1-6: The second pass in transposing using the key 374</em></p>
<p class="indent">The secret number 374, then, is our cipher key. Someone who intercepts this message won’t be able to decrypt it without the key, even if they understand we’re using a transposition method. The code can be regularly changed to prevent blabbermouths and turncoats from compromising the encryption.</p>
<h4 class="h4" id="ch01lev2sec02"><strong><em>Attacking the Encryption</em></strong></h4>
<p class="noindent">Even without the key, attackers can still try to recover the plaintext through other means. Encrypted data can be attacked through <em>brute force</em>, trying all the possible ways of applying the encryption method to the ciphertext. For a message encrypted using transposition, a brute-force attack would examine all permutations of the ciphertext. Because brute force is almost always an option, the number of trials an attacker will need to find the plaintext is a good baseline for encryption strength. In our example, the message CATHY LIKES KEITH has around 40 billion permutations.</p>
<p class="indent">That’s a huge number, so instead of brute force, a smart attacker would apply some common sense to recover the plaintext faster. If the attacker can assume the plaintext is in English, then most of the permutations can be ruled out before they are tested. For example, the attacker can assume the plaintext won’t start with the letters <em>HT</em> because no English word starts with those letters. That’s a billion permutations the attacker won’t have to check.</p>
<p class="indent"><a id="page_6"/>An attacker with some idea of the words in the message can be even smarter about figuring out the plaintext. In our example, the attacker might guess the message includes the name of a classmate. They can see what names can be formed from the ciphertext letters and then determine what words can be formed from the leftover letters.</p>
<p class="indent">Guesses about the plaintext content are known as <em>cribs</em>. The strongest kind of crib is a <em>known-plaintext attack</em>. To carry out this type of attack, the attacker must have access to a plaintext A, its matching ciphertext A, and a ciphertext B that uses the same cipher key as ciphertext A. Although this scenario sounds unlikely, it does happen. People often leave documents unguarded when they are no longer considered secret without realizing they may aid attacks on other documents. Known-plaintext attacks are power ful; figuring out the transposition pattern is easy when you have both the plaintext and ciphertext in front of you.</p>
<p class="indent">The best defenses against known-plaintext attacks are good security practices, such as regularly changing passwords. Even with the best security practices, though, attackers will almost always have some idea of a plaintext’s contents (that’s why are they so interested in reading it). In many cases, they will know most of the plaintext and may have access to known plaintext-ciphertext pairs. A good encryption system should render cribs and known plaintexts useless to attackers.</p>
<h3 class="h3" id="ch01lev1sec03"><strong>Substitution: Replacing Data</strong></h3>
<p class="noindent">The other fundamental encryption technique is more resistant to cribs. Instead of moving the data around, <em>substitution</em> methods systematically replace individual pieces of data. With text messages, the simplest form of substitution replaces every occurrence of one letter with another letter. For example, every <em>A</em> becomes a <em>D</em>, every <em>B</em> an <em>H</em>, and so on. A key for this type of encryption looks like <a href="ch01.html#ch1tab1">Table 1-1</a>.</p>
<p class="tablet"><a id="ch1tab1"/><strong>Table 1-1:</strong> A Substitution Cipher Key</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="100%">
<tbody>
<tr>
<td class="table" valign="top"><p class="table">Original</p></td>
<td class="table" valign="top"><p class="table">A</p></td>
<td class="table" valign="top"><p class="table">B</p></td>
<td class="table" valign="top"><p class="table">C</p></td>
<td class="table" valign="top"><p class="table">D</p></td>
<td class="table" valign="top"><p class="table">E</p></td>
<td class="table" valign="top"><p class="table">F</p></td>
<td class="table" valign="top"><p class="table">G</p></td>
<td class="table" valign="top"><p class="table">H</p></td>
<td class="table" valign="top"><p class="table">I</p></td>
<td class="table" valign="top"><p class="table">J</p></td>
<td class="table" valign="top"><p class="table">K</p></td>
<td class="table" valign="top"><p class="table">L</p></td>
<td class="table" valign="top"><p class="table">M</p></td>
<td class="table" valign="top"><p class="table">N</p></td>
<td class="table" valign="top"><p class="table">O</p></td>
<td class="table" valign="top"><p class="table">P</p></td>
<td class="table" valign="top"><p class="table">Q</p></td>
<td class="table" valign="top"><p class="table">R</p></td>
<td class="table" valign="top"><p class="table">S</p></td>
<td class="table" valign="top"><p class="table">T</p></td>
<td class="table" valign="top"><p class="table">U</p></td>
<td class="table" valign="top"><p class="table">V</p></td>
<td class="table" valign="top"><p class="table">W</p></td>
<td class="table" valign="top"><p class="table">X</p></td>
<td class="table" valign="top"><p class="table">Y</p></td>
<td class="table" valign="top"><p class="table">Z</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">Replacement</p></td>
<td class="table" valign="top"><p class="table">M</p></td>
<td class="table" valign="top"><p class="table">N</p></td>
<td class="table" valign="top"><p class="table">B</p></td>
<td class="table" valign="top"><p class="table">V</p></td>
<td class="table" valign="top"><p class="table">C</p></td>
<td class="table" valign="top"><p class="table">X</p></td>
<td class="table" valign="top"><p class="table">Z</p></td>
<td class="table" valign="top"><p class="table">L</p></td>
<td class="table" valign="top"><p class="table">K</p></td>
<td class="table" valign="top"><p class="table">F</p></td>
<td class="table" valign="top"><p class="table">H</p></td>
<td class="table" valign="top"><p class="table">G</p></td>
<td class="table" valign="top"><p class="table">J</p></td>
<td class="table" valign="top"><p class="table">D</p></td>
<td class="table" valign="top"><p class="table">S</p></td>
<td class="table" valign="top"><p class="table">A</p></td>
<td class="table" valign="top"><p class="table">P</p></td>
<td class="table" valign="top"><p class="table">O</p></td>
<td class="table" valign="top"><p class="table">I</p></td>
<td class="table" valign="top"><p class="table">U</p></td>
<td class="table" valign="top"><p class="table">Y</p></td>
<td class="table" valign="top"><p class="table">T</p></td>
<td class="table" valign="top"><p class="table">R</p></td>
<td class="table" valign="top"><p class="table">E</p></td>
<td class="table" valign="top"><p class="table">W</p></td>
<td class="table" valign="top"><p class="table">Q</p></td>
</tr>
</tbody>
</table>
<p class="indent">Although <em>simple substitution</em>, as this method is called, is an improvement over transposition, it too has problems: there are only so many possible substitutions, so an attacker can sometimes decrypt ciphertext through brute force.</p>
<p class="indent">Simple substitution is also vulnerable to <em>frequency analysis</em>, in which an attacker applies knowledge of how often letters or letter combinations occur in a given language. Stated broadly, knowing how often data items are likely to appear in a plaintext gives the attacker an advantage. For example, the letter <em>E</em> is the most common letter in English writing, and <em>TH</em> is the most common letter pair. Therefore, the most frequently occurring letter in a long ciphertext is likely to represent plaintext <em>E</em>, and the most frequently occurring letter pair is likely to represent plaintext <em>TH</em>.</p>
<p class="indent"><a id="page_7"/>The power of frequency analysis means that substitution encryption becomes more vulnerable as the text grows longer. Attacks are also easier when a collection of ciphertexts is known to have been encrypted with the same key; avoiding such <em>key reuse</em> is an important security practice.</p>
<h4 class="h4" id="ch01lev2sec03"><strong><em>Varying the Substitution Pattern</em></strong></h4>
<p class="noindent">To strengthen encryption against frequency analysis, we can vary the substitution pattern during encryption, so the first <em>E</em> in the plaintext might be replaced with <em>A</em>, but the second <em>E</em> in the plaintext is replaced with a <em>T</em>. This technique is known as <em>polyalphabetic substitution</em>. One method of polyalphabetic substitution uses a grid of alphabets known as a <em>tabula recta</em>, shown in <a href="ch01.html#ch1fig7">Figure 1-7</a>. In this table, each row and column is labeled with the letter of the alphabet that starts the row or column. Every location in the grid is located with two letters, such as row D, column H, which contains the letter <em>K</em>.</p>
<div class="image"><img alt="image" src="graphics/f01-07.jpg"/></div>
<p class="figuret"><a id="ch1fig7"/><em>Figure 1-7: A tabula recta—the shaded first column and row are labels.</em></p>
<p class="indent">When using a tabula recta, the key is textual—letters are used to vary the encryption instead of numbers, as we used in our transposition example. <a id="page_8"/>The letters of the plaintext select rows in the tabula recta, and the letters of the key select columns. For example, suppose our plaintext message is the word <em>SECRET</em>, and our encryption key is the word <em>TOUGH</em>. Because the first letter of the plaintext is <em>S</em> and the first letter of the key is <em>T</em>, the first letter of the ciphertext is found at row S, column T in the tabula recta: the letter <em>L</em>. We then use the O column of the table to encrypt the second plaintext letter <em>E</em> (resulting in <em>S</em>), and so on, as shown in <a href="ch01.html#ch1fig8">Figure 1-8</a>. Because the plaintext is longer than the key, we must reuse the first letter of the key.</p>
<div class="image"><img alt="image" src="graphics/f01-08.jpg"/></div>
<p class="figuret"><a id="ch1fig8"/><em>Figure 1-8: Encryption using the tabula recta and cipher key</em> TOUGH</p>
<p class="indent">Decryption reverses the process, as shown in <a href="ch01.html#ch1fig9">Figure 1-9</a>. The letters in the key indicate the columns, which are scanned to find the corresponding letter in the ciphertext. The row where the ciphertext letter is found indicates the plaintext letter. In our example, the first letter of our key is <em>T</em>, and the first letter of the ciphertext is <em>L</em>. We scan the T column of the tabula recta to find <em>L</em>; because <em>L</em> appears in row S, the plaintext letter is <em>S</em>. The process repeats for every letter of the ciphertext.</p>
<div class="image"><img alt="image" src="graphics/f01-09.jpg"/></div>
<p class="figuret"><a id="ch1fig9"/><em>Figure 1-9: Decryption using the tabula recta and cipher key</em> TOUGH</p>
<p class="indent"><a id="page_9"/>Polyalphabetic substitution is more effective than simple substitution because it varies the substitution pattern throughout the message. In our example, the two occurrences of <em>E</em> in the plaintext become different ciphertext letters, and the two occurrences of <em>L</em> in the ciphertext represent two different plaintext letters.</p>
<h4 class="h4" id="ch01lev2sec04"><strong><em>Key Expansion</em></strong></h4>
<p class="noindent">Although polyalphabetic substitution is a great improvement over simple substitution, it’s effective only when the key isn’t repeated too often; otherwise it has the same problems as simple substitution. With a key length of five, for example, each plaintext letter would be represented by only five different ciphertext letters, leaving long ciphertexts vulnerable to frequency analysis and cribs. An attacker would have to work harder, but given enough ciphertext to work with, an attacker could still break the encryption.</p>
<p class="indent">For maximum effectiveness, we need encryption keys that are as long as the plaintext, a technique known as a <em>one-time pad</em>. But that’s not a practical solution for most situations. Instead, a method called <em>key expansion</em> allows short keys to do the work of longer ones. One implementation of this idea frequently appears in spy novels. Instead of sharing a super-long key, two spies who need to exchange messages agree on a <em>code book</em>, which is used as a repository of long keys. To avoid arousing suspicion, the code book is an ordinary piece of literature, like a specific edition of Shakespeare’s plays.</p>
<p class="indent">Let’s suppose a 50-letter message will be sent using this scheme. In addition to the ciphertext, the message sender also appends the unexpanded key. Using the works of Shakespeare as the code book, the unexpanded key might be 2.2.4.9. The first 2 indicates the second of Shakespeare’s plays when listed alphabetically (<em>As You Like It</em>). The second 2 means Act II of the play. The 4 means Scene 4 of that act. The 9 means the ninth sentence of that scene in the specified edition: “When I was at home, I was in a better place, but travelers must be content.” The number of letters in this sentence exceeds the number in the plaintext and could be used for encryption and decryption using a tabula recta as before. In this way, a relatively short key can be expanded to fit a particular message.</p>
<p class="indent">Note that this scheme doesn’t qualify as a one-time pad because the code book is finite, and therefore the sentence-keys would have to be reused eventually. But it does mean our spies only have to remember short cipher keys while encrypting their messages more securely with longer keys. As you’ll see, the key expansion concept is important in computer encryption because the cipher keys required are huge but need to be stored in smaller forms.</p>
<h3 class="h3" id="ch01lev1sec04"><strong>The Advanced Encryption Standard</strong></h3>
<p class="noindent">Now that we’ve seen how transposition, substitution, and key expansion work individually, let’s see how secure digital encryption results from a careful combination of all three techniques.</p>
<p class="indent"><a id="page_10"/>The <em>Advanced Encryption Standard (AES)</em> is an open standard, which means the specifications may be implemented by anyone without paying a license fee. Whether you realize it or not, much of your data is protected by AES. If you have a secure wireless network at your home or office, if you have ever password-protected a file in a <em>.zip</em> archive, or if you use a credit card at a store or make a withdrawal from an ATM, you are probably relying, at least in part, on AES.</p>
<h4 class="h4" id="ch01lev2sec05"><strong><em>Binary Basics</em></strong></h4>
<p class="noindent">Up to now, I’ve used text encryption samples to keep the examples simple. The data encrypted by computers, though, is represented in the form of binary numbers. If you haven’t worked with these numbers before, here’s an introduction.</p>
<h5 class="h5" id="ch01lev3sec01"><strong>Decimal Versus Binary</strong></h5>
<p class="noindent">The number system we all grew up with is called the <em>decimal</em> system, <em>deci</em> meaning “ten,” because the system uses 10 digits, 0 through 9. Each digit in a number represents the quantity of a unit 10 times greater than the digit to its right. The units and quantities for the decimal number 23,065 are shown in <a href="ch01.html#ch1fig10">Figure 1-10</a>. The 2 in the fifth position from the left means we have 2 “ten thousands,” for example, and the 6 means 6 “tens.”</p>
<div class="image"><img alt="image" src="graphics/f01-10.jpg"/></div>
<p class="figuret"><a id="ch1fig10"/><em>Figure 1-10: Each digit in the decimal number 23,065 represents a different unit quantity.</em></p>
<p class="indent">In the <em>binary</em> number system, there are only two possible digits, 0 or 1, which are called <em>bits</em>, for <em>bi</em>nary digi<em>ts</em>. Each bit in a binary number represents a unit twice as large as the bit to the right. The units and quantities for the binary number 110101 are shown in <a href="ch01.html#ch1fig11">Figure 1-11</a>. As shown, we have one of each of the following units: 32, 16, 4, and 1. Therefore, the binary number 110101 represents the sum of these four unit values, which is the decimal number 53.</p>
<div class="image"><img alt="image" src="graphics/f01-11.jpg"/></div>
<p class="figuret"><a id="ch1fig11"/><em>Figure 1-11: Each bit in the binary number 110101 represents a different unit quantity.</em></p>
<p class="indent">Binary numbers are often written with a fixed number of bits. The most common length for a binary number is eight bits, known as a <em>byte</em>. Although the decimal number 53 can be written as 110101 in binary, writing 53 as a byte requires eight bits, so leading 0 bits fill out the other positions to make 00110101. The smallest byte value, 00000000, represents decimal 0; the largest possible byte, 11111111, represents decimal 255.</p>
<h5 class="h5" id="ch01lev3sec02"><a id="page_11"/><strong>Bitwise Operations</strong></h5>
<p class="noindent">Along with the usual mathematical operations such as addition and multiplication, software also uses some operations unique to binary numbers. These are known as <em>bitwise operations</em> because they are applied individually to each bit rather than to the binary number as whole.</p>
<p class="indent">The bitwise operation known as <em>exclusive-or</em>, or <em>XOR</em>, is common in encryption. When two binary numbers are XORed together, the 1s in the second number flip the corresponding bits in the first number, as shown in <a href="ch01.html#ch1fig12">Figure 1-12</a>.</p>
<div class="image"><img alt="image" src="graphics/f01-12.jpg"/></div>
<p class="figuret"><a id="ch1fig12"/><em>Figure 1-12: The exclusive-or (XOR) operation. The 1 bits in the second byte indicate which bits are “flipped” in the first byte, as shown in the shaded columns.</em></p>
<p class="indent">Remember, encryption must be reversible. XOR alters the bit patterns in a way that’s impossible to predict without knowing the binary numbers involved, but it’s easily reversed. XORing the result with the second number flips the same bits back to their original state, as shown in <a href="ch01.html#ch1fig13">Figure 1-13</a>.</p>
<div class="image"><img alt="image" src="graphics/f01-13.jpg"/></div>
<p class="figuret"><a id="ch1fig13"/><em>Figure 1-13: If we XOR a byte with the same byte twice, we’re back to where we started.</em></p>
<h5 class="h5" id="ch01lev3sec03"><strong>Converting Data to Binary Form</strong></h5>
<p class="noindent">Computers use binary numbers to represent all kinds of data. A plaintext file could be a text message, a spreadsheet, an image, an audio file, or anything else—but in the end, every file is a sequence of bytes. Most computer <a id="page_12"/>data is already numeric and can therefore be directly converted into binary numbers. In some cases, though, a special encoding system is needed to convert non-numeric data into binary form.</p>
<p class="indent">For example, to see how a text message becomes a sequence of bytes, consider this message:</p>
<pre><span class="codestrong">Send more money!</span></pre>
<p class="indent">This message has 16 characters, counting the letters, spaces, and exclamation point. We can turn each character into a byte using a system such as the <em>American Standard Code for Information Interchange</em>, which is always referred to by its acronym, <em>ASCII</em>, pronounced “as-key”. In ASCII, capital <em>A</em> is represented by the number 65, <em>B</em> by 66, and so on, through 90 for <em>Z</em>. <a href="ch01.html#ch1tab2">Table 1-2</a> shows some selected entries from the ASCII table.</p>
<p class="tablet"><a id="ch1tab2"/><strong>Table 1-2:</strong> Selected Entries from the ASCII Table</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="80%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Character</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Decimal number</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Binary byte</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table">(space)</p></td>
<td class="table" valign="top"><p class="table">32</p></td>
<td class="table" valign="top"><p class="table">00100000</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">!</p></td>
<td class="table" valign="top"><p class="table">33</p></td>
<td class="table" valign="top"><p class="table">00100001</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">,</p></td>
<td class="table" valign="top"><p class="table">44</p></td>
<td class="table" valign="top"><p class="table">00101100</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">.</p></td>
<td class="table" valign="top"><p class="table">46</p></td>
<td class="table" valign="top"><p class="table">00101110</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">A</p></td>
<td class="table" valign="top"><p class="table">65</p></td>
<td class="table" valign="top"><p class="table">01000001</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">B</p></td>
<td class="table" valign="top"><p class="table">66</p></td>
<td class="table" valign="top"><p class="table">01000010</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">C</p></td>
<td class="table" valign="top"><p class="table">67</p></td>
<td class="table" valign="top"><p class="table">01000011</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">D</p></td>
<td class="table" valign="top"><p class="table">68</p></td>
<td class="table" valign="top"><p class="table">01000100</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">E</p></td>
<td class="table" valign="top"><p class="table">69</p></td>
<td class="table" valign="top"><p class="table">01000101</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">a</p></td>
<td class="table" valign="top"><p class="table">97</p></td>
<td class="table" valign="top"><p class="table">01100001</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">b</p></td>
<td class="table" valign="top"><p class="table">98</p></td>
<td class="table" valign="top"><p class="table">01100010</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">c</p></td>
<td class="table" valign="top"><p class="table">99</p></td>
<td class="table" valign="top"><p class="table">01100011</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">d</p></td>
<td class="table" valign="top"><p class="table">100</p></td>
<td class="table" valign="top"><p class="table">01100100</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">e</p></td>
<td class="table" valign="top"><p class="table">101</p></td>
<td class="table" valign="top"><p class="table">01100101</p></td>
</tr>
</tbody>
</table>
<h4 class="h4" id="ch01lev2sec06"><strong><em>AES Encryption: The Big Picture</em></strong></h4>
<p class="noindent">Before we examine the details of AES encryption, here’s an overview of the process.</p>
<p class="indent">Cipher keys in AES are binary numbers. The size of the key can vary, but we’ll discuss the simplest version of AES, which uses a 128-bit key. Using mathematical key expansion, AES transforms the original 128-bit key into eleven 128-bit keys.</p>
<p class="indent">AES divides plaintext data into blocks of 16 bytes in a 4×4 grid; the grid for the sample message <em>Send more money!</em> is shown in <a href="ch01.html#ch1fig14">Figure 1-14</a>. Heavy lines separate the 16 bytes, and light lines separate the bits within the bytes.</p>
<div class="image"><a id="page_13"/><img alt="image" src="graphics/f01-14.jpg"/></div>
<p class="figuret"><a id="ch1fig14"/><em>Figure 1-14: The sample message</em> Send more money! <em>transformed into a grid of bytes, ready for encryption using AES</em></p>
<p class="indent">The plaintext data is divided into as many 16-byte blocks as necessary. If the last block isn’t full, the rest of the block is padded with random binary numbers.</p>
<p class="indent">AES then subjects each 16-byte block of plaintext data to 10 <em>rounds</em> of encryption. During a round, the bytes are transposed within the block and substituted using a table. Then, using the XOR operation, the bytes in the block are combined with each other and with one of the 128-bit keys.</p>
<p class="indent">That’s AES in a nutshell; now let’s look at some of these steps in more detail.</p>
<h4 class="h4" id="ch01lev2sec07"><strong><em>Key Expansion in AES</em></strong></h4>
<p class="noindent">Key expansion in a digital encryption system is a bit different than the “code book” concept we discussed earlier. Instead of just looking up a longer key in a book, AES expands the key using the same tools it will later use for the encryption itself: the binary XOR operation, transposition, and simple substitution.</p>
<p class="indent"><a href="ch01.html#ch1fig15">Figure 1-15</a> shows the first few stages of the key expansion process. Each of the blocks in the figure is 32 bits, and one row in this figure represents one 128-bit key. The original 128-bit key makes up the first four blocks, which are shaded in the figure. Every other block is the result of an XOR between two previous blocks; the XOR operation is represented by a plus sign in a circle. Block 6, for example, results from the XOR of Block 2 and Block 5.</p>
<div class="image"><img alt="image" src="graphics/f01-15.jpg"/></div>
<p class="figuret"><a id="ch1fig15"/><em>Figure 1-15: Key expansion process for AES</em></p>
<p class="indent">As you can see on the right of the figure, every fourth block passes through a box labeled “Extra Scrambling.” This process includes transposing the bytes inside the block and substituting each byte according to a table called the <em>S-box</em>.</p>
<p class="indent"><a id="page_14"/>The S-box table, which is used both in the key expansion and later in the encryption itself, is carefully designed to amplify differences in the plaintext. That is, two plaintext bytes that are similar will tend to have S-box replacements that are quite different. The first eight entries from the table are shown in <a href="ch01.html#ch1tab3">Table 1-3</a>.</p>
<p class="tablet"><a id="ch1tab3"/><strong>Table 1-3:</strong> Excerpts from the S-Box Table</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="70%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Original bit pattern</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Replacement bit pattern</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table">00000000</p></td>
<td class="table" valign="top"><p class="table">01100011</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">00000001</p></td>
<td class="table" valign="top"><p class="table">01111100</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">00000010</p></td>
<td class="table" valign="top"><p class="table">01110111</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">00000011</p></td>
<td class="table" valign="top"><p class="table">01111011</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">00000100</p></td>
<td class="table" valign="top"><p class="table">11110010</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">00000101</p></td>
<td class="table" valign="top"><p class="table">01101011</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">00000110</p></td>
<td class="table" valign="top"><p class="table">01101111</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">00000111</p></td>
<td class="table" valign="top"><p class="table">11000101</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">00001000</p></td>
<td class="table" valign="top"><p class="table">00110000</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">00001001</p></td>
<td class="table" valign="top"><p class="table">00000001</p></td>
</tr>
</tbody>
</table>
<h4 class="h4" id="ch01lev2sec08"><strong><em>AES Encryption Rounds</em></strong></h4>
<p class="noindentb">Once AES has all the required keys, the real encryption can begin. Recall that the binary plaintext is stored in a grid of 16 bytes or 128 bits, which is the same size as the original key. This is not a coincidence. The first step of the actual encryption is to XOR the 128-bit data grid with the original 128-bit key. Now the work begins in earnest, as the data grid is subjected to 10 rounds of number crunching. There are four steps in each round.</p>
<p class="order"><strong>1. Substitution.</strong></p>
<p class="orderp">Each of the 16 bytes in the grid is replaced using the same S-box table used in the key expansion process.</p>
<p class="order"><strong>2. Row Transposition.</strong></p>
<p class="orderp">Next, the bytes are moved to different positions within their row in the grid.</p>
<p class="order"><strong>3. Column Combination.</strong></p>
<p class="orderp">Next, for each byte in the grid, a new byte is calculated from a combination of all four bytes in that column. This computation involves the XOR operation again, but also a binary form of transposition. To give you the flavor of the process, <a href="ch01.html#ch1fig16">Figure 1-16</a> shows the computation of the leftmost byte in the lowest row. The four bytes of the leftmost column are XORed together, but the top and bottom bytes in the column have their bits transposed first. This kind of transposition is known as <em>bitwise rotation</em>; the bits slide one position to the left, with the leftmost bit moving over to the right end.</p>
<p class="orderpi"><a id="page_15"/>Every byte in the new grid is computed in a similar way, by combining the bytes in the column using XOR; the only variation is which bytes have their bits rotated before the XOR.</p>
<div class="image"><img alt="image" src="graphics/f01-16.jpg"/></div>
<p class="figuret"><a id="ch1fig16"/><em>Figure 1-16: One part of the column-scrambling step in an AES round</em></p>
<p class="order"><strong>4. XOR with Cipher Key.</strong></p>
<p class="orderp">Finally, the grid that results from the previous step is XORed with the key for that round. This is why key expansion is needed, so that each round XORs with a different key.</p>
<p class="indentt">The AES decryption process performs the same steps as the encryption process, in reverse. Because the only operations in the encryption are XORs, simple substitution from the S-box, and transpositions of bits and bytes, everything is reversible if the key is known.</p>
<h4 class="h4" id="ch01lev2sec09"><strong><em>Block Chaining</em></strong></h4>
<p class="noindent">AES encryption could be applied individually to each 16-byte block in a file, but this would create vulnerabilities in the ciphertext. As we’ve discussed, the more times an encryption key is used, the more likely it is that attackers will discover and exploit patterns. Computer files are often enormous, and using the same key to encrypt millions of blocks is a form of large-scale key reuse that exposes the ciphertext to frequency analysis and related techniques.</p>
<p class="indent">For this reason, block-based encryption systems like AES are modified so that identical blocks in plaintext produce different ciphertext blocks. One such modification is called <em>block chaining</em>.</p>
<p class="indent">When block chaining, the first block of the plaintext is XORed with a random 128-bit number before encryption. This random number is called the <em>starting variable</em> and is stored along with the ciphertext. Because each <a id="page_16"/>encryption is assigned a random starting variable, two files that begin with the same data will have different ciphertexts even when encrypted with the same key.</p>
<p class="indent">Every subsequent plaintext block is XORed with the previous ciphertext block before encryption, “chaining” the encryption as shown in <a href="ch01.html#ch1fig17">Figure 1-17</a>. Chaining ensures that duplicate blocks in a plaintext will result in different ciphertext blocks. This means files of any length can be encrypted without fear of frequency analysis.</p>
<div class="image"><img alt="image" src="graphics/f01-17.jpg"/></div>
<p class="figuret"><a id="ch1fig17"/><em>Figure 1-17: AES encryption using block chaining</em></p>
<h4 class="h4" id="ch01lev2sec10"><strong><em>Why AES Is Secure</em></strong></h4>
<p class="noindent">As you can see, although AES contains many steps, each individual step is just transposition or simple substitution. Why is AES considered strong enough to protect the world’s data? Remember, attackers use brute force or cribs, or exploit patterns in the ciphertext. AES has excellent defenses against all of these attack methods.</p>
<p class="indent">With AES, brute force means running the ciphertext through the decryption process with every possible key until the plaintext is produced. In AES, keys have 128, 192, or 256 bits. Even the smallest key size offers around 300,000,000,000,000,000,000,000,000,000,000,000,000 possible keys, and a brute-force attack would need to try about half of these before it could expect to hit the right one. An attacker with a computer that could try a million keys per second could, in a day, try 1,000,000 keys × 60 seconds × 60 minutes × 24 hours = 86,400,000,000 keys. In a year, the attacker could try 31,536,000,000,000 keys. Although that’s a large number, it’s not even a billionth of a billionth of the possible combinations. An attacker might acquire more computing power, but trying that many keys still doesn’t seem feasible—and that’s just for the 128-bit version.</p>
<p class="indent">AES also makes using cribs or finding exploitable patterns difficult. During each encryption round, AES rotates the bytes in each row of the grid and combines the bytes in each column. After many rounds of this, the bytes are thoroughly mixed together so the final value of any one byte in the ciphertext grid depends on the initial plaintext values of all the bytes in a grid. This encryption property is called <em>diffusion</em>.</p>
<p class="indent"><a id="page_17"/>Furthermore, passing the bytes through the S-box, round after round, amplifies the effect of diffusion, and block chaining passes the diffusion effects of each block on to the next. Together, these operations give AES the <em>avalanche</em> property, in which small changes in the plaintext result in sweeping changes throughout the ciphertext.</p>
<p class="indent">AES thwarts attackers no matter how much they know about the general layout of the plaintext. For example, a company may send emails to customers based on a common template, in which the only variables are the customers’ account numbers and outstanding balances. With diffusion, avalanches, and block chaining, the ciphertexts of these emails will be very different. Diffusion and avalanches also reduce patterns that could be exploited through frequency analysis. Even a huge plaintext file consisting of the same 16-byte block repeated over and over would result in a random-looking jumble of bits when run through AES encryption with block chaining.</p>
<h4 class="h4" id="ch01lev2sec11"><strong><em>Possible AES Attacks</em></strong></h4>
<p class="noindent">AES appears to be strong against conventional encryption attacks, but are there hidden weaknesses that offer shortcuts to finding the right cipher key? The answer is unclear because proving a negative is difficult. Stating that no shortcuts, or <em>cracks</em>, are known to exist is one thing; proving they <em>couldn’t</em> exist is another. Cryptography is a science, and science is always expanding its boundaries. We simply don’t understand cryptography and its underlying mathematics to a point where we can say what’s impossible.</p>
<p class="indent">Part of the difficulty in analyzing the vulnerabilities of an open standard like AES is that programmers implementing the standard in code may unwittingly introduce security flaws. For example, some AES implementations are vulnerable to a <em>timing attack</em>, in which an attacker gleans information about the data being encrypted by measuring how long the encryption takes. The attacker must have access to the specific computer on which the encryption is performed, however, so this isn’t really a flaw in the underlying encryption, but that’s no comfort if security is compromised.</p>
<p class="indent">The best-understood vulnerability of AES is known as a <em>related-key attack</em>. When two keys are mathematically related in a specific way, an attacker can sometimes use knowledge gathered from messages encrypted using one key to recover a message encrypted using the other key. Researchers have discovered a way to recover the AES encryption key for a particular ciphertext in less time than a brute-force attack, but the method requires ciphertexts of the same plaintext encrypted with keys that are related to the original key in very specific ways.</p>
<p class="indent">Although this shortcut counts as a crack, it may not be of practical value to attackers. First of all, although it greatly reduces the amount of work to recover the original key, it may not be feasible for any existing computer or network of computers. Second, it’s not easy to obtain the other ciphertexts that have been encrypted with the related keys; it requires a breakdown in the implementation or use of the cipher. Therefore, this crack is currently considered theoretical, not a practical weakness of the system.</p>
<p class="indent"><a id="page_18"/>Perhaps the most worrying aspect of this crack is that it’s believed to work only for the supposedly stronger 256-bit-key version of AES, not the simpler 128-bit-key version described in this chapter. This demonstrates perhaps the greatest weakness of modern encryption techniques: their complexity. Flaws can go undetected for years despite the efforts of expert reviewers; small changes in the design can have large ramifications for security; and features intended to increase security may have the opposite effect.</p>
<h3 class="h3" id="ch01lev1sec05"><strong>The Limits of Private-Key Encryption</strong></h3>
<p class="noindent">The real limitation of an encryption method like AES, though, has nothing to do with a potential hidden flaw.</p>
<p class="indent">All the encryption methods in this chapter, AES included, are known as <em>symmetric-key</em> methods—this means the key that encrypts a message or file is the same key that is used to decrypt it. If you want to use AES to encrypt a file on your desktop’s hard drive or the contact list in your phone, that’s not a problem; only you are locking and unlocking the data. But what happens when you need to secure a data transmission, as when you enter your credit card number on a retail website? You could encrypt the data with AES and send it to the website, but the software on the website couldn’t decrypt the ciphertext without the key.</p>
<p class="indent">This is the <em>shared key problem</em>, and it’s one of the central problems of cryptography. Without a secure way to share keys, symmetric key encryption, by itself, is only useful for locking one’s own private data. Encrypting data for transmission requires a different approach, using different keys for encryption and decryption—you’ll see how this is done in <a href="ch03.html#ch03">Chapter 3</a>.</p>
<p class="indent">But there’s another problem we need to tackle first. AES requires an enormous binary number as a key, but users can’t be expected to memorize a string of 128 bits. Instead, we memorize passwords. As it turns out, the secure storage and use of passwords presents its own quandaries. Those are the subject of the next chapter.</p>
</body></html>