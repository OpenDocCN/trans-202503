<html><head></head><body>
<h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_35"/><strong><span class="big">3</span></strong><br/><strong>VEHICLE COMMUNICATION WITH SOCKETCAN</strong></h2>&#13;
<div class="image1"><img src="graphics/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">When you begin using a CAN for vehicle communications, you may well find it to be a hodgepodge of different drivers and software utilities. The ideal would be to unify the CAN tools and their different interfaces into a common interface so we could easily share information between tools.</p>&#13;
<p class="indent">Luckily, there’s a set of tools with a common interface, and it’s free! If you have Linux or install Linux on a virtual machine (VM), you already have this interface. The interface, called SocketCAN, was created on the Open Source development site BerliOS in 2006. Today, the term <em>SocketCAN</em> is used to refer to the implementation of CAN drivers as network devices, like Ethernet cards, and to describe application access to the CAN bus via the network socket–programming interface. In this chapter we’ll set up SocketCAN so that we’re more easily able to communicate with the vehicle.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_36"/>Volkswagen Group Research contributed the original SocketCAN implementation, which supports built-in CAN chips and card drivers, external USB and serial CAN devices, and virtual CAN devices. The <span class="literal">can-utils</span> package provides several applications and tools to interact with the CAN network devices, CAN-specific protocols, and the ability to set up a virtual CAN environment. In order to test many of the examples in this book, install a recent version in a Linux VM on your system. The newest versions of Ubuntu have <span class="literal">can-utils</span> in their standard repositories.</p>&#13;
<p class="indent">SocketCAN ties into the Linux networking stack, which makes it very easy to create tools to support CAN. SocketCAN applications can use standard C socket calls with a custom network protocol family, <span class="literal">PF_CAN</span>. This functionality allows the kernel to handle CAN device drivers and to interface with existing networking hardware to provide a common interface and user-space utilities.</p>&#13;
<p class="indent"><a href="ch03.html#ch3fig1">Figure 3-1</a> compares the implementation of traditional CAN software with that of a unified SocketCAN.</p>&#13;
<div class="image"><img src="graphics/f03-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch3fig1"/><em>Figure 3-1: SocketCAN layout (left) and traditional CAN software (right)</em></p>&#13;
<p class="indent">With traditional CAN software, the application has its own protocol that typically talks to a character device, like a serial driver, and then the actual hardware driver. On the left of the figure, SocketCAN is implemented in the Linux kernel. By creating its own CAN protocol family, SocketCAN can integrate with the existing network device drivers, thus enabling applications to treat a CAN bus interface as if it’s a generic network interface.</p>&#13;
<h3 class="h3" id="ch03lev1sec1"><strong>Setting Up can-utils to Connect to CAN Devices</strong></h3>&#13;
<p class="noindent">In order to install <span class="literal">can-utils</span>, you must be running a Linux distribution from 2008 or later or one running the 2.6.25 Linux kernel or higher. First we’ll install <span class="literal">can-utils</span>, then cover how to configure it for your particular setup.</p>&#13;
<h4 class="h4" id="ch03lev2sec1"><span epub:type="pagebreak" id="page_37"/><strong><em>Installing can-utils</em></strong></h4>&#13;
<p class="noindent">You should be able to use your package manager to install <span class="literal">can-utils</span>. Here’s a Debian/Ubuntu example:</p>&#13;
<p class="programs">$ <span class="codestrong">sudo apt-get install can-utils</span></p>&#13;
<p class="indent">If you don’t have <span class="literal">can-utils</span> in your package manager, install it from source with the <span class="literal">git</span> command:</p>&#13;
<p class="programs">$ <span class="codestrong">git clone https://github.com/linux-can/can-utils</span></p>&#13;
<p class="indent">As of this writing, <span class="literal">can-utils</span> has <em>configure</em>, <em>make</em>, and <em>make install</em> files, but in older versions, you’d just enter <span class="literal">make</span> to install from source.</p>&#13;
<h4 class="h4" id="ch03lev2sec2"><strong><em>Configuring Built-In Chipsets</em></strong></h4>&#13;
<p class="noindentb">The next step depends on your hardware. If you’re looking for a CAN sniffer, you should check the list of supported Linux drivers to ensure your device is compatible. As of this writing, the Linux built-in CAN drivers support the following chipsets:</p>&#13;
<p class="bull">• Atmel AT91SAM SoCs</p>&#13;
<p class="bull">• Bosch CC770</p>&#13;
<p class="bull">• ESD CAN-PCI/331 cards</p>&#13;
<p class="bull">• Freescale FlexCAN</p>&#13;
<p class="bull">• Freescale MPC52xx SoCs (MSCAN)</p>&#13;
<p class="bull">• Intel AN82527</p>&#13;
<p class="bull">• Microchip MCP251x</p>&#13;
<p class="bull">• NXP (Philips) SJA1000</p>&#13;
<p class="bull">• TI’s SoCs</p>&#13;
<p class="indentt">CAN controllers, like the SJA1000, are usually built into ISA, PCI, and PCMCIA cards or other embedded hardware. For example, the EMS PCMCIA card driver implements access to its SJA1000 chip. When you insert the EMS PCMCIA card into a laptop, the <span class="literal">ems_pcmcia</span> module loads into the kernel, which then requires the <span class="literal">sja1000</span> module and the <span class="literal">can_dev</span> module to be loaded. The <span class="literal">can_dev</span> module provides standard configuration interfaces—for example, for setting bit rates for the CAN controllers.</p>&#13;
<p class="indent">The Linux kernel’s modular concept also applies to CAN hardware drivers that attach CAN controllers via bus hardware, such as the <span class="literal">kvaser_pci</span>, <span class="literal">peak_pci</span>, and so on. When you plug in a supported device, these modules should automatically load, and you should see them when you enter the <span class="literal">lsmod</span> command. USB drivers, like <span class="literal">usb8dev</span>, usually implement a proprietary USB communication protocol and, therefore, do not load a CAN controller driver.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_38"/>For example, when you plug in a PEAK-System PCAN-USB adapter, the <span class="literal">can_dev</span> module loads and the <span class="literal">peak_usb</span> module finalizes its initialization. Using the display message command <span class="literal">dmesg</span>, you should see output similar to this:</p>&#13;
<p class="programs">$ <span class="codestrong">dmesg</span><br/><span class="codeitalic">--snip --</span><br/>[ 8603.743057] CAN device driver interface<br/>[ 8603.748745] peak_usb 3-2:1.0: PEAK-System PCAN-USB adapter hwrev 28 serial<br/>    FFFFFFFF (1 channel)<br/>[ 8603.749554] peak_usb 3-2:1.0 can0: attached to PCAN-USB channel 0 (device<br/>    255)<br/>[ 8603.749664] usbcore: registered new interface driver peak_usb</p>&#13;
<p class="indent">You can verify the interface loaded properly with <span class="literal">ifconfig</span> and ensure a <span class="literal">can0</span> interface is now present:</p>&#13;
<p class="programs">$ <span class="codestrong">ifconfig can0</span><br/>can0      Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00<br/>          UP RUNNING NOARP  MTU:16  Metric:1<br/>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0<br/>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0<br/>          collisions:0 txqueuelen:10<br/>          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</p>&#13;
<p class="indent">Now set the CAN bus speed. (You’ll find more information on bus speeds in <a href="ch05.html#ch05">Chapter 5</a>.) The key component you need to set is the bit rate. This is the speed of the bus. A typical value for high-speed CAN (HS-CAN) is 500Kbps. Values of 250Kbps or 125Kbps are typical for lower-speed CAN buses.</p>&#13;
<p class="programs">$ <span class="codestrong">sudo ip link set can0 type can bitrate 500000</span><br/>$ <span class="codestrong">sudo ip link set up can0</span></p>&#13;
<p class="indent">Once you bring up the <span class="literal">can0</span> device, you should be able to use the tools from <span class="literal">can-utils</span> on this interface. Linux uses netlink to communicate between the kernel and user-space tools. You can access netlink with the <span class="literal">ip link</span> command. To see all the netlink options, enter the following:</p>&#13;
<p class="programs">$ <span class="codestrong">ip link set can0 type can help</span></p>&#13;
<p class="indent">If you begin to see odd behavior, such as a lack of packet captures and packet errors, the interface may have stopped. If you’re working with an external device, just unplug or reset. If the device is internal, run these commands to reset it:</p>&#13;
<p class="programs">$ <span class="codestrong">sudo ip link set canX type can restart-ms 100</span><br/>$ <span class="codestrong">sudo ip link set canX type can restart</span></p>&#13;
<h4 class="h4" id="ch03lev2sec3"><span epub:type="pagebreak" id="page_39"/><strong><em>Configuring Serial CAN Devices</em></strong></h4>&#13;
<p class="noindent">External CAN devices usually communicate via serial. In fact, even USB devices on a vehicle often communicate through a serial interface—typically an FTDI chip from Future Technology Devices International, Ltd.</p>&#13;
<p class="indentb">The following devices are known to work with SocketCAN:</p>&#13;
<p class="bull">• Any device that supports the LAWICEL protocol</p>&#13;
<p class="bull">• CAN232/CANUSB serial adapters (<em><a href="http://www.can232.com/">http://www.can232.com/</a></em>)</p>&#13;
<p class="bull">• VSCOM USB-to-serial adapter (<em><a href="http://www.vscom.de/usb-to-can.htm">http://www.vscom.de/usb-to-can.htm</a></em>)</p>&#13;
<p class="bull">• CANtact (<em><a href="http://cantact.io">http://cantact.io</a></em>)</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you’re using an Arduino or building your own sniffer, you must implement the LAWICEL protocol—also known as the SLCAN protocol—in your firmware in order for your device to work. For details, see</em> <a href="http://www.can232.com/docs/canusb_manual.pdf">http://www.can232.com/docs/canusb_manual.pdf</a> <em>and</em> <a href="https://github.com/linux-can/can-misc/blob/master/docs/SLCAN-API.pdf">https://github.com/linux-can/can-misc/blob/master/docs/SLCAN-API.pdf</a>.</p>&#13;
</div>&#13;
<p class="indent">In order to use one of the USB-to-serial adapters, you must first initialize both the serial hardware and the baud rate on the CAN bus:</p>&#13;
<p class="programs">$ <span class="codestrong">slcand -o -s6 -t hw -S 3000000 /dev/ttyUSB0</span><br/>$ <span class="codestrong">ip link set up slcan0</span></p>&#13;
<p class="indent">The <span class="literal">slcand</span> daemon provides the interface needed to translate serial communication to the network driver, <span class="literal">slcan0</span>. The following options can be passed to <span class="literal">slcand</span>:</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">-o</span></span> Opens the device</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">-s6</span></span> Sets the CAN bus baud rate and speed (see <a href="ch03.html#ch3tab1">Table 3-1</a>)</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">-t hw</span></span> Specifies the serial flow control, either <span class="literal">HW</span> (hardware) or <span class="literal">SW</span> (software)</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">-S 3000000</span></span> Sets the serial baud, or bit rate, speed</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">/dev/ttyUSB0</span></span> Your USB FTDI device</p>&#13;
<p class="indent"><a href="ch03.html#ch3tab1">Table 3-1</a> lists the numbers passed to <span class="literal">-s</span> and the corresponding baud rates.</p>&#13;
<p class="tabcaption"><a id="ch3tab1"/><strong>Table 3-1:</strong> Numbers and Corresponding Baud Rates</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Number</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Baud</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">0</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">10Kbps</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">1</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">20Kbps</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">2</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">50Kbps</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">3</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">100Kbps</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">4</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">125Kbps</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><span epub:type="pagebreak" id="page_40"/><p class="table">5</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">250Kbps</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">6</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">500Kbps</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">7</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">800Kbps</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">8</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">1Mbps</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">As you can see, entering <span class="literal">-s6</span> prepares the device to communicate with a 500Kbps CAN bus network.</p>&#13;
<p class="indent">With these options set, you should now have an <span class="literal">slcan0</span> device. To confirm, enter the following:</p>&#13;
<p class="programs">$ <span class="codestrong">ifconfig slcan0</span><br/>slcan0    Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00<br/>          NOARP  MTU:16  Metric:1<br/>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0<br/>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0<br/>          collisions:0 txqueuelen:10<br/>          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</p>&#13;
<p class="indent">Most of the information returned by <span class="literal">ifconfig</span> is set to generic default values, which may be all 0s. This is normal. We’re simply making sure that we can see the device with <span class="literal">ifconfig</span>. If we see an <span class="literal">slcan0</span> device, we know that we should be able to use our tools to communicate over serial with the CAN controller.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>At this point, it may be good to see whether your physical sniffer device has additional lights. Often a CAN sniffer will have green and red lights to signify that it can communicate correctly with the CAN bus. Your CAN device must be plugged in to your computer and the vehicle in order for these lights to function properly. Not all devices have these lights. (Check your device’s manual.)</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch03lev2sec4"><strong><em>Setting Up a Virtual CAN Network</em></strong></h4>&#13;
<p class="noindent">If you don’t have CAN hardware to play with, fear not. You can set up a virtual CAN network for testing. To do so, simply load the <span class="literal">vcan</span> module.</p>&#13;
<p class="programs">$ <span class="codestrong">modprobe vcan</span></p>&#13;
<p class="indent">If you check <span class="literal">dmesg</span>, you shouldn’t see much more than a message like this:</p>&#13;
<p class="programs">$ <span class="codestrong">dmesg</span><br/>[604882.283392] vcan: Virtual CAN interface driver</p>&#13;
<p class="indent">Now you just set up the interface as discussed in “<a href="ch03.html#ch03lev2sec2">Configuring Built-In Chipsets</a>” on <a href="ch03.html#page_37">page 37</a> but without specifying a baud rate for the virtual interface.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_41"/>$ <span class="codestrong">ip link add dev vcan0 type vcan</span><br/>$ <span class="codestrong">ip link set up vcan0</span></p>&#13;
<p class="indent">To verify your setup, enter the following:</p>&#13;
<p class="programs">$ <span class="codestrong">ifconfig vcan0</span><br/>vcan0     Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00<br/>          UP RUNNING NOARP  MTU:16  Metric:1<br/>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0<br/>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0<br/>          collisions:0 txqueuelen:0<br/>          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</p>&#13;
<p class="indent">As long as you see a <span class="literal">vcan0</span> in the output, you’re ready to go.</p>&#13;
<h3 class="h3" id="ch03lev1sec2"><strong>The CAN Utilities Suite</strong></h3>&#13;
<p class="noindent">With our CAN device up and running, let’s take a high-level look at the <span class="literal">can-utils</span>. They’re listed and described briefly here; we’ll use them throughout the book, and we’ll explore them in greater detail as we use them.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">asc2log</span></span> This tool parses ASCII CAN dumps in the following form into a standard SocketCAN logfile format:</p>&#13;
<p class="programs1">0.002367 1 390x Rx d 8 17 00 14 00 C0 00 08 00</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">bcmserver</span></span> Jan-Niklas Meier’s proof-of-concept (PoC) broadcast manager server takes commands like the following:</p>&#13;
<p class="programs1">vcan1 A 1 0 123 8 11 22 33 44 55 66 77 88</p>&#13;
<p class="ulni">By default, it listens on port 28600. It can be used to handle some busy work when dealing with repetitive CAN messages.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">canbusload</span></span> This tool determines which ID is most responsible for putting the most traffic on the bus and takes the following arguments:</p>&#13;
<p class="programs1"><span class="codeitalic">interface</span>@<span class="codeitalic">bitrate</span></p>&#13;
<p class="ulni">You can specify as many interfaces as you like and have <span class="literal">canbusload</span> display a bar graph of the worst bandwidth offenders.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">can-calc-bit-timing</span></span> This command calculates the bit rate and the appropriate register values for each CAN chipset supported by the kernel.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">candump</span></span> This utility dumps CAN packets. It can also take filters and log packets.</p>&#13;
<p class="uln"><span epub:type="pagebreak" id="page_42"/><span class="literal"><span class="codestrong">canfdtest</span></span> This tool performs send and receive tests over two CAN buses.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">cangen</span></span> This command generates CAN packets and can transmit them at set intervals. It can also generate random packets.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">cangw</span></span> This tool manages gateways between different CAN buses and can also filter and modify packets before forwarding them on to the next bus.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">canlogserver</span></span> This utility listens on port 28700 (by default) for CAN packets and logs them in standard format to <span class="literal">stdout</span>.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">canplayer</span></span> This command replays packets saved in the standard SocketCAN “compact” format.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">cansend</span></span> This tool sends a single CAN frame to the network.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">cansniffer</span></span> This interactive sniffer groups packets by ID and highlights changed bytes.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">isotpdump</span></span> This tool dumps ISO-TP CAN packets, which are explained in “<a href="ch04.html#ch04lev2sec4">Sending Data with ISO-TP and CAN</a>” on <a href="ch04.html#page_55">page 55</a>.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">isotprecv</span></span> This utility receives ISO-TP CAN packets and outputs to <span class="literal">stdout</span>.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">isotpsend</span></span> This command sends ISO-TP CAN packets that are piped in from <span class="literal">stdin</span>.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">isotpserver</span></span> This tool implements TCP/IP bridging to ISO-TP and accepts data packets in the format <span class="literal"><span class="codeitalic">1122334455667788</span></span>.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">isotpsniffer</span></span> This interactive sniffer is like <span class="literal">cansniffer</span> but designed for ISO-TP packets.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">isotptun</span></span> This utility creates a network tunnel over the CAN network.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">log2asc</span></span> This tool converts from standard compact format to the following ASCII format:</p>&#13;
<p class="programs1">0.002367 1 390x Rx d 8 17 00 14 00 C0 00 08 00</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">log2long</span></span> This command converts from standard compact format to a user readable format.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">slcan_attach</span></span> This is a command line tool for serial-line CAN devices.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">slcand</span></span> This daemon handles serial-line CAN devices.</p>&#13;
<p class="uln"><span class="literal"><span class="codestrong">slcanpty</span></span> This tool creates a Linux psuedoterminal interface (PTY) to communicate with a serial-based CAN interface.</p>&#13;
<h4 class="h4" id="ch03lev2sec5"><strong><em>Installing Additional Kernel Modules</em></strong></h4>&#13;
<p class="noindent">Some of the more advanced and experimental commands, such as the ISO-TP–based ones, require you to install additional kernel modules, such as <span class="literal">can-isotp</span>, before they can be used. As of this writing, these additional <span epub:type="pagebreak" id="page_43"/>modules haven’t been included with the standard Linux kernels, and you’ll likely have to compile them separately. You can grab the additional CAN kernel modules like this:</p>&#13;
<p class="programs">$ <span class="codestrong">git clone https://gitorious.org/linux-can/can-modules.git</span><br/>$ <span class="codestrong">cd can-modules/net/can</span><br/>$ <span class="codestrong">sudo ./make_isotp.sh</span></p>&#13;
<p class="indent">Once <span class="literal">make</span> finishes, it should create a <em>can-isotp.ko</em> file.</p>&#13;
<p class="indent">If you run <span class="literal">make</span> in the root folder of the repository, it’ll try to compile some out-of-sync modules, so it’s best to compile only the module that you need in the current directory. To load the newly compiled <span class="literal">can-isotp.ko</span> module, run <span class="literal">insmod</span>:</p>&#13;
<p class="programs"># <span class="codestrong">sudo insmod ./can-isotp.ko</span></p>&#13;
<p class="indent"><span class="literal">dmesg</span> should show that it loaded properly:</p>&#13;
<p class="programs">$ <span class="codestrong">dmesg</span><br/>[830053.381705] can: isotp protocol (rev 20141116 alpha)</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>Once the ISO-TP driver has proven to be stable, it should be moved into the stable kernel branch in Linux. Depending on when you’re reading this, it may already have been moved, so be sure to check whether it’s already installed before compiling your own.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch03lev2sec6"><strong><em>The can-isotp.ko Module</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">can-isotp.ko</span> module is a CAN protocol implementation inside the Linux network layer that requires the system to load the <span class="literal">can.ko</span> core module. The <span class="literal">can.ko</span> module provides the network layer infrastructure for all in-kernel CAN protocol implementations, like <span class="literal">can_raw.ko</span>, <span class="literal">can_bcm.ko</span>, and <span class="literal">can-gw.ko</span>. If it’s working correctly, you should see this output in response to the following command:</p>&#13;
<p class="programs"># <span class="codestrong">sudo insmod ./can-isotp.ko</span><br/>[830053.374734] can: controller area network core (rev 20120528 abi 9)<br/>[830053.374746] NET: Registered protocol family 29<br/>[830053.376897] can: netlink gateway (rev 20130117) max_hops=1</p>&#13;
<p class="indent">When <span class="literal">can.ko</span> is not loaded, you get the following:</p>&#13;
<p class="programs"># <span class="codestrong">sudo insmod ./can-isotp.ko</span><br/>insmod: ERROR: could not insert module ./can-isotp.ko: Unknown symbol in<br/>module</p>&#13;
<p class="indent">If you’ve forgotten to attach your CAN device or load the CAN kernel module, this is the strange error message you’ll see. If you were to enter <span epub:type="pagebreak" id="page_44"/><span class="literal">dmesg</span> for more information, you’d see a series of missing symbols referenced in the error messages.</p>&#13;
<p class="programs">$ <span class="codestrong">dmesg</span><br/>[830760.460054] can_isotp: Unknown symbol can_rx_unregister (err 0)<br/>[830760.460134] can_isotp: Unknown symbol can_proto_register (err 0)<br/>[830760.460186] can_isotp: Unknown symbol can_send (err 0)<br/>[830760.460220] can_isotp: Unknown symbol can_ioctl (err 0)<br/>[830760.460311] can_isotp: Unknown symbol can_proto_unregister (err 0)<br/>[830760.460345] can_isotp: Unknown symbol can_rx_register (err 0)</p>&#13;
<p class="indent">The <span class="literal">dmesg</span> output shows a lot of <span class="literal">Unknown symbol</span> messages, especially around <span class="literal">can_</span><span class="literal"><span class="codeitalic">x</span></span> methods. (Ignore the <span class="literal">(err 0)</span> messages.) These messages tell us that the <span class="literal">_isotop</span> module can’t find methods related to standard CAN functions. These messages indicate that you need to load the <span class="literal">can.ko</span> module. Once loaded, everything should work fine.</p>&#13;
<h3 class="h3" id="ch03lev1sec3"><strong>Coding SocketCAN Applications</strong></h3>&#13;
<p class="noindent">While <span class="literal">can-utils</span> is very robust, you’ll find that you want to write custom tools to perform specific actions. (If you’re not a developer, you may want to skip this section.)</p>&#13;
<h4 class="h4" id="ch03lev2sec7"><strong><em>Connecting to the CAN Socket</em></strong></h4>&#13;
<p class="noindent">In order to write your own utilities, you first need to connect to the CAN socket. Connecting to a CAN socket on Linux is the same as connecting to any networking socket that you might know from TCP/IP network programming. The following shows C code that’s specific to CAN as well as the minimum required code to connect to a CAN socket. This code snippet will bind to <span class="literal">can0</span> as a raw CAN socket.</p>&#13;
<p class="programs">int s;<br/>struct sockaddr_can addr;<br/>struct ifreq ifr;<br/><br/>s = socket(PF_CAN, SOCK_RAW, CAN_RAW);<br/><br/>strcpy(ifr.ifr_name, "can0");<br/>ioctl(s, SIOCGIFINDEX, &amp;ifr);<br/><br/>addr.can_family = AF_CAN;<br/>addr.can_ifindex = ifr.ifr_ifindex;<br/><br/>bind(s, (struct sockaddr *)&amp;addr, sizeof(addr));</p>&#13;
<p class="indent">Let’s dissect the sections that are specific to CAN:</p>&#13;
<p class="programs">s = socket(PF_CAN, SOCK_RAW, CAN_RAW);</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_45"/>This line specifies the protocol family, <span class="literal">PF_CAN</span>, and defines the socket as <span class="literal">CAN_RAW</span>. You can also use <span class="literal">CAN_BCM</span> if you plan on making a broadcast manager (BCM) service. A BCM service is a more complex structure that can monitor for byte changes and the queue of cyclic CAN packet transmissions.</p>&#13;
<p class="indent">These two lines name the interface:</p>&#13;
<p class="programs">strcpy(ifr.ifr_name, "can0");<br/>ioctl(s, SIOCGIFINDEX, &amp;ifr);</p>&#13;
<p class="indent">These lines set up the CAN family for <span class="literal">sockaddr</span> and then bind to the socket, allowing you to read packets off the network:</p>&#13;
<p class="programs">addr.can_family = AF_CAN;<br/>addr.can_ifindex = ifr.ifr_ifindex;</p>&#13;
<h4 class="h4" id="ch03lev2sec8"><strong><em>Setting Up the CAN Frame</em></strong></h4>&#13;
<p class="noindent">Next we want to setup the CAN frame and read the bytes off the CAN network into our newly defined structure:</p>&#13;
<p class="programs">struct can_frame frame;<br/>nbytes = read(s, &amp;frame, sizeof(struct can_frame));</p>&#13;
<p class="indent">The <span class="literal">can_frame</span> is defined in <em>linux/can.h</em> as:</p>&#13;
<p class="programs">struct can_frame {<br/>        canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */<br/>        __u8    can_dlc; /* frame payload length in byte (0 .. 8) */<br/>        __u8    data[8] __attribute__((aligned(8)));<br/>};</p>&#13;
<p class="indent">Writing to the CAN network is just like the <span class="literal">read</span> command but in reverse. Simple, eh?</p>&#13;
<h4 class="h4" id="ch03lev2sec9"><strong><em>The Procfs Interface</em></strong></h4>&#13;
<p class="noindent">The SocketCAN network-layer modules implement a <em>procfs</em> interface as well. Having access to information in <em>proc</em> can make bash scripting easier and also provide a quick way to see what the kernel is doing. You’ll find the provided network-layer information in <em>/proc/net/can/</em> and <em>/proc/net/can-bcm/</em>. You can see a list of hooks into the CAN receiver by searching the <em>rcvlist_all</em> file with <span class="literal">cat</span>:</p>&#13;
<p class="programs">$ <span class="codestrong">cat /proc/net/can/rcvlist_all</span><br/>    receive list 'rx_all':<br/>      (vcan3: no entry)<br/>      (vcan2: no entry)<br/>      (vcan1: no entry)<br/>      device   can_id   can_mask  function  userdata   matches  ident<br/>      vcan0     000     00000000  f88e6370  f6c6f400         0  raw<br/>     (any: no entry)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_46"/>Some other useful <em>procfs</em> files include the following:</p>&#13;
<p class="uln"><em><strong>stats</strong></em> CAN network-layer stats</p>&#13;
<p class="uln"><em><strong>reset_stats</strong></em> Resets the stats (for example, for measurements)</p>&#13;
<p class="uln"><em><strong>version</strong></em> SocketCAN version</p>&#13;
<p class="indent">You can limit the maximum length of transmitted packets in <em>proc</em>:</p>&#13;
<p class="programs">$ <span class="codestrong">echo 1000 &gt; /sys/class/net/can0/tx_queue_len</span></p>&#13;
<p class="indent">Set this value to whatever you feel will be the maximum packet length for your application. You typically won’t need to change this value, but if you find that you’re having throttling issues, you may want to fiddle with it.</p>&#13;
<h3 class="h3" id="ch03lev1sec4"><strong>The Socketcand Daemon</strong></h3>&#13;
<p class="noindent">Socketcand (<em><a href="https://github.com/dschanoeh/socketcand">https://github.com/dschanoeh/socketcand</a></em>) provides a network interface into a CAN network. Although it doesn’t include <span class="literal">can-utils</span>, it can still be very useful, especially when developing an application in a programming language like Go that can’t set the CAN low-level socket options described in this chapter.</p>&#13;
<p class="indent">Socketcand includes a full protocol to control its interaction with the CAN bus. For example, you can send the following line to socketcand to open a loopback interface:</p>&#13;
<p class="programs">&lt; can0 C listen_only loopback three_samples &gt;</p>&#13;
<p class="indent">The protocol for socketcand is essentially the same as that of Jan-Niklas Meier’s BCM server mentioned earlier; it’s actually a fork of the BCM server. (Socketcand, however, is a bit more robust than the BCM server.)</p>&#13;
<h3 class="h3" id="ch03lev1sec5"><strong>Kayak</strong></h3>&#13;
<p class="noindent">Kayak (<em><a href="http://kayak.2codeornot2code.org/">http://kayak.2codeornot2code.org/</a></em>), a Java-based GUI for CAN diagnostics and monitoring (see <a href="ch03.html#ch3fig2">Figure 3-2</a>), is one of the best tools for use with socketcand. Kayak links with OpenStreetMaps for mapping and can handle CAN definitions. As a Java-based application, it’s platform independent, so it leans on socketcand to handle communication to the CAN transceivers.</p>&#13;
<p class="indent">You can download a binary package for Kayak or compile from source. In order to compile Kayak, install the latest version of Apache Maven, and clone the Kayak git repository (<em><a href="http://git://github.com/dschanoeh/Kayak">git://github.com/dschanoeh/Kayak</a></em>). Once the clone is complete, run the following:</p>&#13;
<p class="programs">$ <span class="codestrong">mvn clean package</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_47"/>You should find your binary in the <em>Kayak/application/target/kayak/bin</em> folder.</p>&#13;
<div class="image"><img src="graphics/f03-02.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch3fig2"/><em>Figure 3-2: The Kayak GUI</em></p>&#13;
<p class="indent">Before you launch Kayak, start socketcand:</p>&#13;
<p class="programs">$ <span class="codestrong">socketcand -i can0</span></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>You can attach as many CAN devices as you want to socketcand, separated by commas.</em></p>&#13;
</div>&#13;
<p class="indent">Next, start Kayak and take the following steps:</p>&#13;
<ol>&#13;
<li><p class="noindent">Create a new project with <small>CTRL</small>-N and give it a name.</p></li>&#13;
<li><p class="noindent">Right-click the project and choose <strong>Newbus</strong>; then, give your bus a name (see <a href="ch03.html#ch3fig3">Figure 3-3</a>).</p>&#13;
<div class="imagea"><img src="graphics/f03-03.jpg" alt="image"/></div>&#13;
<p class="figcap1"><a id="ch3fig3"/><em>Figure 3-3: Creating a name for the CAN bus</em></p></li>&#13;
<li><p class="noindent">Click the <strong>Connections</strong> tab at the right; your socketcand should show up under Auto Discovery (see <a href="ch03.html#ch3fig4">Figure 3-4</a>).</p>&#13;
<div class="imagea"><span epub:type="pagebreak" id="page_48"/><img src="graphics/f03-04.jpg" alt="image"/></div>&#13;
<p class="figcap1"><a id="ch3fig4"/><em>Figure 3-4: Finding Auto Discovery under the Connections tab</em></p></li>&#13;
<li><p class="noindent">Drag the socketcand connection to the bus connection. (The bus connection should say <em>Connection: None</em> before it’s set up.) To see the bus, you may have to expand it by clicking the drop-down arrow next to the bus name, as shown in <a href="ch03.html#ch3fig5">Figure 3-5</a>.</p>&#13;
<div class="imagea"><img src="graphics/f03-05.jpg" alt="image"/></div>&#13;
<p class="figcap1"><a id="ch3fig5"/><em>Figure 3-5: Setting up the bus connection</em></p></li>&#13;
<li><p class="noindent">Right-click the bus and choose <strong>Open RAW view</strong>.</p></li>&#13;
<li><p class="noindent">Press the play button (circled in <a href="ch03.html#ch3fig6">Figure 3-6</a>); you should start to see packets from the CAN bus.</p>&#13;
<div class="image1"><img src="graphics/f03-06.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch3fig6"/><em>Figure 3-6: Open RAW view and press the play button to see packets from the CAN bus.</em></p></li>&#13;
<li><p class="noindent">Choose <strong>Colorize</strong> from the toolbar to make it easier to see and read the changing packets.</p></li>&#13;
</ol>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_49"/>Kayak can easily record and play back packet capture sessions, and it supports CAN definitions (stored in an open KDC format). As of this writing, the GUI doesn’t support creating definitions, but I’ll show how to create definitions later.</p>&#13;
<p class="indent">Kayak is a great open source tool that can work on any platform. In addition, it has a friendly GUI with advanced features that allow you to define the CAN packets you see and view them graphically.</p>&#13;
<h3 class="h3" id="ch03lev1sec6"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you learned how to use SocketCAN as a unified interface for CAN devices and how to set up your device and apply the appropriate bit rate for your CAN bus. I reviewed all of the default CAN utilities in the <span class="literal">can-utils</span> package that come with SocketCAN support, and I showed you how to write low-level C code to directly interface with the CAN sockets. Finally, you learned how to use socketcand to allow remote interaction with your CAN devices and set up Kayak to work with socketcand. Now that you’ve set up communication with your vehicle, you’re just about ready to try out some attacks.<span epub:type="pagebreak" id="page_50"/></p>&#13;
</body></html>