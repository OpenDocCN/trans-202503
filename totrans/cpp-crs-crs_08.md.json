["```\ntemplate➊<typename X, typename Y, typename Z> ➋\nstruct MyTemplateClass➌ {\n  X foo(Y&); ➍\nprivate:\n  Z* member; ➎\n};\n```", "```\ntemplate<typename X, typename Y, typename Z>\nX my_template_function(Y& arg1, const Z* arg2) {\n  --snip--\n}\n```", "```\ntc_name➊<t_param1➋, t_param2, ...> my_concrete_class{ ... }➌;\n```", "```\nauto result = tf_name➊<t_param1➋, t_param2, ...>(f_param1➌, f_param2, ...);\n```", "```\nnamed-conversion<desired-type>(object-to-cast)\n```", "```\nvoid carbon_thaw(const➊ int& encased_solo) {\n  //encased_solo++; ➋ // Compiler error; modifying const\n  auto& hibernation_sick_solo = const_cast➌<int&➍>(encased_solo➎);\n  hibernation_sick_solo++; ➏\n}\n```", "```\n#include <cstdio>\nshort increment_as_short(void*➊ target) {\n  auto as_short = static_cast➋<short*➌>(target➍);\n  *as_short = *as_short + 1;\n  return *as_short;\n}\n\nint main() {\n  short beast{ 665 };\n  auto mark_of_the_beast = increment_as_short(&beast);\n  printf(\"%d is the mark_of_the_beast.\", mark_of_the_beast);\n}\n--------------------------------------------------------------------------\n666 is the mark_of_the_beast.\n```", "```\nfloat on = 3.5166666666;\nauto not_alright = static_cast<char*>(&on); // Bang!\n```", "```\n#include <cstdio>\nint main() {\n  auto timer = reinterpret_cast➊<const unsigned long*➋>(0x1000➌);\n  printf(\"Timer is %lu.\", *timer);\n}\n```", "```\nconst unsigned long* timer{ 0x1000 };\n```", "```\n#include <stdexcept>\ntemplate <typename To➊, typename From➋>\nTo➌ narrow_cast(From➍ value) {\n  const auto converted = static_cast<To>(value); ➎\n  const auto backwards = static_cast<From>(converted); ➏\n  if (value != backwards) throw std::runtime_error{ \"Narrowed!\" }; ➐\n  return converted; ➑\n}\n```", "```\n#include <cstdio>\n#include <stdexcept>\n\ntemplate <typename To, typename From>\nTo narrow_cast(From value) {\n  --snip--\n}\nint main() {\n  int perfect{ 496 }; ➊\n  const auto perfect_short = narrow_cast<short>(perfect); ➋\n  printf(\"perfect_short: %d\\n\", perfect_short); ➌\n  try {\n    int cyclic{ 142857 }; ➍\n    const auto cyclic_short = narrow_cast<short>(cyclic); ➎\n    printf(\"cyclic_short: %d\\n\", cyclic_short);\n  } catch (const std::runtime_error& e) {\n    printf(\"Exception: %s\\n\", e.what()); ➏\n  }\n}\n--------------------------------------------------------------------------\nperfect_short: 496 ➌\nException: Narrowed! ➏\n```", "```\n#include <cstddef>\n\ndouble mean(const double* values, size_t length) {\n  double result{}; ➊\n  for(size_t i{}; i<length; i++) {\n    result += values[i]; ➋\n  }\n  return result / length; ➌\n}\n```", "```\n#include <cstddef>\n\nlong➊ mean(const long*➋ values, size_t length) {\n  long result{}; ➌\n  for(size_t i{}; i<length; i++) {\n    result += values[i];\n  }\n  return result / length;\n}\n```", "```\n#include <cstddef>\n\ntemplate<typename T> ➊\nT➋ mean(constT*➌ values, size_t length) {\n  T➍ result{};\n  for(size_t i{}; i<length; i++) {\n    result += values[i];\n }\n  return result / length;\n}\n```", "```\n#include <cstddef>\n#include <cstdio>\n\ntemplate<typename T>\nT mean(const T* values, size_t length) {\n  --snip--\n}\n\nint main() {\n  const double nums_d[] { 1.0, 2.0, 3.0, 4.0 };\n  const auto result1 = mean<double>(nums_d, 4); ➊\n  printf(\"double: %f\\n\", result1);\n\n  const float nums_f[] { 1.0f, 2.0f, 3.0f, 4.0f };\n  const auto result2 = mean<float>(nums_f, 4); ➋\n  printf(\"float: %f\\n\", result2);\n\n  const size_t nums_c[] { 1, 2, 3, 4 };\n  const auto result3 = mean<size_t>(nums_c, 4); ➌\n  printf(\"size_t: %zu\\n\", result3);\n}\n--------------------------------------------------------------------------\ndouble: 2.500000\nfloat: 2.500000\nsize_t: 2\n```", "```\ndouble mean(const double* values, size_t length) {\n  double result{};\n  for(size_t i{}; i<length; i++) {\n    result += values[i];\n  }\n return result / length;\n}\n\nfloat mean(const float* values, size_t length) {\n  float result{};\n  for(size_t i{}; i<length; i++) {\n    result += values[i];\n  }\n  return result / length;\n}\n\nsize_t mean(const size_t* values, size_t length) {\n  size_t result{};\n  for(size_t i{}; i<length; i++) {\n    result += values[i];\n  }\n  return result / length;\n}\n```", "```\n#include <cstddef>\n#include <cstdio>\n\ntemplate<typename T>\nT mean(const T* values, size_t length) {\n  --snip--\n}\n\nint main() {\n  const double nums_d[] { 1.0, 2.0, 3.0, 4.0 };\n  const auto result1 = mean(nums_d, 4); ➊\n  printf(\"double: %f\\n\", result1);\n\n  const float nums_f[] { 1.0f, 2.0f, 3.0f, 4.0f };\n  const auto result2 = mean(nums_f, 4); ➋\n  printf(\"float: %f\\n\", result2);\n\n  const size_t nums_c[] { 1, 2, 3, 4 };\n const auto result3 = mean(nums_c, 4); ➌\n  printf(\"size_t: %zu\\n\", result3);\n}\n--------------------------------------------------------------------------\ndouble: 2.500000\nfloat: 2.500000\nsize_t: 2\n```", "```\ntemplate <typename T> ➊\nstruct SimpleUniquePointer {\n  SimpleUniquePointer() = default; ➋\n  SimpleUniquePointer(T* pointer)\n    : pointer{ pointer } { ➌\n  }\n  ~SimpleUniquePointer() { ➍\n    if(pointer) delete pointer;\n  }\n  SimpleUniquePointer(const SimpleUniquePointer&) = delete;\n  SimpleUniquePointer& operator=(const SimpleUniquePointer&) = delete; ➎\n  SimpleUniquePointer(SimpleUniquePointer&& other) noexcept ➏\n    : pointer{ other.pointer } {\n    other.pointer = nullptr;\n  }\n  SimpleUniquePointer& operator=(SimpleUniquePointer&& other) noexcept { ➐\n    if(pointer) delete pointer;\n    pointer = other.pointer;\n    other.pointer = nullptr;\n    return *this;\n }\n  T* get() { ➑\n    return pointer;\n  }\nprivate:\n  T* pointer;\n};\n```", "```\n#include <cstdio>\n#include <utility>\n\ntemplate <typename T>\nstruct SimpleUniquePointer {\n  --snip--\n};\n\nstruct Tracer {\n  Tracer(const char* name) : name{ name } {\n    printf(\"%s constructed.\\n\", name); ➊\n  }\n  ~Tracer() {\n printf(\"%s destructed.\\n\", name); ➋\n  }\nprivate:\n  const char* const name;\n};\n\nvoid consumer(SimpleUniquePointer<Tracer> consumer_ptr) {\n  printf(\"(cons) consumer_ptr: 0x%p\\n\", consumer_ptr.get()); ➌\n}\n\nint main() {\n  auto ptr_a = SimpleUniquePointer(new Tracer{ \"ptr_a\" });\n  printf(\"(main) ptr_a: 0x%p\\n\", ptr_a.get()); ➍\n  consumer(std::move(ptr_a));\n  printf(\"(main) ptr_a: 0x%p\\n\", ptr_a.get()); ➎\n}\n--------------------------------------------------------------------------\nptr_a constructed. ➊\n(main) ptr_a: 0x000001936B5A2970 ➍\n(cons) consumer_ptr: 0x000001936B5A2970 ➌\nptr_a destructed. ➋\n(main) ptr_a: 0x0000000000000000 ➎\n```", "```\ntemplate<typename T>\nT square(T value) {\n  return value * value; ➊\n}\n```", "```\ntemplate<typename T>\nT square(T value) {\n  return value * value;\n}\n\nint main() {\n  char my_char{ 'Q' };\n  auto result = square(&my_char); ➊ // Bang!\n}\n```", "```\nmain.cpp(3): error C2296: '*': illegal, left operand has type 'char *'\nmain.cpp(8): note: see reference to function template instantiation 'T *square<char*>(T)' being compiled\n        with\n        [\n            T=char *\n        ]\nmain.cpp(3): error C2297: '*': illegal, right operand has type 'char *'\n```", "```\nmain.cpp: In instantiation of 'T square(T) [with T = char*]':\nmain.cpp:8:32:   required from here\nmain.cpp:3:16: error: invalid operands of types 'char*' and 'char*' to binary\n'operator*'\n   return value * value;\n          ~~~~~~^~~~~~~\n```", "```\ntemplate<typename T1, typename T2, ...>\nconcept bool ConceptName() {\n  --snip--\n}\n```", "```\n#include <type_traits>\n#include <cstdio>\n#include <cstdint>\n\nconstexpr const char* as_str(bool x) { return x ? \"True\" : \"False\"; } ➊\n\nint main() {\n  printf(\"%s\\n\", as_str(std::is_integral<int>::value)); ➋\n  printf(\"%s\\n\", as_str(std::is_integral<const int>::value)); ➌\n  printf(\"%s\\n\", as_str(std::is_integral<char>::value)); ➍\n  printf(\"%s\\n\", as_str(std::is_integral<uint64_t>::value)); ➎\n  printf(\"%s\\n\", as_str(std::is_integral<int&>::value)); ➏\n  printf(\"%s\\n\", as_str(std::is_integral<int*>::value)); ➐\n  printf(\"%s\\n\", as_str(std::is_integral<float>::value)); ➑\n}\n--------------------------------------------------------------------------\nTrue ➋\nTrue ➌\nTrue ➍\nTrue ➎\nFalse ➏\nFalse ➐\nFalse ➑\n```", "```\nrequires (arg-1, arg-2, ...➊) {\n  { expression1➋ } -> return-type1➌;\n  { expression2 } -> return-type2;\n  --snip--\n}\n```", "```\n// T, U are types\nrequires (T t, U u) {\n  { t == u } -> bool; // syntactic requirement 1\n  { u == t } -> bool; // syntactic requirement 2\n  { t != u } -> bool; // syntactic requirement 3\n  { u != t } -> bool; // syntactic requirement 4\n}\n```", "```\ntemplate<typename T>\nT mean(T* values, size_t length) {\n  T result{}; ➊\n  for(size_t i{}; i<length; i++) {\n    result ➋+= values[i];\n  }\n  ➌return result / length;\n}\n```", "```\ntemplate<typename T>\nconcept bool Averageable() {\n  return std::is_default_constructible<T>::value ➊\n    && requires (T a, T b) {\n      { a += b } -> T; ➋\n      { a / size_t{ 1 } } -> T; ➌\n    };\n}\n```", "```\n#include <cstddef>\n#include <type_traits>\n\ntemplate<typename T>\nconcept bool Averageable() { ➊\n  --snip--\n}\n\ntemplate<Averageable➋ T>\nT mean(const T* values, size_t length) {\n  --snip--\n}\n\nint main() {\n  const double nums_d[] { 1.0f, 2.0f, 3.0f, 4.0f };\n  const auto result1 = mean(nums_d, 4);\n  printf(\"double: %f\\n\", result1);\n\n  const float nums_f[] { 1.0, 2.0, 3.0, 4.0 };\n  const auto result2 = mean(nums_f, 4);\n  printf(\"float: %f\\n\", result2);\n\n  const size_t nums_c[] { 1, 2, 3, 4 };\n  const auto result3 = mean(nums_c, 4);\n  printf(\"size_t: %d\\n\", result3);\n}\n--------------------------------------------------------------------------\ndouble: 2.500000\nfloat: 2.500000\nsize_t: 2\n```", "```\n--snip—\nint main() {\n  auto value1 = 0.0;\n  auto value2 = 1.0;\n  const double* values[] { &value1, &value2 };\n  mean(values➊, 2);\n}\n```", "```\n<source>: In instantiation of 'T mean(const T*, size_t) [with T = const\ndouble*; size_t = long unsigned int]':\n<source>:17:17:   required from here\n<source>:8:12: error: invalid operands of types 'const double*' and 'const\ndouble*' to binary 'operator+'\n     result += values[i]; ➊\n     ~~~~~~~^~~~~~~~~~\n<source>:8:12: error:   in evaluation of 'operator+=(const double*, const\ndouble*)'\n<source>:10:17: error: invalid operands of types 'const double*' and 'size_t'\n{aka 'long unsigned int'} to binary 'operator/'\n   return result / length; ➋\n          ~~~~~~~^~~~~~~~\n```", "```\n<source>: In function 'int main()':\n<source>:28:17: error: cannot call function 'T mean(const T*, size_t) [with T\n= const double*; size_t = long unsigned int]'\n   mean(values, 2); ➊\n                 ^\n<source>:16:3: note:   constraints not satisfied\n T mean(const T* values, size_t length) {\n   ^~~~\n\n<source>:6:14: note: within 'template<class T> concept bool Averageable()\n[with T = const double*]'\n concept bool Averageable() {\n              ^~~~~~~~~~~\n<source>:6:14: note:     with 'const double* a'\n<source>:6:14: note:     with 'const double* b'\n<source>:6:14: note: the required expression '(a + b)' would be ill-formed ➋\n<source>:6:14: note: the required expression '(a / b)' would be ill-formed ➌\n```", "```\nreturn-type function-name(Concept1➊ arg-1, …) {\n  --snip--\n}\n```", "```\n#include <origin/core/concepts.hpp>\nsize_t index_of_minimum(Ordered➊* x, size_t length) {\n  size_t min_index{};\n  for(size_t i{ 1 }; i<length; i++) {\n    if(x[i] < x[min_index]) min_index = i;\n  }\n  return min_index;\n}\n```", "```\n#include <cstdio>\n#include <cstdint>\n#include <origin/core/concepts.hpp>\n\nstruct Goblin{};\n\nsize_t index_of_minimum(Ordered* x, size_t length) {\n  --snip--\n}\n\nint main() {\n  int x1[] { -20, 0, 100, 400, -21, 5123 };\n  printf(\"%zu\\n\", index_of_minimum(x1, 6)); ➊\n\n  unsigned short x2[] { 42, 51, 900, 400 };\n  printf(\"%zu\\n\", index_of_minimum(x2, 4)); ➋\n\n  Goblin x3[] { Goblin{}, Goblin{} };\n  //index_of_minimum(x3, 2); ➌ // Bang! Goblin is not Ordered.\n}\n--------------------------------------------------------------------------\n4 ➊\n0 ➋\n```", "```\nerror: cannot call function 'size_t index_\nof_minimum(auto:1*, size_t) [with auto:1 = Goblin; size_t = long unsigned int]'\n   index_of_minimum(x3, 2); // Bang! Goblin is not Ordered.\n                         ^\nnote:   constraints not satisfied\n size_t index_of_minimum(Ordered* x, size_t length) {\n        ^~~~~~~~~~~~~~~~\n\nnote: within 'template<class T> concept bool origin::Ordered() [with T =\nGoblin]'\n Ordered()\n```", "```\n#include <stdexcept>\n\ntemplate<typename T>\n  requires➊ is_copy_constructible<T>::value ➋\nT get_copy(T* pointer) {\n  if (!pointer) throw std::runtime_error{ \"Null-pointer dereference\" };\n  return *pointer;\n}\n```", "```\n#include <stdexcept>\n#include <type_traits>\n\ntemplate<typename T>\n  requires std::is_copy_constructible<T>::value\nT get_copy(T* pointer) { ➊\n  --snip--\n}\n\nstruct Highlander {\n  Highlander() = default; ➋\n  Highlander(const Highlander&) = delete; ➌\n};\n\nint main() {\n  Highlander connor; ➍\n  auto connor_ptr = &connor; ➎\n  auto connor_copy = get_copy(connor_ptr); ➏\n}\n--------------------------------------------------------------------------\nIn function 'int main()':\nerror: cannot call function 'T get_copy(T*) [with T = Highlander]'\n   auto connor_copy = get_copy(connor_ptr);\n                                         ^\nnote:   constraints not satisfied\n T get_copy(T* pointer) {\n   ^~~~~~~~\n\nnote: 'std::is_copy_constructible::value' evaluated to false\n```", "```\nstatic_assert(boolean-expression, optional-message);\n```", "```\n#include <type_traits>\n\ntemplate <typename T>\nT mean(T* values, size_t length) {\n  static_assert(std::is_default_constructible<T>(),\n    \"Type must be default constructible.\"); ➊\n  static_assert(std::is_copy_constructible<T>(),\n    \"Type must be copy constructible.\"); ➋\n  static_assert(std::is_arithmetic<T>(),\n    \"Type must support addition and division.\"); ➌\n  static_assert(std::is_constructible<T, size_t>(),\n    \"Type must be constructible from size_t.\"); ➍\n  --snip--\n}\n```", "```\nelement-type(¶m-name)[array-length]\n```", "```\n#include <stdexcept>\n\nint& get(int (&arr)[10]➊, size_t index➋) {\n  if (index >= 10) throw std::out_of_range{ \"Out of bounds\" }; ➌\n  return arr[index]; ➍\n}\n```", "```\n#include <stdexcept>\n\ntemplate <typename T➊>\nT&➋ get(T➌ (&arr)[10], size_t index) {\n  if (index >= 10) throw std::out_of_range{ \"Out of bounds\" };\n  return arr[index];\n}\n```", "```\n#include <stdexcept>\n\ntemplate <typename T, size_t Length➊>\nT& get (T(&arr)[Length➋], size_t index) {\n  if (index >= Length➌) throw std::out_of_range{ \"Out of bounds\" };\n  return arr[index];\n}\n```", "```\n#include <cstdio>\n\ntemplate <size_t Index➊, typename T, size_t Length>\nT& get(T (&arr)[Length]) {\n  static_assert(Index < Length, \"Out-of-bounds access\"); ➋\n  return arr[Index➌];\n}\n\nint main() {\n  int fib[]{ 1, 1, 2, 0 }; ➍\n  printf(\"%d %d %d \", get<0>(fib), get<1>(fib), get<2>(fib)); ➎\n  get<3>(fib) = get<1>(fib) + get<2>(fib); ➏\n  printf(\"%d\", get<3>(fib)); ➐\n  //printf(\"%d\", get<4>(fib)); ➑\n}\n--------------------------------------------------------------------------\n1 1 2 ➎3 ➐\n```", "```\ntemplate <typename T, typename... Arguments➊>\nSimpleUniquePointer<T> make_simple_unique(Arguments... arguments➋) {\n  return SimpleUniquePointer<T>{ new T{ arguments...➌ } };\n}\n```"]