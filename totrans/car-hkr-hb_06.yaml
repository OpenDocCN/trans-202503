- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: '**ECU HACKING**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**ECU 黑客攻击**'
- en: '*by Dave Blundell*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*由 Dave Blundell 撰写*'
- en: '![image](graphics/common-01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common-01.jpg)'
- en: A vehicle typically has as many as a dozen or more electronic controllers, many
    of which are networked to communicate with each other. These computerized devices
    go by many different names, including *electronic control unit* or *engine control
    unit (ECU)*, *transmission control unit (TCU),* or *transmission control module
    (TCM)*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一辆车通常有十多个电子控制器，其中许多通过网络互相通信。这些计算机化设备有很多不同的名称，包括*电子控制单元*（ECU）、*发动机控制单元（ECU）*、*变速器控制单元（TCU）*，或*变速器控制模块（TCM）*。
- en: While these terms may have specific meanings in a formal setting, similar terms
    are often used interchangeably in practice. What may be a TCU to one manufacturer
    is a TCM to another, yet both electronic controllers perform the same or extremely
    similar functions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些术语在正式场合中有特定的含义，但在实际操作中，相似的术语往往是互换使用的。对某一制造商来说可能是TCU，对另一家制造商来说是TCM，但这两个电子控制器执行的功能相同或极为相似。
- en: 'Most automotive control modules have measures in place to prevent you from
    altering their code and operation; these range from very strong to laughably weak.
    You won’t know what you’re dealing with until you investigate a particular system.
    In this chapter, we’ll take a closer look at particular security mechanisms, but
    first we’ll examine strategies for gaining access to these systems. Then in [Chapter
    8](ch08.html#ch08) we’ll look at some more specific ECU hacks, like glitch attacks
    and debugging. The attack vectors for ECUs fall into three different classes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数汽车控制模块都有防止你更改其代码和操作的措施，这些措施从非常强到极其薄弱不等。你无法知道你正在处理的具体系统，直到你对某一系统进行调查。在本章中，我们将更详细地探讨特定的安全机制，但首先我们将研究如何获取这些系统的访问权限。然后，在[第8章](ch08.html#ch08)中，我们将讨论一些更具体的ECU黑客攻击，如故障攻击和调试。ECU的攻击路径分为三种不同的类别：
- en: '**Front door attacks** Commandeering the access mechanism of the original equipment
    manufacturer (OEM)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**前门攻击** 控制原始设备制造商（OEM）的访问机制'
- en: '**Backdoor attacks** Applying more traditional hardware-hacking approaches'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**后门攻击** 应用更传统的硬件黑客方法'
- en: '**Exploits** Discovering unintentional access mechanisms'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞** 发现意外的访问机制'
- en: We’ll look at an overview of these attack classes, and then analyze the data
    you find. It’s worth remembering that while the goal for ECU and other control
    module hacking is often the same—to gain access in order to reprogram and change
    behavior—it’s unlikely there’ll be a “master key” for all controllers. However,
    OEMs are generally not very creative and seldom change their ways, so insight
    into one controller likely applies to similar models from the same manufacturer.
    Also, few of today’s auto manufacturers develop their own automotive computers
    from scratch, instead licensing prefabricated solutions from third parties like
    Denso, Bosch, Continental, and others. Because of this design methodology, it’s
    relatively common to see vehicles from different auto manufacturers using very
    similar computer systems sourced from the same vendors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先概述这些攻击类别，然后分析你发现的数据。值得记住的是，虽然ECU和其他控制模块的黑客攻击目标通常是相同的——获取访问权限以重新编程并改变行为——但不太可能会有一个“万能钥匙”适用于所有控制器。然而，OEM（原始设备制造商）通常缺乏创意，很少改变其方法，因此对一个控制器的见解往往适用于同一制造商的类似型号。另外，今天很少有汽车制造商从零开始开发自己的汽车计算机，通常是从第三方如电装（Denso）、博世（Bosch）、大陆（Continental）等公司获得预制解决方案。由于这种设计方法，来自不同汽车制造商的车辆使用相似的计算机系统通常源自相同的供应商。
- en: '**Front Door Attacks**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**前门攻击**'
- en: The OBD-II standard mandates that you be able to reprogram vehicles through
    the OBD-II connector, and reverse engineering the original method for programming
    is a guaranteed attack vector. We’ll examine J2534 and KWP2000 as examples of
    common protocols for programming.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: OBD-II标准要求你能够通过OBD-II连接器重新编程车辆，而反向工程原始编程方法是一个确保有效的攻击路径。我们将以J2534和KWP2000为例，探讨常见的编程协议。
- en: '***J2534: The Standardized Vehicle Communication API***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***J2534：标准化车辆通信API***'
- en: The SAE J2534-1 standard, or simply *J2534*, was developed to promote interoperability
    among digital tool vendors through the use of the J2534 API, which outlines the
    recommended way for Microsoft Windows to communicate with a vehicle. (You can
    purchase the J2534 API from the SAE at *[http://standards.sae.org/j2534/1_200412/](http://standards.sae.org/j2534/1_200412/)*.)
    Prior to the adoption of the J2534 standard, each software vendor created its
    own proprietary hardware and drivers for communicating with a vehicle in order
    to perform computerized repairs. Because these proprietary tools weren’t always
    available to smaller shops, the EPA mandated the adoption of the J2534 standard
    in 2004 to allow independent shops access to the same specialized computer tools
    used by dealerships. J2534 introduced a series of DLLs that map standard API calls
    to instructions necessary to communicate with a vehicle, thereby allowing multiple
    manufacturers to release software designed to work with J2534-compatible hardware.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SAE J2534-1 标准，简称 *J2534*，旨在通过使用 J2534 API，促进数字工具供应商之间的互操作性，该 API 概述了微软 Windows
    与车辆通信的推荐方式。（你可以从 SAE 购买 J2534 API，链接地址为 *[http://standards.sae.org/j2534/1_200412/](http://standards.sae.org/j2534/1_200412/)*。）在
    J2534 标准被采纳之前，每个软件供应商都会创建自己的专有硬件和驱动程序与车辆通信，从而进行计算机化修理。由于这些专有工具并不总是可以供小型车行使用，美国环保署（EPA）在
    2004 年要求采用 J2534 标准，以便独立维修店也能使用与经销商相同的专用计算机工具。J2534 引入了一系列 DLL 文件，将标准的 API 调用映射到与车辆通信所需的指令，从而允许多个制造商发布与
    J2534 兼容硬件配合使用的软件。
- en: '***Using J2534 Tools***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 J2534 工具***'
- en: J2534 tools provide a convenient way to observe OEM tools interacting with vehicle
    computers. Manufacturers often leverage J2534 to update computer firmware and
    sometimes to provide powerful diagnostic software. By observing and capturing
    information exchanged with a vehicle using J2534, you can see how OEMs perform
    certain tasks, which may provide you with information that you need to unlock
    the “front door.”
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: J2534 工具提供了一种方便的方式来观察 OEM 工具与车辆计算机的互动。制造商通常利用 J2534 更新计算机固件，有时还提供强大的诊断软件。通过观察和捕获使用
    J2534 与车辆交换的信息，你可以看到 OEM 如何执行某些任务，这可能为你提供解锁“前门”所需的信息。
- en: When using J2534 tools to attack vehicle systems, the basic idea is to observe,
    record, analyze, and extend functionality. Of course, the first step is to obtain
    and configure a J2534 application and its corresponding interface hardware in
    order to perform a task you want to observe. Once you have your setup, the next
    step is to observe and record communications with the target while using the J2534
    tools to perform an action on the target, like updating a configuration parameter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 J2534 工具攻击车辆系统时，基本思路是观察、记录、分析并扩展功能。当然，第一步是获取并配置 J2534 应用程序及其对应的接口硬件，以便执行你想要观察的任务。一旦设置完成，下一步是观察并记录与目标的通信，同时使用
    J2534 工具对目标执行操作，比如更新配置参数。
- en: 'There are two primary ways to observe J2534 transactions: by watching J2534
    API calls on a PC using J2534 shim DLLs or by watching actual bus traffic using
    a separate sniffer tool to capture data.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 观察 J2534 事务的主要方式有两种：一种是通过在 PC 上使用 J2534 shim DLL 观察 J2534 API 调用，另一种是通过使用单独的嗅探工具观察实际的总线流量以捕获数据。
- en: J2534 tools are key to eavesdropping on the protocols built into the factory
    embedded vehicle systems, and they’re one of the primary ways to attack the front
    door. Successful analysis of this communication will give you the knowledge you
    need to access vehicle systems the way the OEMs do. It’ll also allow you to write
    applications with full access to read and reprogram systems, which will in turn
    enable you to communicate directly with a vehicle without having to use the J2534
    interface or the OEM’s J2534 software.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: J2534 工具是窃听工厂嵌入式车辆系统协议的关键，它们是攻击前门的主要方式之一。成功分析这些通信将使你掌握像 OEM（原始设备制造商）一样访问车辆系统的知识。它还将使你能够编写具有完全访问权限的应用程序，读取和重新编程系统，进而使你能够直接与车辆通信，而无需使用
    J2534 接口或 OEM 的 J2534 软件。
- en: '**J2534 Shim DLLs**'
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**J2534 Shim DLLs**'
- en: The J2534 shim is a software J2534 interface that connects to a physical J2534
    interface and then passes along and logs all commands that it receives. This dummy
    interface is a kind of man-in-the-middle attack that allows you to record all
    API calls between the J2534 application and the target. You can then examine the
    log of commands to determine the actual data exchanged between the J2534 interface
    and the device.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: J2534 shim是一个软件J2534接口，它连接到物理J2534接口，然后传递并记录它收到的所有命令。这个虚拟接口是一种中间人攻击，允许你记录J2534应用程序与目标之间的所有API调用。然后，你可以检查命令日志，以确定J2534接口和设备之间实际交换的数据。
- en: To find an open source J2534 shim, search *[code.google.com](mailto:code.google.com)*
    for *J2534-logger*. You should also be able to find precompiled binaries.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到一个开源的J2534 shim，可以在* [code.google.com](mailto:code.google.com) *上搜索 *J2534-logger*。你也应该能够找到预编译的二进制文件。
- en: '**J2534 with a Sniffer**'
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**J2534与嗅探器**'
- en: 'You can also use J2534 to generate interesting traffic that you can then observe
    and record with a third party sniffer. There’s no magic here: this is just an
    excellent example of how to generate juicy packets that might otherwise be difficult
    to capture. (See [Chapter 5](ch05.html#ch05) for more information on monitoring
    network traffic.)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用J2534生成有趣的流量，然后使用第三方嗅探器观察和记录。这没有什么神奇的：这只是一个优秀的例子，展示了如何生成可能难以捕获的有用数据包。
    （有关监控网络流量的更多信息，请参见[第5章](ch05.html#ch05)。）
- en: '***KWP2000 and Other Earlier Protocols***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***KWP2000和其他早期协议***'
- en: Before J2534, there were many flash-programmable ECUs and other control units,
    such as the Keyword Protocol 2000 (KWP2000 or ISO14230). From an OSI networking
    perspective, it’s primarily an application protocol. It can be used on top of
    CAN or ISO9141 as the physical layer. You’ll find a *huge* number of KWP2000 flasher
    tools that interface with a PC using a serial/ USB-serial interface and that support
    diagnostics and flashing using this protocol just by searching online. (For more
    on the Keyword Protocol 2000, see [Chapter 2](ch02.html#ch02).)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在J2534之前，已经有许多可闪存编程的ECU和其他控制单元，例如关键词协议2000（KWP2000或ISO14230）。从OSI网络的角度来看，它主要是一种应用协议。它可以在CAN或ISO9141之上作为物理层使用。你会发现大量支持KWP2000协议的闪存工具，它们通过串行/USB串行接口与PC进行通信，并支持使用此协议进行诊断和刷新，只需在线搜索即可找到。
    （有关关键词协议2000的更多信息，请参见[第2章](ch02.html#ch02)。）
- en: '***Capitalizing on Front Door Approaches: Seed-Key Algorithms***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***利用前门方法：种子-密钥算法***'
- en: 'Now that we’ve discussed how legitimate tools use the front door, it’s time
    to capitalize on this attack vector by learning how to operate the figurative
    “lock on the gate.” To do this, we must understand the algorithm that the embedded
    controller uses to authenticate valid users; this is almost always a seed-key
    algorithm. Seed-key algorithms usually generate a pseudorandom *seed* and expect
    a particular response, or *key*, for each seed before allowing access. A typical
    valid exchange could look something like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了合法工具如何使用前门，是时候利用这一攻击向量，学习如何操作比喻中的“门锁”了。为了做到这一点，我们必须理解嵌入式控制器用来验证合法用户的算法；这几乎总是种子-密钥算法。种子-密钥算法通常会生成一个伪随机的*种子*，并期望在允许访问之前针对每个种子提供一个特定的响应或*密钥*。一个典型的有效交换可能是这样的：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'or this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这样：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Unfortunately, there’s no standard seed-key algorithm. You might have a 16-bit
    seed and 16-bit key, a 32-bit seed and 16-bit key, or a 32-bit seed and 32-bit
    key. The algorithm that generates a key from a given seed also varies from platform
    to platform. Most algorithms are a combination of simple arithmetic operations
    and one or more values used as part of the computation. There are several techniques
    for figuring out these algorithms in order to give you access to the ECU:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有标准的种子-密钥算法。你可能会遇到16位种子和16位密钥、32位种子和16位密钥，或者32位种子和32位密钥。生成密钥的算法因平台而异。大多数算法是简单算术运算和一个或多个用于计算的值的组合。有几种方法可以搞清楚这些算法，从而为你提供对ECU的访问权限：
- en: • Obtain the firmware for the device in question through other means. Disassemble
    it and analyze the embedded code to find the code responsible for generating seed-key
    pairs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: • 通过其他方式获取设备的固件。对其进行反汇编并分析嵌入式代码，以找出负责生成种子-密钥对的代码。
- en: • Obtain a legitimate software tool—for example, J2534 reflash software—that’s
    capable of generating legitimate seed-key pairs, and analyze the PC application
    code with a disassembler to determine the algorithm used.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: • 获取一个合法的软件工具——例如，J2534重编程软件——它能够生成合法的种子密钥对，并使用反汇编工具分析PC应用程序代码，以确定使用的算法。
- en: • Observe a legitimate tool exchanging keys, and analyze the pairs for patterns.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: • 观察一个合法工具交换密钥，并分析这些密钥对的模式。
- en: • Create a device to spoof a legitimate tool into providing responses repeatedly.
    The main advantage of this method over purely passive observation is that it allows
    you to pick seeds for which you can reproduce the keys.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: • 创建一个设备，欺骗合法工具反复提供响应。这种方法相较于纯粹的被动观察的主要优势在于，它可以让你选择种子，从而重现密钥。
- en: You can find more information about reverse engineering the seed-key algorithms
    used by General Motors at *[http://pcmhacking.net/forums/viewtopic.php?f=4&t=1566&start=10](http://pcmhacking.net/forums/viewtopic.php?f=4&t=1566&start=10)*,
    and those used by VAG MED9.1 at *[http://nefariousmotorsports.com/forum/index.php?topic=4983.0](http://nefariousmotorsports.com/forum/index.php?topic=4983.0)*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*[http://pcmhacking.net/forums/viewtopic.php?f=4&t=1566&start=10](http://pcmhacking.net/forums/viewtopic.php?f=4&t=1566&start=10)*找到有关通用汽车逆向工程种子密钥算法的更多信息，在*[http://nefariousmotorsports.com/forum/index.php?topic=4983.0](http://nefariousmotorsports.com/forum/index.php?topic=4983.0)*找到有关VAG
    MED9.1的更多信息。
- en: '**Backdoor Attacks**'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**后门攻击**'
- en: Sometimes front door attacks are too tricky; you may not have the right tools
    or the lock might be too hard to figure out. Don’t despair—remember that automotive
    control modules are embedded systems, so you can use all the usual hardware-hacking
    approaches. In fact, using more direct-to-hardware backdoor approaches often makes
    more sense than trying to reverse engineer the front door lock placed by the factory,
    especially when trying to reprogram engine modules. If you can obtain a dump of
    the module, you can often disassemble and analyze it to figure out how the keys
    to the front door work. The first step in a hardware backdoor attack is analyzing
    the circuit board.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，正面攻击可能过于复杂；你可能没有合适的工具，或者锁太难破解。不必绝望——记住，汽车控制模块是嵌入式系统，所以你可以使用所有常见的硬件黑客方法。事实上，相比于尝试逆向工程厂商设置的正面锁，使用更直接的硬件后门方法往往更有意义，尤其是在尝试重新编程引擎模块时。如果你能获取到模块的转储数据，通常可以进行反汇编并分析，从而搞清楚正面锁的密钥如何工作。硬件后门攻击的第一步是分析电路板。
- en: When reversing a circuit board of any system, you should start with the largest
    chips first. These larger processor and memory chips are likely to be the most
    complex. It’s a good idea to make a list of part numbers to feed to Google, *[datasheet.com](http://datasheet.com)*,
    or something similar, to obtain a copy of the data sheet. You’ll sometimes encounter
    custom application-specific integrated circuits (ASICs) and one-off chips, especially
    with older ECUs, which will prove more difficult than off-the-shelf parts. In
    many cases, you’ll have to infer the function of these parts based on how they’re
    connected to identifiable parts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在逆向任何系统的电路板时，应该从最大的芯片开始。因为这些较大的处理器和内存芯片可能是最复杂的。建议列出零件号，利用Google、*[datasheet.com](http://datasheet.com)*或类似网站，获取数据手册。有时，你可能会遇到定制的应用特定集成电路（ASIC）和独立芯片，特别是在较旧的ECU中，这些芯片会比常规零件更难处理。在很多情况下，你需要根据这些部件与可识别部件的连接方式，推测它们的功能。
- en: It’s critical to look out for memory chips—SRAM, EEPROM, FlashROM, one-time-programmable
    ROM, serial EEPROM, serial flash, NVSRAM, and so on. The type of memory used varies
    immensely from one platform to another; every single variety listed here has been
    found in the wild. Newer designs are less likely to have parallel memories and
    more likely to have serial chips. Newer microcontrollers are less likely to have
    any external memories at all, as their internal flash capacities have dramatically
    increased. Any nonvolatile memory chip present can be removed from the circuit
    board, read, and then replaced. [Chapter 8](ch08.html#ch08) goes into much more
    detail on reverse engineering the circuit board.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是要注意内存芯片——SRAM、EEPROM、FlashROM、一次性可编程ROM、串行EEPROM、串行Flash、NVSRAM等。不同平台使用的内存类型差异极大；这里列出的每一种类型的内存芯片都有可能在实际应用中遇到。较新的设计较少使用并行内存，更倾向于使用串行芯片。较新的微控制器很少使用外部内存，因为它们的内部Flash存储容量已经大幅增加。任何存在的非易失性内存芯片都可以从电路板上拆卸下来，读取后再替换。[第8章](ch08.html#ch08)会详细讲解如何逆向电路板。
- en: '**Exploits**'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**漏洞**'
- en: Although arguably just another example of a backdoor approach, exploits deserve
    special attention. Rather than taking apart a computer, exploits involve feeding
    a system carefully crafted inputs to make it do things outside normal operation.
    Typically, exploits build on a bug or problem. This bug might cause a system to
    crash, reboot, or perform some undesirable behavior from the perspective of the
    vehicle user. Some of these bugs present the opportunity for buffer overflow attacks,
    which open the door for commandeering the vulnerable device merely by feeding
    it unexpected inputs. A cleverly crafted set of inputs triggers the bug, which
    then makes the device execute arbitrary code provided by the attacker instead
    of triggering the usual fault condition.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以说这只是另一种反向门的例子，但利用工具值得特别关注。与拆解计算机不同，利用工具是通过向系统提供精心设计的输入，使其执行超出正常操作范围的动作。通常，利用工具是基于漏洞或问题构建的。这个漏洞可能导致系统崩溃、重启，或从车辆用户的角度来看，执行一些不希望发生的行为。某些漏洞为缓冲区溢出攻击提供了机会，这使得仅通过向设备输入意外的输入就能控制它。巧妙设计的一组输入触发漏洞，进而使设备执行攻击者提供的任意代码，而不是触发通常的故障条件。
- en: Not all bugs can be turned into exploits, however—some bugs only cause problems
    or shut down core systems. And while bugs are usually discovered by accident,
    most exploits require careful craft. It is unlikely that you’d be able to turn
    a known bug into an exploit without also having prior knowledge of the system,
    usually gained from firmware analysis. At a bare minimum, you’d need basic knowledge
    of the architecture in order to write the necessary code. Most of the time, this
    knowledge needs to be gathered through research prior to writing an exploit.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并不是所有的漏洞都能转化为利用工具——有些漏洞只会导致问题或关闭核心系统。虽然漏洞通常是偶然发现的，但大多数利用工具需要精心制作。没有系统的先验知识，你不太可能将已知漏洞转化为利用工具，这些知识通常来自于固件分析。最起码，你需要对体系结构有基本了解，才能编写必要的代码。大多数情况下，这些知识需要在编写利用工具之前通过研究收集。
- en: It’s hard to find bugs that make suitable attack vectors and it’s often just
    as difficult to write exploits for them, so exploits that build on bugs are fairly
    uncommon. While it is foolish to discount the relevance of exploits, the other
    methods presented here and in [Chapter 8](ch08.html#ch08) are much more practical
    paths to understanding and reprogramming automotive systems in most cases.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找合适的攻击向量的漏洞很难，编写利用工具同样困难，因此基于漏洞的利用工具相对少见。虽然低估利用工具的重要性是愚蠢的，但在[第8章](ch08.html#ch08)和这里介绍的其他方法在大多数情况下是理解和重新编程汽车系统的更实际途径。
- en: '**Reversing Automotive Firmware**'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**汽车固件逆向**'
- en: Hacking into an automotive control module far enough to retrieve its current
    firmware and configuration is really just the beginning of the adventure. At this
    point, you probably have anywhere from 4KB to 4MB of raw machine-ready code, with
    a mixture of various parameters and actual code that forms the program the processor
    will run. Let’s say you have a binary blob in the firmware from one of the hacks
    in this chapter or the chapters later in this book. Next you need to disassemble
    the binary.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客攻击汽车控制模块，足够深入以提取其当前固件和配置，实际上只是冒险的开始。在这个阶段，你可能拥有从4KB到4MB的原始机器可用代码，其中混合了各种参数和实际代码，这些代码构成了处理器将运行的程序。假设你在本章或本书后续章节的某个黑客攻击中获得了固件中的一个二进制块。接下来，你需要反汇编该二进制文件。
- en: First, you must know which chip this binary is for. There are several free decompilers
    for different chips out on the Internet. Otherwise you can drop some cash and
    buy IDA Pro, which supports a large variety of chips. These tools will convert
    the hex values in the binary into assembler instructions. The next stage is to
    figure out what exactly you are looking at.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须知道这个二进制文件适用于哪个芯片。互联网上有一些免费的反编译器，支持不同的芯片。否则，你可以花钱购买IDA Pro，它支持多种芯片。这些工具会将二进制文件中的十六进制值转换为汇编指令。下一步是弄清楚你到底在看什么。
- en: When you’re starting to analyze raw data, a high-level understanding of the
    function of the devices you’re reverse engineering will be key to knowing what
    to look for. You can follow a number of *breadcrumbs*, or clues, for starters;
    these breadcrumbs are almost guaranteed to lead you to interesting and useful
    material. Next, we’ll look at a few specific examples of how to use common automotive
    controller functions to gain insight into their operation, which will hopefully
    allow us to change their behavior.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始分析原始数据时，对你逆向工程的设备功能有一个高层次的理解是非常重要的，这将帮助你知道该寻找什么。你可以首先跟踪一些*线索*，这些线索几乎肯定会引导你找到有趣和有用的材料。接下来，我们将查看一些具体的示例，了解如何使用常见的汽车控制器功能来洞察它们的工作原理，这样我们可能就能改变它们的行为。
- en: '***Self-Diagnostic System***'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自诊断系统***'
- en: Every engine controller has some type of self-diagnostic system that typically
    monitors most critical engine functions, and analyzing this is an excellent route
    to understanding firmware. A good first step in investigative disassembly is to
    identify the location of these procedures. This will provide you with insight
    into the memory locations involved in all of the sensors and functions that are
    checked for errors. Any modern vehicle should support OBD-II packets, which standardize
    the diagnostic data reported. Even controllers created prior to OBD-II standards
    have a way to report faults. Some have a system where an analog input is shorted
    to ground and either an internal LED or the “check engine” light flashes out the
    code. For example, knowing that code 10 refers to a failed intake air temperature
    sensor means you can find the piece of code that sets error code 10 to help you
    identify the internal variables associated with the air temperature sensor.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个发动机控制器都有某种类型的自诊断系统，通常会监控大多数关键的发动机功能，分析这些内容是理解固件的绝佳途径。调查拆解的一个好起点是确定这些程序的位置。这将使你深入了解与所有传感器和检查错误的功能相关的内存位置。任何现代车辆都应该支持
    OBD-II 数据包，这些数据包标准化了报告的诊断数据。即使是 OBD-II 标准之前制造的控制器也有报告故障的方式。有些控制器有一个系统，通过将模拟输入短接到地面，并通过内部
    LED 或“检查引擎”灯闪烁显示代码。例如，知道代码 10 表示进气温度传感器故障，就意味着你可以找到设置错误代码 10 的代码片段，帮助你识别与进气温度传感器相关的内部变量。
- en: For more detailed information on using diagnostics, see [Chapter 4](ch04.html#ch04).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于诊断的详细信息，请参见[第 4 章](ch04.html#ch04)。
- en: '***Library Procedures***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***库函数***'
- en: Being able to change the behavior of a control unit is often one of the primary
    goals of reverse engineering ECU firmware, and identifying data used by a controller
    is an important step in the process. Most ECUs have a set of library functions
    used for routine tasks throughout the code. Library functions used for table lookups
    are worth identifying early on in the reverse engineering process, as these can
    lead straight to the parameters you’re interested in. Each time a table is used,
    a function is called to fetch a result. Calls to this type of function are among
    the most frequent, making them easy to spot.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 改变控制单元行为通常是逆向工程 ECU 固件的主要目标之一，识别控制器使用的数据是该过程中的一个重要步骤。大多数 ECU 都有一组库函数，用于代码中的常规任务。用于表查找的库函数值得在逆向工程过程中尽早识别，因为这些函数可以直接指向你感兴趣的参数。每次使用表时，都会调用一个函数来获取结果。调用此类函数的频率很高，因此很容易识别。
- en: Usually each type of data stored within the ECU—one-dimensional array of bytes;
    two-dimensional array of words; three-dimensional array of unsigned, signed, and
    float shorts; and so on—has a unique reference function. When called, each table
    lookup routine needs to be passed, at a minimum, the table index (or start address)
    and the axis variables. Often, table lookup routines can be reused to pass information
    about the structure of the table, such as how many rows and columns are present.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，ECU 中存储的每种数据——一维字节数组；二维字数组；三维无符号、带符号和浮点短整型数组；等等——都有一个独特的引用函数。调用时，每个表查找程序至少需要传入表的索引（或起始地址）和轴变量。通常，表查找程序可以重用，传递关于表结构的信息，例如表中有多少行和列。
- en: Calibration data is usually stored in program memory, along with the routines
    accessing them. Microcontrollers typically have special instructions to access
    program memory, which provide a unique signature to search for and make table
    lookup routines particularly easy to spot. A secondary characteristic of these
    lookup routines is that they tend to have lots of interpolation math. In addition,
    table lookup routines are often grouped closely together in program memory, making
    it even easier to find others after you’ve found one. After identifying reference
    routines, searching for all calls to them can provide a key to identifying the
    vast majority of data used by the controller to make decisions. The arguments
    passed to these functions typically include the start address of a table, its
    structure or shape, and which variables index elements of the table. Armed with
    this information, you’re much closer to being able to change the behavior of the
    controller.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 校准数据通常存储在程序存储器中，并且有访问这些数据的例程。微控制器通常有特殊的指令来访问程序存储器，这些指令提供了独特的签名，便于查找并使表格查找例程特别容易被发现。这些查找例程的一个次要特征是，它们往往包含大量的插值数学。此外，表格查找例程通常在程序存储器中紧密地分布在一起，使得在找到一个例程后，查找其他例程变得更加容易。在识别出参考例程后，搜索所有对它们的调用可以为识别控制器用来做出决策的绝大多数数据提供关键。传递给这些函数的参数通常包括表格的起始地址、表格的结构或形状，以及用于索引表格元素的变量。有了这些信息，你就离改变控制器的行为更近了一步。
- en: '**Finding Known Tables**'
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**寻找已知表格**'
- en: One way to identify tables is to leverage the specific physical and electrical
    characteristics of vehicle sensors, which will display identifiable characteristics
    within ECU firmware. For example, an ECU with a MAF sensor will have a table that
    translates raw readings of voltage or frequency from the MAF into airflow into
    the engine, providing an internal representation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 识别表格的一种方法是利用车辆传感器的特定物理和电气特性，这些特性将在 ECU 固件中显示出可识别的特征。例如，带有 MAF 传感器的 ECU 会有一个表格，将
    MAF 的原始电压或频率读数转化为进入发动机的气流量，从而提供内部表示。
- en: Fortunately for us, the signal output from an MAF is determined by physics—that
    is, King’s Law—so the curve will always have a characteristic shape, though it’ll
    be slightly different for each sensor. This will result in the tables having a
    characteristic set of values that can be observed in the ROM. Armed with the knowledge
    that there will be universal data to identify, let’s take a closer look at how
    calibration data is displayed in different programs.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，MAF 输出信号由物理学决定——也就是金氏定律——因此曲线将始终具有特征形状，尽管每个传感器的形状略有不同。这将导致表格具有一组可观察到的特征值，可以在
    ROM 中查看。了解这些数据是普遍存在的，接下来我们来仔细看看不同程序中如何显示校准数据。
- en: '[Figures 6-1](ch06.html#ch6fig1) and [6-2](ch06.html#ch6fig2) show similarly
    shaped Ford and Nissan sensor curves; the similarity they illustrate extends to
    multiple manufacturers.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-1](ch06.html#ch6fig1) 和 [图 6-2](ch06.html#ch6fig2) 展示了形状相似的福特和日产传感器曲线；它们所展示的相似性扩展到多个制造商。'
- en: '![image](graphics/f06-01.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-01.jpg)'
- en: '*Figure 6-1: Ford MAF transfer graph*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：福特 MAF 转换图*'
- en: '![image](graphics/f06-02.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-02.jpg)'
- en: '*Figure 6-2: Nissan MAF VQ graph*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：日产 MAF VQ 图*'
- en: '[Figures 6-2](ch06.html#ch6fig2) through [6-6](ch06.html#ch6fig6) show five
    different views of the same data. [Figure 6-3](ch06.html#ch6fig3) shows how the
    VQ curve pictured in [Figure 6-2](ch06.html#ch6fig2) would look in a hex editor.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-2](ch06.html#ch6fig2) 到 [图 6-6](ch06.html#ch6fig6) 展示了同一数据的五种不同视图。[图 6-3](ch06.html#ch6fig3)
    展示了在十六进制编辑器中，[图 6-2](ch06.html#ch6fig2) 中所示的 VQ 曲线会是什么样子。'
- en: '![image](graphics/f06-03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-03.jpg)'
- en: '*Figure 6-3: VQ table in HxD hex editor: 128 bytes or 64- to 16-bit words*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：HxD 十六进制编辑器中的 VQ 表格：128 字节或 64 到 16 位字*'
- en: '[Figures 6-4](ch06.html#ch6fig4) and [6-5](ch06.html#ch6fig5) show the VQ table
    in analyze.exe available from *[https://github.com/blundar/analyze.exe/](https://github.com/blundar/analyze.exe/)*.
    A simple visualization tool, analyze.exe colors cells based on their numeric value.
    You can select the precision of the data—for example, 1 = 8-bit byte, 2 = 16-bit
    word, and 4 = 32-bit long—and how many rows and columns you want present. This
    simple visual arrangement often makes it easier to identify what is code and what
    is data than it is when you’re using a hex editor, as in [Figure 6-3](ch06.html#ch6fig3).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-4](ch06.html#ch6fig4) 和 [6-5](ch06.html#ch6fig5) 显示了在 *[https://github.com/blundar/analyze.exe/](https://github.com/blundar/analyze.exe/)*
    上可以找到的 analyze.exe 中的 VQ 表。analyze.exe 是一个简单的可视化工具，它根据数值大小为单元格上色。你可以选择数据的精度——例如，1
    = 8 位字节，2 = 16 位字，4 = 32 位长整型——以及你希望显示的行和列数。这个简单的视觉排列通常比使用十六进制编辑器（如在 [图 6-3](ch06.html#ch6fig3)
    中）更容易识别哪些是代码，哪些是数据。'
- en: '![image](graphics/f06-04.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-04.jpg)'
- en: '*Figure 6-4: VQ table in analyze.exe: values from 48 to 65535 in first four
    rows of 16×16-bit values*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：analyze.exe 中的 VQ 表：前四行的 16×16 位值，值范围从 48 到 65535*'
- en: '![image](graphics/f06-05.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-05.jpg)'
- en: '*Figure 6-5: First four rows of 16x16-bit values*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：前四行的 16x16 位值*'
- en: Look again at the first four rows of 16×16-bit values in [Figures 6-4](ch06.html#ch6fig4)
    and [6-5](ch06.html#ch6fig5) shaded in analyze.exe. Notice how the smooth nonlinear
    curve in [Figures 6-1](ch06.html#ch6fig1) and [6-2](ch06.html#ch6fig2) mimics
    the smooth nonlinear progression of values. [Figure 6-6](ch06.html#ch6fig6) shows
    the same values in a 64-column layout, so you can see the full gradient of the
    first four rows from [Figure 6-5](ch06.html#ch6fig5). No matter what type of vehicle
    you’re looking at, the overall data structures will be similar.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看 [图 6-4](ch06.html#ch6fig4) 和 [6-5](ch06.html#ch6fig5) 中在 analyze.exe 中阴影处理的前四行
    16×16 位值。注意，[图 6-1](ch06.html#ch6fig1) 和 [6-2](ch06.html#ch6fig2) 中的平滑非线性曲线如何模拟这些值的平滑非线性变化。[图
    6-6](ch06.html#ch6fig6) 显示了相同的值，在 64 列布局中，你可以看到 [图 6-5](ch06.html#ch6fig5) 中前四行的完整梯度。无论你查看哪种类型的载体，整体数据结构都将是相似的。
- en: '![image](graphics/f06-06.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-06.jpg)'
- en: '*Figure 6-6: 64- to 16-bit words per row*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：每行从 64 位到 16 位字的转换*'
- en: Data visualization tools like hex editors or analyze.exe can also be useful
    when you don’t know the exact shape or pattern you are looking for. No matter
    what type of vehicle you’re looking at, data structures will have orders and patterns
    that are not typically seen in executable code. [Figure 6-7](ch06.html#ch6fig7)
    shows an example of the clear visual pattern of data in analyze.exe—gradually
    changing values and repetition should stand out.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 像十六进制编辑器或 analyze.exe 这样的数据可视化工具，也在你不确定要寻找的确切形状或模式时非常有用。无论你正在查看哪种类型的载体，数据结构通常会具有在可执行代码中不常见的顺序和模式。[图
    6-7](ch06.html#ch6fig7) 显示了 analyze.exe 中数据的明显视觉模式——值逐渐变化和重复的现象应该很容易被察觉。
- en: '![image](graphics/f06-07.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-07.jpg)'
- en: '*Figure 6-7: Patterns and gradual changes in table data appear in a 2002 Chevrolet
    Camaro ROM visualized with analyze.exe*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-7：表格数据中的模式和逐渐变化出现在 2002 款雪佛兰 Camaro ROM 中，通过 analyze.exe 可视化*'
- en: On the other hand, when you look at code like that in [Figure 6-8](ch06.html#ch6fig8),
    there is a more random, chaotic appearance. (In [Figures 6-7](ch06.html#ch6fig7)
    and [6-8](ch06.html#ch6fig8), precision is set to 2 because the microcontroller
    unit used is a 16-bit processor and it’s reasonable to assume that a good chunk
    of the data items will be 16-bit as well.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当你查看 [图 6-8](ch06.html#ch6fig8) 中的代码时，它呈现出更为随机、混乱的外观。（在 [图 6-7](ch06.html#ch6fig7)
    和 [6-8](ch06.html#ch6fig8) 中，精度设置为 2，因为使用的微控制器单元是 16 位处理器，可以合理假设大部分数据项也将是 16 位的。）
- en: '![image](graphics/f06-08.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-08.jpg)'
- en: '*Figure 6-8: This random code doesn’t have the neat, orderly patterns that
    are present in most tables.*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-8：这段随机代码没有像大多数表格中那样整齐、有序的模式。*'
- en: '**More to Learn from the MCU**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从 MCU 中学到更多**'
- en: Hopefully, these examples help connect knowledge of the table data you expect
    to find with their representation within a binary blob. Learning the capabilities
    of the microcontroller unit (MCU) used in a target system can shed light on the
    types of data to expect when looking over the binary data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这些示例能帮助你将你期望在表格数据中找到的知识与其在二进制大对象中的表示进行连接。了解目标系统中使用的微控制器单元（MCU）的能力，可以为你查看二进制数据时提供有关预期数据类型的线索。
- en: Generally, data representation formats are dictated by the hardware present.
    Knowing the size of registers on the MCU running the show can be a big help for
    identifying parameters. Most parameters tend to be the same size as or smaller
    than the registers of a given MCU. An 8-bit MCU, like a 68HC11, is likely to have
    lots of 8-bit data. It’s unusual to see mostly 4-byte, or 32-bit, unsigned long
    integers on an 8-bit MCU. While 16-bit data becomes more common on MCUs like the
    68332, 32-bit data becomes the norm with MPC5xx Power Architecture MCUs and so
    on. It’s unusual to find floating-point data on an MCU that lacks a floating-point
    processor.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数据表示格式由硬件决定。了解运行程序的MCU寄存器的大小，对于识别参数非常有帮助。大多数参数的大小通常与给定MCU的寄存器相同或更小。比如，像68HC11这样的8位MCU，通常会有很多8位数据。在8位MCU上看到主要是4字节或32位无符号长整型数据是不常见的。虽然像68332这样的MCU上16位数据变得更加常见，但在MPC5xx
    Power架构MCU及其后续版本中，32位数据成为常态。在没有浮点处理器的MCU上，找到浮点数据是很不寻常的。
- en: '***Comparing Bytes to Identify Parameters***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***比较字节以识别参数***'
- en: It’s often possible to get multiple bins that’ll run on the same physical ECU.
    The more the better! Doing a simple compare in a hex editor will show which bytes
    differ between the files. It’s common—but not guaranteed—for code to remain unchanged
    while parameters change. If less than 5 percent of the files differ, it’s generally
    safe to assume that the differences are parameters. If you know what’s been changed
    functionally between the two bins and you know which bytes have changed, you have
    further clues to help correlate changes in the ROM with changes in parameters.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以获得多个bin文件，这些文件可以在相同的物理ECU上运行。越多越好！在十六进制编辑器中进行简单比较会显示文件之间哪些字节不同。代码保持不变而参数发生变化是常见的——但不能保证。如果文件之间的差异小于5％，通常可以安全地假设这些差异是参数。如果你知道两个bin文件之间功能上的变化，并且知道哪些字节发生了变化，那么你可以获得更多线索，帮助你将ROM中的变化与参数的变化关联起来。
- en: '[Figures 6-9](ch06.html#ch6fig9) and [6-10](ch06.html#ch6fig10) compare a 1996
    V8 Mustang and a 1997 V6 Thunderbird, showing 6,667 differences out of 114,688
    bytes. This is an extreme example of having the same code with different parameters,
    but there’s still only about a 5.8 percent difference compared to overall file
    size.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-9](ch06.html#ch6fig9) 和 [6-10](ch06.html#ch6fig10) 比较了1996年V8 Mustang与1997年V6
    Thunderbird，展示了在114,688字节中有6,667个差异。这是一个极端的例子，展示了相同的代码在不同参数下的变化，但与整体文件大小相比，差异仅约为5.8％。'
- en: Most processors use an interrupt vector table defined by the processor being
    used. Referencing the processor’s data sheet will define the structure of interrupt
    routines, allowing you to quickly identify the interrupt handlers. Tracing interrupt
    pins on the processor to circuitry within the ECU to pins you can reference in
    a vehicle wiring diagram can help you identify code blocks used to service such
    hardware functions as fuel and spark control, crank and cam signal processing,
    and idle functions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数处理器使用由所用处理器定义的中断向量表。参考处理器的数据手册可以定义中断例程的结构，从而帮助你快速识别中断处理程序。通过追踪处理器的中断引脚到ECU内的电路，再到车辆接线图中可以参考的引脚，可以帮助你识别用于服务硬件功能的代码块，例如燃油和点火控制、曲轴和凸轮信号处理以及空转功能。
- en: '![image](graphics/f06-09.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-09.jpg)'
- en: '*Figure 6-9: Comparison of a 1996 V8 Mustang* (DXE2.bin) *and a 1997 V6 Thunderbird*
    (SPP3.bin)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-9：1996年V8 Mustang*（DXE2.bin）*与1997年V6 Thunderbird*（SPP3.bin）*的比较*'
- en: '![image](graphics/f06-10.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-10.jpg)'
- en: '*Figure 6-10: File compare function of the HxD hex editor*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-10：HxD十六进制编辑器的文件比较功能*'
- en: '***Identifying ROM Data with WinOLS***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用WinOLS识别ROM数据***'
- en: WinOLS is a popular commercial program for modifying bins. It combines a series
    of tools for calculating and updating checksums within a ROM with a set of tools
    for identifying tables. [Figures 6-11](ch06.html#ch6fig11) and [6-12](ch06.html#ch6fig12)
    illustrate WinOLS in use.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: WinOLS是一款流行的商业程序，用于修改bin文件。它结合了一系列工具来计算和更新ROM中的校验和，并配有一组工具用于识别表格。[图6-11](ch06.html#ch6fig11)和[6-12](ch06.html#ch6fig12)展示了WinOLS的使用情况。
- en: If the ROM type is known, it has many templates that automatically identify
    configuration parameters. Most of the known built-in ROM types are geared toward
    Bosch Motronic ECUs. Templates and configurations can be saved, shared, and sold
    to enable users to make modifications to specific files with greater ease. WinOLS
    is arguably the most common software used for identifying interesting data within
    a ROM that doesn’t involve code analysis. It’s designed to facilitate rapid tuning
    changes to a controller.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已知 ROM 类型，它有许多模板，可以自动识别配置参数。大多数已知的内置 ROM 类型都面向博世 Motronic ECU。模板和配置可以保存、共享，并出售，使用户能够更轻松地对特定文件进行修改。WinOLS
    可以说是用于识别 ROM 中有趣数据的最常见软件，它不涉及代码分析。它的设计旨在便于快速调整控制器的设置。
- en: '![image](graphics/f06-11.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-11.jpg)'
- en: '*Figure 6-11: WinOLS supports 2D and 3D table views, as shown in these alternate
    views.*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-11：WinOLS 支持 2D 和 3D 表格视图，如这些替代视图所示。*'
- en: '![image](graphics/f06-12.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-12.jpg)'
- en: '*Figure 6-12: WinOLS being used on a 2006 Volkswagen 2.0Tsi ECU*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-12：WinOLS 用于分析 2006 年大众 2.0Tsi ECU*'
- en: '**Code Analysis**'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**代码分析**'
- en: 'Code analysis can be a long, complicated task. If you’re starting from scratch,
    with no experience, it will likely take hundreds of hours to analyze a complex
    piece of code. Modern control units often have upward of a megabyte or two of
    code, which is a huge amount of code when you’re looking at it in assembly. An
    ECU from 1995 with 32 kilobytes (not megabytes) of code will have upward of 10,000
    assembly instructions to sort out. Bottom line: do not underestimate how much
    work this approach will take. I’ll briefly introduce a few tools, but I don’t
    have the space to address the topic in sufficient depth for someone unfamiliar
    with the process. (After all, entire books have been written solely on code analysis.)
    Here, I’ll just talk through specific tools and methods particularly applicable
    to automotive embedded systems.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分析可能是一个漫长而复杂的任务。如果你是从零开始，没有经验，分析一段复杂的代码可能需要数百小时。现代控制单元的代码通常有一到两兆字节，这在你用汇编语言查看时是一大堆代码。1995
    年的 ECU 代码为 32 千字节（而不是兆字节），可能有超过 10,000 条汇编指令需要整理。最重要的是：不要低估这种方法所需的工作量。我会简要介绍一些工具，但没有足够的空间对这个话题进行深入讨论，尤其是对于那些不熟悉这一过程的人来说。（毕竟，关于代码分析已经有整本书了。）在这里，我只会讨论一些特别适用于汽车嵌入式系统的工具和方法。
- en: When analyzing a new target, first identify the architecture you’re working
    with. Knowing what processor executed the blob of binary will help you choose
    an appropriate software tool to further assist. If you can’t identify a processor
    based on the markings on the chip itself, search online for data sheets to identify
    it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析一个新的目标时，首先要识别你正在使用的架构。了解哪个处理器执行了这段二进制代码，将帮助你选择合适的软件工具进一步辅助分析。如果你无法通过芯片上的标记来识别处理器，可以在线搜索数据手册来帮助识别。
- en: To analyze code, you might need to find a disassembler. A quick Google search
    reveals that there are lots of them out there. Some target a single architecture—for
    example, Dis51—and some are custom-written for automotive reverse engineering—for
    example, Dis66k. Others, like CATS dasm, IDA Pro, Hopper, dasmx, and objdump from
    the GNU Binary Utilities (binutils), target multiple processors. IDA Pro supports
    more embedded targets than just about any other program, but it’s also one of
    the most expensive disassemblers. GNU binutils also supports a pretty wide range
    of architectures, but the version included on most systems will be built only
    for the “native” architecture. Rebuilding binutils with all architectures enabled
    will open a few doors. Your budget and supported processors will determine which
    disassemblers are an option.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要分析代码，你可能需要找到一个反汇编器。快速搜索一下 Google，你会发现有很多这样的工具。一些反汇编器只针对单一架构——例如 Dis51——而一些则是为汽车逆向工程专门编写的——例如
    Dis66k。还有一些，像 CATS dasm、IDA Pro、Hopper、dasmx 和 GNU 二进制工具（binutils）中的 objdump，支持多种处理器架构。IDA
    Pro 支持的嵌入式目标比大多数其他程序都要多，但它也是最昂贵的反汇编器之一。GNU binutils 也支持相当广泛的架构，但大多数系统中包含的版本仅针对“本地”架构构建。如果重新构建
    binutils 并启用所有架构，将为你打开一些大门。你的预算和支持的处理器将决定哪些反汇编器是可用的。
- en: Bust out the disassembly tools and start trying to make sense of the mess, but
    as I warned earlier, this might take hundreds of hours. A divide-and-conquer mentality
    works best—focus on the smaller tasks rather than the project as a whole. If you
    obtained the binary by backdoor methods, you probably already took the ECU apart
    to identify the processor. If you cracked the J2534 programming routines, you
    might not have a clue what processor is running the show. In this case, you’re
    going to need to keep running it through a disassembler over and over using different
    settings until you get something that makes sense.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 拿出反汇编工具，开始尝试理解这些杂乱无章的内容，但正如我之前警告的，这可能需要几百个小时。采用“分而治之”的心态效果最佳——聚焦于小任务，而不是整个项目。如果你通过后门方法获得了二进制文件，你可能已经拆解了ECU来识别处理器。如果你破解了J2534编程例程，你可能不知道是哪个处理器在主导操作。在这种情况下，你需要不断地通过反汇编器使用不同的设置进行运行，直到得到一个有意义的结果。
- en: You’re looking for assembly code that disassembles cleanly, meaning that it
    looks like it makes logical sense. If you disassemble a binary for the wrong architecture
    or using the wrong settings, you’ll still see assembly instructions, but the assembler
    actions won’t make sense. Disassembly is a bit of an art, and it may take a little
    practice at seeing a “clean” assembler to get the hang of identifying when a dissassembler
    is providing the correct response, especially when nonexecutable tables and data
    are scattered among the code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要寻找反汇编后能清晰显示的汇编代码，这意味着它看起来有逻辑。如果你对错误的架构进行了反汇编，或者使用了错误的设置，你仍然会看到汇编指令，但汇编动作将没有意义。反汇编有点像一门艺术，可能需要一些实践来识别“干净”的汇编，尤其是当非执行表格和数据在代码中散布时，要学会识别反汇编器是否提供了正确的响应。
- en: 'Here are some hints for making sense of disassembled code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提示，帮助你理解反汇编代码：
- en: • OEMs love to patent stuff. If you can find the patents relevant to your system,
    you may end up with a guided tour of the code being disassembled. This is probably
    the most consistently available high-level procedural guide to help you understand
    the logic in an automotive computer. Patents usually lead production by at least
    one to two years, if not more.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: • OEM（原始设备制造商）喜欢为技术申请专利。如果你能找到与系统相关的专利，你可能会得到一份关于反汇编代码的指导性文档。这很可能是最一致可用的高层次过程指南，有助于你理解汽车计算机中的逻辑。专利通常至少领先于生产一到两年，甚至更多。
- en: • Look at any available software for manipulating the ECU at hand for insight
    into the structure and purpose of code segments. You can often infer a model of
    behavior from tables available to be modified in aftermarket software.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: • 查看任何可用的软件，以便通过操作手头的ECU获取代码段的结构和目的。你通常可以通过售后软件中可修改的表格推测出行为模型。
- en: • Otherwise, start with a wiring diagram for the vehicle, and trace connections
    back through ECU circuitry to particular pins on the MCU. This should tell you
    which piece of MCU hardware handles which function. Cross reference the interrupt
    tables, or look for calls to service particular pieces of hardware in order to
    identify which piece(s) of code service that hardware function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: • 否则，从车辆的接线图开始，追踪连接通过ECU电路到达MCU的特定引脚。这应该能告诉你哪个MCU硬件处理了哪个功能。交叉引用中断表，或查找服务特定硬件的调用，以识别哪些代码段处理该硬件功能。
- en: A plain, or old-style, disassembler will output very verbose text. Each individual
    instruction is parsed. Some disassemblers will attempt to mark areas referenced
    as data and void disassembling them. Other disassemblers need to be specifically
    told which areas are code and which areas are data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的，或旧式的，反汇编器会输出非常冗长的文本。每个单独的指令都会被解析。一些反汇编器会尝试标记作为数据引用的区域，并避免对其进行反汇编。其他反汇编器则需要特别告知哪些区域是代码，哪些区域是数据。
- en: '***A Plain Disassembler at Work***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一个普通反汇编器的工作***'
- en: 'To see disassembly in action, we’ll look at a plain disassembly of a 1990 Nissan
    300ZX Twin Turbo ROM. This ECU has a 28-pin external 27C256 EPROM, so it’s relatively
    easy to obtain its contents. This particular platform uses a HD6303 MCU, a derivative
    of the Motorola 6800 8-bit MCU that appears to be supported by the free disassembler
    DASMx (see *[http://www.16paws.com/ECU/DASMxx/DASMx.htm](http://www.16paws.com/ECU/DASMxx/DASMx.htm)*).
    DASMx comes with minimal instructions: to disassemble *foo.bin*, create a file,
    *foo.sym*, that describes which platform is in use, and then create an entry point
    in memory to place the image, symbols you know about, and so on. Time for a crash
    course in the architecture!'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到反汇编的实际效果，我们将查看1990年日产300ZX双涡轮ROM的简单反汇编。这款ECU使用的是一颗28引脚的外部27C256 EPROM，因此相对容易获取其内容。这个平台使用的是HD6303
    MCU，它是摩托罗拉6800 8位MCU的一个衍生版本，似乎可以通过免费的反汇编工具DASMx进行支持（请参见*[http://www.16paws.com/ECU/DASMxx/DASMx.htm](http://www.16paws.com/ECU/DASMxx/DASMx.htm)*）。DASMx附带的说明非常简洁：要反汇编*foo.bin*，需要创建一个文件*foo.sym*，描述使用的平台类型，然后在内存中创建一个入口点来放置映像、已知的符号等。是时候进行架构速成课程了！
- en: A critical point about the memory structure is that the MCU can address 65535
    bytes (64KB). This information tells you what to expect when looking at the addresses
    in your binary blob. Further reading suggests that the interrupt vector table
    lies at the *end* of addressable memory, with the reset vector—where every processor
    starts after a reset—at 0xFFFE/0xFFFF. Assuming that the 32KB (0x7FFF hex) binary
    blob we have from reading the EPROM contains the interrupt vector table, we can
    figure out that the binary image needs to start at memory address 0x8000 for it
    to end at 0xFFFF (0xFFFF – 0x7FFF = 0x8000). It also helps to search online to
    see whether others are trying to do something similar. For example, the post at
    *[http://forum.nistune.com/viewtopic.php?f=2&t=417](http://forum.nistune.com/viewtopic.php?f=2&t=417)*
    is for a smaller 16KB binary based on settings for a 0xC000 entry point. The more
    legwork and research you do prior to actually invoking a disassembler, the more
    likely you are to get reasonable results.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关于内存结构的一个关键点是，MCU可以寻址65535字节（64KB）。这个信息告诉你在查看二进制文件中的地址时应该期待什么。进一步的阅读表明，中断向量表位于可寻址内存的*末尾*，而复位向量——每个处理器在重置后开始的地方——位于0xFFFE/0xFFFF。假设我们从读取EPROM中获得的32KB（0x7FFF十六进制）二进制文件包含了中断向量表，那么我们可以推断出二进制映像需要从内存地址0x8000开始，这样它就可以在0xFFFF结束（0xFFFF
    – 0x7FFF = 0x8000）。同时，搜索在线资源查看是否有其他人正在做类似的事情也很有帮助。例如，* [http://forum.nistune.com/viewtopic.php?f=2&t=417](http://forum.nistune.com/viewtopic.php?f=2&t=417)*上的帖子是关于一个较小的16KB二进制文件，它基于0xC000入口点的设置。在实际调用反汇编工具之前做更多的前期调研和研究，越有可能获得合理的结果。
- en: '[Figure 6-13](ch06.html#ch6fig13) shows the symbol table for the 300ZX binary.
    Next to each `symbol` is the memory address used by the firmware. These memory
    addresses can hold values such as incoming data from different physical pins on
    the chip or internal information, like timing.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-13](ch06.html#ch6fig13)展示了300ZX二进制文件的符号表。在每个`符号`旁边是固件使用的内存地址。这些内存地址可以保存如来自芯片不同物理引脚的输入数据或内部信息（如时序）等值。'
- en: '![image](graphics/f06-13.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-13.jpg)'
- en: '*Figure 6-13: Symbol file for 32KB 300ZX binary disassembly with DASMx*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-13：DASMx反汇编32KB 300ZX二进制文件的符号文件*'
- en: We’ll use DASMx to disassemble the binary. As shown in [Figure 6-14](ch06.html#ch6fig14),
    DASMx reports a Hitachi 6303 MCU with a source file length, or size, of 32KB,
    which is 32768 bytes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用DASMx来反汇编这个二进制文件。如[图6-14](ch06.html#ch6fig14)所示，DASMx报告了一个日立6303 MCU，其源文件的长度或大小为32KB，即32768字节。
- en: '![image](graphics/f06-14.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-14.jpg)'
- en: '*Figure 6-14: Running DASMx to disassemble 32KB 300ZX binary*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-14：运行DASMx反汇编32KB 300ZX二进制文件*'
- en: Now cross your fingers and hope for a meaningful result!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，交叉你的手指，祈祷得到一个有意义的结果！
- en: 'The result is the vector table shown in [Figure 6-15](ch06.html#ch6fig15),
    which looks sane enough: all addresses are above the 0x8000 entry point specified.
    Notice that the reset vector (0xFFFE, `RES-vector`) has a pointer to the `RESET_entry`
    at 0xBE6D.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 结果就是[图6-15](ch06.html#ch6fig15)中显示的向量表，看起来是合理的：所有地址都位于指定的0x8000入口点之上。注意，复位向量（0xFFFE，`RES-vector`）指向位于0xBE6D的`RESET_entry`。
- en: '![image](graphics/f06-15.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-15.jpg)'
- en: '*Figure 6-15: Disassembled vector table*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-15：反汇编的向量表*'
- en: We can disassemble the code at 0xBE6D for the reset vector, which is also the
    entry point for code. In [Figure 6-16](ch06.html#ch6fig16), we see a routine,
    `RESET_entry`, that looks like it wipes a chunk of RAM. This is a plausible part
    of the initial reset sequence because often when booting, firmware will initialize
    the data region to all 0s.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 0xBE6D 处反汇编复位向量，该位置也是代码的入口点。在[图 6-16](ch06.html#ch6fig16)中，我们看到一个例程，`RESET_entry`，它看起来像是清除了一块
    RAM。这是初始复位序列中一个合理的部分，因为在启动时，固件通常会将数据区域初始化为全零。
- en: '![image](graphics/f06-16.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-16.jpg)'
- en: '*Figure 6-16: Reset vector disassembly*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-16：复位向量反汇编*'
- en: 'We’ve taken this example as far as obtaining a disassembled binary image and
    looking for basic sanity. Now, for the hard part: following the code, breaking
    it into routines, and trying to figure out how it works.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将这个示例进行到获取反汇编二进制镜像并检查基本合理性为止。现在，进入更难的部分：跟踪代码，将其拆分为多个例程，并试图弄清楚它是如何工作的。
- en: '***Interactive Disassemblers***'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***交互式反汇编器***'
- en: As of this writing, IDA Pro is the most popular interactive disassembler available.
    It performs the same tasks as the simple disassembler just discussed, and more.
    Specifically, IDA Pro names registers and variables; once IDA Pro identifies and
    names a variable, or memory address—for instance, $FC50–RPM—it gives all references
    to that variable within the code a descriptive name rather than a less-recognizable
    plain hex address. IDA Pro also graphs code to visualize program flow.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文写作时，IDA Pro 是目前最受欢迎的交互式反汇编器。它执行与刚才讨论的简单反汇编器相同的任务，还做得更多。具体来说，IDA Pro 为寄存器和变量命名；一旦
    IDA Pro 识别并命名了一个变量或内存地址——例如，$FC50–RPM——它会为代码中对该变量的所有引用赋予一个描述性名称，而不是较难识别的普通十六进制地址。IDA
    Pro 还可以绘制代码图表，以可视化程序流程。
- en: One of the advantages of IDA Pro is that it’s programmable to allow additional
    opcodes for customizing automotive processors and plugins for further processing
    disassembled code (for example, decompiling assembly into higher language code);
    it also lets you use structs, unions, classes, and other user-defined data types.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: IDA Pro 的一个优点是它可以编程，允许为定制汽车处理器添加额外的操作码，并为进一步处理反汇编代码（例如，将汇编代码反编译为更高级的语言代码）提供插件；它还允许使用结构体、联合体、类和其他用户定义的数据类型。
- en: Lastly, IDA Pro supports more embedded platforms out of the box than just about
    any other disassembler currently available.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，IDA Pro 支持的嵌入式平台比当前市面上几乎所有其他反汇编器都要多。
- en: You don’t necessarily need these functions to successfully analyze code, but
    they make things substantially easier. [Figures 6-17](ch06.html#ch6fig17) and
    [6-18](ch06.html#ch6fig18) are screenshots from real code analysis with IDA Pro.
    Thanks to Matt Wallace for graciously posting these examples in a public forum.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不一定需要这些功能来成功分析代码，但它们会大大简化工作。[图 6-17](ch06.html#ch6fig17) 和 [6-18](ch06.html#ch6fig18)
    是使用 IDA Pro 进行的实际代码分析的截图。感谢 Matt Wallace 在公开论坛上慷慨地发布了这些示例。
- en: The user in [Figure 6-18](ch06.html#ch6fig18) obtained Acura NSX ECU firmware
    through a combination of hardware-hacking approaches, took the code apart, analyzed
    it using IDA Pro, and rewrote it. Next, the user determined the necessary functions
    to log data from the ECU and alter its operation. The result allowed the user
    to use forced induction—that is, turbochargers and superchargers—with a factory
    computer; this would have been impossible without ECU modification.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-18](ch06.html#ch6fig18)中的用户通过多种硬件破解方法获得了 Acura NSX ECU 固件，将代码拆解后使用 IDA
    Pro 进行了分析，并对其进行了重写。接下来，用户确定了从 ECU 日志数据并修改其操作所需的功能。最终的结果使得用户能够在工厂电脑上使用强制进气——即涡轮增压器和机械增压器；如果没有
    ECU 修改，这是不可能实现的。'
- en: '![image](graphics/f06-17.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-17.jpg)'
- en: '*Figure 6-17: IDA diagram showing a custom-written routine for NVRAM real-time
    programming*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-17：显示为 NVRAM 实时编程编写的自定义例程的 IDA 图*'
- en: '![image](graphics/f06-18.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f06-18.jpg)'
- en: '*Figure 6-18: IDA diagram of code for checking fuel injectors on NSX ECU*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-18：用于检查 NSX ECU 燃油喷射器的代码的 IDA 图*'
- en: '**Summary**'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Because hacking on the ECU often involves processors that are smaller than those
    used in more powerful modern devices, such as cell phones, the tools used for
    reversing the firmware differ for each target. By using a combination of techniques,
    such as data visualization to locate tables, and by reversing the firmware directly,
    you can identify the areas you’re interested in modifying. The methods discussed
    in this chapter are techniques commonly used by performance tuners to adjust how
    a vehicle handles fuel efficiency. All can be used to unlock features hidden in
    the code of your vehicle. We’ll look at performance tuning in more detail in [Chapter
    13](ch13.html#ch13).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因为对ECU的破解通常涉及到比现代设备（如手机）使用的处理器更小的处理器，因此用于反向工程固件的工具在不同的目标设备之间有所不同。通过结合多种技术，比如使用数据可视化来定位表格，和直接反向固件，你可以识别出你感兴趣的修改区域。本章讨论的方法是性能调校员常用的技术，用于调整车辆的燃油效率表现。这些方法都可以用来解锁隐藏在你车辆代码中的功能。我们将在[第13章](ch13.html#ch13)中更详细地探讨性能调校。
