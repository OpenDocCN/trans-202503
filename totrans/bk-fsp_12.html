<html><head></head><body><section class="chapter" title="Chapter&#xA0;12.&#xA0;Computation Expressions" epub:type="chapter" id="computation_expressions"><div class="titlepage"><div><div><h2 class="title">Chapter 12. Computation Expressions</h2></div></div></div><p><a id="iddle1253" class="indexterm"/><a id="iddle1656" class="indexterm"/>In <a class="xref" href="ch06.html" title="Chapter 6. Going to Collections">Chapter 6</a>, we looked at how sequence expressions simplify creating sequences. In <a class="xref" href="ch10.html" title="Chapter 10. Show Me the Data">Chapter 10</a>, we saw how query expressions provide a unified approach to querying data from disparate data sources. Similarly, in <a class="xref" href="ch11.html" title="Chapter 11. Asynchronous and Parallel Programming">Chapter 11</a>, we explored how asynchronous workflows can be employed to simplify creating and executing asynchronous operations. Each of these constructs serves a very different purpose, but what they all have in common is that they’re examples of another F# language feature: the computation expression.</p><p><span class="emphasis"><em>Computation expressions</em></span>, sometimes referred to as <span class="emphasis"><em>workflows</em></span>, provide a convenient construct for expressing a series of operations where data flow and side effects are controlled. In that regard, computation expressions are similar to what other functional languages refer to as <span class="emphasis"><em>monads</em></span>. Where computation expressions differ, though, is that they’re designed in such a way that individual expressions look like a natural part of the language.</p><p><a id="iddle1250" class="indexterm"/><a id="iddle1251" class="indexterm"/><a id="iddle1252" class="indexterm"/>Within the context of a computation expression, you can repurpose several familiar language elements—such as the <code class="literal">let</code> and <code class="literal">use</code> keywords, and <code class="literal">for</code> loops—to unify the syntax with the language. Computation expressions also provide an alternative “bang” syntax for some of these elements, allowing you to nest computation expressions for inline evaluation.</p><p>This feature’s generalized nature means that computation expressions can simplify working with complex types and are applicable to a variety of situations. For instance, we already know that the built-in computation expressions streamline sequence creation, querying, and asynchronous processing, but they also have applications in logging and in projects such as the {m}brace framework that aim to simplify offloading computations to the cloud.</p><p>In this chapter, we’ll explore the inner workings of computation expressions. We’ll forego discussing monadic theory because it doesn’t really help you understand how computation expressions can fit into your solutions. Instead, we’ll begin with a look at builder classes and how they enable computation expressions. With that foundation established, we’ll then walk through two examples of custom computation expressions.</p><div class="sect1" title="Anatomy of a Computation Expression"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="anatomy_of_a_computation_expression">Anatomy of a Computation Expression</h2></div></div></div><p>You’re already familiar with the basic pattern for writing computation expressions, but until now, you haven’t seen how they work beyond a brief glimpse behind the scenes when we created some additional query operators in <a class="xref" href="ch10.html#extending_query_expressions" title="Extending Query Expressions">Extending Query Expressions</a>. To reiterate for the more general case, computation expressions take the following form:</p><a id="pro_id00613"/><pre class="programlisting"><span class="emphasis"><em>builder-name</em></span> { <span class="emphasis"><em>computation-expression-body</em></span> }</pre><p>Computation expressions are designed around an underlying <span class="emphasis"><em>computation type</em></span> (sometimes called a <span class="emphasis"><em>monadic type</em></span>) that we compute by transparently invoking methods exposed by a <span class="emphasis"><em>builder class</em></span>. In the preceding syntax, <span class="emphasis"><em>builder-name</em></span> represents a concrete instance of a builder class, and <span class="emphasis"><em>computation-expression-body</em></span> represents the series of nested expressions that map to the method calls necessary to produce an instance of the computation type. For example, asynchronous workflows are based on <code class="literal">Async&lt;'T&gt;</code> and built via <code class="literal">AsyncBuilder</code>. Similarly, query expressions are based on <code class="literal">QuerySource&lt;'T, 'Q&gt;</code> and built via <code class="literal">QueryBuilder</code>.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note01"/>Note</h3><p><span class="emphasis"><em>Sequence expressions are an anomaly in the realm of computation expressions in that they don’t follow the normal implementation pattern. Although sequence expressions use the computation expression syntax and are based on <code class="literal">IEnumerable&lt;'T&gt;</code>, they don’t have a corresponding builder class. Instead, the details that would normally be handled by the builder class are handled directly by the F# compiler.</em></span></p></div><p>Builder classes define the operations supported by a computation expression. Defining a builder class is largely a matter of convention, as <a id="iddle1208" class="indexterm"/><a id="iddle1254" class="indexterm"/><a id="iddle1323" class="indexterm"/><a id="iddle1444" class="indexterm"/><a id="iddle1562" class="indexterm"/><a id="iddle1853" class="indexterm"/><a id="iddle1855" class="indexterm"/><a id="iddle1857" class="indexterm"/><a id="iddle2028" class="indexterm"/><a id="iddle2031" class="indexterm"/><a id="iddle2086" class="indexterm"/><a id="iddle2087" class="indexterm"/><a id="iddle2092" class="indexterm"/><a id="iddle2114" class="indexterm"/><a id="iddle2125" class="indexterm"/><a id="iddle2127" class="indexterm"/><a id="iddle2129" class="indexterm"/><a id="iddle2131" class="indexterm"/>there are no specific interfaces to implement or base classes to inherit. There aren’t any steadfast rules for naming builder classes, but you typically do so by appending <code class="literal">Builder</code> to the underlying type name (for example, <code class="literal">AsyncBuilder</code> and <code class="literal">QueryBuilder</code>).</p><p>Although computation expressions are part of the language, they are really just syntactic sugar—a more convenient way to call into the builder class’s methods. When the compiler encounters what appears to be a computation expression, it attempts to convert the code to a series of method calls through a process called <span class="emphasis"><em>desugaring</em></span>. This process involves replacing each operation in the computation expression with a call to a corresponding instance method on the builder type (similar to how LINQ query expressions are translated to extension method calls and delegates in C# and Visual Basic). I like to think of the builder class methods as belonging to either of two groups. The first group, listed in <a class="xref" href="ch12.html#control_methods_for_syntactic_elements" title="Table 12-1. Control Methods for Syntactic Elements">Table 12-1</a>, controls various syntactic elements such as bindings, <code class="literal">for</code> and <code class="literal">while</code> loops, and return values.</p><div class="table"><a id="control_methods_for_syntactic_elements"/><div class="table-title">Table 12-1. Control Methods for Syntactic Elements</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/><col class="c3"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Method</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Signature</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Bind</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Enables <code class="literal">let!</code> and <code class="literal">do!</code> bindings</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">M&lt;'T&gt; * ('T -&gt; M&lt;'U&gt;) -&gt; M&lt;'U&gt;</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">For</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Enables <code class="literal">for</code> loops</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">seq&lt;'T&gt; * ('T -&gt; M&lt;'U&gt;) -&gt; M&lt;'U&gt;</code></p>
<p>or</p>
<p><code class="literal">seq&lt;'T&gt; * ('T -&gt; M&lt;'U&gt;) -&gt; seq&lt;M&lt;'U&gt;&gt;</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Return</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Enables <code class="literal">return</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">'T -&gt; M&lt;'T&gt;</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">ReturnFrom</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Enables <code class="literal">return!</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">M&lt;'T&gt; -&gt; M&lt;'T&gt;</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">TryFinally</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows exception handling through <code class="literal">try...finally</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">M&lt;'T&gt; * (unit -&gt; unit) -&gt; M&lt;'T&gt;</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">TryWith</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows exception handling through <code class="literal">try...with</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">M&lt;'T&gt; * (exn -&gt; M&lt;'T&gt;) -&gt; M&lt;'T&gt;</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Using</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Enables creating <code class="literal">IDisposable</code> objects with <code class="literal">use</code> and <code class="literal">use!</code></p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">'T * ('T -&gt; M&lt;'U&gt;) -&gt; M&lt;'U&gt;</code></p>
<p>when</p>
<p><code class="literal">'U :&gt; IDisposable</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">While</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Allows you to use <code class="literal">while...do</code> loops within a computation expression</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">(unit -&gt; bool) * M&lt;'T&gt; -&gt; M&lt;'T&gt;</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Yield</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Returns items from a nested computation expression using a sequence-like approach with the <code class="literal">yield</code> keyword</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">'T -&gt; M&lt;'T&gt;</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><code class="literal">YieldFrom</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>Returns items from a nested computation expression using a sequence-like approach with the <code class="literal">yield!</code> keyword</p></td><td style="vertical-align: top; "><p><code class="literal">M&lt;'T&gt; -&gt; M&lt;'T&gt;</code></p></td></tr></tbody></table></div></div><p>The second group of methods, those that control how computation expressions are evaluated, is listed in <a class="xref" href="ch12.html#methods_affecting_computation_expression" title="Table 12-2. Methods Affecting Computation Expression Evaluation">Table 12-2</a>.</p><div class="table"><a id="methods_affecting_computation_expression"/><div class="table-title">Table 12-2. Methods Affecting Computation Expression Evaluation</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/><col class="c3"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><a id="iddle1241" class="indexterm"/><a id="iddle1306" class="indexterm"/><a id="iddle1859" class="indexterm"/><a id="iddle2135" class="indexterm"/>Method</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Description</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Signature</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Combine</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Merges two parts of a computation expression into one</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">M&lt;'T&gt; * M&lt;'T&gt; -&gt; M&lt;'T&gt;</code></p>
<p>or</p>
<p><code class="literal">M&lt;unit&gt; * M&lt;'T&gt; -&gt; M&lt;'T&gt;</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Delay</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Wraps a computation expression in a function for deferred execution, thereby helping prevent unintended side effects</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">(unit -&gt; M&lt;'T&gt;) -&gt; M&lt;'T&gt;</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">Run</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Executed as the last step in evaluating a computation expression; can “undo” a delay by invoking the function returned by <code class="literal">Delay</code> and can also transform the result into a more consumable format</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p><code class="literal">M&lt;'T&gt; -&gt; M&lt;'T&gt;</code></p>
<p>or</p>
<p><code class="literal">M&lt;'T&gt; -&gt; 'T</code></p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p><code class="literal">Zero</code></p></td><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>Returns a default value for the expression’s monadic type; used when a computation expression doesn’t explicitly return a value</p></td><td style="vertical-align: top; "><p><code class="literal">unit -&gt; M&lt;'T&gt;</code>(<code class="literal">'T</code> can be <code class="literal">unit</code>)</p></td></tr></tbody></table></div></div><p>Because computation expressions are intended to be designed in such a way that they apply to a variety of situations, it’s important to keep them as generic as possible. This is reflected in the highly generalized structure of the signatures. For instance, the notation <code class="literal">M&lt;_&gt;</code> is used to indicate that the underlying type wraps another value.</p><p>It is not necessary to implement each method listed in <a class="xref" href="ch12.html#control_methods_for_syntactic_elements" title="Table 12-1. Control Methods for Syntactic Elements">Table 12-1</a> in your builder classes. Should you omit any of those methods, though, the corresponding mapped syntax will not be available within the computation expression and the compiler will produce an error. For example, if you try to include a <code class="literal">use</code> binding within a custom computation expression but omit the <code class="literal">Using</code> method from the builder class, compilation will fail with the message:</p><a id="pro_id00614"/><pre class="programlisting">error FS0708: This control construct may only be used if the computation
expression builder defines a 'Using' method</pre><p>Likewise, it is not always necessary to implement each method from <a class="xref" href="ch12.html#methods_affecting_computation_expression" title="Table 12-2. Methods Affecting Computation Expression Evaluation">Table 12-2</a>, but failure to do so in some situations can lead to undesirable results. For instance, not implementing the <code class="literal">Delay</code> method will prevent you from composing expressions that yield multiple results. Furthermore, when your computation expression involves side effects, not implementing the <code class="literal">Delay</code> method can invoke the side effects prematurely—regardless of where they appear within the expression—because they are evaluated immediately when they’re encountered instead of wrapped up in a function for deferred execution.</p><p>Computation expressions can be difficult to understand when discussed in abstract terms focused on the builder classes and method calls. I think it’s far more helpful to walk through some simple implementations to see how the pieces work together. We’ll spend the remainder of the chapter discussing two examples. In particular, we’ll look at the builder implementations, their corresponding expression syntax, and the desugaring process.</p></div><div class="sect1" title="Example: FizzBuzz"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="example_fizzbuzz">Example: FizzBuzz</h2></div></div></div><p><a id="iddle1432" class="indexterm"/><a id="iddle2132" class="indexterm"/>In <a class="xref" href="ch07.html" title="Chapter 7. Patterns, Patterns, Everywhere">Chapter 7</a>, we looked at a few ways to solve the FizzBuzz problem by iterating over a sequence using <code class="literal">Seq.map</code> and using pattern-matching functions with active patterns and partial active patterns to identify which value should be printed. At its core, however, the FizzBuzz problem is essentially just an exercise in sequence transformation. As such, the problem can easily be solved with a computation expression.</p><p>When implemented as a computation expression, our FizzBuzz sequence can be constructed in a manner such that it looks and behaves like a standard sequence expression. With the computation expression, though, mapping a number to the corresponding string will be completely abstracted away within the builder class.</p><p>Because FizzBuzz transforms integers to strings and carries no intrinsic state, we’ll forego creating an intermediary wrapper type and jump right into creating the builder class incrementally, beginning with the <code class="literal">Yield</code> method.</p><a id="pro_id00615"/><pre class="programlisting">type FizzBuzzSequenceBuilder() =
  member x.Yield(v) =
    match (v % 3, v % 5) with
    | 0, 0 -&gt; "FizzBuzz"
    | 0, _ -&gt; "Fizz"
    | _, 0 -&gt; "Buzz"
    | _ -&gt; v.ToString()</pre><p>Now that we have a rudimentary builder class, we can create the instance that we’ll use for every FizzBuzz computation expression, like this:</p><a id="pro_id00616"/><pre class="programlisting">let fizzbuzz = FizzBuzzSequenceBuilder()</pre><p>That’s it! There’s nothing fancy here; we just create an instance of the class via its primary constructor. To use the instance as a computation expression, we can write something such as the following:</p><a id="pro_id00617"/><pre class="programlisting">&gt; <span class="strong"><strong>fizzbuzz { yield 1 };;</strong></span>
val it : string = "1"</pre><p>As you can see, evaluating the preceding expression doesn’t give us quite the result we’re looking for. Instead of returning a sequence of strings, it gives us only a single string, because so far the builder class doesn’t know how to create a sequence; it simply yields a string based on an integer value. You can see this a bit more clearly in the desugared form, which resembles this:</p><a id="pro_id00618"/><pre class="programlisting">fizzbuzz.Yield 1</pre><p>To get a sequence of strings, we could make <code class="literal">Yield</code> return a singleton sequence (a sequence containing only a single item), but doing so would complicate implementing other methods, such as <code class="literal">For</code> and <code class="literal">While</code>. Instead, <a id="iddle1242" class="indexterm"/><a id="iddle1307" class="indexterm"/>we’ll extend the builder class to include the <code class="literal">Delay</code> method as follows (be sure to re-create the builder instance after updating the builder class to ensure that the <code class="literal">fizzbuzz</code> expressions are evaluated using the latest definitions):</p><a id="pro_id00619"/><pre class="programlisting">type FizzBuzzSequenceBuilder() =
-- <span class="emphasis"><em>snip</em></span> --
member x.Delay(f) = f() |&gt; Seq.singleton</pre><p>Evaluating the previous <code class="literal">fizzbuzz</code> expression with the <code class="literal">Delay</code> method in place gives us a slightly more desirable result:</p><a id="pro_id00620"/><pre class="programlisting">&gt; <span class="strong"><strong>fizzbuzz { yield 1 };;</strong></span>
val it : seq&lt;string&gt; = seq ["1"]</pre><p>Again, the desugared expression can help clarify what’s happening. With the inclusion of the <code class="literal">Delay</code> method, the desugared form now looks like this:</p><a id="pro_id00621"/><pre class="programlisting">fizzbuzz.Delay(fun () -&gt; fizzbuzz.Yield 1)</pre><p>As it stands now, though, all we’ll ever get from a <code class="literal">fizzbuzz</code> expression is a singleton sequence because we can’t yield multiple values. In fact, trying to do so as follows will result in a compiler error indicating that the builder class must define a <code class="literal">Combine</code> method:</p><a id="pro_id00622"/><pre class="programlisting">fizzbuzz {
  yield 1
  yield 2
  yield 3 }</pre><p>To make the preceding snippet work, we’ll provide two overloaded implementations of the <code class="literal">Combine</code> method. The reason for overloading the methods is that, depending on their position within the expression, we’ll either be combining individual strings into a sequence or appending a new string to an existing sequence. We want to be careful that we don’t create a sequence containing a sequence, so we’ll also need to overload the existing <code class="literal">Delay</code> method to simply return a supplied sequence. We can implement each of these methods as follows:</p><a id="pro_id00623"/><pre class="programlisting">type FizzBuzzSequenceBuilder() =
  -- <span class="emphasis"><em>snip</em></span> --
  member x.Delay(f : unit -&gt; string seq) = f()
  member x.Combine(l, r) =
    Seq.append (Seq.singleton l) (Seq.singleton r)
  member x.Combine(l, r) =
    Seq.append (Seq.singleton l) r</pre><p><a id="iddle1243" class="indexterm"/><a id="iddle1308" class="indexterm"/><a id="iddle1445" class="indexterm"/><a id="iddle2133" class="indexterm"/>Now evaluating the preceding <code class="literal">fizzbuzz</code> expression will result in a sequence containing three strings:</p><a id="pro_id00624"/><pre class="programlisting">&gt; <span class="strong"><strong>fizzbuzz {</strong></span>
  <span class="strong"><strong>yield 1</strong></span>
  <span class="strong"><strong>yield 2</strong></span>
  <span class="strong"><strong>yield 3 };;</strong></span>
val it : seq&lt;string&gt; = seq ["1"; "2"; "Fizz"]</pre><p>When yielding multiple results like this, the desugaring process produces a much more complicated chain of method calls. For instance, desugaring the preceding expression that yields three items results in code that resembles this:</p><a id="pro_id00625"/><pre class="programlisting">fizzbuzz.Delay (fun () -&gt;
  fizzbuzz.Combine (
    fizzbuzz.Yield 1,
    fizzbuzz.Delay (fun () -&gt;
      fizzbuzz.Combine(
        fizzbuzz.Yield 2,
        fizzbuzz.Delay (fun () -&gt; fizzbuzz.Yield 3)))))</pre><p>Yielding instances one at a time as we’ve been doing isn’t a very effective way to build a sequence of any length. It would be much nicer if we could compose a <code class="literal">fizzbuzz</code> expression using a <code class="literal">for</code> loop. For this we need to implement the <code class="literal">For</code> method. The approach we’ll take is to simply wrap a call to <code class="literal">Seq.map</code>, as shown here:</p><a id="pro_id00626"/><pre class="programlisting">type FizzBuzzSequenceBuilder() =
  -- <span class="emphasis"><em>snip</em></span> --
  member x.For(g, f) = Seq.map f g</pre><p>Now it’s trivial to generate FizzBuzz sequences because instead of using multiple <code class="literal">yield</code> expressions, we can nest a single <code class="literal">yield</code> expression within a <code class="literal">for</code> loop, like this:</p><a id="pro_id00627"/><pre class="programlisting">fizzbuzz { for x = 1 to 99 do yield x }</pre><p>Part of the beauty of implementing the <code class="literal">Yield</code>, <code class="literal">Delay</code>, <code class="literal">Combine</code>, and <code class="literal">For</code> methods in the builder class is that we can combine the styles for more flexible expressions. For instance, we can yield values directly before yielding them from a loop:</p><a id="pro_id00628"/><pre class="programlisting">fizzbuzz { yield 1
           yield 2
           for x = 3 to 50 do yield x }</pre><p>As it’s currently written, the builder class doesn’t support every way you could combine the various expressions, but you shouldn’t have trouble adding the appropriate overloads to support many more scenarios.</p><p><a id="iddle1221" class="indexterm"/>For your convenience, here’s the builder class in its entirety:</p><a id="pro_id00629"/><pre class="programlisting">type FizzBuzzSequenceBuilder() =
  member x.Yield(v) =
    match (v % 3, v % 5) with
    | 0, 0 -&gt; "FizzBuzz"
    | 0, _ -&gt; "Fizz"
    | _, 0 -&gt; "Buzz"
    | _ -&gt; v.ToString()
  member x.Delay(f) = f() |&gt; Seq.singleton
  member x.Delay(f : unit -&gt; string seq) = f()
  member x.Combine(l, r) =
    Seq.append (Seq.singleton l) (Seq.singleton r)
  member x.Combine(l, r) =
    Seq.append (Seq.singleton l) r
  member x.For(g, f) = Seq.map f g</pre></div><div class="sect1" title="Example: Building Strings"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="example_building_strings">Example: Building Strings</h2></div></div></div><p>FizzBuzz does a nice job showing how you can use computation expressions to create your own sequence-like constructs with the <code class="literal">For</code> and <code class="literal">Yield</code> methods, but it’s not particularly practical for everyday computing. For a more useful example, we turn to a common programming task: combining strings.</p><p>It has long been established that constructing strings using a <code class="literal">StringBuilder</code> is usually more efficient than concatenation. <code class="literal">StringBuilder</code>’s fluent interface keeps the code fairly clean, as shown in the following snippet:</p><a id="pro_id00630"/><pre class="programlisting">open System.Text

StringBuilder("The quick ")
  .Append("brown fox ")
  .Append("jumps over ")
  .Append("the lazy dog")
  .ToString()</pre><p>Creating a <code class="literal">StringBuider</code> instance and chaining calls to the various <code class="literal">Append</code> methods doesn’t really fit into the functional-first paradigm, however. The <code class="literal">Printf</code> module tries to address this disconnect through the <code class="literal">bprintf</code> function, which formats a string and appends it to a <code class="literal">StringBuilder</code> instance as shown here:</p><a id="pro_id00631"/><pre class="programlisting">let sb = System.Text.StringBuilder()
Printf.bprintf sb "The quick "
Printf.bprintf sb "brown fox "
Printf.bprintf sb "jumps over "
Printf.bprintf sb "the lazy dog"
sb.ToString() |&gt; printfn "%s"</pre><p>All <code class="literal">bprintf</code> really accomplishes, though, is replacing an instance method call with a call to a function that accepts a <code class="literal">StringBuilder</code> as an argument. What’s more, you still have to manage the <code class="literal">StringBuilder</code> instance and pass it to each <code class="literal">bprintf</code> call. With a computation expression, not only can you make string construction look like a natural part of the F# language, you can also abstract away the <code class="literal">StringBuilder</code>! The computation expression we’ll define shortly will allow us to compose strings using the following syntax:</p><a id="pro_id00632"/><pre class="programlisting">buildstring {
  yield "The quick "
  yield "brown fox "
  yield "jumps over "
  yield "the lazy dog" }</pre><p>Here, we chain together a number of strings by yielding them within a <code class="literal">buildstring</code> expression. To make this magic happen, we first need to define the underlying type for the expression. For convenience we’ll use a discriminated union called <code class="literal">StringFragment</code> to track all of the strings as we yield them. The <code class="literal">StringFragment</code> type is defined as follows:</p><a id="pro_id00633"/><pre class="programlisting">open System.Text

type StringFragment =
| ① Empty
| ② Fragment of string
| ③ Concat of StringFragment * StringFragment
  override x.ToString() =
    let rec flatten frag (sb : StringBuilder) =
      match frag with
      | Empty -&gt; sb
      | Fragment(s) -&gt; sb.Append(s)
      | Concat(s1, s2) -&gt; sb |&gt; flatten s1 |&gt; flatten s2
    (StringBuilder() |&gt; flatten x).ToString()</pre><p>The <code class="literal">StringFragment</code> union has three cases, <code class="literal">Empty</code>①, <code class="literal">Fragment</code> ②, and <code class="literal">Concat</code> ③. The <code class="literal">Empty</code> case represents empty strings, while the <code class="literal">String</code> case contains a single string. The final case, <code class="literal">Concat</code>, forms a hierarchy of <code class="literal">StringFragment</code> instances that will eventually be joined together through the <code class="literal">ToString</code> method. The beauty of this type is that once the builder is in place, you never have to manually manage these instances or the <code class="literal">StringBuilder</code>.</p><p>The builder class, which we’ll call <code class="literal">StringFragmentBuilder</code>, is similar to the</p><p><code class="literal">FizzBuzzBuilder</code>, but instead of creating sequences it creates <code class="literal">StringFragment</code>s. We already know based on the earlier syntax that we’ll be using the <code class="literal">yield</code> keyword, so we’ll need to provide a <code class="literal">Yield</code> method. To yield multiple items, we’ll need to implement the <code class="literal">Combine</code> and <code class="literal">Delay</code> methods as well. It would be <a id="iddle1244" class="indexterm"/><a id="iddle2126" class="indexterm"/><a id="iddle2128" class="indexterm"/><a id="iddle2134" class="indexterm"/><a id="iddle2136" class="indexterm"/>nice to allow nested expressions, too, so we’ll implement a <code class="literal">YieldFrom</code> method. Here is the <code class="literal">StringFragmentBuilder</code> class in its entirety along with the instance used with <code class="literal">buildString</code> expressions:</p><a id="pro_id00634"/><pre class="programlisting">type StringFragmentBuilder() =
  member x.Zero() = Empty
  member x.Yield(v) = Fragment(v)
  member x.YieldFrom(v) = v
  member x.Combine(l, r) = Concat(l, r)
  member x.Delay(f) = f()
  member x.For(s, f) =
    Seq.map f s
    |&gt; Seq.reduce (fun l r -&gt; x.Combine(l, r))

let buildstring = StringFragmentBuilder()</pre><p>The <code class="literal">StringFragmentBuilder</code> class is considerably simpler than <code class="literal">FizzBuzzSequenceBuilder</code> because it’s concerned only with mapping strings to <code class="literal">StringFragments</code> and controlling execution. Let’s look at each method individually to understand how it’s used within the context of the computation expression.</p><p>The first method, <code class="literal">Zero</code>, returns a default value for the expression. In this case, we return <code class="literal">Empty</code> to indicate an empty string. During the desugaring process, a call to <code class="literal">Zero</code> will be inserted automatically in scenarios such as the expression returning <code class="literal">unit</code>, or a nested <code class="literal">if</code> expression not including an <code class="literal">else</code> branch.</p><p>The <code class="literal">Yield</code> method enables the <code class="literal">yield</code> keyword within the <code class="literal">buildstring</code> expression. In this implementation, <code class="literal">Yield</code> accepts a string, which it wraps in a new <code class="literal">Fragment</code> instance.</p><p>The <code class="literal">YieldFrom</code> method allows you to evaluate a nested <code class="literal">buildstring</code> expression through the <code class="literal">yield!</code> keyword. This method is similar to <code class="literal">Yield</code>, but instead of returning a new <code class="literal">StringFragment</code>, it returns the one created by the nested expression.</p><p>Each <code class="literal">yield</code> or <code class="literal">yield!</code> in the computation expression represents the end of a portion of the expression, so we need a way to merge them all together. For that we turn to the <code class="literal">Combine</code> method, which essentially treats the remainder of the expression as a continuation. <code class="literal">Combine</code> takes two <code class="literal">StringFragments</code> and wraps them each within a <code class="literal">Concat</code> instance.</p><div class="sidebar"><a id="combinecomma_exposed"/><div class="sidebar-title">Combine, Exposed</div><p>I think it’s easier to understand the <code class="literal">Combine</code> method’s role by looking at the desugared form. Say you’re writing a <code class="literal">buildstring</code> expression that combines <code class="literal">"A"</code> and <code class="literal">"B"</code> into a single string like this:</p><a id="pro_id00635"/><pre class="programlisting">buildstring {
  yield "A"
  yield "B" }</pre><p><a id="iddle1309" class="indexterm"/>The corresponding desugared form of this expression would look very much like this:</p><a id="pro_id00636"/><pre class="programlisting">buildstring.Combine(
  buildstring.Yield("A"),
  buildstring.Yield("B"))</pre><p>For clarity, I simplified the desugared form to just the parts essential for understanding the process. Here, the first call to <code class="literal">Yield</code> returns <code class="literal">Fragment("A")</code> and the second returns <code class="literal">Fragment("B")</code>. The <code class="literal">Combine</code> method takes both of these and produces the following:</p><a id="pro_id00637"/><pre class="programlisting">Concat (Fragment "A", Fragment "B")</pre><p><code class="literal">Combine</code> is called for every yield after the first. If our hypothetical example were extended to also yield <code class="literal">"C"</code>, then the desugared form would then resemble this simplified code:</p><a id="pro_id00638"/><pre class="programlisting">buildstring.Combine(
  buildstring.Yield("A"),
  buildstring.Combine(
    buildstring.Yield("B"),
    buildstring.Yield("C")))</pre><p>The resulting <code class="literal">StringFragment</code> should then be:</p><a id="pro_id00639"/><pre class="programlisting">Concat (Fragment "A", Concat (Fragment "B", Fragment "C"))</pre></div><p>The next method in the <code class="literal">StringFragmentBuilder</code> class, <code class="literal">Delay</code>, controls when the computation expression is evaluated. When a computation expression has multiple parts, the compiler requires you to define <code class="literal">Delay</code> to avoid prematurely evaluating expressions that contain side effects and control execution as expressions are combined. Many of the method calls are wrapped in a function that’s passed to <code class="literal">Delay</code>, so that those portions of the expression won’t be evaluated until <code class="literal">Delay</code> is invoked. More specifically, the entire expression is wrapped in one <code class="literal">Delay</code> call, as are the calls that compute the second argument to each <code class="literal">Combine</code> call. The desugared form looks a bit like this (simplified for clarity):</p><a id="pro_id00640"/><pre class="programlisting">buildstring.Delay(
  fun () -&gt;
    buildstring.Combine(
      buildstring.Yield("A"),
      buildstring.Delay(
        fun () -&gt;
          buildstring.Combine(
           buildstring.Yield("B"),
             buildstring.Delay(
               fun () -&gt;
                 buildstring.Yield("C"))))))</pre><p>Finally, the <code class="literal">For</code> method allows us to use <code class="literal">for</code> loops within a <code class="literal">buildstring</code> expression. Unlike the FizzBuzz implementation, however, this version employs the Map/Reduce pattern to map the supplied sequence values to individual <code class="literal">StringFragment</code> instances and then reduce them into a single <code class="literal">StringFragment</code> instance through the <code class="literal">Combine</code> method. This flattened instance can then be used in conjunction with other instances.</p><p>Now that you’ve seen the builder class and understand how the methods work together through the desugaring process, let’s look at an example that exercises the entire chain. For this, we can use <code class="literal">buildstring</code> expressions to build the lyrics to a popular children’s song about a farmer and his dog, Bingo. The song’s simple lyrics and its repetitive nature make it easy to represent programmatically, like this:</p><a id="pro_id00641"/><pre class="programlisting">let bingo() =
  let buildNamePhrase fullName =
    buildstring {
      yield "And "
      yield fullName
      yield " was his name-o\n"
   }
  let buildClapAndSpellPhrases maxChars chars =
    let clapCount = maxChars - (List.length chars)
    let spellPart =
      List.init clapCount (fun _ -&gt; "*clap*") @ chars
      |&gt; Seq.ofList
      |&gt; String.concat "-"
    buildstring {
      for i in 1..3 do yield spellPart
                       yield "\n" }
  let rec buildVerse fullName (chars : string list) =
    buildstring {
      yield "There was a farmer who had a dog,\n"
      yield! buildNamePhrase fullName
      yield! buildClapAndSpellPhrases fullName.Length chars
      yield! buildNamePhrase fullName
      match chars with
      | [] -&gt; ()
      | _::nextChars -&gt; yield "\n"
                        yield! buildVerse fullName nextChars
    }
  let name = "Bingo"
  let letters = [ for c in name.ToUpper() -&gt; c.ToString() ]
  buildVerse name letters</pre><p>Nested within the <code class="literal">bingo</code> function are three functions: <code class="literal">buildNamePhrase</code>,<code class="literal">buildClapAndSpellPhrases</code>, and <code class="literal">buildVerse</code>. Each of these functions constructs a <code class="literal">StringFragment</code> through a <code class="literal">buildstring</code> expression. At the end of each verse, <a id="iddle1383" class="indexterm"/><a id="iddle1387" class="indexterm"/>the <code class="literal">buildstring</code> expression includes a match expression to determine whether it should end with the <code class="literal">Zero</code> value (implied by returning <code class="literal">unit</code>) or recursively include another fully constructed verse via the <code class="literal">yield!</code> keyword.</p><p>Evaluating the preceding snippet should print the following string (remember, the <code class="literal">%O</code> token formats the corresponding argument by calling its <code class="literal">ToString</code> method):</p><a id="pro_id00642"/><pre class="programlisting">&gt; <span class="strong"><strong>bingo() |&gt; printfn "%O";;</strong></span>
There was a farmer who had a dog,
And Bingo was his name-o!
B-I-N-G-O
B-I-N-G-O
B-I-N-G-O
And Bingo was his name-o!

There was a farmer who had a dog,
And Bingo was his name-o!
*clap*-I-N-G-O
*clap*-I-N-G-O
*clap*-I-N-G-O
And Bingo was his name-o!

There was a farmer who had a dog,
And Bingo was his name-o!
*clap*-*clap*-N-G-O
*clap*-*clap*-N-G-O
*clap*-*clap*-N-G-O
And Bingo was his name-o!
-- <span class="emphasis"><em>snip</em></span> --</pre></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id00019">Summary</h2></div></div></div><p>Computation expressions play an important role within F#. Out of the box, they make creating sequences, querying data from disparate data sources, and managing asynchronous operations appear to be a native part of the language by reusing familiar language elements. They’re also fully extensible, so you can define your own computation expressions by creating a builder class that constructs an instance of an underlying type. Creating custom computation expressions can be a tricky endeavor, but once you understand the purpose of each builder class method and the desugaring process, the result can be cleaner, more descriptive code.</p><p>It can be difficult to find good information about computation expressions, but there are a few resources you can use for further study. First, the computation expressions series at <span class="emphasis"><em>F# for Fun and Profit</em></span> (<span class="emphasis"><em><a class="ulink" href="http://fsharpforfunandprofit.com/series/computation-expressions.htm" target="_top">http://fsharpforfunandprofit.com/series/computation-expressions.htm</a></em></span>) has plenty of examples covering the range of builder methods. For some more real-world examples, check out the ExtCore project on GitHub (<span class="emphasis"><em><a class="ulink" href="https://github.com/jack-pappas/ExtCore/" target="_top">https://github.com/jack-pappas/ExtCore/</a></em></span>), which contains several practical applications for computation expressions, such as a lazy list implementation.</p></div></section></body></html>