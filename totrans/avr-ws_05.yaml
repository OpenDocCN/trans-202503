- en: '[5](nsp-boxall502581-0008.xhtml#rch05)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[5](nsp-boxall502581-0008.xhtml#rch05)'
- en: Taking Control with Hardware Interrupts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用硬件中断进行控制
- en: '![](images/nsp-boxall502581-ct.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-boxall502581-ct.jpg)'
- en: So far, the code for your projects in this book has been sequential. Any deviations
    from a linear pattern, such as detecting button presses, required you to monitor
    digital inputs. However, preplanning button presses in your code isn’t always
    efficient or realistic. *Hardware interrupts* allow your programs to respond to
    events more efficiently and dynamically.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中你的项目代码都是顺序执行的。任何偏离线性模式的行为，例如检测按钮按下，都需要你监控数字输入。然而，在代码中预先规划按钮按下并不总是高效或现实的。*硬件中断*使你的程序能够更高效、动态地响应事件。
- en: 'Hardware interrupts enable the AVR microcontroller to react to a change of
    state at a digital input pin at any time. In a way, they allow your AVR to multitask:
    when a button is pressed or when a signal is received at a digital input, the
    AVR will stop what it is doing and run some other code, called an *interrupt service
    routine (ISR)* . After the ISR code runs, the AVR picks up execution where it
    left off before the interrupt.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件中断使 AVR 微控制器能够随时响应数字输入引脚状态的变化。某种程度上，它们让你的 AVR 可以进行多任务处理：当按下按钮或在数字输入引脚接收到信号时，AVR
    会暂停当前的任务并执行其他代码，这部分代码被称为*中断服务程序 (ISR)*。在 ISR 代码执行完毕后，AVR 会从中断前暂停的位置继续执行。
- en: Interrupts allow you to write more logical code and make your AVR-based projects
    operate more intuitively. This chapter covers two kinds of hardware interrupts,
    external interrupts and pin-change interrupts, using the ATmega328P-PU microcontroller.
    Both interrupts are triggered by state changes in pins (for instance, a change
    from high to low voltage). Pin-change interrupts can occur on all the pins, while
    external interrupts can only happen on two pins. Once you’ve got the basics down,
    you’ll use interrupts to create a counting device with a USART-based display.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 中断让你可以编写更有逻辑的代码，使基于 AVR 的项目更直观地运行。本章介绍了两种硬件中断：外部中断和引脚变化中断，使用的微控制器为 ATmega328P-PU。两种中断都由引脚上的状态变化触发（例如，从高电压到低电压的变化）。引脚变化中断可以发生在所有引脚上，而外部中断只能发生在两个引脚上。掌握基本知识后，你将使用中断创建一个基于
    USART 显示的计数设备。
- en: '[External Interrupts](nsp-boxall502581-0008.xhtml#rah0701)'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[外部中断](nsp-boxall502581-0008.xhtml#rah0701)'
- en: 'This section walks you through the basics of initializing external interrupts,
    which you’ll put to use in [Project 22](nsp-boxall502581-0015.xhtml#pro22) . The
    ATmega328P-PU uses pins 4 and 5, referenced as INT0 and INT1, for external interrupts.
    These two pins can detect and report changes in the electrical signal connected
    to them. The interrupts can be set to react to one of the following four possible
    changes in state at the pin:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将带你了解初始化外部中断的基础知识，你将在[项目 22](nsp-boxall502581-0015.xhtml#pro22)中使用这些知识。ATmega328P-PU
    使用引脚 4 和 5，分别称为 INT0 和 INT1，用于外部中断。这两个引脚可以检测并报告它们连接的电信号的变化。中断可以设置为响应引脚上以下四种可能的状态变化：
- en: Low level The voltage at the pin changes to a low state (equivalent to GND).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 低电平 引脚上的电压变化为低电平状态（等同于 GND）。
- en: Any logic change The voltage at the pin changes in any way, either from high
    to low or from low to high.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 任何逻辑变化 引脚上的电压以任何方式变化，无论是从高到低还是从低到高。
- en: Falling edge The voltage changes from high to low.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下降沿 电压从高变为低。
- en: Rising edge The voltage changes from low to high.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 上升沿 电压从低变为高。
- en: Consider which of these options would allow your code to respond to a button
    press. For example, if you had a button connected to GND and a microcontroller
    input with a pullup resistor, then the button press would switch the input from
    high to low. In this situation, you would typically use the falling edge interrupt
    option. Conversely, if you had a button connected between 5 V and the microcontroller
    input with a pulldown resistor, the button press would switch the input from low
    to high. In this case you could use a rising edge or any logic change interrupt.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下哪些选项可以让你的代码响应按钮按下的动作。例如，如果你将按钮连接到 GND 并且微控制器输入端有一个上拉电阻，那么按钮按下时会将输入从高电平切换到低电平。在这种情况下，你通常会使用下降沿中断选项。相反，如果按钮连接在
    5V 和微控制器输入之间，并且输入端有一个下拉电阻，那么按钮按下时会将输入从低电平切换到高电平。在这种情况下，你可以使用上升沿中断或任何逻辑变化中断。
- en: Overall, the choice of interrupt type will be determined by the external circuitry
    connected to the interrupt pin. I’ll demonstrate various types of interrupts in
    action in this chapter, so you can use these examples to help you determine what’s
    right for your own projects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，中断类型的选择将由连接到中断引脚的外部电路决定。在本章中，我将演示各种类型的中断，帮助你根据自己的项目需求选择合适的中断类型。
- en: '[Setting Up Interrupts in Code](nsp-boxall502581-0008.xhtml#rbh0701)'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[在代码中设置中断](nsp-boxall502581-0008.xhtml#rbh0701)'
- en: 'To use interrupts, first add the interrupt library as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用中断，首先按如下方式添加中断库：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, you’ll need to set up a few registers—we’ll step through them one by
    one below. The first of these is the EICRA register, which we use to determine
    which of the four state changes the pin will respond to. Here’s the template for
    setting the EICRA register in any AVR program:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要设置一些寄存器——我们将逐一介绍。第一个是EICRA寄存器，用于确定引脚响应的四种状态变化中的哪一种。以下是任何AVR程序中设置EICRA寄存器的模板：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Set interrupt INT0 (pin 4) with bits `c` and `d` and interrupt INT1 (pin 5)
    with bits `a` and `b` , using the guidelines in [Table 5-1](nsp-boxall502581-0015.xhtml#tab0501)
    .
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[表5-1](nsp-boxall502581-0015.xhtml#tab0501)中的指南，通过`c`和`d`位设置中断INT0（引脚4）并通过`a`和`b`位设置中断INT1（引脚5）。
- en: '| Table 5-1 : EICRA Register Option Bits |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 表 5-1 : EICRA寄存器选项位 |'
- en: '| --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Bit a/c | Bit b/d | Interrupt type |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 位 a/c | 位 b/d | 中断类型 |'
- en: '| --- | --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | Low level |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 低电平 |'
- en: '| 0 | 1 | Any logic change |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 任意逻辑变化 |'
- en: '| 1 | 0 | Falling edge |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 下降沿 |'
- en: '| 1 | 1 | Rising edge |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 上升沿 |'
- en: 'For example, you could set up INT0 for a rising edge interrupt as follows,
    using the `c` and `d` bits:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用`c`和`d`位，按如下方式设置INT0为上升沿中断：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, set up the EIMSK register, which is used to turn on the interrupt function,
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置EIMSK寄存器，该寄存器用于启用中断功能，方法如下：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, bit `a` is INT1 and bit `b` is INT0\. Set each bit to 1 for on or 0 for
    off. For example, to turn the interrupt function on for INT0, use:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，位`a`是INT1，位`b`是INT0。将每个位设置为1表示开启，设置为0表示关闭。例如，要启用INT0的中断功能，使用：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since only the last bit is set to 1, only INT0 will be turned on.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有最后一位被设置为1，因此只有INT0会被启用。
- en: 'After setting the EICRA and EIMSK registers, enable interrupts in your code
    using this function call:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 设置EICRA和EIMSK寄存器后，在代码中使用此函数调用启用中断：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Don’t forget this step—if you skip it, even if you’ve set your registers properly,
    the interrupt won’t be triggered.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了这一步——如果跳过了，即使你已正确设置寄存器，中断也不会被触发。
- en: 'Here’s a recap of the code required for interrupts so far:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是迄今为止中断所需代码的总结：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once you’ve prepared your AVR to respond to interrupts, you must define your
    ISR—the code that runs when the interrupt is triggered. The ISR is a custom function
    with the following structure:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备好让你的AVR响应中断，你必须定义ISR——当中断被触发时执行的代码。ISR是一个自定义函数，具有以下结构：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The parameter `INT` `x` `_vect` specifies the pin that the ISR responds to.
    When you pass a value to the function, replace the `x` in `INT` `x` `_vect` with
    `0` for INT0 or `1` for INT1\. The body of the function is the code that executes
    when the interrupt is triggered. We always end this ISR code section with this
    command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`INT` `x` `_vect`指定ISR响应的引脚。当你传递一个值给函数时，将`INT` `x` `_vect`中的`x`替换为`0`表示INT0，`1`表示INT1。函数体是当中断被触发时执行的代码。我们总是以此命令结束ISR代码段：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This sets the external interrupt flag registers back to zero, telling the microcontroller
    that the interrupt code for this particular ISR is complete and the AVR can return
    to normal operation. If you are using only one interrupt, you can use the following
    values for `y` : `0b00000001` for INT0 and `0b00000010` for INT1\. However, if
    your project is using both interrupts, if you set the EIFR register with an entire
    8-bit value, you will alter both interrupts. Instead, you can use the following,
    which will just turn off one interrupt:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将外部中断标志寄存器重置为零，告诉微控制器该ISR的中断代码已完成，AVR可以返回到正常操作。如果只使用一个中断，可以使用以下`y`值：`0b00000001`表示INT0，`0b00000010`表示INT1。若项目中使用了两个中断，如果你用整个8位值设置EIFR寄存器，将会更改两个中断。相反，你可以使用以下方法，只关闭一个中断：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This way of addressing register bits individually will be explained in detail
    in the [next chapter](nsp-boxall502581-0016.xhtml#ch06) . In the meanwhile, let’s
    put pin-change interrupts to the test in the [following project](nsp-boxall502581-0015.xhtml#pro22)
    .
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种逐个处理寄存器位的方式将在[下一章](nsp-boxall502581-0016.xhtml#ch06)中详细解释。同时，让我们在[下一个项目](nsp-boxall502581-0015.xhtml#pro22)中测试引脚变化中断。
- en: '[Project 22: Experimenting with Rising Edge Interrupts](nsp-boxall502581-0008.xhtml#rpro22)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[第22项目：实验上升沿中断](nsp-boxall502581-0008.xhtml#rpro22)'
- en: In this project, you’ll first program your microcontroller to rapidly blink
    an LED, then add logic so that pressing a button interrupts the blinking LED and
    runs some other code, keeping the LED on for two seconds before it returns to
    its blinking pattern. You’ll accomplish this using a rising edge interrupt.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将首先编程让微控制器快速闪烁LED，然后添加逻辑，使得按下按钮时中断LED的闪烁并运行其他代码，让LED保持亮灯两秒钟，之后恢复闪烁模式。你将使用上升沿中断来实现这一功能。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0702)'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件](nsp-boxall502581-0008.xhtml#rbh0702)'
- en: 'For this project, you’ll need the following hardware:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将需要以下硬件：
- en: • USBasp programmer
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp编程器
- en: • Solderless breadboard
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊接面包板
- en: • ATmega328P-PU microcontroller
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATmega328P-PU微控制器
- en: • Jumper wires
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线
- en: • One LED
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一颗LED
- en: • One 560 Ω resistor
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一颗560 Ω电阻
- en: • One pushbutton
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一颗按钮
- en: • One 10 kΩ resistor
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一颗10 kΩ电阻
- en: First, assemble the circuit shown in [Figure 5-1](nsp-boxall502581-0015.xhtml#f05001)
    .
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，组装[图5-1](nsp-boxall502581-0015.xhtml#f05001)所示的电路。
- en: '![Schematic diagram for Project 22](images/nsp-boxall502581-f05001.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![第22项目的电路图](images/nsp-boxall502581-f05001.jpg)'
- en: 'Figure 5-1: The main circuit for [Project 22](nsp-boxall502581-0015.xhtml#pro22)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-1：[第22项目](nsp-boxall502581-0015.xhtml#pro22)的主要电路
- en: The resistor and button are in the pulldown configuration that I introduced
    in [Chapter 3](nsp-boxall502581-0013.xhtml#ch03) . When you press the button the
    current will flow to pin 4, changing its state from low to high. This rising edge
    state change will trigger the interrupt.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻器和按钮采用的是我在[第3章](nsp-boxall502581-0013.xhtml#ch03)中介绍的下拉配置。当你按下按钮时，电流将流向引脚4，将其状态从低电平变为高电平。这个上升沿的状态变化将触发中断。
- en: With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard, as you did in previous projects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 组装好电路后，像之前的项目一样，通过无焊接面包板将USBasp连接到微控制器。
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0703)'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码](nsp-boxall502581-0008.xhtml#rbh0703)'
- en: Open a terminal window and navigate to the *Project 22* subfolder of this book’s
    *Chapter 5* folder, then enter the command `make flash` . The toolchain should
    compile the program file and upload the data to the microcontroller, at which
    point the LED should begin to blink rapidly, turning on and off every 50 milliseconds.
    Press the button quickly (don’t leave your finger on it for long, since this will
    trigger switch bouncing), and the LED should stay on for two seconds, then resume
    blinking.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口，导航到本书*第5章*文件夹中的*第22项目*子文件夹，然后输入命令`make flash`。工具链应编译程序文件并将数据上传到微控制器，此时LED应开始快速闪烁，每50毫秒开关一次。快速按下按钮（不要长时间按住它，因为这会触发开关抖动），LED应保持亮灯两秒钟，然后恢复闪烁。
- en: 'Open the *main.c* file for [Project 22](nsp-boxall502581-0015.xhtml#pro22)
    to see how this code works:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*main.c*文件，查看[第22项目](nsp-boxall502581-0015.xhtml#pro22)中的代码是如何工作的：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code defines a `startInt0()` function to initialize the interrupts. Within
    this function, we first set the EICRA register so that INT0 reacts to a rising
    edge interrupt ❸, then set the EIMSK register to turn INT0 on ❹, and finally call
    `sei()` to enable interrupts. In the main section of the code, we set up PORTB
    pins as outputs to control the LED ❺ and set PORTD pins as inputs ❻. PORTD includes
    digital pin 4, which will act as input for the interrupt INT0.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个`startInt0()`函数来初始化中断。在这个函数中，我们首先设置EICRA寄存器，使得INT0响应上升沿中断❸，然后设置EIMSK寄存器开启INT0❹，最后调用`sei()`来启用中断。在代码的主部分，我们将PORTB引脚设置为输出，用来控制LED❺，并将PORTD引脚设置为输入❻。PORTD包含数字引脚4，它将作为INT0中断的输入。
- en: Once everything is initialized, the for loop ❼ makes the LED blink on and off.
    Because there’s an interrupt, when you press the button, the resulting rising
    edge triggers the hardware interrupt INT0\. This tells the AVR to stop blinking
    the LED and run the code in the ISR ❶. When the ISR code has finished, the EIFR
    register is set to 0 ❷ and the LED returns to rapidly blinking as normal.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一切初始化完成，for 循环 ❼ 会让 LED 闪烁。由于存在中断，当你按下按钮时，产生的上沿触发硬件中断 INT0。这告诉 AVR 停止闪烁 LED，并运行
    ISR ❶ 中的代码。当 ISR 代码执行完毕，EIFR 寄存器被设置为 0 ❷，LED 会恢复正常的快速闪烁。
- en: Congratulations! You’ve just seen the most common kind of interrupt in action.
    Less often, you’ll need to detect when current stops flowing to the microcontroller,
    which you can do using a falling edge interrupt. You’ll try this out in the [next
    project](nsp-boxall502581-0015.xhtml#pro23) .
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚看到了一种最常见的中断形式的实现。较少见的情况是需要检测到电流停止流向微控制器，这可以通过下沿中断来实现。你将在 [下一个项目](nsp-boxall502581-0015.xhtml#pro23)
    中尝试这个。
- en: '[Project 23: Experimenting with Falling Edge Interrupts](nsp-boxall502581-0008.xhtml#rpro23)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 23：实验下沿中断](nsp-boxall502581-0008.xhtml#rpro23)'
- en: This project has the same result as [Project 22](nsp-boxall502581-0015.xhtml#pro22)
    , but this time the circuit uses the pullup configuration introduced in [Chapter
    3](nsp-boxall502581-0013.xhtml#ch03) . By default, there will be current at digital
    pin 4\. When you press the button, current should stop flowing to pin 4, changing
    its state from high to low to trigger the falling edge interrupt.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的结果与 [项目 22](nsp-boxall502581-0015.xhtml#pro22) 相同，但这次电路使用了在 [第 3 章](nsp-boxall502581-0013.xhtml#ch03)
    中介绍的上拉配置。默认情况下，数字引脚 4 上会有电流。当你按下按钮时，电流应该停止流向引脚 4，导致其状态从高变低，从而触发下沿中断。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0704)'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件部分](nsp-boxall502581-0008.xhtml#rbh0704)'
- en: 'You’ll need the following hardware:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下硬件：
- en: • USBasp programmer
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp 编程器
- en: • Solderless breadboard
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊面包板
- en: • ATmega328P-PU microcontroller
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATmega328P-PU 微控制器
- en: • Jumper wires
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线
- en: • One LED
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 LED
- en: • One 560 Ω resistor
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 560 Ω 电阻
- en: • One pushbutton
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个按键
- en: • One 10 kΩ resistor
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 10 kΩ 电阻
- en: Start by assembling the circuit shown in [Figure 5-2](nsp-boxall502581-0015.xhtml#f05002)
    .
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先组装如 [图 5-2](nsp-boxall502581-0015.xhtml#f05002) 所示的电路。
- en: '![Schematic diagram for Project 23](images/nsp-boxall502581-f05002.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![项目 23 的原理图](images/nsp-boxall502581-f05002.jpg)'
- en: 'Figure 5-2: The main circuit for [Project 23](nsp-boxall502581-0015.xhtml#pro23)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '图 5-2: [项目 23](nsp-boxall502581-0015.xhtml#pro23) 的主电路'
- en: With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard as you did in previous projects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在组装好电路后，通过无焊面包板将 USBasp 连接到微控制器，就像在之前的项目中那样。
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0705)'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码部分](nsp-boxall502581-0008.xhtml#rbh0705)'
- en: Open a terminal window, navigate to the *Project 23* subfolder of this book’s
    *Chapter 5* folder, and enter the command `make flash` . Once the project’s code
    has been uploaded, the LED should begin to blink rapidly. Quickly press the button.
    The LED should stay on for two seconds, then resume blinking.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口，导航到本书 *第 5 章* 文件夹下的 *项目 23* 子文件夹，并输入命令 `make flash` 。项目代码上传完成后，LED 应该开始快速闪烁。快速按下按钮，LED
    应该保持亮起两秒钟，然后恢复闪烁。
- en: 'To see how this works, open the *main.c* file for [Project 23](nsp-boxall502581-0015.xhtml#pro23)
    :'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看其工作原理，打开 [项目 23](nsp-boxall502581-0015.xhtml#pro23) 的 *main.c* 文件：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code for this project is identical to that of [Project 22](nsp-boxall502581-0015.xhtml#pro22)
    , except for one change: we set the EICRA register to `0b00000010` instead of
    `0b00000011` ❶. Per [Table 5-1](nsp-boxall502581-0015.xhtml#tab0501) , the last
    two bits ( `10` ) set INT0 to the falling edge type of interrupt. EIMSK stays
    the same, since we’re still using INT0 as the interrupt pin, and as usual we call
    `sei()` to enable the interrupt.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的代码与 [项目 22](nsp-boxall502581-0015.xhtml#pro22) 完全相同，唯一的变化是：我们将 EICRA 寄存器设置为
    `0b00000010`，而不是 `0b00000011` ❶。根据 [表 5-1](nsp-boxall502581-0015.xhtml#tab0501)，最后两位（`10`）将
    INT0 设置为下沿中断类型。EIMSK 保持不变，因为我们仍然使用 INT0 作为中断引脚，通常我们调用 `sei()` 来使能中断。
- en: Play with these projects to familiarize yourself with both rising and falling
    edge interrupts. Once you feel comfortable using both options for digital inputs,
    you can choose whether to trigger an interrupt with a high or low signal in your
    own projects, depending on how the circuit you’re working with is built. This
    may sound like a trivial choice now, but it’ll become important as you create
    more complicated AVR-based projects. In some situations, you can’t choose the
    hardware or the circuit, and you’ll have to work around their limitations using
    code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 玩这些项目，熟悉上升沿和下降沿中断的使用。一旦你习惯了这两种数字输入的方式，你可以根据自己使用的电路设计来选择是用高电平还是低电平触发中断。现在这看起来可能是一个微不足道的选择，但随着你创建更多复杂的基于
    AVR 的项目，它会变得非常重要。在某些情况下，你可能无法选择硬件或电路，那么你就必须通过编写代码来绕过它们的限制。
- en: Now let’s try something more interesting. As I mentioned earlier, the ATmega328P-PU
    has two interrupt pins. In the [next project](nsp-boxall502581-0015.xhtml#pro24)
    , you’ll use both to make the microcontroller respond to two different interrupts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试一些更有趣的东西。正如我之前提到的，ATmega328P-PU 有两个中断引脚。在[下一个项目](nsp-boxall502581-0015.xhtml#pro24)中，你将使用这两个引脚来让微控制器响应两个不同的中断。
- en: '[Project 24: Experimenting with Two Interrupts](nsp-boxall502581-0008.xhtml#rpro24)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 24：实验两个中断](nsp-boxall502581-0008.xhtml#rpro24)'
- en: This project uses two buttons to allow you to trigger two interrupts for different
    responses. One button triggers a rising edge interrupt and turns on the LED for
    one second, while the other triggers a falling edge interrupt that turns on the
    LED for two seconds.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目使用两个按钮，使你能够触发两个不同的中断并产生不同的响应。一个按钮触发上升沿中断，并将 LED 点亮一秒钟，另一个按钮触发下降沿中断，并将 LED
    点亮两秒钟。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0706)'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件](nsp-boxall502581-0008.xhtml#rbh0706)'
- en: 'You’ll need the following hardware:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下硬件：
- en: • USBasp programmer
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp 编程器
- en: • Solderless breadboard
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊面包板
- en: • ATmega328P-PU microcontroller
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATmega328P-PU 微控制器
- en: • Jumper wires
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线
- en: • One LED
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一只 LED
- en: • One 560 Ω resistor
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 560 Ω 电阻
- en: • Two pushbuttons
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个按键开关
- en: • Two 10 kΩ resistors
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个 10 kΩ 电阻
- en: Assemble the circuit shown in [Figure 5-3](nsp-boxall502581-0015.xhtml#f05003)
    .
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图 5-3](nsp-boxall502581-0015.xhtml#f05003)所示组装电路。
- en: '![Schematic diagram for Project 24](images/nsp-boxall502581-f05003.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![项目 24 的原理图](images/nsp-boxall502581-f05003.jpg)'
- en: 'Figure 5-3: The main circuit for [Project 24](nsp-boxall502581-0015.xhtml#pro24)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3：[项目 24](nsp-boxall502581-0015.xhtml#pro24)的主电路
- en: With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard as in the previous projects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 组装好电路后，将 USBasp 编程器通过无焊面包板连接到你的微控制器，和之前的项目一样。
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0707)'
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码](nsp-boxall502581-0008.xhtml#rbh0707)'
- en: Open a terminal window, navigate to the *Project 24* subfolder of this book’s
    *Chapter 5* folder, and enter the command `make flash` . As in the previous two
    projects, once the code has been uploaded the LED should start to blink rapidly.
    Press the button connected to INT0 (digital pin 4), and the LED should stay on
    for one second. Press the button connected to INT1 (digital pin 5), and the LED
    should stay on for two seconds.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口，导航到本书*第 5 章*文件夹下的*项目 24*子文件夹，输入命令`make flash`。和前两个项目一样，一旦代码上传完成，LED 应该开始快速闪烁。按下连接到
    INT0（数字引脚 4）的按钮，LED 应该保持亮起一秒钟。按下连接到 INT1（数字引脚 5）的按钮，LED 应该保持亮起两秒钟。
- en: 'To see how the code handles these interrupts, open the *main.c* file for [Project
    24](nsp-boxall502581-0015.xhtml#pro24) :'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看代码如何处理这些中断，打开[项目 24](nsp-boxall502581-0015.xhtml#pro24)的*main.c*文件：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code is similar to the code for [Projects 22](nsp-boxall502581-0015.xhtml#pro22)
    and [23](nsp-boxall502581-0015.xhtml#pro23) , again with a little modification.
    As usual, we start by defining a `startInts()` function to initialize the interrupts.
    Inside this function, we set the EICRA register to respond to each interrupt ❶.
    Remember that the register is set with the formula `0b0000` `abcd` , where bits
    `a` and `b` correspond to pin 5 and bits `c` and `d` correspond to pin 6\. Here,
    we’ve set EICRA so that INT0 reacts to a rising edge interrupt and INT1 reacts
    to a falling edge interrupt ( `0b00001011` ). Next, we set the EIMSK register
    to turn on both INT0 and INT1 by setting the last two bits to 1 ❷, then we call
    `sei()` to enable interrupts.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: In the main section of the code, we set up PORTB as outputs so that the code
    will control the LED ❸. We also set up PORTD as inputs to cover digital pins 4
    and 5, which will act as inputs for INT0 and INT1, respectively ❹. Once everything
    is initialized, the code in the `for` loop ❺ will cause the LED to blink on and
    off. However, when one of the buttons is pressed, the corresponding interrupt
    will trigger and the code in the interrupt’s ISR will run.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: When planning projects with multiple interrupts, remember that an interrupt
    cannot be called by another interrupt. That is, if one interrupt’s ISR code is
    running, triggering another interrupt will not affect the operation of that ISR.
    You can’t interrupt an interrupt!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: What if you need to use more than two interrupt pins, or can’t use digital pins
    4 and 5 but still need your project to respond to state change triggers? The solution
    is to use pin-change interrupts.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[Pin-Change Interrupts](nsp-boxall502581-0008.xhtml#rah0702)'
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While using the external interrupts INT0 and INT1 is simple, straightforward,
    and gives you lots of control, working with just two interrupts is a huge limitation.
    Using *pin-change interrupts* is a little trickier, but gives you as many interrupts
    as you have pins.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Pin-change interrupts can only tell you if a pin has changed state—they can’t
    provide any details about that change of state. While an external interrupt can
    detect a change from low to high or high to low, a pin-change interrupt can only
    detect that a change happened. That means any change in state will trigger the
    interrupt, and you’ll have to decide in your code if you want to respond to that
    change.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The pins used for pin-change interrupts are organized into three banks:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Bank 0 Includes PCINT0 through PCINT7.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Bank 1 Includes PCINT8 through PCINT14.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Bank 2 Includes PCINT16 through PCINT23.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: PCINT stands for *pin-change interrupt* . Each bank has its own ISR code, giving
    you three types of level changes that you can use with their respective pins.
    This gives you more flexibility, but it means you can’t assume that each ISR function
    corresponds to a single pin. Rather, each ISR function responds to any state change
    in any of the pins in its corresponding bank. Thus, your code will have to determine
    not only what the state change was but which pin it came from before it can respond
    appropriately. Note that there is no PCINT15.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: PCINT 代表 *引脚变化中断*。每个 Bank 都有自己的 ISR 代码，给你提供了三种可以与各自引脚配合使用的电平变化类型。这为你提供了更多灵活性，但也意味着你不能假设每个
    ISR 函数只对应一个引脚。实际上，每个 ISR 函数响应其对应 Bank 中任一引脚的状态变化。因此，你的代码不仅要判断状态变化是什么，还要确定它来自哪个引脚，然后才能做出相应响应。请注意，PCINT15
    是不存在的。
- en: 'Note PCINT numbers are not the same as pin numbers: for example, PCINT8 is
    pin 23, not pin 8\. Refer to the pinout diagram in [Figure 5-4](nsp-boxall502581-0015.xhtml#f05004)
    for each PCINT value’s pin number, and make sure not to confuse the two numbers
    in your code. Each bank’s byte in binary represents the order of pins in the bank,
    from highest to lowest.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，PCINT 编号与引脚编号不同：例如，PCINT8 对应引脚 23，而不是引脚 8。请参考 [图 5-4](nsp-boxall502581-0015.xhtml#f05004)
    中的引脚图来查看每个 PCINT 值对应的引脚编号，并确保在代码中不要混淆这两个编号。每个 Bank 的字节在二进制中表示了该 Bank 中引脚的顺序，从高到低排列。
- en: You can match the three PCINT *xx* banks to physical pin numbers using the ATmega328P-PU’s
    pinout diagram, shown in [Figure 5-4](nsp-boxall502581-0015.xhtml#f05004) .
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 ATmega328P-PU 的引脚图将三个 PCINT *xx* Bank 与物理引脚编号进行匹配，该引脚图如 [图 5-4](nsp-boxall502581-0015.xhtml#f05004)
    所示。
- en: '![Diagram of ATmega328P-PU microcontroller with pins and their functions](images/nsp-boxall502581-f05004.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![ATmega328P-PU 微控制器的引脚及其功能示意图](images/nsp-boxall502581-f05004.jpg)'
- en: 'Figure 5-4: ATmega328P-PU pinout diagram'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-4：ATmega328P-PU 引脚图
- en: For example, Bank 0 responds to PCINT0–PCINT7, meaning you can trigger it with
    pins 15–19 at the bottom right of [Figure 5-4](nsp-boxall502581-0015.xhtml#f05004)
    and pins 9, 10, and 14 at the bottom left.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Bank 0 响应于 PCINT0–PCINT7，这意味着你可以通过 [图 5-4](nsp-boxall502581-0015.xhtml#f05004)
    右下角的 15–19 引脚和左下角的 9、10、14 引脚来触发它。
- en: Using pin-change interrupts in your code is similar to using external interrupts.
    Once again, first include the interrupt library.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中使用引脚变化中断类似于使用外部中断。首先，仍然需要包含中断库。
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, set the PCICR register to turn on the required PCI (pin-change interrupt)
    banks, using this formula:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置 PCICR 寄存器来启用所需的 PCI（引脚变化中断）Bank，使用以下公式：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Bank 0 is set with bit `z` , bank 1 with bit `y` , and bank 2 with bit `x`
    . For example, to turn on banks 0 and 2, you would use:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Bank 0 使用位 `z` 设置，Bank 1 使用位 `y` 设置，Bank 2 使用位 `x` 设置。例如，要启用 Bank 0 和 Bank 2，你可以使用：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Remember that each bank can respond to several pins, so you’ll need to select
    which pins in each of the banks can be used for an interrupt by turning on the
    interrupt function corresponding to each pin you select. Each bank has its own
    interrupt function that you can turn on with the registers PCMSK0, PCMSK1, and
    PCMSK2\. Pins are turned on or off with a 1 or 0 in that pin’s spot. To use pin
    15 in bank 0, pin 23 in bank 1, and pin 13 in bank 2, you’d set the PCMSK *x*
    registers like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个 Bank 都可以响应多个引脚，因此你需要选择每个 Bank 中哪些引脚可以用于中断，通过启用对应于你选择的每个引脚的中断功能来实现。每个 Bank
    都有自己的中断功能，你可以通过 PCMSK0、PCMSK1 和 PCMSK2 寄存器来启用它们。引脚的开启或关闭通过该引脚对应位置上的 1 或 0 来控制。要使用
    Bank 0 的引脚 15、Bank 1 的引脚 23 和 Bank 2 的引脚 13，你需要像这样设置 PCMSK *x* 寄存器：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once you’ve selected the pins in each bank that should trigger an interrupt,
    enable the interrupts with the line:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了每个 Bank 中应触发中断的引脚，使用以下代码行来启用中断：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, define your ISR. Each PCI has its own ISR with the following structure:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义你的 ISR。每个 PCI 都有自己的 ISR，结构如下：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Replace the `x` in `PCINT` `x` `_vect` with `0` for bank 0, `1` for bank 1,
    and `2` for bank 2, and you’re ready to add your interrupt code. We always end
    this ISR code section with the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `PCINT` `x` `_vect` 中的 `x` 替换为 Bank 0 的 `0`、Bank 1 的 `1` 和 Bank 2 的 `2`，然后你就可以开始添加中断代码了。我们通常以以下命令结束这部分
    ISR 代码：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This sets the pin-change interrupt flag register back to zero, which tells
    the microcontroller that the interrupt code for that particular bank has completed
    and that it can return to running the code in the main loop as normal. You can
    use the following values for `y` in order to set the pin-change interrupt flag:
    `0b00000001` for bank 0, `0b00000010` for bank 1, and `0b00000100` for bank 2.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把引脚变更中断标志寄存器重置为零，告知微控制器该特定银行的中断代码已完成，并且可以正常返回主循环中运行的代码。你可以使用以下`y`的值来设置引脚变更中断标志：`0b00000001`表示银行0，`0b00000010`表示银行1，`0b00000100`表示银行2。
- en: You’ll put pin-change interrupts to the test in the following project.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在接下来的项目中测试引脚变更中断。
- en: '[Project 25: Experimenting with Pin-Change Interrupts](nsp-boxall502581-0008.xhtml#rpro25)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目25：实验引脚变更中断](nsp-boxall502581-0008.xhtml#rpro25)'
- en: This project expands on the previous ones, using three buttons, in conjunction
    with a pin on each of the three PCI banks, to demonstrate how to use pin-change
    interrupts. Pressing each button should trigger a different interrupt, which should
    turn the LED on for a certain period of time.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目在之前的基础上进行了扩展，使用三个按钮，并与每个PCI银行的一个引脚配合，演示如何使用引脚变更中断。按下每个按钮应触发不同的中断，使LED点亮一段时间。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0708)'
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件](nsp-boxall502581-0008.xhtml#rbh0708)'
- en: 'You’ll need the following hardware:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下硬件：
- en: • USBasp programmer
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp编程器
- en: • Solderless breadboard
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊接面包板
- en: • ATmega328P-PU microcontroller
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATmega328P-PU微控制器
- en: • Jumper wires
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线
- en: • One LED
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个LED
- en: • One 560 Ω resistor
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个560 Ω电阻
- en: • Three pushbuttons
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 三个按键
- en: • Three 10 kΩ resistors
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 三个10 kΩ电阻
- en: To begin, assemble the circuit shown in [Figure 5-5](nsp-boxall502581-0015.xhtml#f05005)
    .
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，组装[图5-5](nsp-boxall502581-0015.xhtml#f05005)中所示的电路。
- en: '![Schematic diagram for Project 25](images/nsp-boxall502581-f05005.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![项目25的原理图](images/nsp-boxall502581-f05005.jpg)'
- en: 'Figure 5-5: The main circuit for [Project 25](nsp-boxall502581-0015.xhtml#pro25)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-5： [项目25](nsp-boxall502581-0015.xhtml#pro25)的主要电路
- en: With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard as you have for the previous projects.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 组装好电路后，像之前的项目一样，将USBasp通过无焊接面包板连接到微控制器。
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0709)'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码](nsp-boxall502581-0008.xhtml#rbh0709)'
- en: Open a terminal window, navigate to the *Project 25* subfolder of this book’s
    *Chapter 5* folder, and enter the command `make flash` to upload the project’s
    code, as usual. Once the code has uploaded, the LED should start to blink rapidly.
    Pressing the different buttons should turn the LED on for one, two, or three seconds,
    as defined in the ISR for each pin-change interrupt bank.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口，导航到本书*第5章*文件夹中的*项目25*子文件夹，输入命令`make flash`上传项目的代码，如往常一样。代码上传完成后，LED应该开始快速闪烁。按下不同的按钮应该使LED亮起一秒、两秒或三秒，具体时间由每个引脚变更中断银行的ISR定义。
- en: 'To see how this works, open the *main.c* file for [Project 25](nsp-boxall502581-0015.xhtml#pro25)
    :'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这如何工作，打开[项目25](nsp-boxall502581-0015.xhtml#pro25)的*main.c*文件：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code has the same structure as the code for the external interrupt projects.
    First, we define a `startInts()` function to initialize the interrupts. Inside
    this function, we set the PCICR register to enable all three banks of PCIs ❶;
    then we set the physical pins to use as each bank’s interrupt pin using the three
    following lines and make a call to `sei()` to enable interrupts.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码的结构与外部中断项目的代码相同。首先，我们定义一个`startInts()`函数来初始化中断。在此函数内，我们设置PCICR寄存器以启用所有三个PCI银行
    ❶；然后，我们设置物理引脚，作为每个银行的中断引脚，使用以下三行代码，并调用`sei()`启用中断。
- en: In the main section of the code, we set up PORTB and PORTD so that the LED pin
    is an output and PORTC as inputs for the interrupt pins ❷. Once the initializations
    have taken place, the code in the `for` loop ❸ will make the LED blink on and
    off. However, when you press one of the buttons, you’ll trigger the interrupt
    for the corresponding PCI bank, running the code in that bank’s matching ISR.
    We end the code run for each interrupt by setting the PCIFR flag to 1 for that
    particular bank.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的主部分，我们设置PORTB和PORTD，使LED引脚为输出，PORTC为中断引脚的输入 ❷。初始化完成后，`for`循环 ❸中的代码将使LED闪烁。然而，当你按下其中一个按钮时，会触发对应PCI银行的中断，运行该银行匹配的ISR。我们通过将PCIFR标志设置为1来结束每个中断的代码运行。
- en: At this point, you’ve seen how to use interrupts with digital inputs to activate
    code on demand when required by the user. To finish off this chapter’s experiments,
    I’ll show you how to use interrupts in a more practical situation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何使用中断与数字输入配合，在用户需要时激活代码。为了完成本章的实验，我将向你展示如何在更实际的情况下使用中断。
- en: '[Project 26: Creating an Up/Down Counter Using Interrupts](nsp-boxall502581-0008.xhtml#rpro26)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 26：使用中断创建上下计数器](nsp-boxall502581-0008.xhtml#rpro26)'
- en: 'This project combines what you’ve learned about interrupts with sending data
    to your computer via the USART (covered in [Project 18](nsp-boxall502581-0014.xhtml#pro18)
    in [Chapter 4](nsp-boxall502581-0014.xhtml#ch04) ). You’ll build a counting device
    that uses two buttons to accept user input: one button increases the count by
    one, and the other decreases it. Each button will trigger a rising edge interrupt
    and call a matching ISR to add to or subtract from the counter’s tally.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目结合了你在[第 4 章](nsp-boxall502581-0014.xhtml#ch04)的[项目 18](nsp-boxall502581-0014.xhtml#pro18)中学到的关于中断的知识，并通过
    USART 向计算机发送数据。你将构建一个计数设备，使用两个按钮来接受用户输入：一个按钮将计数值增加 1，另一个按钮将其减少。每个按钮都会触发上升沿中断，并调用一个匹配的
    ISR 来增加或减少计数器的值。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0710)'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件](nsp-boxall502581-0008.xhtml#rbh0710)'
- en: 'You’ll need the following hardware:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要以下硬件：
- en: • USBasp programmer
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp 程序烧录器
- en: • Solderless breadboard
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊面包板
- en: • ATmega328P-PU microcontroller
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATmega328P-PU 微控制器
- en: • USB to serial converter
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USB 转串口转换器
- en: • Jumper wires
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线
- en: • Two pushbuttons
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个按钮
- en: • Two 10 kΩ resistors
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个 10 kΩ 电阻
- en: Assemble the circuit shown in [Figure 5-6](nsp-boxall502581-0015.xhtml#f05006)
    .
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图 5-6](nsp-boxall502581-0015.xhtml#f05006)所示组装电路。
- en: '![Schematic diagram for Project 26](images/nsp-boxall502581-f05006.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![项目 26 的原理图](images/nsp-boxall502581-f05006.jpg)'
- en: 'Figure 5-6: Schematic for [Project 26](nsp-boxall502581-0015.xhtml#pro26)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-6： [项目 26](nsp-boxall502581-0015.xhtml#pro26) 的原理图
- en: With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard as in the previous projects. Next, connect your USB-to-serial
    converter to your computer, just as you did in [Chapter 4](nsp-boxall502581-0014.xhtml#ch04)
    .
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将电路组装好后，将 USBasp 通过无焊面包板连接到你的微控制器，方式与之前的项目相同。接下来，将你的 USB 转串口转换器连接到计算机，像在[第 4
    章](nsp-boxall502581-0014.xhtml#ch04)中一样操作。
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0711)'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码](nsp-boxall502581-0008.xhtml#rbh0711)'
- en: Open a terminal window, navigate to the *Project 26* subfolder of this book’s
    *Chapter 5* folder, and enter the command `make flash` to upload the project’s
    code as usual. Now run your terminal software on your computer, as you did in
    [Chapter 4](nsp-boxall502581-0014.xhtml#ch04) , and click the **Connect** button.
    After a moment, the terminal software should display the value of the counting
    variable.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，导航到本书*第 5 章*文件夹下的*项目 26*子文件夹，并输入命令`make flash`，像往常一样上传项目代码。接下来，像在[第
    4 章](nsp-boxall502581-0014.xhtml#ch04)中一样运行终端软件，并点击**连接**按钮。片刻之后，终端软件应该会显示计数变量的值。
- en: Try pressing each button. The counter value should increase or decrease with
    each button press, giving you output like that shown in [Figure 5-7](nsp-boxall502581-0015.xhtml#f05007)
    .
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试按下每个按钮。每按一下按钮，计数值应该会增加或减少，输出结果应与[图 5-7](nsp-boxall502581-0015.xhtml#f05007)中的示例类似。
- en: '![A screenshot of the output of Project 26 in the terminal software on Windows
    11](images/nsp-boxall502581-f05007.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![Windows 11上终端软件运行项目26输出的截图](images/nsp-boxall502581-f05007.jpg)'
- en: 'Figure 5-7: Our counter in action'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-7：我们计数器的实际运行情况
- en: In this figure, the counter doesn’t always appear to increase or decrease by
    just one. That’s because the count is only updated every second, and you can press
    a button many times in the span of one second.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，计数器并不总是看起来只增加或减少 1。这是因为计数值每秒更新一次，而你可以在一秒钟内多次按下按钮。
- en: 'To see how this is implemented, open the *main.c* file for [Project 26](nsp-boxall502581-0015.xhtml#pro26)
    :'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看如何实现这一点，请打开[项目 26](nsp-boxall502581-0015.xhtml#pro26)的*main.c*文件：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This project demonstrates how to use interrupts to receive user input, using
    much less code than if we had to check for a button press in every cycle of the
    main code. First we set up the library initialization and functions required to
    use the USART. Then we declare the `i` variable ❶, which stores the value of the
    counter, followed by the convenient functions used in the [last chapter](nsp-boxall502581-0014.xhtml#ch04)
    to send text and numbers via the USART to the PC.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目演示了如何使用中断接收用户输入，所需的代码比在主代码的每个周期中检查按钮按下要少得多。首先，我们设置了库的初始化和使用USART所需的函数。接着我们声明了`i`变量❶，它存储计数器的值，后面是上一个章节中用于通过USART将文本和数字发送到PC的方便函数，详见[上一章](nsp-boxall502581-0014.xhtml#ch04)。
- en: Both the main code and the ISR functions need to be able to access the `i` variable,
    which is why it’s defined outside the `int main(void)` section. Declaring a variable
    outside the main code makes it a *global variable* , which means any part of the
    code can access it, not just the code in the particular function in which the
    variable could be declared. When you declare a global variable, you should place
    the `volatile` keyword before its data type to let the compiler know that it could
    change at any time, so the microcontroller needs to reload it from memory every
    time the program uses it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 主代码和ISR函数都需要能够访问`i`变量，这就是为什么它被定义在`int main(void)`部分之外的原因。将变量声明在主代码之外使其成为*全局变量*，这意味着代码的任何部分都可以访问它，而不仅仅是声明变量的特定函数中的代码。当你声明一个全局变量时，应该在其数据类型前加上`volatile`关键字，告诉编译器该变量可能随时变化，因此每次程序使用它时，微控制器需要从内存中重新加载它。
- en: This project uses pins 4 and 5 as external rising edge interrupts, so next we
    define the code to run when the INT0 ❷ and INT1 ❸ interrupts are triggered and
    initialize them using EICRA and EIMSK ❹. Once the main code starts running, it
    should send the value of the counter variable to your PC via the USART every second.
    Thanks to the power of the interrupts (and the buttons connected to them), each
    time you trigger one of the interrupts, the relevant ISR code should add or subtract
    one to or from the counter variable, depending on which button is pressed. You
    can test this by pressing either button on and off rapidly; as the variable changes,
    the updated value should display in your terminal.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目使用引脚4和5作为外部上升沿中断，因此接下来我们定义了在INT0❷和INT1❸中断触发时执行的代码，并使用EICRA和EIMSK❹初始化它们。一旦主代码开始运行，它应该每秒通过USART将计数器变量的值发送到PC。由于中断的强大功能（以及连接到它们的按钮），每次触发其中一个中断时，相关的ISR代码应该根据按下的按钮将计数器变量加或减去1。你可以通过快速按下和松开任一按钮来测试这一点；随着变量的变化，更新的值应显示在终端中。
- en: '[Final Notes on Interrupts](nsp-boxall502581-0008.xhtml#rah0703)'
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[关于中断的最终说明](nsp-boxall502581-0008.xhtml#rah0703)'
- en: Working with hardware interrupts can give your AVR-based projects more options
    to complete tasks on demand, instead of during a preprogrammed sequence of events.
    To simplify this introduction to interrupts, this chapter focused on creating
    circuits that react to button presses. However, in real-world projects, you’ll
    more often program interrupts to respond to limit switches in machinery or signals
    from sensors to help your project make a decision.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用硬件中断可以为基于AVR的项目提供更多的选项，以便按需完成任务，而不是在预先编程的事件序列中完成。为了简化这对中断的介绍，本章重点介绍了创建响应按钮按下的电路。然而，在实际项目中，你更常见的是编程中断来响应机械设备中的限位开关或传感器发出的信号，以帮助你的项目做出决策。
- en: When using interrupts, always declare the pins used to trigger interrupts as
    inputs using a `DDR` `x` function, or the microcontroller won’t detect the trigger.
    Also declare any variables used in both your main code and ISRs as `volatile`
    and make them global variables.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中断时，始终将用于触发中断的引脚声明为输入，使用`DDR` `x`函数，否则微控制器将无法检测到触发。同时，将主代码和ISR中使用的任何变量声明为`volatile`，并使它们成为全局变量。
- en: The [next chapter’s](nsp-boxall502581-0016.xhtml#ch06) projects expand on interrupts,
    showing you how to use them to run functions after a preset period of time.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[下一章](nsp-boxall502581-0016.xhtml#ch06)的项目扩展了中断的应用，向你展示了如何使用中断在预设的时间段后运行函数。'
