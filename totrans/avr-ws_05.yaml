- en: '[5](nsp-boxall502581-0008.xhtml#rch05)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking Control with Hardware Interrupts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/nsp-boxall502581-ct.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So far, the code for your projects in this book has been sequential. Any deviations
    from a linear pattern, such as detecting button presses, required you to monitor
    digital inputs. However, preplanning button presses in your code isn’t always
    efficient or realistic. *Hardware interrupts* allow your programs to respond to
    events more efficiently and dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hardware interrupts enable the AVR microcontroller to react to a change of
    state at a digital input pin at any time. In a way, they allow your AVR to multitask:
    when a button is pressed or when a signal is received at a digital input, the
    AVR will stop what it is doing and run some other code, called an *interrupt service
    routine (ISR)* . After the ISR code runs, the AVR picks up execution where it
    left off before the interrupt.'
  prefs: []
  type: TYPE_NORMAL
- en: Interrupts allow you to write more logical code and make your AVR-based projects
    operate more intuitively. This chapter covers two kinds of hardware interrupts,
    external interrupts and pin-change interrupts, using the ATmega328P-PU microcontroller.
    Both interrupts are triggered by state changes in pins (for instance, a change
    from high to low voltage). Pin-change interrupts can occur on all the pins, while
    external interrupts can only happen on two pins. Once you’ve got the basics down,
    you’ll use interrupts to create a counting device with a USART-based display.
  prefs: []
  type: TYPE_NORMAL
- en: '[External Interrupts](nsp-boxall502581-0008.xhtml#rah0701)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section walks you through the basics of initializing external interrupts,
    which you’ll put to use in [Project 22](nsp-boxall502581-0015.xhtml#pro22) . The
    ATmega328P-PU uses pins 4 and 5, referenced as INT0 and INT1, for external interrupts.
    These two pins can detect and report changes in the electrical signal connected
    to them. The interrupts can be set to react to one of the following four possible
    changes in state at the pin:'
  prefs: []
  type: TYPE_NORMAL
- en: Low level The voltage at the pin changes to a low state (equivalent to GND).
  prefs: []
  type: TYPE_NORMAL
- en: Any logic change The voltage at the pin changes in any way, either from high
    to low or from low to high.
  prefs: []
  type: TYPE_NORMAL
- en: Falling edge The voltage changes from high to low.
  prefs: []
  type: TYPE_NORMAL
- en: Rising edge The voltage changes from low to high.
  prefs: []
  type: TYPE_NORMAL
- en: Consider which of these options would allow your code to respond to a button
    press. For example, if you had a button connected to GND and a microcontroller
    input with a pullup resistor, then the button press would switch the input from
    high to low. In this situation, you would typically use the falling edge interrupt
    option. Conversely, if you had a button connected between 5 V and the microcontroller
    input with a pulldown resistor, the button press would switch the input from low
    to high. In this case you could use a rising edge or any logic change interrupt.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the choice of interrupt type will be determined by the external circuitry
    connected to the interrupt pin. I’ll demonstrate various types of interrupts in
    action in this chapter, so you can use these examples to help you determine what’s
    right for your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting Up Interrupts in Code](nsp-boxall502581-0008.xhtml#rbh0701)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use interrupts, first add the interrupt library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you’ll need to set up a few registers—we’ll step through them one by
    one below. The first of these is the EICRA register, which we use to determine
    which of the four state changes the pin will respond to. Here’s the template for
    setting the EICRA register in any AVR program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Set interrupt INT0 (pin 4) with bits `c` and `d` and interrupt INT1 (pin 5)
    with bits `a` and `b` , using the guidelines in [Table 5-1](nsp-boxall502581-0015.xhtml#tab0501)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 5-1 : EICRA Register Option Bits |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| Bit a/c | Bit b/d | Interrupt type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | Low level |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | Any logic change |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | Falling edge |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | Rising edge |'
  prefs: []
  type: TYPE_TB
- en: 'For example, you could set up INT0 for a rising edge interrupt as follows,
    using the `c` and `d` bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, set up the EIMSK register, which is used to turn on the interrupt function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, bit `a` is INT1 and bit `b` is INT0\. Set each bit to 1 for on or 0 for
    off. For example, to turn the interrupt function on for INT0, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Since only the last bit is set to 1, only INT0 will be turned on.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting the EICRA and EIMSK registers, enable interrupts in your code
    using this function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Don’t forget this step—if you skip it, even if you’ve set your registers properly,
    the interrupt won’t be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a recap of the code required for interrupts so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve prepared your AVR to respond to interrupts, you must define your
    ISR—the code that runs when the interrupt is triggered. The ISR is a custom function
    with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter `INT` `x` `_vect` specifies the pin that the ISR responds to.
    When you pass a value to the function, replace the `x` in `INT` `x` `_vect` with
    `0` for INT0 or `1` for INT1\. The body of the function is the code that executes
    when the interrupt is triggered. We always end this ISR code section with this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets the external interrupt flag registers back to zero, telling the microcontroller
    that the interrupt code for this particular ISR is complete and the AVR can return
    to normal operation. If you are using only one interrupt, you can use the following
    values for `y` : `0b00000001` for INT0 and `0b00000010` for INT1\. However, if
    your project is using both interrupts, if you set the EIFR register with an entire
    8-bit value, you will alter both interrupts. Instead, you can use the following,
    which will just turn off one interrupt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This way of addressing register bits individually will be explained in detail
    in the [next chapter](nsp-boxall502581-0016.xhtml#ch06) . In the meanwhile, let’s
    put pin-change interrupts to the test in the [following project](nsp-boxall502581-0015.xhtml#pro22)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 22: Experimenting with Rising Edge Interrupts](nsp-boxall502581-0008.xhtml#rpro22)'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll first program your microcontroller to rapidly blink
    an LED, then add logic so that pressing a button interrupts the blinking LED and
    runs some other code, keeping the LED on for two seconds before it returns to
    its blinking pattern. You’ll accomplish this using a rising edge interrupt.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0702)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One 560 Ω resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One pushbutton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One 10 kΩ resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, assemble the circuit shown in [Figure 5-1](nsp-boxall502581-0015.xhtml#f05001)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 22](images/nsp-boxall502581-f05001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: The main circuit for [Project 22](nsp-boxall502581-0015.xhtml#pro22)'
  prefs: []
  type: TYPE_NORMAL
- en: The resistor and button are in the pulldown configuration that I introduced
    in [Chapter 3](nsp-boxall502581-0013.xhtml#ch03) . When you press the button the
    current will flow to pin 4, changing its state from low to high. This rising edge
    state change will trigger the interrupt.
  prefs: []
  type: TYPE_NORMAL
- en: With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard, as you did in previous projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0703)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window and navigate to the *Project 22* subfolder of this book’s
    *Chapter 5* folder, then enter the command `make flash` . The toolchain should
    compile the program file and upload the data to the microcontroller, at which
    point the LED should begin to blink rapidly, turning on and off every 50 milliseconds.
    Press the button quickly (don’t leave your finger on it for long, since this will
    trigger switch bouncing), and the LED should stay on for two seconds, then resume
    blinking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the *main.c* file for [Project 22](nsp-boxall502581-0015.xhtml#pro22)
    to see how this code works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code defines a `startInt0()` function to initialize the interrupts. Within
    this function, we first set the EICRA register so that INT0 reacts to a rising
    edge interrupt ❸, then set the EIMSK register to turn INT0 on ❹, and finally call
    `sei()` to enable interrupts. In the main section of the code, we set up PORTB
    pins as outputs to control the LED ❺ and set PORTD pins as inputs ❻. PORTD includes
    digital pin 4, which will act as input for the interrupt INT0.
  prefs: []
  type: TYPE_NORMAL
- en: Once everything is initialized, the for loop ❼ makes the LED blink on and off.
    Because there’s an interrupt, when you press the button, the resulting rising
    edge triggers the hardware interrupt INT0\. This tells the AVR to stop blinking
    the LED and run the code in the ISR ❶. When the ISR code has finished, the EIFR
    register is set to 0 ❷ and the LED returns to rapidly blinking as normal.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You’ve just seen the most common kind of interrupt in action.
    Less often, you’ll need to detect when current stops flowing to the microcontroller,
    which you can do using a falling edge interrupt. You’ll try this out in the [next
    project](nsp-boxall502581-0015.xhtml#pro23) .
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 23: Experimenting with Falling Edge Interrupts](nsp-boxall502581-0008.xhtml#rpro23)'
  prefs: []
  type: TYPE_NORMAL
- en: This project has the same result as [Project 22](nsp-boxall502581-0015.xhtml#pro22)
    , but this time the circuit uses the pullup configuration introduced in [Chapter
    3](nsp-boxall502581-0013.xhtml#ch03) . By default, there will be current at digital
    pin 4\. When you press the button, current should stop flowing to pin 4, changing
    its state from high to low to trigger the falling edge interrupt.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0704)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One 560 Ω resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One pushbutton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One 10 kΩ resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start by assembling the circuit shown in [Figure 5-2](nsp-boxall502581-0015.xhtml#f05002)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 23](images/nsp-boxall502581-f05002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: The main circuit for [Project 23](nsp-boxall502581-0015.xhtml#pro23)'
  prefs: []
  type: TYPE_NORMAL
- en: With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard as you did in previous projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0705)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 23* subfolder of this book’s
    *Chapter 5* folder, and enter the command `make flash` . Once the project’s code
    has been uploaded, the LED should begin to blink rapidly. Quickly press the button.
    The LED should stay on for two seconds, then resume blinking.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, open the *main.c* file for [Project 23](nsp-boxall502581-0015.xhtml#pro23)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for this project is identical to that of [Project 22](nsp-boxall502581-0015.xhtml#pro22)
    , except for one change: we set the EICRA register to `0b00000010` instead of
    `0b00000011` ❶. Per [Table 5-1](nsp-boxall502581-0015.xhtml#tab0501) , the last
    two bits ( `10` ) set INT0 to the falling edge type of interrupt. EIMSK stays
    the same, since we’re still using INT0 as the interrupt pin, and as usual we call
    `sei()` to enable the interrupt.'
  prefs: []
  type: TYPE_NORMAL
- en: Play with these projects to familiarize yourself with both rising and falling
    edge interrupts. Once you feel comfortable using both options for digital inputs,
    you can choose whether to trigger an interrupt with a high or low signal in your
    own projects, depending on how the circuit you’re working with is built. This
    may sound like a trivial choice now, but it’ll become important as you create
    more complicated AVR-based projects. In some situations, you can’t choose the
    hardware or the circuit, and you’ll have to work around their limitations using
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s try something more interesting. As I mentioned earlier, the ATmega328P-PU
    has two interrupt pins. In the [next project](nsp-boxall502581-0015.xhtml#pro24)
    , you’ll use both to make the microcontroller respond to two different interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 24: Experimenting with Two Interrupts](nsp-boxall502581-0008.xhtml#rpro24)'
  prefs: []
  type: TYPE_NORMAL
- en: This project uses two buttons to allow you to trigger two interrupts for different
    responses. One button triggers a rising edge interrupt and turns on the LED for
    one second, while the other triggers a falling edge interrupt that turns on the
    LED for two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0706)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One 560 Ω resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two pushbuttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two 10 kΩ resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit shown in [Figure 5-3](nsp-boxall502581-0015.xhtml#f05003)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 24](images/nsp-boxall502581-f05003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-3: The main circuit for [Project 24](nsp-boxall502581-0015.xhtml#pro24)'
  prefs: []
  type: TYPE_NORMAL
- en: With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard as in the previous projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0707)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 24* subfolder of this book’s
    *Chapter 5* folder, and enter the command `make flash` . As in the previous two
    projects, once the code has been uploaded the LED should start to blink rapidly.
    Press the button connected to INT0 (digital pin 4), and the LED should stay on
    for one second. Press the button connected to INT1 (digital pin 5), and the LED
    should stay on for two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how the code handles these interrupts, open the *main.c* file for [Project
    24](nsp-boxall502581-0015.xhtml#pro24) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code is similar to the code for [Projects 22](nsp-boxall502581-0015.xhtml#pro22)
    and [23](nsp-boxall502581-0015.xhtml#pro23) , again with a little modification.
    As usual, we start by defining a `startInts()` function to initialize the interrupts.
    Inside this function, we set the EICRA register to respond to each interrupt ❶.
    Remember that the register is set with the formula `0b0000` `abcd` , where bits
    `a` and `b` correspond to pin 5 and bits `c` and `d` correspond to pin 6\. Here,
    we’ve set EICRA so that INT0 reacts to a rising edge interrupt and INT1 reacts
    to a falling edge interrupt ( `0b00001011` ). Next, we set the EIMSK register
    to turn on both INT0 and INT1 by setting the last two bits to 1 ❷, then we call
    `sei()` to enable interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: In the main section of the code, we set up PORTB as outputs so that the code
    will control the LED ❸. We also set up PORTD as inputs to cover digital pins 4
    and 5, which will act as inputs for INT0 and INT1, respectively ❹. Once everything
    is initialized, the code in the `for` loop ❺ will cause the LED to blink on and
    off. However, when one of the buttons is pressed, the corresponding interrupt
    will trigger and the code in the interrupt’s ISR will run.
  prefs: []
  type: TYPE_NORMAL
- en: When planning projects with multiple interrupts, remember that an interrupt
    cannot be called by another interrupt. That is, if one interrupt’s ISR code is
    running, triggering another interrupt will not affect the operation of that ISR.
    You can’t interrupt an interrupt!
  prefs: []
  type: TYPE_NORMAL
- en: What if you need to use more than two interrupt pins, or can’t use digital pins
    4 and 5 but still need your project to respond to state change triggers? The solution
    is to use pin-change interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: '[Pin-Change Interrupts](nsp-boxall502581-0008.xhtml#rah0702)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While using the external interrupts INT0 and INT1 is simple, straightforward,
    and gives you lots of control, working with just two interrupts is a huge limitation.
    Using *pin-change interrupts* is a little trickier, but gives you as many interrupts
    as you have pins.
  prefs: []
  type: TYPE_NORMAL
- en: Pin-change interrupts can only tell you if a pin has changed state—they can’t
    provide any details about that change of state. While an external interrupt can
    detect a change from low to high or high to low, a pin-change interrupt can only
    detect that a change happened. That means any change in state will trigger the
    interrupt, and you’ll have to decide in your code if you want to respond to that
    change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pins used for pin-change interrupts are organized into three banks:'
  prefs: []
  type: TYPE_NORMAL
- en: Bank 0 Includes PCINT0 through PCINT7.
  prefs: []
  type: TYPE_NORMAL
- en: Bank 1 Includes PCINT8 through PCINT14.
  prefs: []
  type: TYPE_NORMAL
- en: Bank 2 Includes PCINT16 through PCINT23.
  prefs: []
  type: TYPE_NORMAL
- en: PCINT stands for *pin-change interrupt* . Each bank has its own ISR code, giving
    you three types of level changes that you can use with their respective pins.
    This gives you more flexibility, but it means you can’t assume that each ISR function
    corresponds to a single pin. Rather, each ISR function responds to any state change
    in any of the pins in its corresponding bank. Thus, your code will have to determine
    not only what the state change was but which pin it came from before it can respond
    appropriately. Note that there is no PCINT15.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note PCINT numbers are not the same as pin numbers: for example, PCINT8 is
    pin 23, not pin 8\. Refer to the pinout diagram in [Figure 5-4](nsp-boxall502581-0015.xhtml#f05004)
    for each PCINT value’s pin number, and make sure not to confuse the two numbers
    in your code. Each bank’s byte in binary represents the order of pins in the bank,
    from highest to lowest.'
  prefs: []
  type: TYPE_NORMAL
- en: You can match the three PCINT *xx* banks to physical pin numbers using the ATmega328P-PU’s
    pinout diagram, shown in [Figure 5-4](nsp-boxall502581-0015.xhtml#f05004) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram of ATmega328P-PU microcontroller with pins and their functions](images/nsp-boxall502581-f05004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-4: ATmega328P-PU pinout diagram'
  prefs: []
  type: TYPE_NORMAL
- en: For example, Bank 0 responds to PCINT0–PCINT7, meaning you can trigger it with
    pins 15–19 at the bottom right of [Figure 5-4](nsp-boxall502581-0015.xhtml#f05004)
    and pins 9, 10, and 14 at the bottom left.
  prefs: []
  type: TYPE_NORMAL
- en: Using pin-change interrupts in your code is similar to using external interrupts.
    Once again, first include the interrupt library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, set the PCICR register to turn on the required PCI (pin-change interrupt)
    banks, using this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Bank 0 is set with bit `z` , bank 1 with bit `y` , and bank 2 with bit `x`
    . For example, to turn on banks 0 and 2, you would use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that each bank can respond to several pins, so you’ll need to select
    which pins in each of the banks can be used for an interrupt by turning on the
    interrupt function corresponding to each pin you select. Each bank has its own
    interrupt function that you can turn on with the registers PCMSK0, PCMSK1, and
    PCMSK2\. Pins are turned on or off with a 1 or 0 in that pin’s spot. To use pin
    15 in bank 0, pin 23 in bank 1, and pin 13 in bank 2, you’d set the PCMSK *x*
    registers like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve selected the pins in each bank that should trigger an interrupt,
    enable the interrupts with the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, define your ISR. Each PCI has its own ISR with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `x` in `PCINT` `x` `_vect` with `0` for bank 0, `1` for bank 1,
    and `2` for bank 2, and you’re ready to add your interrupt code. We always end
    this ISR code section with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets the pin-change interrupt flag register back to zero, which tells
    the microcontroller that the interrupt code for that particular bank has completed
    and that it can return to running the code in the main loop as normal. You can
    use the following values for `y` in order to set the pin-change interrupt flag:
    `0b00000001` for bank 0, `0b00000010` for bank 1, and `0b00000100` for bank 2.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll put pin-change interrupts to the test in the following project.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 25: Experimenting with Pin-Change Interrupts](nsp-boxall502581-0008.xhtml#rpro25)'
  prefs: []
  type: TYPE_NORMAL
- en: This project expands on the previous ones, using three buttons, in conjunction
    with a pin on each of the three PCI banks, to demonstrate how to use pin-change
    interrupts. Pressing each button should trigger a different interrupt, which should
    turn the LED on for a certain period of time.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0708)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One 560 Ω resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Three pushbuttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Three 10 kΩ resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To begin, assemble the circuit shown in [Figure 5-5](nsp-boxall502581-0015.xhtml#f05005)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 25](images/nsp-boxall502581-f05005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-5: The main circuit for [Project 25](nsp-boxall502581-0015.xhtml#pro25)'
  prefs: []
  type: TYPE_NORMAL
- en: With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard as you have for the previous projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0709)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 25* subfolder of this book’s
    *Chapter 5* folder, and enter the command `make flash` to upload the project’s
    code, as usual. Once the code has uploaded, the LED should start to blink rapidly.
    Pressing the different buttons should turn the LED on for one, two, or three seconds,
    as defined in the ISR for each pin-change interrupt bank.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, open the *main.c* file for [Project 25](nsp-boxall502581-0015.xhtml#pro25)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This code has the same structure as the code for the external interrupt projects.
    First, we define a `startInts()` function to initialize the interrupts. Inside
    this function, we set the PCICR register to enable all three banks of PCIs ❶;
    then we set the physical pins to use as each bank’s interrupt pin using the three
    following lines and make a call to `sei()` to enable interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: In the main section of the code, we set up PORTB and PORTD so that the LED pin
    is an output and PORTC as inputs for the interrupt pins ❷. Once the initializations
    have taken place, the code in the `for` loop ❸ will make the LED blink on and
    off. However, when you press one of the buttons, you’ll trigger the interrupt
    for the corresponding PCI bank, running the code in that bank’s matching ISR.
    We end the code run for each interrupt by setting the PCIFR flag to 1 for that
    particular bank.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you’ve seen how to use interrupts with digital inputs to activate
    code on demand when required by the user. To finish off this chapter’s experiments,
    I’ll show you how to use interrupts in a more practical situation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 26: Creating an Up/Down Counter Using Interrupts](nsp-boxall502581-0008.xhtml#rpro26)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This project combines what you’ve learned about interrupts with sending data
    to your computer via the USART (covered in [Project 18](nsp-boxall502581-0014.xhtml#pro18)
    in [Chapter 4](nsp-boxall502581-0014.xhtml#ch04) ). You’ll build a counting device
    that uses two buttons to accept user input: one button increases the count by
    one, and the other decreases it. Each button will trigger a rising edge interrupt
    and call a matching ISR to add to or subtract from the counter’s tally.'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0710)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • USB to serial converter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two pushbuttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two 10 kΩ resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit shown in [Figure 5-6](nsp-boxall502581-0015.xhtml#f05006)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 26](images/nsp-boxall502581-f05006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-6: Schematic for [Project 26](nsp-boxall502581-0015.xhtml#pro26)'
  prefs: []
  type: TYPE_NORMAL
- en: With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard as in the previous projects. Next, connect your USB-to-serial
    converter to your computer, just as you did in [Chapter 4](nsp-boxall502581-0014.xhtml#ch04)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0711)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 26* subfolder of this book’s
    *Chapter 5* folder, and enter the command `make flash` to upload the project’s
    code as usual. Now run your terminal software on your computer, as you did in
    [Chapter 4](nsp-boxall502581-0014.xhtml#ch04) , and click the **Connect** button.
    After a moment, the terminal software should display the value of the counting
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Try pressing each button. The counter value should increase or decrease with
    each button press, giving you output like that shown in [Figure 5-7](nsp-boxall502581-0015.xhtml#f05007)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the output of Project 26 in the terminal software on Windows
    11](images/nsp-boxall502581-f05007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-7: Our counter in action'
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the counter doesn’t always appear to increase or decrease by
    just one. That’s because the count is only updated every second, and you can press
    a button many times in the span of one second.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this is implemented, open the *main.c* file for [Project 26](nsp-boxall502581-0015.xhtml#pro26)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This project demonstrates how to use interrupts to receive user input, using
    much less code than if we had to check for a button press in every cycle of the
    main code. First we set up the library initialization and functions required to
    use the USART. Then we declare the `i` variable ❶, which stores the value of the
    counter, followed by the convenient functions used in the [last chapter](nsp-boxall502581-0014.xhtml#ch04)
    to send text and numbers via the USART to the PC.
  prefs: []
  type: TYPE_NORMAL
- en: Both the main code and the ISR functions need to be able to access the `i` variable,
    which is why it’s defined outside the `int main(void)` section. Declaring a variable
    outside the main code makes it a *global variable* , which means any part of the
    code can access it, not just the code in the particular function in which the
    variable could be declared. When you declare a global variable, you should place
    the `volatile` keyword before its data type to let the compiler know that it could
    change at any time, so the microcontroller needs to reload it from memory every
    time the program uses it.
  prefs: []
  type: TYPE_NORMAL
- en: This project uses pins 4 and 5 as external rising edge interrupts, so next we
    define the code to run when the INT0 ❷ and INT1 ❸ interrupts are triggered and
    initialize them using EICRA and EIMSK ❹. Once the main code starts running, it
    should send the value of the counter variable to your PC via the USART every second.
    Thanks to the power of the interrupts (and the buttons connected to them), each
    time you trigger one of the interrupts, the relevant ISR code should add or subtract
    one to or from the counter variable, depending on which button is pressed. You
    can test this by pressing either button on and off rapidly; as the variable changes,
    the updated value should display in your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '[Final Notes on Interrupts](nsp-boxall502581-0008.xhtml#rah0703)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with hardware interrupts can give your AVR-based projects more options
    to complete tasks on demand, instead of during a preprogrammed sequence of events.
    To simplify this introduction to interrupts, this chapter focused on creating
    circuits that react to button presses. However, in real-world projects, you’ll
    more often program interrupts to respond to limit switches in machinery or signals
    from sensors to help your project make a decision.
  prefs: []
  type: TYPE_NORMAL
- en: When using interrupts, always declare the pins used to trigger interrupts as
    inputs using a `DDR` `x` function, or the microcontroller won’t detect the trigger.
    Also declare any variables used in both your main code and ISRs as `volatile`
    and make them global variables.
  prefs: []
  type: TYPE_NORMAL
- en: The [next chapter’s](nsp-boxall502581-0016.xhtml#ch06) projects expand on interrupts,
    showing you how to use them to run functions after a preset period of time.
  prefs: []
  type: TYPE_NORMAL
