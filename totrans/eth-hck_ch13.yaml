- en: '**13'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SERIOUS CROSS-SITE SCRIPTING EXPLOITATION**
  prefs: []
  type: TYPE_NORMAL
- en: '*Love all, trust a few, do wrong to none.*'
  prefs: []
  type: TYPE_NORMAL
- en: –William Shakespeare, *All’s Well That Ends Well*
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter explores a website exploitation technique called *cross-site scripting
    (XSS)* that lets you run your own JavaScript in other users’ browsers when they
    visit a vulnerable site. Successful XSS attacks can block access to websites,
    steal cookies and credentials, and even compromise a user’s machine.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re comfortable identifying and performing XSS attacks manually, we’ll
    explore the Browser Exploitation Framework, which allows you to quickly inject
    JavaScript into a vulnerable site for a variety of purposes. We’ll use this framework
    to perform social engineering attacks and collect credentials. You’ll also learn
    how to use a chain of exploits to take over a browser and load a reverse shell
    onto a machine that visits your website.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-Site Scripting**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a web app doesn’t correctly sanitize user inputs, such as comments or blog
    entries, an attacker could inject malicious code into the site by entering JavaScript
    code into the comment form instead of a legitimate comment. For example, say the
    web page uses a template like the one in [Figure 13-1](ch13.xhtml#ch13fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch13fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: JavaScript that has been injected into a template using XSS*'
  prefs: []
  type: TYPE_NORMAL
- en: Templates are skeletons containing placeholders that represent a web page’s
    general structure. When a page is rendered, a program called a template engine
    replaces these placeholders with values the programmer specifies. For example,
    a programmer may tell the template engine to replace the `{{name}}` placeholder
    with the last value entered into the database. If the last name in the database
    was Frances, the template engine would generate a page that reads `"Welcome Frances."`
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of an XSS attack is to get a web app to add malicious JavaScript to
    a page. In this example, an attacker could trick the web page into adding malicious
    code by writing a comment containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `<script>` and `</script>` tags represent where the JavaScript code starts
    and ends, respectively. In this case, the tags contain the JavaScript command
    `alert()`, which causes a message to pop up on the screen. The template engine
    will now generate a web page that contains this comment; however, because this
    comment contains the `<script>` tag, the browser interprets it as code instead
    of text. When the browser runs this code, it will open a dialog box containing
    the message `"You've been Hacked!"` If the programmer had correctly sanitized
    the comment, it wouldn’t have contained the `<script>` tags and the browser wouldn’t
    have interpreted it as code.
  prefs: []
  type: TYPE_NORMAL
- en: Because the malicious JavaScript is stored in the web app, we commonly call
    this type of XSS attack a *stored XSS* attack. There are other types of XSS attacks,
    too, including reflected XSS and DOM XSS attacks. We’ll discuss reflected XSS
    attacks later in this chapter. You can find a detailed discussion of DOM XSS attacks
    on OWASP’s website.
  prefs: []
  type: TYPE_NORMAL
- en: '***How JavaScript Can Be Malicious***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The payload you inject into the website’s code can be quite harmful. For example,
    it could include JavaScript code that steals a user’s cookies, allowing the attacker
    to impersonate them.
  prefs: []
  type: TYPE_NORMAL
- en: When you visit a web page, the web server sends your browser the HTML, JavaScript,
    and cascading styles sheet (CSS) code it needs to render the page, and if you’ve
    successfully authenticated, the web server might also send your browser a cookie.
    As discussed in [Chapter 12](ch12.xhtml#ch12), a cookie is a field in the HTTP
    request and response that the browser and web server use to store values and maintain
    state. Your browser stores this cookie and includes it in any future HTTP requests
    it sends to the web server. This keeps users from having to log in each time they
    perform an action on the site. The web server verifies that the HTTP requests
    are authentic by checking the cookie, so if an attacker steals this cookie, they
    can access the victim’s account by sending HTTP requests containing the stolen
    cookie.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand cookies, let’s look at the web developer tools that allow
    you to view and analyze the HTML, Javascript, CSS, and cookies your browser receives.
    Open Firefox and then press CTRL-SHIFT-I to open its developer tools ([Figure
    13-2](ch13.xhtml#ch13fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch13fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: Accessing the developer tools in Firefox*'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Debugger** tab ➊ to reveal a window that lets you explore the page’s
    code. Using the panel ➋, navigate to the associated files and folders. The window
    ➌ shows the associated source code. To run this JavaScript and see what it does,
    click the **Console** tab ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript is an interpreted language, which means you don’t need to recompile
    the program to run a new command. Try entering new commands into the console.
    For example, enter the following command to view the page’s cookies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To steal a victim’s cookie using this JavaScript, the attacker must inject the
    code into a page on the domain to which the cookie belongs. This is because of
    a security policy called the *same origin policy* that allows only JavaScript
    running on the same page to access that page’s resources. So, JavaScript on one
    domain can’t access cookies associated with a different domain. For example, JavaScript
    running on *virginia.edu* can’t access cookies created by *[nostarch.com](http://nostarch.com)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand the attack’s mechanisms, consider the following JavaScript
    code. It includes an HTML image tag that contains carefully crafted malicious
    code to steal cookies. This JavaScript is the payload that the attacker will inject
    into the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `<script>` tags, the JavaScript command `document.write()` uses the
    browser document API to write to the *document object model (DOM)*, which is a
    virtual representation of the web page. Here, it writes an image (`<img>`). However,
    this image is special. Its source URL, the location from which the browser should
    retrieve the image, points to the attacker’s server, and its query string parameter
    (`cookie`) contains the user’s cookies. So when the image loads it will send the
    users cookies to the attacker’s server. Once an attacker has access to a victim’s
    cookies, they can attempt to authenticate as the user.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the cookie might contain characters that aren’t allowed in a URL, so
    we must escape these before sending the cookie by including it as a query string
    parameter in the source URL. When the browser attempts to load the image, it will
    generate a `GET` request to the attacker’s server, essentially sending the user’s
    cookies directly to the attacker.
  prefs: []
  type: TYPE_NORMAL
- en: 'The attacker’s server that receives the cookies might be running a simple Python
    program like the following, which extracts the query string parameter from the
    `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that it’s using an encrypted socket, so you’ll need to generate your
    *server.crt* certificate and private key, *server.key*. See [Chapter 6](ch06.xhtml#ch6)
    for details on doing so. To be even more stealthy, you could purchase a certificate
    for a domain you own. After you’ve extracted the cookies, you can load them into
    your browser and access the user’s accounts. One way to do this is with *Cookie
    Quick Manager*, a Firefox extension that allows you to edit, add, and delete cookies
    from your browser ([Figure 13-3](ch13.xhtml#ch13fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch13fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: An example of Quick Cookie Manager*'
  prefs: []
  type: TYPE_NORMAL
- en: When you install the extension, you will see a cookie icon in your toolbar ➊.
    Click the cookie icon and then select **Manage all Cookies**. This will show all
    the cookies your browser currently has. When you click a specific domain ➋, it
    will show you all the cookies your browser has stored for that domain. You can
    edit the cookies by changing the value field ➌. You’ll need to enable editing
    by clicking the pencil icon at the bottom of the page. Once you’ve loaded the
    stolen cookies, you can access the victim’s account.
  prefs: []
  type: TYPE_NORMAL
- en: '***Stored XSS Attacks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you understand the general mechanisms of an XSS attack, let’s walk
    through a real example by performing a stored XSS attack. As shown earlier, we’ll
    use a blog post to insert malicious JavaScript into a server. We’ll attack a blog
    page on the vulnerable Mutillidae app we used in [Chapter 12](ch12.xhtml#ch12).
    This app is hosted on Metasploitable, so start the Metasploitable virtual machine,
    log in to it, and get the server’s IP address using `**ifconfig**`. Now start
    the web browser on your Kali Linux virtual machine and visit the “add your own
    blog” page in the Mutillidae app by selecting **OWASP Top 10** ▶ **A2 Cross Site
    Scripting (XSS)** ▶ **Persistent (Second Order)** ▶ **Add to your blog**.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s test whether this page is vulnerable to XSS by attempting to inject
    some JavaScript into our blog post ([Figure 13-4](ch13.xhtml#ch13fig4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch13fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-4: Executing the stored XSS attack in Mutillidae’s blog*'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of writing a regular blog post in the text box, we’ll write some JavaScript
    code (`<script> alert("Hacked") </script>`) and save the post. Once you’ve refreshed
    the page, Mutillidae will retrieve the malicious JavaScript and embed it in the
    page as it would any other blog post. However, unlike other blog posts, your new
    blog post contains JavaScript code, which the browser will execute. If it runs
    successfully, it should open a pop-up containing the word *Hacked*. Save the blog
    post and refresh the page. This should embed the JavaScript code in the page and
    cause the browser to display a pop-up.
  prefs: []
  type: TYPE_NORMAL
- en: To understand why this attack worked, take a look at the table in [Figure 13-5](ch13.xhtml#ch13fig5)
    that shows the blog entries located directly below the **Save Blog Entry** button.
    You’ll notice an empty blog entry ➊. This is the one we just created. To read
    the source code for this entry, right-click the entry and select the **Inspect**
    option from the drop-down. This will launch the developer tools.
  prefs: []
  type: TYPE_NORMAL
- en: If you use the tools to read the table code and data, you should notice the
    table data entry (`<td>`) that contains your newly created post ➋. The entry contains
    your malicious JavaScript, which the browser will run as code rather than displaying
    as text in the browser. This is why our blog entry is blank.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch13fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-5: Using the developer tools to show where the malicious script
    was inserted*'
  prefs: []
  type: TYPE_NORMAL
- en: This malicious JavaScript runs when any user visits the blog page. We’ve executed
    a mere alert here, but we can execute any malicious JavaScript such as the cookie
    stealing script we wrote earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '***Reflected XSS Attacks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *reflected XSS* attack exploits a vulnerability in a web app that occurs when
    the app includes data from the HTTP request message in the HTTP response without
    adequately sanitizing it. Consider the following attack scenario. An attacker
    sends an email with the text “Check out this great article about hacking.” However,
    unbeknownst to the victim, the attacker has embedded some malicious JavaScript
    code into one of the query string parameters of the link included in the email.
    When a user clicks the link, the web server adds the malicious JavaScript in the
    query string parameter to the page and the browser executes it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see an example of how query string parameters are added to pages, copy the
    following URL into your web browser: *[https://www.google.com/?q=Ethical+Hacking](https://www.google.com/?q=Ethical+Hacking)*.
    Notice that Google’s server added the value in the query string parameter to the
    search box as a search term. Now suppose that a website doesn’t correctly sanitize
    query string parameters. In that case, an attacker may use a reflected XSS attack
    to inject malicious JavaScript into a victim’s browser.'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at an example that targets the DVWA installed on your Metasploitable
    server. You can access it using a browser on your Kali Linux machine to navigate
    to *http://<Metasploitable-IP>/dvwa/login.php*. Log in using the username **admin**
    and password **password**. Just like the Mutillidae app, DVWA has security levels.
    Click the **Security** tab and set the security level to **low**. Click the tab
    **XSS Reflected**. You should see a submission box that lets you send input to
    the server ([Figure 13-6](ch13.xhtml#ch13fig6)). Try entering “test” in the submission
    box.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch13fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-6: DVWA’s reflected XSS page*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now take a look at the URL. You should notice that the `name` query parameter
    now contains the value `test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also notice the value of the query string parameter is reflected in the page,
    below the submission box. If we include JavaScript in the URL and the app doesn’t
    correctly sanitize it, we can inject JavaScript directly into the page. Copy the
    following URL into your browser and press ENTER:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here we’re using the name query parameter to inject our alert script. If you
    see an alert box, you’ve successfully executed your first reflected XSS attack.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding Vulnerabilities with OWASP Zed Attack Proxy**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with SQL injection, websites protect against XSS attacks by sanitizing user
    input through a variety of means. OWASP maintains a document on the best ways
    to prevent XSS attacks, as well as strategies for evading those protections. You
    can find these on OWASP’s website.
  prefs: []
  type: TYPE_NORMAL
- en: To help companies audit their websites, OWASP developed OWASP *Zed Attack Proxy
    (ZAP)*, an auditing tool that comes preinstalled with Kali Linux, that can scan
    applications to discover web vulnerabilities like XSS or the SQL injection attacks
    discussed in [Chapter 12](ch12.xhtml#ch12).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s scan the Mutillidae app to see what vulnerabilities we find. Launch OWASP
    and select the default setup options. After the setup is complete, click the **Quick
    Start** tab and select the automated scan.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch13fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-7: Starting the ZAP scan*'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the URL of the Mutillidae app in the box. ZAP will explore all the URLs
    in the domain by following the links it discovers. We call the process of exploring
    the links in a domain *spidering* or *crawling*. However, modern web apps may
    sometimes use JavaScript to dynamically render URLs or access APIs, which can’t
    be detected with traditional spidering. For this reason, the ZAP team created
    the *Ajax spider*, a tool that launches the browser and then waits for the page
    to load before exploring it by clicking links and entering data. To use this tool,
    select the **Use ajax spider** option and the **Firefox Headless** option, which
    uses the Firefox browser without opening a window. If you select the Firefox option
    instead, ZAP will open Firefox and you’ll be able to watch it explore the page
    with the Selenium testing framework. Once you’ve chosen these options, start the
    scan by clicking **Attack**.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch13fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-8: The result of running a quick ZAP scan*'
  prefs: []
  type: TYPE_NORMAL
- en: When the scan completes, you should see the screen shown in [Figure 13-8](ch13.xhtml#ch13fig8).
    The lower-left panel shows a list of possible web vulnerabilities ZAP has discovered.
    You should see that the ZAP tool found the *add-to-your-blog.php* page ➊ containing
    the XSS vulnerability we exploited earlier. The tool also shows the headers of
    the HTTP response the server generated ➋ and the body of the response, which contains
    the HTML ➌. As evidence that the XSS attack is possible, the tool has highlighted
    where it injected the JavaScript. ZAP highlights details about the attack ➍. This
    panel also contains information on the URL with the vulnerability and a short
    description of the vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: You can probably already see that ZAP is a very useful tool. Take some time
    to familiarize yourself with its great features by exploring its documentation
    online. Another way to scan a web app is to search for known vulnerabilities associated
    with the technologies used to build it. Use the tools and techniques discussed
    in [Chapter 8](ch08.xhtml#ch8) to discover a target’s underlying technologies.
    For example, you might perform a `whatweb` scan and use the `searchsploit` command
    line tool to find vulnerabilities associated with a specific version of the software
    used to build the app.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Browser Exploitation Framework Payloads**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Browser Exploitation Framework (BeEF)* allows hackers to easily embed
    and control malicious JavaScript payloads in vulnerable apps. We’ll use the tool
    to explore the many things you can achieve with your malicious JavaScript. BeEF
    should come preinstalled in Kali Linux; however, if your version doesn’t have
    it, you can install it by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '***Injecting the BeEF Hook***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When the installation completes, run BeEF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be asked to enter a username and password when the framework starts.
    Create these, and make sure to remember them. Your terminal should then display
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Copy the URL for the BeEF web interface ➊ and enter it into your browser. You
    should see the BeEF login screen, as shown in [Figure 13-9](ch13.xhtml#ch13fig9).
    Log in using the username and password you created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch13fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-9: The BeEF login screen*'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you’ve set up your BeEF server. The server will listen for connections
    from the malicious JavaScript you’ll implant. The framework should also provide
    you with the JavaScript to inject ➋. The script tag included here will load the
    *hook.js* file, a malicious JavaScript file that communicates with the BeEF server.
    Once the module is loaded, you can access all the features of that module.
  prefs: []
  type: TYPE_NORMAL
- en: Use the stored XSS attack covered earlier in this chapter to inject this payload
    into Mutillidae’s blog page at *add-to-your-blog.php*. If you successfully execute
    the attack, the script should become embedded in the web page and your Kali Linux
    browser should show up in the list of the victim machines in the BeEF web UI ([Figure
    13-10](ch13.xhtml#ch13fig10)). Any browser that visits the web page should be
    hooked by the malicious JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch13fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-10: List of browsers running the malicious JavaScript*'
  prefs: []
  type: TYPE_NORMAL
- en: To test this, try hooking the Firefox browser on the Ubuntu virtual machine.
    Start Ubuntu and visit the blog page. When the Ubuntu machine loads the page,
    it should be added to the list of online browsers.
  prefs: []
  type: TYPE_NORMAL
- en: '***Performing a Social Engineering Attack***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What can you do after you’ve hooked the browser? Try using the BeEF framework
    to launch a social engineering attack. This attack will show the victim a fake
    login screen when they try to access the blog page. When the user enters in their
    username and password, the BeEF framework will capture the credentials and redirect
    the user to the blog page.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, click the Ubuntu machine’s IP address in the list of hooked
    browsers and select the **Commands** tab ([Figure 13-11](ch13.xhtml#ch13fig11)).
  prefs: []
  type: TYPE_NORMAL
- en: The **Command** tab contains a list of BeEF modules. I recommend looking through
    them; you might be surprised at all the things you can do once you can inject
    your own JavaScript into a site. You can even write your own BeEF modules using
    Ruby and JavaScript. If you’re interested in trying this, check out the documentation
    at *[https://github.com/beefproject/beef/wiki/Module-Creation/](https://github.com/beefproject/beef/wiki/Module-Creation/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch13fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-11: Performing a social engineering attack in BeEF*'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Social Engineering** folder and select the **Google Phishing** attack.
    This attack injects JavaScript that mimics the Gmail login page. After you execute
    the attack, you’ll see a page similar to [Figure 13-12](ch13.xhtml#ch13fig12)
    on the victim’s machine.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch13fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-12: The fake Google login screen*'
  prefs: []
  type: TYPE_NORMAL
- en: Set the **XSS hook URL** to */index.php?page=add-to-your-blog.php*. When the
    user enters their credentials, they’ll be redirected to the page specified by
    the hook URL. Then, click **Execute** and use the Ubuntu browser to navigate to
    the blog page. Try entering some fake credentials in the fraudulent login screen.
    When you click **command 1** in the **Module Results History** panel of the BeEF
    interface, you should see the captured username and password ([Figure 13-13](ch13.xhtml#ch13fig13)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch13fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-13: Credentials stolen using the phishing attack*'
  prefs: []
  type: TYPE_NORMAL
- en: The **Details** tab offers information the BeEF framework has collected on the
    browser, including the browser’s version and the type of attacks to which it might
    be susceptible.
  prefs: []
  type: TYPE_NORMAL
- en: '**Moving from Browser to Machine**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So you’ve compromised a website. But if you hope to access the computer visiting
    the website, you may feel stuck. Most modern browser tabs are *sandboxed*; that
    is, isolated from other tabs and the operating system. This prevents malicious
    code running in one tab from accessing anything else on the same device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose there are vulnerabilities in the sandbox. In that case, an attacker
    might be able to use malicious JavaScript to exploit these vulnerabilities, escape
    the browser, and run a reverse shell on the targeted machine. This would allow
    an attacker to compromise a user’s machine by exploiting the vulnerable website.
    This attack could be extremely detrimental: imagine if an attacker injected malicious
    code into a popular social media site or search engine and subsequently accessed
    the machines of every visitor.'
  prefs: []
  type: TYPE_NORMAL
- en: Such an attack is not out of the ordinary. Each year, the Pwn2Own hacking contest
    gives hackers three days to break into machines through a web browser. These machines
    always run the latest operating systems and browsers, and there’s a winner most
    years.
  prefs: []
  type: TYPE_NORMAL
- en: '***Case Study: Exploiting an Old Version of the Chrome Browser***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In 2017, Oliver Chang, an engineer on the Chrome security team, discovered a
    vulnerability in Chrome’s V8 JavaScript engine. The vulnerability allowed an attacker
    to perform an out-of-bounds write to launch a shell on the victim’s machine. You
    can find the code for the exploit in the Exploit Database under the ID 42078\.
    When the code is run, a vulnerable version of the Chrome browser will launch the
    calculator app on a Linux machine. Launching a calculator has become the de facto
    way of demonstrating that you can escape the browser. Out-of-bounds reads and
    writes are great bugs to find. An attacker can use these bugs to load and execute
    a shell by chaining together a collection of exploitation techniques.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, discovering and writing exploits for browsers can be an involved
    process. The most popular browsers, Chrome and Safari, are developed by two large
    tech companies with in-house testing teams, so although traditional techniques
    like fuzzing and concolic execution may help you discover vulnerabilities, keep
    in mind that these companies use fuzzing tools, too. For example, Google has an
    in-house tool for fuzzing Chrome, called *ClusterFuzz*, that they almost certainly
    run before releasing a new version of the browser. Thus, you might have the best
    results doing manual code inspection. Luckily, the browser engines used by Chrome
    (Blink) and Safari (Webkit) are open source, and the projects are well documented,
    so you can compile and debug them yourself. The Chrome team even has a free YouTube
    lecture series for Google Chrome developers called Chrome University. The lecture
    series dedicates an entire lecture to exploring the CVE-2019-5786 vulnerability,
    which affected Chrome in 2019 and was exploited by a state actor.
  prefs: []
  type: TYPE_NORMAL
- en: Once these vulnerabilities are fixed, it takes time (days to weeks) to update
    the user’s device. Because these projects are open source, attackers can view
    and exploit these fixes before they make it to production.
  prefs: []
  type: TYPE_NORMAL
- en: '***Installing Rootkits via Website Exploitation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'How might an attacker chain the exploits covered in this chapter to, say, install
    a rootkit on a machine when the victim visits a certain website? Consider the
    following attack scenario: you’ve scanned a website and discovered an XSS vulnerability
    in the app. We’ll call this vulnerability 1\. Next, you use this vulnerability
    to upload malicious JavaScript code that will escape the browser’s sandbox and
    load a malicious reverse shell onto the victim’s machine (vulnerability 2). Once
    the reverse shell connects to your attacker server, you use a kernel vulnerability
    (discussed in [Chapter 14](ch14.xhtml#ch14)) to escalate your privileges (vulnerability
    3) and install a rootkit. You now can invisibly control the machine.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-14](ch13.xhtml#ch13fig14) shows the process of performing this exploit
    using BeEF and Metasploit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch13fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-14: The interactions between a web server, the victim’s laptop,
    and the hacker’s server*'
  prefs: []
  type: TYPE_NORMAL
- en: First, the victim visits a website containing the malicious JavaScript ➊ you’ve
    injected. After the victim’s browser loads the page ➋, it activates the code,
    which then connects to the BeEF server ➌. The BeEF server will then inject additional
    malicious JavaScript ➍ containing a link to the exploitation code on the Metasploit
    server. The browser will then connect to the Metasploit server ➎ and download
    JavaScript code that automatically scans for browser vulnerabilities ➏. If it
    finds a vulnerability, the code exploits the browser and loads a reverse shell
    onto the machine that will connect to the Metasploit server ➐. Now the attacker
    can perform a privilege escalation attack and install a rootkit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try performing this attack by installing a vulnerable version of the
    Firefox browser on the Ubuntu virtual machine. We’ll use Metasploit’s `browser_autopwn2`
    module to automatically scan a browser for a collection of exploits. Start the
    Metasploit console by opening a terminal in your Kali Linux virtual machine and
    running `msfconsole`. Once the Metasploit Framework is up and running, select
    the `browser_autopwn2` module by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Use the `options` command to see a list of available options. We’ll keep the
    default options, but to be stealthier, you might want to specify an SSL certificate
    and URL path instead of using a randomly generated one. For example, the tool
    URLCrazy can identify domains that look similar to domains you’re attacking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now start the Metasploit server running the `browser_autopwn` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the URL of the server ➊ and a list of the exploits the module
    will try ➋. Many of the exploits are outdated, though, and work only on Firefox
    27 or earlier. However, this module is open source, so maybe someone reading this
    book will update it with new exploits. For now, you’ll simply need to run them
    against an older version of Firefox. Download and install an older version on
    the Ubuntu virtual machine with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Time to use BeEF to inject some malicious JavaScript. Ensure that you’ve hooked
    the browser on the Ubuntu virtual machine by injecting a payload in the blog page
    on the Metasploitable server. Then, open the browser window containing the BeEF
    UI and click the browser associated with the Ubuntu virtual machine. As you did
    earlier in this chapter, select **Commands** and open the **Misc** folder. Click
    the **Raw JavaScript** module. This module allows you to inject any JavaScript
    you please into the page. In this case, we’ll inject a script that loads a malicious
    page associated with the `browser_autopwn2` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This JavaScript command opens a tab in the user’s browser that will navigate
    to the malicious page. This is not very stealthy, but it is effective. A subtler
    approach would be to inject the JavaScript associated with the attack directly
    into the page. Click **Execute** and switch over to the terminal running your
    `browser_autopwn2` module. If the attack has successfully executed, you should
    have a new Meterpreter session. Enter `**sessions**` to see a list of your available
    sessions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can interact with a session by entering the `**session**` keyword followed
    by the session number. For example, `sessions 1` lets you interface with the first
    session. Try running a simple command such as `**whoami**` or `**pwd**`, or you
    can run `**help**` to see all possible commands. You might want to use this shell
    to download a rootkit so that you can avoid detection and maintain access to the
    machine even after the browser has been updated.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty spooky, right? To protect yourself, pay attention to the sites you visit,
    and if you’re super paranoid, install the NoScript plug-in. It prevents your browser
    from running any JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise: Hunting for Bugs in a Bug Bounty Program**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time for you to go out and hunt on your own. Because you’re an ethical
    hacker, you won’t attack companies without their permission. Luckily, many companies
    create *bug bounty programs* that allow ethical hackers to attack their websites
    and receive payment for any vulnerabilities they find. Each bug bounty program
    has its own rules outlining what parts of the website can be attacked and other
    limitations (for example, no social engineering attacks). *[Hackerone.com](http://Hackerone.com)*
    maintains a list of bug bounty programs. To sharpen your skills while you hunt
    for bugs, take a look at *Real-World Bug Hunting* by Peter Yaworski (No Starch
    Press, 2019), which describes the bugs discovered while participating in bug bounty
    programs (and the rewards earned). In addition to XSS and SQL injection, Yaworski
    covers other vulnerabilities, such as race conditions, memory vulnerabilities,
    and cross-site request forgery. Happy hunting.
  prefs: []
  type: TYPE_NORMAL
