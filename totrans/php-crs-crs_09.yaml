- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 7 SIMPLE ARRAYS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7 简单数组
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This chapter introduces *arrays*, a compound data type designed for storing
    and manipulating multiple data items under a single variable name. Arrays allow
    you to group related data and efficiently apply the same operations to each data
    item.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了*数组*，这是一种复合数据类型，用于存储和操作多个数据项，在一个变量名称下。数组允许你将相关数据分组，并高效地对每个数据项应用相同的操作。
- en: At its heart, an array is a mapping of values to keys. Each *value* is a piece
    of data you want to store in the array, and its *key* is a unique identifier associated
    with that value so that you can access it from within the array. In this chapter,
    we’ll focus on simple arrays, which use integers as the keys. You’ll learn how
    to create and manipulate simple arrays, and how to iterate over the items in an
    array by using a foreach loop. In the next chapter, we’ll explore how to create
    more sophisticated arrays by using strings (and other data types) as keys, instead
    of integers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，数组是值与键的映射。每个*值*是你想要存储在数组中的数据，而它的*键*是与该值关联的唯一标识符，以便你可以从数组中访问它。在本章中，我们将重点讲解简单数组，它们使用整数作为键。你将学习如何创建和操作简单数组，并通过foreach循环遍历数组中的项目。在下一章中，我们将探讨如何通过使用字符串（以及其他数据类型）作为键来创建更复杂的数组，而不是使用整数。
- en: '### Creating an Array and Accessing Its Values'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### 创建数组并访问其值'
- en: Let’s start our exploration of arrays by creating a simple array that stores
    the monthly rainfall totals for a location ([Listing 7-1](#lis7-1)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个简单数组开始，这个数组存储了某个地点的每月降水总量（[列表 7-1](#lis7-1)）。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 7-1: Declaring a simple array'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-1：声明一个简单数组
- en: 'We declare an array called $rainfall by using a sequence of comma-separated
    values inside square brackets: [10, 8, 12]. This is a three-element array, containing
    the values 10, 8, and 12.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在方括号内使用逗号分隔的值序列来声明一个名为$rainfall的数组：[10, 8, 12]。这是一个三元素数组，包含值10、8和12。
- en: 'By default, PHP gives each array value an integer as a key. The keys are assigned
    in sequence, starting from zero: the first value (10) has a key of 0, the second
    value (8) has a key of 1, and the third value (12) has a key of 2. Accepting this
    default mapping is what makes $rainfall a *simple array* (as opposed to the *sophisticated
    arrays* with custom key-value mappings that we’ll explore in [Chapter 8](chapter8.xhtml)).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，PHP会给每个数组值分配一个整数作为键。键是按顺序分配的，从零开始：第一个值（10）的键是0，第二个值（8）的键是1，第三个值（12）的键是2。接受这个默认映射就是使$rainfall成为一个*简单数组*（与我们将在[第8章](chapter8.xhtml)中探讨的具有自定义键值映射的*复杂数组*相对）。
- en: Now that we have an array, we can use its keys to access its values individually.
    In [Listing 7-2](#lis7-2), we concatenate each value from the $rainfall array
    into a string message and print it out.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个数组，可以使用其键单独访问其值。在[列表 7-2](#lis7-2)中，我们将$rainfall数组中的每个值连接成一个字符串消息并打印出来。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 7-2: Accessing array elements with their integer keys'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-2：通过整数键访问数组元素
- en: 'We access an item in an array by specifying its key in square brackets, after
    the array name. For example, $rainfall[0] gives us the first value in the $rainfall
    array (10), which we concatenate with the string "Jan: ". Similarly, we access
    the second element of the array with $rainfall[1]. Since the integer keys start
    at zero, the last element of an *n*-member array has a key of *n* – 1\. In this
    case, we access the last element of our three-element array with $rainfall[2].
    Here’s the output of running this script:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '我们通过在数组名称后面指定方括号中的键来访问数组中的项目。例如，$rainfall[0]给我们返回$rainfall数组中的第一个值（10），然后我们将其与字符串"Jan:
    "连接。同样，我们可以通过$rainfall[1]访问数组中的第二个元素。由于整数键从零开始，具有*n*个元素的数组的最后一个元素的键是*n* - 1。在这个例子中，我们通过$rainfall[2]访问我们这个三元素数组的最后一个元素。以下是运行该脚本的输出：'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The values 10, 8, and 12 have been successfully read from the array and printed
    using their integer keys 0, 1, and 2.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 值10、8和12已经成功地从数组中读取并使用它们的整数键0、1和2打印出来。
- en: 'If you try to access an array element by using a key that hasn’t been assigned,
    you’ll get a PHP warning. For example, say we add the following print statement
    to the end of [Listing 7-2](#lis7-2):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用一个未分配的键访问数组元素，PHP会给出警告。例如，假设我们在[列表 7-2](#lis7-2)的末尾添加以下打印语句：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This statement will trigger a warning that looks something like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这条语句将触发类似于以下的警告：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our array has only three elements, with keys 0, 1, and 2, so no element exists
    corresponding to $rainfall[3]. Later in the chapter, we’ll discuss how to avoid
    warnings like this by first ensuring that an array element with a particular key
    exists before trying to access it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组只有三个元素，键分别为0、1和2，因此没有与$rainfall[3]对应的元素。稍后我们将在本章中讨论如何通过首先确保数组中具有特定键的元素存在来避免类似的警告，然后再尝试访问它。
- en: Updating an Array
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新数组
- en: Often you’ll need to update an array after you’ve created it by adding or removing
    elements. For example, it’s common to start with an empty array, created by assigning
    an empty set of square brackets ([]) to a variable, and then to add elements to
    it as a script progresses. In this section, we’ll discuss common techniques for
    changing the contents of an array.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在创建数组后，你需要通过添加或删除元素来更新数组。例如，通常会从一个空数组开始，通过将一个空的方括号([])赋值给一个变量来创建它，然后随着脚本的执行，逐渐向其中添加元素。在本节中，我们将讨论一些常见的技术，用于更改数组的内容。
- en: Appending an Element
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 追加元素
- en: If you’re adding a new element to an array, you’ll most often want to add it
    at the end, an operation known as *appending*. This is such a common task that
    PHP makes it very easy to do as part of a simple assignment statement. On the
    left side of the equal sign, you write the array name followed by an empty set
    of square brackets; on the right side of the equal sign, you write the value you
    want to append to the array. For example, [Listing 7-3](#lis7-3) shows a script
    that creates an empty array of animals and then appends elements to the end of
    it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在向一个数组添加新元素，你通常会希望将其添加到数组的末尾，这个操作被称为*追加*。这是一个非常常见的任务，PHP通过简单的赋值语句使其变得非常容易。在等号左侧，你写数组的名称，后面跟着一个空的方括号；在等号右侧，你写你想要追加到数组中的值。例如，[Listing
    7-3](#lis7-3)展示了一个脚本，它创建了一个空的动物数组，然后将元素追加到它的末尾。
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 7-3: Appending elements to the end of an array'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-3: 追加元素到数组的末尾'
- en: 'We declare an empty array called $animals by writing an empty set of square
    brackets. Then we add two elements to the end of the array, one at a time. For
    example, $animals[] = ''cat'' adds the string value ''cat'' to the end of the
    array. PHP automatically gives the new element the next available integer as a
    key. In this case, since $animals is empty when ''cat'' is added, it receives
    a key of 0. When we then use the same notation to add ''dog'' to the array, that
    element automatically gets a key of 1. To confirm this, we print the individual
    values from the array at the end of the script, resulting in this output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过写一个空的方括号来声明一个名为$animals的空数组。然后，我们一个一个地将两个元素添加到数组的末尾。例如，$animals[] = 'cat'
    将字符串值'cat'添加到数组的末尾。PHP会自动为新元素分配下一个可用的整数作为键。在这个例子中，由于$animals在添加'cat'时是空的，所以它的键被赋值为0。当我们使用相同的符号将'dog'添加到数组时，该元素自动得到键1。为了确认这一点，我们在脚本末尾打印数组的每个值，输出如下：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output indicates that 'cat' was successfully mapped to key 0 of the array,
    and 'dog' to 1. The PHP engine was able to find the array’s highest integer key,
    add 1 to it, and use the result as the next unique integer key when appending
    to the array.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果表明，'cat'成功映射到了数组的键0，而'dog'映射到了键1。PHP引擎能够找到数组中最高的整数键，给它加1，并将结果作为追加到数组时的下一个唯一整数键。
- en: Adding an Element with a Specific Key
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用特定键添加元素
- en: While it’s more common to append elements to an array and let PHP do the work
    of automatically assigning the next available integer key, you can also manually
    specify an element’s key when you’re adding it to an array. For example, $heights[22]
    = 101 would add the value 101 to the $heights array and give it the integer key
    22. If a value already exists at that key, that value will be overwritten. As
    such, this direct assignment technique is often used to update an existing value
    in an array rather than add a completely new value. [Listing 7-4](#lis7-4) expands
    our $animals array script to illustrate how this is done.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然更常见的做法是将元素追加到数组，并让PHP自动分配下一个可用的整数键，但你也可以在向数组添加元素时手动指定该元素的键。例如，$heights[22]
    = 101 将值101添加到$heights数组，并为其分配整数键22。如果该键已经存在值，则该值会被覆盖。因此，这种直接赋值技术通常用于更新数组中已存在的值，而不是添加一个全新的值。[Listing
    7-4](#lis7-4)扩展了我们的$animals数组脚本，演示了如何进行这种操作。
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 7-4: Directly assigning an array element with a specified key'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-4: 使用指定键直接赋值数组元素'
- en: 'As before, we append ''cat'' and ''dog'' to the $animals array. Then we replace
    the value of the first array element with ''hippo'' by directly assigning this
    string to key 0 of the array. Here’s the output of running this script:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前所示，我们将 'cat' 和 'dog' 添加到 `$animals` 数组中。然后，我们通过直接将该字符串赋值给数组的键 0 来替换第一个数组元素的值为
    'hippo'。这是运行该脚本后的输出：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that 'hippo' is now mapped to key 0, indicating it has replaced the original
    'cat' value.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，'hippo' 现在映射到了键 0，这表示它已经替换了原来的 'cat' 值。
- en: Be careful when adding a new array element with a specific key. This action
    can break the sequence of integer keys if an array element doesn’t exist for the
    key you provide. This would happen if you used a key beyond the existing size
    of the array. Making an array with a break in the sequence of integer keys is
    permissible, but it can cause issues if you’ve written code elsewhere that relies
    on having a continuous sequence of keys. We’ll explore nonsequential and non-integer
    keys when we look at sophisticated arrays in [Chapter 8](chapter8.xhtml).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用特定的键添加新数组元素时要小心。如果为你提供的键不存在的数组元素进行此操作，可能会破坏整数键的顺序。如果你使用了超出数组当前大小的键，就会发生这种情况。创建一个具有断裂整数键序列的数组是允许的，但如果你在其他地方编写的代码依赖于键的连续序列，这可能会引发问题。我们将在
    [第 8 章](chapter8.xhtml) 中探讨非顺序和非整数键的数组。
- en: Appending Multiple Elements
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加多个元素
- en: So far we’ve been able to add only one element to an array at a time, but the
    built-in array_push() function can add several elements at once to the end of
    an array. The function takes a variable number of parameters. The first is the
    array you want to update, and the rest are the new values to be appended, and
    you can append as many as you want. For example, [Listing 7-5](#lis7-5) revisits
    the script from [Listing 7-3](#lis7-3), where we first added elements to the $animals
    array and then printed them, and uses array_push() to append two more animals
    to the end of the array.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只能一次向数组中添加一个元素，但内置的 `array_push()` 函数可以一次将多个元素添加到数组的末尾。该函数接受可变数量的参数。第一个参数是你要更新的数组，后面是要附加的新值，你可以添加任意多个。例如，[示例
    7-5](#lis7-5) 重新展示了 [示例 7-3](#lis7-3) 中的脚本，在该脚本中我们首先向 `$animals` 数组添加了元素并打印出来，然后使用
    `array_push()` 将另外两个动物添加到数组末尾。
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 7-5: Using array_push() to append multiple values to the end of an
    array'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-5：使用 `array_push()` 将多个值附加到数组末尾
- en: 'We call array_push(), passing in the $animals array and the two string values
    we want to add, ''giraffe'' and ''elephant''. Since the new elements are added
    to the end of the array, they’re automatically assigned the next available integer
    keys, 2 and 3. We confirm this at the end of the script by accessing the two additional
    elements by their keys and printing them out, along with the two original elements:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 `array_push()` 函数，将 `$animals` 数组和我们想要添加的两个字符串值，'giraffe' 和 'elephant'，传入。由于新元素被添加到数组的末尾，它们会自动分配下一个可用的整数键值，分别是
    2 和 3。我们通过访问这两个额外的元素并根据它们的键值打印出来，确认了这一点，连同两个原始元素一起输出：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The output indicates that 'giraffe' was successfully mapped to key 2 and 'elephant'
    to 3.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明，'giraffe' 成功映射到键 2，'elephant' 映射到了键 3。
- en: You may have noticed that when we called the array_push() function, we didn’t
    do it as part of an assignment statement, with the function call on the right
    side of an equal sign and a variable name on the left to capture the function’s
    return value. This is because array_push() directly modifies the array passed
    to it. In this sense, array_push() is quite different from the string manipulation
    functions we looked at in [Chapter 3](chapter3.xhtml), which created and returned
    a new string rather than making changes directly to the original string passed
    to them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当我们调用 `array_push()` 函数时，并没有将其作为赋值语句的一部分，函数调用位于等号的右侧，变量名在左侧用于捕获函数的返回值。这是因为
    `array_push()` 会直接修改传递给它的数组。从这个意义上讲，`array_push()` 与我们在 [第 3 章](chapter3.xhtml)
    中看到的字符串操作函数非常不同，后者是创建并返回一个新的字符串，而不是直接修改传递给它们的原始字符串。
- en: 'The array_push() function can directly modify the provided array because its
    first parameter has been declared using a pass-by-reference approach. As we discussed
    in [Chapter 5](chapter5.xhtml), this means the function is given a direct reference
    to the value of the argument passed in, as opposed to being given a copy of the
    argument’s value via a pass-by-value approach. We can confirm this by looking
    at the function’s signature in the PHP documentation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: array_push() 函数可以直接修改提供的数组，因为它的第一个参数是通过按引用传递的方式声明的。正如我们在[第 5 章](chapter5.xhtml)中讨论的，这意味着该函数会获得传入参数值的直接引用，而不是通过按值传递方式获得该参数值的副本。我们可以通过查看
    PHP 文档中的函数签名来确认这一点：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The ampersand (&) before the first parameter, &$array, indicates that this is
    a pass-by-reference parameter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数前的与符号（&）即 &$array，表示这是一个按引用传递的参数。
- en: Since array_push() is directly modifying the array, there’s no need for it to
    return a copy of the array, or for us to use an assignment statement to capture
    that return value when we call the function. In fact, array_push() *does* have
    a return value, an integer indicating the new length of the array. This can be
    useful if you need to keep track of the array’s length as you’re updating it;
    we didn’t need this return value in [Listing 7-5](#lis7-5), so we simply made
    a stand-alone call to the function, without assigning the result to a variable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 array_push() 是直接修改数组的，因此无需返回数组的副本，或者我们在调用该函数时使用赋值语句来捕获返回值。实际上，array_push()
    *确实*有返回值，它返回一个整数，表示数组的新长度。如果你需要在更新数组时跟踪数组的长度，这个返回值就很有用；在[列表 7-5](#lis7-5)中我们并不需要这个返回值，所以我们只是独立地调用了该函数，而没有将结果赋值给变量。
- en: Removing the Last Element
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移除最后一个元素
- en: The built-in array_pop() function returns the last item of an array while also
    removing that item from the array. This is another example of a pass-by-reference
    function that changes the provided array. In [Listing 7-6](#lis7-6), we use array_pop()
    to retrieve and remove the last element of our $animals array.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 array_pop() 函数返回数组中的最后一个元素，并同时从数组中移除该元素。这是另一个按引用传递的函数示例，它会改变提供的数组。在[列表 7-6](#lis7-6)中，我们使用
    array_pop() 来获取并移除 $animals 数组的最后一个元素。
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 7-6: Using array_pop() to retrieve and remove the last array element'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-6：使用 array_pop() 函数获取并移除数组中的最后一个元素
- en: 'We call array_pop(), passing the $animals array as an argument, and we store
    the function’s return value in the $lastAnimal variable. We then print out $lastAnimal,
    as well as the $animals array, to see which elements remain. Here’s the result:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 array_pop()，将 $animals 数组作为参数传递，并将函数的返回值存储在 $lastAnimal 变量中。然后，我们打印出 $lastAnimal
    和 $animals 数组，查看哪些元素还剩下。结果如下：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The string in variable $lastAnimal is 'dog', since this was the last of the
    elements appended to the array. The var_dump of $animals shows that the array
    contains only 'cat' after the call to array_pop(), demonstrating how this pass-by-reference
    function was able to change the array passed into it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 $lastAnimal 中的字符串为 'dog'，因为这是最后一个被添加到数组中的元素。$animals 的 var_dump 显示，调用 array_pop()
    后数组只包含 'cat'，这演示了这个通过引用传递的函数如何能够改变传入的数组。
- en: Retrieving Information About an Array
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检索数组信息
- en: We’ve considered some functions for modifying an array, but other functions
    can return useful information about an array without changing it at all. For example,
    count() returns the number of elements in an array. This can be useful if you
    want to check whether an array contains anything at all (a count of zero might
    indicate that a shopping cart is empty or that no records were retrieved from
    a database), or whether it has more items than expected (perhaps a customer has
    more than one address on file). Sometimes knowing the number of items in an array
    can be helpful in order to control a loop through that array. In [Listing 7-7](#lis7-7),
    we use count() to print the total number of items in the $animals array.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经考虑了修改数组的一些函数，但其他函数可以在不改变数组的情况下返回关于数组的有用信息。例如，count() 返回数组中元素的数量。如果你想检查一个数组是否为空（零个元素可能意味着购物车为空，或者没有从数据库中检索到记录），或者它是否包含比预期更多的项（也许某个客户有多个地址存档），count()
    就非常有用。有时，知道数组中有多少项对于控制遍历数组的循环也很有帮助。在[列表 7-7](#lis7-7)中，我们使用 count() 来打印 $animals
    数组中的总项数。
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 7-7: Counting the number of elements in an array'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-7：计算数组中元素的数量
- en: We call the count() function, passing the name of the array we want it to count
    up, and print the result. Since $animals has four elements, this script should
    output the integer 4.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用count()函数，传入我们希望计数的数组名称，并打印结果。由于$animals数组包含四个元素，因此此脚本应输出整数4。
- en: NOTE
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* sizeof() *function is an alias of* count()*. If you see a script that
    uses* sizeof()*, know that it works the same way as* count()*.*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*sizeof()* *函数是* count() *的别名。如果你看到一个使用* sizeof() *的脚本，知道它的功能与* count() *相同。*'
- en: Another analytical array function is array_is_list(). PHP distinguishes between
    arrays that are lists and arrays that aren’t. To be considered a *list*, an array
    of length *n* must have consecutively numbered keys from 0 to *n* – 1\. The array_is_list()
    function takes in an array and returns true or false based on whether the array
    meets that definition. All the arrays discussed in this chapter qualify as lists,
    since they rely on PHP’s default behavior of assigning keys sequentially from
    0\. In the next chapter, however, we’ll explore arrays with non-integer keys as
    well as the unset() function, which can remove an element of an array with a given
    key, potentially breaking the consecutive chain of numeric keys and disqualifying
    an array as a list. Thus, array_is_list() could be useful for evaluating an array
    before passing it along to code that expects the array to be structured as a list.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个分析性数组函数是array_is_list()。PHP区分了列表数组和非列表数组。为了被认为是*列表*，一个长度为*n*的数组必须拥有从0到*n*
    – 1的连续编号键。array_is_list()函数接收一个数组，并根据该数组是否符合该定义返回true或false。本章讨论的所有数组都符合列表的标准，因为它们依赖于PHP的默认行为，即从0开始顺序分配键。然而，在下一章，我们将探索具有非整数键的数组，以及unset()函数，它可以删除一个具有特定键的数组元素，这可能打破连续的数字键链，使数组不再符合列表的定义。因此，array_is_list()函数对于在将数组传递给期望列表结构的代码之前评估数组是否符合要求非常有用。
- en: The array_key_last() function returns the key for the last element of the given
    array. Assuming the array is a proper list with consecutively numbered keys, the
    return value of array_key_last() should be one less than the return value of count().
    For example, calling array_key_last($animals) at the end of [Listing 7-7](#lis7-7)
    would return the integer 3, since that’s the key of the fourth (and final) element
    of the array.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: array_key_last()函数返回给定数组最后一个元素的键。假设数组是一个有效的列表，且键是连续编号的，则array_key_last()的返回值应该比count()的返回值少1。例如，在[列表
    7-7](#lis7-7)的末尾调用array_key_last($animals)将返回整数3，因为这是数组中第四个（也是最后一个）元素的键。
- en: Earlier I mentioned that trying to access an array key that doesn’t exist triggers
    a warning. To avoid this, use the isset() function to test whether an array key
    exists before trying to access it. [Listing 7-8](#lis7-8) shows the function in
    action.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我提到过，尝试访问一个不存在的数组键会触发警告。为了避免这种情况，在尝试访问数组键之前，使用isset()函数检查该键是否存在。[列表 7-8](#lis7-8)展示了该函数的实际应用。
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 7-8: Using isset() to test the existence of an array key'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-8：使用isset()测试数组键的存在
- en: 'First, we create our four-element $animals array. Then we use an if...else
    statement with isset() to access only the element with key 3 if that element exists
    (at this point, it should) ❶. We next use array_pop() to remove the last element
    from $animals (the one at key 3) ❷. Then we repeat the same if...else statement.
    Now no element has key 3, but since we’re testing for the element with isset()
    before attempting to access it, we shouldn’t get a warning. Take a look at the
    output of the script:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个包含四个元素的$animals数组。然后，我们使用带有isset()的if...else语句，只有当键为3的元素存在时才访问它（此时它应该存在）❶。接着，我们使用array_pop()删除$animals数组中的最后一个元素（键为3的元素）❷。然后，我们重复相同的if...else语句。现在数组中没有键为3的元素，但由于我们在尝试访问该元素之前使用isset()进行测试，因此我们不应该收到警告。看看脚本的输出：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first line of the output indicates the first call to isset() returned true,
    triggering the if branch of the conditional. The last line shows the second isset()
    call returned false, triggering the else branch and saving us from trying to access
    a nonexistent array element.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行表示第一次调用isset()返回了true，触发了条件语句的if分支。最后一行显示第二次调用isset()返回了false，触发了else分支，避免了尝试访问一个不存在的数组元素。
- en: Looping Through an Array
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历数组
- en: It’s common to have to access the elements of an array, one at a time, and do
    something with each one. Assuming the array is a list, you can do this with a
    for loop that uses a counter variable as the key for the current array element.
    By starting the counter at 0 and incrementing it up to the length of the array,
    you can access each element in turn. [Listing 7-9](#lis7-9) uses a for loop to
    print each element of our $animals array.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数组元素并逐个处理它们是常见的操作。假设数组是一个列表，你可以通过使用一个计数器变量作为当前数组元素的键来使用`for`循环实现这一点。从0开始计数器并将其递增直到数组的长度，你可以依次访问每个元素。[清单
    7-9](#lis7-9)使用`for`循环打印我们$animals数组中的每个元素。
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 7-9: Using a for loop to loop through an array'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-9：使用`for`循环遍历数组
- en: 'We use count() to look up the length of the array, storing the result into
    the $numElements variable. Then we declare a for loop that increments counter
    $i from 0 up to but not including the value of $numElements. (We could hardcode
    the stopping condition as $i < 4, but using a variable makes the code more flexible
    in case the length of the array changes.) In the loop statement group, we use
    $animals[$i] to retrieve the element whose key is the current value of loop variable
    $i, storing it in $animal ❶. Then we print out this $animal string, followed by
    a comma and a space. The output when we run this script in a terminal is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`count()`来查找数组的长度，并将结果存储到$numElements变量中。然后我们声明一个`for`循环，将计数器$i从0递增到$numElements的值（但不包括$numElements本身）。(我们可以将停止条件硬编码为$i
    < 4，但使用变量可以使代码在数组长度变化时更具灵活性。）在循环语句组内，我们使用$animals[$i]来获取当前循环变量$i对应的数组元素，并将其存储到$animal
    ❶。然后我们打印这个$animal字符串，后面跟着一个逗号和一个空格。当我们在终端运行此脚本时，输出如下：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Each of the array elements is printed out in sequence. (Don’t worry, we’ll fix
    that final comma shortly.)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组元素按顺序打印出来。（别担心，我们稍后会修正那个多余的逗号。）
- en: Using a foreach Loop
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`foreach`循环
- en: This for loop approach works, but cycling through the elements of an array is
    such a common task that PHP provides another type of loop, the foreach loop, to
    do it more efficiently. At the core of a foreach loop is the foreach ($array as
    $value) syntax; $array is the name of an array to loop over, and $value is a temporary
    variable that will be assigned the value of each element in the array, one at
    a time. [Listing 7-10](#lis7-10) shows an updated version of [Listing 7-9](#lis7-9),
    using a foreach loop rather than a for loop.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`for`循环方法是可行的，但由于遍历数组元素是一个非常常见的任务，PHP提供了另一种循环类型——`foreach`循环，来更高效地完成此任务。`foreach`循环的核心语法是`foreach
    ($array as $value)`；其中$array是要循环的数组名，而$value是一个临时变量，每次被赋值为数组中的一个元素。[清单 7-10](#lis7-10)展示了[清单
    7-9](#lis7-9)的更新版本，使用了`foreach`循环而不是`for`循环。
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 7-10: Using a foreach loop to elegantly loop through an array'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-10：使用`foreach`循环优雅地遍历数组
- en: We declare this loop by using foreach ($animals as $animal). Here, $animal is
    a temporary variable that takes on the value of each array element in turn, which
    we then print in the body of the loop. Notice that we no longer have to worry
    about determining the length of the array to set the loop’s stopping condition,
    nor do we need to manually access each array element, as we did in the for loop
    version with $animals[$i]. The foreach loop retrieves each element automatically.
    The result is the same as the for loop version, but the foreach loop’s syntax
    is much more elegant and concise.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`foreach ($animals as $animal)`来声明这个循环。在这里，$animal是一个临时变量，依次获取每个数组元素的值，我们然后在循环体内打印它。注意，我们不再需要担心确定数组的长度来设置循环的停止条件，也不需要像在`for`循环版本中那样手动访问每个数组元素（如$animals[$i]）。`foreach`循环会自动访问每个元素。结果与`for`循环版本相同，但`foreach`循环的语法更加优雅简洁。
- en: The foreach loop has the added benefit that we don’t need to care whether the
    provided array is a true list. With the for loop version, we’re relying on the
    consecutive integer numbering of the array keys; if a key is missing, we’ll get
    a warning when we try to access that key. By contrast, the foreach loop simply
    accesses each element in the array, no matter what the keys are.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`循环还有一个额外的好处，我们无需关心提供的数组是否是真正的列表。在`for`循环版本中，我们依赖于数组键的连续整数编号；如果某个键缺失，尝试访问该键时会出现警告。相比之下，`foreach`循环会简单地访问数组中的每个元素，无论键是什么。'
- en: Accessing Keys and Values
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问键和值
- en: An alternative syntax for foreach loops allows you to access both the key and
    the value of each array element, instead of just the value. For this, declare
    the loop in the format foreach ($array as $key => $value). Here, $array is the
    array you want to loop through, $key is a temporary variable that will hold the
    current element’s key, and $value is a temporary variable that will hold the current
    element’s value. The => operator connects a key to a value. We’ll use it more
    extensively in [Chapter 8](chapter8.xhtml) when we work with sophisticated arrays
    whose keys can be strings and other data types.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach` 循环的另一种语法允许你访问每个数组元素的键和值，而不仅仅是值。为此，可以按以下格式声明循环：`foreach ($array as
    $key => $value)`。这里，`$array` 是你想要遍历的数组，`$key` 是一个临时变量，保存当前元素的键，`$value` 是一个临时变量，保存当前元素的值。`=>`
    操作符将键与值连接起来。在 [第8章](chapter8.xhtml) 中，当我们处理包含字符串和其他数据类型键的复杂数组时，会更加广泛地使用这种语法。'
- en: Gaining access to keys as well as values allows us to eliminate that pesky final
    comma from the output after the last element in the $animals array. Recall that
    the array_key_last() function returns the key of the last element in an array.
    By comparing the value from this function with the current key in the foreach
    loop, we can decide whether to print a comma after each element. [Listing 7-11](#lis7-11)
    shows how.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 访问键和值使我们能够消除数组中最后一个元素后的多余逗号。回顾一下，`array_key_last()` 函数返回数组最后一个元素的键。通过将这个函数的返回值与
    `foreach` 循环中的当前键进行比较，我们可以决定是否在每个元素后面打印逗号。 [清单 7-11](#lis7-11) 展示了这一方法。
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 7-11: A revised foreach loop that accesses the key and value of each
    array element'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-11：一个修改后的 `foreach` 循环，访问每个数组元素的键和值
- en: 'We declare a foreach loop by using foreach ($animals as $key => $animal). Each
    cycle through the loop, $key will be the key and $animal will be the value of
    the current array element. Inside the loop, we first print out the string in $animal.
    Then we use an if statement to also print a comma and a space if the current element’s
    key is *not* equal to the last key of the array (identified with the array_key_last()
    function). This should produce the following output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 `foreach ($animals as $key => $animal)` 来声明一个 `foreach` 循环。在每次循环中，`$key`
    是当前数组元素的键，而 `$animal` 是当前数组元素的值。在循环内，我们首先打印出 `$animal` 中的字符串。然后，我们使用 `if` 语句来判断，如果当前元素的键
    *不* 等于数组的最后一个键（可以通过 `array_key_last()` 函数获得），则打印出一个逗号和一个空格。这样应该会产生如下输出：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We’ve successfully eliminated the comma after the last element in the array.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地去掉了数组中最后一个元素后的逗号。
- en: Imploding an Array
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将数组转换为字符串
- en: The code in [Listing 7-11](#lis7-11) is essentially printing a string containing
    the elements in an array with a separator (in this case, a comma and a space)
    between them. This is a common task, so PHP provides a built-in function called
    implode() to do it automatically, without the need for any kind of loop.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-11](#lis7-11) 中的代码本质上是打印一个包含数组元素的字符串，元素之间有一个分隔符（在本例中是逗号和空格）。这是一个常见的任务，因此
    PHP 提供了一个内建函数 `implode()` 来自动执行此操作，无需使用任何类型的循环。'
- en: 'The function takes two arguments: a string to use as a separator and an array
    to implode into a string. The separator goes *between* elements, not *after each*
    element, so the code won’t place an extra separator after the last array element.
    [Listing 7-12](#lis7-12) shows an updated script that uses implode() rather than
    a foreach loop.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受两个参数：一个作为分隔符的字符串和一个要转换为字符串的数组。分隔符 *位于* 元素之间，而不是 *每个* 元素后面，因此代码不会在数组的最后一个元素后添加额外的分隔符。[清单
    7-12](#lis7-12) 展示了一个更新后的脚本，使用 `implode()` 而不是 `foreach` 循环。
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 7-12: Using implode() to convert an array into a string'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-12：使用 `implode()` 将数组转换为字符串
- en: Here we print the result of calling implode() on the $animals array. We use
    the string ', ' as a separator to put a comma and a space between the array elements.
    The output should be exactly the same as that of [Listing 7-11](#lis7-11), but
    implode() makes the code much more efficient to write.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们打印调用 `implode()` 函数对 `$animals` 数组进行处理后的结果。我们使用字符串 `', '` 作为分隔符，在数组元素之间添加逗号和空格。输出应该与
    [清单 7-11](#lis7-11) 完全相同，但 `implode()` 使得代码写起来更高效。
- en: The implode() function may have rendered our foreach loop unnecessary in this
    case, but don’t let that fool you. A foreach loop is the right tool to use in
    plenty of scenarios. In general, when the code you want to apply to each element
    in an array is more sophisticated than simply printing out that element’s value,
    a foreach loop is likely appropriate.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: implode()函数可能已经让我们在这种情况下不再需要foreach循环，但不要被这个误导。foreach循环在很多场景下都是正确的工具。一般来说，当你要应用到数组中每个元素的代码比简单地打印出该元素的值更复杂时，使用foreach循环通常是合适的。
- en: Functions with a Variable Number of Arguments
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有可变数量参数的函数
- en: One important application for arrays is that you can use them to declare functions
    that accept a variable number of arguments. When we created custom functions in
    [Chapter 5](chapter5.xhtml), we needed to know exactly how many arguments each
    function would take in so we could define the function with the corresponding
    number of parameters. This isn’t always possible, however.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的一个重要应用是，你可以用它们来声明接受可变数量参数的函数。当我们在[第5章](chapter5.xhtml)中创建自定义函数时，我们需要准确知道每个函数会接受多少个参数，这样我们才能定义具有相应参数数量的函数。然而，这并不总是可能的。
- en: For example, say we want to declare a sum() function that takes in an unspecified
    quantity of numbers, adds them all up, and returns the result. We don’t know whether
    the user will pass two numbers, three numbers, or more as arguments, so we can’t
    create a separate parameter for each number. Instead, we use a single parameter
    to represent all the numbers, and we write an ellipsis, or three dots (...), before
    the parameter name. This syntax tells PHP to treat the parameter as an array and
    to fill it with all the arguments provided, however many there are.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想声明一个sum()函数，它接受一个不确定数量的数字，将它们全部加起来并返回结果。我们不知道用户会传递两个数字、三个数字或更多作为参数，因此无法为每个数字创建一个单独的参数。相反，我们使用一个单一的参数来表示所有数字，并在参数名前写三个点（...）。这种语法告诉PHP将该参数视为数组，并将其填充为所有传入的参数，无论有多少个。
- en: '[Listing 7-13](#lis7-13) shows how this approach works by declaring the sum()
    function just described. Remember that functions should be declared in a separate
    file from the code that calls them, so create a *my_functions.php* file containing
    the contents of this listing.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-13](#lis7-13)展示了如何通过声明刚才描述的sum()函数来实现这一方法。记住，函数应该在与调用它们的代码分开的文件中声明，所以创建一个名为*my_functions.php*的文件，包含此列表的内容。'
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 7-13: A function to take in a variable number of integer arguments
    and return their sum'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-13：一个接受可变数量整数参数并返回它们总和的函数
- en: We declare the sum() function, which returns an integer. It has a single parameter,
    ...$numbers. Thanks to the ellipsis, any arguments the function receives will
    be assigned as elements to a local array called $numbers. Notice that we don’t
    specify a data type for the parameter when using the ellipsis notation; we know
    the overall $numbers variable will be of the array type, although the individual
    elements of the array can be of any type. Inside the function body, we initialize
    $total to 0. Then we use a foreach loop to cycle through the elements of the $numbers
    array, adding the value of each element to $total. Once the loop has finished,
    we return $total, which holds the sum of the arguments.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了sum()函数，它返回一个整数。它有一个单一的参数，...$numbers。由于省略号，函数接收到的任何参数都会作为元素分配给一个名为$numbers的本地数组。注意，使用省略号表示法时，我们没有为参数指定数据类型；我们知道整体的$numbers变量将是数组类型，尽管数组的单个元素可以是任何类型。在函数体内，我们将$total初始化为0。然后我们使用foreach循环遍历$numbers数组的元素，将每个元素的值加到$total中。当循环结束时，我们返回$total，它保存了所有参数的总和。
- en: NOTE
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Our* sum() *function doesn’t include any logic to confirm that the elements
    in* $numbers *are actually numbers. A real-world function would need some form
    of data validation and would perhaps return* NULL *or indicate invalid data some
    other way if the arguments provided aren’t all numbers. Also note that PHP already
    has a built-in* array_sum() *function that totals up the numbers in an array.
    We’ve implemented our own version for demonstration purposes.*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们的* sum() *函数没有包含任何逻辑来确认* $numbers *中的元素实际上是数字。一个真实的函数需要某种形式的数据验证，如果传入的参数不是所有数字，它可能会返回*
    NULL *或以其他方式指示数据无效。还需要注意的是，PHP已经有一个内置的* array_sum() *函数，用来计算数组中数字的总和。我们实现了自己的版本用于演示。*'
- en: '[Listing 7-14](#lis7-14) shows a *main.php* script to read in the sum() function
    declaration and test it out with a variable number of arguments.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-14](#lis7-14)展示了一个*main.php*脚本，用于读取sum()函数的声明并通过传递不同数量的参数进行测试。'
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 7-14: A main script that calls sum() with different numbers of arguments'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-14：一个调用sum()并传入不同参数个数的主脚本
- en: 'After reading in and executing *my_functions.php* with require_once, we make
    three calls to sum(), each with a different number of arguments, and print the
    results. The script produces this output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用require_once读取并执行*my_functions.php*之后，我们调用了三次sum()，每次传入不同数量的参数，并打印结果。脚本输出如下：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The three printed sums have been correctly calculated. This indicates that our
    sum() function has successfully collected the variable number of arguments in
    an array.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的三个总和已正确计算。这表明我们的sum()函数已经成功地将可变数量的参数收集到一个数组中。
- en: Array Copies vs. Array References
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组复制与数组引用
- en: Say you have a variable containing an array, and you assign it as the value
    of a second variable. In some languages, such as Python and JavaScript, the second
    variable would be assigned a *reference* to the original array. The two variables
    would then refer to the same array in the computer’s memory, so a change to one
    variable would apply to the other variable as well. In PHP, however, the default
    is to assign the second variable a *copy* of the array. Because the two variables
    have their own separate arrays, a change to one won’t impact the other. [Listing
    7-15](#lis7-15) returns to our $animals array to illustrate this point.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含数组的变量，并将其赋值给第二个变量。在一些语言中，例如Python和JavaScript，第二个变量将被赋值为指向原始数组的*引用*。两个变量将指向计算机内存中的同一个数组，因此一个变量的变化也会影响另一个变量。而在PHP中，默认情况下是将第二个变量赋值为数组的*副本*。由于两个变量各自拥有独立的数组，因此一个变量的变化不会影响另一个变量。[列表
    7-15](#lis7-15)回到我们的$animals数组来说明这一点。
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 7-15: Copying an array'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-15：复制数组
- en: 'We declare our usual $animals array, then assign $animals to $variable2. This
    creates a separate copy of the array in $variable2, so anything we do to one array
    should have no effect on the other. To prove it, we use array_pop() to remove
    the last element from the $variable2 array, then print the original $animals array.
    Here’s the result:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了常规的$animals数组，然后将$animals赋值给$variable2。这会在$variable2中创建一个数组的独立副本，因此我们对一个数组的操作不应影响另一个数组。为了证明这一点，我们使用array_pop()删除$variable2数组中的最后一个元素，然后打印原始的$animals数组。结果如下：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: All four animal strings are still present in the $animals array, even though
    we deleted the final element ('elephant') from the $variable2 array, so the variables
    indeed hold separate arrays.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们从$variable2数组中删除了最后一个元素（'elephant'），$animals数组中的四个动物字符串仍然存在，因此这两个变量确实持有独立的数组。
- en: If you want to assign the second variable a reference to the original array,
    as is customary in other languages, rather than a copy of the array, then use
    the reference operator (&) at the time of assignment. [Listing 7-16](#lis7-16)
    updates the code from [Listing 7-15](#lis7-15) to show the difference.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望将第二个变量赋值为对原始数组的引用，而不是数组的副本，就像其他语言中常见的做法那样，可以在赋值时使用引用操作符（&）。[列表 7-16](#lis7-16)更新了[列表
    7-15](#lis7-15)中的代码，展示了两者的区别。
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 7-16: Using the reference operator when assigning an array'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-16：在赋值数组时使用引用操作符
- en: 'This time we prefix the $animals array with the reference operator (&) when
    assigning it to $variable2. This means a change to one variable will now apply
    to the other variable as well, since both refer to the same array in memory. The
    updated script results in this output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们在将$animals数组赋值给$variable2时，前缀加上了引用操作符（&）。这意味着一个变量的变化将影响另一个变量，因为两个变量都引用了内存中的同一个数组。更新后的脚本输出结果如下：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The output reveals that popping element 3 from the $variable2 array also removed
    element 3 from the $animals array. This confirms that both $variable2 and $animals
    refer to the same array in memory.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果显示，从$variable2数组中弹出元素3也同时删除了$animals数组中的元素3。这确认了$variable2和$animals都引用了内存中的同一个数组。
- en: One of these approaches to array assignment isn’t inherently better than the
    other; they’re just different. Sometimes it’s best to copy an array before manipulating
    it. For example, a web page might offer the user a chance to edit a shopping list,
    while providing a Cancel button to undo those edits. In this case, you’ll want
    to work with a copy of the shopping list array until the changes are confirmed,
    since you may need to revert to the original array if the user clicks Cancel.
    Other times, it’s preferable to have multiple variables referencing the same array
    in memory. Perhaps the code contains logic that chooses one of several arrays
    and so needs to set a variable to be a reference to the chosen array.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数组赋值的方法没有哪种天生比另一种更好，它们只是不同。有时最好在操作数组之前先复制一份。例如，一个网页可能让用户编辑购物清单，同时提供一个取消按钮来撤销编辑。在这种情况下，你可能希望在确认更改之前处理购物清单数组的副本，因为如果用户点击取消，你可能需要恢复到原始数组。其他时候，最好让多个变量引用内存中同一个数组。也许代码包含选择多个数组中的一个的逻辑，因此需要将某个变量设置为所选数组的引用。
- en: The key point to take away from this section is that PHP defaults to copying
    the array unless you use the reference operator (&). If you’ve learned a different
    programming language before PHP, or if you learn another language in the future,
    it’s important to understand the difference between assignment of a copy and assignment
    of a reference, and to know which behavior the language uses by default.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的关键点是，除非使用引用操作符（&），否则PHP默认会复制数组。如果你在学习PHP之前已经学习过其他编程语言，或者将来学习其他语言，那么理解赋值副本与赋值引用之间的区别，并了解语言默认使用的行为是很重要的。
- en: Treating Strings as Arrays of Characters
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将字符串视为字符数组
- en: In a way, you can think of a string as an array of individual characters. This
    can be useful since you may sometimes want to “navigate” through the string character
    by character for tasks such as encryption, spellchecking, and so on, just as you’d
    traverse the elements of an array.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种程度上讲，你可以把字符串看作是一个个独立字符的数组。这在某些情况下很有用，因为你可能希望逐字符“遍历”字符串，执行加密、拼写检查等任务，就像遍历数组的元素一样。
- en: 'As you saw in [Chapter 3](chapter3.xhtml), the characters in a string are numbered
    from 0, just like the elements in a simple array. In fact, you can use the same
    square-bracket notation for accessing an array element to also access a specific
    character from a string. For example, if $name held the string ''Smith'', $name[0]
    would return ''S'', $name[1] would return ''m'', and so on. Strings also support
    *negative* integer keys for counting characters backward from the end of the string:
    $name[-1] returns ''h'' (the last character), $name[-2] returns ''t'', and so
    on.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第3章](chapter3.xhtml)中看到的，字符串中的字符是从0开始编号的，就像简单数组中的元素一样。事实上，你可以使用相同的方括号表示法来访问数组元素，同时也可以访问字符串中的特定字符。例如，如果$name保存的是字符串'Smith'，那么$name[0]将返回'S'，$name[1]将返回'm'，依此类推。字符串还支持*负*整数键，用于从字符串的末尾反向计数字符：$name[-1]返回'h'（最后一个字符），$name[-2]返回't'，依此类推。
- en: NOTE
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Unlike strings, arrays themselves don’t interpret negative integer keys as
    counting backward from the end of the array. Instead,* $animals[-1] *would be
    interpreted as an element of the* $animals *array with an actual key of* -1*.
    While you* can *manually assign negative integers as keys to array elements, I
    personally can’t remember ever needing to do so.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*与字符串不同，数组本身并不会将负整数键解释为从数组末尾反向计数。相反，* $animals[-1] *将被解释为* $animals *数组中一个实际键为*
    -1 *的元素。虽然你*可以*手动将负整数作为键分配给数组元素，但我个人不记得曾经需要这么做。*'
- en: '[Listing 7-17](#lis7-17) shows an example of using array key syntax to access
    individual characters from a string.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-17](#lis7-17)展示了使用数组键语法访问字符串中单个字符的示例。'
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 7-17: Using square-bracket notation to access string characters'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-17：使用方括号表示法访问字符串字符
- en: 'We assign the string ''Smith'' to the $name variable. Next, we copy the string’s
    first character ($name[0]) to the $firstChar variable and its second-to-last character
    ($name[-2]) to $secondToLastChar. We then print out messages with the values of
    these variables, producing the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将字符串 'Smith' 分配给$name变量。接下来，我们将字符串的第一个字符（$name[0]）复制到$firstChar变量，将倒数第二个字符（$name[-2]）复制到$secondToLastChar变量。然后，我们打印出这些变量的值，输出如下信息：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Unlike with arrays, we can’t pass a string to a foreach loop to cycle through
    all its characters. However, we *can* use PHP’s built-in str_split() function
    to convert a string into an actual array of individual characters, then pass that
    array to a foreach loop, as shown in [Listing 7-18](#lis7-18).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组不同，我们不能将字符串传递给 `foreach` 循环以循环遍历其所有字符。然而，我们*可以*使用 PHP 内置的 `str_split()` 函数将字符串转换为实际的字符数组，然后将该数组传递给
    `foreach` 循环，如 [示例 7-18](#lis7-18) 所示。
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 7-18: Using str_split() and foreach to loop over the characters in
    a string'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-18：使用 `str_split()` 和 `foreach` 循环遍历字符串中的字符
- en: 'We pass the same $name string to str_split(). By default, this function breaks
    the string into individual characters, assigns them as elements of an array, and
    returns the result, which we store in the $characters variable. We then use a
    foreach loop to access each key and value in the array version of the string and
    print them out. Here’s the result:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将相同的 $name 字符串传递给 `str_split()`。默认情况下，该函数将字符串拆分为单个字符，将它们作为数组的元素，并返回结果，我们将其存储在
    $characters 变量中。然后，我们使用 `foreach` 循环访问字符串的数组版本中的每个键和值并打印它们。结果如下：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The output shows that we’ve successfully looped through the characters from
    the original string after first converting the string to an array with str_split().
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，在使用 `str_split()` 将字符串转换为数组后，我们已成功循环遍历原始字符串中的字符。
- en: 'The str_split() function has an optional second argument controlling the number
    of characters for each string element in the resulting array. The argument defaults
    to 1, splitting the string into individual characters, but if we’d called str_split($name,
    2), for example, then the resulting array would contain two-character strings:
    [''Sm'', ''it'', ''h''].'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`str_split()` 函数有一个可选的第二个参数，用于控制结果数组中每个字符串元素的字符数。该参数的默认值为 1，将字符串拆分为单个字符，但如果我们调用
    `str_split($name, 2)`，例如，那么结果数组将包含两个字符的字符串：[''Sm'', ''it'', ''h'']。'
- en: Other Array Functions
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他数组函数
- en: 'We’ve discussed some built-in functions for working with arrays in this chapter,
    but PHP has many more. Other useful functions that apply to arrays include the
    following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已讨论了处理数组的一些内置函数，但 PHP 还有许多其他函数。适用于数组的其他有用函数包括：
- en: sort()   Sorts an array’s values in ascending order (alphabetical for string
    values, numerical order for number values)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: sort()   将数组的值按升序排列（对于字符串值按字母顺序，对于数字值按数字顺序）
- en: usort()   Sorts the values into a custom order based on a user-defined function
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: usort()   根据用户定义的函数将值排序为自定义顺序
- en: array_flip()   Swaps the keys and values for each array element
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: array_flip()   交换数组元素的键和值
- en: array_slice()   Returns a new array containing a subsequence of elements from
    an existing array
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: array_slice()   返回一个包含现有数组子序列的新数组
- en: array_walk()   Calls a user-defined function on each element of an array
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: array_walk()   对数组的每个元素调用用户定义的函数
- en: array_map()   Calls a user-defined function on each element of an array and
    returns a new array of the results
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: array_map()   对数组的每个元素调用用户定义的函数，并返回一个包含结果的新数组
- en: array_rand()   Returns random keys from an array
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: array_rand()   返回数组中的随机键
- en: For a full list of array functions, see the PHP documentation at *[https://www.php.net/manual/en/ref.array.php](https://www.php.net/manual/en/ref.array.php)*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的数组函数列表，请参阅 PHP 文档中的 *[https://www.php.net/manual/en/ref.array.php](https://www.php.net/manual/en/ref.array.php)*。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve begun exploring arrays, a compound data type that stores
    multiple values under a single variable name, with each value having its own identifying
    key. For now, we’ve focused on simple arrays, whose keys are integers. The chapter
    introduced various techniques for adding, subtracting, and accessing array elements,
    as well as functions for obtaining information about an array, such as count()
    and isset(). You also learned how to work with each array element in sequence
    by using a foreach loop. In some cases, PHP provides built-in functions for handling
    common array tasks, such as the implode() function that joins all the elements
    of an array into a single string. These functions sometimes allow you to replace
    complete loops and conditional statements with a single function call.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们开始探索数组，这是一种复合数据类型，它在单一的变量名下存储多个值，每个值都有自己的标识键。目前，我们主要关注简单数组，它们的键是整数。本章介绍了多种技术，用于添加、删除和访问数组元素，以及获取数组信息的函数，如
    `count()` 和 `isset()`。你还学会了如何通过使用 `foreach` 循环依次处理每个数组元素。在某些情况下，PHP 提供了内置函数来处理常见的数组任务，例如
    `implode()` 函数，它将数组中的所有元素连接成一个字符串。这些函数有时可以让你用一个函数调用替代整个循环和条件语句。
- en: Exercises
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 1.   Create a $colors array containing the string names of five colors. Print
    a random color from the array.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   创建一个 `$colors` 数组，其中包含五种颜色的字符串名称。打印数组中的随机颜色。
- en: 'Hint: You can get a valid random key by calling array_rand($colors).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你可以通过调用 `array_rand($colors)` 获取一个有效的随机键。
- en: '2.   Write a foreach loop to print each of the colors from your array in Exercise
    1 on a new line, in the following form:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   写一个 `foreach` 循环，在新的一行中打印出练习 1 中数组的每个颜色，格式如下：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 3.   Use array_pop() to print the last element of your array of colors from
    Exercise 1\. Then use var_dump() to show that this item has been removed from
    the array.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   使用 `array_pop()` 打印练习 1 中颜色数组的最后一个元素。然后使用 `var_dump()` 显示该元素已经从数组中移除。
- en: 4.   Create an array containing integer ages 23, 31, and 55. Use built-in functions
    to calculate and print out the number of items in the array and their average.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   创建一个包含整数年龄 23、31 和 55 的数组。使用内置函数计算并打印数组中项的数量及其平均值。
