- en: '**12'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SYSTEM MONITORING**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Monitoring often comes with a negative connotation because it suggests that
    data is collected for surveillance by something or somebody. However, many digital
    business models like predictive maintenance wouldn’t work without monitoring and
    subsequent data analytics. In the same way, the continuous protection of devices
    requires data logging and analysis to detect and trace back malicious activities.
  prefs: []
  type: TYPE_NORMAL
- en: The creation of extensive logfiles in IT systems has been common for decades.
    However, when it comes to embedded systems, logs might not receive the attention
    they deserve. In the past, low storage capacities and missing internet connections
    were legitimate reasons for putting system monitoring in second place, but luckily,
    these days, those limitations have continued to decrease.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I explain the benefits of monitoring devices for security reasons.
    In addition, I discuss resource limitations on embedded systems and multiple aspects
    of logging processes and their management. To wrap everything up, the book’s final
    case study looks at available log data on an STM32MP157F device and how to analyze
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Monitoring for the Right Reasons**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many companies have been accused of being “data krakens” because they collect
    all the data they can lay their hands on, whether from web services, IT infrastructures,
    or end-user devices. For them, this collection leads to profitable business models,
    but this development obviously contradicts privacy efforts to protect humans from
    tracking, surveillance, and spying.
  prefs: []
  type: TYPE_NORMAL
- en: On the legal side, the European GDPR is an example of counteracting excessive
    data collection, but other legal requirements—such as UN Regulation 155 in the
    automotive sector, IEC 62443-4-2 for the industrial automation industry, and the
    Critical Infrastructure Protection (CIP) standard CIP-007-6 of the North American
    Electric Reliability Corporation (NERC)—explicitly require security monitoring
    of connected products, either by manufacturers or operators. In a nutshell, be
    aware that the two sides of the data collection and monitoring coin always have
    to be balanced carefully.
  prefs: []
  type: TYPE_NORMAL
- en: In some areas, monitoring has been common practice for a long time; for example,
    surveillance cameras and security staff keep an eye on the physical security threats
    of buildings and corporate sites. The banking sector has a long tradition of monitoring
    transactions and reacting to unusual activities. Last but not least, network traffic
    monitoring by firewalls and intrusion detection systems is part of every sane
    IT infrastructure. Collecting data and monitoring systems in the name of security
    is clearly often acceptable, but it always must stay within reasonable bounds.
  prefs: []
  type: TYPE_NORMAL
- en: System monitoring has various advantages for device security. Log data can be
    especially useful in two cases. First, every attack on your device runs through
    multiple phases including reconnaissance, delivery, exploitation, installation,
    command and control, and actions on objectives. Each phase might leave traces
    in the device’s logfiles that enable you to detect the attack early, react accordingly,
    and thereby avert further damage. Second, log data can be an immensely valuable
    source during forensic processes after an incident happened. Imagine that your
    devices were attacked in the field, but you don’t have any data to reconstruct
    and understand what happened. Being blind in such a situation not only leaves
    you clueless but also can be a significant risk for your business.
  prefs: []
  type: TYPE_NORMAL
- en: In general, device monitoring raises transparency throughout your device population
    in the field and gives you an overview of when, where, and how your products are
    used. In critical infrastructures, such monitoring might even be necessary to
    fulfill legal or certification requirements. Also, as mentioned in [Chapter 9](ch09.xhtml#ch09),
    knowing the state of firmware versions deployed on your devices in the field can
    be helpful in understanding the threat landscape of your customers.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the pure security use cases, monitoring can even be a supporting tool
    for handling and analyzing customer complaints. Log data might, for example, prove
    that an end user performed manual configuration changes that led to unauthorized
    operation modes, which overstressed mechanical components and caused a machine
    to break.
  prefs: []
  type: TYPE_NORMAL
- en: '**Monitoring the Right Things**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Embedded systems running Linux, communicating with a variety of services, and
    interacting with sensors and actuators have reached a complexity that doesn’t
    allow for recording the whole device state at any given point in time. The only
    option is *selective monitoring* of system properties and events.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Logging system data is a double-edged sword. It might be of great use to your
    service engineers during troubleshooting, but if your log contains usernames,
    passwords, and other sensitive data, attackers might very much appreciate the
    information free of charge.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***User Interactions and Access Control***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A good starting point is to monitor events that are related to user interaction
    and access control.
  prefs: []
  type: TYPE_NORMAL
- en: '**User Sessions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If humans log in to a device, they don’t do it without intention, whether authorized
    or malicious. Knowing the user login history and being able to match it with real-world
    activities of a certain human might reveal that an account was misused. For example,
    the person corresponding to a virtual user could have been on vacation and therefore
    clearly not acting.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, a high number of failed login attempts can indicate that a brute-force
    attack has been performed. Finally, the time and date information of user sessions
    might help in reconstructing an attack’s timeline.
  prefs: []
  type: TYPE_NORMAL
- en: '**Access-Control Violations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As described in [Chapter 11](ch11.xhtml#ch11), users and processes should be
    restricted to the minimum permissions necessary to fulfill their tasks. Besides
    the positive effect of access restrictions at runtime, those measures can also
    yield valuable information about which user or process *tried* to access a forbidden
    resource, which might help detect attacks in an early phase.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filesystem Activities**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Temporary files that appear suddenly and permanent changes to configuration
    or system files can indicate malicious activities. They could be initiated by
    processes running on the device, possibly because they’ve been compromised by
    exploitation of an unknown vulnerability. But a human user also could be the origin
    of manipulation, which could hint at an insider attack. Monitoring at least a
    subset of critical files and their events can be valuable in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Removable Media**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Sometimes just plugging a USB thumb drive or a memory card into a device can
    trigger an attack. If your product offers such features, it absolutely makes sense
    to log information about when such media was plugged in or removed and maybe even
    which identifiers it had.
  prefs: []
  type: TYPE_NORMAL
- en: '***Communication***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although monitoring all data running on all communication channels of a device
    is usually not possible because of the vast amount of data transmitted, certain
    metadata or specific sent or received information can provide valuable insights.
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Communication**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Communication data received from external sources as well as data your device
    sends can yield hints of malicious activities. For example, a high amount of traffic
    from certain IP addresses might represent targeted DoS attacks. Nonstandard packets
    of communication protocols can represent adversaries testing your device’s reactions
    upon manipulated requests.
  prefs: []
  type: TYPE_NORMAL
- en: New connections from your device to unknown locations and IP addresses or an
    unexpected, increased amount of outbound network traffic also might indicate that
    the device is already compromised.
  prefs: []
  type: TYPE_NORMAL
- en: '**Low-Level Communication**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In contrast to classic IT systems, an embedded system often has a variety of
    low-level interfaces like an I²C bus, serial connections, or general-purpose input/output
    (GPIO) pins. Their communication usually carries sensor or control data, which
    might again be a source for detecting unexpected behavior like forcing actuators
    into a dangerous operation mode.
  prefs: []
  type: TYPE_NORMAL
- en: Logging the state and communication data of these interfaces might not be a
    standard feature, but depending on their criticality, implementing it might be
    worth considering.
  prefs: []
  type: TYPE_NORMAL
- en: '***Application Behavior***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In contrast to looking at security monitoring from a user or communication interface
    perspective, considering an application-centric approach might make sense.
  prefs: []
  type: TYPE_NORMAL
- en: '**Service Activities**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some services provide interesting information about your device’s state, especially
    those with remote connections. For example, an SSH daemon that allows remote sessions
    may provide a history of login attempts with corresponding IP addresses and usernames.
  prefs: []
  type: TYPE_NORMAL
- en: A web server also is able to log the HTTP requests it receives, which can reveal
    adversarial activities on application layer communication.
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom Applications**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Proprietary software components that are, for example, relevant for your business
    model might provide deep insight into the use of your device. Therefore, it should
    be quite natural to integrate monitoring facilities into important applications
    you develop on your own.
  prefs: []
  type: TYPE_NORMAL
- en: '**Third-Party Applications**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Whenever you allow users to install applications developed by third parties
    on your device, you face common threats originating from untrustworthy software
    components. Besides strict access management for those programs, continuous monitoring
    of their behavior is a reasonable measure.
  prefs: []
  type: TYPE_NORMAL
- en: '***System Behavior***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Last but not least, the overall “health status” of your device may reveal attacks
    or at least unexpected behavior you can analyze further.
  prefs: []
  type: TYPE_NORMAL
- en: '**System Utilization**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Typical system utilization values, such as CPU load and memory consumption,
    are usually known by developers and maintenance staff. A device that shows unexpectedly
    high values can indicate additional software running on the device—for example,
    a crypto miner or backdoor service installed by attackers. But it might also just
    be a side effect of an attack targeting low-level or network interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '**Process and System Crashes**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Do your device’s processes crash from time to time? I hope not, but maybe they
    do only in rare cases that you didn’t cover during testing. If single processes
    or even the whole system crashes multiple times, it might be due to an attacker
    probing your device for potential vulnerabilities. If it’s detected and analyzed
    early enough, you might be able to take action and prevent further damage.
  prefs: []
  type: TYPE_NORMAL
- en: '**Errors and Warnings**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Although error messages and warnings can be part of perfectly normal device
    behavior, they can also be evidence that an adversary is tampering with a device’s
    services or configuration options during a reconnaissance phase.
  prefs: []
  type: TYPE_NORMAL
- en: '***Risk-Based Monitoring***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Which monitoring measures are reasonable for your product should be decided
    on the basis of your device’s threat and risk analysis, as described in [Chapter
    1](ch01.xhtml#ch01). For example, if you discovered that high network loads are
    a risk for your device’s real-time operations, monitoring network communication
    and system utilization is a good idea. If your device allows for running third-party
    Docker containers, monitoring the activities of those potentially dangerous software
    bundles should be on your list. And if your device has a web interface for configuration
    purposes, logging web server events becomes a necessity.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Many more sources of valuable information might exist for security monitoring
    that are specific to your device. Find them and use them to secure your device.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Designing a Monitoring Scheme**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While system monitoring is not new for IT systems, implementing it efficiently
    is always a challenge—especially when it comes to logging events and processes
    on embedded systems. Depending on the capabilities of a specific product and the
    requirements for its use, a trade-off between on-device and server-based processing
    must be found.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-1](ch12.xhtml#ch12fig01) shows a generic data-flow architecture
    of log data, starting with its collection, local storage, and eventual on-device
    analysis. While constrained devices will keep this part rather lean, stronger
    devices might aggregate more data and already perform on-device analysis to maximize
    potential insights.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/12fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: A generic logging architecture*'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, networked devices transmit at least part of the collected information
    to a remote server, whether on the local network or on the internet. This not
    only allows for storing larger amounts of log data but also enables performance-intensive
    data analytics for single devices and across whole device populations. The latter
    especially leads to significantly increased quality of security monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: '***Challenges for Embedded Systems***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When it comes to (I)IoT scenarios with rather constrained devices and possibly
    pretty large populations, the specific design of the monitoring process faces
    several challenges.
  prefs: []
  type: TYPE_NORMAL
- en: '**Limited Resources**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Embedded systems can be limited in several dimensions, which leaves developers
    with the difficulty of determining the amount of resources to use for monitoring.
    Some devices are battery powered, and collection (let alone transmission) of log
    data would be a further burden on battery life. For products based on small microcontrollers,
    log data collection isn’t possible from a performance perspective because there’s
    simply no time left for such tasks. Some systems have limited storage space and
    store only small amounts of log data, while others don’t have the high-bandwidth
    network connection necessary for transferring monitoring data to central servers.
    Some devices have all these limitations.
  prefs: []
  type: TYPE_NORMAL
- en: For existing products, which are optimized to their single, dedicated task,
    it’s often difficult or nearly impossible to integrate security monitoring as
    an add-on. But that shouldn’t be an excuse to discard all monitoring features.
    If you identify the need for security monitoring early in the development life
    cycle, you have a chance to reserve resources for this absolutely relevant purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronized Time Sources**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Correct timestamps are essential for correlating events within a device and
    with those of other devices and system components. For this purpose, time sources
    have to be synchronized, which can’t be taken for granted on embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: Support for synchronization protocols, like NTP, likely has to be enabled on
    purpose, and integrators who use your product as well as operators of these systems
    have to provide a suitable infrastructure, like master clocks and time servers
    within their networks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Secure Communication**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Secure transmission of monitoring data from a device to a central collection
    server comes with several prerequisites. The device has to be able to authenticate
    the central server; otherwise, it could be tricked into sending valuable data
    to unauthorized parties.
  prefs: []
  type: TYPE_NORMAL
- en: The server also has to be able to verify the identity of the device providing
    data, because fake devices could significantly disturb the monitoring process
    by sending manipulated data. In addition, the data transmission itself should
    be protected in all aspects of secure communication, as described in [Chapter
    7](ch07.xhtml#ch07).
  prefs: []
  type: TYPE_NORMAL
- en: '**Integrity-Protected Local Storage**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you decide to partly or even completely rely on device-side logging without
    external transmissions, you have to prepare for the question, “How do you actually
    guarantee that the log data wasn’t altered at some point?” This question might
    even be posed by legal entities or in a court of law, for example, if your device
    is part of a nation’s critical infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: System-integrity protection as described in [Chapter 8](ch08.xhtml#ch08) is
    a fundamental requirement for solid solutions regarding this challenge.
  prefs: []
  type: TYPE_NORMAL
- en: '**Confidentiality-Protected Local Storage**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As mentioned in the previous section, log data might be useful not only for
    debugging your device but also for attackers during their reconnaissance phase.
    Therefore, you can definitely regard logfiles as assets that need confidentiality
    protection.
  prefs: []
  type: TYPE_NORMAL
- en: Measures like encrypted filesystems, as explained in [Chapter 5](ch05.xhtml#ch05),
    can be a solution. Another option is the implementation of a hybrid encryption
    scheme using the public key of a central log server to encrypt a random local
    symmetric key, which is, in turn, used to encrypt the locally generated log data.
    In that case, only the remote server in possession of the corresponding private
    key would be able to decrypt and analyze the log information.
  prefs: []
  type: TYPE_NORMAL
- en: '***Monitoring of the On-Device Logging Process***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Continuous security monitoring can play a central role in the detection of attacks,
    timely reactions to incidents, and comprehensive forensic analysis after a compromise,
    which means the involved on-device logging processes are expected to function
    properly. However, it would be naive to assume that monitoring processes are robust
    by nature and immune to all sorts of influences. It’s important to install measures
    that check whether the involved logging procedures are working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: No matter whether the local log storage is only a few megabytes or some gigabytes,
    it is always finite. In some cases, it might be tempting to say that a certain
    memory can hold “more log events than a specific device could ever generate,”
    but keep in mind that logging behavior can change with future firmware versions,
    devices in industrial scenarios might operate for decades, and new features and
    content could significantly reduce storage capacities. Monitoring the log storage
    capacity is, therefore, a mandatory task. Also, you have to make a decision about
    how to react if storage space is exhausted, or even before that happens. For example,
    if possible, logs can be compressed and archived to a remote location, or the
    oldest events can be overwritten by new ones coming in.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to local storage-capacity issues, remote connections used to transmit
    log data also could be affected. You can easily imagine how the bandwidth of such
    communication could decrease abruptly or completely disconnect. In such cases,
    it’s the device’s responsibility to decide whether collected data is temporarily
    stored at a local destination until the connection is reestablished and the remote
    location is able to catch up again, or if monitoring data should be discarded
    at least partially or even completely.
  prefs: []
  type: TYPE_NORMAL
- en: Further, your logging applications could unpleasantly run into unknown bugs,
    or adversaries might attack your monitoring system on purpose. Both scenarios
    could result in crashes of critical system parts and leave you blind in terms
    of monitoring data. Even though your device can’t recover from all possible situations,
    automatically restarting monitoring services after crashes and locally logging
    events regarding the eventual loss of monitoring capabilities can be worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: '***Central Log Analysis and Management***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In many use cases, having a central storage location for monitoring data as
    well as the analysis and correlation of information from the whole device population
    is of great value. Among other advantages, this approach allows you to react to
    security-related events in the field within a short time frame. If an attacker
    is messing with critical configuration or system files, you might want to know
    that as soon as possible. This approach also enables you to include a long history
    of device log data into current analyses, and once the data has been transmitted,
    on-device manipulation or destruction of log information would become obvious.
  prefs: []
  type: TYPE_NORMAL
- en: However, implementing the second row of the logging architecture shown in [Figure
    12-1](ch12.xhtml#ch12fig01) is all but simple. One challenge in (I)IoT scenarios
    can be the scalability of the central monitoring system and the availability of
    corresponding analysis capacities. Of course, this depends on the size of your
    device populations. While a few thousand products might be manageable, scalability
    gains center stage when monitoring a six-digit number of devices or even more.
    This requires not only a vast amount of central storage capacities but also people
    and algorithms that sift through all the data to identify unexpected device behavior,
    emerging malicious activities, or indicators of compromise (IoCs).
  prefs: []
  type: TYPE_NORMAL
- en: Systems used for this purpose are often known as *security information and event
    management (SIEM)* because they collect event data relevant for security monitoring
    and provide a means to find the proverbial needle in the haystack. Examples of
    such analysis platforms, open source or commercial, include the Elastic Stack,
    Graylog, and Splunk, just to name a few. While big data analytics and artificial
    intelligence can provide strong support for this task, in many cases, judgment
    and eventual manual investigation by a human expert is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in [Chapter 1](ch01.xhtml#ch01), every secure product life cycle
    has to establish some kind of incident- and vulnerability-response processes.
    Make sure that the teams operating the SIEM system have a strong connection to
    the product development and management teams, which will enable you to gain efficiency
    in your incident and vulnerability handling.
  prefs: []
  type: TYPE_NORMAL
- en: With all the advantages of central monitoring systems and processes, don’t forget
    to critically assess which data you *really* need for your chosen monitoring approach.
    Piling up stacks of unnecessary data only makes your solution inefficient and
    could lead to conflicts with the European GDPR or similar laws, especially if
    your database contains personally identifiable information (PII).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re not familiar with the legal restrictions of PII collection, thoroughly
    acquaint yourself with that topic. Even rather “technical” data like IP and MAC
    addresses might be traced back to natural persons and, therefore, require special
    treatment or should not be collected at all.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case Study: Logging Events on an STM32MP157F Device**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This case study presents typical tools and configurations to extract monitoring
    data from a Linux-based embedded system like an STM32MP157F-DK2 board.
  prefs: []
  type: TYPE_NORMAL
- en: '***User-Session Monitoring with journald***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Linux systems that run `systemd`, like my STM32MP157F-DK2 firmware does, come
    with the `journald` tool, which collects valuable information about basic system
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Listing 12-1](ch12.xhtml#ch12list01) shows a series of log entries
    extracted from `journalctl` by using `grep logind`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-1: Typical* journald *entries for user sessions*'
  prefs: []
  type: TYPE_NORMAL
- en: The logs clearly show that the root user had two sessions on April 28 and that
    the local service user `lservice` was logged in for around 13 minutes on May 14\.
    If this doesn’t correlate with an official inspection by a technician from your
    company, it might be an indication of unauthorized access.
  prefs: []
  type: TYPE_NORMAL
- en: The `journald` daemon can run in several modes, two of which are *volatile*
    and *persistent*. While the first option stores journal data only until the system
    is rebooted, the second one makes `journald` store its log data under */var/log/
    journal* in a persistent way, which can be helpful for forensics. You can set
    the corresponding `Storage=persistent` option in its configuration file */etc/
    systemd/journald.conf*.
  prefs: []
  type: TYPE_NORMAL
- en: Further configuration parameters like `SystemMaxUse=` and `RuntimeMaxUse=` as
    well as `SystemKeepFree=` and `RuntimeKeepFree=` determine the limits of journal
    file sizes for on-disk and in-memory storage, respectively, so critical situations
    caused by too much memory consumption of logfiles can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: '***Kernel Event Monitoring with auditd***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Linux kernel provides an audit framework that collects information about
    potentially security-relevant events happening within the kernel. It’s the same
    framework that’s used by MAC systems like SELinux or AppArmor to watch and restrict
    access to system resources, as described in [Chapter 11](ch11.xhtml#ch11).
  prefs: []
  type: TYPE_NORMAL
- en: The `auditd` user-space tool builds upon this framework and enables the persistent
    storage of security events in a device’s nonvolatile memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installation**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you successfully installed AppArmor or another popular MAC system on your
    device, the audit framework is probably already up and running. Otherwise, you
    can set `CONFIG_AUDIT=y` within your Linux kernel’s configuration to enable it.
  prefs: []
  type: TYPE_NORMAL
- en: The `meta-oe` layer for Yocto contains the recipe to install the `auditd` tool
    from *meta-oe/recipes-security/audit*. It can be simply added to your image by
    setting `IMAGE_INSTALL += "auditd"`. After booting your system with the newly
    installed software, you should see that your system now contains the */var/ log/audit/audit.log*
    file, which is the default place to persistently store kernel audit data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Customization**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The audit framework is a powerful tool with deep access to system processes,
    so it’s important to explicitly specify the kind of events you want to monitor.
    You can use `auditctl` to add watch rules to a running `auditd` service, as shown
    in [Listing 12-2](ch12.xhtml#ch12list02).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-2: Adding audit rules with* auditctl'
  prefs: []
  type: TYPE_NORMAL
- en: The `-D` parameter removes all currently active rules. The second command in
    [Listing 12-2](ch12.xhtml#ch12list02) installs a rule that monitors the */etc/passwd*
    file (`-w /etc/ passwd`) for read (`r`) and write (`w`) access as well as file
    attribute changes (`a`). The `-k` option allows for adding an arbitrary key string
    that gives the rule a certain meaning and accelerates log searching at a later
    time.
  prefs: []
  type: TYPE_NORMAL
- en: However, the rules set by `auditctl` are available only until the system performs
    a reboot. To install watch rules persistently, you have to add them to the */etc/audit/audit.rules*
    file. As shown in [Listing 12-3](ch12.xhtml#ch12list03), the rules in this file
    are actually equal to the command line calls to `auditctl`, just without the tool
    name at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-3: An example of persistent audit rules*'
  prefs: []
  type: TYPE_NORMAL
- en: File-access monitoring can be useful in a variety of scenarios. For example,
    if you enable SSH access to your device based on the popular `dropbear` daemon,
    it might be reasonable to watch for changes of the corresponding configuration
    file, which—if manipulated—could potentially open a backdoor to your device. Further,
    access to */etc/passwd* and */etc/shadow* are common indicators for malicious
    activities. Advanced attackers might also target the audit system itself, which
    makes the files containing audit rules and the audit tools valid targets to watch.
  prefs: []
  type: TYPE_NORMAL
- en: After enabling the rules, you can use the `ausearch` tool to filter audit data,
    as demonstrated in [Listing 12-4](ch12.xhtml#ch12list04) for the installed SSH
    configuration watch rules.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-4: Using* ausearch *to find suspicious activities*'
  prefs: []
  type: TYPE_NORMAL
- en: The first call to `ausearch` with the `ssh_config` key reports that a new rule
    with this key was added by the `auditctl` tool. Afterward, I just touched (didn’t
    even manipulate) the configuration file located at */etc/default/dropbear*. The
    second call to `ausearch` clearly states that the root user (`uid=0 gid=0`) used
    the `touch` tool to access the file */etc/default/dropbear* while being in the
    */home/ root* directory only 12 minutes after the new rule was loaded. This example
    shows the beneficial strengths of having monitoring data available for critical
    system files.
  prefs: []
  type: TYPE_NORMAL
- en: Besides watching file access, `auditd` is also able to intercept syscalls. However,
    since such rules directly affect performance, you should use them only if you
    consider them absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '***Service and Application Event Logging***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While `auditd` provides powerful services to monitor kernel behavior and to
    log accesses to system resources, it doesn’t capture an important part of your
    device: specific events generated by services and applications.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logging Application Events with syslog**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Within my STM32MP157F firmware, BusyBox implements a minimal version of `syslogd`
    that some applications use to store log information in the */var/log/messages*
    file. One example for such an application is the lightweight `dropbear` SSH daemon.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-5](ch12.xhtml#ch12list05) shows corresponding log messages after
    several SSH login attempts.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-5: SSH login attempts logged by* syslogd'
  prefs: []
  type: TYPE_NORMAL
- en: The log data first shows a `Bad PAM password attempt` ➊ for the user `rservice`,
    shortly followed by a successful `PAM password auth` ➋ for the same user. The
    established session is closed only 10 seconds later ➌. Further, three failed login
    attempts for the root user can be seen that finally make the SSH daemon quit the
    login process ➍. Such log data can be extremely useful for detecting brute-force
    attacks on SSH accounts or login attempts for unusual users and from unexpected
    IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Application-Specific Logfiles**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some applications do not rely on `syslogd`’s services by default, but rather
    create and manage their own logfiles. One example is the `apache2` web server
    running on my STM32MP157F-DK2 board. Its logfiles *access_log* and *error_log*
    can be found under */var/log/apache2/*. [Listing 12-6](ch12.xhtml#ch12list06)
    shows sample HTTP requests from the IP address 192.168.13.17.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-6: Sample access log entries from* apache2'
  prefs: []
  type: TYPE_NORMAL
- en: This information provides not only the history of successfully delivered web
    pages by the web server but also requests that might reveal adversarial activities
    typical for the reconnaissance phase. Here, an attacker checked the availability
    of the */admin/*, */config/*, and */cgi-bin/* subdirectories. Again, early detection
    can prevent later attacks and damages.
  prefs: []
  type: TYPE_NORMAL
- en: '***Logging to a Remote Server***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All the previously mentioned tools operate locally on a device, which might
    be sufficient for device-specific forensic purposes whenever you have physical
    or remote access to it. However, as suggested earlier in this chapter, the central
    collection of log data can be beneficial in many ways. Although the setup of a
    central monitoring infrastructure goes beyond the device-centered focus of this
    book, I would like to point out that all the data collected by these tools can
    be transmitted to remote locations.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `journald` daemon can be extended by a service called `systemd-journal-remote`
    for logging data to a remote server. The `audisp` tool and its `audisp-remote`
    plug-in can enable central log aggregation for data collected by the Linux audit
    framework and `auditd`. Alternatively, specific tools like `auditbeat` can be
    used to send audit data to an Elastic Stack, for example. Further, `rsyslog` and
    `syslog-ng` are modern `syslog` implementations that allow for logging to remote
    locations. Finally, some of these tools are even interoperable, which means that
    `journald`, for example, can be configured to forward log data to a `syslog` daemon,
    which in turn can take care of remote transmission.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s simple to request that a device should aggregate and transmit system data
    and event information to a central server. However, when you start implementing
    such measures, you’ll encounter several obstacles to overcome, from legal issues
    to device constraints to the human resources necessary for continuously operating
    security-monitoring services.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I discussed typical information that can be useful for security
    monitoring of embedded systems, from user sessions and their interactions to network
    traffic metadata to system crashes and error messages. Clearly, the more you want
    to monitor, the more on-device and server resources you need. A risk-based approach
    is absolutely reasonable to find a compromise between full device transparency
    and minimal resource usage for your specific product.
  prefs: []
  type: TYPE_NORMAL
- en: System monitoring is an essential layer within your defense-in-depth strategy
    because even if all the protection measures you implement fail, monitoring might
    enable you to detect ongoing attacks and anomalies. Monitoring can make the difference
    between getting away with a black eye and ruining your product’s and your company’s
    reputation.
  prefs: []
  type: TYPE_NORMAL
