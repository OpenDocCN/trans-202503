- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Unix Domain Sockets
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Unix域套接字
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: So far in this book, we’ve discussed communications between nodes on a network.
    But not all network programming occurs exclusively between separate nodes. Your
    applications may sometimes need to communicate with services, such as a database,
    hosted on the same node.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经讨论了网络节点之间的通信。但并非所有网络编程都专门在不同节点之间进行。您的应用程序有时可能需要与在同一节点上托管的服务（例如数据库）进行通信。
- en: 'One way to connect your application to a database running on the same system
    would be to send data to the node’s IP address or localhost address—commonly 127.0.0.1—and
    the database’s port number. However, there’s another way: using Unix domain sockets.
    The *Unix domain socket* is a communication method that uses the filesystem to
    determine a packet’s destination address, allowing services running on the same
    node to exchange data with one another, a process known as *inter-process communication
    (IPC)*.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序连接到在同一系统上运行的数据库的一种方法是将数据发送到节点的IP地址或本地主机地址（通常为127.0.0.1）以及数据库的端口号。但是，还有另一种方法：使用Unix域套接字。Unix域套接字是一种使用文件系统确定数据包目的地地址的通信方法，允许在同一节点上运行的服务之间交换数据，这个过程称为进程间通信（IPC）。
- en: This chapter first defines exactly what Unix domain sockets are and how you
    can control read and write access to them. Next, you’ll explore the three types
    of Unix domain sockets available through Go’s `net` package and write a simple
    echo server in each of them. Finally, you’ll write a service that uses Unix domain
    sockets to authenticate clients based on their user and group ID information.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先精确定义了Unix域套接字是什么，以及如何控制对它们的读写访问。接下来，您将通过Go的`net`包探索三种Unix域套接字的类型，并在每种类型中编写一个简单的回显服务器。最后，您将编写一个使用Unix域套接字的服务，根据客户端的用户和组ID信息进行身份验证。
- en: What Are Unix Domain Sockets?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Unix域套接字？
- en: In Chapter 2, I defined a network socket as an IP address and port number. Socket
    addressing allows individual services on the same node, at the same IP address,
    to listen for incoming traffic. To illustrate the importance of socket addressing,
    just imagine how inefficient having a single phone line at a large corporation
    would be. If you wanted to speak to someone, you’d best hope the phone wasn’t
    already in use. That’s why, to alleviate the congestion, most corporations assign
    an extension number to each employee. This allows you to contact the person you
    want to speak to by dialing the company’s phone number (which is like the node’s
    IP address) followed by the employee’s extension (which is like the port number).
    Just as phone numbers and extensions allow you to individually call every single
    person at a corporation, the IP address and port number of a socket address allow
    you to communicate with every single service listening to each socket address
    on a node.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，我将网络套接字定义为IP地址和端口号。套接字定址允许同一节点上的各个服务监听传入的流量。为了说明套接字定址的重要性，想象一下在大公司只有一条电话线的低效率。如果您想要与某人交谈，最好希望电话没有被占线。这就是为什么为了缓解拥塞，大多数公司为每个员工分配一个分机号。这使您可以通过拨打公司的电话号码（类似于节点的IP地址）后接员工的分机号（类似于端口号）来联系您想要交谈的人。正如电话号码和分机号允许您单独呼叫公司中的每个人一样，套接字地址的IP地址和端口号允许您与节点上每个套接字地址监听的每个服务通信。
- en: '*Unix domain sockets* apply the socket-addressing principle to the filesystem:
    each Unix domain socket has an associated file on the filesystem, which corresponds
    to a network socket’s IP address and port number. You can communicate with a service
    listening to the socket by reading from and writing to this file. Likewise, you
    can leverage the filesystem’s ownership and permissions to control read and write
    access to the socket. Unix domain sockets increase efficiency by bypassing the
    operating system’s network stack, eliminating the overhead of traffic routing.
    For the same reasons, you won’t need to worry about fragmentation or packet ordering
    when using Unix domain sockets. If you choose to forgo Unix domain sockets and
    exclusively use network sockets when communicating with local services (for example,
    to connect your application to a local database, a memory cache, and so on), you
    ignore significant security advantages and performance gains.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*Unix域套接字*将套接字寻址原理应用于文件系统：每个Unix域套接字在文件系统上都有一个关联的文件，该文件对应于网络套接字的IP地址和端口号。你可以通过读取和写入这个文件与监听该套接字的服务进行通信。同样，你可以利用文件系统的所有权和权限来控制对该套接字的读写访问。Unix域套接字通过绕过操作系统的网络栈来提高效率，消除了流量路由的开销。出于同样的原因，在使用Unix域套接字时，你不需要担心分片或数据包排序问题。如果你选择放弃Unix域套接字，专门使用网络套接字与本地服务进行通信（例如，将应用程序连接到本地数据库、内存缓存等），你将忽视显著的安全优势和性能提升。'
- en: 'Though this system brings distinct advantages, it comes with a caveat: Unix
    domain sockets are local to the node using them, so you cannot use them to communicate
    with other nodes, as you can with network sockets. Therefore, Unix domain sockets
    may not be a good fit if you anticipate moving a service to another node or require
    maximum portability for your application. To maintain communication, you’d have
    to first migrate to a network socket.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一系统带来了明显的优势，但它也有一个警告：Unix域套接字仅限于使用它们的节点，因此你不能像使用网络套接字那样与其他节点进行通信。因此，如果你预见到将服务迁移到其他节点，或者需要最大程度的应用程序可移植性，Unix域套接字可能并不适合你。为了保持通信，你必须首先迁移到网络套接字。
- en: Binding to Unix Domain Socket Files
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定到Unix域套接字文件
- en: A Unix domain socket file is created when your code attempts to bind to an unused
    Unix domain socket address by using the `net.Listen`, `net.ListenUnix`, or `net.ListenPacket`
    functions. If the socket file for that address already exists, the operating system
    will return an error indicating that the address is in use. In most cases, simply
    removing the existing Unix domain socket file is enough to clear up the error.
    However, you should first make sure that the socket file exists not because a
    process is currently using that address but because you didn’t properly clean
    up the file from a defunct process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码尝试通过使用`net.Listen`、`net.ListenUnix`或`net.ListenPacket`函数绑定到一个未使用的Unix域套接字地址时，将会创建一个Unix域套接字文件。如果该地址的套接字文件已经存在，操作系统会返回一个错误，指示该地址正在使用。大多数情况下，简单地删除现有的Unix域套接字文件就足以解决错误。然而，你应首先确保套接字文件存在，并非因为某个进程正在使用该地址，而是因为你没有正确清理来自一个已经终止的进程的文件。
- en: If you wish to reuse a socket file, use the `net` package’s `FileListener` function
    to bind to an existing socket file. This function is beyond the scope of this
    book, but I encourage you to read its documentation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望重用一个套接字文件，可以使用`net`包的`FileListener`函数来绑定到一个已存在的套接字文件。这个函数超出了本书的范围，但我鼓励你阅读它的文档。
- en: Changing a Socket File’s Ownership and Permissions
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改套接字文件的所有权和权限
- en: Once a service binds to the socket file, you can use Go’s `os` package to modify
    the file’s ownership and read/write permissions. Specifically, the `os.Chown`
    function allows you to modify the user and group that owns the file. Windows does
    not support this function, though this function is supported on Windows Subsystem
    for Linux (WSL), Linux, and macOS, among others outside the scope of this book.
    We’ll look at the lines of code that change file ownership and permissions now
    but cover them in context later in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务绑定到套接字文件，你可以使用Go的`os`包修改文件的所有权和读写权限。具体来说，`os.Chown`函数允许你修改文件的用户和组所有者。Windows不支持此函数，但在Windows
    Subsystem for Linux（WSL）、Linux、macOS等平台上支持此函数，这些都超出了本书的范围。我们现在将查看更改文件所有权和权限的代码行，但将在本章稍后在上下文中进行讲解。
- en: 'The following line instructs the operating system to update the user and group
    ownership of the given file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令指示操作系统更新给定文件的用户和组所有权：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `os.Chown` function accepts three arguments: the path to a file, the user
    ID of the owner 1, and the group ID of the owner 2. A user or group ID of `-1`
    tells Go you want to maintain the current user or group ID. In this example, you
    want to maintain the socket file’s current user ID but set its group ID to 100,
    which here is assumed to be a valid group ID in the */etc/group* file.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.Chown` 函数接受三个参数：文件路径、所有者的用户 ID 和所有者的组 ID。如果用户或组 ID 为 `-1`，则告诉 Go 保持当前的用户或组
    ID。在此示例中，你希望保持套接字文件的当前用户 ID，但将其组 ID 设置为 100，这里假定它是 */etc/group* 文件中的有效组 ID。'
- en: 'Go’s `os/user` package includes functions to help you translate between user
    and group names and IDs. For example, this line of code uses the `LookupGroup`
    function to find the group ID for the *users* group:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的 `os/user` 包包含帮助你在用户和组名称与 ID 之间进行转换的函数。例如，这行代码使用 `LookupGroup` 函数查找 *users*
    组的组 ID：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Provided `user.LookupGroup` did not return an error, the `grp` variable’s `Gid`
    field contains the group ID for the *users* group.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的 `user.LookupGroup` 没有返回错误，`grp` 变量的 `Gid` 字段将包含 *users* 组的组 ID。
- en: 'The `os.Chmod` function changes the file’s mode and the numeric notation of
    Unix-compatible permission bits. These bits inform the operating system of the
    file’s mode, the file’s user read/write/execute permissions, the file’s group
    read/write/execute permissions, and the read/write/execute permissions for any
    user not in the file’s group:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.Chmod` 函数更改文件的模式以及 Unix 兼容的权限位的数字表示法。这些权限位通知操作系统文件的模式、文件的用户读/写/执行权限、文件的组读/写/执行权限，以及对于任何不在文件组中的用户的读/写/执行权限：'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `os.Chmod` function accepts a file path and an `os.FileMode`, which represents
    the file mode, the user permissions, the group permissions, and non-group user
    permissions. Since you’re dealing with a socket file, you should always set the
    `os.ModeSocket` mode on the file. You do that using a bitwise OR between the `os.ModeSocket`
    and the numeric file permission notation. Here, you’re passing the octal `0660`,
    which gives the user and group read and write access but prevents anyone outside
    the group from reading or writing to the socket. You can read more about `os.FileMode`
    in Go’s documentation at [https://golang.org/pkg/os/#FileMode](https://golang.org/pkg/os/#FileMode)
    and familiarize yourself with filesystem permissions numeric notation at [https://en.wikipedia.org/wiki/File_system_permissions#Numeric_notation](https://en.wikipedia.org/wiki/File_system_permissions#Numeric_notation).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.Chmod` 函数接受一个文件路径和一个 `os.FileMode`，后者表示文件模式、用户权限、组权限和非组用户权限。由于你正在处理一个套接字文件，应该始终在文件上设置
    `os.ModeSocket` 模式。你可以通过 `os.ModeSocket` 与数字文件权限符号之间的按位或操作来做到这一点。在这里，你传递的是八进制的
    `0660`，这意味着用户和组有读写权限，但阻止组外的任何人读取或写入套接字。你可以在 Go 的文档中阅读更多关于 `os.FileMode` 的内容，访问
    [https://golang.org/pkg/os/#FileMode](https://golang.org/pkg/os/#FileMode)，并在
    [https://en.wikipedia.org/wiki/File_system_permissions#Numeric_notation](https://en.wikipedia.org/wiki/File_system_permissions#Numeric_notation)
    上熟悉文件系统权限的数字表示法。'
- en: Understanding Unix Domain Socket Types
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 Unix 域套接字类型
- en: 'There are three types of Unix domain sockets: *streaming sockets*, which operate
    like TCP; *datagram sockets*, which operate like UDP; and *sequence packet sockets*,
    which combine elements of both. Go designates these types as `unix`, `unixgram`,
    and`unixpacket`, respectively. In this section, we’ll write echo servers that
    work with each of these types.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 域套接字有三种类型：*流套接字*，其工作方式类似于 TCP；*数据报套接字*，其工作方式类似于 UDP；以及 *序列数据包套接字*，其结合了前两者的特点。Go
    分别将这些类型指定为 `unix`、`unixgram` 和 `unixpacket`。在本节中，我们将编写与每种类型配合使用的回显服务器。
- en: The `net.Conn` interface allows you to write code once and use it across multiple
    network types. It abstracts many of the differences between the network sockets
    used by TCP and UDP and Unix domain sockets, which means that you can take code
    written for communication over TCP, for example, and use it over a Unix domain
    socket by simply changing the address and network type.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.Conn` 接口允许你一次编写代码并在多种网络类型中使用它。它抽象了 TCP、UDP 和 Unix 域套接字所使用的网络套接字之间的许多差异，这意味着你可以将为
    TCP 通信编写的代码拿来直接用于 Unix 域套接字，只需更改地址和网络类型即可。'
- en: The unix Streaming Socket
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Unix 流套接字
- en: The streaming Unix domain socket works like TCP without the overhead associated
    with TCP’s acknowledgments, checksums, flow control, and so on. The operating
    system is responsible for implementing the streaming inter-process communication
    over Unix domain sockets in lieu of TCP.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 流式Unix域套接字的工作原理类似于TCP，但没有TCP的确认、校验和、流控制等开销。操作系统负责通过Unix域套接字实现流式进程间通信，代替了TCP。
- en: To illustrate this type of Unix domain socket, let’s write a function that creates
    a generic stream-based echo server ([Listing 7-1](#listing7-1)). You’ll be able
    to use this function with any streaming network type. That means you can use it
    to create a TCP connection to a different node, but you’ll also be able to use
    it with the `unix` type to communicate with a Unix socket address.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这种Unix域套接字，让我们编写一个函数来创建一个通用的基于流的回显服务器（[示例 7-1](#listing7-1)）。你将能够使用这个函数与任何流式网络类型一起使用。这意味着你可以用它来创建一个到不同节点的TCP连接，但你也可以将它与`unix`类型一起使用，来与Unix套接字地址通信。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 7-1: Creating the streaming echo server function (*echo.go*)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-1：创建流式回显服务器函数 (*echo.go*)
- en: The `streamingEchoServer` function 1 accepts a string representing a stream-based
    network and a string representing an address and returns an address object and
    an `error` interface. You should recognize these arguments and return types from
    earlier in the book.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`streamingEchoServer`函数1接受一个表示基于流的网络的字符串和一个表示地址的字符串，并返回一个地址对象和一个`error`接口。你应该从本书前面的内容中认识到这些参数和返回类型。'
- en: Since you’ve made the echo server a bit more generic by accepting a context,
    a network string, and an address string, you can pass it any stream-based network
    type, such as `tcp`, `unix`, or `unixpacket`. The address would then need to correspond
    to the network type. The context is used for signaling the server to close. If
    the network type is `tcp`, the address string must be an IP address and port combination,
    such as 127.0.0.1:80\. If the network type is `unix` or `unixpacket`, the address
    must be the path to a nonexistent file. The socket file will be created when the
    echo server binds to it 2. Then the server will start listening for incoming connections.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你通过接受上下文、网络字符串和地址字符串使回显服务器变得更加通用，你可以将任何基于流的网络类型传递给它，如`tcp`、`unix`或`unixpacket`。地址需要与网络类型相对应。上下文用于向服务器发出关闭信号。如果网络类型是`tcp`，地址字符串必须是IP地址和端口的组合，如127.0.0.1:80。如果网络类型是`unix`或`unixpacket`，地址必须是指向一个不存在文件的路径。套接字文件将在回显服务器绑定到该地址时创建2。然后服务器会开始监听传入的连接。
- en: '[Listing 7-2](#listing7-2) completes the streaming echo server implementation.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-2](#listing7-2) 完成了流式回显服务器的实现。'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 7-2: A stream-based echo server (*echo.go*)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-2：基于流的回显服务器 (*echo.go*)
- en: A listener created with either `net.Listen` or `net.ListenUnix` will automatically
    remove the socket file when the listener exits. You can modify this behavior with
    `net.UnixListener`’s `SetUnlinkOnClose` method, though the default is ideal for
    most use cases. Unix domain socket files created with `net.ListenPacket` won’t
    be automatically removed when the listener exits, as you’ll see a little later
    in this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`net.Listen`或`net.ListenUnix`创建的监听器在退出时会自动删除套接字文件。你可以通过`net.UnixListener`的`SetUnlinkOnClose`方法来修改这种行为，尽管默认行为对大多数使用案例来说是理想的。使用`net.ListenPacket`创建的Unix域套接字文件在监听器退出时不会自动删除，稍后在本章中你会看到这一点。
- en: As before, you spin off the echo server in its own goroutine so it can asynchronously
    accept connections. Once the server accepts a connection 2, you start a goroutine
    to echo incoming messages. Since you’re using the `net.Conn` interface, you can
    use its `Read`3 and `Write`4 methods to communicate with the client no matter
    whether the server is communicating over a network socket or a Unix domain socket.
    Once the caller cancels the context 1, the server closes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你将回显服务器放入自己的goroutine中，以便它能够异步接受连接。一旦服务器接受了连接2，你就会启动一个goroutine来回显接收到的消息。由于你使用的是`net.Conn`接口，你可以使用其`Read`3和`Write`4方法与客户端进行通信，无论服务器是通过网络套接字还是Unix域套接字进行通信。一旦调用者取消了上下文1，服务器就会关闭。
- en: '[Listing 7-3](#listing7-3) tests the streaming echo server over a Unix domain
    socket using the `unix` network type.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-3](#listing7-3) 测试了通过`unix`网络类型使用Unix域套接字的流式回显服务器。'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 7-3: Setting up an echo server test over a `unix` domain socket (*echo_test.go*)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-3：通过`unix`域套接字设置回显服务器测试 (*echo_test.go*)
- en: You create a subdirectory in your operating system’s temporary directory named
    *echo_unix*1 that will contain the echo server’s socket file. The deferred call
    to `os.RemoveAll` cleans up after the server 2 by removing your temporary subdirectory
    when the test completes. You pass a socket file named *#.sock*3, where *#* is
    the server’s process ID, saved in the temporary subdirectory (*/tmp/echo_unix/123.sock*)
    to the `streamingEchoServer` function. Finally, you make sure everyone has read
    and write access to the socket 4.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你在操作系统的临时目录中创建一个名为 *echo_unix*1 的子目录，该子目录将包含回显服务器的套接字文件。对 `os.RemoveAll` 的延迟调用会在测试完成时清理服务器
    2，通过删除临时子目录。你将一个名为 *#.sock*3 的套接字文件传递给 `streamingEchoServer` 函数，其中 *#* 是服务器的进程
    ID，保存于临时子目录（*/tmp/echo_unix/123.sock*）中。最后，你确保所有人都能对套接字具有读写权限 4。
- en: '[Listing 7-4](#listing7-4) makes a connection to the streaming echo server
    and sends a test.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-4](#listing7-4) 连接到流回显服务器并发送测试。'
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 7-4: Streaming data over a Unix domain socket (*echo_test.go*)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-4：通过 Unix 域套接字传输流数据 (*echo_test.go*)
- en: You dial the server by using the familiar `net.Dial` function. It accepts the
    `unix` network type and the server’s address, which is the full path to the Unix
    domain socket file 1.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过使用熟悉的 `net.Dial` 函数来拨号连接服务器。它接受 `unix` 网络类型和服务器地址，即 Unix 域套接字文件的完整路径 1。
- en: You write three ping messages to the echo server before reading the first response
    2. The reasoning for sending three separate pings will be clear when you explore
    the `unixpacket` type later in this chapter. When you read the first response
    3 with a buffer large enough to store the three messages you just sent, you receive
    all three ping messages 4 in a single read as the string `pingpingping`. Remember,
    a stream-based connection does not delineate messages. The onus is on you to determine
    where one message stops and another one starts when you read a series of bytes
    from the server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取第一个响应之前，你向回显服务器发送了三条 ping 消息 2。当你稍后在本章中探索 `unixpacket` 类型时，发送三条独立的 ping 消息的原因会变得很清楚。当你使用足够大的缓冲区读取第一个响应
    3 来存储刚刚发送的三条消息时，你会以字符串 `pingpingping` 的形式接收到所有三条 ping 消息 4。请记住，基于流的连接并不区分消息。你需要自己确定当从服务器读取一系列字节时，一条消息的结束和另一条消息的开始。
- en: The unixgram Datagram Socket
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: unixgram 数据报套接字
- en: Next let’s create an echo server that will communicate using datagram-based
    network types, such as `udp` and `unixgram`. Whether you’re communicating over
    UDP or a `unixgram` socket, the server you’ll write looks essentially the same.
    The difference is, you will need to clean up the socket file with a `unixgram`
    listener, as you’ll see in [Listing 7-5](#listing7-5).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个使用基于数据报的网络类型（如 `udp` 和 `unixgram`）进行通信的回显服务器。无论你是通过 UDP 还是 `unixgram`
    套接字进行通信，你编写的服务器基本上是相同的。不同之处在于，你需要使用 `unixgram` 监听器清理套接字文件，正如你将在[列表 7-5](#listing7-5)中看到的那样。
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 7-5: A datagram-based echo server (*echo.go*)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-5：基于数据报的回显服务器 (*echo.go*)
- en: You call `net.ListenPacket`1, which returns a `net.PacketConn`. As mentioned
    earlier in this chapter, since you don’t use `net.Listen` or `net.ListenUnix`
    to create the listener, Go won’t clean up the socket file for you when your server
    is done with it. You must make sure you remove the socket file yourself, 2 or
    subsequent attempts to bind to the existing socket file will fail.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你调用 `net.ListenPacket`1，它返回一个 `net.PacketConn`。如本章前面所述，由于你没有使用 `net.Listen`
    或 `net.ListenUnix` 创建监听器，Go 在服务器完成后不会为你清理套接字文件。你必须确保自己移除套接字文件 2，否则后续尝试绑定到现有套接字文件时会失败。
- en: Since the `unixgram` network type doesn’t work on Windows, [Listing 7-6](#listing7-6)
    uses a build constraint to make sure this code does not run on Windows and then
    imports the necessary packages.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `unixgram` 网络类型在 Windows 上无法工作，[列表 7-6](#listing7-6) 使用构建约束确保这段代码不会在 Windows
    上运行，并导入必要的包。
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 7-6: Building constraints and imports for macOS and Linux (*echo_posix_test.go*)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-6：适用于 macOS 和 Linux 的构建约束和导入 (*echo_posix_test.go*)
- en: The build constraint tells Go to include this code only if it’s running on a
    macOS or Linux operating system. Granted, Go supports other operating systems,
    many of which may offer `unixgram` support, that are outside the scope of this
    book. This build constraint does not take those other operating systems into account,
    and I encourage you to test this code on your target operating system.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 构建约束告诉 Go 仅在 macOS 或 Linux 操作系统上运行时包含这段代码。诚然，Go 支持其他操作系统，其中许多可能提供 `unixgram`
    支持，但这些操作系统超出了本书的范围。此构建约束没有考虑到这些其他操作系统，因此我鼓励你在目标操作系统上测试这段代码。
- en: With the build constraint in place, you can add the test in [Listing 7-7](#listing7-7).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置构建约束后，您可以在[清单 7-7](#listing7-7)中添加测试。
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 7-7: Instantiating the datagram-based echo server (*echo_posix_test.go*)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-7：实例化基于数据报的回显服务器（*echo_posix_test.go*）
- en: Just as with UDP connections, both the server and the client must bind to an
    address so they can send and receive datagrams. The server has its own socket
    file 1 that is separate from the client’s socket file in [Listing 7-8](#listing7-8).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 UDP 连接一样，服务器和客户端都必须绑定到一个地址，以便它们可以发送和接收数据报。服务器有自己的套接字文件 1，该文件与客户端在[清单 7-8](#listing7-8)中的套接字文件是分开的。
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 7-8: Instantiating the datagram-based client (*echo_posix_test.go*)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-8：实例化基于数据报的客户端（*echo_posix_test.go*）
- en: The call to `os.Remove` in [Listing 7-5](#listing7-5)’s `datagramEchoServer`
    function cleans up the socket file when the server closes. The client has some
    additional housecleaning, so you make the client clean up its own socket file
    1 when it’s done listening to it. Thankfully, this is taken care of for you by
    the call to `os.RemoveAll` to remove your temporary subdirectory in [Listing 7-7](#listing7-7).
    Otherwise, you would need to add a call to `os.Remove` to remove the client’s
    socket file in the `defer`2. Also, the server should be able to write to the client’s
    socket file as well as its own socket file, or the server won’t be able to reply
    to messages. In this example, you set very permissive permissions so all users
    can write to the socket 3.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 7-5](#listing7-5)的 `datagramEchoServer` 函数中调用 `os.Remove` 来清理服务器关闭时的套接字文件。客户端有一些额外的清理工作，因此当客户端完成监听后，您需要让客户端清理自己的套接字文件
    1。幸运的是，在[清单 7-7](#listing7-7)中通过调用 `os.RemoveAll` 来删除临时子目录，已经为您处理了这个问题。否则，您需要在
    `defer`2 中添加一个调用 `os.Remove` 来删除客户端的套接字文件。此外，服务器应该能够写入客户端的套接字文件以及它自己的套接字文件，否则服务器将无法回复消息。在这个例子中，您设置了非常宽松的权限，以便所有用户都可以写入套接字
    3。
- en: Now that the server and client are instantiated, [Listing 7-9](#listing7-9)
    tests the difference between a streaming echo server and a datagram echo server.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务器和客户端都已实例化，[清单 7-9](#listing7-9) 测试了流式回显服务器和数据报回显服务器之间的区别。
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 7-9: Using unixgram sockets to echo messages (*echo_posix_test.go*)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-9：使用 unixgram 套接字回显消息（*echo_posix_test.go*）
- en: You write three ping messages to the server 1 before reading the first datagram.
    You then perform three reads 2 with a buffer large enough to fit all three ping
    messages. As expected, `unixgram` sockets maintain the delineation between messages;
    you sent three messages and read three replies. Compare this to the `unix` socket
    type in Listings 7-3 and 7-4, where you sent three messages and received all three
    replies with a single read from the connection.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您在读取第一个数据报之前向服务器 1 发送三条 ping 消息。然后，您执行三次读取 2，使用一个足够大的缓冲区来容纳三条 ping 消息。如预期，`unixgram`
    套接字保持消息之间的划分；您发送了三条消息并读取了三条回复。与清单 7-3 和 7-4 中的 `unix` 套接字类型相比，您发送了三条消息并通过连接一次读取收到了三条回复。
- en: The unixpacket Sequence Packet Socket
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: unixpacket 序列数据包套接字
- en: The *sequence packet socket* type is a hybrid that combines the session-oriented
    connections and reliability of TCP with the clearly delineated datagrams of UDP.
    However, sequence packet sockets discard unrequested data in each datagram. If
    you read 32 bytes of a 50-byte datagram, for example, the operating system discards
    the 18 unrequested bytes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列数据包套接字* 类型是一个混合类型，它结合了 TCP 的面向会话的连接和可靠性，以及 UDP 清晰划分的数据报。然而，序列数据包套接字会丢弃每个数据报中的未请求数据。例如，如果您读取了一个
    50 字节数据报中的 32 字节，操作系统会丢弃剩余的 18 个未请求字节。'
- en: Of the three Unix domain socket types, `unixpacket` enjoys the least cross-platform
    support. Coupled with `unixpacket`’s hybrid behavior and discarding of unrequested
    data, `unix` or `unixgram` are better suited for most applications. You are unlikely
    to find sequence packet sockets in use over the internet. It was largely used
    in old X.25 telecommunication networks, some types of financial transactions,
    and AX.25 used in amateur radio.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在三种 Unix 域套接字类型中，`unixpacket` 具有最少的跨平台支持。再加上 `unixpacket` 的混合行为和丢弃未请求数据的特点，`unix`
    或 `unixgram` 更适合大多数应用。您不太可能在互联网上找到序列数据包套接字的应用。它主要用于旧的 X.25 电信网络、某些类型的金融交易以及业余无线电中使用的
    AX.25。
- en: The test code in [Listing 7-10](#listing7-10) sets up a demonstration of `unixpacket`
    sockets.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-10](#listing7-10) 中的测试代码展示了 `unixpacket` 套接字的演示。'
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 7-10: Instantiating a packet-based streaming echo server (*echo_linux_test.go*)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-10：实例化基于数据包的流式回显服务器（*echo_linux_test.go*）
- en: Notice first that you save this code in a file called *echo_linux_test.go.*
    The *_linux_test.go* suffix is a build constraint informing Go that it should
    include this file only when tests are invoked on Linux.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-11](#listing7-11) dials the echo server and sends a series of ping
    messages.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 7-11: Using a `unixpacket` socket to echo messages (*echo_linux_test.go*)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Since `unixpacket` is session oriented, you use `net.Dial`1 to initiate a connection
    with the server. You do not simply write to the server’s address, as you would
    if the network type were datagram based.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: You can see the distinction between the `unix` and `unixpacket` socket types
    by writing three ping messages to the server 2 before reading the first reply.
    Whereas a `unix` socket type would return all three ping messages with a single
    read, `unixpacket` acts just like other datagram-based network types and returns
    one message for each read operation 3.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-12](#listing7-12) illustrates how `unixpacket` discards unrequested
    data in each datagram.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 7-12: Discarding unread bytes (*echo_linux_test.go*)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: This time around, you reduce your buffer size to 2 bytes 1 and read the first
    2 bytes of each datagram. If you were using a streaming network type like `tcp`
    or `unix`, you would expect to read `pi` for the first read and `ng` for the second
    read. But `unixpacket` discards the `ng` portion of the `ping` message because
    you requested only the first 2 bytes—`pi`. Therefore, you make sure you’re receiving
    only the first 2 bytes of the datagram with each read 2.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Service That Authenticates Clients
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On Linux systems, Unix domain sockets allow you to glean details about the process
    on the other end of a socket—your peer—by receiving the credentials from your
    peer’s operating system. You can use this information to authenticate your peer
    on the other side of the Unix domain socket and deny access if the peer’s credentials
    don’t meet your criteria. For instance, if the user *davefromaccounting* connects
    to your administrative service through a Unix domain socket, the peer credentials
    might indicate that you should deny access; Dave should be crunching numbers,
    not sending bits to your administrative service.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: You can create a service that allows connections only from specific users or
    any user in a specific group found in the */etc/groups* file. Each named group
    in the */etc/groups* file has a corresponding group ID number. When a client connects
    to your Unix domain socket, you can request the peer credentials and compare the
    client’s group ID in the peer credentials to the group ID of any allowed groups.
    If the client’s group ID matches one of the allowed group IDs, you can consider
    the client authenticated. Go’s standard library has useful support for working
    with Linux groups, which you’ll use in “Writing the Service” on page 156.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Requesting Peer Credentials
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The process of requesting peer credentials isn’t exactly straightforward. You
    cannot simply request the peer credentials from the connection object itself.
    Rather, you need to use the `golang.org/x/sys/unix` package to request peer credentials
    from the operating system, which you can retrieve using the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请求对等凭证的过程并不完全简单。你不能仅仅从连接对象本身请求对等凭证。相反，你需要使用 `golang.org/x/sys/unix` 包从操作系统请求对等凭证，可以使用以下命令获取：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Listing 7-13](#listing7-13) shows a function that accepts a Unix domain socket
    connection and denies access if the peer isn’t a member of specific groups.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-13](#listing7-13) 显示了一个函数，该函数接受一个 Unix 域套接字连接，并在对等方不是特定组的成员时拒绝访问。'
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 7-13: Retrieving the peer credentials for a socket connection (*creds/auth/allowed_linux.go*)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-13：获取套接字连接的对等凭证 (*creds/auth/allowed_linux.go*)
- en: To retrieve the peer’s Unix credentials, you first grab the underlying file
    object from `net.UnixConn`1, the object that represents your side of the Unix
    domain socket connection. It’s analogous to `net.TCPConn` of a TCP connection
    in Go. Since you need to extract the file descriptor details from the connection,
    you cannot simply rely on the `net.Conn` interface that you receive from the listener’s
    `Accept` method. Instead, your `Allowed` function requires the caller to pass
    in a pointer to the underlying `net.UnixConn` object, typically returned from
    the listener’s `AcceptUnix` method. You’ll see this method in action in the next
    section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索对等方的 Unix 凭证，你首先需要从 `net.UnixConn`1 中获取底层文件对象，它表示你这一方的 Unix 域套接字连接。它类似于 Go
    中 TCP 连接的 `net.TCPConn`。由于你需要从连接中提取文件描述符的详细信息，因此不能仅仅依赖从监听器的 `Accept` 方法收到的 `net.Conn`
    接口。相反，你的 `Allowed` 函数需要调用者传递指向底层 `net.UnixConn` 对象的指针，通常这是从监听器的 `AcceptUnix` 方法返回的。你将在下一节中看到这个方法的实际应用。
- en: You can then pass the file object’s descriptor 3, the protocol-level `unix.SOL_SOCKET`,
    and the option name `unix.SO_PEERCRED` to the `unix.GetsockoptUcred` function
    2. Retrieving socket options from the Linux kernel requires that you specify both
    the option you want and the level at which the option resides. The `unix.SOL_SOCKET`
    tells the Linux kernel you want a socket-level option, as opposed to, for example,
    `unix.SOL_TCP`, which indicates TCP-level options. The `unix.SO_PEERCRED` constant
    tells the Linux kernel that you want the peer credentials option. If the Linux
    kernel finds the peer credentials option at the Unix domain socket level, `unix.GetsockoptUcred`
    returns a pointer to a valid `unix.Ucred` object.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将文件对象的描述符 3、协议级别的 `unix.SOL_SOCKET` 和选项名称 `unix.SO_PEERCRED` 传递给 `unix.GetsockoptUcred`
    函数 2。要从 Linux 内核检索套接字选项，必须指定你想要的选项以及选项所在的级别。`unix.SOL_SOCKET` 告诉 Linux 内核你需要一个套接字级别的选项，而不是比如说
    `unix.SOL_TCP`，它表示 TCP 级别的选项。`unix.SO_PEERCRED` 常量告诉 Linux 内核你需要对等凭证选项。如果 Linux
    内核在 Unix 域套接字级别找到对等凭证选项，`unix.GetsockoptUcred` 将返回指向有效的 `unix.Ucred` 对象的指针。
- en: The `unix.Ucred` object contains the peer’s process, user, and group IDs. You
    pass the peer’s user ID to the `user.LookupId` function 4. If successful, you
    then retrieve a list of group IDs from the user object 5. The user can belong
    to more than one group, and you want to consider each one for access. Finally,
    you check each group ID against a map of allowed groups 6. If any one of the peer’s
    group IDs is in your map, you return `true`, allowing the peer to connect.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`unix.Ucred` 对象包含对等方的进程、用户和组 ID。你将对等方的用户 ID 传递给 `user.LookupId` 函数 4。如果成功，你将从用户对象中获取一组组
    ID 5。用户可以属于多个组，你需要考虑每个组的访问权限。最后，你检查每个组 ID 是否存在于允许的组映射中 6。如果对等方的任何一个组 ID 在你的映射中，你就返回
    `true`，允许对等方连接。'
- en: This example is largely didactic. You can achieve similar results by assigning
    group ownership to the socket file, as we discussed in “Changing a Socket File’s
    Ownership and Permissions” on page 143. However, knowledge of group membership
    could be used for access control and other security decisions within your application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子主要是教学性的。你可以通过将套接字文件的组所有权分配给相应的组来实现类似的结果，正如我们在第 143 页“更改套接字文件的所有权和权限”中讨论的那样。然而，了解组成员身份可以用于应用程序中的访问控制和其他安全决策。
- en: Writing the Service
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写服务
- en: Let’s now use this function in a service that you can run from the command line.
    This service will accept one or more group names found in the Linux operating
    system’s */etc/group* file as arguments on the command line and begin listening
    to a Unix domain socket file. The service will allow clients to connect only if
    they are a member of one of the groups specified on the command line. Clients
    can then make a Unix domain socket connection to the service. The service will
    retrieve the peer credentials of the client and either allow the client to remain
    connected, if the client is a member of one of the allowed groups, or immediately
    disconnect the unauthorized client. The service doesn’t do anything beyond authenticating
    the client’s group ID.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在一个可以从命令行运行的服务中使用此函数。此服务将接受 Linux 操作系统中 */etc/group* 文件中找到的一个或多个组名作为命令行参数，并开始监听
    Unix 域套接字文件。只有当客户端是命令行中指定的某个组的成员时，服务才会允许客户端连接。客户端随后可以建立与该服务的 Unix 域套接字连接。服务将检索客户端的对等方凭证，并根据客户端是否是允许的组成员，决定是否允许其保持连接，或者立即断开未授权的客户端。该服务仅进行客户端组
    ID 的身份验证，不执行其他操作。
- en: In [Listing 7-14](#listing7-14), you specify the imports you’ll need and create
    a meaningful usage message for the service.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 7-14](#listing7-14)中，你指定了所需的导入，并为该服务创建了一个有意义的使用消息。
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 7-14: Expecting group names on the command line (*creds/creds.go*)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-14：期望在命令行中传入组名（*creds/creds.go*）
- en: Our application expects a series of group names as arguments 1. You’ll add the
    group ID for each group name to the map of allowed groups. The code in [Listing
    7-15](#listing7-15) parses these group names.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序期望传入一系列组名作为参数 1。你将把每个组名的组 ID 添加到允许的组映射中。[列表 7-15](#listing7-15) 中的代码解析了这些组名。
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 7-15: Parsing group names into group IDs (*creds/creds.go*)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-15：将组名解析为组 ID（*creds/creds.go*）
- en: The `parseGroupNames` function accepts a string slice of group names, retrieves
    the group information for each group name 1, and inserts each group ID into the
    `groups` map 2.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseGroupNames` 函数接受一个包含组名的字符串切片，获取每个组名的组信息 1，并将每个组的 ID 插入到 `groups` 映射 2
    中。'
- en: '[Listing 7-16](#listing7-16) ties the last few listings together into a service
    that you can connect to from the command line.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-16](#listing7-16) 将最后几项列表结合成一个可以从命令行连接的服务。'
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 7-16: Authorizing peers based on their credentials (*creds/creds.go*
    continued)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-16：基于凭证授权对等方（*creds/creds.go* 续）
- en: You start by parsing the command line arguments to create the map of allowed
    group IDs. You then create a listener on the */tmp/creds.sock* socket. The listener
    accepts connections by using `AcceptUnix`3 so a `*net.UnixConn` is returned instead
    of the usual `net.Conn`, since your `auth.Allowed` function requires a `*net.UnixConn`
    type as its first argument. You then determine whether the peer’s credentials
    are allowed 4. Allowed peers stay connected. Disallowed peers are immediately
    disconnected.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先解析命令行参数，以创建允许的组 ID 映射。然后，你在 */tmp/creds.sock* 套接字上创建一个监听器。监听器通过 `AcceptUnix`3
    接受连接，因此会返回一个 `*net.UnixConn`，而不是通常的 `net.Conn`，因为你的 `auth.Allowed` 函数需要一个 `*net.UnixConn`
    类型作为第一个参数。接着，你确定对等方的凭证是否被允许 4。允许的对等方保持连接，不允许的对等方会立即断开连接。
- en: Since you’ll execute this service on the command line, you’ll stop the service
    by sending an interrupt signal, usually with the ctrl-C key combination. However,
    this signal abruptly terminates the service before Go has a chance to clean up
    the socket file, despite your diligent use of `net.ListenUnix`. Therefore, you
    need to listen for this signal 1 and spin off a goroutine in which you gracefully
    close the listener after receiving the signal 2. This will make sure Go properly
    cleans up the socket file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将在命令行中执行此服务，因此可以通过发送中断信号来停止该服务，通常是使用 ctrl-C 键组合。然而，这个信号会在 Go 有机会清理套接字文件之前突然终止服务，尽管你已经小心使用了
    `net.ListenUnix`。因此，你需要监听这个信号 1，并在接收到信号后启动一个 goroutine，在其中优雅地关闭监听器 2。这将确保 Go 正确地清理套接字文件。
- en: Testing the Service with Netcat
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Netcat 测试服务
- en: 'Netcat is a popular command line utility that allows you to make TCP, UDP,
    and Unix domain socket connections. You’ll use it to test the service from the
    command line. You can likely find Netcat in your Linux distribution’s package
    manager. For example, to install the OpenBSD rewrite of Netcat on Debian 10, run
    the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Netcat 是一个流行的命令行工具，它允许你建立 TCP、UDP 和 Unix 域套接字连接。你将使用它从命令行测试该服务。你可以在 Linux 发行版的包管理器中找到
    Netcat。例如，在 Debian 10 上安装 Netcat 的 OpenBSD 重写版本，运行以下命令：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The command uses the `sudo` command line utility to run `apt install netcat-openbsd`
    masquerading as the `root` user. CentOS 8.1 offers Nmap’s Netcat replacement.
    Run this command to install it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once it’s installed, you should find the *nc* binary in your `PATH` environment
    variable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can connect to your credential-checking service, you need to run
    the service so that it binds to a socket file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, you allow connections from any peer in the `users` or `staff`
    groups. The service will deny access to any peers who are not in at least one
    of these groups. If these groups do not exist in your Linux distribution, choose
    any group in the */etc/groups* file. The service is listening to the */tmp/creds.sock*
    socket file, which is the address you give to Netcat.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need a way of changing your group ID so that you can test whether
    the service denies access to clients you haven’t allowed. Currently, the service
    is running with your user and group IDs, since you started the service. Therefore,
    it will accept all your connections, since the service allows its own group (which
    is our group) to authenticate, per the `groups` map in [Listing 7-15](#listing7-15).
    To change your group when initiating the socket connection with your service,
    you can use the `sudo` command line utility.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Since using `sudo` requires escalated privileges, you are usually prompted
    for your password when you attempt to do so. I’ve omitted password prompts from
    the following examples, but expect to be prompted for your password on `sudo`’s
    first invocation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using `sudo`, you modify your group by passing the group name to the `-g` flag.
    In this case, you set your group to `staff`. Then you execute the `nc` command.
    The `-U` flag tells Netcat to make a Unix domain socket connection to the */tmp/creds.sock*
    file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Since the `staff` group is one of the allowed groups, you receive the `Welcome`
    message upon connecting. You terminate your side of the connection by pressing
    ctrl-C.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'If you repeat the test with a disallowed group, you should receive the opposite
    result:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This time, you use the group `nogroup`, which the service doesn’t allow. As
    expected, you immediately receive the `Access denied` message, and the server
    side of the socket terminates your connection.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: What You’ve Learned
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You started this chapter with a look at Unix domain sockets. A Unix domain socket
    is a file-based communication method for processes running on the same node. Two
    or more processes, such as a local database server and client, can send and receive
    data through a Unix domain socket. Since Unix domain sockets rely on the filesystem
    for addressing, you can leverage filesystem ownership and permissions to control
    access to processes communicating over Unix domain sockets.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'You then learned about the types of Unix domain sockets that Go supports: `unix`,
    `unixgram`, and `unixpacket`. Go makes communication over Unix domain sockets
    relatively painless and handles many of the details for you, particularly if you
    stick to the `net` package’s interfaces. For example, code written for use over
    a stream-based TCP network will also work with little modification over the stream-based
    `unix` domain socket, albeit only for local process communication. Likewise, code
    written for use over a UDP network can be leveraged by the `unixgram` domain socket.
    You also touched on the hybrid Unix domain socket type, `unixpacket`, and learned
    that its drawbacks don’t outweigh its benefits for most applications, particularly
    with respect to cross-platform support. The other two Unix domain socket types
    are better options for most use cases.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你接着学习了 Go 支持的 Unix 域套接字类型：`unix`、`unixgram` 和 `unixpacket`。Go 使得通过 Unix 域套接字进行通信变得相对轻松，并且处理了许多细节，特别是如果你坚持使用
    `net` 包的接口。例如，针对基于流的 TCP 网络编写的代码也能在 `unix` 域套接字（仅限本地进程通信）上工作，几乎不需要修改。同样，针对 UDP
    网络编写的代码可以通过 `unixgram` 域套接字来使用。你还了解了混合型的 Unix 域套接字类型 `unixpacket`，并学到了它的缺点在大多数应用中并不超过其优点，特别是在跨平台支持方面。对于大多数使用场景，另外两种
    Unix 域套接字类型是更好的选择。
- en: This chapter introduced peer credentials and showed how you could use them to
    authenticate client connections. You can go beyond file-based access restrictions
    to a Unix domain socket and request details about the client on the other side
    of the Unix domain socket.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了对等凭据，并展示了如何使用它们来验证客户端连接。你可以超越基于文件的 Unix 域套接字访问限制，获取 Unix 域套接字另一端客户端的详细信息。
- en: You should now be equipped to determine where Unix domain sockets best fit into
    your network stack.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该具备了判断 Unix 域套接字在网络栈中最佳应用位置的能力。
