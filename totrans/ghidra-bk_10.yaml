- en: '## **8'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **8'
- en: DATA TYPES AND DATA STRUCTURES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据类型与数据结构**'
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/com.jpg)'
- en: Understanding the data types and data structures that you encounter as you analyze
    a binary is foundational to reverse engineering. The data that is being passed
    into a function is a key to reverse engineering the function’s signature (the
    number, type, and sequence of parameters required by the function). Beyond that,
    the data types and data structures declared and utilized within functions provide
    additional clues to what each function is doing. This reinforces the importance
    of developing a deep understanding of how data types and data structures are represented
    and manipulated at the assembly language level.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 理解你在分析二进制时遇到的数据类型和数据结构是逆向工程的基础。传递给函数的数据是逆向工程函数签名的关键（即函数所需的参数数量、类型和顺序）。除此之外，在函数内部声明和使用的数据类型和数据结构为每个函数的作用提供了更多线索。这进一步强调了深入理解数据类型和数据结构在汇编语言级别上的表示和操作的重要性。
- en: In this chapter, we devote significant time to these topics that are so critical
    to the success of a reverse engineering effort. We demonstrate how to recognize
    data structures used in a disassembly and to model those structures in Ghidra.
    We follow with a demonstration of how Ghidra’s rich collection of structure layouts
    can save you time with your analysis. Since C++ classes are a complex extension
    of C structures, the chapter concludes with a discussion of reverse engineering
    compiled C++ programs. So let’s begin our discussion of the manipulation and definition
    of simple and complex data types and structures found within compiled programs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将大量时间专注于这些对逆向工程工作至关重要的主题。我们将演示如何识别反汇编中使用的数据结构，并在 Ghidra 中建模这些结构。接下来，我们将展示
    Ghidra 丰富的结构布局如何帮助你节省分析时间。由于 C++ 类是 C 结构的复杂扩展，本章最后将讨论如何进行已编译 C++ 程序的逆向工程。所以，让我们开始讨论在已编译程序中如何操作和定义简单与复杂的数据类型及结构。
- en: '**Making Sense of Data**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据解析**'
- en: As a reverse engineer, you want to make sense of the data you see in a disassembly.
    The simplest method for associating a specific data type with a variable is to
    observe the use of the variable as a parameter to a function that we know something
    about. During its analysis phase, Ghidra makes every effort to annotate data types
    when they can be deduced based on a variable’s use with a function for which Ghidra
    possesses a prototype.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 作为逆向工程师，你需要理解在反汇编中看到的数据。将特定数据类型与变量关联的最简单方法是观察该变量作为已知函数参数的使用情况。在分析阶段，Ghidra 会尽可能地注释数据类型，当它可以基于变量与
    Ghidra 拥有原型的函数的使用关系来推导时。
- en: With imported library functions, Ghidra often will already know the prototype
    of the function. In such cases, you can easily view the prototype by hovering
    over the function name in the Listing window or the Symbol Tree window. When Ghidra
    has no knowledge of a function’s parameter sequence, it should, at a minimum,
    know the name of the library from which the function was imported (see the *Imports*
    folder in the Symbol Tree window). When this happens, your best resources for
    learning the signature and behavior of the function are any associated man pages
    or other available API documentation. When all else fails, remember the adage
    “Google is your friend.”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入的库函数，Ghidra 通常已经知道函数的原型。在这种情况下，你可以通过将鼠标悬停在 Listing 窗口或 Symbol Tree 窗口中的函数名称上，轻松查看该原型。当
    Ghidra 无法识别函数的参数顺序时，至少应该知道函数是从哪个库中导入的（请参见 Symbol Tree 窗口中的 *Imports* 文件夹）。遇到这种情况时，学习函数签名和行为的最佳资源是任何相关的
    man 页面或其他可用的 API 文档。如果一切都失败了，记住这句格言：“谷歌是你的朋友。”
- en: The low-hanging fruit in understanding the behavior of binary programs lies
    in cataloging the library functions that the program calls. A C program that calls
    the `connect` function is creating a network connection. A Windows program that
    calls `RegOpenKey` is accessing the Windows registry. Additional analysis is required,
    however, to gain an understanding of how and why these functions are called.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 理解二进制程序行为的低悬果实在于 cataloging（编目）程序调用的库函数。调用 `connect` 函数的 C 程序正在创建一个网络连接。调用 `RegOpenKey`
    函数的 Windows 程序则是在访问 Windows 注册表。然而，为了理解这些函数的调用方式及原因，还需要进行额外的分析。
- en: 'Discovering how a function is called requires learning about the parameters
    associated with the function. Let’s consider a C program that calls the `connect`
    function as part of retrieving an HTML page. To call `connect`, the program needs
    to know the IP address and destination port of the server that is hosting the
    page, which is provided by a library function called `getaddrinfo`. Ghidra recognizes
    this as a library function and adds a comment to the call to provide us with additional
    information in the Listing window, as shown here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 发现一个函数是如何被调用的需要了解与该函数相关的参数。我们来看看一个 C 程序，它调用 `connect` 函数来检索一个 HTML 页面。在调用 `connect`
    时，程序需要知道托管该页面的服务器的 IP 地址和目标端口，这些信息通过一个名为 `getaddrinfo` 的库函数提供。Ghidra 识别出这是一个库函数，并在调用中添加了注释，在列表窗口中为我们提供了额外的信息，如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can obtain more information about this call in several ways. Hovering over
    the abbreviated comment to the right of the instruction shows that Ghidra has
    provided the complete function prototype to help you understand the parameters
    that are being passed in the function call. Hovering over the function name in
    the Symbol Tree displays the function prototype and variables in a pop-up window.
    Alternatively, choosing Edit Function from the right-click menu provides the same
    information in an editable format, as shown in [Figure 8-1](ch08.xhtml#fig8_1).
    If you want even more information, you can then use the Data Type Manager window
    to find information on specific parameters such as the `addrinfo` data type. If
    you had clicked `getaddrinfo` in the preceding listing, you would see that the
    content shown in [Figure 8-1](ch08.xhtml#fig8_1) is replicated within the listing.
    (This is within a thunk function, which is discussed in “[Thunk](ch10.xhtml#ch10sb01)”
    on [page 212](ch10.xhtml#page_212).)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种方式获取更多关于此调用的信息。将鼠标悬停在指令右侧的简略注释上，可以看到 Ghidra 提供了完整的函数原型，帮助你理解函数调用中传递的参数。将鼠标悬停在符号树中的函数名称上，会在弹出窗口中显示函数原型和变量。或者，右键菜单中选择编辑功能会以可编辑格式提供相同的信息，如[图
    8-1](ch08.xhtml#fig8_1)所示。如果你需要更多信息，可以使用数据类型管理器窗口查找特定参数的信息，如 `addrinfo` 数据类型。如果你点击了前述列表中的
    `getaddrinfo`，你会看到[图 8-1](ch08.xhtml#fig8_1)中显示的内容会在列表中重复显示。（这属于一个 thunk 函数，具体讨论内容请参见
    “[Thunk](ch10.xhtml#ch10sb01)” 在[第 212 页](ch10.xhtml#page_212)的内容。）
- en: '![image](Images/fig8-1.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig8-1.jpg)'
- en: '*Figure 8-1: Edit Function window for* getaddrinfo *function*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：getaddrinfo* 函数的编辑功能窗口'
- en: 'Finally, you aren’t required to navigate through the Symbol Tree and Data Type
    Manager windows to make these observations, as the decompiler has already applied
    this information in the Decompiler window. If you look at the Decompiler window,
    you will see that Ghidra has already incorporated member names for the fields
    contained within the structure (`addrinfo`) by using information from loaded type
    libraries. For the same example, in the following excerpt of code from the decompiler,
    you can see that the member names `ai_family` and `ai_socktype` help us understand
    that `local_48` is a structure that is used when getting the information needed
    for `connect`. In this case, the `ai_family` assignment indicates that an IPv4
    address is being used (`2` equates to the symbolic constant `AF_INET`), and `ai_socktype`
    indicates the use of a stream socket (`1` equates to the symbolic constant `SOCK_STREAM`):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你不需要通过符号树和数据类型管理器窗口来查看这些信息，因为反编译器已经在反编译器窗口中应用了这些信息。如果你查看反编译器窗口，你会看到 Ghidra
    已经通过使用加载的类型库中的信息，为结构体 (`addrinfo`) 中包含的字段加入了成员名称。在这个示例中，在反编译器的以下代码摘录中，你可以看到成员名称
    `ai_family` 和 `ai_socktype` 帮助我们理解 `local_48` 是在获取 `connect` 所需的信息时使用的结构体。在这种情况下，`ai_family`
    的赋值表示正在使用 IPv4 地址（`2` 等同于符号常量 `AF_INET`），而 `ai_socktype` 表示使用的是流套接字（`1` 等同于符号常量
    `SOCK_STREAM`）：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '### **Recognizing Data Structure Use**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '### **识别数据结构的使用**'
- en: While primitive data types often fit in a processor’s registers or instruction
    operands, composite data types such as arrays and structures typically require
    more complex instruction sequences in order to access the individual data items
    they contain. Before we can discuss Ghidra’s features for improving the readability
    of code that utilizes complex data types, we need to review what that code looks
    like.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然原始数据类型通常适合存放在处理器的寄存器或指令操作数中，但复合数据类型如数组和结构体通常需要更复杂的指令序列来访问它们包含的各个数据项。在我们讨论
    Ghidra 提供的用于提高复杂数据类型代码可读性的功能之前，我们需要回顾一下该代码的样子。
- en: '***Array Member Access***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数组成员访问***'
- en: '*Arrays* are the simplest composite data structures in terms of memory layout.
    Traditionally, arrays are contiguous blocks of memory that contain consecutive
    elements of the same data type (a homogeneous collection). The size of an array
    is the product of the number of elements in the array and the size of each element.
    Using C notation, the minimum number of bytes consumed by declaring the integer
    array'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组*是最简单的复合数据结构，就内存布局而言。传统上，数组是连续的内存块，包含相同数据类型的连续元素（同质集合）。数组的大小是数组中元素数量与每个元素大小的乘积。使用C语言的表示法，声明整数数组时所消耗的最小字节数是'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: is computed as
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 计算结果为
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Individual array elements can be accessed by supplying an index value, which
    may be a variable or a constant, as shown in these valid array references:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供一个索引值（该值可以是变量或常量），可以访问单个数组元素，如下所示的有效数组引用：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Assuming, for the sake of example, that `sizeof(int)`is 4 bytes, then the first
    array access ➊ accesses the integer value that lies 80 bytes into the array, while
    the second array access ➋ accesses integers at offsets 0, 4, 8, . . . 96 bytes
    into the array. The offset for the first array access can be computed at compile
    time as `20 * 4`. In most cases, the offset for the second array access must be
    computed at runtime because the value of the loop counter, `i`, is not fixed at
    compile time. Thus, the product `i * 4` is computed on each pass through the loop
    to determine the exact offset into the array.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设为了举例，`sizeof(int)`是4个字节，那么第一次数组访问 ➊ 访问的是位于数组内80字节处的整数值，而第二次数组访问 ➋ 访问的是位于数组内偏移量为0、4、8、...
    96字节处的整数值。第一次数组访问的偏移量可以在编译时计算为`20 * 4`。在大多数情况下，第二次数组访问的偏移量必须在运行时计算，因为循环计数器`i`的值在编译时并不固定。因此，`i
    * 4`的乘积会在每次循环时计算，以确定数组的确切偏移量。
- en: Ultimately, how an array element is accessed depends not only on the type of
    index used but also on where the array is allocated within the program’s memory
    space.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，如何访问数组元素不仅取决于所使用的索引类型，还取决于数组在程序内存空间中的分配位置。
- en: '**Globally Allocated Arrays**'
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**全局分配数组**'
- en: When an array is allocated within the global data area of a program (within
    the `.data` or `.bss` section, for example), the compiler knows the base address
    of the array at compile time, which enables the compiler to compute fixed addresses
    for any array element that is accessed using a fixed index. Consider the following
    trivial program, which accesses a global array using both fixed and variable indices.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当数组在程序的全局数据区分配时（例如，在`.data`或`.bss`段内），编译器在编译时就知道数组的基地址，这使得编译器能够计算出任何通过固定索引访问的数组元素的固定地址。考虑以下简单程序，它通过固定和变量索引访问全局数组。
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**WHAT IS C REALLY EXPECTING?**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**C语言究竟在期待什么？**'
- en: For simplicity, we said that C is expecting an integer index as either a variable
    or a constant. In reality, any expression that can be evaluated to or interpreted
    as an integer will do. The general guideline is, “anywhere you can use an integer,
    you can use an expression that evaluates to an integer.” Of course, this is not
    limited to just integers. C is perfectly happy to evaluate any expression you
    provide and try to make it work for the variable type expected. What if the values
    are outside the bounds of the array? You have the makings of numerous exploitable
    vulnerabilities, of course! Values will be read from or written to the resulting
    out-of-bounds memory region, or the program will simply crash if the computed
    target address is not valid within the program.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们说C语言期望使用整数索引，无论是变量还是常量。实际上，任何可以计算为整数或被解释为整数的表达式都可以使用。一般准则是：“任何可以使用整数的地方，都可以使用一个能计算出整数的表达式。”当然，这并不仅限于整数。C语言可以很好地评估你提供的任何表达式，并尝试使其与预期的变量类型兼容。如果值超出了数组的范围会怎样？当然，你就有了许多可以被利用的漏洞！值将会被读取或写入到超出范围的内存区域，或者如果计算出的目标地址在程序中无效，程序就会崩溃。
- en: 'If we disassemble a stripped version of the corresponding binary, the main
    function contains the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对相应的二进制文件进行反汇编，主函数包含以下代码：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'While this program has only one global variable (the global array), the disassembly
    lines ➊ ➋ ➌ seem to indicate three global variables: `DAT_00301018`, `DAT_0030101c`,
    and `DAT_00301020`, respectively. However, the `LEA` instruction ➎ loads the address
    of a global variable seen previously ➊. In this context, when combined with the
    computation of an offset (`RAX*4`) ➍, and scaled memory access ➏, `DAT_00301018`
    is most likely the base address of a global array. The annotated operand `=>DAT_00301018`
    ➏ provides us with the base of the array into which 40 will be written.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个程序只有一个全局变量（全局数组），但是反汇编结果的 ➊ ➋ ➌ 行似乎表明有三个全局变量：`DAT_00301018`、`DAT_0030101c`
    和 `DAT_00301020`。然而，`LEA` 指令 ➎ 加载了之前看到的一个全局变量的地址 ➊。在这种情况下，当与偏移量计算（`RAX*4`） ➍ 和规模化内存访问
    ➏ 结合时，`DAT_00301018` 很可能是一个全局数组的基地址。注释操作数 `=>DAT_00301018` ➏ 为我们提供了一个数组的基地址，值
    40 将会写入该数组。
- en: '**WHAT’S A STRIPPED BINARY?**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是去除符号的二进制文件？**'
- en: When compilers generate object files, they must include enough information for
    the linker to be able to do its job. One of the linker’s jobs is to resolve references
    between object files, such as a call to a function whose body resides in a different
    file, utilizing information from a compiler-generated symbol. In many cases, the
    linker combines all of the symbol table information from the object files and
    includes the consolidated information in the resulting executable file. This information
    is not necessary for the executable to run properly, but it is very useful from
    a reverse engineering perspective, as Ghidra (and other tools like debuggers)
    can use the symbol table information to recover function and global variable names
    and sizes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器生成目标文件时，它们必须包含足够的信息，以便链接器能够完成工作。链接器的一个任务是解析目标文件之间的引用，比如调用一个函数，而该函数的实现位于不同的文件中，并利用编译器生成的符号信息。在许多情况下，链接器会将目标文件中的所有符号表信息合并，并将合并后的信息包含在最终的可执行文件中。这些信息对于可执行文件的正确运行不是必需的，但从逆向工程的角度来看，它非常有用，因为
    Ghidra（以及像调试器这样的其他工具）可以利用符号表信息恢复函数和全局变量的名称及大小。
- en: '*Stripping* a binary means removing portions of an executable file that are
    not essential to the runtime operation of the binary. This can be accomplished
    by using the command-line `strip` utility to post-process an executable, or by
    providing build options to the compiler and/or linker (`-s` for `gcc`/`ld`) to
    have them generate a stripped binary themselves. In addition to symbol table information,
    `strip` can remove any debugging symbol information, such as local variable `names`
    and type information, that were embedded in a binary when it was built. Lacking
    symbol information, reverse engineering tools must have algorithms for both identifying
    and naming functions and data.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*去除符号*一个二进制文件意味着移除可执行文件中对二进制运行操作不必要的部分。这可以通过使用命令行工具 `strip` 对可执行文件进行后处理，或者通过向编译器和/或链接器提供构建选项（对于
    `gcc`/`ld` 来说是 `-s`）让它们自己生成一个去除符号的二进制文件来实现。除了符号表信息，`strip` 还可以移除任何调试符号信息，例如局部变量
    `names` 和类型信息，这些信息是在构建二进制文件时嵌入其中的。缺少符号信息时，逆向工程工具必须拥有算法来识别和命名函数及数据。'
- en: 'Based on the names assigned by Ghidra, we know that the global array starts
    with the 12 bytes beginning at address `00301018`. During compilation, the compiler
    used the fixed indices (0, 1, 2) to compute the actual addresses of the corresponding
    elements in the array (`00301018`, `0030101c`, and `00301020`), which are referenced
    using the global variables at ➊, ➋, and ➌. Based on the values being moved into
    these locations, we can surmise that we are moving 32-bit integer (`dword`) values
    into this array. If we navigate to the associated data in the listing, we see
    the following content:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Ghidra 所分配的名称，我们知道全局数组从地址 `00301018` 开始，包含12个字节。在编译期间，编译器使用固定的索引（0、1、2）来计算数组中相应元素的实际地址（`00301018`、`0030101c`
    和 `00301020`），这些地址分别由 ➊、➋ 和 ➌ 中的全局变量引用。根据写入这些位置的值，我们可以推测我们正在将 32 位整数（`dword`）值写入该数组。如果我们查看列表中相关的数据，看到以下内容：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The question marks indicate that this array is probably allocated within the
    program’s `.bss` section and that no initialization values are present within
    the file image.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 问号表示该数组可能在程序的 `.bss` 区段中分配，并且文件镜像中没有初始化值。
- en: It is easier to recognize an array in disassembly when it is accessed using
    variable indices. When constant indices are used to access global arrays, the
    corresponding array elements appear as global variables in the disassembly. However,
    the use of variable index values reveals the base address of the array at ➎ and
    the size of the individual elements at ➍, because the offset into the array must
    be computed using the index. (Such scaling operations are required to convert
    an integer array index from C to a byte offset for the correct array element in
    assembly language.)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用变量索引访问数组时，在反汇编中更容易识别数组。当使用常量索引访问全局数组时，相应的数组元素在反汇编中显示为全局变量。然而，使用变量索引值会在 ➎
    显示数组的基址，在 ➍ 显示单个元素的大小，因为访问数组时必须使用索引来计算偏移量。（这种缩放操作是必需的，用于将 C 中的整数数组索引转换为汇编语言中正确数组元素的字节偏移量。）
- en: 'Using Ghidra’s type- and array-formatting operations discussed in the previous
    chapter (Data ▸ Create Array), we can format `DAT_000301018` as a three-element
    integer array, yielding disassembly lines with a named array accessed with indices
    rather than offsets:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ghidra 中在前一章节讨论的类型和数组格式化操作（数据 ▸ 创建数组），我们可以将 `DAT_000301018` 格式化为一个三元素整数数组，从而在反汇编中显示带有名称的数组，使用索引而非偏移量访问：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The default array name assigned by Ghidra, `INT_ARRAY_00301018`, includes the
    array type as well as the starting address of the array.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 分配的默认数组名称 `INT_ARRAY_00301018` 包括了数组类型以及数组的起始地址。
- en: '**UPDATING SYMBOL INFORMATION IN COMMENTS**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**更新注释中的符号信息**'
- en: As you begin identifying data types, changing symbol names, and so on, you can
    make sure that the valuable comments you have added to your listing don’t become
    outdated, or challenging to follow, by using comment annotations that update automatically.
    The `Symbol` annotation option lets you include references to symbols that will
    be updated as you change the symbols to accurately reflect your findings. (See
    “[Annotations](ch07.xhtml#ch07lev131)” on [page 132](ch07.xhtml#page_132).)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始识别数据类型、修改符号名称等时，你可以确保你在列表中添加的重要注释不会变得过时或难以理解，通过使用注释标注，这些标注会随着你更新符号而自动更新。`Symbol`
    注释选项允许你包含符号引用，当你更改符号时，它们会自动更新，以准确反映你的发现。（请参见[“注释”](ch07.xhtml#ch07lev131)，见[第132页](ch07.xhtml#page_132)）
- en: Let’s look at the Decompiler window before ([Figure 8-2](ch08.xhtml#fig8_2))
    and after ([Figure 8-3](ch08.xhtml#fig8_3)) the array has been created. In [Figure
    8-2](ch08.xhtml#fig8_2), the important warning on line 2 is another clue that
    you might be looking at an array, and the assignment of integer values supports
    the assumption that the array type is integer.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看数组创建前后的反汇编窗口（[图 8-2](ch08.xhtml#fig8_2)和[图 8-3](ch08.xhtml#fig8_3)）。在[图
    8-2](ch08.xhtml#fig8_2)中，第2行的一个重要警告是另一个线索，提示你可能正在查看一个数组，并且整数值的赋值支持数组类型是整数的假设。
- en: '![image](Images/fig8-2.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig8-2.jpg)'
- en: '*Figure 8-2: Decompiler view indicating potential array*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：反汇编窗口指示潜在的数组*'
- en: After the integer array is created, the code in the Decompiler window is updated
    to use the new array variable, as shown in [Figure 8-3](ch08.xhtml#fig8_3).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建整数数组后，反汇编窗口中的代码会更新为使用新的数组变量，如[图 8-3](ch08.xhtml#fig8_3)所示。
- en: '![image](Images/fig8-3.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig8-3.jpg)'
- en: '*Figure 8-3: Decompiler view after declaring array type*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：声明数组类型后的反汇编窗口视图*'
- en: '**Stack-Allocated Arrays**'
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**堆栈分配的数组**'
- en: The compiler can’t know the absolute address of an array allocated on the stack
    as a local variable in a function at compile time, so even accesses that use constant
    indices require some computation at runtime. Despite the differences, compilers
    often treat stack-allocated arrays almost identically to globally allocated arrays.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在编译时无法知道堆栈上分配的数组的绝对地址，因为它是函数中的局部变量，因此即使是使用常量索引的访问也需要在运行时进行计算。尽管有这些差异，编译器通常将堆栈分配的数组与全局分配的数组几乎一样对待。
- en: 'The following program is a variation of the previous example that uses a stack-allocated
    array rather than a global array:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序是前一个示例的变体，它使用堆栈分配的数组，而不是全局数组：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The address at which `stack_array` will be allocated is unknown at compile
    time, so the compiler cannot precompute the address of `stack_array[2]` as it
    did for `global_array[2]`. The compiler can, however, compute the relative location
    of any element within the array. For example, element `stack_array[2]` begins
    at offset `2*sizeof(int)` from the beginning of the array, and the compiler is
    well aware of this at compile time. If the compiler elects to allocate `stack_array`
    at offset `EBP-0x18` within the stack frame, it can compute `EBP-0x18+2*sizeof(int)`,
    which reduces to `EBP-0x10` at compile time and avoids the need for additional
    arithmetic at runtime to access `stack_array[2]`. This becomes evident in the
    following listing:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`stack_array` 分配的地址在编译时是未知的，因此编译器无法像处理 `global_array[2]` 那样预计算 `stack_array[2]`
    的地址。然而，编译器可以计算数组中任何元素的相对位置。例如，`stack_array[2]` 的元素从数组开头的偏移量 `2*sizeof(int)` 开始，编译器在编译时是清楚这一点的。如果编译器决定在堆栈帧中的偏移量
    `EBP-0x18` 分配 `stack_array`，它可以计算 `EBP-0x18+2*sizeof(int)`，这在编译时会简化为 `EBP-0x10`，避免了在运行时访问
    `stack_array[2]` 时需要额外的算术运算。这个过程在以下的列表中变得明显：'
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is even more difficult to detect this array than the global array. This function
    appears to have six unrelated variables ➊ (`local_c`, `local_10`, `local_14`,
    `local_18`, `local_1c`, and `local_28`), rather than an array of three integers
    and an integer index variable. Two of these locals (`local_1c` and `local_28`)
    are the function’s two parameters, `argc` and `argv`, being saved for later use
    ➋.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 检测这个数组比检测全局数组更困难。这个函数似乎有六个不相关的变量 ➊（`local_c`、`local_10`、`local_14`、`local_18`、`local_1c`
    和 `local_28`），而不是一个包含三个整数和一个整数索引变量的数组。这些局部变量中的两个（`local_1c` 和 `local_28`）是函数的两个参数，`argc`
    和 `argv`，它们被保存以便稍后使用 ➋。
- en: 'The use of constant index values tends to hide the presence of a stack-allocated
    array, because you see only assignments to separate local variables ➍. Only the
    multiplication ➎ hints at the existence of an array with individual elements that
    are 4 bytes each. Let’s break down that statement further: `RBP` holds the stack
    frame base pointer address; `RAX*4` is the array index (converted by `atoi` and
    stored in `local_c` ➌) multiplied by the size of an array element; `-0x10` is
    the offset to the start of the array from `RBP`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常量索引值往往掩盖了堆栈分配数组的存在，因为你只会看到对单独局部变量的赋值 ➍。只有乘法 ➎ 暗示了存在一个数组，数组的每个元素都是 4 字节。我们来进一步分解这个表达式：`RBP`
    保存堆栈帧基指针的地址；`RAX*4` 是数组索引（由 `atoi` 转换并存储在 `local_c` ➌）乘以数组元素的大小；`-0x10` 是从 `RBP`
    开始到数组起始位置的偏移量。
- en: The process to convert local variables to an array is a little different from
    creating an array in the data section of the listing. Because the stack structure
    information is associated with the first address in the function, you cannot select
    a subset of the stack variables. Instead, place the cursor on the variable at
    the start of the array, `local_18`, select the Set Data Type followed by the Array
    option from the right-click context menu, and then specify the number of elements
    in the array. Ghidra will display a warning message about conflict with the local
    variables that we are pulling into the array definition, as shown in [Figure 8-4](ch08.xhtml#fig8_4).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将局部变量转换为数组的过程与在数据段中创建数组有所不同。由于堆栈结构信息与函数中的第一个地址相关联，你不能选择堆栈变量的子集。相反，将光标放置在数组起始位置的变量
    `local_18` 上，右键点击并选择“设置数据类型”后选择“数组”选项，然后指定数组元素的数量。Ghidra 会显示关于与我们将局部变量拉入数组定义时冲突的警告信息，如[图
    8-4](ch08.xhtml#fig8_4)所示。
- en: '![image](Images/fig8-4.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig8-4.jpg)'
- en: '*Figure 8-4: Warning about potential conflict when defining stack array*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：定义堆栈数组时的潜在冲突警告*'
- en: 'If you proceed, despite the potential conflict, you will see the array in the
    Listing window, as shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果继续操作，尽管存在潜在冲突，你仍然会在列表窗口中看到数组，如下所示：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Even after the array is defined, the decompiler listing in [Figure 8-5](ch08.xhtml#fig8_5)
    doesn’t resemble the original source code. The decompiler has omitted the static
    array assignments because it believes they do not contribute to the result of
    the function. The call to `atoi` and resulting assignment remain because Ghidra
    can’t compute the side effects of calling `atoi`, but Ghidra mistakes the saved
    result of `atoi` as the fourth element of the array (`local_c` in the disassembly,
    and `iVar1` in the decompiler listing).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在定义了数组之后，[图8-5](ch08.xhtml#fig8_5)中的反编译器输出也与原始源代码不相似。反编译器省略了静态数组赋值操作，因为它认为这些操作对函数的结果没有贡献。调用`atoi`及其结果赋值依然保留，因为Ghidra无法计算调用`atoi`的副作用，但Ghidra错误地将`atoi`保存的结果误认为是数组的第四个元素（反汇编中的`local_c`，反编译器输出中的`iVar1`）。
- en: '![image](Images/fig8-5.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig8-5.jpg)'
- en: '*Figure 8-5: Decompiler view of function with all stack variables after array
    is defined*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-5：数组定义后的所有栈变量反编译器视图*'
- en: '**Heap-Allocated Arrays**'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**堆分配数组**'
- en: '*Heap-allocated arrays* are allocated using a dynamic memory allocation function
    such as `malloc` (C) or `new` (C++). From the compiler’s perspective, the primary
    difference in dealing with a heap-allocated array is that the compiler must generate
    all references into the array based on the address returned from the memory allocation
    function. The following C program allocates a small array in the program heap:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆分配数组*是使用动态内存分配函数如`malloc`（C）或`new`（C++）分配的。从编译器的角度来看，处理堆分配数组的主要区别是，编译器必须基于内存分配函数返回的地址生成对数组的所有引用。以下是一个在程序堆中分配一个小数组的C程序：'
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The corresponding disassembly is a little more complex than the two previous
    examples:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的反汇编比前两个例子稍微复杂一些：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The starting address of the array (returned from `malloc` in the `RAX` register)
    is stored in the local variable `heap_array` ➋. In this example, unlike the previous
    examples, every access to the array begins with reading the contents of `heap_array`
    to obtain the array’s base address. The references to `heap_array[0]`, `heap_array[1]`,
    and `heap_array[2]` require offsets of 0 ➌, 4 ➍, and 8 bytes ➎, respectively.
    The variable index array access `heap_array[idx]` is implemented with multiple
    instructions to compute the offset into the array by multiplying the array index
    by the size of an array element ➏, and adding the result to the base address of
    the array ➐.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的起始地址（由`malloc`返回并存储在`RAX`寄存器中）被保存在局部变量`heap_array` ➋中。在这个例子中，与前面的例子不同，每次访问数组时都会先读取`heap_array`的内容以获取数组的基地址。对`heap_array[0]`、`heap_array[1]`和`heap_array[2]`的引用分别需要0
    ➌、4 ➍和8字节的偏移 ➎。对数组索引的访问`heap_array[idx]`通过多条指令实现，首先将数组索引与数组元素的大小相乘 ➏，然后将结果加到数组的基地址
    ➐。
- en: 'Heap-allocated arrays have one particularly nice feature: the number of elements
    allocated to the array can be computed from the total size of the array and the
    size of each element. The parameter passed to the memory allocation function (`12`
    passed to `malloc` ➊) tells you the number of bytes allocated to the array. Dividing
    this by the size of an element (4 bytes in this example, as observed from the
    offsets ➌ ➍ ➎ , which step by 4, and the scale factor ➏) tells us the number of
    elements in the array. In this example, a three-element array was allocated.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 堆分配的数组有一个特别好的特性：可以通过数组的总大小和每个元素的大小计算出分配给数组的元素个数。传递给内存分配函数的参数（这里是传给`malloc`的`12`
    ➊）告诉你分配给数组的字节数。将这个值除以元素的大小（在这个例子中是4字节，从偏移量➌ ➍ ➎可以观察到，步长是4，而比例因子➏也表明这一点）就能得出数组中的元素数量。在这个例子中，分配了一个三元素的数组。
- en: The decompiler was also able to recognize the array, as seen in [Figure 8-6](ch08.xhtml#fig8_6).
    (The name of the array pointer, `puVar2`, indicates that it is a pointer to an
    unsigned integer using the prefix `pu`.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图8-6](ch08.xhtml#fig8_6)所示，反编译器也能识别该数组。（数组指针的名称`puVar2`表明它是一个指向无符号整数的指针，前缀`pu`表示这一点。）
- en: '![image](Images/fig8-6.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig8-6.jpg)'
- en: '*Figure 8-6: Decompiler view of heap array function*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-6：堆数组函数的反编译器视图*'
- en: 'In this function, unlike the stack-allocated array function, the decompiler
    listing shows the constant index array assignments, even though it would normally
    exclude them because the array is not used in other operations or returned from
    the function. This case is different because the assignments are *not* just manipulating
    stack variables: the stack variable is actually a pointer to memory that `malloc`
    requested from the heap. Writing via that variable does not write to the local
    stack variable but rather uses the stack variable to locate the allocated memory.
    The program may lose the pointer (address of the start of the heap array) when
    the function exits, but the values persist in memory. (This particular example
    is actually a demonstration of a memory leak. While not a good programming practice,
    it does allow us to demonstrate the concept of a heap array.)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，与栈分配的数组函数不同，反编译器列出了常量索引数组的赋值，即使它通常会排除这些赋值，因为数组没有在其他操作中使用或从函数中返回。这个情况不同，因为这些赋值*不是*仅仅操作栈变量：栈变量实际上是一个指向堆上由`malloc`请求的内存的指针。通过这个变量写入数据并不是写入到本地栈变量，而是通过栈变量来定位已分配的内存。程序可能会在函数退出时丢失该指针（堆数组起始地址），但值会继续保存在内存中。（这个具体的例子实际上是一个内存泄漏的演示。虽然这不是一个好的编程实践，但它确实让我们展示了堆数组的概念。）
- en: In conclusion, arrays are easiest to recognize when a variable is used as an
    index into the array. The array-access operation, which requires the index to
    be scaled by the size of an array element before adding the resulting offset to
    the base address of the array, stands out in a disassembly listing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，当一个变量作为数组的索引使用时，数组最容易被识别。数组访问操作需要将索引乘以数组元素的大小，再将结果偏移量加到数组的基地址，这一点在反汇编列表中非常明显。
- en: '***Structure Member Access***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结构体成员访问***'
- en: C-style structs, referred to here generically as *structures*, group collections
    of (often heterogeneous) data items into a composite data type. In source code,
    the data fields within a structure are accessed by name rather than by index.
    Unfortunately, these informative field names are converted to numeric offsets
    by the compiler, so by the time you are looking at a disassembly, structure field
    access looks remarkably similar to accessing array elements using constant indices.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: C 风格的结构体，通常在这里称为*结构体*，将（通常是异质的）数据项集合成复合数据类型。在源代码中，结构体中的数据字段是通过名称访问的，而不是通过索引。不幸的是，这些有用的字段名称在编译时被转换为数字偏移量，因此当你查看反汇编时，结构体字段的访问与使用常量索引访问数组元素非常相似。
- en: 'The following structure definition containing five heterogeneous fields will
    be used in the upcoming examples:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是包含五个异质字段的结构定义，将在接下来的示例中使用：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When a compiler encounters a structure definition, the compiler maintains a
    running total of the number of bytes consumed by the fields of the structure to
    determine the offset of each field within the structure. The sum of the space
    required to allocate each field within a structure determines the minimum space
    required for the structure. However, you should never assume that a compiler utilizes
    the minimum required space to allocate a structure. By default, compilers align
    structure fields to memory addresses that allow for the most efficient reading
    and writing of those fields. For example, 4-byte integer fields will be aligned
    to offsets that are divisible by four, while 8-byte doubles will be aligned to
    offsets that are divisible by eight. Depending on the composition of the structure,
    the compiler may insert padding bytes to meet alignment requirements, meaning
    the actual size of a structure will be larger than the sum of its component fields.
    The default offsets and resulting structure size for the sample structure can
    be seen in the Default offset column in the comments in the preceding structure
    definition, and they sum to 24 rather than the minimum 19.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到结构体定义时，它会持续跟踪结构体各个字段占用的字节数，以确定每个字段在结构体中的偏移量。分配每个字段所需的空间总和决定了结构体所需的最小空间。然而，你不应当假设编译器会使用最小所需空间来分配结构体。默认情况下，编译器会将结构体字段对齐到最有效的内存地址，以便最有效地读写这些字段。例如，4字节的整型字段会对齐到能被四整除的偏移量，而8字节的双精度浮点数则会对齐到能被八整除的偏移量。根据结构体的组成，编译器可能会插入填充字节来满足对齐要求，这意味着结构体的实际大小会比其组件字段的大小总和大。样本结构的默认偏移量和结果结构大小可以在前述结构定义的注释中的默认偏移量列中看到，它们的总和为24，而不是最小的19。
- en: Structures can be packed into the minimum required space by using compiler options
    to request specific member alignments. Microsoft C/C++ and GNU `gcc`/`g++` both
    recognize the `pack` pragma for controlling structure field alignment. The GNU
    compilers additionally recognize the `packed` attribute for controlling structure
    alignment on a per-structure basis. Requesting 1-byte alignment for structure
    fields causes compilers to squeeze the structure into the minimum required space.
    The offsets and structure size of the sample structure are found in the Minimum
    offset column. (Note that some processors perform better when data is aligned
    according to its type, while other processors may generate exceptions if data
    is *not* aligned on specific boundaries.)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用编译器选项请求特定的成员对齐方式，可以将结构打包到所需的最小空间中。Microsoft C/C++ 和 GNU `gcc`/`g++` 都识别
    `pack` 编译指令来控制结构字段对齐。GNU 编译器还识别 `packed` 属性，用于按结构单独控制结构对齐。请求对结构字段进行 1 字节对齐会导致编译器将结构压缩到所需的最小空间。样本结构的偏移量和结构大小可以在最小偏移量列中找到。（请注意，某些处理器在数据按其类型对齐时表现更好，而其他处理器则可能在数据*未*按特定边界对齐时产生异常。）
- en: With these facts in mind, let’s look at how structures are treated in compiled
    code. As with arrays, access to structure members is performed by adding the base
    address of the structure to the offset of the desired member. However, while array
    offsets can be computed at runtime from a provided index value (because each element
    in an array has the same size), structure offsets must be computed at compile
    time and will turn up in compiled code as fixed offsets into the structure, looking
    nearly identical to array references that make use of constant indices.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这些事实后，我们来看编译后的代码中结构的处理方式。与数组一样，访问结构成员的方式是将结构的基地址与所需成员的偏移量相加。然而，虽然数组的偏移量可以根据提供的索引值在运行时计算（因为数组中的每个元素大小相同），但结构的偏移量必须在编译时计算，并且在编译后的代码中将显示为固定的结构偏移量，这些偏移量与使用常量索引的数组引用几乎一模一样。
- en: Creating structures in Ghidra is more involved than creating arrays, so we cover
    that in the next section, after we show several examples of disassembled and decompiled
    structures.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ghidra 中创建结构比创建数组更为复杂，因此我们将在下一节中讲解该内容，在展示几个反汇编和反编译的结构示例后进行说明。
- en: '##### **Globally Allocated Structures**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '##### **全局分配结构**'
- en: 'As with globally allocated arrays, the addresses of globally allocated structures
    are known at compile time. This allows the compiler to compute the address of
    each member of the structure at compile time and eliminates the need to do any
    math at runtime. Consider the following program that accesses a globally allocated
    structure:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与全局分配的数组一样，全局分配的结构的地址在编译时已知。这使得编译器能够在编译时计算结构中每个成员的地址，从而避免在运行时进行任何计算。考虑以下程序，它访问一个全局分配的结构：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If this program is compiled with default structure alignment options, we can
    expect to see something like the following when we disassemble it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该程序使用默认的结构对齐选项进行编译，那么我们可以期待在反汇编时看到如下所示的结果：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This disassembly contains no math whatsoever to access the members of the structure,
    and, in the absence of source code, it would not be possible to state with any
    certainty that a structure is being used at all. Because the compiler has performed
    all of the offset computations at compile time, this program appears to reference
    five global variables rather than five fields within a single structure. You should
    be able to note the similarities with the previous example of globally allocated
    arrays using constant index values.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该反汇编中没有进行任何数学运算来访问结构的成员，并且如果没有源代码，我们无法确定是否确实使用了结构。因为编译器在编译时已经完成了所有的偏移量计算，这个程序看起来像是在引用五个全局变量，而不是一个结构中的五个字段。你应该能注意到，这与之前使用常量索引值的全局分配数组的示例有很多相似之处。
- en: In [Figure 8-2](ch08.xhtml#fig8_2), the uniform offsets coupled with the values
    allowed us to surmise (accurately) that we were dealing with an array. In this
    example, we are correct to conclude that we are not dealing with an array because
    the size of the variables is nonuniform (`dword`, `word`, `byte`, `dword`, and
    `qword`, respectively), but we lack sufficient evidence to assert that we are
    dealing with a struct.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 8-2](ch08.xhtml#fig8_2) 中，均匀的偏移量和相应的值使我们能够准确推测我们正在处理的是一个数组。在这个示例中，我们可以正确地得出结论，我们没有在处理一个数组，因为变量的大小是不均匀的（分别是
    `dword`、`word`、`byte`、`dword` 和 `qword`），但我们缺乏足够的证据来断言我们正在处理的是一个结构。
- en: '##### **Stack-Allocated Structures**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '##### **栈分配结构体**'
- en: 'Like stack-allocated arrays, stack-allocated structures are challenging to
    recognize based on stack layout alone, and the decompiler doesn’t provide additional
    insight. Modifying the preceding program to use a stack-allocated structure, declared
    in `main`, yields the following disassembly:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 和栈分配的数组一样，单凭栈布局很难识别栈分配的结构体，反编译器也无法提供额外的洞察。修改前面的程序以使用在`main`中声明的栈分配结构体，得到如下反汇编结果：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Again, no math is performed to access the structure’s fields since the compiler
    can determine the relative offsets for each field within the stack frame at compile
    time, and we are left with the same, potentially misleading picture that five
    individual variables are being used rather than a single variable that happens
    to contain five distinct fields. In reality, `local_28` should be the start of
    a 24-byte structure, and each of the other variables should somehow be formatted
    to reflect the fact that they are fields within the structure.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，访问结构体字段时不进行任何数学运算，因为编译器可以在编译时确定每个字段在堆栈帧中的相对偏移量，我们得到的依然是一个可能具有误导性的图像——看起来像是使用了五个独立的变量，而不是一个包含五个不同字段的单一变量。实际上，`local_28`应该是一个24字节结构体的起始位置，其他变量应该以某种方式格式化，反映它们是结构体中的字段。
- en: '**Heap-Allocated Structures**'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**堆分配的结构体**'
- en: Heap-allocated structures reveal much more about the size of the structure and
    the layout of its fields. When a structure is allocated in the program heap, the
    compiler has no choice but to generate code to compute the proper field address
    whenever a field is accessed, because the structure’s address is unknown at compile
    time. For globally allocated structures, the compiler is able to compute a fixed
    starting address. For stack-allocated structures, the compiler can compute a fixed
    relationship between the start of the structure and the frame pointer for the
    enclosing stack frame. When a structure has been allocated in the heap, the only
    reference to the structure available to the compiler is the pointer to the structure’s
    starting address.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 堆分配的结构体揭示了结构体的大小和字段布局的更多信息。当一个结构体在程序堆中分配时，编译器别无选择，只能生成代码，在每次访问字段时计算正确的字段地址，因为结构体的地址在编译时是未知的。对于全局分配的结构体，编译器能够计算出固定的起始地址。对于栈分配的结构体，编译器可以计算出结构体起始地址与包含该栈帧的栈指针之间的固定关系。当结构体在堆中分配时，编译器唯一能访问的结构体引用就是指向结构体起始地址的指针。
- en: 'To demonstrate heap-allocated structures, we modify the sample program to declare
    a pointer within `main` and assign it the address of a block of memory large enough
    to hold the structure:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示堆分配的结构体，我们修改示例程序，在`main`中声明一个指针，并将其指向足够大的内存块，以容纳该结构体：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the corresponding disassembly:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对应的反汇编：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this example, we can discern the exact size and layout of the structure.
    The structure size can be inferred to be 24 bytes based on the amount of memory
    requested from `malloc` ➊. The structure contains the following fields at the
    indicated offsets:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以分辨出结构体的确切大小和布局。结构体的大小可以通过`malloc`请求的内存量推测为24字节 ➊。结构体包含以下字段，位于指定的偏移量：
- en: A 4-byte (`dword`) field at offset 0 ➋
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏移量为0的一个4字节（`dword`）字段 ➋
- en: A 2-byte (`word`) field at offset 4 ➌
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏移量为4的一个2字节（`word`）字段 ➌
- en: A 1-byte field at offset 6 ➍
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏移量为6的一个1字节字段 ➍
- en: A 4-byte (`dword`) field at offset 8 ➎
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏移量为8的一个4字节（`dword`）字段 ➎
- en: An 8-byte (`qword`) field at offset 16 ➏
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏移量为16的一个8字节（`qword`）字段 ➏
- en: Based on the use of floating point instructions (`MOVSD`), we can further deduce
    that the `qword` field is actually a `double`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 基于浮点数指令（`MOVSD`）的使用，我们进一步推测，`qword`字段实际上是一个`double`类型。
- en: 'The same program compiled to pack structures with a 1-byte alignment yields
    the following disassembly:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用1字节对齐打包结构体的同一程序编译结果如下：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The only changes are the smaller structure size (now 19 bytes) and the adjusted
    offsets to account for the realignment of each structure field.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的变化是结构体的大小变小（现在为19字节），并且为了适应每个结构体字段的重新对齐，偏移量进行了调整。
- en: 'Regardless of the alignment used when compiling a program, finding structures
    allocated and manipulated in the program heap is the fastest way to determine
    the size and layout of a given data structure. However, keep in mind that many
    functions will not do you the favor of immediately accessing every member of a
    structure to help you understand the structure’s layout. Instead, you may need
    to follow the use of the pointer to the structure and make note of the offsets
    used whenever that pointer is dereferenced, and eventually piece together the
    complete layout of the structure. In “[Example 3: Automated Structure Creation](ch19.xhtml#ch19lev360)”
    on [page 437](ch19.xhtml#page_437), you’ll see how the decompiler can automate
    this process for you.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 无论编译程序时使用了什么对齐方式，找到程序堆中分配和操作的结构体是确定给定数据结构大小和布局的最快方式。然而，请记住，许多函数不会直接访问结构体的每个成员来帮助你理解结构体的布局。相反，你可能需要跟踪指向结构体的指针，并注意每当该指针被解引用时所使用的偏移量，最终拼凑出结构体的完整布局。在[第437页](ch19.xhtml#page_437)的“[示例3：自动化结构体创建](ch19.xhtml#ch19lev360)”中，你将看到反编译器如何自动化这一过程。
- en: '**Arrays of Structures**'
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**结构体数组**'
- en: 'Some programmers say that the beauty of composite data structures is that they
    allow you to build arbitrarily complex structures by nesting smaller structures
    within larger structures: arrays of structures, structures within structures,
    and structures that contain arrays as members, for example. The preceding discussions
    regarding arrays and structures apply just as well to such nested types. As an
    example, consider the following simple program in which `heap_struct` points to
    an array of five `ch8_struct` items:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员认为，复合数据结构的美妙之处在于，它们允许通过将较小的结构体嵌套在较大的结构体中，构建任意复杂的结构体：例如，结构体数组、结构体内嵌结构体、以及包含数组作为成员的结构体。之前关于数组和结构体的讨论同样适用于这些嵌套类型。例如，考虑以下简单程序，其中`heap_struct`指向一个包含五个`ch8_struct`项的数组：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Underneath the hood, accessing `field1` involves multiplying the index value
    by the size of an array element (in this case, the size of the structure) and
    then adding the offset to the desired field. The corresponding disassembly is
    shown here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，访问`field1`涉及将索引值乘以数组元素的大小（在这种情况下，结构体的大小），然后将偏移量加到所需的字段上。对应的反汇编结果如下所示：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The function allocates 120 bytes ➊ in the heap. The array index in `RAX` is
    multiplied by 24 using a series of operations ➋, ending with `SHL RAX, 3` ➌ before
    being added to the start address for the array ➍. (If it is not readily apparent
    to you that the series of operations starting at ➋ is equivalent to multiplication
    by 24, don’t worry. Code sequences such as this are discussed in [Chapter 20](ch20.xhtml#ch20).)
    Because `field1` is the first member of the struct, no additional offset is required
    in order to generate the final address for the assignment into `field1` ➎.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数在堆中分配了120字节➊。`RAX`中的数组索引通过一系列操作乘以24➋，最后以`SHL RAX, 3` ➌结束，然后将结果加到数组的起始地址➍。（如果你不太清楚从➋开始的操作序列等同于乘以24，不用担心，类似的代码序列在[第20章](ch20.xhtml#ch20)中有详细讨论。）由于`field1`是结构体的第一个成员，因此无需额外的偏移量即可生成分配到`field1`的最终地址➎。
- en: From these facts, we can deduce the size of an array item (24), the number of
    items in the array (120 / 24 = 5), and the fact that there is a 4-byte (`dword`)
    field at offset 0 within each array element. This short listing does not offer
    enough information to draw any conclusions about how the remaining 20 bytes within
    each structure are allocated to additional fields. The size of the array can be
    even more easily deduced using the same formula from the decompiler listing in
    [Figure 8-7](ch08.xhtml#fig8_7) (0x18 hex is 24 decimal).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些事实中，我们可以推导出数组项的大小（24），数组中的项数（120 / 24 = 5），以及每个数组元素在偏移量0处有一个4字节（`dword`）字段。这个简短的列表没有提供足够的信息来得出关于每个结构体中剩余20字节如何分配给其他字段的结论。使用反编译器列出的[图8-7](ch08.xhtml#fig8_7)中的相同公式，我们可以更容易地推导出数组的大小（0x18十六进制是24十进制）。
- en: '![image](Images/fig8-7.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig8-7.jpg)'
- en: '*Figure 8-7: Decompiler view of function with heap-allocated struct array*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-7：带有堆分配结构体数组的函数反编译视图*'
- en: '**Creating Structures with Ghidra**'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用Ghidra创建结构体**'
- en: In the preceding chapter, you saw how to use Ghidra’s array-aggregation capabilities
    to collapse long lists of data declarations into a single disassembly line representing
    an array. The next few sections explore Ghidra’s facilities for improving the
    readability of code that manipulates structures. Our goal is to move away from
    cryptic structure references such as `[EDX + 10h]` and toward something more readable
    like `[EDX + ch8_struct.field_e]`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你看到如何使用 Ghidra 的数组聚合功能，将长列表的数据声明折叠成表示数组的单一反汇编行。接下来的几节将探讨 Ghidra 提供的功能，以提高操作结构的代码的可读性。我们的目标是避免使用像
    `[EDX + 10h]` 这样的晦涩结构引用，转而使用更易读的方式，比如 `[EDX + ch8_struct.field_e]`。
- en: Whenever you discover that a program is manipulating a data structure, you need
    to decide whether you want to incorporate structure field names into your disassembly
    or whether you can make sense of all the numeric offsets sprinkled throughout
    the listing. In some cases, Ghidra may recognize the use of a structure defined
    as part of the C standard library or the Windows API and use its knowledge of
    the exact layout of the structure to convert numeric offsets into symbolic field
    names. This is the ideal case, as it leaves you with a lot less work to do. We
    will return to this scenario once you understand a little more about how Ghidra
    deals with structure definitions in general.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你发现程序在操作数据结构时，你需要决定是否要将结构字段名称包含到你的反汇编中，还是你可以理解反汇编列表中散布的所有数字偏移量。在某些情况下，Ghidra
    可能会识别出一个作为 C 标准库或 Windows API 一部分定义的结构，并利用它对该结构的精确布局的了解，将数字偏移量转换为符号字段名。这是理想的情况，因为它会减少你需要做的工作。我们将在你更深入了解
    Ghidra 如何处理结构定义后，再回到这个场景。
- en: '***Creating a New Structure***'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建新结构***'
- en: When Ghidra has no layout knowledge for a structure, you can create the structure
    by selecting the data and using the right-click context menu. When you select
    Data ▸ Create Structure (or use the hotkey SHIFT-[), you will see the Create Structure
    window shown in [Figure 8-8](ch08.xhtml#fig8_8). Since you have highlighted a
    block of data (which could be defined or undefined), Ghidra will try to identify
    existing structures that have a matching format or the same size. You can select
    one of the existing structures from the window or create a new structure. In this
    example, we are using the globally allocated structure sample code discussed previously
    and are creating a new structure called `ch8_struct`. As soon as you click OK,
    the structure becomes an official type in the Data Type Manager window and the
    information is propagated to other CodeBrowser windows.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ghidra 没有某个结构的布局知识时，你可以通过选择数据并使用右键上下文菜单来创建该结构。当你选择 数据 ▸ 创建结构（或使用快捷键 SHIFT-[）时，你将看到如[图
    8-8](ch08.xhtml#fig8_8)所示的“创建结构”窗口。由于你已高亮选中一块数据（无论它是已定义还是未定义），Ghidra 会尝试识别是否有现有结构具有匹配的格式或相同的大小。你可以从窗口中选择现有结构之一，或者创建一个新结构。在这个例子中，我们使用了之前讨论的全局分配结构示例代码，并创建了一个名为`ch8_struct`的新结构。点击“确定”后，该结构将成为数据类型管理器窗口中的官方类型，且信息会传播到其他
    CodeBrowser 窗口。
- en: '![image](Images/fig8-8.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig8-8.jpg)'
- en: '*Figure 8-8: Create Structure window*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-8：创建结构窗口*'
- en: 'Let’s look at the effect of this creation on the associated CodeBrowser windows,
    starting with the Listing window. As shown earlier in the chapter, the disassembly
    listing gives you few hints that you might be dealing with a structure, because
    the code modifies a series of seemingly unrelated global variables:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下创建这个结构对相关 CodeBrowser 窗口的影响，从列表窗口开始。如章节早些时候所示，反汇编列表几乎没有提示你正在处理一个结构，因为代码修改了一系列看似无关的全局变量：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When you navigate to the associated data items, select the range (`00301020`
    through `00301037`), and create the associated structure, you see the individual
    data items in the structure are now associated with a structure called `ch8_struct``_00301020`,
    and each item in the structure has the name `field_` concatenated with its offset
    from the first element in the structure.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导航到相关数据项，选择范围（`00301020` 到 `00301037`），并创建关联的结构时，你会看到结构中的各个数据项现在与名为 `ch8_struct_00301020`
    的结构相关联，并且结构中的每个项目都有一个名称 `field_`，后面加上它与结构中第一个元素的偏移量。
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is just one of the windows that changes with the creation of the structure.
    Recall that the Decompiler window gave us a helpful warning that we might be working
    with a structure or array. After we create the structure, the warning disappears
    and the decompiled code more closely resembles the original C code, as shown in
    [Figure 8-9](ch08.xhtml#fig8_9).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是随着结构的创建而变化的多个窗口之一。回想一下，Decompiler 窗口曾给出过一个有用的警告，提醒我们可能在处理结构体或数组。创建结构体后，警告消失，反编译的代码也更接近原始的
    C 代码，如[图 8-9](ch08.xhtml#fig8_9)所示。
- en: '![image](Images/fig8-9.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig8-9.jpg)'
- en: '*Figure 8-9: Decompiler view after struct is created*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-9：创建结构体后的反编译器视图*'
- en: '**STATE OF THE UNION**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**联合体的状态**'
- en: A *union* is a construct that is similar to a structure. The major difference
    between structures and unions is that structure fields have unique offsets and
    their own dedicated memory space, whereas union fields all overlap one another
    beginning at offset 0\. The result is that all union fields share the same memory
    space. The Union Editor window in Ghidra looks similar to the Structure Editor
    window, and the functionality is basically the same.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*联合体*是一种与结构体相似的构造。结构体和联合体之间的主要区别在于，结构体字段有独立的偏移量和专用的内存空间，而联合体字段从偏移量 0 开始重叠在一起。其结果是所有联合体字段共享相同的内存空间。Ghidra
    中的联合体编辑器窗口与结构体编辑器窗口相似，功能基本相同。'
- en: The new structure also now appears as an entry in the Data Type Manager window
    in the CodeBrowser. [Figure 8-10](ch08.xhtml#fig8_10) shows the new entry in the
    Data Type Manager window and the associated window showing all uses of `ch8_struct`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的结构体现在也作为一个条目出现在 CodeBrowser 中的 Data Type Manager 窗口中。[图 8-10](ch08.xhtml#fig8_10)显示了
    Data Type Manager 窗口中的新条目以及关联的窗口，展示了 `ch8_struct` 的所有引用。
- en: '![image](Images/fig8-10.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig8-10.jpg)'
- en: '*Figure 8-10: Newly declared structure in Data Type Manager and References
    windows*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-10：Data Type Manager 和 References 窗口中新声明的结构体*'
- en: '***Editing Structure Members***'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编辑结构体成员***'
- en: At this point, Ghidra presents the newly created structure as a contiguous collection
    of undefined bytes with cross-references at each offset accessed by the example
    program, instead of a collection of defined data types (which you have identified
    from the size of each item and the way it is being used). To define the type of
    each field, you can edit the structure from the Listing window by right-clicking
    and selecting the appropriate Data option. Alternatively, you can edit the structure
    from within the Data Type Manager by double-clicking the structure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Ghidra 将新创建的结构体呈现为一系列未定义字节的连续集合，每个偏移量由示例程序访问，而不是一组已定义的数据类型（你可以根据每个项的大小和使用方式来确定）。要定义每个字段的类型，你可以通过右键单击
    Listing 窗口中的结构体并选择合适的 Data 选项来编辑结构体。或者，你可以通过双击 Data Type Manager 中的结构体来编辑它。
- en: If you double-click the newly created structure in the Data Type Manager window
    (shown in [Figure 8-10](ch08.xhtml#fig8_10)), the Structure Editor window (shown
    in [Figure 8-11](ch08.xhtml#fig8_11)) opens to show 24 elements of undefined type,
    all with a length of 1\. To determine the number, sizes, and types of the individual
    elements within the structure, you could study the disassembly, or you could let
    the decompiler listing shown earlier in [Figure 8-9](ch08.xhtml#fig8_9) provide
    the answers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Data Type Manager 窗口中双击新创建的结构体（如[图 8-10](ch08.xhtml#fig8_10)所示），将会打开结构体编辑器窗口（如[图
    8-11](ch08.xhtml#fig8_11)所示），该窗口展示了 24 个未定义类型的元素，长度都为 1。要确定结构体中各个元素的数量、大小和类型，你可以研究反汇编代码，或者让前面[图
    8-9](ch08.xhtml#fig8_9)中显示的反编译器列表提供答案。
- en: '![image](Images/fig8-11.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig8-11.jpg)'
- en: '*Figure 8-11: Structure Editor window*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-11：结构体编辑器窗口*'
- en: The original decompiler listing associated with our newly created structure
    shows that five items are referenced within the same structure, `ch8_struct``_00301020`,
    using field names containing two integers. The first integer represents the offset
    from the base address of the structure. The second shows the number of bytes used,
    which is a good indicator of the size of the item. Using this information (and
    some meaningful field names), you can update the Structure Editor window, as shown
    in [Figure 8-12](ch08.xhtml#fig8_12). The Byte Offset/Component Bits scroll bar
    within the Structure Editor provides a visual representation of the structure.
    When a structure is edited, the Decompiler window (on the left of [Figure 8-12](ch08.xhtml#fig8_12)),
    the Listing window, and other associated windows are also updated.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们新创建的结构相关的原始反编译器列表显示，在同一结构`ch8_struct_00301020`中，使用包含两个整数的字段名引用了五个项目。第一个整数表示从结构基地址的偏移量。第二个整数表示使用的字节数，这是衡量项目大小的一个好指标。使用这些信息（以及一些有意义的字段名），你可以更新结构编辑器窗口，如[图
    8-12](ch08.xhtml#fig8_12)所示。结构编辑器中的字节偏移/组件位滚动条提供了结构的可视化表示。当结构被编辑时，反编译器窗口（在[图 8-12](ch08.xhtml#fig8_12)的左侧）、列表窗口以及其他相关窗口也会更新。
- en: Because `field_c` is a character, the decompiler converted the integer 30 into
    the ASCII character represented by 30 (0x1e), which is an unprintable control
    character (RS). In the Structure Editor, the padding bytes (indicated by the mnemonic
    `??`) have been included for proper field alignment, and the offsets to each field
    and the overall size (24 bytes) of the structure match the values seen in the
    earlier examples.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`field_c`是一个字符，反编译器将整数30转换为表示30（0x1e）的ASCII字符，这是一个不可打印的控制字符（RS）。在结构编辑器中，已包含填充字节（由助记符`??`表示），以确保字段的正确对齐，并且每个字段的偏移量以及结构的整体大小（24字节）与之前示例中的值相匹配。
- en: '![image](Images/fig8-12.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig8-12.jpg)'
- en: '*Figure 8-12: Decompiler and Structure Editor windows after editing structure*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-12：编辑结构后的反编译器和结构编辑器窗口*'
- en: '***Applying Structure Layouts***'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***应用结构布局***'
- en: You have seen how to use existing structure definitions and create new ones
    to associate existing memory with a particular memory layout. You have also seen
    how that association is propagated through the CodeBrowser windows to make the
    contents clearer. Vague memory references such as `[EBX+8]` become more readable
    by converting numeric structure offsets into symbolic references such as `[EBX+ch8_struct.field_d]`,
    especially because symbolic references can be given meaningful names. Ghidra’s
    use of a hierarchical notation makes it clear exactly what type of structure,
    and exactly which field within that structure, is being accessed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到如何使用现有的结构定义并创建新的结构，将现有内存与特定的内存布局关联。你还看到这种关联是如何通过CodeBrowser窗口传播的，以使内容更加清晰。模糊的内存引用，例如`[EBX+8]`，通过将数字结构偏移量转换为符号引用，如`[EBX+ch8_struct.field_d]`，变得更加易读，尤其是因为符号引用可以赋予有意义的名称。Ghidra使用层次符号表示法，明确显示正在访问的结构类型以及该结构中的哪个字段。
- en: Ghidra’s library of known structure layouts has been populated with information
    gathered by parsing common C header files. The layout of a structure defines its
    total size, the name and size of each field, and the starting offset of each field
    within the structure. You can use structure layouts even without associated content
    in the data section, which is especially helpful when dealing with structure pointers.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra的已知结构布局库已通过解析常见的C头文件收集的信息进行了填充。结构的布局定义了其总大小、每个字段的名称和大小以及每个字段在结构中的起始偏移量。即使数据段中没有相关内容，你也可以使用结构布局，这在处理结构指针时尤其有用。
- en: Anytime you encounter a memory reference in the form `[reg+N]` (for example,
    `[RAX+0x12]`), where `reg` is a register name and `N` is a small constant, `reg`
    is being used as a pointer and `N` represents an offset into the memory that `reg`
    points to. This is a common pattern for structure member access, with `reg` pointing
    to the beginning of the structure and `N` selecting the field at structure offset
    `N`. Under some circumstances, Ghidra, with your assistance, can clean up this
    type of memory reference to reflect both the type of structure being pointed to
    and the specific field within that structure that is being referenced.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你遇到形如`[reg+N]`的内存引用时（例如`[RAX+0x12]`），其中`reg`是寄存器名称，`N`是一个小常量，`reg`作为指针使用，`N`表示相对于`reg`所指向的内存的偏移量。这是结构体成员访问的常见模式，`reg`指向结构体的开始位置，`N`选择结构体中偏移量为`N`的字段。在某些情况下，在你的帮助下，Ghidra可以清理这种类型的内存引用，以反映指向的结构类型以及引用的结构体中的具体字段。
- en: 'Let’s look at the 32-bit version of the example from the beginning of the chapter,
    where we were requesting an HTTP page from a server. The request is made by a
    function named `get_page`. In this version of the binary, Ghidra asserts that
    the function receives three stack-allocated parameters. These parameters appear
    in the Listing window as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下本章开始时示例的32位版本，我们请求从服务器获取一个HTTP页面。请求是通过一个名为`get_page`的函数发出的。在这个版本的二进制文件中，Ghidra确认该函数接收三个堆栈分配的参数。这些参数在Listing窗口中显示如下：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The Decompiler window shows that `param_3` is used with some offsets in a call
    to `connect`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Decompiler窗口显示，`param_3`在调用`connect`时与一些偏移量一起使用：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Tracing through the calling sequence and the return values from the called
    functions, we can conclude that `param_3` is a pointer to an `addrinfo` struct
    and retype `param_3` as an `addrinfo*` (using CTRL-L from the Listing or Decompiler
    window). The decompiled statement using `param_3` will be replaced with the far
    more informative statement shown here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过追踪调用序列和被调用函数的返回值，我们可以得出结论，`param_3`是指向`addrinfo`结构体的指针，并将`param_3`重新定义为`addrinfo*`（使用Listing或Decompiler窗口中的CTRL-L）。使用`param_3`的反编译语句将被替换为这里显示的更具信息量的语句：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can see that pointer arithmetic has been replaced by structure field references.
    Pointer arithmetic in source code is rarely self-explanatory. Any effort you spend
    updating data types for program variables will be well worth it. You’ll have saved
    your colleagues the time required to deduce the type of `param_3` themselves,
    and you’ll thank yourself upon returning from two weeks at the beach that you
    don’t need to reanalyze the code to relearn the type of that variable that you
    forgot to update.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，指针运算已被结构体字段引用所取代。源代码中的指针运算很少能自我解释。你花费时间更新程序变量的数据类型是非常值得的。你将为同事节省他们自己推断`param_3`类型所需的时间，等你从海滩度假回来时，你会感谢自己，因为你不需要重新分析代码以重新学习那个你忘记更新的变量类型。
- en: '**C++ Reversing Primer**'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**C++反向工程入门**'
- en: C++ classes are the object-oriented extensions of C structs, so it is somewhat
    logical to wrap up our discussion of data structures by reviewing the features
    of compiled C++ code. Detailed coverage of C++ is beyond the scope of this book.
    Here, we attempt to cover the highlights and a few of the differences between
    Microsoft’s C++ compiler and GNU’s `g++.`
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: C++类是C结构体的面向对象扩展，因此，通过回顾已编译C++代码的特性来总结我们对数据结构的讨论是有一定逻辑的。C++的详细内容超出了本书的范围。在这里，我们尝试概述要点，并指出Microsoft的C++编译器和GNU的`g++`之间的几个差异。
- en: Remember that a solid, fundamental understanding of the C++ language will assist
    you greatly in understanding compiled C++. Object-oriented concepts such as inheritance
    and polymorphism are difficult enough to master at the source level. Attempting
    to dive into these concepts at the assembly level without understanding them at
    the source level can be an exercise in frustration.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对C++语言的扎实基础理解将极大地帮助你理解已编译的C++。面向对象的概念，如继承和多态性，在源代码级别就很难掌握。如果在没有理解这些概念的源代码基础上试图在汇编级别深入探讨它们，可能会让你感到沮丧。
- en: '#### ***The this Pointer***'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***this指针***'
- en: 'The `this` pointer is available in all nonstatic C++ member functions. Whenever
    such a function is called, `this` is initialized to point to the object used to
    invoke the function. Consider the following function calls in C++:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`指针在所有非静态的C++成员函数中都可以使用。每当调用这样的函数时，`this`会被初始化为指向用于调用该函数的对象。考虑以下C++中的函数调用：'
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the three calls to `member_func`, `this` takes on the values `&object1`,
    `&object2`, and `p_obj`, respectively.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在三次对 `member_func` 的调用中，`this` 分别取值为 `&object1`、`&object2` 和 `p_obj`。
- en: It is easiest to view `this` as a hidden first parameter passed in to all non-static
    member functions. As discussed in [Chapter 6](ch06.xhtml#ch06), the Microsoft
    C++ compiler utilizes the `thiscall` calling convention and passes `this` in the
    `ECX` register (x86) or the `RCX` register (x86-x64). The GNU `g++` compiler treats
    `this` exactly as if it were the first (leftmost) parameter to nonstatic member
    functions. On 32-bit Linux x86, the address of the object used to invoke the function
    is pushed as the topmost item on the stack prior to calling the function. On Linux
    x86-64, `this` is passed in the first register parameter, `RDI`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易将 `this` 视为传递给所有非静态成员函数的隐藏第一个参数。如 [第6章](ch06.xhtml#ch06) 所讨论，Microsoft C++
    编译器使用 `thiscall` 调用约定，并将 `this` 传递给 `ECX` 寄存器（x86）或 `RCX` 寄存器（x86-x64）。GNU `g++`
    编译器将 `this` 处理得就像它是非静态成员函数的第一个（最左边的）参数一样。在 32 位 Linux x86 上，用于调用函数的对象地址在调用函数之前被压入栈顶。在
    Linux x86-64 上，`this` 通过第一个寄存器参数 `RDI` 传递。
- en: From a reverse engineering point of view, moving an address into the `ECX` register
    immediately before a function call is a probable indicator of two things. First,
    the file was compiled using Microsoft’s C++ compiler. Second, the function is
    possibly a member function. When the same address is passed to two or more functions,
    we can conclude that those functions all belong to the same class hierarchy.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从逆向工程的角度来看，在函数调用之前将地址移动到 `ECX` 寄存器中，很可能指示两件事。首先，文件是使用 Microsoft 的 C++ 编译器编译的。其次，函数可能是成员函数。当相同的地址被传递给两个或更多函数时，我们可以推断出这些函数都属于同一类层次结构。
- en: Within a function, the use of `ECX` prior to initializing it implies that the
    caller must have initialized `ECX` (recall the discussion of *liveness* from “[Register-Based
    Parameters](ch06.xhtml#ch06sb01)” on [page 113](ch06.xhtml#page_113)) and is a
    possible sign that the function is a member function (though the function may
    simply use the `fastcall` calling convention). Further, when a member function
    passes `this` to additional functions, those functions can be inferred to be members
    of the same class as well.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，如果在初始化 `ECX` 之前就使用了它，意味着调用者必须先初始化 `ECX`（回想一下在 “[基于寄存器的参数](ch06.xhtml#ch06sb01)”
    中讨论的 *活跃性* 概念，[第113页](ch06.xhtml#page_113)），这可能是函数是成员函数的一个迹象（尽管该函数也可能只是使用了 `fastcall`
    调用约定）。进一步说，当成员函数将 `this` 传递给其他函数时，能够推断出这些函数也属于同一类。
- en: For code compiled using GNU `g++`, calls to member functions stand out somewhat
    less because `this` looks a lot like any other first parameter. However, any function
    that does not take a pointer as its first argument can certainly be ruled out
    as a member function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 GNU `g++` 编译的代码，调用成员函数时 `this` 参数看起来和其他任何第一个参数差不多，因此成员函数的调用不太容易区分。然而，任何不以指针作为第一个参数的函数，肯定可以排除为成员函数。
- en: '***Virtual Functions and Vftables***'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***虚函数和虚函数表***'
- en: '*Virtual functions* enable polymorphic behavior in C++ programs. For each class
    (or subclass through inheritance) that contains virtual functions, the compiler
    generates a table containing pointers to each virtual function in the class. Such
    tables are called *vftables* (also *vtables*). Every instance of a class that
    contains virtual functions is given an additional data member that points to the
    class’s vftable. The *vftable pointer* is allocated as the first data member within
    the class instance, and when an object is created at runtime, its constructor
    function sets its vftable pointer to point at the appropriate vftable. When that
    object invokes a virtual function, the correct function is selected by performing
    a lookup in the object’s vftable. Thus, vftables are the underlying mechanism
    that facilitates runtime resolution of calls to virtual functions.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚函数* 使 C++ 程序具有多态行为。对于每个包含虚函数的类（或通过继承得到的子类），编译器都会生成一个表，表中包含指向类中每个虚函数的指针。这些表被称为
    *虚函数表*（也称为 *vtable*）。每个包含虚函数的类的实例都会增加一个数据成员，该成员指向类的虚函数表。*虚函数表指针* 被分配为类实例中的第一个数据成员，当对象在运行时被创建时，其构造函数会设置虚函数表指针，指向合适的虚函数表。当该对象调用虚函数时，正确的函数会通过在对象的虚函数表中查找来选择。因此，虚函数表是实现运行时解析虚函数调用的基本机制。'
- en: 'A few examples may help to clarify the use of vftables. Consider the following
    C++ class definitions:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例可能有助于澄清虚函数表的使用。考虑以下 C++ 类定义：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, `SubClass` inherits from `BaseClass` ➌. `BaseClass` contains four
    virtual functions ➊, while `SubClass` contains five ➍ (four from `BaseClass`,
    two of which it overrides, plus the new `vfunc5`). Within `BaseClass`, `vfunc1`
    is a *pure virtual function*, indicated by `= 0` ➋ in its declaration. Pure virtual
    functions have no implementation in their declaring class and *must* be overridden
    in a subclass before the class is considered concrete. In other words, there is
    no function named `BaseClass::vfunc1`, and until a subclass provides an implementation,
    no objects can be instantiated. `SubClass` provides such an implementation, so
    `SubClass` objects can be created. In object-oriented terms, `BaseClass::vfunc1`
    is an *abstract function*, which makes `BaseClass` an *abstract base class* (that
    is, an incomplete class that cannot be directly instantiated since it is missing
    an implementation for at least one function).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`SubClass` 继承自 `BaseClass` ➌。`BaseClass` 包含四个虚函数 ➊，而 `SubClass` 包含五个虚函数
    ➍（其中四个来自 `BaseClass`，其中两个被它重写，另外加上新的 `vfunc5`）。在 `BaseClass` 中，`vfunc1` 是一个 *纯虚函数*，在其声明中由
    `= 0` ➋ 标明。纯虚函数在声明类中没有实现，并且 *必须* 在子类中重写，才能使类成为具体类。换句话说，`BaseClass::vfunc1` 没有实现，直到子类提供实现之前，不能实例化对象。`SubClass`
    提供了这样的实现，因此可以创建 `SubClass` 对象。从面向对象的角度看，`BaseClass::vfunc1` 是一个 *抽象函数*，这使得 `BaseClass`
    成为一个 *抽象基类*（即一个不完整的类，不能直接实例化，因为它缺少至少一个函数的实现）。
- en: At first glance, `BaseClass` appears to contain two data members, and `SubClass`
    three data members. Recall, however, that any class that contains virtual functions,
    either explicitly or because they are inherited, also contains a vftable pointer.
    As a result, the compiled implementation of `BaseClass` has three data members,
    while instantiated `SubClass` objects have four data members. In each case, the
    first data member is the vftable pointer. Within `SubClass`, the vftable pointer
    is actually inherited from `BaseClass` rather than being introduced specifically
    for `SubClass`. You can see this in the simplified memory layout in [Figure 8-13](ch08.xhtml#fig8_13),
    in which a single `SubClass` object has been dynamically allocated. During the
    creation of the object, the new object’s vftable pointer is initialized to point
    to the correct vftable (`SubClass`’s in this case).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，`BaseClass` 似乎包含两个数据成员，`SubClass` 包含三个数据成员。然而请记住，任何包含虚函数的类，无论是显式定义的还是因为继承了虚函数，都包含一个
    vftable 指针。因此，编译后的 `BaseClass` 实现有三个数据成员，而实例化后的 `SubClass` 对象有四个数据成员。在这两种情况下，第一个数据成员是
    vftable 指针。在 `SubClass` 中，vftable 指针实际上是从 `BaseClass` 继承的，而不是专门为 `SubClass` 引入的。你可以在
    [图 8-13](ch08.xhtml#fig8_13) 中简化的内存布局中看到这一点，其中一个 `SubClass` 对象已经被动态分配。在对象创建过程中，新的对象的
    vftable 指针会被初始化为指向正确的 vftable（在这种情况下是 `SubClass` 的 vftable）。
- en: '![image](Images/fig8-13.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig8-13.jpg)'
- en: '*Figure 8-13: A simple vftable layout*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-13：一个简单的 vftable 布局*'
- en: The vftable for `SubClass` contains two pointers to functions belonging to `BaseClass`
    (`BaseClass::vfunc2` and `BaseClass::vfunc4`) because `SubClass` does not override
    either of these functions and instead inherits them from `BaseClass`. The vftable
    for `BaseClass` shows how pure virtual functions are handled. Because there is
    no implementation for the pure virtual function `BaseClass::vfunc1`, no address
    is available to store in the `BaseClass` vftable slot for `vfunc1`. In such cases,
    compilers insert the address of an error-handling function, dubbed `purecall`
    in Microsoft libraries and `__cxa_pure_virtual` in GNU libraries. In theory, these
    functions should never be called, but in the event that they are, they cause the
    program to be terminated abnormally.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`SubClass` 的 vftable 包含两个指向属于 `BaseClass` 的函数的指针（`BaseClass::vfunc2` 和 `BaseClass::vfunc4`），因为
    `SubClass` 并没有重写这两个函数，而是从 `BaseClass` 继承了它们。`BaseClass` 的 vftable 显示了纯虚函数是如何处理的。由于纯虚函数
    `BaseClass::vfunc1` 没有实现，因此在 `BaseClass` 的 vftable 中没有地址可以存储在 `vfunc1` 的位置上。在这种情况下，编译器会插入一个错误处理函数的地址，这个函数在微软库中叫做
    `purecall`，在 GNU 库中叫做 `__cxa_pure_virtual`。理论上，这些函数不应被调用，但如果它们被调用，程序将异常终止。'
- en: You must account for the vftable pointer when you manipulate classes within
    Ghidra. Because C++ classes are extensions of C structures, you can use Ghidra’s
    structure definition features to define the layout of C++ classes. With polymorphic
    classes, you must include a vftable pointer as the first field within the class
    as well as account for the vftable pointer in the total size of the object. This
    is most apparent when observing the dynamic allocation of an object using the
    `new` operator, where the size value passed to `new` includes the space needed
    by all explicitly declared fields in the class (and any superclasses) as well
    as any space required for a vftable pointer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ghidra 中操作类时，必须考虑 vftable 指针。由于 C++ 类是 C 结构体的扩展，您可以利用 Ghidra 的结构定义功能来定义 C++
    类的布局。对于多态类，您必须将 vftable 指针作为类中的第一个字段，并且在计算对象的总大小时考虑 vftable 指针的大小。这一点在观察使用 `new`
    运算符动态分配对象时最为明显，其中传递给 `new` 的大小值包括所有显式声明字段（包括任何超类字段）所需的空间，以及 vftable 指针所需的空间。
- en: 'In the following example, a `SubClass` object is created dynamically and its
    address saved in a `BaseClass` pointer. The pointer is then passed to a function
    (`call_vfunc`), which uses the pointer to call `vfunc3`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，一个 `SubClass` 对象被动态创建，并将其地址保存在一个 `BaseClass` 指针中。然后，指针被传递给一个函数（`call_vfunc`），该函数使用该指针调用
    `vfunc3`：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Since `vfunc3` is a virtual function and `bc` points to a `SubClass` object,
    the compiler must ensure that `SubClass::vfunc3` is called. The following disassembly
    of a 32-bit, Microsoft C++ version of `call_vfunc` demonstrates how the virtual
    function call is resolved:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `vfunc3` 是一个虚拟函数，而 `bc` 指向一个 `SubClass` 对象，编译器必须确保调用 `SubClass::vfunc3`。以下是
    `call_vfunc` 的 32 位 Microsoft C++ 版本反汇编，演示了如何解析虚拟函数调用：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The vftable pointer (the address of `SubClass`’s vftable) is read from the structure
    and saved in `EDX` ➊. Next, the `this` pointer is moved into `ECX` ➋. Then, the
    vftable is indexed to read the third pointer (the address of `SubClass::vfunc3`
    in this case) into the `EAX` register ➌. Finally, the virtual function is called
    ➍.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: vftable 指针（`SubClass` 的 vftable 地址）从结构体中读取并保存在 `EDX` 中 ➊。接下来，`this` 指针被移动到 `ECX`
    中 ➋。然后，vftable 被索引，读取第三个指针（在此情况下为 `SubClass::vfunc3` 的地址）到 `EAX` 寄存器中 ➌。最后，虚拟函数被调用
    ➍。
- en: The vftable indexing operation ➌ looks very much like a structure reference
    operation. In fact, it is no different, and it is possible to define new structures
    for the class and its vftable (right-click in the Data Type Manager window) and
    then use the defined structures (see [Figure 8-14](ch08.xhtml#fig8_14)) to make
    the disassembly and decompilation more readable.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: vftable 索引操作 ➌ 看起来非常像结构体引用操作。事实上，它与结构体引用操作没有区别，您可以为类及其 vftable 定义新的结构体（在数据类型管理器窗口右键单击），然后使用定义的结构体（见
    [图 8-14](ch08.xhtml#fig8_14)）使反汇编和反编译结果更加易读。
- en: '![image](Images/fig8-14.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig8-14.jpg)'
- en: '*Figure 8-14: Data Manager Window showing new* SubClass *and* SubClass_vftable'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-14：数据管理器窗口显示新的* SubClass *和* SubClass_vftable'
- en: The Decompiler window with references to the new structures is shown in [Figure
    8-15](ch08.xhtml#fig8_15).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 反编译器窗口显示了包含新结构的引用，如 [图 8-15](ch08.xhtml#fig8_15) 所示。
- en: '![image](Images/fig8-15.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig8-15.jpg)'
- en: '*Figure 8-15: Decompiler window reflecting defined structures for* SubClass'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-15：反编译器窗口反映了* SubClass 的定义结构'
- en: 'A class’s vftable is referenced directly in only two circumstances: within
    the class constructor(s) and destructor. When you locate a vftable, you can utilize
    Ghidra’s data cross-referencing capabilities (see [Chapter 9](ch09.xhtml#ch09))
    to quickly locate all constructors and destructors for the associated class.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 类的 vftable 仅在两种情况下直接引用：在类的构造函数和析构函数中。当你定位到 vftable 时，可以利用 Ghidra 的数据交叉引用功能（见
    [第 9 章](ch09.xhtml#ch09)）快速定位相关类的所有构造函数和析构函数。
- en: '***The Object Life Cycle***'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***对象生命周期***'
- en: Understanding the mechanism by which objects are created and destroyed can help
    to reveal object hierarchies and nested object relationships as well as quickly
    identify class constructor and destructor functions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 理解对象的创建和销毁机制有助于揭示对象层次结构和嵌套对象关系，并快速识别类的构造函数和析构函数。
- en: '**WHAT’S A CONSTRUCTOR?**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**构造函数是什么？**'
- en: A *class constructor function* is an initialization function that is invoked
    when a new object of that class is created. Constructors provide an opportunity
    to initialize variables within the class. The inverse of a constructor, a *destructor*,
    is called when an object goes out of scope or a dynamically allocated object is
    explicitly deleted. Destructor functions perform cleanup activities such as releasing
    resources like open file descriptors and dynamically allocated memory. Properly
    written destructors mitigate the potential for memory leaks.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*类构造函数*是一个初始化函数，在创建该类的新对象时会被调用。构造函数为类中的变量初始化提供了一个机会。构造函数的反向操作是*析构函数*，当对象超出作用域或动态分配的对象被显式删除时，会调用析构函数。析构函数执行清理工作，如释放资源（例如打开的文件描述符和动态分配的内存）。编写得当的析构函数可以减轻内存泄漏的潜在风险。'
- en: 'The storage class of an object determines when its constructor is called.^([1](footnotes.xhtml#ch08fn1))
    For global and statically allocated objects (static storage class), constructors
    are called during program startup prior to entry into the program’s `main` function.
    Constructors for stack-allocated objects (automatic storage class) are invoked
    when the object comes into scope within the function in which it is declared.
    In many cases, this will be immediately upon entry to the function in which it
    is declared. However, when an object is declared within a nested block statement,
    its constructor is not invoked until that block is entered, if it is entered at
    all. When an object is allocated dynamically in the program heap, its creation
    is a two-step process: the `new` operator is invoked to allocate the object’s
    memory and then the constructor is invoked to initialize the object. Microsoft
    C++ ensures that the result of `new` is not null prior to invoking the constructor,
    but GNU’s `g++` does not.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象的存储类别决定了其构造函数何时被调用。^([1](footnotes.xhtml#ch08fn1)) 对于全局和静态分配的对象（静态存储类别），构造函数在程序启动时被调用，即在进入程序的`main`函数之前。对于栈分配的对象（自动存储类别），当对象在声明它的函数作用域内可见时，构造函数会被调用。在许多情况下，这会在进入声明它的函数时立即发生。然而，当一个对象在嵌套的块语句中声明时，只有在进入该块时（如果真的进入的话），它的构造函数才会被调用。当对象在程序堆中动态分配时，它的创建是一个两步过程：首先调用`new`运算符分配对象的内存，然后调用构造函数来初始化对象。Microsoft
    C++确保在调用构造函数之前，`new`的结果不为null，但GNU的`g++`并不这样做。
- en: '**WHAT’S NEW?**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**新变化？**'
- en: The `new` operator is used for dynamic memory allocation in C++ in much the
    same way that `malloc` is used in C. It is used to allocate memory from the heap
    and allows a program to request space as needed during execution. The `new` operator
    is built into the C++ language, whereas `malloc` is merely a standard library
    function. Remember that C is a subset of C++, so you might see either in a C++
    program. The most notable difference between `malloc` and `new` is that invocations
    of `new` for object types will result in an implicit invocation of the object’s
    constructor, where memory returned by `malloc` is not initialized before it is
    made available to the caller.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`运算符用于C++中的动态内存分配，就像`malloc`在C中用于动态内存分配一样。它用于从堆中分配内存，并允许程序在执行过程中根据需要请求空间。`new`运算符是C++语言内建的，而`malloc`仅仅是一个标准库函数。请记住，C是C++的子集，因此你可能在C++程序中看到它们中的任何一个。`malloc`与`new`之间最显著的区别是，对于对象类型，`new`的调用会隐式地调用对象的构造函数，而`malloc`返回的内存在提供给调用者之前不会被初始化。'
- en: 'When a constructor executes, the following sequence of actions takes place:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当构造函数执行时，以下操作顺序会发生：
- en: If the class has a superclass, the superclass constructor is invoked.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类有超类，则会调用超类的构造函数。
- en: If the class has any virtual functions, the vftable pointer is initialized to
    point to the class’s vftable. This may overwrite a vftable pointer that was initialized
    in the superclass constructor, which is exactly the desired behavior.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类中有虚函数，vftable指针会被初始化为指向该类的vftable。这可能会覆盖在超类构造函数中初始化的vftable指针，这正是期望的行为。
- en: If the class has any data members that are themselves objects, the constructor
    for each of those data members is invoked.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类中有任何数据成员本身是对象，那么每个数据成员的构造函数都会被调用。
- en: Finally, the class constructor is executed. This is the C++ constructor code
    specified by the programmer of the class.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，类构造函数会执行。这是由类的程序员指定的C++构造函数代码。
- en: From a programmer’s perspective, constructors do not specify a return type or
    allow a value to be returned. Some compilers actually return `this` as a result
    that they may further utilize in the caller, but this is a compiler implementation
    detail and C++ programmers cannot access the returned value.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序员的角度来看，构造函数不指定返回类型，也不允许返回值。某些编译器实际上将`this`作为结果返回，并可能在调用者中进一步使用它，但这是编译器的实现细节，C++程序员无法访问返回的值。
- en: Destructors, as their name implies, are called at the end of an object’s lifetime.
    For global and static objects, destructors are called by cleanup code that is
    executed after the `main` function terminates. Destructors for stack-allocated
    objects are invoked as the objects go out of scope. Destructors for heap-allocated
    objects are invoked via the `delete` operator immediately before the memory allocated
    to the object is released.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数顾名思义，在对象生命周期结束时被调用。对于全局和静态对象，析构函数由在`main`函数终止后执行的清理代码调用。对于栈上分配的对象，析构函数在对象超出作用域时被调用。对于堆上分配的对象，析构函数通过`delete`操作符在释放对象所分配的内存之前立即调用。
- en: 'The actions performed by destructors mimic those performed by constructors,
    with the exception that they are performed in roughly reverse order:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数执行的操作与构造函数类似，唯一的区别是它们大致按照相反的顺序执行：
- en: If the class has any virtual functions, the vftable pointer for the object is
    restored to point to the vftable for the associated class. This is required in
    case a subclass had overwritten the vftable pointer as part of its creation process.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类有任何虚函数，对象的vftable指针会被恢复，指向与关联类对应的vftable。这是必须的，以防子类在其创建过程中覆盖了vftable指针。
- en: The programmer-specified code for the destructor executes.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序员指定的析构函数代码会被执行。
- en: If the class has any data members that are themselves objects, the destructor
    for each of those members is executed.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类有任何数据成员是对象，析构函数会依次执行这些成员的析构函数。
- en: Finally, if the object has a superclass, the superclass destructor is called.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果对象有父类，则会调用父类的析构函数。
- en: By understanding when superclass constructors and destructors are called, it
    is possible to trace an object’s inheritance hierarchy through the chain of calls
    to its related superclass functions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解何时调用父类的构造函数和析构函数，可以通过调用其相关父类函数的链条追踪对象的继承层次结构。
- en: '**I THINK YOU ARE OVERLOADED**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**我认为你超负荷了**'
- en: Overloaded functions are functions that share the same name but have different
    parameters. C++ requires that each version of an overloaded function differ from
    every other version in the sequence and/or quantity of parameter types that the
    function receives. In other words, while they share the same function name, each
    function prototype must be unique, and each overloaded function body can be uniquely
    identified within the disassembled binary. This is not to be confused with functions,
    such as `printf`, that take a variable number of arguments but are associated
    with a single function body.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 重载函数是指具有相同名称但参数不同的函数。C++要求每个重载函数版本在接收的参数类型的顺序和/或数量上与其他版本有所不同。换句话说，虽然它们共享相同的函数名，但每个函数原型必须是唯一的，每个重载函数体可以在反汇编的二进制文件中被唯一标识。这与如`printf`这样的函数不同，后者接收可变数量的参数，但仅与一个函数体关联。
- en: '***Name Mangling***'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***名称修饰***'
- en: 'Also called *name decoration*, *name mangling* is the mechanism C++ compilers
    use to distinguish among overloaded versions of a function. To generate unique,
    internal names for overloaded functions, compilers decorate the function name
    with additional characters that encode various pieces of information about the
    function: the namespace to which the function (or its owning class) belongs (if
    any), the class to which the function belongs (if any), and the parameter sequence
    (type and order) required to call the function.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 也叫做*名称装饰*，*名称修饰*是C++编译器用来区分重载函数版本的机制。为了为重载函数生成唯一的内部名称，编译器会通过附加字符修饰函数名，这些字符编码了函数的各种信息：函数（或其所属类）所在的命名空间（如果有的话）、函数所属的类（如果有的话），以及调用函数所需的参数顺序（类型和顺序）。
- en: Name mangling is a compiler implementation detail for C++ programs and, as such,
    is not part of the C++ language specification. Not unexpectedly, compiler vendors
    have developed their own, often-incompatible conventions for name mangling. Fortunately,
    Ghidra understands the name mangling conventions employed by Microsoft’s C++ compiler
    and GNU `g++` v3 (and later) as well as some other compilers. Ghidra provides
    names of the form `FUN_`address in place of the mangled name. Mangled names do
    carry valuable information regarding the signature of each function, and Ghidra
    includes this information in the Symbol Table window as well as propagating the
    information to the disassembly and other related windows. (To determine the signature
    of a function without a mangled name, you might need to conduct time-consuming
    analysis of the data flowing into and out of the function.)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 名称修饰是 C++ 程序的编译器实现细节，因此不是 C++ 语言规范的一部分。不出所料，编译器厂商开发了各自的、通常不兼容的名称修饰约定。幸运的是，Ghidra
    能理解 Microsoft C++ 编译器和 GNU `g++` v3（及之后版本）使用的名称修饰约定，以及其他一些编译器。Ghidra 用类似 `FUN_`地址
    的形式代替被修饰的名称。被修饰的名称确实携带有关每个函数签名的有价值信息，Ghidra 会将这些信息包含在符号表窗口中，并将其传播到反汇编和其他相关窗口。（要确定没有被修饰名称的函数签名，可能需要进行耗时的数据流分析，分析该函数的输入和输出数据。）
- en: '***Runtime Type Identification***'
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行时类型识别***'
- en: C++ provides operators to determine (`typeid`) and check (`dynamic_cast`) an
    object’s data type at runtime. To support these operations, C++ compilers must
    embed type-specific information, for each polymorphic class, within a program
    binary. When a `typeid` or `dynamic_cast` operation is performed at runtime, library
    routines reference the type-specific information in order to determine the exact
    runtime type of the polymorphic object being referenced. Unfortunately, as with
    name mangling, *Runtime Type Identification (RTTI)* is a compiler implementation
    detail rather than a language issue, and there is no standard means by which compilers
    implement RTTI capabilities.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 提供了操作符 (`typeid`) 用于确定和检查（`dynamic_cast`）对象在运行时的数据类型。为了支持这些操作，C++ 编译器必须在程序二进制文件中嵌入每个多态类的类型特定信息。当在运行时执行
    `typeid` 或 `dynamic_cast` 操作时，库函数会引用类型特定信息以确定所引用的多态对象的确切运行时类型。不幸的是，和名称修饰一样，*运行时类型识别（RTTI）*
    是编译器的实现细节，而不是语言问题，并且没有标准的方式来实现 RTTI 功能。
- en: We will take a brief look at the similarities and differences between the RTTI
    implementations of Microsoft’s C++ compiler and GNU `g++`. Specifically, we’ll
    describe how to locate RTTI information and, from there, how to learn the name
    of the class to which that information pertains. Readers desiring more detailed
    discussion of Microsoft’s RTTI implementation should consult the references listed
    at the end of this chapter. In particular, the references detail how to traverse
    a class’s inheritance hierarchy, including how to trace that hierarchy when multiple
    inheritance is being used.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要介绍 Microsoft C++ 编译器和 GNU `g++` 在 RTTI 实现上的相似性与差异性。具体而言，我们将描述如何定位 RTTI
    信息，并从中了解与该信息相关的类名。希望获得更详细讨论的读者可以参考本章末尾列出的参考文献，特别是那些文献详细描述了如何遍历类的继承层次结构，包括在使用多重继承时如何追踪该层次结构。
- en: 'Consider the following simple program, which uses polymorphism:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下简单程序，它使用了多态：
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `print_type` function ➊ prints the type of the object being pointed to by
    the pointer `p`. In this case, it must print `"concrete_class"` since a `concrete``_class`
    object is created in the `main` function ➋. How does `print_type`, and more specifically
    `typeid`, know what type of object `p` is pointing to?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_type` 函数 ➊ 打印指针 `p` 所指向对象的类型。在这种情况下，它必须打印 `"concrete_class"`，因为在 `main`
    函数 ➋ 中创建了一个 `concrete_class` 对象。那么 `print_type`，更具体地说，`typeid` 是如何知道 `p` 指向的是什么类型的对象呢？'
- en: The answer is surprisingly simple. Since every polymorphic object contains a
    pointer to a vftable, compilers leverage that fact by co-locating class-type information
    with the class vftable. Specifically, the compiler places a pointer, immediately
    prior to the class vftable, that points to a structure containing information
    about the class that owns the vftable. In GNU `g++` code, this pointer points
    to a `type_info` structure, which contains a pointer to the name of the class.
    In Microsoft C++ code, the pointer points to a Microsoft `RTTICompleteObjectLocator`
    structure, which in turn contains a pointer to a `TypeDescriptor` structure. The
    `TypeDescriptor` structure contains a character array that specifies the name
    of the polymorphic class.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 答案出奇地简单。由于每个多态对象都包含指向vftable的指针，编译器利用这一事实将类类型信息与类的vftable放置在一起。具体而言，编译器会在类的vftable之前立即放置一个指针，该指针指向一个包含关于拥有该vftable的类的信息的结构体。在GNU
    `g++`代码中，该指针指向一个`type_info`结构，该结构包含指向类名的指针。在Microsoft C++代码中，指针指向Microsoft的`RTTICompleteObjectLocator`结构，该结构又包含指向`TypeDescriptor`结构的指针。`TypeDescriptor`结构包含一个字符数组，指定多态类的名称。
- en: RTTI information is required only in C++ programs that use the `typeid` or `dynamic_cast`
    operator. Most compilers provide options to disable the generation of RTTI in
    binaries that do not require it; therefore, you should not be surprised if you
    encounter compiled binaries that contain no RTTI information even though vftables
    are present.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在使用`typeid`或`dynamic_cast`运算符的C++程序中，才需要RTTI信息。大多数编译器提供了选项，允许在不需要RTTI的二进制文件中禁用RTTI的生成；因此，如果你遇到的编译后的二进制文件中没有RTTI信息，而vftable却存在，也不必感到惊讶。
- en: For C++ programs built with Microsoft’s C++ compiler, Ghidra contains an RTTI
    analyzer that is enabled by default and that is capable of identifying Microsoft
    RTTI structures, annotating those structures (if present) in the disassembly listing,
    and utilizing class names recovered from those RTTI structures in the Symbol Tree’s
    *Classes* folder. Ghidra has no RTTI analyzer for non-Windows binaries. When Ghidra
    encounters an unstripped, non-Windows binary, if it understands the name mangling
    scheme employed in the binary, then Ghidra utilizes available name information
    to populate the Symbol Tree’s *Classes* folder. If a non-Windows binary has been
    stripped, Ghidra will not be able to automatically recover any class names or
    identify vftables or RTTI information.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用Microsoft C++编译器构建的C++程序，Ghidra包含一个默认启用的RTTI分析器，能够识别Microsoft的RTTI结构，标注这些结构（如果存在）在反汇编清单中，并在符号树的*Classes*文件夹中利用从这些RTTI结构中恢复的类名。Ghidra没有非Windows二进制文件的RTTI分析器。当Ghidra遇到一个未剥离的非Windows二进制文件时，如果它理解该二进制文件使用的名称重整方案，Ghidra会利用可用的名称信息填充符号树的*Classes*文件夹。如果一个非Windows二进制文件已经被剥离，Ghidra将无法自动恢复任何类名或识别vftable或RTTI信息。
- en: '***Inheritance Relationships***'
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***继承关系***'
- en: It is possible to unravel inheritance relationships by using a compiler’s particular
    implementation of RTTI, but RTTI may not be present when a program does not utilize
    the `typeid` or `dynamic_cast` operators. Lacking RTTI information, what techniques
    can be employed to determine inheritance relationships among C++ classes?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用编译器特定实现的RTTI，确实可以解开继承关系，但如果程序没有使用`typeid`或`dynamic_cast`运算符，则RTTI可能不存在。没有RTTI信息的情况下，可以使用什么技术来确定C++类之间的继承关系呢？
- en: The simplest method to determine an inheritance hierarchy is to observe the
    chain of calls to superclass constructors that are called when an object is created.
    The single biggest hindrance to this technique is the use of inline constructors.
    In C/C++, a function declared as `inline` is usually treated as a macro by the
    compiler, and the code for the function is expanded in place of an explicit function
    call. Inline functions hide the fact that a function is being used, since no assembly
    language call statement will be generated. This makes it challenging to understand
    that a superclass constructor has in fact been called.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 确定继承层次结构的最简单方法是观察在创建对象时调用的父类构造函数的调用链。使用内联构造函数是这一技术的最大障碍。在C/C++中，被声明为`inline`的函数通常会被编译器当作宏处理，函数的代码会被扩展到显式函数调用的位置。内联函数隐藏了函数被调用的事实，因为不会生成任何汇编语言的调用语句。这使得理解父类构造函数是否被调用变得具有挑战性。
- en: 'The analysis and comparison of vftables can also reveal inheritance relationships.
    For example, in comparing the vftables shown in [Figure 8-14](ch08.xhtml#fig8_14),
    we note that the vftable for `SubClass` contains two of the same pointers that
    appear in the vftable for `BaseClass`, and we conclude that `BaseClass` and `SubClass`
    must be related in some way. To understand which one is the base class and which
    one is the subclass, we can apply the following guidelines, singly or in combination:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对vftable的分析和比较也能揭示继承关系。例如，在比较[图8-14](ch08.xhtml#fig8_14)中显示的vftable时，我们注意到`SubClass`的vftable包含了在`BaseClass`的vftable中出现的两个相同的指针，我们由此得出结论，`BaseClass`和`SubClass`之间一定存在某种关系。为了理解哪个是基类，哪个是子类，我们可以应用以下准则，单独使用或组合使用：
- en: When two vftables contain the same number of entries, the two corresponding
    classes *may* be involved in an inheritance relationship.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当两个vftable包含相同数量的条目时，这两个相应的类*可能*涉及到继承关系。
- en: When the vftable for class X contains more entries than the vftable for class
    Y, class X *may* be a subclass of class Y.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当类X的vftable包含的条目比类Y的vftable多时，类X*可能*是类Y的子类。
- en: 'When the vftable for class X contains entries that are also found in the vftable
    for class Y, then one of the following relationships must exist: X is a subclass
    of Y, Y is a subclass of X, or X and Y are both subclasses of a common superclass
    Z.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当类X的vftable包含在类Y的vftable中也存在的条目时，必须存在以下关系之一：X是Y的子类，Y是X的子类，或者X和Y都是共同基类Z的子类。
- en: When the vftable for class X contains entries that are also found in the vftable
    for class Y and the vftable for class X contains at least one `purecall` entry
    that is not also present in the corresponding vftable entry for class Y, then
    class Y is likely to be a subclass of class X.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当类X的vftable包含的条目也出现在类Y的vftable中，并且类X的vftable包含至少一个`purecall`条目，而该条目在类Y的相应vftable条目中不存在时，类Y很可能是类X的子类。
- en: While the preceding list is by no means all-inclusive, we can use these guidelines
    to deduce the relationship between `BaseClass` and `SubClass` in [Figure 8-14](ch08.xhtml#fig8_14).
    In this case, the last three rules all apply, but the last rule specifically leads
    us to conclude, based on vftable analysis alone, that `SubClass` inherits from
    `BaseClass`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的列表并非详尽无遗，但我们可以使用这些准则来推断[图8-14](ch08.xhtml#fig8_14)中`BaseClass`和`SubClass`之间的关系。在这种情况下，最后三个规则都适用，但最后一条规则特别引导我们得出结论，单凭vftable分析，我们可以推断`SubClass`继承自`BaseClass`。
- en: '***C++ Reverse Engineering References***'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***C++ 反向工程参考***'
- en: Several excellent references exist on reverse engineering compiled C++.^([2](footnotes.xhtml#ch08fn2))
    While many of the details in each of these articles apply specifically to programs
    compiled using Microsoft’s C++ compiler, many of the concepts apply equally to
    programs compiled using other C++ compilers.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 关于反向工程编译后的C++程序，存在若干优秀的参考资料。^([2](footnotes.xhtml#ch08fn2))虽然这些文章中的许多细节专门适用于使用微软C++编译器编译的程序，但许多概念同样适用于使用其他C++编译器编译的程序。
- en: '**Summary**'
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: You can expect to encounter complex data types in all but the most trivial programs.
    Understanding how data within data structures is accessed and knowing how to recognize
    clues to the layout of those data structures is an essential reverse engineering
    skill. Ghidra provides a wide variety of features designed specifically to deal
    with data structures. Familiarity with these features will greatly enhance your
    ability to comprehend what data is being manipulated and spend more time understanding
    how and why that data is being manipulated. In the next chapter, we continue our
    discussion of Ghidra’s basic capabilities with an in-depth look at cross-references.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以预期在几乎所有非简单程序中都会遇到复杂数据类型。理解数据结构中数据的访问方式，以及如何识别数据结构布局的线索，是反向工程的重要技能。Ghidra提供了多种专门用于处理数据结构的功能。熟悉这些功能将大大增强你理解正在操作的数据的能力，并让你有更多时间去理解数据是如何以及为什么被操作的。在下一章，我们将继续讨论Ghidra的基本功能，深入探讨交叉引用。
