- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Common API Vulnerabilities
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的 API 漏洞
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'Understanding common vulnerabilities will help you identify weaknesses when
    you’re testing APIs. In this chapter, I cover most of the vulnerabilities included
    in the Open Web Application Security Project (OWASP) API Security Top 10 list,
    plus two other useful weaknesses: information disclosure and business logic flaws.
    I’ll describe each vulnerability, its significance, and the techniques used to
    exploit it. In later chapters, you’ll gain hands-on experience finding and exploiting
    many of these vulnerabilities.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 了解常见的漏洞将帮助你在测试 API 时识别弱点。在本章中，我将介绍 Open Web Application Security Project（OWASP）API
    安全十大漏洞列表中的大部分漏洞，以及另外两个有用的弱点：信息泄露和业务逻辑缺陷。我将描述每个漏洞、其重要性以及利用这些漏洞的技术。在后续章节中，你将通过实践获得发现和利用这些漏洞的经验。
- en: Information Disclosure
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息泄露
- en: When an API and its supporting software share sensitive information with unprivileged
    users, the API has an *information disclosure* vulnerability. Information may
    be disclosed in API responses or public sources such as code repositories, search
    results, news, social media, the target’s website, and public API directories.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当 API 及其支持的软件与无权限的用户共享敏感信息时，该 API 存在*信息泄露*漏洞。信息可能通过 API 响应或公共资源（如代码库、搜索结果、新闻、社交媒体、目标网站和公共
    API 目录）泄露。
- en: 'Sensitive data can include any information that attackers can leverage to their
    advantage. For example, a site that is using the WordPress API may unknowingly
    be sharing user information with anyone who navigates to the API path */wp-json/wp/v2/users*,
    which returns all the WordPress usernames, or “slugs.” For instance, take a look
    at the following request:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 敏感数据可以包括攻击者能够利用的任何信息。例如，一个使用 WordPress API 的网站可能在不知情的情况下将用户信息与任何访问 API 路径 */wp-json/wp/v2/users*
    的人共享，该路径返回所有 WordPress 用户名或“别名”。例如，看看以下请求：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It might return this data:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能返回以下数据：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These slugs can then be used in an attempt to log in as the disclosed users
    with a brute-force, credential-stuffing, or password-spraying attack. (Chapter
    8 describes these attacks in detail.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些别名可以用于尝试通过暴力破解、凭证填充或密码喷洒攻击登录已泄露的用户账户。（第八章详细描述了这些攻击。）
- en: Another common information disclosure issue involves verbose messaging. Error
    messaging helps API consumers troubleshoot their interactions with an API and
    allows API providers to understand issues with their application. However, it
    can also reveal sensitive information about resources, users, and the API’s underlying
    architecture (such as the version of the web server or database). For example,
    say you attempt to authenticate to an API and receive an error message such as
    “the provided user ID does not exist.” Next, say you use another email and the
    error message changes to “incorrect password.” This lets you know that you’ve
    provided a legitimate user ID for the API.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的信息泄露问题涉及详细的错误信息。错误消息帮助 API 使用者排查与 API 的交互问题，并让 API 提供者理解应用程序的问题。然而，它也可能暴露有关资源、用户和
    API 基础架构的敏感信息（如 web 服务器或数据库的版本）。例如，假设你尝试认证到一个 API 并收到错误消息“提供的用户 ID 不存在”。接下来，假设你使用另一个电子邮件地址，错误消息变为“密码不正确”。这就让你知道你已经提供了一个有效的
    API 用户 ID。
- en: 'Finding user information is a great way to start gaining access to an API.
    The following information can also be leveraged in an attack: software packages,
    operating system information, system logs, and software bugs. Generally, any information
    that can help us find more severe vulnerabilities or assist in exploitation can
    be considered an information disclosure vulnerability.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查找用户信息是开始访问 API 的一个好方法。以下信息也可以在攻击中被利用：软件包、操作系统信息、系统日志和软件漏洞。通常，任何可以帮助我们找到更严重漏洞或协助利用的
    信息，都可以视为信息泄露漏洞。
- en: Often, you can gather the most information by interacting with an API endpoint
    and analyzing the response. API responses can reveal information within headers,
    parameters, and verbose errors. Other good sources of information are API documentation
    and resources gathered during reconnaissance. Chapter 6 covers many of the tools
    and techniques used for discovering API information disclosures.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通过与 API 端点交互并分析响应，你可以收集到最多的信息。API 响应可以揭示头部、参数和详细错误中的信息。其他好的信息来源包括 API 文档以及在侦察过程中收集的资源。第六章介绍了许多用于发现
    API 信息泄露的工具和技术。
- en: Broken Object Level Authorization
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误的对象级别授权
- en: One of the most prevalent vulnerabilities in APIs is *broken object level authorization
    (BOLA)*. BOLA vulnerabilities occur when an API provider allows an API consumer
    access to resources they are not authorized to access. If an API endpoint does
    not have object-level access controls, it won’t perform checks to make sure users
    can only access their own resources. When these controls are missing, User A will
    be able to successfully request User B’s resources.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: API 中最常见的漏洞之一是 *破坏的对象级授权（BOLA）*。BOLA 漏洞发生在 API 提供方允许 API 消费者访问他们未被授权访问的资源时。如果一个
    API 端点没有对象级访问控制，它将不会检查以确保用户只能访问他们自己的资源。当这些控制缺失时，用户 A 将能够成功请求用户 B 的资源。
- en: 'APIs use some sort of value, such as names or numbers, to identify various
    objects. When we discover these object IDs, we should test to see if we can interact
    with the resources of other users when unauthenticated or authenticated as a different
    user. For instance, imagine that we are authorized to access only the user Cloud
    Strife. We would send an initial GET request to *https://bestgame.com/api/v3/users?id=5501*
    and receive the following response:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: API 使用某种值，如名称或数字，来识别不同的对象。当我们发现这些对象的 ID 时，我们应该测试是否可以在未认证或以其他用户身份认证的情况下与其他用户的资源进行交互。例如，假设我们只被授权访问用户
    Cloud Strife 的信息。我们将向 *https://bestgame.com/api/v3/users?id=5501* 发送初始的 GET 请求，并收到以下响应：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This poses no problem since we are authorized to access Cloud’s information.
    However, if we are able to access another user’s information, there is a major
    authorization issue.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会构成问题，因为我们被授权访问 Cloud 的信息。然而，如果我们能够访问其他用户的信息，则存在一个严重的授权问题。
- en: 'In this situation, we might check for these problems by using another identification
    number that is close to Cloud’s ID of 5501\. Say we are able to obtain information
    about another user by sending a request for *https://bestgame.com/api/v3/users?id=5502*
    and receiving the following response:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能会通过使用接近 Cloud 的 ID 5501 的另一个标识号来检查这些问题。假设我们能够通过发送请求 *https://bestgame.com/api/v3/users?id=5502*
    并收到以下响应来获取其他用户的信息：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, Cloud has discovered a BOLA. Note that predictable object IDs
    don’t necessarily indicate that you’ve found a BOLA. For the application to be
    vulnerable, it must fail to verify that a given user is only able to access their
    own resources.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，Cloud 发现了一个 BOLA。请注意，可预测的对象 ID 并不一定表明你发现了 BOLA。为了使应用程序容易受到攻击，必须未能验证某个用户只能访问他们自己的资源。
- en: 'In general, you can test for BOLAs by understanding how an API’s resources
    are structured and attempting to access resources you shouldn’t be able to access.
    By detecting patterns within API paths and parameters, you should be able to predict
    other potential resources. The bolded elements in the following API requests should
    catch your attention:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你可以通过了解 API 的资源结构并尝试访问你不应访问的资源来测试 BOLA。通过在 API 路径和参数中检测模式，你应该能够预测其他潜在的资源。以下
    API 请求中的加粗部分应该引起你的注意：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In these instances, you can probably guess other potential resources, like
    the following, by altering the bolded values:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，你可能通过更改加粗的值来猜测其他潜在的资源，如下所示：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In these simple examples, you’ve performed an attack by merely replacing the
    bolded items with other numbers or words. If you can successfully access information
    you shouldn’t be authorized to access, you have discovered a BOLA vulnerability.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些简单的示例中，你只是通过用其他数字或词语替换加粗的部分执行了攻击。如果你能够成功访问不应有权限访问的信息，那么你就发现了 BOLA 漏洞。
- en: In Chapter 9, I will demonstrate how you can easily fuzz parameters like *user_id=*
    in the URL path and sort through the results to determine if a BOLA vulnerability
    exists. In Chapter 10, we will focus on attacking authorization vulnerabilities
    like BOLA and BFLA (broken function level authorization, discussed later in this
    chapter). BOLA can be a low-hanging API vulnerability that you can easily discover
    using pattern recognition and then prodding it with a few requests. Other times,
    it can be quite complicated to discover due to the complexities of object IDs
    and the requests used to obtain another user’s resources.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 9 章，我将演示如何轻松地对 URL 路径中的 *user_id=* 等参数进行模糊测试，并整理结果以判断是否存在 BOLA 漏洞。在第 10 章，我们将重点讨论攻击像
    BOLA 和 BFLA（功能级别授权失败，稍后在本章讨论）这样的授权漏洞。BOLA 可能是一个低门槛的 API 漏洞，你可以通过模式识别轻松发现它，并通过几个请求来测试。有时，由于对象
    ID 和用于获取其他用户资源的请求的复杂性，它可能变得相当难以发现。
- en: Broken User Authentication
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户认证失效
- en: '*Broken user authentication* refers to *any* weakness within the API authentication
    process. These vulnerabilities typically occur when an API provider either doesn’t
    implement an authentication protection mechanism or implements a mechanism incorrectly.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户认证失效*指的是API认证过程中存在的*任何*弱点。这些漏洞通常发生在API提供方未实现认证保护机制或错误地实现了机制时。'
- en: API authentication can be a complex system that includes several processes with
    a lot of room for failure. A couple decades ago, security expert Bruce Schneier
    said, “The future of digital systems is complexity, and complexity is the worst
    enemy of security.” As we know from the six constraints of REST APIs discussed
    in Chapter 2, RESTful APIs are supposed to be stateless. In order to be stateless,
    the provider shouldn’t need to remember the consumer from one request to another.
    For this constraint to work, APIs often require users to undergo a registration
    process in order to obtain a unique token. Users can then include the token within
    requests to demonstrate that they’re authorized to make such requests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: API 认证可能是一个复杂的系统，包含多个过程，且有很大的失败空间。几十年前，安全专家布鲁斯·施奈尔（Bruce Schneier）曾说：“数字系统的未来是复杂性的，而复杂性是安全性的最大敌人。”正如我们在第二章讨论的
    REST API 六大约束所知，RESTful API 应该是无状态的。为了实现无状态，提供方不应该需要记住消费者从一次请求到另一次请求的状态。为了使这一约束生效，API
    通常要求用户经过注册过程，以获得一个独特的令牌。用户随后可以在请求中包含该令牌，以证明他们有权限进行这些请求。
- en: As a consequence, the registration process used to obtain an API token, the
    token handling, and the system that generates the token could all have their own
    sets of weaknesses. To determine if the *token generation process* is weak, for
    example, we could collect a sampling of tokens and analyze them for similarities.
    If the token generation process doesn’t rely on a high level of randomness, or
    entropy, there is a chance we’ll be able to create our own token or hijack someone
    else’s.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，用于获取 API 令牌的注册过程、令牌的处理方式以及生成令牌的系统都可能存在各自的弱点。例如，为了确定*令牌生成过程*是否脆弱，我们可以收集一批令牌并分析它们的相似性。如果令牌生成过程不依赖于高水平的随机性或熵值，那么我们有可能自己创建一个令牌，或者劫持他人的令牌。
- en: '*Token handling* could be the storage of tokens, the method of transmitting
    tokens across a network, the presence of hardcoded tokens, and so on. We might
    be able to detect hardcoded tokens in JavaScript source files or capture them
    as we analyze a web application. Once we’ve captured a token, we can use it to
    gain access to previously hidden endpoints or to bypass detection. If an API provider
    attributes an identity to a token, we would then take on the identity by hijacking
    the stolen token.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*令牌处理*可能包括令牌的存储、通过网络传输令牌的方法、硬编码令牌的存在等。我们可能在分析 Web 应用时，检测到 JavaScript 源文件中的硬编码令牌，或者直接捕获它们。一旦我们捕获到令牌，就可以用它来访问以前隐藏的端点，或者绕过检测。如果
    API 提供商将身份归属于令牌，我们就能通过劫持被盗的令牌来获取该身份。'
- en: The other authentication processes that could have their own set of vulnerabilities
    include aspects of the *registration system*, such as the password reset and multifactor
    authentication features. For example, imagine a password reset feature requires
    you to provide an email address and a six-digit code to reset your password. Well,
    if the API allowed you to make as many requests as you wanted, you’d only have
    to make one million requests in order to guess the code and reset any user’s password.
    A four-digit code would require only 10,000 requests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能存在漏洞的认证过程包括*注册系统*的各个方面，例如密码重置和多因素认证功能。例如，假设一个密码重置功能要求你提供电子邮件地址和六位数字验证码来重置密码。如果
    API 允许你进行任意数量的请求，你只需进行一百万次请求，就可以猜到验证码并重置任何用户的密码。而四位数字验证码只需进行10,000次请求。
- en: 'Also watch for the ability to access sensitive resources without being authenticated;
    API keys, tokens, and credentials used in URLs; a lack of rate-limit restrictions
    when authenticating; and verbose error messaging. For example, code committed
    to a GitHub repository could reveal a hardcoded admin API key:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还需注意是否可以在未经认证的情况下访问敏感资源；API 密钥、令牌和凭证是否出现在 URL 中；认证时是否缺少速率限制；以及是否存在冗长的错误信息。例如，提交到
    GitHub 仓库的代码可能会暴露硬编码的管理员 API 密钥：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Due to the stateless nature of REST APIs, a publicly exposed API key is the
    equivalent of discovering a username and password. By using an exposed API key,
    you’ll assume the role associated with that key. In Chapter 6, we will use our
    reconnaissance skills to find exposed keys across the internet.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于REST API的无状态特性，公开暴露的API密钥相当于发现了用户名和密码。使用暴露的API密钥，攻击者将获得与该密钥关联的角色权限。在第六章中，我们将运用侦察技能，查找互联网上暴露的密钥。
- en: In Chapter 8, we will perform numerous attacks against API authentication, such
    as authentication bypass, brute-force attacks, credential stuffing, and a variety
    of attacks against tokens.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在第八章中，我们将对API身份验证进行多种攻击，例如身份验证绕过、暴力破解攻击、凭证填充攻击以及各种针对令牌的攻击。
- en: Excessive Data Exposure
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过度的数据暴露
- en: '*Excessive data exposure* is when an API endpoint responds with more information
    than is needed to fulfill a request. This often occurs when the provider expects
    the API consumer to filter results; in other words, when a consumer requests specific
    information, the provider might respond with all sorts of information, assuming
    the consumer will then remove any data they don’t need from the response. When
    this vulnerability is present, it can be the equivalent of asking someone for
    their name and having them respond with their name, date of birth, email address,
    phone number, and the identification of every other person they know.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*过度的数据暴露*是指API端点响应时返回了超过请求所需的信息。这通常发生在提供方期望API消费者进行结果筛选时；换句话说，当消费者请求特定信息时，提供方可能会返回各种信息，假设消费者会从响应中移除他们不需要的数据。当这种漏洞存在时，它就像是你问某人他们的名字，而他们却告诉你他们的名字、出生日期、电子邮件地址、电话号码以及他们认识的每一个人的身份。'
- en: 'For example, if an API consumer requests information for their user account
    and receives information about other user accounts as well, the API is exposing
    excessive data. Suppose I requested my own account information with the following
    request:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果API消费者请求他们自己的账户信息，但却收到了其他用户账户的信息，那么API就暴露了过多的数据。假设我请求了我的账户信息，且请求内容如下：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now say I got the following JSON in the response:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我在响应中得到了以下JSON：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I requested a single user’s account information, and the provider responded
    with information about the person who created my account, including the administrator’s
    full name, the admin’s ID number, and whether the admin had two-factor authentication
    enabled.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我请求了一个用户的账户信息，结果提供方返回了创建我账户的人的信息，包括管理员的全名、管理员的ID号，以及管理员是否启用了双重身份验证。
- en: Excessive data exposure is one of those awesome API vulnerabilities that bypasses
    every security control in place to protect sensitive information and hands it
    all to an attacker on a silver platter simply because they used the API. All you
    need to do to detect excessive data exposure is test your target API endpoints
    and review the information sent in response.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 过度的数据暴露是一个极其危险的API漏洞，它能够绕过所有的安全控制措施，保护敏感信息的方式完全失效，攻击者只需使用API，就能轻松获得所有数据。要检测过度的数据暴露，只需测试目标API端点并审查响应中发送的信息。
- en: Lack of Resources and Rate Limiting
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源不足和速率限制
- en: One of the more important vulnerabilities to test for is *lack of resources
    and rate limiting*. Rate limiting plays an important role in the monetization
    and availability of APIs. Without limiting the number of requests consumers can
    make, an API provider’s infrastructure could be overwhelmed by the requests. Too
    many requests without enough resources will lead to the provider’s systems crashing
    and becoming unavailable—a *denial of service (DoS)* state.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个需要测试的重要漏洞是*资源不足和速率限制*。速率限制在API的货币化和可用性中起着重要作用。如果不限制消费者可以发出的请求数量，API提供方的基础设施可能会被请求压垮。请求过多而资源不足将导致提供方的系统崩溃并变得不可用——这就是*拒绝服务（DoS）*状态。
- en: Besides potentially DoS-ing an API, an attacker who bypasses rate limits can
    cause additional costs for the API provider. Many API providers monetize their
    APIs by limiting requests and allowing paid customers to request more information.
    RapidAPI, for example, allows for 500 requests per month for free but 1,000 requests
    per month for paying customers. Some API providers also have infrastructure that
    automatically scales with the quantity of requests. In these cases, an unlimited
    number of requests would lead to a significant and easily preventable increase
    in infrastructure costs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可能造成API的拒绝服务（DoS）攻击外，绕过速率限制的攻击者还可能为API提供商带来额外的成本。许多API提供商通过限制请求次数来盈利，允许付费客户请求更多信息。例如，RapidAPI允许每月500次免费请求，但付费客户每月可请求1,000次。一些API提供商还具有自动扩展的基础设施，能够根据请求数量自动调节。在这些情况下，无限制的请求将导致基础设施成本的显著增加，这种情况是完全可以预防的。
- en: When testing an API that is supposed to have rate limiting, the first thing
    you should check is that rate limiting works, and you can do so by sending a barrage
    of requests to the API. If rate limiting is functioning, you should receive some
    sort of response informing you that you’re no longer able to make additional requests,
    usually in the form of an HTTP 429 status code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试应该具有速率限制的API时，你首先要检查的是速率限制是否有效，可以通过向API发送大量请求来进行验证。如果速率限制有效，你应该收到某种响应，告知你无法再发送额外请求，通常是HTTP
    429状态码的形式。
- en: Once you are restricted from making additional requests, it’s time to attempt
    to see how rate limiting is enforced. Can you bypass it by adding or removing
    a parameter, using a different client, or altering your IP address? Chapter 13
    includes various measures for attempting to bypass rate limiting.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你被限制不能再发送额外请求，接下来就可以尝试查看速率限制是如何被执行的。你能否通过添加或移除参数、使用不同的客户端，或更改IP地址来绕过速率限制？第13章介绍了绕过速率限制的各种方法。
- en: Broken Function Level Authorization
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能级别授权缺失（BFLA）
- en: '*Broken function level authorization (BFLA)* is a vulnerability where a user
    of one role or group is able to access the API functionality of another role or
    group. API providers will often have different roles for different types of accounts,
    such as public users, merchants, partners, administrators, and so on. A BFLA is
    present if you are able to use the functionality of another privilege level or
    group. In other words, BFLA can be a lateral move, where you use the functions
    of a similarly privileged group, or it could be a privilege escalation, where
    you are able to use the functions of a more privileged group. Particularly interesting
    API functions to access include those that deal with sensitive information, resources
    that belong to another group, and administrative functionality such as user account
    management.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*功能级别授权缺失（BFLA）*是一种漏洞，指的是某个角色或用户组的用户能够访问另一个角色或用户组的API功能。API提供商通常会为不同类型的账户设置不同的角色，比如公共用户、商户、合作伙伴、管理员等。如果你能够使用另一个特权级别或用户组的功能，就存在BFLA漏洞。换句话说，BFLA可能是一种横向移动，你使用的是具有相似权限的组的功能，或者它可能是特权升级，你能够使用更高权限组的功能。特别值得关注的API功能包括涉及敏感信息、属于其他组的资源，以及管理功能，如用户账户管理。'
- en: BFLA is similar to BOLA, except instead of an authorization problem involving
    accessing resources, it is an authorization problem for performing actions. For
    example, consider a vulnerable banking API. When a BOLA vulnerability is present
    in the API, you might be able to access the information of other accounts, such
    as payment histories, usernames, email addresses, and account numbers. If a BFLA
    vulnerability is present, you might be able to transfer money and actually update
    the account information. BOLA is about unauthorized access, whereas BFLA is about
    unauthorized actions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: BFLA类似于BOLA（业务对象级别授权缺失），不同之处在于它是一个关于执行操作的授权问题，而不是访问资源的授权问题。例如，考虑一个脆弱的银行API。当API存在BOLA漏洞时，你可能能够访问其他账户的信息，如支付历史、用户名、电子邮件地址和账户号码。如果存在BFLA漏洞，你可能能够进行转账，甚至更新账户信息。BOLA是关于未授权访问，而BFLA是关于未授权操作。
- en: If an API has different privilege levels or roles, it may use different endpoints
    to perform privileged actions. For example, a bank may use the */{user}/account/balance*
    endpoint for a user wishing to access their account information and the */admin/account/{user}*
    endpoint for an administrator wishing to access user account information. If the
    application does not have access controls implemented correctly, we’ll be able
    to perform administrative actions, such as seeing a user’s full account details,
    by simply making administrative requests.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 API 具有不同的权限级别或角色，它可能会使用不同的端点来执行特权操作。例如，一家银行可能会使用 */{user}/account/balance*
    端点来允许用户访问其帐户信息，而使用 */admin/account/{user}* 端点来允许管理员访问用户帐户信息。如果应用程序没有正确实施访问控制，我们将能够通过简单地发起管理员请求来执行管理操作，如查看用户的完整帐户详情。
- en: An API won’t always use administrative endpoints for administrative functionality.
    Instead, the functionality could be based on HTTP request methods such as GET,
    POST, PUT, and DELETE. If a provider doesn’t restrict the HTTP methods a consumer
    can use, simply making an unauthorized request with a different method could indicate
    a BFLA vulnerability.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 API 并不总是使用管理端点来执行管理功能。相反，这些功能可能基于 HTTP 请求方法，如 GET、POST、PUT 和 DELETE。如果提供者没有限制消费者可以使用的
    HTTP 方法，那么仅仅通过使用不同方法发起未经授权的请求，就可能表明存在 BFLA 漏洞。
- en: When hunting for BFLA, look for any functionality you could use to your advantage,
    including altering user accounts, accessing user resources, and gaining access
    to restricted endpoints. For example, if an API gives partners the ability to
    add new users to the partner group but does not restrict this functionality to
    the specific group, any user could add themselves to any group. Moreover, if we’re
    able to add ourselves to a group, there is a good chance we’ll be able to access
    that group’s resources.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找 BFLA 漏洞时，寻找任何可能对你有利的功能，包括修改用户帐户、访问用户资源和获取对受限端点的访问。例如，如果一个 API 允许合作伙伴向合作伙伴组添加新用户，但没有将此功能限制到特定的组，则任何用户都可以将自己添加到任何组中。而且，如果我们能够将自己添加到某个组，
    chances are we’ll be able to access that group’s resources。
- en: The easiest way to discover BFLA is to find administrative API documentation
    and send requests as an unprivileged user that test admin functions and capabilities.
    [Figure 3-1](#figure3-1) shows the public Cisco Webex Admin API documentation,
    which provides a handy list of actions to attempt if you were testing Cisco Webex.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 发现 BFLA 漏洞的最简单方法是找到管理 API 文档，并以没有特权的用户身份发起请求，测试管理员功能和能力。[图 3-1](#figure3-1)
    显示了公开的 Cisco Webex 管理 API 文档，它提供了一个方便的操作列表，供你测试 Cisco Webex 时尝试。
- en: '![Screenshot of a Cisco Webex documentation page titled “Admin API.” Includes
    links to a list of APIs for various actions, including “Create a user,” “Update
    a user,” “View license usage of an organization,” “View available roles of an
    organization,” “Manage Hybrid Services licenses and users,” and “View information
    about Hybrid Clusters or Hybrid Connectors.”](image_fi/502444c03/F03001.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![截图：Cisco Webex 文档页面，标题为“Admin API”。包括指向各种操作 API 的链接，如“创建用户”、“更新用户”、“查看组织的许可使用情况”、“查看组织的可用角色”、“管理混合服务许可证和用户”和“查看有关混合集群或混合连接器的信息。”](image_fi/502444c03/F03001.png)'
- en: 'Figure 3-1: The Cisco Webex Admin API documentation'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1：Cisco Webex 管理 API 文档
- en: As an unprivileged user, make requests included in the admin section, such as
    attempting to create users, update user accounts, and so on. If access controls
    are in place, you’ll likely receive an HTTP 401 Unauthorized or 403 Forbidden
    response. However, if you’re able to make successful requests, you have discovered
    a BFLA vulnerability.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个没有特权的用户，发起包含在管理员部分中的请求，例如尝试创建用户、更新用户帐户等。如果已实施访问控制，你很可能会收到 HTTP 401 Unauthorized
    或 403 Forbidden 响应。然而，如果你能够成功发起请求，那么你就发现了一个 BFLA 漏洞。
- en: If API documentation for privileged actions is not available, you will need
    to discover or reverse engineer the endpoints used to perform privileged actions
    before testing them; more on this in Chapter 7. Once you’ve found administrative
    endpoints, you can begin making requests.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有关于特权操作的 API 文档，你将需要发现或逆向工程用于执行特权操作的端点，然后再进行测试；更多内容将在第 7 章中讨论。一旦你找到管理端点，就可以开始发起请求。
- en: Mass Assignment
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大规模赋值
- en: '*Mass assignment* occurs when an API consumer includes more parameters in their
    requests than the application intended and the application adds these parameters
    to code variables or internal objects. In this situation, a consumer may be able
    to edit object properties or escalate privileges.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*大规模赋值*是指当 API 用户在请求中包含比应用程序预期更多的参数时，应用程序将这些参数添加到代码变量或内部对象中。在这种情况下，用户可能能够编辑对象属性或提升权限。'
- en: For example, an application might have account update functionality that the
    user should use only to update their username, password, and address. If the consumer
    can include other parameters in a request related to their account, such as the
    account privilege level or sensitive information like account balances, and the
    application accepts those parameters without checking them against a whitelist
    of permitted actions, the consumer could take advantage of this weakness to change
    these values.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个应用可能具有账户更新功能，用户应该仅用于更新用户名、密码和地址。如果用户可以在请求中包含其他与账户相关的参数，比如账户权限级别或敏感信息如账户余额，并且应用程序在没有将这些参数与允许的操作白名单进行检查的情况下接受这些参数，用户就可能利用这个漏洞修改这些值。
- en: 'Imagine an API is called to create an account with parameters for `"User"`
    and `"Password"`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个 API 被调用来创建一个账户，传递的参数为 `"User"` 和 `"Password"`：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'While reading the API documentation regarding the account creation process,
    suppose you discover that there is an additional key, `"isAdmin"`, that consumers
    can use to become administrators. You could use a tool like Postman or Burp Suite
    to add the attribute to a request and set the value to `true`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读有关账户创建过程的 API 文档时，假设你发现有一个额外的键 `"isAdmin"`，消费者可以用它来成为管理员。你可以使用像 Postman 或
    Burp Suite 这样的工具将该属性添加到请求中，并将值设置为 `true`：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the API does not sanitize the request input, it is vulnerable to mass assignment,
    and you could use the updated request to create an admin account. On the backend,
    the vulnerable web app will add the key/value attribute, `{"isAdmin":"true"}`,
    to the user object and make the user the equivalent of an administrator.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 API 没有清理请求输入，它就容易受到大规模赋值攻击，你可以利用更新后的请求创建一个管理员账户。在后端，易受攻击的 Web 应用会将键值对属性 `{"isAdmin":"true"}`
    添加到用户对象中，从而使用户成为管理员。
- en: You can discover mass assignment vulnerabilities by finding interesting parameters
    in API documentation and then adding those parameters to a request. Look for parameters
    involved in user account properties, critical functions, and administrative actions.
    Intercepting API requests and responses could also reveal parameters worthy of
    testing. Additionally, you can guess parameters or fuzz them in API requests.
    (Chapter 9 describes the art of fuzzing.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 API 文档中查找有趣的参数，并将这些参数添加到请求中，来发现大规模赋值漏洞。寻找涉及用户账户属性、关键功能和管理操作的参数。拦截 API
    请求和响应也可能揭示值得测试的参数。此外，你还可以猜测或模糊化 API 请求中的参数。（第 9 章讲述了模糊测试的技巧。）
- en: Security Misconfigurations
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全配置错误
- en: '*Security misconfigurations* include all the mistakes developers could make
    within the supporting security configurations of an API. If a security misconfiguration
    is severe enough, it can lead to sensitive information exposure or a complete
    system takeover. For example, if the API’s supporting security configuration reveals
    an unpatched vulnerability, there is a chance that an attacker could leverage
    a published exploit to easily “pwn” the API and its system.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*安全配置错误*包括开发者在 API 支持的安全配置中可能犯的所有错误。如果安全配置错误足够严重，它可能导致敏感信息泄露或系统完全被接管。例如，如果
    API 的安全配置暴露了一个未修补的漏洞，攻击者有可能利用发布的漏洞轻松“攻陷” API 及其系统。'
- en: Security misconfigurations are really a set of weaknesses that includes misconfigured
    headers, misconfigured transit encryption, the use of default accounts, the acceptance
    of unnecessary HTTP methods, a lack of input sanitization, and verbose error messaging.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 安全配置错误实际上是一组漏洞，包括配置错误的头部、配置错误的传输加密、使用默认账户、接受不必要的 HTTP 方法、缺乏输入清理以及冗长的错误消息。
- en: A *lack of input sanitization* can allow attackers to upload malicious payloads
    to the server. APIs often play a key role in automating processes, so imagine
    being able to upload payloads that the server automatically processes into a format
    that could be remotely executed or executed by an unsuspecting end user. For example,
    if an upload endpoint was used to pass uploaded files to a web directory, it could
    allow the upload of a script. Navigating to the URL where the file is located
    could launch the script, resulting in direct shell access to the web server. Additionally,
    lack of input sanitization can lead to unexpected behavior on the part of the
    application. In Part III, we will fuzz API inputs in attempts to discover vulnerabilities
    such as security misconfigurations, improper assets management, and injection
    weaknesses.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺乏输入净化* 可能使攻击者将恶意有效载荷上传到服务器。API 通常在自动化过程中起着关键作用，因此可以想象将有效载荷上传到服务器，服务器自动将其处理成可能被远程执行或被毫无防备的最终用户执行的格式。例如，如果上传端点用于将上传的文件传递到
    Web 目录，可能会允许上传脚本。访问该文件所在的 URL 可能会启动脚本，从而直接访问 Web 服务器的 shell。此外，缺乏输入净化还可能导致应用程序出现意外行为。在第三部分中，我们将模糊测试
    API 输入，尝试发现诸如安全配置错误、不当的资产管理和注入漏洞等问题。'
- en: 'API providers use *headers* to provide the consumer with instructions for handling
    the response and security requirements. Misconfigured headers can result in sensitive
    information disclosure, downgrade attacks, and cross-site scripting attacks. Many
    API providers will use additional services alongside their API to enhance API-related
    metrics or to improve security. It is fairly common for those additional services
    to add headers to requests for metrics and perhaps serve as some level of assurance
    to the consumer. For example, take the following response:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: API 提供者使用*头部*来向消费者提供处理响应和安全要求的指令。配置错误的头部可能导致敏感信息泄露、降级攻击和跨站脚本攻击。许多 API 提供者会在其
    API 旁边使用额外的服务来增强与 API 相关的指标或提高安全性。那些额外的服务常常会在请求中添加头部，以提供指标，并可能作为某种程度的保证。例如，以下是一个响应：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `X-Powered-By` header reveals backend technology. Headers like this one
    will often advertise the exact supporting service and its version. You could use
    information like this to search for exploits published for that version of software.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`X-Powered-By` 头部揭示了后端技术。像这样的头部通常会展示确切的支持服务及其版本。你可以利用这些信息搜索针对该版本软件发布的漏洞。'
- en: '`X-XSS-Protection` is exactly what it looks like: a header meant to prevent
    cross-site scripting (XSS) attacks. XSS is a common type of injection vulnerability
    where an attacker can insert scripts into a web page and trick end users into
    clicking malicious links. We will cover XSS and cross-API scripting (XAS) in Chapter
    12. An `X-XSS-Protection` value of `0` indicates no protections are in place,
    and a value of `1` indicates that protection is turned on. This header, and others
    like it, clearly reveals whether a security control is in place.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`X-XSS-Protection` 就是它看起来的样子：一个旨在防止跨站脚本（XSS）攻击的头部。XSS 是一种常见的注入漏洞，攻击者可以将脚本插入网页，并诱使最终用户点击恶意链接。在第
    12 章中，我们将讨论 XSS 和跨 API 脚本（XAS）。`X-XSS-Protection` 的值为 `0` 表示没有保护措施，而值为 `1` 表示已启用保护。这个头部，以及类似的头部，清楚地揭示了是否存在安全控制。'
- en: 'The `X-Response-Time` header is middleware that provides usage metrics. In
    the previous example, its value represents 566.43 milliseconds. However, if the
    API isn’t configured properly, this header can function as a side channel used
    to reveal existing resources. If the `X-Response-Time` header has a consistent
    response time for nonexistent records, for example, but increases its response
    time for certain other records, this could be an indication that those records
    exist. Here’s an example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`X-Response-Time` 头部是中间件，用于提供使用指标。在前面的示例中，它的值表示 566.43 毫秒。然而，如果 API 配置不当，这个头部可能作为一个旁路渠道，用于揭示现有资源。例如，如果
    `X-Response-Time` 头部对不存在的记录有一致的响应时间，但对某些其他记录的响应时间有所增加，这可能表明这些记录存在。以下是一个示例：'
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, UserC has a response time value that is 20 times the response
    time of the other resources. With this small sample size, it is hard to definitively
    conclude that UserC exists. However, imagine you have a sample of hundreds or
    thousands of requests and know the average `X-Response-Time` values for certain
    existing and nonexistent resources. Say, for instance, you know that a bogus account
    like */user/account/thisdefinitelydoesnotexist876* has an average `X-Response-Time`
    of 25.5 ms. You also know that your existing account */user/account/1021* receives
    an `X-Response-Time` of 510.00\. If you then sent requests brute-forcing all account
    numbers from 1000 to 2000, you could review the results and see which account
    numbers resulted in drastically increased response times.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，UserC 的响应时间值是其他资源响应时间的 20 倍。鉴于样本量较小，很难断定 UserC 是否存在。然而，假设你有数百或数千个请求的样本，并且知道某些存在和不存在的资源的平均
    `X-Response-Time` 值。例如，假设你知道一个虚假帐户，如 */user/account/thisdefinitelydoesnotexist876*，它的平均
    `X-Response-Time` 为 25.5 毫秒。你还知道你的现有帐户 */user/account/1021* 的 `X-Response-Time`
    为 510.00 毫秒。如果你接着对所有帐户编号从 1000 到 2000 进行暴力破解请求，你可以查看结果并看到哪些帐户编号导致响应时间急剧增加。
- en: Any API providing sensitive information to consumers should use Transport Layer
    Security (TLS) to encrypt the data. Even if the API is only provided internally,
    privately, or at a partner level, using TLS, the protocol that encrypts HTTPS
    traffic, is one of the most basic ways to ensure that API requests and responses
    are protected when being passed across a network. Misconfigured or missing transit
    encryption can cause API users to pass sensitive API information in cleartext
    across networks, in which case an attacker could capture the responses and requests
    with a man-in-the-middle (MITM) attack and read them plainly. The attacker would
    need to have access to the same network as the person they were attacking and
    then intercept the network traffic with a network protocol analyzer such as Wireshark
    to see the information being communicated between the consumer and the provider.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 任何向消费者提供敏感信息的 API 应该使用传输层安全协议（TLS）来加密数据。即使 API 仅在内部、私下或在合作伙伴层级提供，使用 TLS——这一加密
    HTTPS 流量的协议——也是确保 API 请求和响应在网络传输过程中得到保护的最基本方法之一。配置错误或缺失的传输加密可能导致 API 用户在网络中以明文形式传递敏感
    API 信息，在这种情况下，攻击者可以通过中间人（MITM）攻击捕获请求和响应并直接读取它们。攻击者需要能够访问与目标相同的网络，然后使用网络协议分析工具，如
    Wireshark，来截获网络流量，从而查看消费者与提供者之间传递的信息。
- en: When a service uses a *default account and credentials* and the defaults are
    known, an attacker can use those credentials to assume the role of that account.
    This could allow them to gain access to sensitive information or administrative
    functionality, potentially leading to a compromise of the supporting systems.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务使用*默认帐户和凭证*，并且默认凭证已知时，攻击者可以使用这些凭证假冒该帐户的角色。这可能使他们能够访问敏感信息或管理功能，从而潜在地导致支持系统的安全漏洞。
- en: Lastly, if an API provider allows *unnecessary HTTP methods*, there is an increased
    risk that the application won’t handle these methods properly or will result in
    sensitive information disclosure.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果 API 提供者允许*不必要的 HTTP 方法*，则增加了应用程序无法正确处理这些方法或导致敏感信息泄露的风险。
- en: You can detect several of these security misconfigurations with web application
    vulnerability scanners such as Nessus, Qualys, OWASP ZAP, and Nikto. These scanners
    will automatically check the web server version information, headers, cookies,
    transit encryption configuration, and parameters to see if expected security measures
    are missing. You can also check for these security misconfigurations manually,
    if you know what you are looking for, by inspecting the headers, SSL certificate,
    cookies, and parameters.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 web 应用程序漏洞扫描器（如 Nessus、Qualys、OWASP ZAP 和 Nikto）来检测这些安全配置错误。这些扫描器会自动检查
    web 服务器版本信息、头部、cookie、传输加密配置和参数，以查看是否缺少预期的安全措施。如果你知道查找的内容，也可以手动检查这些安全配置错误，通过检查头部、SSL
    证书、cookie 和参数来识别问题。
- en: Injections
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入攻击
- en: '*Injection flaws* exist when a request is passed to the API’s supporting infrastructure
    and the API provider doesn’t filter the input to remove unwanted characters (a
    process known as *input sanitization*). As a result, the infrastructure might
    treat data from the request as code and run it. When this sort of flaw is present,
    you’ll be able to conduct injection attacks such as SQL injection, NoSQL injection,
    and system command injection.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*注入漏洞* 出现的原因是请求被传递到 API 支持的基础设施时，API 提供者没有过滤输入以去除不需要的字符（这一过程被称为 *输入清理*）。因此，基础设施可能会将请求中的数据当作代码来执行。当这种漏洞存在时，你就能够进行注入攻击，如
    SQL 注入、NoSQL 注入和系统命令注入。'
- en: In each of these injection attacks, the API delivers your unsanitized payload
    directly to the operating system running the application or its database. As a
    result, if you send a payload containing SQL commands to a vulnerable API that
    uses a SQL database, the API will pass the commands to the database, which will
    process and perform the commands. The same will happen with vulnerable NoSQL databases
    and affected systems.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些注入攻击中，API 会将未清理的负载直接传递给运行应用程序或其数据库的操作系统。因此，如果你向一个使用 SQL 数据库的易受攻击的 API 发送包含
    SQL 命令的负载，API 会将这些命令传递给数据库，数据库会处理并执行这些命令。易受攻击的 NoSQL 数据库和受影响的系统也会发生类似的情况。
- en: 'Verbose error messaging, HTTP response codes, and unexpected API behavior can
    all be clues that you may have discovered an injection flaw. Say, for example,
    you were to send `OR 1=0--` as an address in an account registration process.
    The API may pass that payload directly to the backend SQL database, where the
    `OR 1=0` statement would fail (because 1 does not equal 0), causing some SQL error:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 详细的错误信息、HTTP 响应码和意外的 API 行为都可能是你发现注入漏洞的线索。举个例子，如果你在账户注册过程中发送了 `OR 1=0--` 作为地址，API
    可能会将该负载直接传递给后台的 SQL 数据库，在那里 `OR 1=0` 语句会失败（因为 1 不等于 0），从而引发 SQL 错误：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'An error in the backend database could show up as a response to the consumer.
    In this case, you might receive a response like “Error: You have an error in your
    SQL syntax. . . .” Any response directly from a database or the supporting system
    is a clear indicator that there is an injection vulnerability.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 后端数据库的错误可能会以响应的形式反馈给用户。在这种情况下，你可能会收到类似 “错误：你的 SQL 语法有误……” 的响应。任何直接来自数据库或支持系统的响应都是注入漏洞的明显指示。
- en: 'Injection vulnerabilities are often complemented by other vulnerabilities such
    as poor input sanitization. In the following example, you can see a code injection
    attack that uses an API GET request to take advantage of a weak query parameter.
    In this case, the weak query parameter passes any data in the query portion of
    the request directly to the underlying system, without sanitizing it first:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注入漏洞往往伴随其他漏洞，如输入清理不当。以下示例中，你可以看到一个代码注入攻击，它利用 API 的 GET 请求来利用一个弱查询参数。在这种情况下，弱查询参数将请求中的任何数据直接传递到底层系统，而不会首先进行清理：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following response body shows that the API endpoint has been manipulated
    into displaying the host’s */etc/passwd* file, revealing users on the system:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下响应体显示了 API 端点被篡改，显示了主机的 */etc/passwd* 文件，暴露了系统中的用户信息：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finding injection flaws requires diligently testing API endpoints, paying attention
    to how the API responds, and then crafting requests that attempt to manipulate
    the backend systems. Like directory traversal attacks, injection attacks have
    been around for decades, so there are many standard security controls to protect
    API providers from them. I will demonstrate various methods for performing injection
    attacks, encoding traffic, and bypassing standard controls in Chapters 12 and
    13.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 查找注入漏洞需要认真测试 API 端点，注意 API 的响应方式，然后构造尝试操控后台系统的请求。像目录遍历攻击一样，注入攻击已经存在了几十年，因此有许多标准的安全控制措施来保护
    API 提供者免受这些攻击。我将在第 12 章和第 13 章展示执行注入攻击、编码流量和绕过标准控制的方法。
- en: Improper Assets Management
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不当的资产管理
- en: '*Improper assets management* takes place when an organization exposes APIs
    that are either retired or still in development. As with any software, old API
    versions are more likely to contain vulnerabilities because they are no longer
    being patched and upgraded. Likewise, APIs that are still being developed are
    typically not as secure as their production API counterparts.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*不当资产管理* 是指组织暴露了已经退休或仍在开发中的 API。与任何软件一样，旧版 API 更容易存在漏洞，因为它们不再进行修补和升级。同样，仍在开发中的
    API 通常不如生产版 API 安全。'
- en: Improper assets management can lead to other vulnerabilities, such as excessive
    data exposure, information disclosure, mass assignment, improper rate limiting,
    and API injection. For attackers, this means that discovering an improper assets
    management vulnerability is only the first step toward further exploitation of
    an API.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不当资产管理可能导致其他漏洞，如过度数据暴露、信息泄露、大规模赋值、不当速率限制和 API 注入。对于攻击者来说，发现不当资产管理漏洞仅是进一步利用 API
    的第一步。
- en: You can discover improper assets management by paying close attention to outdated
    API documentation, changelogs, and version history on repositories. For example,
    if an organization’s API documentation has not been updated along with the API’s
    endpoints, it could contain references to portions of the API that are no longer
    supported. Organizations often include versioning information in their endpoint
    names to distinguish between older and newer versions, such as */v1/*, */v2/*,
    */v3/*, and so on. APIs still in development often use paths such as */alpha/*,
    */beta/*, */test/*, */uat/*, and */demo/*. If you know that an API is now using
    *apiv3.org/admin* but part of the API documentation refers to *apiv1.org/admin*,
    you could try testing different endpoints to see if *apiv1* or *apiv2* is still
    active. Additionally, the organization’s changelog may disclose the reasons why
    *v1* was updated or retired. If you have access to *v1*, you can test for those
    weaknesses.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过仔细关注过时的 API 文档、更新日志和仓库中的版本历史，发现不当的资产管理。例如，如果一个组织的 API 文档没有随着 API 的端点更新，它可能包含指向已不再支持的部分
    API 的引用。组织通常会在端点名称中包含版本信息，以区分旧版和新版，例如 */v1/*、*/v2/*、*/v3/* 等等。仍在开发中的 API 通常使用类似
    */alpha/*、*/beta/*、*/test/*、*/uat/* 和 */demo/* 的路径。如果你知道某个 API 当前使用 *apiv3.org/admin*，但部分
    API 文档仍提到 *apiv1.org/admin*，你可以尝试测试不同的端点，看看 *apiv1* 或 *apiv2* 是否仍然活跃。此外，组织的更新日志可能会透露
    *v1* 被更新或淘汰的原因。如果你能访问 *v1*，你可以测试这些弱点。
- en: Outside of using documentation, you can discover improper assets management
    vulnerabilities through the use of guessing, fuzzing, or brute-force requests.
    Watch for patterns in the API documentation or path-naming scheme, and then make
    requests based on your assumptions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过文档使用外，你还可以通过猜测、模糊测试或暴力请求来发现不当的资产管理漏洞。留意 API 文档或路径命名模式中的规律，然后基于你的假设进行请求。
- en: Business Logic Vulnerabilities
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务逻辑漏洞
- en: '*Business logic vulnerabilities* (also known as *business logic flaws*, or
    *BLFs*) are intended features of an application that attackers can use maliciously.
    For example, if an API has an upload feature that doesn’t validate encoded payloads,
    a user could upload any file as long as it was encoded. This would allow end users
    to upload and execute arbitrary code, including malicious payloads.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*业务逻辑漏洞*（也称为 *业务逻辑缺陷* 或 *BLFs*）是应用程序的预期功能，攻击者可以恶意利用它们。例如，如果一个 API 有一个上传功能，但没有验证编码后的负载，用户只要将文件编码后上传就可以。这将允许最终用户上传并执行任意代码，包括恶意负载。'
- en: Vulnerabilities of this sort normally come about from an assumption that API
    consumers will follow directions, be trustworthy, or only use the API in a certain
    way. In those cases, the organization essentially depends on trust as a security
    control by expecting the consumer to act benevolently. Unfortunately, even good-natured
    API consumers make mistakes that could lead to a compromise of the application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的漏洞通常源于假设 API 消费者会遵循指示、值得信任或仅以某种方式使用 API。在这些情况下，组织基本上依赖于信任作为一种安全控制，期望消费者行为良好。不幸的是，即便是心地善良的
    API 消费者也会犯错误，从而导致应用程序的安全性受到威胁。
- en: The Experian partner API leak, in early 2021, was a great example of an API
    trust failure. A certain Experian partner was authorized to use Experian’s API
    to perform credit checks, but the partner added the API’s credit check functionality
    to their web application and inadvertently exposed all partner-level requests
    to users. A request could be intercepted when using the partner’s web application,
    and if it included a name and address, the Experian API would respond with the
    individual’s credit score and credit risk factors. One of the leading causes of
    this business logic vulnerability was that Experian trusted the partner not to
    expose the API.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 2021 年初的 Experian 合作伙伴 API 泄漏事件就是一个 API 信任失败的典型例子。某个 Experian 合作伙伴被授权使用 Experian
    的 API 进行信用检查，但该合作伙伴将 API 的信用检查功能添加到了他们的 web 应用中，意外地将所有合作伙伴级别的请求暴露给用户。当使用该合作伙伴的
    web 应用时，请求可能会被拦截，如果请求中包含姓名和地址，Experian API 会返回该个人的信用分数和信用风险因素。造成这个业务逻辑漏洞的主要原因之一是
    Experian 信任合作伙伴不会暴露 API。
- en: Another problem with trust is that credentials, such as API keys, tokens, and
    passwords, are constantly being stolen and leaked. When a trusted consumer’s credentials
    are stolen, the consumer can become a wolf in sheep’s clothing and wreak havoc.
    Without strong technical controls in place, business logic vulnerabilities can
    often have the most significant impact, leading to exploitation and compromise.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关于信任的问题是，凭据，如 API 密钥、令牌和密码，经常被盗取和泄露。当一个受信任的消费者的凭据被盗时，该消费者就可能变成披着羊皮的狼，造成严重破坏。如果没有强有力的技术控制，业务逻辑漏洞往往会产生最大的影响，导致被利用和妥协。
- en: 'You can search API documentation for telltale signs of business logic vulnerabilities.
    Statements like the following should illuminate the lightbulb above your head:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以搜索 API 文档，寻找业务逻辑漏洞的明显迹象。像以下的声明应该能点亮你脑袋上的灯泡：
- en: “Only use feature X to perform function Y.”
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “仅使用功能 X 来执行功能 Y。”
- en: “Do not do X with endpoint Y.”
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “不要使用端点 Y 执行 X 操作。”
- en: “Only admins should perform request X.”
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “只有管理员应该执行请求 X。”
- en: These statements may indicate that the API provider is trusting that you won’t
    do any of the discouraged actions, as instructed. When you attack their API, make
    sure to disobey such requests to test for the presence of security controls.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些声明可能表明，API 提供商信任你不会执行任何被禁止的操作，如同指示的那样。当你攻击他们的 API 时，确保不遵守这些请求，以测试安全控制是否存在。
- en: Another business logic vulnerability comes about when developers assume that
    consumers will exclusively use a browser to interact with the web application
    and won’t capture API requests that take place behind the scenes. All it takes
    to exploit this sort of weakness is to intercept requests with a tool like Burp
    Suite Proxy or Postman and then alter the API request before it is sent to the
    provider. This could allow you to capture shared API keys or use parameters that
    could negatively impact the security of the application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个业务逻辑漏洞出现在开发者假设消费者仅会使用浏览器与 web 应用交互，并且不会捕获发生在背后 API 请求的情况下。利用这种弱点所需的只是使用 Burp
    Suite Proxy 或 Postman 等工具拦截请求，然后在请求发送给提供商之前修改 API 请求。这可能使你能够捕获共享的 API 密钥或使用可能对应用程序安全产生负面影响的参数。
- en: 'As an example, consider a web application authentication portal that a user
    would normally employ to authenticate to their account. Say the web application
    issued the following API request:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑一个用户通常用来验证自己账户的 web 应用认证门户。假设 web 应用发出了以下 API 请求：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There is a chance that we could bypass multifactor authentication by simply
    altering the parameter `MFA` to `false`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有可能通过简单地将参数 `MFA` 改为 `false` 来绕过多因素认证。
- en: Testing for business logic flaws can be challenging because each business is
    unique. Automated scanners will have a difficult time detecting these issues,
    as the flaws are part of the API’s intended use. You must understand how the business
    and API operate and then consider how you could use these features to your advantage.
    Study the application’s business logic with an adversarial mindset, and try breaking
    any assumptions that have been made.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 测试业务逻辑缺陷可能具有挑战性，因为每个业务都是独特的。自动化扫描器很难检测到这些问题，因为这些缺陷是 API 预期用途的一部分。你必须理解业务和 API
    的运作方式，然后考虑如何利用这些特性为自己谋利。以对立的心态研究应用程序的业务逻辑，并尝试打破任何已做出的假设。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I covered common API vulnerabilities. It is important to become
    familiar with these vulnerabilities so that you can easily recognize them, take
    advantage of them during an engagement, and report them back to the organization
    to prevent the criminals from dragging your client into the headlines.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我介绍了常见的 API 漏洞。熟悉这些漏洞非常重要，这样你可以轻松识别它们，在渗透测试中利用它们，并将其报告给组织，防止罪犯将你的客户拖入头条新闻。
- en: Now that you are familiar with web applications, APIs, and their weaknesses,
    it is time to prepare your hacking machine and get your hands busy on the keyboard.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了 web 应用、API 及其弱点，是时候准备好你的黑客工具并开始在键盘上动手了。
