- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Network Applications and Services
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用与服务
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter explores basic network applications—the clients and servers running
    in user space that reside at the application layer. Because this layer is at the
    top of the stack, close to end users, you may find this material more accessible
    than the material in Chapter 9. Indeed, you interact with network client applications
    such as web browsers every day.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了基础的网络应用——在用户空间中运行的客户端和服务器，它们位于应用层。因为这一层位于堆栈的顶部，靠近终端用户，你可能会发现这部分内容比第9章的内容更容易理解。实际上，你每天都会与网络客户端应用程序（如Web浏览器）进行交互。
- en: To do their work, network clients connect to corresponding network servers.
    Unix network servers come in many forms. A server program can listen to a port
    on its own or through a secondary server. We’ll look at some common servers as
    well as tools that will help you understand and debug server operation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成工作，网络客户端会连接到相应的网络服务器。Unix网络服务器有多种形式。服务器程序可以单独监听某个端口，或者通过一个二级服务器进行监听。我们将了解一些常见的服务器以及帮助你理解和调试服务器操作的工具。
- en: Network clients use the operating system’s transport layer protocols and interfaces,
    so it’s important to understand the basics of the TCP and UDP transport layers.
    Let’s start looking at network applications by experimenting with a network client
    that uses TCP.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 网络客户端使用操作系统的传输层协议和接口，因此理解TCP和UDP传输层的基础非常重要。让我们通过实验使用一个利用TCP的网络客户端来开始了解网络应用。
- en: 10.1 The Basics of Services
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 服务基础
- en: 'TCP services are among the easiest to understand because they are built upon
    simple, uninterrupted two-way data streams. Perhaps the best way to see how they
    work is to talk directly to an unencrypted web server on TCP port 80 to get an
    idea of how data moves across the connection. For example, run the following command
    to connect to the IANA documentation example web server:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: TCP服务是最容易理解的，因为它们建立在简单、连续的双向数据流之上。也许最好的方法是直接与TCP端口80上的未加密Web服务器进行交互，了解数据是如何通过连接传输的。例如，运行以下命令连接到IANA文档示例Web服务器：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should get a response like this, indicating a successful connection to
    the server:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到像这样的响应，表示成功连接到服务器：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now enter these two lines:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入这两行：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Press enter twice after the last line. The server should send a bunch of HTML
    text as a response. To terminate the connection, press ctrl-D.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行后按两次回车。服务器应该会发送一大段HTML文本作为响应。要终止连接，请按ctrl-D。
- en: 'This exercise demonstrates that:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习演示了：
- en: The remote host has a web server process listening on TCP port 80\.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程主机上有一个Web服务器进程监听TCP端口80\。
- en: '`telnet` was the client that initiated the connection.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`telnet`是发起连接的客户端。'
- en: The reason you have to terminate the connection with ctrl-D is that, because
    most web pages need several requests to load, it makes sense to keep the connection
    open. If you explore web servers at the protocol level, you may find that this
    behavior varies. For example, many servers disconnect quickly if they do not receive
    a request soon after a connection opens.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须通过ctrl-D来终止连接的原因是，由于大多数网页需要多次请求才能加载，保持连接开启是有意义的。如果你从协议层面探索Web服务器，你可能会发现这种行为有所不同。例如，如果服务器在连接打开后不久没有接收到请求，许多服务器会迅速断开连接。
- en: 10.2 A Closer Look
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 更深入的了解
- en: 'In the previous example, you manually interacted with a web server on the network
    with `telnet`, using the HTTP application layer protocol. Although you’d normally
    use a web browser to make this sort of connection, let’s take just one step up
    from `telnet` and use a command-line program that knows how to speak to the HTTP
    application layer. We’ll use the `curl` utility with a special option to record
    details about its communication:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你通过`telnet`手动与网络上的Web服务器进行了交互，使用了HTTP应用层协议。虽然通常你会使用Web浏览器来建立这种连接，但让我们从`telnet`稍微向上迈一步，使用一个了解如何与HTTP应用层进行通信的命令行程序。我们将使用带有特殊选项的`curl`工具来记录其通信细节：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You’ll get a lot of HTML output. Ignore it (or redirect it to */dev/null*)
    and instead look at the newly created file *trace_file*. If the connection was
    successful, the first part of the file should look something like the following,
    at the point where `curl` attempts to establish the TCP connection to the server:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得大量的HTML输出。忽略它（或者将其重定向到*/dev/null*），而是查看新创建的文件*trace_file*。如果连接成功，文件的第一部分应该类似于以下内容，即`curl`尝试建立与服务器的TCP连接时：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Everything you’ve seen so far happens in the transport layer or below. However,
    if this connection succeeds, `curl` then tries to send the request (the “header”);
    this is where the application layer starts:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您看到的一切都发生在传输层或以下。然而，如果这个连接成功，`curl`接着会尝试发送请求（即“头部”）；这就是应用层开始的地方：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Line 1 is `curl` debugging output telling you what it will do next. The remaining
    lines show what `curl` sends to the server. The text in bold is what goes to the
    server; the hexadecimal numbers at the beginning are just debugging offsets `curl`
    adds to help you keep track of how much data was sent or received.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第1行是`curl`的调试输出，告诉你接下来将做什么。其余行显示了`curl`发送给服务器的内容。粗体文本是发送给服务器的内容；开头的十六进制数字只是调试偏移量，`curl`加上这些偏移量以帮助你跟踪发送或接收的数据量。
- en: 'At 2, you can see that `curl` starts by issuing a `GET` command to the server
    (as you did with `telnet`), followed by some extra information for the server
    and an empty line. Next, the server sends a reply, first with its own header,
    shown here in bold:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行，你可以看到`curl`开始向服务器发出`GET`命令（就像你使用`telnet`做的那样），接着是一些额外的信息和一个空行。接下来，服务器发送回复，首先是它自己的头部，显示在这里的粗体中：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Much like the previous output, the `<=` lines are debugging output, and `0000:`
    precedes the lines of output to tell you the offsets (in `curl`, the header won’t
    count toward the offset; that’s why all of these lines begin with 0).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的输出类似，`<=`行是调试输出，`0000:`位于输出行前，告诉你偏移量（在`curl`中，头部不会计入偏移量；这就是为什么所有这些行都以0开头）。
- en: 'The header in the server’s reply can be fairly long, but at some point the
    server transitions from transmitting headers to sending the actual requested document,
    like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器回复中的头部可能相当长，但在某个时候，服务器会从传输头部切换到发送实际请求的文档，如下所示：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This output also illustrates an important property of the application layer.
    Even though the debugging output says `Recv header` and `Recv data`, implying
    that those are two different kinds of messages from the server, there’s no difference
    in how `curl` talked to the operating system to retrieve the two messages, in
    how the operating system handled them, or in how the network handled the packets
    underneath. The difference is entirely within the user-space `curl` application.
    `curl` knew that until this point it had been getting headers, but when it received
    a blank line 1, which signifies the end of headers in HTTP, it knew to interpret
    anything that followed as the requested document.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出还展示了应用层的一个重要特性。即使调试输出中显示了`Recv header`和`Recv data`，暗示这些是服务器发送的两种不同类型的消息，但`curl`与操作系统交互以检索这两条消息的方式、操作系统如何处理它们、或网络如何处理这些包都没有区别。区别完全在于用户空间的`curl`应用程序。`curl`知道，在此之前它一直在获取头部，但当它接收到一个空行1时，这个空行表示HTTP头部的结束，它知道接下来要将其余部分视为请求的文档。
- en: The same is true of the server sending this data. When sending the reply, the
    server’s operating system didn’t differentiate between header and document data;
    the distinctions happen inside the user-space server program.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 发送这些数据的服务器也是如此。当服务器发送回复时，服务器的操作系统没有区分头部和文档数据；这些区分发生在用户空间的服务器程序内部。
- en: 10.3 Network Servers
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 网络服务器
- en: Most network servers are like other server daemons on your system such as cron,
    except that they interact with network ports. In fact, syslogd, discussed in Chapter
    7, accepts UDP packets on port 514 when started with the `-r` option.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络服务器就像你系统上的其他服务器守护进程（例如cron），不同之处在于它们与网络端口进行交互。实际上，syslogd（第7章讨论）在启动时带有`-r`选项，会在514端口接收UDP数据包。
- en: 'Here are some other common network servers that you might find running on your
    system:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些您可能在系统上运行的其他常见网络服务器：
- en: httpd, apache, apache2, nginx Web servers
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: httpd, apache, apache2, nginx 网页服务器
- en: sshd Secure shell daemon
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: sshd 安全外壳守护进程
- en: postfix, qmail, sendmail Mail servers
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: postfix, qmail, sendmail 邮件服务器
- en: cupsd Print server
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: cupsd 打印服务器
- en: nfsd, mountd Network filesystem (file-sharing) daemons
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: nfsd, mountd 网络文件系统（文件共享）守护进程
- en: smbd, nmbd Windows file-sharing daemons (see Chapter 12)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: smbd, nmbd Windows文件共享守护进程（见第12章）
- en: rpcbind Remote procedure call (RPC) portmap service daemon
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: rpcbind 远程过程调用（RPC）端口映射服务守护进程
- en: One feature common to most network servers is that they usually operate as multiple
    processes. At least one process listens on a network port, and upon receiving
    a new incoming connection, the listening process uses `fork()` to create a child
    process, which is then responsible for the new connection. The child, often called
    a *worker* process, terminates when the connection is closed. Meanwhile, the original
    listening process continues to listen on the network port. This process allows
    a server to easily handle many connections without much trouble.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络服务器的一个共同特点是，它们通常作为多个进程运行。至少有一个进程监听网络端口，接收到新的连接后，监听进程使用`fork()`创建一个子进程，然后由该子进程负责处理新连接。这个子进程，通常称为*工作*进程，在连接关闭时终止。与此同时，原始的监听进程继续监听网络端口。这一过程使得服务器能够轻松处理多个连接而不会出现太多问题。
- en: There are some exceptions to this model, however. Calling `fork()` adds a significant
    amount of system overhead. To avoid this, high-performance TCP servers such as
    the Apache web server may create a number of worker processes upon startup so
    they’re available to handle connections as needed. Servers that accept UDP packets
    don’t need to fork at all, as they don’t have connections to listen for; they
    simply receive data and react to it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一模型也有一些例外。调用`fork()`会增加大量的系统开销。为了避免这种情况，像 Apache Web 服务器这样的高性能 TCP 服务器可能会在启动时创建多个工作进程，以便根据需要处理连接。接受
    UDP 数据包的服务器根本不需要 fork，因为它们不需要监听连接；它们只需接收数据并对其作出反应。
- en: 10.3.1  Secure Shell
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1  安全外壳协议（SSH）
- en: 'Every network server program works a bit differently. To get hands-on experience
    with a server’s configuration and operation, let’s take a close look at the standalone
    secure shell (SSH) server. One of the most common network service applications,
    SSH is the de facto standard for remote access to a Unix machine. SSH is designed
    to allow secure shell logins, remote program execution, simple file sharing, and
    more—replacing the old, insecure `telnet` and `rlogin` remote-access systems with
    public-key cryptography for authentication and simpler ciphers for session data.
    Most ISPs and cloud providers require SSH for shell access to their services,
    and many Linux-based network appliances (such as network attached storage, or
    NAS, devices) provide access via SSH as well. OpenSSH ([http://www.openssh.com/](http://www.openssh.com/))
    is a popular free SSH implementation for Unix, and nearly all Linux distributions
    come with it preinstalled. The OpenSSH client program is `ssh`, and the server
    is sshd. There are two main SSH protocol versions: 1 and 2\. OpenSSH supports
    only version 2, having dropped version 1 support due to vulnerabilities and lack
    of use.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网络服务器程序的工作方式略有不同。为了更好地了解服务器的配置和运行情况，让我们仔细研究一下独立的安全外壳（SSH）服务器。作为最常见的网络服务应用之一，SSH
    已成为远程访问 Unix 机器的事实标准。SSH 旨在允许安全的 shell 登录、远程程序执行、简单的文件共享等——用公钥加密来进行身份验证，并用更简单的密码算法处理会话数据，取代了不安全的`telnet`和`rlogin`远程访问系统。大多数互联网服务提供商和云服务商要求通过
    SSH 进行 shell 访问，而许多基于 Linux 的网络设备（如网络附加存储设备，简称 NAS）也提供通过 SSH 访问的功能。OpenSSH（[http://www.openssh.com/](http://www.openssh.com/)）是一个流行的免费
    SSH 实现，适用于 Unix，几乎所有 Linux 发行版都预装了它。OpenSSH 客户端程序是`ssh`，而服务器是 sshd。SSH 协议有两个主要版本：1
    和 2。OpenSSH 只支持版本 2，已经由于漏洞和使用率低而放弃对版本 1 的支持。
- en: 'Among its many useful capabilities and features, SSH does the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在其众多有用的功能和特性中，SSH 执行以下操作：
- en: Encrypts your password and all other session data, protecting you from snoopers.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密你的密码和所有其他会话数据，保护你免受窥探者的侵害。
- en: Tunnels other network connections, including those from X Window System clients.
    (You’ll learn more about X in Chapter 14.)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隧道其他网络连接，包括来自 X Window System 客户端的连接。（你将在第 14 章中了解更多关于 X 的内容。）
- en: Offers clients for nearly any operating system.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供几乎适用于任何操作系统的客户端。
- en: Uses keys for host authentication.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用密钥进行主机身份验证。
- en: 'SSH does have a few disadvantages. For one, in order to set up an SSH connection,
    you need the remote host’s public key, and you don’t necessarily get it in a secure
    way (though you can check it manually to make sure you’re not being spoofed).
    For an overview of how several methods of cryptography work, get your hands on
    the book *Serious Cryptography: A Practical Introduction to Modern Encryption*
    (No Starch Press, 2017), by Jean-Philippe Aumasson. Two in-depth books on SSH
    are *SSH Mastery: OpenSSH, PuTTY, Tunnels, and Keys*, 2nd edition, by Michael
    W. Lucas (Tilted Windmill Press, 2018) and *SSH, The Secure Shell: The Definitive
    Guide*, 2nd edition, by Daniel J. Barrett, Richard E. Silverman, and Robert G.
    Byrnes (O’Reilly, 2005).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 'SSH 确实有一些缺点。例如，为了建立 SSH 连接，你需要远程主机的公共密钥，而你不一定能以安全的方式获得它（尽管你可以手动检查它，以确保不会被伪造）。要了解几种加密方法的概述，可以阅读
    Jean-Philippe Aumasson 所著的《*Serious Cryptography: A Practical Introduction to
    Modern Encryption*》（No Starch Press, 2017）。关于 SSH 的两本深入书籍分别是 Michael W. Lucas
    所著的《*SSH Mastery: OpenSSH, PuTTY, Tunnels, and Keys*》第二版（Tilted Windmill Press,
    2018），以及 Daniel J. Barrett、Richard E. Silverman 和 Robert G. Byrnes 所著的《*SSH, The
    Secure Shell: The Definitive Guide*》第二版（O’Reilly, 2005）。'
- en: 10.3.2  The sshd Server
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2  sshd 服务器
- en: Running the sshd server to allow remote connections to your system requires
    a configuration file and host keys. Most distributions keep configurations in
    the */etc/ssh* configuration directory and try to configure everything properly
    for you if you install their sshd package. (The server configuration filename
    *sshd_config* is easy to confuse with the client’s *ssh_config* setup file, so
    be careful.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 sshd 服务器以允许远程连接到你的系统需要一个配置文件和主机密钥。大多数发行版将配置保存在 */etc/ssh* 配置目录中，并在你安装它们的
    sshd 包时会为你配置好一切。（服务器配置文件名 *sshd_config* 容易与客户端的 *ssh_config* 设置文件混淆，所以要小心。）
- en: You shouldn’t need to change anything in *sshd_config*, but it never hurts to
    check. The file consists of key-value pairs, as shown in this fragment.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要更改 *sshd_config* 中的任何内容，但检查一下也无妨。该文件由键值对组成，如这个片段所示。
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Lines beginning with `#` are comments, and many comments in your *sshd_config*
    indicate default values for various parameters, as you can see from this excerpt.
    The sshd_config(5) manual page contains descriptions of the parameters and possible
    values, but these are among the most important:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `#` 开头的行是注释，许多注释在你的 *sshd_config* 文件中指示了各种参数的默认值，正如你从这个摘录中看到的那样。sshd_config(5)
    手册页包含了参数和可能的值的描述，但以下是其中最重要的：
- en: '`HostKey` `file` Uses `file` as a host key. (Host keys are described next.)'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HostKey` `file` 使用 `file` 作为主机密钥。（主机密钥将在下一节中描述。）'
- en: '`PermitRootLogin` `value` Permits the superuser to log in with SSH if `value`
    is set to `yes`. Set `value` to `no` to prevent this.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PermitRootLogin` `value` 如果 `value` 设置为 `yes`，允许超级用户通过 SSH 登录。将 `value` 设置为
    `no` 可防止这种情况。'
- en: '`LogLevel` `level` Logs messages with syslog level `level` (defaults to `INFO`).'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LogLevel` `level` 使用 syslog 级别 `level` 记录消息（默认值为 `INFO`）。'
- en: '`SyslogFacility` `name` Logs messages with syslog facility `name` (defaults
    to `AUTH`).'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SyslogFacility` `name` 使用 syslog 设施 `name` 记录消息（默认值为 `AUTH`）。'
- en: '`X11Forwarding` `value` Enables X Window System client tunneling if `value`
    is set to `yes`.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`X11Forwarding` `value` 如果 `value` 设置为 `yes`，则启用 X Window 系统客户端隧道。'
- en: '`XAuthLocation` `path` Specifies the location of the `xauth` utility on your
    system. X tunneling will not work without this path. If `xauth` isn’t in */usr/bin*,
    set `path` to the full pathname for `xauth`.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`XAuthLocation` `path` 指定系统上 `xauth` 工具的位置。如果没有此路径，X 隧道将无法工作。如果 `xauth` 不在
    */usr/bin* 中，请将 `path` 设置为 `xauth` 的完整路径。'
- en: Creating Host Keys
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建主机密钥
- en: OpenSSH has several host key sets. Each set has a public key (with a *.pub*
    file extension) and a private key (with no extension).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH 有多个主机密钥集。每个密钥集都有一个公共密钥（以 *.pub* 为扩展名）和一个私有密钥（没有扩展名）。
- en: SSH version 2 has RSA and DSA keys. RSA and DSA are public key cryptography
    algorithms. The key filenames are given in [Table 10-1](#table10-1).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 版本 2 使用 RSA 和 DSA 密钥。RSA 和 DSA 是公钥加密算法。密钥文件名列在 [表 10-1](#table10-1) 中。
- en: 'Table 10-1: OpenSSH Key Files'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-1：OpenSSH 密钥文件
- en: '| **Filename** | **Key type** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **文件名** | **密钥类型** |'
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *ssh_host_rsa_key* | Private RSA key |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| *ssh_host_rsa_key* | 私有 RSA 密钥 |'
- en: '| *ssh_host_rsa_key.pub* | Public RSA key |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| *ssh_host_rsa_key.pub* | 公共 RSA 密钥 |'
- en: '| *ssh_host_dsa_key* | Private DSA key |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| *ssh_host_dsa_key* | 私有 DSA 密钥 |'
- en: '| *ssh_host_dsa_key.pub* | Public DSA key |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| *ssh_host_dsa_key.pub* | 公共 DSA 密钥 |'
- en: 'Creating a key involves a numerical computation that generates both public
    and private keys. Normally you won’t need to create the keys because the OpenSSH
    installation program or your distribution’s installation script will do it for
    you, but you need to know how to do so if you plan to use programs like `ssh-agent`
    that provide authentication services without a password. To create SSH protocol
    version 2 keys, use the `ssh-keygen` program that comes with OpenSSH:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 创建密钥涉及一个数值计算，生成公钥和私钥。通常你不需要自己创建密钥，因为OpenSSH的安装程序或你发行版的安装脚本会为你做这件事，但如果你计划使用像`ssh-agent`这样无需密码的身份验证服务，你需要知道如何创建密钥。要创建SSH协议版本2的密钥，请使用OpenSSH自带的`ssh-keygen`程序：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The SSH server and clients also use a *key file*, called *ssh_known_hosts*,
    to store public keys from other hosts. If you intend to use authentication based
    on a remote client’s identity, the server’s *ssh_known_hosts* file must contain
    the public host keys of all trusted clients. Knowing about the key files is handy
    if you’re replacing a machine. When installing a new machine from scratch, you
    can import the key files from the old machine to ensure that users don’t get key
    mismatches when connecting to the new one.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: SSH服务器和客户端还使用一个*密钥文件*，叫做*ssh_known_hosts*，用来存储来自其他主机的公钥。如果你打算使用基于远程客户端身份的身份验证，服务器的*ssh_known_hosts*文件必须包含所有受信任客户端的公钥。了解密钥文件是很有用的，特别是当你需要替换一台机器时。从零安装新机器时，你可以从旧机器导入密钥文件，以确保用户在连接新机器时不会遇到密钥不匹配的问题。
- en: Starting the SSH Server
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启动SSH服务器
- en: Although most distributions ship with SSH, they usually don’t start the sshd
    server by default. On Ubuntu and Debian, the SSH server is not installed on a
    new system; installing its package creates the keys, starts the server, and adds
    the server startup to the bootup configuration.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数发行版都自带SSH，但它们通常默认不会启动sshd服务器。在Ubuntu和Debian上，新的系统不会安装SSH服务器；安装其包会创建密钥，启动服务器，并将服务器启动项加入开机配置。
- en: 'On Fedora, sshd is installed by default but turned off. To start sshd at boot,
    use `systemctl` like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fedora上，sshd默认已安装但处于关闭状态。要在启动时启动sshd，可以使用`systemctl`，像这样：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you want to start the server immediately without rebooting, use:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在不重启的情况下立即启动服务器，可以使用：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Fedora normally creates any missing host key files upon the first sshd startup.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Fedora通常会在第一次启动sshd时创建任何缺失的主机密钥文件。
- en: 'If you’re running another distribution, you likely won’t need to manually configure
    the sshd startup. However, you should know that there are two startup modes: standalone
    and on-demand. The standalone server is by far more common, and it’s just a matter
    of running sshd as root. The sshd server process writes its PID to */var/run/sshd.pid*
    (of course, when run by systemd, it’s also tracked by its cgroup, as you saw in
    Chapter 6).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是其他发行版，你可能不需要手动配置sshd的启动。然而，你应该知道有两种启动模式：独立模式和按需模式。独立模式服务器更为常见，只需以root身份运行sshd。sshd服务器进程会将其PID写入*/var/run/sshd.pid*（当然，当由systemd运行时，它也会被其cgroup跟踪，正如你在第六章看到的）。
- en: As an alternative, systemd can start sshd on demand through a socket unit. This
    usually isn’t a good idea, because the server occasionally needs to generate key
    files, and that process can take a long time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，systemd可以通过套接字单元按需启动sshd。这通常不是一个好主意，因为服务器偶尔需要生成密钥文件，而这个过程可能会很长。
- en: 10.3.3  fail2ban
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3  fail2ban
- en: If you set up an SSH server on your machine and open it up to the internet,
    you’ll quickly discover constant intrusion attempts. These brute-force attacks
    won’t succeed if your system is properly configured and you haven’t chosen stupid
    passwords. However, they will be annoying, consume CPU time, and unnecessarily
    clutter your logs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在机器上设置了SSH服务器并将其开放到互联网，你很快就会发现不断的入侵尝试。这些暴力破解攻击如果你的系统配置正确且密码足够强大，是不会成功的。然而，它们会很烦人，消耗CPU时间，并且无谓地增加日志的杂乱。
- en: To prevent this, you want to set up a mechanism to block repeated login attempts.
    As of this writing, the fail2ban package is the most popular way to do this; it’s
    simply a script that watches log messages. Upon seeing a certain number of failed
    requests from one host within a certain time frame, fail2ban uses `iptables` to
    create a rule to deny traffic from that host. After a specified period, during
    which the host has probably given up trying to connect, fail2ban removes the rule.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况，你需要设置一个机制来阻止重复的登录尝试。截至目前，fail2ban软件包是最流行的解决方案；它只是一个监视日志消息的脚本。当从某个主机在指定时间范围内出现一定数量的失败请求时，fail2ban使用`iptables`创建规则来拒绝该主机的流量。经过一段时间（在这段时间内该主机可能已经放弃了连接尝试）后，fail2ban会删除该规则。
- en: Most Linux distributions offer a fail2ban package with preconfigured defaults
    for SSH.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Linux发行版提供了带有预配置默认设置的fail2ban包，适用于SSH。
- en: 10.3.4  The SSH Client
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 SSH客户端
- en: 'To log in to a remote host, run:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要登录到远程主机，运行：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You may omit `remote_username``@` if your local username is the same as on
    `remote_host`. You can also run pipelines to and from an `ssh` command as shown
    in the following example, which copies a directory *dir* to another host:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的本地用户名与`remote_host`上的用户名相同，可以省略`remote_username``@`。你还可以像以下示例中那样，通过`ssh`命令运行管道，将目录*dir*复制到另一台主机：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The global SSH client configuration file *ssh_config* should be in */etc/ssh*,
    the same location as your *sshd_config* file. As with the server configuration
    file, the client configuration file has key-value pairs, but you shouldn’t need
    to change them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 全局的 SSH 客户端配置文件*ssh_config*应该位于*/etc/ssh*，与*sshd_config*文件的路径相同。与服务器配置文件一样，客户端配置文件也包含键值对，但通常不需要修改它们。
- en: 'The most frequent problem with using SSH clients occurs when an SSH public
    key in your local *ssh_known_hosts* or *.ssh/known_hosts* file does not match
    the key on the remote host. Bad keys cause errors or warnings like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSH客户端时最常见的问题是，当你本地的*ssh_known_hosts*或*.ssh/known_hosts*文件中的SSH公钥与远程主机上的密钥不匹配时，会导致类似下面的错误或警告：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This usually just means that the remote host’s administrator changed the keys
    (which often happens upon a hardware or cloud server upgrade), but it never hurts
    to check with the administrator if you’re not sure. In any case, the preceding
    message tells you that the bad key is in line 12 of a user’s *known_hosts* file
    1.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常意味着远程主机的管理员更改了密钥（这在硬件或云服务器升级时经常发生），但如果不确定，还是可以联系管理员确认。无论如何，前面的消息告诉你，错误的密钥位于某个用户的*known_hosts*文件的第12行1。
- en: If you don’t suspect foul play, just remove the offending line or replace it
    with the correct public key.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不怀疑有恶意行为，只需删除有问题的行或用正确的公钥替换它。
- en: SSH File Transfer Clients
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SSH 文件传输客户端
- en: OpenSSH includes the file transfer programs `scp` and `sftp`, which are intended
    as replacements for the older, insecure programs `rcp` and `ftp`. You can use
    `scp` to transfer files to or from a remote machine to your machine or from one
    host to another. It works like the `cp` command. Here are a few examples.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH包含文件传输程序`scp`和`sftp`，它们是较旧的、不安全的程序`rcp`和`ftp`的替代品。你可以使用`scp`将文件从远程机器传输到本地机器，或从一台主机传输到另一台主机。它的使用方法类似于`cp`命令。以下是一些示例。
- en: 'Copy a file from a remote host to the current directory:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从远程主机复制文件到当前目录：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Copy a file from the local machine to a remote host:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从本地机器复制一个文件到远程主机：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Copy a file from one remote host to a second remote host:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从一台远程主机复制文件到第二台远程主机：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `sftp` program works like the obsolete command-line `ftp` client, using
    `get` and `put` commands. The remote host must have an `sftp-server` program installed,
    which you can expect if the remote host also uses OpenSSH.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`sftp`程序的工作方式类似于过时的命令行`ftp`客户端，使用`get`和`put`命令。远程主机必须安装有`sftp-server`程序，如果远程主机也使用OpenSSH，你可以预期它已经安装。'
- en: SSH Clients for Non-Unix Platforms
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 非Unix平台的SSH客户端
- en: There are SSH clients for all popular operating systems. Which one should you
    choose? PuTTY is a good, basic Windows client that includes a secure file-copy
    program. macOS is based on Unix and includes OpenSSH.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有流行操作系统都有SSH客户端。你应该选择哪一个？PuTTY是一个很好的基础Windows客户端，包含一个安全的文件复制程序。macOS基于Unix，并包含OpenSSH。
- en: '10.4 Pre-systemd Network Connection Servers: inetd/xinetd'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 系统d之前的网络连接服务器：inetd/xinetd
- en: Before the widespread use of systemd and the socket units that you saw in Section
    6.3.7, there were a handful of servers that provided a standard means of building
    a network service. Many minor network services are very similar in their connection
    requirements, so implementing standalone servers for every service can be inefficient.
    Each server must be separately configured to handle port listening, access control,
    and port configuration. These actions are performed in the same way for most services;
    only when a server accepts a connection is communication handled any differently.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 systemd 和第 6.3.7 节中提到的 socket 单元广泛使用之前，有一些服务器提供了一种标准的构建网络服务的方式。许多小型网络服务在连接需求上非常相似，因此为每个服务实现独立的服务器可能效率不高。每个服务器都必须单独配置来处理端口监听、访问控制和端口配置。这些操作对于大多数服务来说是以相同的方式执行的；只有当服务器接受连接时，通信才会有所不同。
- en: One traditional way to simplify the use of servers is with the inetd daemon,
    a kind of *superserver* designed to standardize network port access and interfaces
    between server programs and network ports. After you start inetd, it reads its
    configuration file and then listens on the network ports defined in that file.
    As new network connections come in, inetd attaches a newly started process to
    the connection.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 简化服务器使用的传统方式之一是通过 inetd 守护进程，这是一种旨在标准化网络端口访问和服务器程序与网络端口之间接口的 *超级服务器*。启动 inetd
    后，它会读取其配置文件，然后监听文件中定义的网络端口。当新的网络连接到来时，inetd 会将新启动的进程附加到该连接上。
- en: A newer version of inetd called xinetd offers easier configuration and better
    access control, but xinetd has almost entirely been phased out in favor of systemd.
    However, you might see it on an older system or one that does not use systemd.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: inetd 的一个新版本叫做 xinetd，提供了更简单的配置和更好的访问控制，但 xinetd 几乎完全被淘汰，取而代之的是 systemd。然而，你可能会在较旧的系统或没有使用
    systemd 的系统上看到它。
- en: 10.5 Diagnostic Tools
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 诊断工具
- en: Let’s look at a few diagnostic tools that are useful for poking around the application
    layer. Some dig into the transport and network layers, because everything in the
    application layer eventually maps down to something in those lower layers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些有用的诊断工具，这些工具适合深入应用层。有些工具深入到传输和网络层，因为应用层中的一切最终都会映射到这些较低的层级。
- en: As discussed in Chapter 9, `netstat` is a basic network service debugging tool
    that can display a number of transport and network layer statistics. [Table 10-2](#table10-2)
    reviews a few useful options for viewing connections.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 9 章所述，`netstat` 是一个基本的网络服务调试工具，可以显示许多传输和网络层统计信息。[表 10-2](#table10-2) 回顾了查看连接的一些有用选项。
- en: 'Table 10-2: Useful Connection-Reporting Options for netstat'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-2：netstat 的有用连接报告选项
- en: '| **Option** | **Description** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **描述** |'
- en: '| --- | --- |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-t` | Prints TCP port information |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `-t` | 打印 TCP 端口信息 |'
- en: '| `-u` | Prints UDP port information |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `-u` | 打印 UDP 端口信息 |'
- en: '| `-l` | Prints listening ports |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `-l` | 打印监听端口 |'
- en: '| `-a` | Prints every active port |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `-a` | 打印所有活动端口 |'
- en: '| `-n` | Disables name lookups (speeds things up; also useful if DNS isn’t
    working) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `-n` | 禁用名称查找（加速操作；如果 DNS 不工作时也很有用） |'
- en: '| `-4`, `-6` | Limits the output to IP version 4 or 6 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `-4`, `-6` | 限制输出为 IP 版本 4 或 6 |'
- en: 10.5.1  lsof
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.1  lsof
- en: 'In Chapter 8, you learned that `lsof` not only can track open files, but can
    also list the programs currently using or listening to ports. For a complete list
    of such programs, run:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 章中，你学习到 `lsof` 不仅可以追踪打开的文件，还可以列出当前正在使用或监听端口的程序。要查看所有这样的程序，运行：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you run this command as a regular user, it shows only that user’s processes.
    When you run it as root, the output should look something like this, displaying
    a variety of processes and users:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当以普通用户身份运行此命令时，它只会显示该用户的进程。当以 root 用户身份运行时，输出应该类似于以下内容，显示多种进程和用户：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This example output shows users and process IDs for server and client programs,
    from the old-style RPC services at the top 1, to the multicast DNS service provided
    by `avahi` 2, to even an IPv6-ready printer service, cupsd 3. The last two entries
    show client connections: an SSH connection 4 and a secure web connection from
    the Chromium web browser 5. Because the output can be extensive, it’s usually
    best to apply a filter (as discussed in the following section).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例输出显示了服务器和客户端程序的用户和进程 ID，从顶部的旧式 RPC 服务 1，到 `avahi` 提供的多播 DNS 服务 2，再到一个支持 IPv6
    的打印服务 cupsd 3。最后两个条目显示了客户端连接：一个 SSH 连接 4 和一个来自 Chromium 浏览器的安全网页连接 5。由于输出可能非常庞大，通常最好应用一个过滤器（如下一节所讨论）。
- en: 'The `lsof` program is like `netstat` in that it tries to reverse-resolve every
    IP address that it finds into a hostname, which slows down the output. Use the
    `-n` option to disable name resolution:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`lsof`程序类似于`netstat`，它尝试将找到的每个IP地址反向解析为主机名，这会减慢输出速度。使用`-n`选项禁用名称解析：'
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can also specify `-P` to disable */etc/services* port name lookups.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以指定`-P`来禁用*/etc/services*端口名称查找。
- en: Filtering by Protocol and Port
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按协议和端口过滤
- en: 'If you’re looking for a particular port (say, you know that a process is using
    a particular port and you want to know what that process is), use this command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在寻找特定的端口（例如，您知道某个进程正在使用特定的端口，您想知道那个进程是什么），请使用以下命令：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The full syntax is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的语法如下：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `protocol`, `@``host`, and `:``port` parameters are all optional and will
    filter the `lsof` output accordingly. As with most network utilities, `host` and
    `port` can be either names or numbers. For example, if you want to see connections
    only on TCP port 443 (the HTTPS port), use:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`protocol`、`@``host`和`:``port`参数都是可选的，并将相应地过滤`lsof`输出。与大多数网络实用程序一样，`host`和`port`可以是名称或数字。例如，如果您只想查看TCP端口443（HTTPS端口）上的连接，请使用：'
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To filter based on IP version, use `-i4` (IPv4) or `-i6` (IPv6). You can add
    this as a separate option or just add the number in with more complex filters
    (for example, `-i6TCP:443`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据IP版本进行过滤，使用`-i4`（IPv4）或`-i6`（IPv6）。您可以将此作为单独的选项添加，也可以将该数字与更复杂的过滤器一起添加（例如，`-i6TCP:443`）。
- en: You can specify service names from */etc/services* (as in `-iTCP:ssh`) instead
    of numbers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从*/etc/services*中指定服务名称（如`-iTCP:ssh`），而不是使用数字。
- en: Filtering by Connection Status
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按连接状态过滤
- en: 'One particularly handy `lsof` filter is connection status. For example, to
    show only the processes listening on TCP ports, enter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别有用的`lsof`过滤器是连接状态。例如，要仅显示监听TCP端口的进程，请输入：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This command gives you a good overview of the network server processes currently
    running on your system. However, because UDP servers don’t listen and don’t have
    connections, you’ll have to use `-iUDP` to view running clients as well as servers.
    This usually isn’t a problem, because you probably won’t have many UDP servers
    on your system.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令可以为您提供系统上当前运行的网络服务器进程的良好概览。但是，由于UDP服务器不进行监听并且没有连接，因此您必须使用`-iUDP`来查看正在运行的客户端和服务器。通常这不是问题，因为您的系统上可能不会有太多UDP服务器。
- en: 10.5.2  tcpdump
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.2  tcpdump
- en: 'Your system normally doesn’t bother with network traffic that isn’t addressed
    to one of its MAC addresses. If you need to see exactly what’s crossing your network,
    `tcpdump` puts your network interface card into *promiscuous mode* and reports
    on every packet that comes across. Entering `tcpdump` with no arguments produces
    output like the following, which includes an ARP request and web connection:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您的系统通常不会处理未地址指向其任何MAC地址的网络流量。如果您需要查看究竟是什么内容穿越您的网络，`tcpdump`会将您的网络接口卡置于*混杂模式*，并报告经过的每个数据包。输入`tcpdump`命令而不带任何参数将产生如下输出，其中包括ARP请求和Web连接：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can tell `tcpdump` to be more specific by adding filters. You can filter
    based on source and destination hosts, networks, Ethernet addresses, protocols
    at many different layers in the network model, and much more. Among the many packet
    protocols that `tcpdump` recognizes are ARP, RARP, ICMP, TCP, UDP, IP, IPv6, AppleTalk,
    and IPX packets. For example, to tell `tcpdump` to output only TCP packets, run:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加过滤器让`tcpdump`更加具体。您可以基于源和目标主机、网络、以太网地址、网络模型中多个不同层次的协议等进行过滤。`tcpdump`识别的许多数据包协议中，包括ARP、RARP、ICMP、TCP、UDP、IP、IPv6、AppleTalk和IPX数据包。例如，要让`tcpdump`仅输出TCP数据包，请运行：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To see web packets and UDP packets, enter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Web数据包和UDP数据包，请输入：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The keyword `or` specifies that the condition on either the left or right can
    be true to pass the filter. Similarly, the `and` keyword requires both conditions
    to be true.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`or`指定左侧或右侧的条件只要满足一个即可通过过滤器。同样，`and`关键字要求两个条件都为真。
- en: Primitives
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 原语
- en: In the preceding examples, `tcp`, `udp`, and `port` `80` are basic elements
    of filters called *primitives*. The most important primitives are listed in [Table
    10-3](#table10-3).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`tcp`、`udp`和`port` `80`是被称为*原语*的过滤器基本元素。最重要的原语列在[表 10-3](#table10-3)中。
- en: 'Table 10-3: tcpdump Primitives'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-3：tcpdump 原语
- en: '| **Primitive** | **Packet specification** |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **原语** | **数据包规格** |'
- en: '| --- | --- |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `tcp` | TCP packets |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `tcp` | TCP 数据包 |'
- en: '| `udp` | UDP packets |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `udp` | UDP 数据包 |'
- en: '| `ip` | IPv4 packets |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `ip` | IPv4 数据包 |'
- en: '| `ip6` | IPv6 packets |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `ip6` | IPv6 数据包 |'
- en: '| `port` `port` | TCP and/or UDP packets to/from port `port` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `port` `port` | 向或来自端口 `port` 的 TCP 和/或 UDP 数据包 |'
- en: '| `host` `host` | Packets to or from `host` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `host` `host` | 向或来自 `host` 的数据包 |'
- en: '| `net` `network` | Packets to or from `network` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `net` `network` | 向或来自 `network` 的数据包 |'
- en: Operators
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 操作符
- en: The `or` used earlier is an *operator*. `tcpdump` can use multiple operators
    (such as `and` and `!`), and you can group operators in parentheses. If you plan
    to do any serious work with `tcpdump`, make sure to read the pcap-filter(7) manual
    page, especially the section that describes the primitives.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 前面使用的 `or` 是一个 *操作符*。`tcpdump` 可以使用多个操作符（例如 `and` 和 `!`），你还可以在括号中组合操作符。如果你打算使用
    `tcpdump` 进行任何深入工作，一定要阅读 pcap-filter(7) 手册页，特别是描述原始操作符的部分。
- en: 10.5.3  netcat
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.3  netcat
- en: 'If you need more flexibility in connecting to a remote host than a command
    like `telnet` `host``port` allows, use `netcat` (or `nc`). `netcat` can connect
    to remote TCP/UDP ports, specify a local port, listen on ports, scan ports, redirect
    standard I/O to and from network connections, and more. To open a TCP connection
    to a port with `netcat`, run:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要比 `telnet` `host``port` 命令更多的远程主机连接灵活性，可以使用 `netcat`（或 `nc`）。`netcat` 可以连接到远程的
    TCP/UDP 端口，指定本地端口，监听端口，扫描端口，重定向标准输入输出到网络连接等。要通过 `netcat` 打开 TCP 连接到端口，运行：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`netcat` terminates when the other side ends the connection, which can be confusing
    if you redirect standard input to `netcat`, because you might not get your prompt
    back after sending data (as opposed to almost any other command pipeline). You
    can end the connection at any time by pressing ctrl-C. (If you’d like the program
    and network connection to terminate based on the standard input stream, try the
    `sock` program instead.)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`netcat` 在对方断开连接时终止，这可能会让人困惑，尤其是当你将标准输入重定向到 `netcat` 时，因为在发送数据后你可能无法立即看到提示符（这与几乎所有其他命令管道不同）。你可以随时通过按
    ctrl-C 来结束连接。（如果你希望程序和网络连接根据标准输入流来终止，可以尝试使用 `sock` 程序。）'
- en: 'To listen on a particular port, run:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要在特定端口上监听，运行：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If `netcat` is successful at listening on the port, it will wait for a connection,
    and upon establishing a connection, prints the output from that connection, and
    sends any standard input to the connection.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `netcat` 成功在端口上监听，它将等待连接，并在建立连接后打印该连接的输出，并将任何标准输入发送到该连接。
- en: 'Here are some additional notes on `netcat`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些关于 `netcat` 的附加说明：
- en: There isn’t much debugging output by default. If something fails, `netcat` fails
    silently, but it does set an appropriate exit code. If you’d like some more information,
    add the `-v` (“verbose”) option.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下没有太多调试输出。如果某些操作失败，`netcat` 会默默失败，但会设置适当的退出代码。如果你需要更多信息，可以加上 `-v`（“详细”）选项。
- en: By default, the `netcat` client tries to connect with IPv4 and IPv6\. However,
    in server mode, `netcat` defaults to IPv4\. To force the protocol, use `-4` for
    IPv4 and `-6` for IPv6.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，`netcat` 客户端会尝试使用 IPv4 和 IPv6 连接。然而，在服务器模式下，`netcat` 默认使用 IPv4。要强制指定协议，可以使用
    `-4` 来指定 IPv4，使用 `-6` 来指定 IPv6。
- en: The `-u` option specifies UDP instead of TCP.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-u` 选项指定使用 UDP 而不是 TCP。'
- en: 10.5.4  Port Scanning
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.4  端口扫描
- en: Sometimes you don’t even know what services the machines on your networks are
    offering or even which IP addresses are in use. The Network Mapper (Nmap) program
    scans all ports on a machine or network of machines looking for open ports, and
    it lists the ports it finds. Most distributions have an Nmap package, or you can
    get it at [http://www.insecure.org/](http://www.insecure.org/). (See the Nmap
    manual page and online resources for all that Nmap can do.)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你甚至不知道网络中机器提供了哪些服务，或者哪些 IP 地址正在使用。网络映射器（Nmap）程序扫描机器或一组机器上的所有端口，寻找开放的端口，并列出它找到的端口。大多数发行版都有
    Nmap 包，或者你可以在[http://www.insecure.org/](http://www.insecure.org/)下载。（有关 Nmap 可以做的所有功能，请参阅
    Nmap 手册页和在线资源。）
- en: 'When listing ports on your own machine, it often helps to run the Nmap scan
    from at least two points: from your own machine and from another one (possibly
    outside your local network). Doing so will give you an overview of what your firewall
    is blocking.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在列出自己机器上的端口时，通常建议从至少两个点运行 Nmap 扫描：从自己的机器和另一台机器（可能是在你的本地网络之外）。这样做能让你概览防火墙在阻挡哪些内容。
- en: 'Run `nmap``host` to run a generic scan on a host. For example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `nmap``host` 对主机进行通用扫描。例如：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see here, a number of services are open, many of which are not enabled
    by default on most distributions. In fact, the only one here that’s usually on
    by default is port 111, the `rpcbind` port.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，许多服务是开启的，其中很多在大多数发行版中默认并未启用。事实上，唯一一个通常默认开启的是端口 111，即 `rpcbind` 端口。
- en: Nmap is also capable of scanning ports over IPv6 if you add the `-6` option.
    This can be a handy way of identifying services that do not support IPv6.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加 `-6` 选项，Nmap 也能够扫描 IPv6 上的端口。这是识别不支持 IPv6 的服务的一个方便方法。
- en: 10.6 Remote Procedure Calls
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6 远程过程调用
- en: What about the rpcbind service from the scan in the preceding section? RPC stands
    for *remote procedure call (RPC)*, a system residing in the lower parts of the
    application layer. It’s designed to make it easier for programmers to build client/server
    network applications, where a client program calls functions that execute on a
    remote server. Each type of remote server program is identified by an assigned
    program number.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的 rpcbind 服务扫描结果怎么样？RPC 代表*远程过程调用（RPC）*，它是一个位于应用层底部的系统。它旨在帮助程序员更容易地构建客户端/服务器网络应用程序，其中客户端程序调用在远程服务器上执行的函数。每种类型的远程服务器程序都有一个分配的程序编号。
- en: RPC implementations use transport protocols such as TCP and UDP, and they require
    a special intermediary service to map program numbers to TCP and UDP ports. The
    server is called rpcbind, and it must be running on any machine that wants to
    use RPC services.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: RPC 实现使用 TCP 和 UDP 等传输协议，并且它们需要一个特殊的中介服务来将程序编号映射到 TCP 和 UDP 端口。这个服务被称为 rpcbind，任何想要使用
    RPC 服务的机器都必须运行它。
- en: 'To see what RPC services your computer has, run:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你的计算机有哪些 RPC 服务，请运行：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: RPC is one of those protocols that just doesn’t want to die. The Network File
    System (NFS) and Network Information Service (NIS) systems use RPC, but they are
    completely unnecessary on standalone machines. But whenever you think that you’ve
    eliminated all need for rpcbind, something else comes up, such as File Access
    Monitor (FAM) support in GNOME.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: RPC 是一种始终不愿消失的协议。网络文件系统（NFS）和网络信息服务（NIS）系统使用 RPC，但它们在独立机器上完全不必要。但是，每当你认为已经消除了对
    rpcbind 的所有需求时，总会出现一些新的需求，比如 GNOME 中的文件访问监视器（FAM）支持。
- en: 10.7 Network Security
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.7 网络安全
- en: Because Linux is a very popular Unix flavor on the PC platform, and especially
    because it is widely used for web servers, it attracts many unpleasant characters
    who try to break into computer systems. Section 9.25 discussed firewalls, but
    that’s not really the whole story on security.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Linux 是一种在 PC 平台上非常流行的 Unix 变种，特别是因为它在 Web 服务器中广泛使用，所以它吸引了许多试图入侵计算机系统的不法分子。第
    9.25 节讨论了防火墙，但这并不是安全的全部内容。
- en: 'Network security attracts extremists—those who *really* like to break into
    systems (whether for fun or money) and those who come up with elaborate protection
    schemes and *really* like to swat away people trying to break into their systems.
    (This, too, can be very profitable.) Fortunately, you don’t need to know very
    much to keep your system safe. Here are a few basic rules of thumb:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全吸引了极端分子——那些*真正*喜欢入侵系统的人（无论是为了乐趣还是金钱），以及那些想出复杂保护方案并*真正*喜欢打击试图入侵其系统的人。（这也可以非常有利可图。）幸运的是，你不需要知道太多就能保持系统安全。这里有一些基本的经验法则：
- en: Run as few services as possible Intruders can’t break into services that don’t
    exist on your system. If you know what a service is and you’re not using it, don’t
    turn it on for the sole reason that you might want to use it “at some later point.”
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽可能运行最少的服务 入侵者无法攻击系统中不存在的服务。如果你知道某个服务是什么，而你又不使用它，不要因为你可能“以后某个时候”需要它就开启它。
- en: Block as much as possible with a firewall Unix systems have a number of internal
    services that you may not know about (such as TCP port 111 for the RPC port-mapping
    server), and no other system in the world *should* know about them. It can be
    very difficult to track and regulate the services on your system because many
    different kinds of programs listen on various ports. To keep intruders from discovering
    internal services on your system, use effective firewall rules and install a firewall
    at your router.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽可能通过防火墙屏蔽 不同的 Unix 系统可能有一些你不知道的内部服务（例如，RPC 端口映射服务器的 TCP 端口 111），而世界上没有其他系统*应该*知道这些服务。追踪和管理你系统上的服务可能非常困难，因为许多不同类型的程序会监听各种端口。为了防止入侵者发现你系统中的内部服务，请使用有效的防火墙规则，并在路由器上安装防火墙。
- en: Track the services that you offer to the internet If you run an SSH server,
    Postfix, or similar services, keep your software up to date and get appropriate
    security alerts. (See Section 10.7.2 for some online resources.)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跟踪你向互联网提供的服务 如果你运行 SSH 服务器、Postfix 或类似服务，请保持软件更新，并获取适当的安全警报。（请参阅第 10.7.2 节，了解一些在线资源。）
- en: Use “long-term support” distribution releases for servers Security teams normally
    concentrate their work on stable, supported distribution releases. Development
    and testing releases such Debian Unstable and Fedora Rawhide receive much less
    attention.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于服务器，使用“长期支持”发行版 安全团队通常将工作重点集中在稳定、受支持的发行版上。开发和测试版，如 Debian Unstable 和 Fedora
    Rawhide，受到的关注较少。
- en: Don’t give an account on your system to anyone who doesn’t need one It’s much
    easier to gain superuser access from a local account than it is to break in remotely.
    In fact, given the huge base of software (and the resulting bugs and design flaws)
    available on most systems, it can be easy to gain superuser access to a system
    after you get to a shell prompt. Don’t assume that your friends know how to protect
    their passwords (or choose good passwords in the first place).
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要为系统上不需要账户的任何人创建账户 从本地账户获取超级用户权限比从远程入侵要容易得多。实际上，考虑到大多数系统中可用的大量软件（以及由此产生的漏洞和设计缺陷），一旦获得
    shell 提示符，获得超级用户权限相对容易。不要假设你的朋友知道如何保护他们的密码（或者一开始就选择了好的密码）。
- en: Avoid installing dubious binary packages They can contain Trojan horses.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 避免安装可疑的二进制软件包 它们可能包含木马程序。
- en: 'That’s the practical end of protecting yourself. But why is it important to
    do so? There are three basic kinds of network attacks that can be directed at
    a Linux machine:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是保护自己的一项实际操作。那么为什么这样做很重要呢？有三种基本的网络攻击可以针对 Linux 机器进行：
- en: Full compromise This means getting superuser access (full control) of a machine.
    An intruder can accomplish this by trying a service attack, such as a buffer overflow
    exploit, or by taking over a poorly protected user account and then trying to
    exploit a poorly written setuid program.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全妥协 这意味着获得机器的超级用户访问权限（完全控制）。入侵者可以通过尝试服务攻击（例如缓冲区溢出漏洞）来实现这一点，或者通过接管一个保护不力的用户账户，然后尝试利用一个编写不规范的
    setuid 程序。
- en: Denial-of-service (DoS) attack This prevents a machine from carrying out its
    network services or forces a computer to malfunction in some other way without
    the use of any special access. Normally, a DoS attack is just a flood of network
    requests, but it can also be an exploit of a flaw in a server program that causes
    a crash. These attacks are harder to prevent, but they are easier to respond to.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拒绝服务（DoS）攻击 这会阻止机器执行其网络服务，或迫使计算机以其他方式发生故障，而无需使用任何特殊的访问权限。通常，DoS 攻击仅仅是网络请求的洪水，但它也可能是利用服务器程序中的漏洞导致崩溃。这些攻击更难以预防，但响应起来相对容易。
- en: Malware Linux users are mostly immune to malware such as email worms and viruses,
    simply because their email clients aren’t stupid enough to actually run programs
    sent in message attachments. But Linux malware does exist. Avoid downloading and
    installing executable software from places that you’ve never heard of.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恶意软件 Linux 用户通常对恶意软件（如电子邮件蠕虫和病毒）免疫，原因是他们的电子邮件客户端通常不会傻到去运行附加在消息中的程序。但 Linux 恶意软件确实存在。避免从你从未听说过的地方下载和安装可执行软件。
- en: 10.7.1  Typical Vulnerabilities
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7.1 典型漏洞
- en: 'There are two basic types of vulnerabilities to worry about: direct attacks
    and cleartext password sniffing. *Direct attacks* try to take over a machine without
    being terribly subtle. One of the most common is locating an unprotected or otherwise
    vulnerable service on your system. This can be as simple as a service that isn’t
    authenticated by default, such as an administrator account without a password.
    Once an intruder has access to one service on a system, they can use it to try
    to compromise the whole system. In the past, a common direct attack was the buffer
    overflow exploit, where a careless programmer doesn’t check the bounds of a buffer
    array. This has been mitigated somewhat by Address Space Layout Randomization
    (ASLR) techniques in the kernel and protective measures elsewhere.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种基本类型的漏洞需要关注：直接攻击和明文密码嗅探。*直接攻击*尝试在不太隐蔽的情况下接管机器。最常见的一种方式是定位系统中未保护或其他易受攻击的服务。这可以是像管理员账户没有密码这样的简单服务，一些服务默认没有身份验证。入侵者一旦访问到系统中的一个服务，就可以利用它尝试攻破整个系统。过去，一种常见的直接攻击是缓冲区溢出漏洞，程序员不小心没有检查缓冲区数组的边界。这个问题在内核中通过地址空间布局随机化（ASLR）技术和其他地方的保护措施有所缓解。
- en: A *cleartext password sniffing attack* captures passwords sent across the wire
    as clear text, or uses a password database populated from one of many data breaches.
    As soon as an attacker gets your password, it’s game over. From there, the assailant
    will inevitably try to gain superuser access locally (which, as mentioned before,
    is much easier than making a remote attack), try to use the machine as an intermediary
    for attacking other hosts, or both.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*明文密码嗅探攻击*通过捕获以明文形式发送的密码，或者利用从多个数据泄露事件中获取的密码数据库，来实施攻击。一旦攻击者获取了你的密码，游戏就结束了。从那时起，攻击者必然会尝试在本地获取超级用户权限（如前所述，这比进行远程攻击容易得多），尝试利用该机器作为攻击其他主机的中介，或者两者兼而有之。'
- en: 'Some services are chronic attack targets due to poor implementation and design.
    You should always deactivate the following services (they’re all quite dated at
    this point, and rarely activated by default on most systems):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一些服务由于糟糕的实现和设计，成为了长期的攻击目标。你应该始终禁用以下服务（它们现在都非常过时，且大多数系统默认不启用）：
- en: ftpd For whatever reason, all FTP servers seem plagued with vulnerabilities.
    In addition, most FTP servers use cleartext passwords. If you have to move files
    from one machine to another, consider an SSH-based solution or an rsync server.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ftpd 无论出于什么原因，所有的FTP服务器似乎都有漏洞。此外，大多数FTP服务器使用明文密码。如果你需要将文件从一台机器转移到另一台机器，考虑使用基于SSH的解决方案或rsync服务器。
- en: telnetd, rlogind, rexecd All of these services pass remote session data (including
    passwords) in cleartext form. Avoid them unless you have a Kerberos-enabled version.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: telnetd、rlogind、rexecd 这些服务都以明文形式传输远程会话数据（包括密码）。除非你有启用Kerberos的版本，否则应避免使用它们。
- en: 10.7.2  Security Resources
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7.2  安全资源
- en: 'Here are three good security resources:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个不错的安全资源：
- en: The SANS Institute ([http://www.sans.org/](http://www.sans.org/)) offers training,
    services, a free weekly newsletter listing the top current vulnerabilities, sample
    security policies, and more.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SANS Institute（[http://www.sans.org/](http://www.sans.org/)）提供培训、服务、每周免费的时事通讯（列出当前的主要漏洞）、样本安全政策等。
- en: The CERT Division of Carnegie Mellon University’s Software Engineering Institute
    ([http://www.cert.org/](http://www.cert.org/)) is a good place to look for the
    most severe problems.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡内基梅隆大学软件工程研究所的CERT部门（[http://www.cert.org/](http://www.cert.org/)）是查找最严重问题的好地方。
- en: Insecure.org, a project from hacker and Nmap creator Gordon “Fyodor” Lyon ([http://www.insecure.org/](http://www.insecure.org/)),
    is the place to go for Nmap and pointers to all sorts of network exploit-testing
    tools. It’s much more open and specific about exploits than are many other sites.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Insecure.org是黑客和Nmap创始人戈登·“费奥多尔”·里昂（[http://www.insecure.org/](http://www.insecure.org/)）的一个项目，是了解Nmap和各种网络漏洞测试工具的好地方。与许多其他网站相比，它在漏洞方面提供了更多开放且具体的信息。
- en: 'If you’re interested in network security, you should learn all about Transport
    Layer Security (TLS) and its predecessor, Secure Socket Layer (SSL). These user-space
    network levels are typically added to networking clients and servers to support
    network transactions through the use of public-key encryption and certificates.
    A good guide is Davies’ *Implementing SSL/TLS Using Cryptography and PKI* (Wiley,
    2011) or Jean-Philippe Aumasson’s *Serious Cryptography: A Practical Introduction
    to Modern Encryption* (No Starch Press, 2017).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对网络安全感兴趣，你应该了解传输层安全性（TLS）及其前身安全套接字层（SSL）。这些用户空间的网络层通常被添加到网络客户端和服务器中，以通过使用公钥加密和证书支持网络交易。一本好的指南是戴维斯的*使用密码学和PKI实现SSL/TLS*（Wiley，2011）或让·菲利普·奥马松的*严肃的密码学：现代加密的实用入门*（No
    Starch Press，2017）。
- en: 10.8 Looking Forward
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.8 展望未来
- en: If you’re interested in getting your hands dirty with some complicated network
    servers, some very common ones are the Apache or nginx web servers and the Postfix
    email server. In particular, web servers are easy to install and most distributions
    supply packages. If your machine is behind a firewall or NAT-enabled router, you
    can experiment with the configuration as much as you’d like without worrying about
    security.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对自己动手操作一些复杂的网络服务器感兴趣，一些常见的服务器包括Apache或nginx Web服务器和Postfix电子邮件服务器。尤其是Web服务器容易安装，大多数发行版都提供了相关包。如果你的机器位于防火墙或NAT启用的路由器后面，你可以随心所欲地进行配置实验，而不必担心安全问题。
- en: Throughout the last few chapters, we’ve been gradually moving from kernel space
    into user space. Only a few utilities discussed in this chapter, such as `tcpdump`,
    interact with the kernel. The remainder of this chapter describes how sockets
    bridge the gap between the kernel’s transport layer and the user-space application
    layer. It’s more advanced material, of particular interest to programmers, so
    feel free to skip to the next chapter if you like.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们逐渐从内核空间转向用户空间。本章中讨论的只有少数工具，如`tcpdump`，与内核交互。本章其余部分描述了套接字如何弥合内核的传输层与用户空间应用层之间的差距。这是更高级的内容，特别适合程序员，因此如果你愿意，可以跳到下一章。
- en: 10.9 Network Sockets
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.9 网络套接字
- en: 'We’re now going to shift gears and look at how processes do the work of reading
    data from and writing data to the network. It’s easy enough for processes to read
    from and write to network connections that are already set up: all you need are
    some system calls, which you can read about in the recv(2) and send(2) manual
    pages. From the point of view of a process, perhaps the most important thing to
    know is how to access the network when using these system calls. On Unix systems,
    a process uses a socket to identify when and how it’s talking to the network.
    *Sockets* are the interface that processes use to access the network through the
    kernel; they represent the boundary between user space and kernel space. They’re
    often also used for interprocess communication (IPC).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将转变话题，看看进程是如何从网络读取数据和写入数据的。对于已经建立的网络连接，进程读取和写入数据是非常简单的：你只需要一些系统调用，相关内容可以在recv(2)和send(2)手册页中找到。从进程的角度来看，或许最重要的是如何在使用这些系统调用时访问网络。在Unix系统中，进程使用套接字来标识与网络通信的时间和方式。*套接字*是进程通过内核访问网络的接口；它们代表了用户空间和内核空间之间的边界。它们通常也用于进程间通信（IPC）。
- en: There are different types of sockets because processes need to access the network
    in different ways. For example, TCP connections are represented by stream sockets
    (`SOCK_STREAM`, from a programmer’s point of view), and UDP connections are represented
    by datagram sockets (`SOCK_DGRAM`).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 存在不同类型的套接字，因为进程需要以不同的方式访问网络。例如，TCP连接由流式套接字（`SOCK_STREAM`，从程序员的角度来看）表示，UDP连接由数据报套接字（`SOCK_DGRAM`）表示。
- en: Setting up a network socket can be somewhat complicated because you need to
    account for socket type, IP addresses, ports, and transport protocol at particular
    times. However, after all of the initial details are sorted out, servers use certain
    standard methods to deal with incoming traffic from the network. The flowchart
    in [Figure 10-1](#figure10-1) shows how many servers handle connections for incoming
    stream sockets.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 设置网络套接字可能有些复杂，因为你需要在特定的时刻考虑套接字类型、IP地址、端口和传输协议。然而，在所有初步细节搞定之后，服务器使用某些标准方法来处理来自网络的传入流量。[图10-1](#figure10-1)中的流程图展示了许多服务器如何处理传入流式套接字的连接。
- en: '![f10001](image_fi/500402c10/f10001.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![f10001](image_fi/500402c10/f10001.png)'
- en: 'Figure 10-1: One method for accepting and processing incoming connections'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-1：接收和处理传入连接的一种方法
- en: 'Notice that this type of server involves two kinds of sockets: one for listening
    and one for reading and writing. The master process uses the listening socket
    to look for connections from the network. When a new connection comes in, the
    master process uses the `accept()` system call to accept the connection, which
    creates the read/write socket dedicated to that connection. Next, the master process
    uses `fork()` to create a new child process to deal with the connection. Finally,
    the original socket remains the listener and continues to look for more connections
    on behalf of the master process.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种类型的服务器涉及两种套接字：一种用于监听，另一种用于读写。主进程使用监听套接字来查找来自网络的连接。当有新连接到来时，主进程使用`accept()`系统调用来接受连接，这会创建一个专门用于该连接的读写套接字。接下来，主进程使用`fork()`创建一个新的子进程来处理该连接。最后，原始套接字仍然作为监听器，继续代表主进程寻找更多的连接。
- en: 'After a process has set up a socket of a particular type, it can interact with
    it in a way that fits the socket type. This is what makes sockets flexible: if
    you need to change the underlying transport layer, you don’t have to rewrite all
    of the parts that send and receive data; you mostly need to modify the initialization
    code.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程设置了特定类型的套接字后，它可以以适合该套接字类型的方式与其交互。这就是套接字灵活性的体现：如果你需要更改底层的传输层，你不必重写所有发送和接收数据的部分；你只需要修改初始化代码。
- en: If you’re a programmer and you’d like to learn how to use the socket interface,
    *Unix Network Programming, Volume 1*, 3rd edition, by W. Richard Stevens, Bill
    Fenner, and Andrew M. Rudoff (Addison-Wesley Professional, 2003), is the classic
    guide. Volume 2 also covers interprocess communication.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是程序员，并且想学习如何使用套接字接口，*Unix Network Programming, Volume 1*（第3版），作者是 W. Richard
    Stevens、Bill Fenner 和 Andrew M. Rudoff（Addison-Wesley Professional，2003），是一本经典指南。第2卷也涵盖了进程间通信。
- en: 10.10 Unix Domain Sockets
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.10 Unix 域套接字
- en: Applications that use network facilities don’t have to involve two separate
    hosts. Many applications are built as client-server or peer-to-peer mechanisms,
    where processes running on the same machine use interprocess communication to
    negotiate what work needs to be done and who does it. For example, recall that
    daemons such as systemd and NetworkManager use D-Bus to monitor and react to system
    events.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络功能的应用程序不必涉及两个独立的主机。许多应用程序以客户端-服务器或点对点机制构建，在这种机制中，运行在同一台机器上的进程通过进程间通信来协商需要做什么工作以及由谁来做。例如，回想一下，像
    systemd 和 NetworkManager 这样的守护进程使用 D-Bus 来监控和响应系统事件。
- en: 'Processes are capable of using regular IP networking over localhost (127.0.0.1
    or ::1) to communicate with each other, but they typically use a special kind
    of socket called a *Unix domain socket* as an alternative. When a process connects
    to a Unix domain socket, it behaves almost exactly like it does with a network
    socket: it can listen for and accept connections on the socket, and you can even
    choose between different socket types to make it behave like TCP or UDP.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 进程能够通过本地主机（127.0.0.1 或 ::1）使用常规的 IP 网络进行通信，但它们通常使用一种叫做 *Unix 域套接字* 的特殊类型套接字作为替代。当进程连接到
    Unix 域套接字时，它的行为几乎与网络套接字相同：它可以监听并接受套接字上的连接，你甚至可以在不同的套接字类型之间进行选择，使其表现得像 TCP 或 UDP。
- en: 'Developers like Unix domain sockets for IPC for two reasons. First, they allow
    the option to use special socket files in the filesystem to control access, so
    any process that doesn’t have access to a socket file can’t use it. And because
    there’s no interaction with the network, it’s simpler and less prone to conventional
    network intrusion. For example, you’ll usually find the socket file for D-Bus
    in */var/run/dbus*:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者喜欢使用 Unix 域套接字进行进程间通信，主要有两个原因。首先，它们允许在文件系统中使用特殊的套接字文件来控制访问，因此任何没有访问套接字文件的进程就无法使用它。而且，由于不与网络交互，这样会更简单，且不容易受到常规网络入侵的影响。例如，你通常会在
    */var/run/dbus* 找到 D-Bus 的套接字文件：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Second, because the Linux kernel doesn’t have to go through the many layers
    of its networking subsystem when working with Unix domain sockets, performance
    tends to be much better.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，由于 Linux 内核在处理 Unix 域套接字时不必通过其网络子系统的多个层次，因此性能往往更好。
- en: Writing code for Unix domain sockets isn’t much different from supporting normal
    network sockets. Because the benefits can be significant, some network servers
    offer communication through both network and Unix domain sockets. For example,
    the MySQL database server mysqld can accept client connections from remote hosts,
    but it usually also offers a Unix domain socket at */var/run/mysqld/mysqld.sock*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Unix 域套接字编写代码与支持普通网络套接字没有太大区别。由于好处显著，一些网络服务器提供通过网络和 Unix 域套接字进行通信的功能。例如，MySQL
    数据库服务器 mysqld 可以接受来自远程主机的客户端连接，但它通常也会在 */var/run/mysqld/mysqld.sock* 提供一个 Unix
    域套接字。
- en: 'You can view a list of Unix domain sockets currently in use on your system
    with `lsof -U`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `lsof -U` 查看当前系统上使用中的 Unix 域套接字列表：
- en: '[PRE33]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The listing will be quite long because many applications make extensive use
    of unnamed sockets, which are indicated by `socket` in the `NAME` output column.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表会相当长，因为许多应用程序广泛使用未命名的套接字，这些套接字在 `NAME` 输出列中由 `socket` 表示。
