- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network Applications and Services
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter explores basic network applications—the clients and servers running
    in user space that reside at the application layer. Because this layer is at the
    top of the stack, close to end users, you may find this material more accessible
    than the material in Chapter 9. Indeed, you interact with network client applications
    such as web browsers every day.
  prefs: []
  type: TYPE_NORMAL
- en: To do their work, network clients connect to corresponding network servers.
    Unix network servers come in many forms. A server program can listen to a port
    on its own or through a secondary server. We’ll look at some common servers as
    well as tools that will help you understand and debug server operation.
  prefs: []
  type: TYPE_NORMAL
- en: Network clients use the operating system’s transport layer protocols and interfaces,
    so it’s important to understand the basics of the TCP and UDP transport layers.
    Let’s start looking at network applications by experimenting with a network client
    that uses TCP.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1 The Basics of Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TCP services are among the easiest to understand because they are built upon
    simple, uninterrupted two-way data streams. Perhaps the best way to see how they
    work is to talk directly to an unencrypted web server on TCP port 80 to get an
    idea of how data moves across the connection. For example, run the following command
    to connect to the IANA documentation example web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get a response like this, indicating a successful connection to
    the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now enter these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Press enter twice after the last line. The server should send a bunch of HTML
    text as a response. To terminate the connection, press ctrl-D.
  prefs: []
  type: TYPE_NORMAL
- en: 'This exercise demonstrates that:'
  prefs: []
  type: TYPE_NORMAL
- en: The remote host has a web server process listening on TCP port 80\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`telnet` was the client that initiated the connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason you have to terminate the connection with ctrl-D is that, because
    most web pages need several requests to load, it makes sense to keep the connection
    open. If you explore web servers at the protocol level, you may find that this
    behavior varies. For example, many servers disconnect quickly if they do not receive
    a request soon after a connection opens.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 A Closer Look
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous example, you manually interacted with a web server on the network
    with `telnet`, using the HTTP application layer protocol. Although you’d normally
    use a web browser to make this sort of connection, let’s take just one step up
    from `telnet` and use a command-line program that knows how to speak to the HTTP
    application layer. We’ll use the `curl` utility with a special option to record
    details about its communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll get a lot of HTML output. Ignore it (or redirect it to */dev/null*)
    and instead look at the newly created file *trace_file*. If the connection was
    successful, the first part of the file should look something like the following,
    at the point where `curl` attempts to establish the TCP connection to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything you’ve seen so far happens in the transport layer or below. However,
    if this connection succeeds, `curl` then tries to send the request (the “header”);
    this is where the application layer starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Line 1 is `curl` debugging output telling you what it will do next. The remaining
    lines show what `curl` sends to the server. The text in bold is what goes to the
    server; the hexadecimal numbers at the beginning are just debugging offsets `curl`
    adds to help you keep track of how much data was sent or received.
  prefs: []
  type: TYPE_NORMAL
- en: 'At 2, you can see that `curl` starts by issuing a `GET` command to the server
    (as you did with `telnet`), followed by some extra information for the server
    and an empty line. Next, the server sends a reply, first with its own header,
    shown here in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Much like the previous output, the `<=` lines are debugging output, and `0000:`
    precedes the lines of output to tell you the offsets (in `curl`, the header won’t
    count toward the offset; that’s why all of these lines begin with 0).
  prefs: []
  type: TYPE_NORMAL
- en: 'The header in the server’s reply can be fairly long, but at some point the
    server transitions from transmitting headers to sending the actual requested document,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This output also illustrates an important property of the application layer.
    Even though the debugging output says `Recv header` and `Recv data`, implying
    that those are two different kinds of messages from the server, there’s no difference
    in how `curl` talked to the operating system to retrieve the two messages, in
    how the operating system handled them, or in how the network handled the packets
    underneath. The difference is entirely within the user-space `curl` application.
    `curl` knew that until this point it had been getting headers, but when it received
    a blank line 1, which signifies the end of headers in HTTP, it knew to interpret
    anything that followed as the requested document.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true of the server sending this data. When sending the reply, the
    server’s operating system didn’t differentiate between header and document data;
    the distinctions happen inside the user-space server program.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 Network Servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most network servers are like other server daemons on your system such as cron,
    except that they interact with network ports. In fact, syslogd, discussed in Chapter
    7, accepts UDP packets on port 514 when started with the `-r` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some other common network servers that you might find running on your
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: httpd, apache, apache2, nginx Web servers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: sshd Secure shell daemon
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: postfix, qmail, sendmail Mail servers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: cupsd Print server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: nfsd, mountd Network filesystem (file-sharing) daemons
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: smbd, nmbd Windows file-sharing daemons (see Chapter 12)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: rpcbind Remote procedure call (RPC) portmap service daemon
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One feature common to most network servers is that they usually operate as multiple
    processes. At least one process listens on a network port, and upon receiving
    a new incoming connection, the listening process uses `fork()` to create a child
    process, which is then responsible for the new connection. The child, often called
    a *worker* process, terminates when the connection is closed. Meanwhile, the original
    listening process continues to listen on the network port. This process allows
    a server to easily handle many connections without much trouble.
  prefs: []
  type: TYPE_NORMAL
- en: There are some exceptions to this model, however. Calling `fork()` adds a significant
    amount of system overhead. To avoid this, high-performance TCP servers such as
    the Apache web server may create a number of worker processes upon startup so
    they’re available to handle connections as needed. Servers that accept UDP packets
    don’t need to fork at all, as they don’t have connections to listen for; they
    simply receive data and react to it.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.1  Secure Shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every network server program works a bit differently. To get hands-on experience
    with a server’s configuration and operation, let’s take a close look at the standalone
    secure shell (SSH) server. One of the most common network service applications,
    SSH is the de facto standard for remote access to a Unix machine. SSH is designed
    to allow secure shell logins, remote program execution, simple file sharing, and
    more—replacing the old, insecure `telnet` and `rlogin` remote-access systems with
    public-key cryptography for authentication and simpler ciphers for session data.
    Most ISPs and cloud providers require SSH for shell access to their services,
    and many Linux-based network appliances (such as network attached storage, or
    NAS, devices) provide access via SSH as well. OpenSSH ([http://www.openssh.com/](http://www.openssh.com/))
    is a popular free SSH implementation for Unix, and nearly all Linux distributions
    come with it preinstalled. The OpenSSH client program is `ssh`, and the server
    is sshd. There are two main SSH protocol versions: 1 and 2\. OpenSSH supports
    only version 2, having dropped version 1 support due to vulnerabilities and lack
    of use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Among its many useful capabilities and features, SSH does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Encrypts your password and all other session data, protecting you from snoopers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tunnels other network connections, including those from X Window System clients.
    (You’ll learn more about X in Chapter 14.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offers clients for nearly any operating system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses keys for host authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SSH does have a few disadvantages. For one, in order to set up an SSH connection,
    you need the remote host’s public key, and you don’t necessarily get it in a secure
    way (though you can check it manually to make sure you’re not being spoofed).
    For an overview of how several methods of cryptography work, get your hands on
    the book *Serious Cryptography: A Practical Introduction to Modern Encryption*
    (No Starch Press, 2017), by Jean-Philippe Aumasson. Two in-depth books on SSH
    are *SSH Mastery: OpenSSH, PuTTY, Tunnels, and Keys*, 2nd edition, by Michael
    W. Lucas (Tilted Windmill Press, 2018) and *SSH, The Secure Shell: The Definitive
    Guide*, 2nd edition, by Daniel J. Barrett, Richard E. Silverman, and Robert G.
    Byrnes (O’Reilly, 2005).'
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.2  The sshd Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Running the sshd server to allow remote connections to your system requires
    a configuration file and host keys. Most distributions keep configurations in
    the */etc/ssh* configuration directory and try to configure everything properly
    for you if you install their sshd package. (The server configuration filename
    *sshd_config* is easy to confuse with the client’s *ssh_config* setup file, so
    be careful.)
  prefs: []
  type: TYPE_NORMAL
- en: You shouldn’t need to change anything in *sshd_config*, but it never hurts to
    check. The file consists of key-value pairs, as shown in this fragment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Lines beginning with `#` are comments, and many comments in your *sshd_config*
    indicate default values for various parameters, as you can see from this excerpt.
    The sshd_config(5) manual page contains descriptions of the parameters and possible
    values, but these are among the most important:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HostKey` `file` Uses `file` as a host key. (Host keys are described next.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PermitRootLogin` `value` Permits the superuser to log in with SSH if `value`
    is set to `yes`. Set `value` to `no` to prevent this.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LogLevel` `level` Logs messages with syslog level `level` (defaults to `INFO`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SyslogFacility` `name` Logs messages with syslog facility `name` (defaults
    to `AUTH`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`X11Forwarding` `value` Enables X Window System client tunneling if `value`
    is set to `yes`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`XAuthLocation` `path` Specifies the location of the `xauth` utility on your
    system. X tunneling will not work without this path. If `xauth` isn’t in */usr/bin*,
    set `path` to the full pathname for `xauth`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating Host Keys
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: OpenSSH has several host key sets. Each set has a public key (with a *.pub*
    file extension) and a private key (with no extension).
  prefs: []
  type: TYPE_NORMAL
- en: SSH version 2 has RSA and DSA keys. RSA and DSA are public key cryptography
    algorithms. The key filenames are given in [Table 10-1](#table10-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-1: OpenSSH Key Files'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Filename** | **Key type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *ssh_host_rsa_key* | Private RSA key |'
  prefs: []
  type: TYPE_TB
- en: '| *ssh_host_rsa_key.pub* | Public RSA key |'
  prefs: []
  type: TYPE_TB
- en: '| *ssh_host_dsa_key* | Private DSA key |'
  prefs: []
  type: TYPE_TB
- en: '| *ssh_host_dsa_key.pub* | Public DSA key |'
  prefs: []
  type: TYPE_TB
- en: 'Creating a key involves a numerical computation that generates both public
    and private keys. Normally you won’t need to create the keys because the OpenSSH
    installation program or your distribution’s installation script will do it for
    you, but you need to know how to do so if you plan to use programs like `ssh-agent`
    that provide authentication services without a password. To create SSH protocol
    version 2 keys, use the `ssh-keygen` program that comes with OpenSSH:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The SSH server and clients also use a *key file*, called *ssh_known_hosts*,
    to store public keys from other hosts. If you intend to use authentication based
    on a remote client’s identity, the server’s *ssh_known_hosts* file must contain
    the public host keys of all trusted clients. Knowing about the key files is handy
    if you’re replacing a machine. When installing a new machine from scratch, you
    can import the key files from the old machine to ensure that users don’t get key
    mismatches when connecting to the new one.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the SSH Server
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although most distributions ship with SSH, they usually don’t start the sshd
    server by default. On Ubuntu and Debian, the SSH server is not installed on a
    new system; installing its package creates the keys, starts the server, and adds
    the server startup to the bootup configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Fedora, sshd is installed by default but turned off. To start sshd at boot,
    use `systemctl` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to start the server immediately without rebooting, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Fedora normally creates any missing host key files upon the first sshd startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re running another distribution, you likely won’t need to manually configure
    the sshd startup. However, you should know that there are two startup modes: standalone
    and on-demand. The standalone server is by far more common, and it’s just a matter
    of running sshd as root. The sshd server process writes its PID to */var/run/sshd.pid*
    (of course, when run by systemd, it’s also tracked by its cgroup, as you saw in
    Chapter 6).'
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative, systemd can start sshd on demand through a socket unit. This
    usually isn’t a good idea, because the server occasionally needs to generate key
    files, and that process can take a long time.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.3  fail2ban
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you set up an SSH server on your machine and open it up to the internet,
    you’ll quickly discover constant intrusion attempts. These brute-force attacks
    won’t succeed if your system is properly configured and you haven’t chosen stupid
    passwords. However, they will be annoying, consume CPU time, and unnecessarily
    clutter your logs.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this, you want to set up a mechanism to block repeated login attempts.
    As of this writing, the fail2ban package is the most popular way to do this; it’s
    simply a script that watches log messages. Upon seeing a certain number of failed
    requests from one host within a certain time frame, fail2ban uses `iptables` to
    create a rule to deny traffic from that host. After a specified period, during
    which the host has probably given up trying to connect, fail2ban removes the rule.
  prefs: []
  type: TYPE_NORMAL
- en: Most Linux distributions offer a fail2ban package with preconfigured defaults
    for SSH.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.4  The SSH Client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To log in to a remote host, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You may omit `remote_username``@` if your local username is the same as on
    `remote_host`. You can also run pipelines to and from an `ssh` command as shown
    in the following example, which copies a directory *dir* to another host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The global SSH client configuration file *ssh_config* should be in */etc/ssh*,
    the same location as your *sshd_config* file. As with the server configuration
    file, the client configuration file has key-value pairs, but you shouldn’t need
    to change them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most frequent problem with using SSH clients occurs when an SSH public
    key in your local *ssh_known_hosts* or *.ssh/known_hosts* file does not match
    the key on the remote host. Bad keys cause errors or warnings like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This usually just means that the remote host’s administrator changed the keys
    (which often happens upon a hardware or cloud server upgrade), but it never hurts
    to check with the administrator if you’re not sure. In any case, the preceding
    message tells you that the bad key is in line 12 of a user’s *known_hosts* file
    1.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t suspect foul play, just remove the offending line or replace it
    with the correct public key.
  prefs: []
  type: TYPE_NORMAL
- en: SSH File Transfer Clients
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: OpenSSH includes the file transfer programs `scp` and `sftp`, which are intended
    as replacements for the older, insecure programs `rcp` and `ftp`. You can use
    `scp` to transfer files to or from a remote machine to your machine or from one
    host to another. It works like the `cp` command. Here are a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy a file from a remote host to the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy a file from the local machine to a remote host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy a file from one remote host to a second remote host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `sftp` program works like the obsolete command-line `ftp` client, using
    `get` and `put` commands. The remote host must have an `sftp-server` program installed,
    which you can expect if the remote host also uses OpenSSH.
  prefs: []
  type: TYPE_NORMAL
- en: SSH Clients for Non-Unix Platforms
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are SSH clients for all popular operating systems. Which one should you
    choose? PuTTY is a good, basic Windows client that includes a secure file-copy
    program. macOS is based on Unix and includes OpenSSH.
  prefs: []
  type: TYPE_NORMAL
- en: '10.4 Pre-systemd Network Connection Servers: inetd/xinetd'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before the widespread use of systemd and the socket units that you saw in Section
    6.3.7, there were a handful of servers that provided a standard means of building
    a network service. Many minor network services are very similar in their connection
    requirements, so implementing standalone servers for every service can be inefficient.
    Each server must be separately configured to handle port listening, access control,
    and port configuration. These actions are performed in the same way for most services;
    only when a server accepts a connection is communication handled any differently.
  prefs: []
  type: TYPE_NORMAL
- en: One traditional way to simplify the use of servers is with the inetd daemon,
    a kind of *superserver* designed to standardize network port access and interfaces
    between server programs and network ports. After you start inetd, it reads its
    configuration file and then listens on the network ports defined in that file.
    As new network connections come in, inetd attaches a newly started process to
    the connection.
  prefs: []
  type: TYPE_NORMAL
- en: A newer version of inetd called xinetd offers easier configuration and better
    access control, but xinetd has almost entirely been phased out in favor of systemd.
    However, you might see it on an older system or one that does not use systemd.
  prefs: []
  type: TYPE_NORMAL
- en: 10.5 Diagnostic Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at a few diagnostic tools that are useful for poking around the application
    layer. Some dig into the transport and network layers, because everything in the
    application layer eventually maps down to something in those lower layers.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in Chapter 9, `netstat` is a basic network service debugging tool
    that can display a number of transport and network layer statistics. [Table 10-2](#table10-2)
    reviews a few useful options for viewing connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-2: Useful Connection-Reporting Options for netstat'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Option** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-t` | Prints TCP port information |'
  prefs: []
  type: TYPE_TB
- en: '| `-u` | Prints UDP port information |'
  prefs: []
  type: TYPE_TB
- en: '| `-l` | Prints listening ports |'
  prefs: []
  type: TYPE_TB
- en: '| `-a` | Prints every active port |'
  prefs: []
  type: TYPE_TB
- en: '| `-n` | Disables name lookups (speeds things up; also useful if DNS isn’t
    working) |'
  prefs: []
  type: TYPE_TB
- en: '| `-4`, `-6` | Limits the output to IP version 4 or 6 |'
  prefs: []
  type: TYPE_TB
- en: 10.5.1  lsof
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Chapter 8, you learned that `lsof` not only can track open files, but can
    also list the programs currently using or listening to ports. For a complete list
    of such programs, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this command as a regular user, it shows only that user’s processes.
    When you run it as root, the output should look something like this, displaying
    a variety of processes and users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This example output shows users and process IDs for server and client programs,
    from the old-style RPC services at the top 1, to the multicast DNS service provided
    by `avahi` 2, to even an IPv6-ready printer service, cupsd 3. The last two entries
    show client connections: an SSH connection 4 and a secure web connection from
    the Chromium web browser 5. Because the output can be extensive, it’s usually
    best to apply a filter (as discussed in the following section).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lsof` program is like `netstat` in that it tries to reverse-resolve every
    IP address that it finds into a hostname, which slows down the output. Use the
    `-n` option to disable name resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can also specify `-P` to disable */etc/services* port name lookups.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering by Protocol and Port
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you’re looking for a particular port (say, you know that a process is using
    a particular port and you want to know what that process is), use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The full syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `protocol`, `@``host`, and `:``port` parameters are all optional and will
    filter the `lsof` output accordingly. As with most network utilities, `host` and
    `port` can be either names or numbers. For example, if you want to see connections
    only on TCP port 443 (the HTTPS port), use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To filter based on IP version, use `-i4` (IPv4) or `-i6` (IPv6). You can add
    this as a separate option or just add the number in with more complex filters
    (for example, `-i6TCP:443`).
  prefs: []
  type: TYPE_NORMAL
- en: You can specify service names from */etc/services* (as in `-iTCP:ssh`) instead
    of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering by Connection Status
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One particularly handy `lsof` filter is connection status. For example, to
    show only the processes listening on TCP ports, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This command gives you a good overview of the network server processes currently
    running on your system. However, because UDP servers don’t listen and don’t have
    connections, you’ll have to use `-iUDP` to view running clients as well as servers.
    This usually isn’t a problem, because you probably won’t have many UDP servers
    on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 10.5.2  tcpdump
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your system normally doesn’t bother with network traffic that isn’t addressed
    to one of its MAC addresses. If you need to see exactly what’s crossing your network,
    `tcpdump` puts your network interface card into *promiscuous mode* and reports
    on every packet that comes across. Entering `tcpdump` with no arguments produces
    output like the following, which includes an ARP request and web connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can tell `tcpdump` to be more specific by adding filters. You can filter
    based on source and destination hosts, networks, Ethernet addresses, protocols
    at many different layers in the network model, and much more. Among the many packet
    protocols that `tcpdump` recognizes are ARP, RARP, ICMP, TCP, UDP, IP, IPv6, AppleTalk,
    and IPX packets. For example, to tell `tcpdump` to output only TCP packets, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To see web packets and UDP packets, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The keyword `or` specifies that the condition on either the left or right can
    be true to pass the filter. Similarly, the `and` keyword requires both conditions
    to be true.
  prefs: []
  type: TYPE_NORMAL
- en: Primitives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the preceding examples, `tcp`, `udp`, and `port` `80` are basic elements
    of filters called *primitives*. The most important primitives are listed in [Table
    10-3](#table10-3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-3: tcpdump Primitives'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Primitive** | **Packet specification** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `tcp` | TCP packets |'
  prefs: []
  type: TYPE_TB
- en: '| `udp` | UDP packets |'
  prefs: []
  type: TYPE_TB
- en: '| `ip` | IPv4 packets |'
  prefs: []
  type: TYPE_TB
- en: '| `ip6` | IPv6 packets |'
  prefs: []
  type: TYPE_TB
- en: '| `port` `port` | TCP and/or UDP packets to/from port `port` |'
  prefs: []
  type: TYPE_TB
- en: '| `host` `host` | Packets to or from `host` |'
  prefs: []
  type: TYPE_TB
- en: '| `net` `network` | Packets to or from `network` |'
  prefs: []
  type: TYPE_TB
- en: Operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `or` used earlier is an *operator*. `tcpdump` can use multiple operators
    (such as `and` and `!`), and you can group operators in parentheses. If you plan
    to do any serious work with `tcpdump`, make sure to read the pcap-filter(7) manual
    page, especially the section that describes the primitives.
  prefs: []
  type: TYPE_NORMAL
- en: 10.5.3  netcat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need more flexibility in connecting to a remote host than a command
    like `telnet` `host``port` allows, use `netcat` (or `nc`). `netcat` can connect
    to remote TCP/UDP ports, specify a local port, listen on ports, scan ports, redirect
    standard I/O to and from network connections, and more. To open a TCP connection
    to a port with `netcat`, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`netcat` terminates when the other side ends the connection, which can be confusing
    if you redirect standard input to `netcat`, because you might not get your prompt
    back after sending data (as opposed to almost any other command pipeline). You
    can end the connection at any time by pressing ctrl-C. (If you’d like the program
    and network connection to terminate based on the standard input stream, try the
    `sock` program instead.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To listen on a particular port, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If `netcat` is successful at listening on the port, it will wait for a connection,
    and upon establishing a connection, prints the output from that connection, and
    sends any standard input to the connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some additional notes on `netcat`:'
  prefs: []
  type: TYPE_NORMAL
- en: There isn’t much debugging output by default. If something fails, `netcat` fails
    silently, but it does set an appropriate exit code. If you’d like some more information,
    add the `-v` (“verbose”) option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, the `netcat` client tries to connect with IPv4 and IPv6\. However,
    in server mode, `netcat` defaults to IPv4\. To force the protocol, use `-4` for
    IPv4 and `-6` for IPv6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-u` option specifies UDP instead of TCP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.5.4  Port Scanning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you don’t even know what services the machines on your networks are
    offering or even which IP addresses are in use. The Network Mapper (Nmap) program
    scans all ports on a machine or network of machines looking for open ports, and
    it lists the ports it finds. Most distributions have an Nmap package, or you can
    get it at [http://www.insecure.org/](http://www.insecure.org/). (See the Nmap
    manual page and online resources for all that Nmap can do.)
  prefs: []
  type: TYPE_NORMAL
- en: 'When listing ports on your own machine, it often helps to run the Nmap scan
    from at least two points: from your own machine and from another one (possibly
    outside your local network). Doing so will give you an overview of what your firewall
    is blocking.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `nmap``host` to run a generic scan on a host. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, a number of services are open, many of which are not enabled
    by default on most distributions. In fact, the only one here that’s usually on
    by default is port 111, the `rpcbind` port.
  prefs: []
  type: TYPE_NORMAL
- en: Nmap is also capable of scanning ports over IPv6 if you add the `-6` option.
    This can be a handy way of identifying services that do not support IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: 10.6 Remote Procedure Calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What about the rpcbind service from the scan in the preceding section? RPC stands
    for *remote procedure call (RPC)*, a system residing in the lower parts of the
    application layer. It’s designed to make it easier for programmers to build client/server
    network applications, where a client program calls functions that execute on a
    remote server. Each type of remote server program is identified by an assigned
    program number.
  prefs: []
  type: TYPE_NORMAL
- en: RPC implementations use transport protocols such as TCP and UDP, and they require
    a special intermediary service to map program numbers to TCP and UDP ports. The
    server is called rpcbind, and it must be running on any machine that wants to
    use RPC services.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what RPC services your computer has, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: RPC is one of those protocols that just doesn’t want to die. The Network File
    System (NFS) and Network Information Service (NIS) systems use RPC, but they are
    completely unnecessary on standalone machines. But whenever you think that you’ve
    eliminated all need for rpcbind, something else comes up, such as File Access
    Monitor (FAM) support in GNOME.
  prefs: []
  type: TYPE_NORMAL
- en: 10.7 Network Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because Linux is a very popular Unix flavor on the PC platform, and especially
    because it is widely used for web servers, it attracts many unpleasant characters
    who try to break into computer systems. Section 9.25 discussed firewalls, but
    that’s not really the whole story on security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Network security attracts extremists—those who *really* like to break into
    systems (whether for fun or money) and those who come up with elaborate protection
    schemes and *really* like to swat away people trying to break into their systems.
    (This, too, can be very profitable.) Fortunately, you don’t need to know very
    much to keep your system safe. Here are a few basic rules of thumb:'
  prefs: []
  type: TYPE_NORMAL
- en: Run as few services as possible Intruders can’t break into services that don’t
    exist on your system. If you know what a service is and you’re not using it, don’t
    turn it on for the sole reason that you might want to use it “at some later point.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Block as much as possible with a firewall Unix systems have a number of internal
    services that you may not know about (such as TCP port 111 for the RPC port-mapping
    server), and no other system in the world *should* know about them. It can be
    very difficult to track and regulate the services on your system because many
    different kinds of programs listen on various ports. To keep intruders from discovering
    internal services on your system, use effective firewall rules and install a firewall
    at your router.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Track the services that you offer to the internet If you run an SSH server,
    Postfix, or similar services, keep your software up to date and get appropriate
    security alerts. (See Section 10.7.2 for some online resources.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use “long-term support” distribution releases for servers Security teams normally
    concentrate their work on stable, supported distribution releases. Development
    and testing releases such Debian Unstable and Fedora Rawhide receive much less
    attention.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t give an account on your system to anyone who doesn’t need one It’s much
    easier to gain superuser access from a local account than it is to break in remotely.
    In fact, given the huge base of software (and the resulting bugs and design flaws)
    available on most systems, it can be easy to gain superuser access to a system
    after you get to a shell prompt. Don’t assume that your friends know how to protect
    their passwords (or choose good passwords in the first place).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Avoid installing dubious binary packages They can contain Trojan horses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That’s the practical end of protecting yourself. But why is it important to
    do so? There are three basic kinds of network attacks that can be directed at
    a Linux machine:'
  prefs: []
  type: TYPE_NORMAL
- en: Full compromise This means getting superuser access (full control) of a machine.
    An intruder can accomplish this by trying a service attack, such as a buffer overflow
    exploit, or by taking over a poorly protected user account and then trying to
    exploit a poorly written setuid program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Denial-of-service (DoS) attack This prevents a machine from carrying out its
    network services or forces a computer to malfunction in some other way without
    the use of any special access. Normally, a DoS attack is just a flood of network
    requests, but it can also be an exploit of a flaw in a server program that causes
    a crash. These attacks are harder to prevent, but they are easier to respond to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Malware Linux users are mostly immune to malware such as email worms and viruses,
    simply because their email clients aren’t stupid enough to actually run programs
    sent in message attachments. But Linux malware does exist. Avoid downloading and
    installing executable software from places that you’ve never heard of.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 10.7.1  Typical Vulnerabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two basic types of vulnerabilities to worry about: direct attacks
    and cleartext password sniffing. *Direct attacks* try to take over a machine without
    being terribly subtle. One of the most common is locating an unprotected or otherwise
    vulnerable service on your system. This can be as simple as a service that isn’t
    authenticated by default, such as an administrator account without a password.
    Once an intruder has access to one service on a system, they can use it to try
    to compromise the whole system. In the past, a common direct attack was the buffer
    overflow exploit, where a careless programmer doesn’t check the bounds of a buffer
    array. This has been mitigated somewhat by Address Space Layout Randomization
    (ASLR) techniques in the kernel and protective measures elsewhere.'
  prefs: []
  type: TYPE_NORMAL
- en: A *cleartext password sniffing attack* captures passwords sent across the wire
    as clear text, or uses a password database populated from one of many data breaches.
    As soon as an attacker gets your password, it’s game over. From there, the assailant
    will inevitably try to gain superuser access locally (which, as mentioned before,
    is much easier than making a remote attack), try to use the machine as an intermediary
    for attacking other hosts, or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some services are chronic attack targets due to poor implementation and design.
    You should always deactivate the following services (they’re all quite dated at
    this point, and rarely activated by default on most systems):'
  prefs: []
  type: TYPE_NORMAL
- en: ftpd For whatever reason, all FTP servers seem plagued with vulnerabilities.
    In addition, most FTP servers use cleartext passwords. If you have to move files
    from one machine to another, consider an SSH-based solution or an rsync server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: telnetd, rlogind, rexecd All of these services pass remote session data (including
    passwords) in cleartext form. Avoid them unless you have a Kerberos-enabled version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 10.7.2  Security Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are three good security resources:'
  prefs: []
  type: TYPE_NORMAL
- en: The SANS Institute ([http://www.sans.org/](http://www.sans.org/)) offers training,
    services, a free weekly newsletter listing the top current vulnerabilities, sample
    security policies, and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CERT Division of Carnegie Mellon University’s Software Engineering Institute
    ([http://www.cert.org/](http://www.cert.org/)) is a good place to look for the
    most severe problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insecure.org, a project from hacker and Nmap creator Gordon “Fyodor” Lyon ([http://www.insecure.org/](http://www.insecure.org/)),
    is the place to go for Nmap and pointers to all sorts of network exploit-testing
    tools. It’s much more open and specific about exploits than are many other sites.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you’re interested in network security, you should learn all about Transport
    Layer Security (TLS) and its predecessor, Secure Socket Layer (SSL). These user-space
    network levels are typically added to networking clients and servers to support
    network transactions through the use of public-key encryption and certificates.
    A good guide is Davies’ *Implementing SSL/TLS Using Cryptography and PKI* (Wiley,
    2011) or Jean-Philippe Aumasson’s *Serious Cryptography: A Practical Introduction
    to Modern Encryption* (No Starch Press, 2017).'
  prefs: []
  type: TYPE_NORMAL
- en: 10.8 Looking Forward
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re interested in getting your hands dirty with some complicated network
    servers, some very common ones are the Apache or nginx web servers and the Postfix
    email server. In particular, web servers are easy to install and most distributions
    supply packages. If your machine is behind a firewall or NAT-enabled router, you
    can experiment with the configuration as much as you’d like without worrying about
    security.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the last few chapters, we’ve been gradually moving from kernel space
    into user space. Only a few utilities discussed in this chapter, such as `tcpdump`,
    interact with the kernel. The remainder of this chapter describes how sockets
    bridge the gap between the kernel’s transport layer and the user-space application
    layer. It’s more advanced material, of particular interest to programmers, so
    feel free to skip to the next chapter if you like.
  prefs: []
  type: TYPE_NORMAL
- en: 10.9 Network Sockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re now going to shift gears and look at how processes do the work of reading
    data from and writing data to the network. It’s easy enough for processes to read
    from and write to network connections that are already set up: all you need are
    some system calls, which you can read about in the recv(2) and send(2) manual
    pages. From the point of view of a process, perhaps the most important thing to
    know is how to access the network when using these system calls. On Unix systems,
    a process uses a socket to identify when and how it’s talking to the network.
    *Sockets* are the interface that processes use to access the network through the
    kernel; they represent the boundary between user space and kernel space. They’re
    often also used for interprocess communication (IPC).'
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of sockets because processes need to access the network
    in different ways. For example, TCP connections are represented by stream sockets
    (`SOCK_STREAM`, from a programmer’s point of view), and UDP connections are represented
    by datagram sockets (`SOCK_DGRAM`).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a network socket can be somewhat complicated because you need to
    account for socket type, IP addresses, ports, and transport protocol at particular
    times. However, after all of the initial details are sorted out, servers use certain
    standard methods to deal with incoming traffic from the network. The flowchart
    in [Figure 10-1](#figure10-1) shows how many servers handle connections for incoming
    stream sockets.
  prefs: []
  type: TYPE_NORMAL
- en: '![f10001](image_fi/500402c10/f10001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-1: One method for accepting and processing incoming connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that this type of server involves two kinds of sockets: one for listening
    and one for reading and writing. The master process uses the listening socket
    to look for connections from the network. When a new connection comes in, the
    master process uses the `accept()` system call to accept the connection, which
    creates the read/write socket dedicated to that connection. Next, the master process
    uses `fork()` to create a new child process to deal with the connection. Finally,
    the original socket remains the listener and continues to look for more connections
    on behalf of the master process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After a process has set up a socket of a particular type, it can interact with
    it in a way that fits the socket type. This is what makes sockets flexible: if
    you need to change the underlying transport layer, you don’t have to rewrite all
    of the parts that send and receive data; you mostly need to modify the initialization
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re a programmer and you’d like to learn how to use the socket interface,
    *Unix Network Programming, Volume 1*, 3rd edition, by W. Richard Stevens, Bill
    Fenner, and Andrew M. Rudoff (Addison-Wesley Professional, 2003), is the classic
    guide. Volume 2 also covers interprocess communication.
  prefs: []
  type: TYPE_NORMAL
- en: 10.10 Unix Domain Sockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications that use network facilities don’t have to involve two separate
    hosts. Many applications are built as client-server or peer-to-peer mechanisms,
    where processes running on the same machine use interprocess communication to
    negotiate what work needs to be done and who does it. For example, recall that
    daemons such as systemd and NetworkManager use D-Bus to monitor and react to system
    events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Processes are capable of using regular IP networking over localhost (127.0.0.1
    or ::1) to communicate with each other, but they typically use a special kind
    of socket called a *Unix domain socket* as an alternative. When a process connects
    to a Unix domain socket, it behaves almost exactly like it does with a network
    socket: it can listen for and accept connections on the socket, and you can even
    choose between different socket types to make it behave like TCP or UDP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers like Unix domain sockets for IPC for two reasons. First, they allow
    the option to use special socket files in the filesystem to control access, so
    any process that doesn’t have access to a socket file can’t use it. And because
    there’s no interaction with the network, it’s simpler and less prone to conventional
    network intrusion. For example, you’ll usually find the socket file for D-Bus
    in */var/run/dbus*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Second, because the Linux kernel doesn’t have to go through the many layers
    of its networking subsystem when working with Unix domain sockets, performance
    tends to be much better.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code for Unix domain sockets isn’t much different from supporting normal
    network sockets. Because the benefits can be significant, some network servers
    offer communication through both network and Unix domain sockets. For example,
    the MySQL database server mysqld can accept client connections from remote hosts,
    but it usually also offers a Unix domain socket at */var/run/mysqld/mysqld.sock*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view a list of Unix domain sockets currently in use on your system
    with `lsof -U`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The listing will be quite long because many applications make extensive use
    of unnamed sockets, which are indicated by `socket` in the `NAME` output column.
  prefs: []
  type: TYPE_NORMAL
