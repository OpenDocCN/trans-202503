- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network Applications and Services
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: This chapter explores basic network applications—the clients and servers running
    in user space that reside at the application layer. Because this layer is at the
    top of the stack, close to end users, you may find this material more accessible
    than the material in Chapter 9. Indeed, you interact with network client applications
    such as web browsers every day.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: To do their work, network clients connect to corresponding network servers.
    Unix network servers come in many forms. A server program can listen to a port
    on its own or through a secondary server. We’ll look at some common servers as
    well as tools that will help you understand and debug server operation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Network clients use the operating system’s transport layer protocols and interfaces,
    so it’s important to understand the basics of the TCP and UDP transport layers.
    Let’s start looking at network applications by experimenting with a network client
    that uses TCP.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 10.1 The Basics of Services
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TCP services are among the easiest to understand because they are built upon
    simple, uninterrupted two-way data streams. Perhaps the best way to see how they
    work is to talk directly to an unencrypted web server on TCP port 80 to get an
    idea of how data moves across the connection. For example, run the following command
    to connect to the IANA documentation example web server:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should get a response like this, indicating a successful connection to
    the server:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now enter these two lines:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Press enter twice after the last line. The server should send a bunch of HTML
    text as a response. To terminate the connection, press ctrl-D.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'This exercise demonstrates that:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The remote host has a web server process listening on TCP port 80\.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`telnet` was the client that initiated the connection.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason you have to terminate the connection with ctrl-D is that, because
    most web pages need several requests to load, it makes sense to keep the connection
    open. If you explore web servers at the protocol level, you may find that this
    behavior varies. For example, many servers disconnect quickly if they do not receive
    a request soon after a connection opens.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 A Closer Look
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous example, you manually interacted with a web server on the network
    with `telnet`, using the HTTP application layer protocol. Although you’d normally
    use a web browser to make this sort of connection, let’s take just one step up
    from `telnet` and use a command-line program that knows how to speak to the HTTP
    application layer. We’ll use the `curl` utility with a special option to record
    details about its communication:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You’ll get a lot of HTML output. Ignore it (or redirect it to */dev/null*)
    and instead look at the newly created file *trace_file*. If the connection was
    successful, the first part of the file should look something like the following,
    at the point where `curl` attempts to establish the TCP connection to the server:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Everything you’ve seen so far happens in the transport layer or below. However,
    if this connection succeeds, `curl` then tries to send the request (the “header”);
    this is where the application layer starts:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Line 1 is `curl` debugging output telling you what it will do next. The remaining
    lines show what `curl` sends to the server. The text in bold is what goes to the
    server; the hexadecimal numbers at the beginning are just debugging offsets `curl`
    adds to help you keep track of how much data was sent or received.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'At 2, you can see that `curl` starts by issuing a `GET` command to the server
    (as you did with `telnet`), followed by some extra information for the server
    and an empty line. Next, the server sends a reply, first with its own header,
    shown here in bold:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Much like the previous output, the `<=` lines are debugging output, and `0000:`
    precedes the lines of output to tell you the offsets (in `curl`, the header won’t
    count toward the offset; that’s why all of these lines begin with 0).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'The header in the server’s reply can be fairly long, but at some point the
    server transitions from transmitting headers to sending the actual requested document,
    like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This output also illustrates an important property of the application layer.
    Even though the debugging output says `Recv header` and `Recv data`, implying
    that those are two different kinds of messages from the server, there’s no difference
    in how `curl` talked to the operating system to retrieve the two messages, in
    how the operating system handled them, or in how the network handled the packets
    underneath. The difference is entirely within the user-space `curl` application.
    `curl` knew that until this point it had been getting headers, but when it received
    a blank line 1, which signifies the end of headers in HTTP, it knew to interpret
    anything that followed as the requested document.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The same is true of the server sending this data. When sending the reply, the
    server’s operating system didn’t differentiate between header and document data;
    the distinctions happen inside the user-space server program.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 Network Servers
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most network servers are like other server daemons on your system such as cron,
    except that they interact with network ports. In fact, syslogd, discussed in Chapter
    7, accepts UDP packets on port 514 when started with the `-r` option.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some other common network servers that you might find running on your
    system:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: httpd, apache, apache2, nginx Web servers
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: sshd Secure shell daemon
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: postfix, qmail, sendmail Mail servers
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: cupsd Print server
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: nfsd, mountd Network filesystem (file-sharing) daemons
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: smbd, nmbd Windows file-sharing daemons (see Chapter 12)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: rpcbind Remote procedure call (RPC) portmap service daemon
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One feature common to most network servers is that they usually operate as multiple
    processes. At least one process listens on a network port, and upon receiving
    a new incoming connection, the listening process uses `fork()` to create a child
    process, which is then responsible for the new connection. The child, often called
    a *worker* process, terminates when the connection is closed. Meanwhile, the original
    listening process continues to listen on the network port. This process allows
    a server to easily handle many connections without much trouble.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: There are some exceptions to this model, however. Calling `fork()` adds a significant
    amount of system overhead. To avoid this, high-performance TCP servers such as
    the Apache web server may create a number of worker processes upon startup so
    they’re available to handle connections as needed. Servers that accept UDP packets
    don’t need to fork at all, as they don’t have connections to listen for; they
    simply receive data and react to it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.1  Secure Shell
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every network server program works a bit differently. To get hands-on experience
    with a server’s configuration and operation, let’s take a close look at the standalone
    secure shell (SSH) server. One of the most common network service applications,
    SSH is the de facto standard for remote access to a Unix machine. SSH is designed
    to allow secure shell logins, remote program execution, simple file sharing, and
    more—replacing the old, insecure `telnet` and `rlogin` remote-access systems with
    public-key cryptography for authentication and simpler ciphers for session data.
    Most ISPs and cloud providers require SSH for shell access to their services,
    and many Linux-based network appliances (such as network attached storage, or
    NAS, devices) provide access via SSH as well. OpenSSH ([http://www.openssh.com/](http://www.openssh.com/))
    is a popular free SSH implementation for Unix, and nearly all Linux distributions
    come with it preinstalled. The OpenSSH client program is `ssh`, and the server
    is sshd. There are two main SSH protocol versions: 1 and 2\. OpenSSH supports
    only version 2, having dropped version 1 support due to vulnerabilities and lack
    of use.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Among its many useful capabilities and features, SSH does the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Encrypts your password and all other session data, protecting you from snoopers.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tunnels other network connections, including those from X Window System clients.
    (You’ll learn more about X in Chapter 14.)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offers clients for nearly any operating system.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses keys for host authentication.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SSH does have a few disadvantages. For one, in order to set up an SSH connection,
    you need the remote host’s public key, and you don’t necessarily get it in a secure
    way (though you can check it manually to make sure you’re not being spoofed).
    For an overview of how several methods of cryptography work, get your hands on
    the book *Serious Cryptography: A Practical Introduction to Modern Encryption*
    (No Starch Press, 2017), by Jean-Philippe Aumasson. Two in-depth books on SSH
    are *SSH Mastery: OpenSSH, PuTTY, Tunnels, and Keys*, 2nd edition, by Michael
    W. Lucas (Tilted Windmill Press, 2018) and *SSH, The Secure Shell: The Definitive
    Guide*, 2nd edition, by Daniel J. Barrett, Richard E. Silverman, and Robert G.
    Byrnes (O’Reilly, 2005).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 'SSH 确实有一些缺点。例如，为了建立 SSH 连接，你需要远程主机的公共密钥，而你不一定能以安全的方式获得它（尽管你可以手动检查它，以确保不会被伪造）。要了解几种加密方法的概述，可以阅读
    Jean-Philippe Aumasson 所著的《*Serious Cryptography: A Practical Introduction to
    Modern Encryption*》（No Starch Press, 2017）。关于 SSH 的两本深入书籍分别是 Michael W. Lucas
    所著的《*SSH Mastery: OpenSSH, PuTTY, Tunnels, and Keys*》第二版（Tilted Windmill Press,
    2018），以及 Daniel J. Barrett、Richard E. Silverman 和 Robert G. Byrnes 所著的《*SSH, The
    Secure Shell: The Definitive Guide*》第二版（O’Reilly, 2005）。'
- en: 10.3.2  The sshd Server
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2  sshd 服务器
- en: Running the sshd server to allow remote connections to your system requires
    a configuration file and host keys. Most distributions keep configurations in
    the */etc/ssh* configuration directory and try to configure everything properly
    for you if you install their sshd package. (The server configuration filename
    *sshd_config* is easy to confuse with the client’s *ssh_config* setup file, so
    be careful.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 sshd 服务器以允许远程连接到你的系统需要一个配置文件和主机密钥。大多数发行版将配置保存在 */etc/ssh* 配置目录中，并在你安装它们的
    sshd 包时会为你配置好一切。（服务器配置文件名 *sshd_config* 容易与客户端的 *ssh_config* 设置文件混淆，所以要小心。）
- en: You shouldn’t need to change anything in *sshd_config*, but it never hurts to
    check. The file consists of key-value pairs, as shown in this fragment.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要更改 *sshd_config* 中的任何内容，但检查一下也无妨。该文件由键值对组成，如这个片段所示。
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Lines beginning with `#` are comments, and many comments in your *sshd_config*
    indicate default values for various parameters, as you can see from this excerpt.
    The sshd_config(5) manual page contains descriptions of the parameters and possible
    values, but these are among the most important:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `#` 开头的行是注释，许多注释在你的 *sshd_config* 文件中指示了各种参数的默认值，正如你从这个摘录中看到的那样。sshd_config(5)
    手册页包含了参数和可能的值的描述，但以下是其中最重要的：
- en: '`HostKey` `file` Uses `file` as a host key. (Host keys are described next.)'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HostKey` `file` 使用 `file` 作为主机密钥。（主机密钥将在下一节中描述。）'
- en: '`PermitRootLogin` `value` Permits the superuser to log in with SSH if `value`
    is set to `yes`. Set `value` to `no` to prevent this.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PermitRootLogin` `value` 如果 `value` 设置为 `yes`，允许超级用户通过 SSH 登录。将 `value` 设置为
    `no` 可防止这种情况。'
- en: '`LogLevel` `level` Logs messages with syslog level `level` (defaults to `INFO`).'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LogLevel` `level` 使用 syslog 级别 `level` 记录消息（默认值为 `INFO`）。'
- en: '`SyslogFacility` `name` Logs messages with syslog facility `name` (defaults
    to `AUTH`).'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SyslogFacility` `name` 使用 syslog 设施 `name` 记录消息（默认值为 `AUTH`）。'
- en: '`X11Forwarding` `value` Enables X Window System client tunneling if `value`
    is set to `yes`.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`X11Forwarding` `value` 如果 `value` 设置为 `yes`，则启用 X Window 系统客户端隧道。'
- en: '`XAuthLocation` `path` Specifies the location of the `xauth` utility on your
    system. X tunneling will not work without this path. If `xauth` isn’t in */usr/bin*,
    set `path` to the full pathname for `xauth`.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`XAuthLocation` `path` 指定系统上 `xauth` 工具的位置。如果没有此路径，X 隧道将无法工作。如果 `xauth` 不在
    */usr/bin* 中，请将 `path` 设置为 `xauth` 的完整路径。'
- en: Creating Host Keys
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建主机密钥
- en: OpenSSH has several host key sets. Each set has a public key (with a *.pub*
    file extension) and a private key (with no extension).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH 有多个主机密钥集。每个密钥集都有一个公共密钥（以 *.pub* 为扩展名）和一个私有密钥（没有扩展名）。
- en: SSH version 2 has RSA and DSA keys. RSA and DSA are public key cryptography
    algorithms. The key filenames are given in [Table 10-1](#table10-1).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 版本 2 使用 RSA 和 DSA 密钥。RSA 和 DSA 是公钥加密算法。密钥文件名列在 [表 10-1](#table10-1) 中。
- en: 'Table 10-1: OpenSSH Key Files'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-1：OpenSSH 密钥文件
- en: '| **Filename** | **Key type** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **文件名** | **密钥类型** |'
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *ssh_host_rsa_key* | Private RSA key |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| *ssh_host_rsa_key* | 私有 RSA 密钥 |'
- en: '| *ssh_host_rsa_key.pub* | Public RSA key |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| *ssh_host_rsa_key.pub* | 公共 RSA 密钥 |'
- en: '| *ssh_host_dsa_key* | Private DSA key |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| *ssh_host_dsa_key* | 私有 DSA 密钥 |'
- en: '| *ssh_host_dsa_key.pub* | Public DSA key |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| *ssh_host_dsa_key.pub* | 公共 DSA 密钥 |'
- en: 'Creating a key involves a numerical computation that generates both public
    and private keys. Normally you won’t need to create the keys because the OpenSSH
    installation program or your distribution’s installation script will do it for
    you, but you need to know how to do so if you plan to use programs like `ssh-agent`
    that provide authentication services without a password. To create SSH protocol
    version 2 keys, use the `ssh-keygen` program that comes with OpenSSH:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 创建密钥涉及一个数值计算，生成公钥和私钥。通常你不需要自己创建密钥，因为OpenSSH的安装程序或你发行版的安装脚本会为你做这件事，但如果你计划使用像`ssh-agent`这样无需密码的身份验证服务，你需要知道如何创建密钥。要创建SSH协议版本2的密钥，请使用OpenSSH自带的`ssh-keygen`程序：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The SSH server and clients also use a *key file*, called *ssh_known_hosts*,
    to store public keys from other hosts. If you intend to use authentication based
    on a remote client’s identity, the server’s *ssh_known_hosts* file must contain
    the public host keys of all trusted clients. Knowing about the key files is handy
    if you’re replacing a machine. When installing a new machine from scratch, you
    can import the key files from the old machine to ensure that users don’t get key
    mismatches when connecting to the new one.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: SSH服务器和客户端还使用一个*密钥文件*，叫做*ssh_known_hosts*，用来存储来自其他主机的公钥。如果你打算使用基于远程客户端身份的身份验证，服务器的*ssh_known_hosts*文件必须包含所有受信任客户端的公钥。了解密钥文件是很有用的，特别是当你需要替换一台机器时。从零安装新机器时，你可以从旧机器导入密钥文件，以确保用户在连接新机器时不会遇到密钥不匹配的问题。
- en: Starting the SSH Server
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启动SSH服务器
- en: Although most distributions ship with SSH, they usually don’t start the sshd
    server by default. On Ubuntu and Debian, the SSH server is not installed on a
    new system; installing its package creates the keys, starts the server, and adds
    the server startup to the bootup configuration.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数发行版都自带SSH，但它们通常默认不会启动sshd服务器。在Ubuntu和Debian上，新的系统不会安装SSH服务器；安装其包会创建密钥，启动服务器，并将服务器启动项加入开机配置。
- en: 'On Fedora, sshd is installed by default but turned off. To start sshd at boot,
    use `systemctl` like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fedora上，sshd默认已安装但处于关闭状态。要在启动时启动sshd，可以使用`systemctl`，像这样：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you want to start the server immediately without rebooting, use:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在不重启的情况下立即启动服务器，可以使用：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Fedora normally creates any missing host key files upon the first sshd startup.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Fedora通常会在第一次启动sshd时创建任何缺失的主机密钥文件。
- en: 'If you’re running another distribution, you likely won’t need to manually configure
    the sshd startup. However, you should know that there are two startup modes: standalone
    and on-demand. The standalone server is by far more common, and it’s just a matter
    of running sshd as root. The sshd server process writes its PID to */var/run/sshd.pid*
    (of course, when run by systemd, it’s also tracked by its cgroup, as you saw in
    Chapter 6).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是其他发行版，你可能不需要手动配置sshd的启动。然而，你应该知道有两种启动模式：独立模式和按需模式。独立模式服务器更为常见，只需以root身份运行sshd。sshd服务器进程会将其PID写入*/var/run/sshd.pid*（当然，当由systemd运行时，它也会被其cgroup跟踪，正如你在第六章看到的）。
- en: As an alternative, systemd can start sshd on demand through a socket unit. This
    usually isn’t a good idea, because the server occasionally needs to generate key
    files, and that process can take a long time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，systemd可以通过套接字单元按需启动sshd。这通常不是一个好主意，因为服务器偶尔需要生成密钥文件，而这个过程可能会很长。
- en: 10.3.3  fail2ban
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3  fail2ban
- en: If you set up an SSH server on your machine and open it up to the internet,
    you’ll quickly discover constant intrusion attempts. These brute-force attacks
    won’t succeed if your system is properly configured and you haven’t chosen stupid
    passwords. However, they will be annoying, consume CPU time, and unnecessarily
    clutter your logs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在机器上设置了SSH服务器并将其开放到互联网，你很快就会发现不断的入侵尝试。这些暴力破解攻击如果你的系统配置正确且密码足够强大，是不会成功的。然而，它们会很烦人，消耗CPU时间，并且无谓地增加日志的杂乱。
- en: To prevent this, you want to set up a mechanism to block repeated login attempts.
    As of this writing, the fail2ban package is the most popular way to do this; it’s
    simply a script that watches log messages. Upon seeing a certain number of failed
    requests from one host within a certain time frame, fail2ban uses `iptables` to
    create a rule to deny traffic from that host. After a specified period, during
    which the host has probably given up trying to connect, fail2ban removes the rule.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Most Linux distributions offer a fail2ban package with preconfigured defaults
    for SSH.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.4  The SSH Client
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To log in to a remote host, run:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You may omit `remote_username``@` if your local username is the same as on
    `remote_host`. You can also run pipelines to and from an `ssh` command as shown
    in the following example, which copies a directory *dir* to another host:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The global SSH client configuration file *ssh_config* should be in */etc/ssh*,
    the same location as your *sshd_config* file. As with the server configuration
    file, the client configuration file has key-value pairs, but you shouldn’t need
    to change them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'The most frequent problem with using SSH clients occurs when an SSH public
    key in your local *ssh_known_hosts* or *.ssh/known_hosts* file does not match
    the key on the remote host. Bad keys cause errors or warnings like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This usually just means that the remote host’s administrator changed the keys
    (which often happens upon a hardware or cloud server upgrade), but it never hurts
    to check with the administrator if you’re not sure. In any case, the preceding
    message tells you that the bad key is in line 12 of a user’s *known_hosts* file
    1.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t suspect foul play, just remove the offending line or replace it
    with the correct public key.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: SSH File Transfer Clients
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: OpenSSH includes the file transfer programs `scp` and `sftp`, which are intended
    as replacements for the older, insecure programs `rcp` and `ftp`. You can use
    `scp` to transfer files to or from a remote machine to your machine or from one
    host to another. It works like the `cp` command. Here are a few examples.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy a file from a remote host to the current directory:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Copy a file from the local machine to a remote host:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Copy a file from one remote host to a second remote host:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `sftp` program works like the obsolete command-line `ftp` client, using
    `get` and `put` commands. The remote host must have an `sftp-server` program installed,
    which you can expect if the remote host also uses OpenSSH.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: SSH Clients for Non-Unix Platforms
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are SSH clients for all popular operating systems. Which one should you
    choose? PuTTY is a good, basic Windows client that includes a secure file-copy
    program. macOS is based on Unix and includes OpenSSH.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '10.4 Pre-systemd Network Connection Servers: inetd/xinetd'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before the widespread use of systemd and the socket units that you saw in Section
    6.3.7, there were a handful of servers that provided a standard means of building
    a network service. Many minor network services are very similar in their connection
    requirements, so implementing standalone servers for every service can be inefficient.
    Each server must be separately configured to handle port listening, access control,
    and port configuration. These actions are performed in the same way for most services;
    only when a server accepts a connection is communication handled any differently.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: One traditional way to simplify the use of servers is with the inetd daemon,
    a kind of *superserver* designed to standardize network port access and interfaces
    between server programs and network ports. After you start inetd, it reads its
    configuration file and then listens on the network ports defined in that file.
    As new network connections come in, inetd attaches a newly started process to
    the connection.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: A newer version of inetd called xinetd offers easier configuration and better
    access control, but xinetd has almost entirely been phased out in favor of systemd.
    However, you might see it on an older system or one that does not use systemd.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 10.5 Diagnostic Tools
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at a few diagnostic tools that are useful for poking around the application
    layer. Some dig into the transport and network layers, because everything in the
    application layer eventually maps down to something in those lower layers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in Chapter 9, `netstat` is a basic network service debugging tool
    that can display a number of transport and network layer statistics. [Table 10-2](#table10-2)
    reviews a few useful options for viewing connections.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-2: Useful Connection-Reporting Options for netstat'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '| **Option** | **Description** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| `-t` | Prints TCP port information |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| `-u` | Prints UDP port information |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| `-l` | Prints listening ports |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| `-a` | Prints every active port |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| `-n` | Disables name lookups (speeds things up; also useful if DNS isn’t
    working) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| `-4`, `-6` | Limits the output to IP version 4 or 6 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: 10.5.1  lsof
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Chapter 8, you learned that `lsof` not only can track open files, but can
    also list the programs currently using or listening to ports. For a complete list
    of such programs, run:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you run this command as a regular user, it shows only that user’s processes.
    When you run it as root, the output should look something like this, displaying
    a variety of processes and users:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This example output shows users and process IDs for server and client programs,
    from the old-style RPC services at the top 1, to the multicast DNS service provided
    by `avahi` 2, to even an IPv6-ready printer service, cupsd 3. The last two entries
    show client connections: an SSH connection 4 and a secure web connection from
    the Chromium web browser 5. Because the output can be extensive, it’s usually
    best to apply a filter (as discussed in the following section).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lsof` program is like `netstat` in that it tries to reverse-resolve every
    IP address that it finds into a hostname, which slows down the output. Use the
    `-n` option to disable name resolution:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can also specify `-P` to disable */etc/services* port name lookups.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Filtering by Protocol and Port
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you’re looking for a particular port (say, you know that a process is using
    a particular port and you want to know what that process is), use this command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The full syntax is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `protocol`, `@``host`, and `:``port` parameters are all optional and will
    filter the `lsof` output accordingly. As with most network utilities, `host` and
    `port` can be either names or numbers. For example, if you want to see connections
    only on TCP port 443 (the HTTPS port), use:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To filter based on IP version, use `-i4` (IPv4) or `-i6` (IPv6). You can add
    this as a separate option or just add the number in with more complex filters
    (for example, `-i6TCP:443`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: You can specify service names from */etc/services* (as in `-iTCP:ssh`) instead
    of numbers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Filtering by Connection Status
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One particularly handy `lsof` filter is connection status. For example, to
    show only the processes listening on TCP ports, enter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This command gives you a good overview of the network server processes currently
    running on your system. However, because UDP servers don’t listen and don’t have
    connections, you’ll have to use `-iUDP` to view running clients as well as servers.
    This usually isn’t a problem, because you probably won’t have many UDP servers
    on your system.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 10.5.2  tcpdump
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your system normally doesn’t bother with network traffic that isn’t addressed
    to one of its MAC addresses. If you need to see exactly what’s crossing your network,
    `tcpdump` puts your network interface card into *promiscuous mode* and reports
    on every packet that comes across. Entering `tcpdump` with no arguments produces
    output like the following, which includes an ARP request and web connection:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can tell `tcpdump` to be more specific by adding filters. You can filter
    based on source and destination hosts, networks, Ethernet addresses, protocols
    at many different layers in the network model, and much more. Among the many packet
    protocols that `tcpdump` recognizes are ARP, RARP, ICMP, TCP, UDP, IP, IPv6, AppleTalk,
    and IPX packets. For example, to tell `tcpdump` to output only TCP packets, run:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To see web packets and UDP packets, enter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The keyword `or` specifies that the condition on either the left or right can
    be true to pass the filter. Similarly, the `and` keyword requires both conditions
    to be true.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Primitives
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the preceding examples, `tcp`, `udp`, and `port` `80` are basic elements
    of filters called *primitives*. The most important primitives are listed in [Table
    10-3](#table10-3).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-3: tcpdump Primitives'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '| **Primitive** | **Packet specification** |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| `tcp` | TCP packets |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| `udp` | UDP packets |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| `ip` | IPv4 packets |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| `ip6` | IPv6 packets |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| `port` `port` | TCP and/or UDP packets to/from port `port` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| `host` `host` | Packets to or from `host` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| `net` `network` | Packets to or from `network` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: Operators
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `or` used earlier is an *operator*. `tcpdump` can use multiple operators
    (such as `and` and `!`), and you can group operators in parentheses. If you plan
    to do any serious work with `tcpdump`, make sure to read the pcap-filter(7) manual
    page, especially the section that describes the primitives.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 10.5.3  netcat
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need more flexibility in connecting to a remote host than a command
    like `telnet` `host``port` allows, use `netcat` (or `nc`). `netcat` can connect
    to remote TCP/UDP ports, specify a local port, listen on ports, scan ports, redirect
    standard I/O to and from network connections, and more. To open a TCP connection
    to a port with `netcat`, run:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`netcat` terminates when the other side ends the connection, which can be confusing
    if you redirect standard input to `netcat`, because you might not get your prompt
    back after sending data (as opposed to almost any other command pipeline). You
    can end the connection at any time by pressing ctrl-C. (If you’d like the program
    and network connection to terminate based on the standard input stream, try the
    `sock` program instead.)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'To listen on a particular port, run:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If `netcat` is successful at listening on the port, it will wait for a connection,
    and upon establishing a connection, prints the output from that connection, and
    sends any standard input to the connection.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some additional notes on `netcat`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: There isn’t much debugging output by default. If something fails, `netcat` fails
    silently, but it does set an appropriate exit code. If you’d like some more information,
    add the `-v` (“verbose”) option.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, the `netcat` client tries to connect with IPv4 and IPv6\. However,
    in server mode, `netcat` defaults to IPv4\. To force the protocol, use `-4` for
    IPv4 and `-6` for IPv6.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-u` option specifies UDP instead of TCP.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.5.4  Port Scanning
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you don’t even know what services the machines on your networks are
    offering or even which IP addresses are in use. The Network Mapper (Nmap) program
    scans all ports on a machine or network of machines looking for open ports, and
    it lists the ports it finds. Most distributions have an Nmap package, or you can
    get it at [http://www.insecure.org/](http://www.insecure.org/). (See the Nmap
    manual page and online resources for all that Nmap can do.)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'When listing ports on your own machine, it often helps to run the Nmap scan
    from at least two points: from your own machine and from another one (possibly
    outside your local network). Doing so will give you an overview of what your firewall
    is blocking.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `nmap``host` to run a generic scan on a host. For example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see here, a number of services are open, many of which are not enabled
    by default on most distributions. In fact, the only one here that’s usually on
    by default is port 111, the `rpcbind` port.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Nmap is also capable of scanning ports over IPv6 if you add the `-6` option.
    This can be a handy way of identifying services that do not support IPv6.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 10.6 Remote Procedure Calls
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What about the rpcbind service from the scan in the preceding section? RPC stands
    for *remote procedure call (RPC)*, a system residing in the lower parts of the
    application layer. It’s designed to make it easier for programmers to build client/server
    network applications, where a client program calls functions that execute on a
    remote server. Each type of remote server program is identified by an assigned
    program number.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: RPC implementations use transport protocols such as TCP and UDP, and they require
    a special intermediary service to map program numbers to TCP and UDP ports. The
    server is called rpcbind, and it must be running on any machine that wants to
    use RPC services.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what RPC services your computer has, run:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: RPC is one of those protocols that just doesn’t want to die. The Network File
    System (NFS) and Network Information Service (NIS) systems use RPC, but they are
    completely unnecessary on standalone machines. But whenever you think that you’ve
    eliminated all need for rpcbind, something else comes up, such as File Access
    Monitor (FAM) support in GNOME.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 10.7 Network Security
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because Linux is a very popular Unix flavor on the PC platform, and especially
    because it is widely used for web servers, it attracts many unpleasant characters
    who try to break into computer systems. Section 9.25 discussed firewalls, but
    that’s not really the whole story on security.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Network security attracts extremists—those who *really* like to break into
    systems (whether for fun or money) and those who come up with elaborate protection
    schemes and *really* like to swat away people trying to break into their systems.
    (This, too, can be very profitable.) Fortunately, you don’t need to know very
    much to keep your system safe. Here are a few basic rules of thumb:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Run as few services as possible Intruders can’t break into services that don’t
    exist on your system. If you know what a service is and you’re not using it, don’t
    turn it on for the sole reason that you might want to use it “at some later point.”
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Block as much as possible with a firewall Unix systems have a number of internal
    services that you may not know about (such as TCP port 111 for the RPC port-mapping
    server), and no other system in the world *should* know about them. It can be
    very difficult to track and regulate the services on your system because many
    different kinds of programs listen on various ports. To keep intruders from discovering
    internal services on your system, use effective firewall rules and install a firewall
    at your router.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Track the services that you offer to the internet If you run an SSH server,
    Postfix, or similar services, keep your software up to date and get appropriate
    security alerts. (See Section 10.7.2 for some online resources.)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use “long-term support” distribution releases for servers Security teams normally
    concentrate their work on stable, supported distribution releases. Development
    and testing releases such Debian Unstable and Fedora Rawhide receive much less
    attention.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t give an account on your system to anyone who doesn’t need one It’s much
    easier to gain superuser access from a local account than it is to break in remotely.
    In fact, given the huge base of software (and the resulting bugs and design flaws)
    available on most systems, it can be easy to gain superuser access to a system
    after you get to a shell prompt. Don’t assume that your friends know how to protect
    their passwords (or choose good passwords in the first place).
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Avoid installing dubious binary packages They can contain Trojan horses.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That’s the practical end of protecting yourself. But why is it important to
    do so? There are three basic kinds of network attacks that can be directed at
    a Linux machine:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Full compromise This means getting superuser access (full control) of a machine.
    An intruder can accomplish this by trying a service attack, such as a buffer overflow
    exploit, or by taking over a poorly protected user account and then trying to
    exploit a poorly written setuid program.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Denial-of-service (DoS) attack This prevents a machine from carrying out its
    network services or forces a computer to malfunction in some other way without
    the use of any special access. Normally, a DoS attack is just a flood of network
    requests, but it can also be an exploit of a flaw in a server program that causes
    a crash. These attacks are harder to prevent, but they are easier to respond to.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Malware Linux users are mostly immune to malware such as email worms and viruses,
    simply because their email clients aren’t stupid enough to actually run programs
    sent in message attachments. But Linux malware does exist. Avoid downloading and
    installing executable software from places that you’ve never heard of.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 10.7.1  Typical Vulnerabilities
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two basic types of vulnerabilities to worry about: direct attacks
    and cleartext password sniffing. *Direct attacks* try to take over a machine without
    being terribly subtle. One of the most common is locating an unprotected or otherwise
    vulnerable service on your system. This can be as simple as a service that isn’t
    authenticated by default, such as an administrator account without a password.
    Once an intruder has access to one service on a system, they can use it to try
    to compromise the whole system. In the past, a common direct attack was the buffer
    overflow exploit, where a careless programmer doesn’t check the bounds of a buffer
    array. This has been mitigated somewhat by Address Space Layout Randomization
    (ASLR) techniques in the kernel and protective measures elsewhere.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: A *cleartext password sniffing attack* captures passwords sent across the wire
    as clear text, or uses a password database populated from one of many data breaches.
    As soon as an attacker gets your password, it’s game over. From there, the assailant
    will inevitably try to gain superuser access locally (which, as mentioned before,
    is much easier than making a remote attack), try to use the machine as an intermediary
    for attacking other hosts, or both.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Some services are chronic attack targets due to poor implementation and design.
    You should always deactivate the following services (they’re all quite dated at
    this point, and rarely activated by default on most systems):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: ftpd For whatever reason, all FTP servers seem plagued with vulnerabilities.
    In addition, most FTP servers use cleartext passwords. If you have to move files
    from one machine to another, consider an SSH-based solution or an rsync server.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: telnetd, rlogind, rexecd All of these services pass remote session data (including
    passwords) in cleartext form. Avoid them unless you have a Kerberos-enabled version.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 10.7.2  Security Resources
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are three good security resources:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The SANS Institute ([http://www.sans.org/](http://www.sans.org/)) offers training,
    services, a free weekly newsletter listing the top current vulnerabilities, sample
    security policies, and more.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CERT Division of Carnegie Mellon University’s Software Engineering Institute
    ([http://www.cert.org/](http://www.cert.org/)) is a good place to look for the
    most severe problems.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insecure.org, a project from hacker and Nmap creator Gordon “Fyodor” Lyon ([http://www.insecure.org/](http://www.insecure.org/)),
    is the place to go for Nmap and pointers to all sorts of network exploit-testing
    tools. It’s much more open and specific about exploits than are many other sites.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you’re interested in network security, you should learn all about Transport
    Layer Security (TLS) and its predecessor, Secure Socket Layer (SSL). These user-space
    network levels are typically added to networking clients and servers to support
    network transactions through the use of public-key encryption and certificates.
    A good guide is Davies’ *Implementing SSL/TLS Using Cryptography and PKI* (Wiley,
    2011) or Jean-Philippe Aumasson’s *Serious Cryptography: A Practical Introduction
    to Modern Encryption* (No Starch Press, 2017).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 10.8 Looking Forward
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re interested in getting your hands dirty with some complicated network
    servers, some very common ones are the Apache or nginx web servers and the Postfix
    email server. In particular, web servers are easy to install and most distributions
    supply packages. If your machine is behind a firewall or NAT-enabled router, you
    can experiment with the configuration as much as you’d like without worrying about
    security.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the last few chapters, we’ve been gradually moving from kernel space
    into user space. Only a few utilities discussed in this chapter, such as `tcpdump`,
    interact with the kernel. The remainder of this chapter describes how sockets
    bridge the gap between the kernel’s transport layer and the user-space application
    layer. It’s more advanced material, of particular interest to programmers, so
    feel free to skip to the next chapter if you like.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 10.9 Network Sockets
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re now going to shift gears and look at how processes do the work of reading
    data from and writing data to the network. It’s easy enough for processes to read
    from and write to network connections that are already set up: all you need are
    some system calls, which you can read about in the recv(2) and send(2) manual
    pages. From the point of view of a process, perhaps the most important thing to
    know is how to access the network when using these system calls. On Unix systems,
    a process uses a socket to identify when and how it’s talking to the network.
    *Sockets* are the interface that processes use to access the network through the
    kernel; they represent the boundary between user space and kernel space. They’re
    often also used for interprocess communication (IPC).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: There are different types of sockets because processes need to access the network
    in different ways. For example, TCP connections are represented by stream sockets
    (`SOCK_STREAM`, from a programmer’s point of view), and UDP connections are represented
    by datagram sockets (`SOCK_DGRAM`).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a network socket can be somewhat complicated because you need to
    account for socket type, IP addresses, ports, and transport protocol at particular
    times. However, after all of the initial details are sorted out, servers use certain
    standard methods to deal with incoming traffic from the network. The flowchart
    in [Figure 10-1](#figure10-1) shows how many servers handle connections for incoming
    stream sockets.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![f10001](image_fi/500402c10/f10001.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-1: One method for accepting and processing incoming connections'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that this type of server involves two kinds of sockets: one for listening
    and one for reading and writing. The master process uses the listening socket
    to look for connections from the network. When a new connection comes in, the
    master process uses the `accept()` system call to accept the connection, which
    creates the read/write socket dedicated to that connection. Next, the master process
    uses `fork()` to create a new child process to deal with the connection. Finally,
    the original socket remains the listener and continues to look for more connections
    on behalf of the master process.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'After a process has set up a socket of a particular type, it can interact with
    it in a way that fits the socket type. This is what makes sockets flexible: if
    you need to change the underlying transport layer, you don’t have to rewrite all
    of the parts that send and receive data; you mostly need to modify the initialization
    code.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: If you’re a programmer and you’d like to learn how to use the socket interface,
    *Unix Network Programming, Volume 1*, 3rd edition, by W. Richard Stevens, Bill
    Fenner, and Andrew M. Rudoff (Addison-Wesley Professional, 2003), is the classic
    guide. Volume 2 also covers interprocess communication.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 10.10 Unix Domain Sockets
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications that use network facilities don’t have to involve two separate
    hosts. Many applications are built as client-server or peer-to-peer mechanisms,
    where processes running on the same machine use interprocess communication to
    negotiate what work needs to be done and who does it. For example, recall that
    daemons such as systemd and NetworkManager use D-Bus to monitor and react to system
    events.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Processes are capable of using regular IP networking over localhost (127.0.0.1
    or ::1) to communicate with each other, but they typically use a special kind
    of socket called a *Unix domain socket* as an alternative. When a process connects
    to a Unix domain socket, it behaves almost exactly like it does with a network
    socket: it can listen for and accept connections on the socket, and you can even
    choose between different socket types to make it behave like TCP or UDP.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers like Unix domain sockets for IPC for two reasons. First, they allow
    the option to use special socket files in the filesystem to control access, so
    any process that doesn’t have access to a socket file can’t use it. And because
    there’s no interaction with the network, it’s simpler and less prone to conventional
    network intrusion. For example, you’ll usually find the socket file for D-Bus
    in */var/run/dbus*:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Second, because the Linux kernel doesn’t have to go through the many layers
    of its networking subsystem when working with Unix domain sockets, performance
    tends to be much better.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Writing code for Unix domain sockets isn’t much different from supporting normal
    network sockets. Because the benefits can be significant, some network servers
    offer communication through both network and Unix domain sockets. For example,
    the MySQL database server mysqld can accept client connections from remote hosts,
    but it usually also offers a Unix domain socket at */var/run/mysqld/mysqld.sock*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view a list of Unix domain sockets currently in use on your system
    with `lsof -U`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The listing will be quite long because many applications make extensive use
    of unnamed sockets, which are indicated by `socket` in the `NAME` output column.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
