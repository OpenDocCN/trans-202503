- en: '**INTRODUCTION**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Much has been written regarding iOS’s security model, jailbreaking, finding
    code execution vulnerabilities in the base OS, and other security-related characteristics.
    Other work has focused on examining iOS from a forensic perspective, including
    how to extract data from physical devices or backups as part of criminal investigations.
    That information is all useful, but this book aims to fill the biggest gaps in
    the iOS literature: applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Little public attention has been given to actually writing secure applications
    for iOS or for performing security evaluations of iOS applications. As a consequence,
    embarrassing security flaws in iOS applications have allowed for exposure of sensitive
    data, circumvention of authentication mechanisms, and abuse of user privacy (both
    intentional and accidental). People are using iOS applications for more and more
    crucial tasks and entrusting them with a lot of sensitive information, and iOS
    application security needs to mature in response.
  prefs: []
  type: TYPE_NORMAL
- en: As such, my goal is for this book is to be as close as possible to the canonical
    work on the secure development of iOS applications in particular. iOS is a rapidly
    moving target, of course, but I’ve tried to make things as accurate as possible
    and give you the tools to inspect and adapt to future API changes.
  prefs: []
  type: TYPE_NORMAL
- en: Different versions of iOS also have different flaws. Since Apple has “end-of-lifed”
    certain devices that developers may still want their applications to run on (like
    the iPad 1), this book covers flaws present in iOS versions 5.*x* to 9.0 (the
    latest at the time of writing) and, where applicable, discusses risks and mitigations
    specific to each version.
  prefs: []
  type: TYPE_NORMAL
- en: '**Who This Book Is For**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, this is a book about security. If you’re a developer or security specialist
    looking for a guide to the common ways iOS applications fail at protecting their
    users (and the options available to you or a client for patching those holes),
    you’re in the right place.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll get the most out of this book if you have at least a little experience
    with iOS development or a passing familiarity with how iOS applications work under
    the hood. But even without that knowledge, as long as you’re an experienced programmer
    or penetration tester who’s not afraid to dig in to Apple’s documentation as needed,
    you should be fine. I give a whirlwind tour of Objective-C and its most commonly
    used API, Cocoa Touch, in [Chapter 2](ch02.html#ch02), so if you need some high-level
    basics or a refresher on the language, start there.
  prefs: []
  type: TYPE_NORMAL
- en: '**What’s in This Book**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ve been performing a wide variety of iOS application security reviews and
    penetration tests since about 2008, and I’ve collected a lot of knowledge on the
    pitfalls and mistakes real-world developers encounter when writing iOS applications.
    This book boils down that knowledge to appeal both to iOS developers looking to
    learn the practice of secure development and to security specialists wanting to
    learn how to spot problems in iOS security.
  prefs: []
  type: TYPE_NORMAL
- en: '***How This Book Is Structured***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In **[Part I: iOS Fundamentals](part01.html#part01)**, you’ll dig in to the
    background of iOS, its security history, and its basic application structure.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **[Chapter 1: The iOS Security Model](ch01.html#ch01)** briefly examines
    the iOS security model to give you an idea of the platform’s fundamental security
    protections and what they can and cannot provide.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **[Chapter 2: Objective-C for the Lazy](ch02.html#ch02)** explains how Objective-C
    differs from other programming languages and gives a quick overview of its terminology
    and design patterns. For seasoned Objective-C programmers, this may not be new
    information, but it should be valuable to beginners and others dabbling in iOS
    for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **[Chapter 3: iOS Application Anatomy](ch03.html#ch03)** outlines how iOS
    applications are structured and bundled and investigates the local storage mechanisms
    that can leak sensitive information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In **[Part II: Security Testing](part02.html#part02)**, you’ll see how to set
    up your security testing environment, for use either in development or in penetration
    testing. I’ll also share some tips for setting up your Xcode projects to get the
    most out of the available security mechanisms.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **[Chapter 4: Building Your Test Platform](ch04.html#ch04)** gives you all
    the information that you need to get started with tools and configurations to
    help you audit and test iOS applications. This includes information on using the
    Simulator, configuring proxies, bypassing TLS validation, and analyzing application
    behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **[Chapter 5: Debugging with lldb and Friends](ch05.html#ch05)** goes deeper
    into monitoring application behavior and bending it to your will using lldb and
    Xcode’s built-in tools. This will help you analyze more complex problems in your
    code, as well as give you a test harness to do things like fault injection.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **[Chapter 6: Black-Box Testing](ch06.html#ch06)** delves into the tools
    and techniques that you’ll need to successfully analyze applications that you
    don’t have source code for. This includes basic reverse engineering, binary modification,
    copying programs around, and debugging on the device with a remote instance of
    lldb.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In **[Part III: Security Quirks of the Cocoa API](part03.html#part03)**, you’ll
    look at common security pitfalls in the Cocoa Touch API.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **[Chapter 7: iOS Networking](ch07.html#ch07)** discusses how networking
    and Transport Layer Security work in iOS, including information on authentication,
    certificate pinning, and mistakes in TLS connection handling.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **[Chapter 8: Interprocess Communication](ch08.html#ch08)** covers interprocess
    communication mechanisms, including URL schemes and the newer Universal Links
    mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **[Chapter 9: iOS-Targeted Web Apps](ch09.html#ch09)** covers how web applications
    are integrated with iOS native apps, including working with web views or using
    JavaScript/Cocoa bridges such as Cordova.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **[Chapter 10: Data Leakage](ch10.html#ch10)** discusses the myriad ways
    that sensitive data can unintentionally leak onto local storage, to other applications,
    or over the network.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **[Chapter 11: Legacy Issues and Baggage from C](ch11.html#ch11)** gives
    an overview of C flaws that persist in iOS applications: stack and heap corruption,
    format string flaws, use-after-free, and some Objective-C variants of these classic
    flaws.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **[Chapter 12: Injection Attacks](ch12.html#ch12)** covers attacks such as
    SQL injection, cross-site scripting, XML injection, and predicate injection, as
    they relate to iOS applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, **[Part IV: Keeping Data Safe](part04.html#part04)** covers issues
    relating to privacy and encryption.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **[Chapter 13: Encryption and Authentication](ch13.html#ch13)** looks at
    encryption best practices, including how to properly use the Keychain, the Data
    Protection API, and other cryptographic primitives provided by the CommonCrypto
    framework.'
  prefs: []
  type: TYPE_NORMAL
- en: '• **[Chapter 14: Mobile Privacy Concerns](ch14.html#ch14)** ends the book with
    a discussion of user privacy, including what collecting more data than needed
    can mean for both application creators and users.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this book, you should be well equipped to grab an application,
    with or without source code, and quickly pinpoint security bugs. You should also
    be able to write safe and secure applications for use in the wider world.
  prefs: []
  type: TYPE_NORMAL
- en: '***Conventions This Book Follows***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because Objective-C is a rather verbose language with many extremely long class
    and method names, I’ve wrapped lines in source code listings to maximize clarity.
    This may not reflect the way you’d actually want to format your code. In some
    cases, the results are unavoidably ugly—if wrapping makes the code seem less clear,
    try pasting it into Xcode and allowing Xcode to reformat it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I will detail in [Chapter 2](ch02.html#ch02), I favor the traditional Objective-C
    infix notation instead of dot notation. I also put curly braces on the same line
    as method declarations for similar reasons: I’m old.'
  prefs: []
  type: TYPE_NORMAL
- en: Objective-C class and method names will appear in `monospaced` font. C functions
    will appear in `monospaced` font as well. For brevity and cleanliness, the path
    */Users/<your username>/Library/Developer/CoreSimulator/* will be referred to
    as *$SIMPATH*.
  prefs: []
  type: TYPE_NORMAL
- en: '***A Note on Swift***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s been much interest in the relatively new Swift language, but you’ll
    find I don’t cover it in this book. There are a few reasons why.
  prefs: []
  type: TYPE_NORMAL
- en: First, I have yet to actually come across a production application written in
    Swift. Objective-C is still far and away the most popular language for iOS applications,
    and we’ll be dealing with code written in it for many years to come.
  prefs: []
  type: TYPE_NORMAL
- en: Second, Swift just has fewer problems. Since it’s not based on C, it’s easier
    to write safer code, and it doesn’t introduce any new security flaws (as far as
    anyone knows).
  prefs: []
  type: TYPE_NORMAL
- en: Third, because Swift uses the same APIs as Objective-C, the security pitfalls
    in the Cocoa Touch API that you may run into will be basically the same in either
    language. The things you learn in this book will almost all apply to both Objective-C
    and Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Also, Swift doesn’t use infix notation and square brackets, which makes me sad
    and confused.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mobile Security Promises and Threats**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When I first started working with mobile applications, I honestly questioned
    the need for a separate mobile application security category. I considered mobile
    applications to be the same as desktop applications when it came to bugs: stack
    and heap overflows, format string bugs, use-after-free, and other code execution
    issues. While these are still possible in iOS, the security focus for mobile devices
    has expanded to include privacy, data theft, and malicious interprocess communication.'
  prefs: []
  type: TYPE_NORMAL
- en: As you read about the iOS security specifics I cover in this book, keep in mind
    that users expect apps to avoid doing certain things that will put their security
    at risk. Even if an app avoids overtly risky behaviors, there are still several
    threats to consider as you fortify that app’s defenses. This section discusses
    both security promises an app makes to its users and the types of attacks that
    can force an app to break them.
  prefs: []
  type: TYPE_NORMAL
- en: '***What Mobile Apps Shouldn’t Be Able to Do***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Learning from the design mistakes of earlier desktop operating systems, the
    major mobile operating systems were designed with application segregation in mind.
    This is different from desktop applications, where any application a user runs
    more or less has access to all that user’s data, if not control of the entire
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of increased focus on segregation and general improvements in the
    mobile OS arena, user expectations have expanded. In general, mobile applications
    (including yours) should be unable to do a few key things.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cause Another Application to Misbehave**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Applications shouldn’t be able to crash or meddle with other applications. In
    the bad old days, not only could other applications generally read, modify, or
    destroy data, they could take down the entire OS with that data. As time went
    on, desktop process segregation improved but primarily with the goal of increasing
    stability, rather than addressing security or privacy concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile operating systems improve upon this, but total process segregation is
    not possible while fulfilling users’ interoperability needs. The boundary between
    applications will always be somewhat porous. It’s up to developers to ensure that
    their applications don’t misbehave and to take all prudent measures to safeguard
    data and prevent interference from malicious applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deny Service to a User**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Given that iOS has historically been used primarily on phones, it’s crucial
    that an application not be able to do something that would prevent the user from
    making an emergency call. In many places, this is a legal requirement, and it’s
    the reason for protective measures that keep attackers (and users) from tampering
    with the underlying OS.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steal a User’s Data**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An application should not be able to read data from other applications or the
    base OS and deliver it to a third party. It should also not be able to access
    sensitive user data without the permission of the user. The OS should keep applications
    from reading data directly from other application’s data stores, but preventing
    theft via other channels requires developers to pay attention to what IPC mechanisms
    an application sends or receives data on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cost the User Unexpected Money**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Apps shouldn’t be able to incur charges without the user’s approval. Much of
    the mobile malware that has been found in the wild has used the ability to send
    SMS messages to subscribe the user to third-party services, which pass charges
    through to the user’s phone provider. Purchases made within the application should
    be clear to the user and require explicit approval.
  prefs: []
  type: TYPE_NORMAL
- en: '***Classifying Mobile Security Threats in This Book***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To help understand mobile device security threats and their mitigations, it’s
    also useful to keep a few attack types in mind. This keeps our analysis of threats
    realistic and helps to analyze the true impact of various attacks and their defenses.
  prefs: []
  type: TYPE_NORMAL
- en: '**Forensic Attacks**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Forensic attackers come into possession of a device or its backups, intending
    to extract its secrets. Most often, this involves examination of the physical
    storage on the device. Because phone or tablet theft is relatively easy and common
    compared to stealing other computing devices, much more attention is placed on
    forensics.
  prefs: []
  type: TYPE_NORMAL
- en: Forensic attacks can be performed by either an opportunistic attacker or a skilled
    attacker targeting a specific individual. For opportunistic attackers, extracting
    information can be as simple as stealing a phone without any PIN protection; this
    allows them to steal images, notes, and any other data normally accessible on
    the phone. It can also assist an attacker in compromising services that use two-factor
    authentication in conjunction with a phonebased token or SMS.
  prefs: []
  type: TYPE_NORMAL
- en: A skilled forensic attacker could be a rogue employee, corporation, government,
    law enforcement official, or perhaps really motivated extortionist. This kind
    of attacker knows the techniques to perform a temporary jailbreak, crack simple
    PINs, and examine data throughout the device’s filesystem, including system-level
    and application-level data. This can provide an attacker with not just data presented
    through the UI but the underlying cache information, which can include screenshots,
    keystrokes, sensitive information cached in web requests, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll cover much of the data of interest to forensic attackers in [Chapter 10](ch10.html#ch10),
    as well as some further protective measures in [Chapter 13](ch13.html#ch13).
  prefs: []
  type: TYPE_NORMAL
- en: '**Code Execution Attacks**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Remote code execution attacks involve compromising the device or its data by
    execution of code on the device, without having physical possession of the device.
    This can happen via many different channels: the network, QR codes or NFC, parsing
    of maliciously crafted files, or even hostile hardware peripherals. Note that
    after gaining code execution on a device, many of the forensic attacks used to
    expose user secrets are now possible. There are a few basic subtypes of code execution
    attacks that frequently result from lower-level programming flaws, which I’ll
    discuss in [Chapter 11](ch11.html#ch11).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web-Based Attacks**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Web-based remote code execution attacks primarily use maliciously crafted HTML
    and JavaScript to mislead the user or steal data. A remote attacker either operates
    a malicious website, has taken over a legitimate website, or simply posts maliciously
    crafted content to a public forum.
  prefs: []
  type: TYPE_NORMAL
- en: These attacks can be used to steal data from local data stores such as HTML5
    database storage or localStorage, alter or steal data stored in SQLite databases,
    read session cookies, or plant a fake login form to steal a user’s credentials.
    I’ll talk more about web application–related issues in [Chapter 9](ch09.html#ch09)
    and [Chapter 12](ch12.html#ch12).
  prefs: []
  type: TYPE_NORMAL
- en: '**Network-Based Attacks**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Network-based code execution attacks attempt to gain control over an application
    or the entire system by injecting executable code of some type over the network.
    This can be either modification of network traffic coming into the device or exploitation
    of a system service or the kernel with a code execution exploit. If the exploit
    targets a process with a high degree of privilege, the attacker can gain access
    not only to the data of a specific application but to data all over the device’s
    storage. They can also monitor the device’s activity and plant backdoors that
    will allow later access. I’ll talk specifically about network-related APIs in
    [Chapter 7](ch07.html#ch07).
  prefs: []
  type: TYPE_NORMAL
- en: '**Attacks That Rely on Physical Proximity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Physical code execution attacks tend to be exploits that target devices using
    communications such as NFC or the USB interface. These types of attacks have been
    used for jailbreaking in the past but can also be used to compromise the device
    using brief physical interaction. Many of these attacks are on the OS itself,
    but I’ll discuss some issues relating to physical proximity in [Chapter 14](ch14.html#ch14).
  prefs: []
  type: TYPE_NORMAL
- en: '**Some Notes for iOS Security Testers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s my strong belief that penetration tests should be performed with source
    code if at all possible. While this is not representative of the position of most
    external attackers, it does maximize the ability to find important bugs within
    a limited time frame. Real-world attackers have as much time as they care to spend
    on analyzing your application, and Objective-C lends well to reverse engineering.
    They’ll figure it out, given the time. However, most penetration tests are limited
    by time and money, so simulating a real-world attacker should not usually be the
    goal.
  prefs: []
  type: TYPE_NORMAL
- en: I cover both white-box (that is, source-assisted) and black-box methodologies
    in this book, but the focus will be on source-assisted penetration tests because
    this finds more bugs faster and helps with learning the standard Cocoa library.
    Many techniques I describe in this book lend well to either approach.
  prefs: []
  type: TYPE_NORMAL
- en: All that said, iOS developers come from many different disciplines, and each
    person’s skill set affects the types of security issues that slip into an app
    unnoticed. Whether you’re testing someone else’s application or trying to poke
    holes in your own, keep in mind a few different development backgrounds as you
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Some iOS developers come from a C or C++ background, and since we all tend to
    use what we know, you’ll find their codebases often use C/C++ APIs rather than
    Cocoa equivalents. If you know an application under test was created by former
    C/C++ programmers, you may find [Chapter 11](ch11.html#ch11) to be useful reading
    because it discusses issues commonly found in straight C/C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: For some new programmers, Objective-C is actually their first programming language.
    They often haven’t learned that many vanilla C APIs, so ideally, you’ll find fewer
    of those issues. There’s also the rare wizened NeXTStep programmer who’s made
    the move to OS X or iOS, with a library of collected wisdom regarding NeXTStep/Cocoa
    APIs but less mobile experience. If either sounds like you or your client, you’ll
    find the chapters in [Part III](part03.html#part03) most helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Programmers with Java backgrounds might try to force Java design patterns onto
    an application, endlessly abstracting functionality. Web developers who have been
    drafted into writing a mobile application, on the other hand, may try to wrap
    as much code as possible into a web app, writing minimal applications that rely
    on WebKit to view application content. Check out [Chapter 9](ch09.html#ch09) for
    some WebKit-related pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: Developers with the last few skill sets I mentioned are less likely to use low-level
    APIs, which can prevent classic C flaws. They are, however, unlikely to spot mistakes
    when using those low-level APIs, so you’ll want to pay close attention if they
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, none of these backgrounds is necessarily better suited to secure
    development than the others—both high-level and low-level APIs can be abused.
    But when you know how existing skills can affect the writing of iOS applications,
    you’re a step closer to finding and solving security issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'My own background is that of a penetration tester, which I consider akin to
    being an art critic: I *can* write code, but the vast majority of my time is spent
    looking at other people’s code and telling them what’s wrong with it. And like
    in the art world, the majority of that code is rather crap. Unlike the art world,
    however, code problems can often be fixed with a patch. My hope is that at the
    end of this book, you’ll be able to spot bad iOS code and know how to start plugging
    the holes.'
  prefs: []
  type: TYPE_NORMAL
