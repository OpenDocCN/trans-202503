<html><head></head><body>
<section aria-labelledby="ch6" epub:type="chapter" role="doc-chapter">
<span aria-label="115" epub:type="pagebreak" id="pg_115" role="doc-pagebreak"/>
<hgroup>

<h1 class="CHAPTER" id="ch6">
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">DYNAMICALLY ALLOCATED MEMORY</samp></span>
</h1>
</hgroup>
<figure class="opener"><img alt="" class="opener" src="../images/opener.jpg"/>
</figure>
<p class="COS">In <span class="chapterintro_Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, you learned that every object has a storage duration that determines its lifetime and that C defines four storage durations: static, thread, automatic, and allocated. In this chapter, you’ll learn about <i>dynamically allocated memory</i>, which is allocated from the heap at runtime. Dynamically allocated memory is useful when the exact storage requirements for a program are unknown before runtime.</p>
<p class="TX">We’ll first describe the differences between allocated, static, and automatic storage duration. We’ll skip thread storage allocation as this involves parallel execution, which we don’t cover here. We’ll then explore the functions you can use to allocate and deallocate dynamic memory, common memory allocation errors, and strategies for avoiding them. The terms <i>memory</i> and <i>storage</i> are used interchangeably in this chapter, similar to the way they’re used in practice.</p>
<section aria-labelledby="sec1" epub:type="division">
<span aria-label="116" epub:type="pagebreak" id="pg_116" role="doc-pagebreak"/>
<h2 class="H1" id="sec1"><span id="h1-55"/><samp class="SANS_Futura_Std_Bold_B_11">Storage Duration</samp></h2>
<p class="TNI">Objects occupy <i>storage</i>, which might be read-write memory, read-only memory, or central processing unit (CPU) registers. Storage of allocated duration has significantly different properties from storage of either automatic or static storage duration. First, we’ll review automatic and static storage duration.</p>
<p class="TX">Objects of <i>automatic storage duration</i> are declared within a block or as a function parameter. The lifetime of these objects begins when the block in which they are declared begins execution and ends when execution of the block ends. If the block is entered recursively, a new object is created each time, each with its own storage.</p>
<p class="TX">Objects declared at file scope have <i>static storage duration</i>. The lifetime of these objects is the entire execution of the program, and their stored value is initialized prior to program startup. You can also declare a variable within a block to have static storage duration by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp> storage-class specifier.</p>
<section aria-labelledby="sec2" epub:type="division">

<h3 class="H2" id="sec2"><span id="h2-68"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Heap and Memory Managers</samp></h3>
<p class="TNI">Dynamically allocated memory has <i>allocated storage duration</i>. The lifetime of an allocated object extends from the allocation until the deallocation. Dynamically allocated memory is allocated from the <i>heap</i>, which is simply one or more large, subdividable blocks of memory managed by the memory manager.</p>
<p class="TX"><i>Memory managers</i> are libraries that manage the heap for you by providing implementations of the standard memory management functions described in this chapter. A memory manager runs as part of the client process. The memory manager requests one or more blocks of memory from the operating system (OS) and then allocates this memory to the client process when it invokes a memory allocation function. Allocation requests don’t go directly to the OS because it’s slower and works only in big chunks of memory, whereas allocators split up those big chunks into little chunks and are faster.</p>
<p class="TX">Memory managers manage unallocated and deallocated memory only. Once memory has been allocated, the caller manages the memory until it’s returned. It’s the caller’s responsibility to ensure that the memory is deallocated, although most implementations will reclaim dynamically allocated memory when the program terminates.</p>
<aside aria-label="box-8" class="box">
<p class="BoxTitle" id="box-8"><samp class="SANS_Dogma_OT_Bold_B_11">MEMORY MANAGER IMPLEMENTATIONS</samp></p>
<p class="BoxFirst"><samp class="SANS_Futura_Std_Book_11">Memory managers frequently implement a variant of a dynamic storage allocation algorithm described by Donald Knuth (1997). This algorithm uses</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">boundary tags</samp><samp class="SANS_Futura_Std_Book_11">, which are size fields that appear before and after the block of memory</samp> <span aria-label="117" epub:type="pagebreak" id="pg_117" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Book_11">returned to the programmer. This size information allows all memory blocks to be traversed from any known block in either direction so that the memory manager can coalesce two bordering unused blocks into a larger block to minimize fragmentation.</samp></p>
<p class="Box"><samp class="SANS_Futura_Std_Book_11">When a program starts, the free memory areas are long and contiguous. During the program’s lifetime, memory is allocated and deallocated. Eventually, the long contiguous regions fragment into smaller and smaller contiguous areas. As a result, larger allocations can fail even though the total amount of free memory is sufficient for the allocation. Memory allocated for the client process and memory allocated for internal use within the memory manager are all within the addressable memory space of the client process.</samp></p>
</aside>
</section>
<section aria-labelledby="sec3" epub:type="division">

<h3 class="H2" id="sec3"><span id="h2-69"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">When to Use Dynamically Allocated Memory</samp></h3>
<p class="TNI">As previously mentioned, dynamically allocated memory is used when the exact storage requirements for a program are unknown before runtime. Dynamically allocated memory is less efficient than statically allocated memory because the memory manager needs to find appropriately sized blocks of memory in the runtime heap, and the caller must explicitly free those blocks when no longer needed, all of which requires additional processing. Dynamically allocated memory also requires additional processing for housekeeping operations such as <i>defragmentation</i> (the consolidation of adjacent free blocks), and the memory manager often uses extra storage for control structures to facilitate these processes.</p>
<p class="TX"><i>Memory leaks</i> occur when dynamically allocated memory that’s no longer needed isn’t returned to the memory manager. If these memory leaks are severe, the memory manager eventually won’t be able to satisfy new requests for storage.</p>
<p class="TX">By default, you should declare objects with either automatic or static storage duration for objects whose sizes are known at compilation time. Dynamically allocate memory when the size of the storage or the number of objects is unknown before runtime. For example, you might use dynamically allocated memory to read a table from a file at runtime, especially if you do not know the number of rows in the table at compile time. Similarly, you might use dynamically allocated memory to create linked lists, hash tables, binary trees, or other data structures for which the number of data elements held in each container is unknown at compile time.</p>
</section>
</section>
<section aria-labelledby="sec4" epub:type="division">

<h2 class="H1" id="sec4"><span id="h1-56"/><samp class="SANS_Futura_Std_Bold_B_11">Memory Management</samp></h2>
<p class="TNI">The C standard library defines memory management functions for allocating (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>) and deallocating (<samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>) dynamic memory. The OpenBSD <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> function is not defined by the <span aria-label="118" epub:type="pagebreak" id="pg_118" role="doc-pagebreak"/>C standard library but can be useful for memory allocation. C23 added two additional deallocation functions: <samp class="SANS_TheSansMonoCd_W5Regular_11">free_sized</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp>.</p>
<p class="TX">Dynamically allocated memory is required to be suitably aligned for objects up to the requested size, including arrays and structures. C11 introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp> function for hardware with stricter-than-normal memory alignment requirements.</p>
<section aria-labelledby="sec5" epub:type="division">

<h3 class="H2" id="sec5"><span id="h2-70"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">malloc</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> function allocates space for an object of a specified size. The representation of the returned storage is indeterminate. In <a href="chapter6.xhtml#Lis6-1">Listing 6-1</a>, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> function to dynamically allocate storage for an object the size of <samp class="SANS_TheSansMonoCd_W5Regular_11">struct widget</samp>.</p>
<span id="Lis6-1"/>
<pre><code>#include &lt;stdlib.h&gt;

typedef struct {
  double d;
  int i;
  char c[10];
} widget;

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> widget *p = malloc(sizeof *p);
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> if (p == nullptr) {
  // handle allocation error
}
// continue processing</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-1: Allocating storage for a widget with the</samp> <samp class="I">malloc</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp></p>
<p class="TX">All memory allocation functions accept an argument of type <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> that specifies the number of bytes of memory to be allocated <span aria-label="annotation1" class="CodeAnnotation">❶</span>. For portability, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator when calculating the size of objects, because the size of objects of distinct types, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, may differ among implementations.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> function returns either a null pointer to indicate an error or a pointer to the allocated space. Therefore, we check whether <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> returns a null pointer <span aria-label="annotation2" class="CodeAnnotation">❷</span> and appropriately handles the error.</p>
<p class="TX">After the function successfully returns the allocated storage, we can reference members of the <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp> structure through the <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> pointer. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">p-&gt;i</samp> accesses the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> member of <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp>, while <samp class="SANS_TheSansMonoCd_W5Regular_11">p-&gt;d</samp> accesses the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> member.</p>
<section aria-labelledby="sec6" epub:type="division">

<h4 class="H3" id="sec6"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Allocating Memory Without Declaring a Type</samp></h4>
<p class="TNI">You can store the return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> as a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> pointer to avoid declaring a type for the referenced object:</p>

<pre><code>void *p = malloc(size);</code></pre>
<p class="TX"><span aria-label="119" epub:type="pagebreak" id="pg_119" role="doc-pagebreak"/>Alternatively, you can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> pointer, which was the convention before the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type was introduced to C:</p>

<pre><code>char *p = malloc(size);</code></pre>
<p class="TX">In either case, the object that <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> points to has no type until an object is copied into this storage. Once that occurs, the object has the <i>effective type</i> of the last object copied into this storage, which imprints the type onto the allocated object.</p>
<p class="TX">In the following example, the storage that <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> references has an effective type of <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp>:</p>

<pre><code>widget w = {3.2, 9, "abc",};
memcpy(p, &amp;w, sizeof(w));</code></pre>
<p class="TX">Following the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>, the change of effective type influences optimizations and nothing else.</p>
<p class="TX">Because allocated memory can store any sufficiently small object type, pointers returned by allocation functions, including <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, must be sufficiently aligned. For example, if an implementation has objects with 1-, 2-, 4-, 8-, and 16-byte alignments and 16 or more bytes of storage are allocated, the alignment of the returned pointer is a multiple of 16.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">

<h4 class="H3" id="sec7"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Reading Uninitialized Memory</samp></h4>
<p class="TNI">The contents of memory returned from <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> are <i>uninitialized</i>, which means it has an indeterminate representation. Reading uninitialized memory is never a good idea; think of it as undefined behavior. If you’d like to know more, I wrote an in-depth article on uninitialized reads (Seacord 2017). The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> function doesn’t initialize the returned memory because you are expected to overwrite this memory anyway.</p>
<p class="TX">Even so, beginners commonly make the mistake of assuming that the memory <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> returns contains zeros. The program shown in <a href="chapter6.xhtml#Lis6-2">Listing 6-2</a> makes this exact error.</p>
<span id="Lis6-2"/>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main() {
  char *str = (char *)malloc(16);
  if (str) {
    strncpy(str, "123456789abcdef", 15);
    printf("str = %s.\n", str);
    free(str);
    return EXIT_SUCCESS;
  }
  return EXIT_FAILURE;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-2: An initialization error</samp></p>
<p class="TX"><span aria-label="120" epub:type="pagebreak" id="pg_120" role="doc-pagebreak"/>This program calls <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> to allocate 16 bytes of memory and then uses <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp> to copy the first 15 bytes of a string into the allocated memory. The programmer attempts to create a properly null-terminated string by copying one fewer byte than the size of the allocated memory. In doing so, the programmer assumes that the allocated storage already contains a zero value to serve as the null byte. However, the storage could easily contain nonzero values, in which case the string wouldn’t be properly null terminated, and the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> would result in undefined behavior.</p>
<p class="TX">A common solution is to write a null character into the last byte of the allocated storage, as follows:</p>

<pre><code>strncpy(str, "123456789abcdef", 15);
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> str[15] = '\0';</code></pre>
<p class="TX">If the source string (the string literal <samp class="SANS_TheSansMonoCd_W5Regular_11">"123456789abcdef"</samp> in this example) has fewer than 15 bytes, the null termination character will be copied, and the assignment <span aria-label="annotation1" class="CodeAnnotation">❶</span> is unnecessary. If the source string has 15 bytes or longer, adding this assignment ensures that the string is properly null terminated.</p>
</section>
</section>
<section aria-labelledby="sec8" epub:type="division">

<h3 class="H2" id="sec8"><span id="h2-71"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">aligned_alloc</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp> function is similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> function, except that it requires you to provide an alignment as well as a size for the allocated object. The function has the following signature, where <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> specifies the object’s size and <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp> specifies its alignment:</p>

<pre><code>void *aligned_alloc(size_t alignment, size_t size);</code></pre>
<p class="TX">Although C requires the dynamically allocated memory from <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> to be sufficiently aligned for all standard types, including arrays and structures, you might occasionally need to override the compiler’s default choices. You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp> function to request stricter alignment than the default (in other words, a larger power of two). If the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp> is not a valid alignment supported by the implementation, the function fails by returning a null pointer. See <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> for more information on alignment.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">

<h3 class="H2" id="sec9"><span id="h2-72"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">calloc</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp> function allocates storage for an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp> objects, each of whose size is <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> bytes. It has the following signature:</p>

<pre><code>void *calloc(size_t nmemb, size_t size);</code></pre>
<p class="TX">This function initializes the storage to all zero-valued bytes. These zero values might not be the same one used to represent floating-point zero or null-pointer constants. You can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp> function to allocate storage for a single object, which can be thought of as an array of one element.</p>
<p class="TX"><span aria-label="121" epub:type="pagebreak" id="pg_121" role="doc-pagebreak"/>Internally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp> function works by multiplying <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp> by <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> to determine the required number of bytes to allocate. Historically, some <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp> implementations failed to validate that these values wouldn’t wrap around when multiplied. C23 requires this test, and modern implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp> return a null pointer if the space cannot be allocated or if the product <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb * size</samp> would wrap around.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">

<h3 class="H2" id="sec10"><span id="h2-73"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">realloc</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function increases or decreases the size of previously allocated storage. It takes a pointer to memory allocated by an earlier call to <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned _alloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> (or a null pointer) and a size and has the following signature:</p>

<pre><code>void *realloc(void *ptr, size_t size);</code></pre>
<p class="TX">You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function to grow or (less commonly) shrink the size of an array.</p>
<section aria-labelledby="sec11" epub:type="division">

<h4 class="H3" id="sec11"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Avoiding Memory Leaks</samp></h4>
<p class="TNI">To avoid introducing bugs when you use <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>, you should understand how this function is specified. If the newly allocated storage is larger than the old contents, <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> leaves the additional storage uninitialized. If <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> succeeds in allocating the new object, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> to deallocate the old object. The pointer to the new object may have the same value as a pointer to the old object. If the allocation fails, the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function retains the old object data at the same address and returns a null pointer. A call to <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> can fail, for example, when insufficient memory is available to allocate the requested number of bytes. The following use of <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> might be erroneous:</p>

<pre><code>size += 50;
if ((p = realloc(p, size)) == nullptr) return nullptr;</code></pre>
<p class="TX">In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> is incremented by 50 before calling <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> to increase the size of the storage that <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> references. If the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> fails, <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> is assigned a null pointer value, but <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> doesn’t deallocate the storage that <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> references, resulting in this memory being leaked.</p>
<p class="TX"><a href="chapter6.xhtml#Lis6-3">Listing 6-3</a> demonstrates the correct use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function.</p>
<span id="Lis6-3"/>
<pre><code>void *p = malloc(100);
void *p2;

// <var>--snip--</var>
if ((nsize == 0) || (p2 = realloc(p, nsize)) == nullptr) {
  free(p);
  return nullptr;
}
p = p2;</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-3: An example of the correct use of the</samp> <samp class="I">realloc</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp></p>
<p class="TX"><span aria-label="122" epub:type="pagebreak" id="pg_122" role="doc-pagebreak"/><a href="chapter6.xhtml#Lis6-3">Listing 6-3</a> declares two variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">p2</samp>. The variable <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> refers to the dynamically allocated memory <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> returns, and <samp class="SANS_TheSansMonoCd_W5Regular_11">p2</samp> starts out uninitialized. Eventually, this memory is resized, which we accomplish by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> pointer and the new <samp class="SANS_TheSansMonoCd_W5Regular_11">nsize</samp> size. The return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> is assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">p2</samp> to avoid overwriting the pointer stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> returns a null pointer, the memory <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> references is freed, and the function returns a null pointer. If <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> succeeds and returns a pointer to an allocation of size <samp class="SANS_TheSansMonoCd_W5Regular_11">nsize</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> is assigned the pointer to the newly reallocated storage, and execution continues.</p>
<p class="TX">This code also includes a test for a zero-byte allocation. Avoid passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function a value of 0 as the size argument, as that is undefined behavior (as clarified in C23).</p>
<p class="TX">If the following call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function doesn’t return a null pointer, the address stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> is invalid and can no longer be read:</p>

<pre><code>newp = realloc(p, ...);</code></pre>
<p class="TX">In particular, the following test is not allowed:</p>

<pre><code>if (newp != p) {
  // update pointers to reallocated memory
}</code></pre>
<p class="TX">Any pointers that reference the memory <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> previously pointed to must be updated to reference the memory <samp class="SANS_TheSansMonoCd_W5Regular_11">newp</samp> pointed to after the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> regardless of whether <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> kept the same address for the storage.</p>
<p class="TX">One solution to this problem is to go through an extra indirection, sometimes called a <i>handle</i>. If all uses of the reallocated pointer are indirect, they’ll all be updated when that pointer is reassigned.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">

<h4 class="H3" id="sec12"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Calling realloc with a Null Pointer</samp></h4>
<p class="TNI">Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> with a null pointer is equivalent to calling <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>. Provided <samp class="SANS_TheSansMonoCd_W5Regular_11">newsize</samp> isn’t equal to 0, we can replace the following code</p>

<pre><code>if (p == nullptr)
  newp = malloc(newsize);
else
  newp = realloc(p, newsize);</code></pre>
<p class="Continued">with this:</p>

<pre><code>newp = realloc(p, newsize);</code></pre>
<p class="TX">The first, longer version of this code calls <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> for the initial allocation and <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> to adjust the size later as required. Because calling <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> with a null pointer is equivalent to calling <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, the second version concisely accomplishes the same thing.</p>
</section>
</section>
<section aria-labelledby="sec13" epub:type="division">
<span aria-label="123" epub:type="pagebreak" id="pg_123" role="doc-pagebreak"/>
<h3 class="H2" id="sec13"><span id="h2-74"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">reallocarray</samp></h3>
<p class="TNI">As we have seen in previous chapters, both signed integer overflow and unsigned integer wraparound are serious problems that can result in buffer overflows and other security vulnerabilities. In the following code snippet, for example, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">num * size</samp> might wrap around before being passed as the size argument in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>:</p>

<pre><code>if ((newp = realloc(p, num * size)) == nullptr) {
  // <var>--snip--</var></code></pre>
<p class="TX">The OpenBSD <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> function can reallocate storage for an array, but like <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>, it checks for wraparound during array size calculations, which saves you from having to perform these checks. The <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> function has the following signature:</p>

<pre><code>void *reallocarray(void *ptr, size_t nmemb, size_t size);</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> function allocates storage for <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb</samp> members of size <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> and checks for wraparound in the <samp class="SANS_TheSansMonoCd_W5Regular_11">nmemb * size</samp> calculation. Other platforms, including the GNU C Library (libc), have adopted this function, and it has been proposed for inclusion in the next revision of the POSIX standard. The <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> function does not zero out the allocated storage.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> function is useful when two values are multiplied to determine the size of the allocation:</p>

<pre><code>if ((newp = reallocarray(p, num, size)) == nullptr) {
  // <var>--snip--</var></code></pre>
<p class="TX">This call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">reallocarray</samp> function will fail and return a null pointer if <samp class="SANS_TheSansMonoCd_W5Regular_11">num * size</samp> would wrap around.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">

<h3 class="H2" id="sec14"><span id="h2-75"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">free</samp></h3>
<p class="TNI">When it’s no longer needed, memory can be deallocated using the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> function. Deallocating memory allows that memory to be reused, reducing the chances that you’ll exhaust the available memory and often providing more efficient use of the heap.</p>
<p class="TX">We can deallocate memory by passing a pointer to that memory to the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> function, which has the following signature:</p>

<pre><code>void free(void *ptr);</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> value must have been returned by a previous call to <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc, aligned_alloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>. CERT C rule MEM34-C, “Only free memory allocated dynamically,” discusses what happens when the value is not returned. Memory is a limited resource and so must be reclaimed.</p>
<p class="TX"><span aria-label="124" epub:type="pagebreak" id="pg_124" role="doc-pagebreak"/>If we call <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> with a null-pointer argument, nothing happens, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> function simply returns:</p>

<pre><code>  char *ptr = nullptr;
  free(ptr);</code></pre>
<p class="TX">Freeing the same pointer twice, on the other hand, is a serious error.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">

<h3 class="H2" id="sec15"><span id="h2-76"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">free_sized</samp></h3>
<p class="TNI">C23 introduced two new memory deallocation functions. The <samp class="SANS_TheSansMonoCd_W5Regular_11">free_sized</samp> function has the following signature:</p>

<pre><code>void free_sized(void *ptr, size_t size);</code></pre>
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is a null pointer or the result obtained from a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> is equal to the requested allocation size, this function behaves the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">free(ptr)</samp>. You cannot pass the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp> to this function; you must use the <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp> function (described in the next section). By <i>reminding</i> the allocator of the size of that allocation, you can reduce deallocation cost and allow extra security-hardening functionality. However, if you specify the size incorrectly, the behavior is undefined.</p>
<p class="TX">Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">free_sized</samp> function, we could improve the performance and safety of the following code</p>

<pre><code>void *buf = malloc(size);
use(buf, size);
free(buf);</code></pre>
<p class="Continued">by rewriting it as:</p>

<pre><code>void *buf = malloc(size);
use(buf, size);
free_sized(buf, size);</code></pre>
<p class="TX">This is feasible and practical when the size of the allocation is retained or can be inexpensively re-created.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">

<h3 class="H2" id="sec16"><span id="h2-77"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">free_aligned_sized</samp></h3>
<p class="TNI">The second of the two new memory deallocation functions that C23 introduced is the <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp> function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp> function has the following signature:</p>

<pre><code>void free_aligned_sized(void *ptr, size_t alignment, size_t size);</code></pre>
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> is a null pointer or the result obtained from a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">alignment</samp> is equal to the requested allocation alignment and <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> is equal to the requested allocation size, this function is equivalent to <span aria-label="125" epub:type="pagebreak" id="pg_125" role="doc-pagebreak"/><samp class="SANS_TheSansMonoCd_W5Regular_11">free(ptr)</samp>. Otherwise, the behavior is undefined. In other words, this function may be used only for deallocating explicitly aligned memory.</p>
<p class="TX">Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">free_aligned_sized</samp> function, we could improve the performance and safety of the following code</p>

<pre><code>void *aligned_buf = aligned_alloc(alignment, size);
use_aligned(buf, size, alignment);
free(buf);</code></pre>
<p class="Continued">by rewriting it as:</p>

<pre><code>void *aligned_buf = aligned_alloc(size, alignment);
use_aligned(buf, size, alignment);
free_aligned_sized(buf, alignment, size);</code></pre>
<p class="TX">This is feasible and practical when the alignment and size of the allocation is retained or can be inexpensively re-created.</p>
<section aria-labelledby="sec17" epub:type="division">

<h4 class="H3" id="sec17"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dealing with Dangling Pointers</samp></h4>
<p class="TNI">If you call one of the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> functions on the same pointer more than once, undefined behavior occurs. These defects can result in a security flaw known as a <i>double-free vulnerability</i>. One consequence is that they might be exploited to execute arbitrary code with the permissions of the vulnerable process. The full effects of double-free vulnerabilities are beyond the scope of this book, but I discuss them in detail in <i>Secure Coding in C and C++</i> (Seacord 2013). Double-free vulnerabilities are especially common in error-handling code, as programmers attempt to free allocated resources.</p>
<p class="TX">Another common error is to access memory that has already been freed. This type of error frequently goes undetected because the code might appear to work but then fails in an unexpected manner away from the actual error. In <a href="chapter6.xhtml#Lis6-4">Listing 6-4</a>, taken from an actual application, the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">close</samp> is invalid because the second call to <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> has reclaimed the storage <samp class="SANS_TheSansMonoCd_W5Regular_11">dirp</samp> formerly pointed to.</p>
<span id="Lis6-4"/>
<pre><code>#include &lt;dirent.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int closedir(DIR *dirp) {
  free(dirp-&gt;d_buf);
  free(dirp);
  return close(dirp-&gt;d_fd);  // dirp has already been freed
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-4: Accessing already freed memory</samp></p>
<p class="TX">We refer to pointers to already freed memory as <i>dangling pointers</i>. Dangling pointers are a potential source of errors (like a banana peel on the floor). Every use of a dangling pointer (not just dereferencing) is undefined behavior. When used to access memory that has already been freed, <span aria-label="126" epub:type="pagebreak" id="pg_126" role="doc-pagebreak"/>dangling pointers can result in use-after-free vulnerabilities (CWE 416). When passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> function, dangling pointers can result in double-free vulnerabilities (CWE 415). See CERT C rule MEM30-C, “Do not access freed memory,” for more information on these topics.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">

<h4 class="H3" id="sec18"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting the Pointer to Null</samp></h4>
<p class="TNI">To limit the opportunity for defects involving dangling pointers, set the pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp> after completing a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>:</p>

<pre><code>char *ptr = malloc(16);
// <var>--snip--</var>
free(ptr);
ptr = nullptr;</code></pre>
<p class="TX">Any future attempt to dereference the pointer will usually result in a crash, increasing the likelihood that the error is detected during implementation and testing. If the pointer is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp>, the memory can be freed multiple times without consequence. Unfortunately, the <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> function cannot set the pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp> itself because it’s passed a copy of the pointer and not the actual pointer.</p>
</section>
</section>
</section>
<section aria-labelledby="sec19" epub:type="division">

<h2 class="H1" id="sec19"><span id="h1-57"/><samp class="SANS_Futura_Std_Bold_B_11">Memory States</samp></h2>
<p class="TNI">Dynamically allocated memory can exist in one of three states shown in <a href="chapter6.xhtml#fig6-1">Figure 6-1</a>: unallocated and uninitialized within the memory manager, allocated but uninitialized, and allocated and initialized. Calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> functions, as well as writing the memory, cause the memory to transition between states.</p>
<figure class="IMG"><img alt="" class="img1" id="fig6-1" src="../images/f06001.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: Memory states</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label="127" epub:type="pagebreak" id="pg_127" role="doc-pagebreak"/>Different operations are valid depending on the state of the memory. Avoid any operation on memory that’s not shown as valid or explicitly listed as invalid. Following execution of the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function in this code snippet</p>

<pre><code>char *p = malloc(100);
memset(p, 0, 50);</code></pre>
<p class="Continued">the first 50 bytes are allocated and initialized, while the last 50 bytes are allocated but uninitialized. Initialized bytes can be read, but uninitialized bytes must not be read.</p>
</section>
<section aria-labelledby="sec20" epub:type="division">

<h2 class="H1" id="sec20"><span id="h1-58"/><samp class="SANS_Futura_Std_Bold_B_11">Flexible Array Members</samp></h2>
<p class="TNI">Allocating storage for a structure that contains an array has always been a little tricky in C. There’s no problem if the array has a fixed number of elements, as the size of the structure can easily be determined. Developers, however, frequently need to declare an array whose size is unknown until runtime, and originally, C offered no straightforward way to do so.</p>
<p class="TX">Flexible array members let you declare and allocate storage for a structure with any number of fixed members, where the last member is an array of unknown size. Starting with C99, the last member of a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> with more than one member can have an <i>incomplete array type</i>, which means that the array has an unknown size that you can specify at runtime. A flexible array member allows you to access a variable-length object.</p>
<p class="TX">For example, <a href="chapter6.xhtml#Lis6-5">Listing 6-5</a> shows the use of a flexible array member <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">widget</samp>. We dynamically allocate storage for the object by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> function.</p>
<span id="Lis6-5"/>
<pre><code>#include &lt;stdlib.h&gt;

constexpr size_t max_elem = 100;

typedef struct {
  size_t num;
<span aria-label="annotation1" class="code_CodeAnnotation">❶</span> int data[];
} widget;

widget *alloc_widget(size_t num_elem) {
  if (num_elem &gt; max_elem) return nullptr;
<span aria-label="annotation2" class="code_CodeAnnotation">❷</span> widget *p = (widget *)malloc(sizeof(widget) + sizeof(int) * num_elem);
  if (p == nullptr) return nullptr;

  p-&gt;num = num_elem;
  for (size_t i = 0; i &lt; p-&gt;num; ++i) {
  <span aria-label="annotation3" class="code_CodeAnnotation">❸</span> p-&gt;data[i] = 17;
  }
  return p;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-5: Flexible array members</samp></p>
<p class="TX"><span aria-label="128" epub:type="pagebreak" id="pg_128" role="doc-pagebreak"/>We first declare a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> whose last member, the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> array <span aria-label="annotation1" class="CodeAnnotation">❶</span>, is an incomplete type (with no specified size). We then allocate storage for the entire <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. When computing the size of a <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> containing a flexible array member using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator, the flexible array member is ignored. Therefore, we must explicitly include an appropriate size for the flexible array member when allocating storage. To accomplish that, we allocate additional bytes for the array by multiplying the number of elements in the array (<samp class="SANS_TheSansMonoCd_W5Regular_11">num_elem</samp>) by the size of each element (<samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(int)</samp>). This program assumes that the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">num_elem</samp> is such that when multiplied by <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(int)</samp>, wraparound won’t occur.</p>
<p class="TX">We can access this storage by using a <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</samp> operator <span aria-label="annotation3" class="CodeAnnotation">❸</span>, as if the storage had been allocated as <samp class="SANS_TheSansMonoCd_W5Regular_11">data[num_elem]</samp>. See CERT C rule MEM33-C, “Allocate and copy structures containing a flexible array member dynamically,” for more information on allocating and copying structures containing flexible array members.</p>
<p class="TX">Prior to C99, multiple compilers supported a similar “<samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> hack” using a variety of syntaxes. CERT C rule DCL38-C, “Use the correct syntax when declaring a flexible array member, ” is a reminder to use the syntax specified in C99 and later versions of the C standard.</p>
</section>
<section aria-labelledby="sec21" epub:type="division">

<h2 class="H1" id="sec21"><span id="h1-59"/><samp class="SANS_Futura_Std_Bold_B_11">Other Dynamically Allocated Storage</samp></h2>
<p class="TNI">C has language and library features beyond the memory management functions that support dynamically allocated storage. This storage is typically allocated in the stack frame of the caller (the C standard does not define a stack, but it’s a common implementation feature). A <i>stack</i> is a last-in-first-out (LIFO) data structure that supports nested invocation of functions at runtime. Each function invocation creates a <i>stack frame</i> in which local variables (of automatic storage duration) and other data specific to that invocation of the function can be stored.</p>
<section aria-labelledby="sec22" epub:type="division">

<h3 class="H2" id="sec22"><span id="h2-78"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">alloca</samp></h3>
<p class="TNI">For performance reasons, <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> (a nonstandard function supported by some implementations) allows dynamic allocation at runtime from the stack rather than the heap. This memory is automatically released when the function that called <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> returns. The <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function is an <i>intrinsic</i> (or <i>built-in</i>) function, which is specially handled by the compiler. This allows the compiler to substitute a sequence of automatically generated instructions for the original function call. For example, on the x86 architecture, the compiler substitutes a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> with a single instruction to adjust the stack pointer to accommodate the additional storage.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function originated in an early version of the Unix operating system from Bell Laboratories but is not defined by the C standard library or POSIX. <a href="chapter6.xhtml#Lis6-6">Listing 6-6</a> shows an example function called <samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp> that uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function to allocate storage for an error string before printing it out to <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>.</p>
<span id="Lis6-6"/>
<pre><code><span aria-label="129" epub:type="pagebreak" id="pg_129" role="doc-pagebreak"/>void printerr(errno_t errnum) {
<span aria-label="annotation1" class="code_CodeAnnotation">❶</span> rsize_t size = strerrorlen_s(errnum) + 1;
<span aria-label="annotation2" class="code_CodeAnnotation">❷</span><b> char *msg = (char *)alloca(size);</b>
  if (<span aria-label="annotation3" class="CodeAnnotation">❸</span> strerror_s(msg, size, errnum) != 0) {
   <span aria-label="annotation4" class="code_CodeAnnotation">❹</span> fputs(msg, stderr);
  }
  else {
   <span aria-label="annotation5" class="code_CodeAnnotation">❺</span> fputs("unknown error", stderr);
  }
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-6: The</samp> <samp class="I">printerr</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp> function takes a single argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">errnum</samp>, of <samp class="SANS_TheSansMonoCd_W5Regular_11">errno_t</samp> type. We call the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp> function <span aria-label="annotation1" class="CodeAnnotation">❶</span> to determine the length of the error string associated with this error number. Once we know the size of the array that we need to allocate to hold the error string, we can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function <span aria-label="annotation2" class="CodeAnnotation">❷</span> to efficiently allocate storage for the array. We then retrieve the error string by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> function <span aria-label="annotation3" class="CodeAnnotation">❸</span> and store the result in the newly allocated storage <samp class="SANS_TheSansMonoCd_W5Regular_11">msg</samp> references. Assuming the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> function succeeds, we output the error message <span aria-label="annotation4" class="CodeAnnotation">❹</span>; otherwise, we output <samp class="SANS_TheSansMonoCd_W5Regular_11">unknown error</samp> <span aria-label="annotation5" class="CodeAnnotation">❺</span>. This <samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp> function is written to demonstrate the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> and is more complicated than it needs to be.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function can be tricky to use. First, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> can make allocations that exceed the bounds of the stack. However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function doesn’t return a null pointer value, so there’s no way to check for the error. For this reason, it’s critically important to avoid using <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> with large or unbounded allocations. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp> in this example should return a reasonable allocation size.</p>
<p class="TX">A further problem with the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function is that programmers may become confused by having to free memory allocated by <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> but not <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>. Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> on a pointer not obtained by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> is a serious error. Due to those issues, the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> is discouraged.</p>
<p class="TX">Both GCC and Clang provide a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Walloca</samp> compiler flag that diagnoses all calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function. GCC also provides a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Walloca-larger-than=</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp> compiler flag that diagnoses any call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function when the requested memory is more than <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">size</samp>.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">

<h3 class="H2" id="sec23"><span id="h2-79"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variable-Length Arrays</samp></h3>
<p class="TNI">Variable-length arrays (VLAs) were introduced in C99. A VLA is an object of a variably modified type (covered in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>). Storage for the VLA is allocated at runtime and is equal to the size of the base type of the variably modified type multiplied by the runtime extent.</p>
<p class="TX">The size of the array cannot be modified after you create it. All VLA declarations must be at <i>block scope</i>.</p>
<p class="TX"><span aria-label="130" epub:type="pagebreak" id="pg_130" role="doc-pagebreak"/>The following example declares the VLA <samp class="SANS_TheSansMonoCd_W5Regular_11">vla</samp> of size <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> as an automatic variable in function <samp class="SANS_TheSansMonoCd_W5Regular_11">func</samp>:</p>

<pre><code>void func(size_t size) {
  int vla[size];
  // <var>--snip--</var>
}</code></pre>
<p class="TX">VLAs are useful when you don’t know the number of elements in the array until runtime. Unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function, VLAs are freed when the corresponding block ends, just like any other automatic variable. <a href="chapter6.xhtml#Lis6-7">Listing 6-7</a> replaces the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">printerr</samp> function from <a href="chapter6.xhtml#Lis6-6">Listing 6-6</a> with a VLA. The change modifies just a single line of code (shown in bold).</p>
<span id="Lis6-7"/>
<pre><code>void print_error(int errnum) {
  size_t size = strerrorlen_s(errnum) + 1;
<b>  char msg[size];</b>
  if (strerror_s(msg, size, errnum) != 0) {
    fputs(msg, stderr);
  }
  else {
    fputs("unknown error", stderr);
  }
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-7: The</samp> <samp class="I">print_error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function rewritten to use a VLA</samp></p>
<p class="TX">The main advantage of using VLAs instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function is that the syntax matches the programmer’s model of how arrays with automatic storage duration work. VLAs work just like automatic variables (because they are). Another advantage is that memory does not accumulate while iterating (which can accidentally happen with <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> because memory is released at the end of the function).</p>
<p class="TX">VLAs share some of the problems of the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function, in that they can attempt to make allocations that exceed the bounds of the stack. Unfortunately, there’s no portable way to determine the remaining stack space to detect such an error. Also, the calculation of the array’s size could wrap around when the size you provide is multiplied by the size of each element. For those reasons, it’s important to validate the size of the array before declaring it to avoid overly large or incorrectly sized allocations. This can be especially important in functions that are called with untrusted inputs or are called recursively, because a complete new set of automatic variables for the functions (including these arrays) will be created for each recursion. Untrusted inputs must be validated before being used for any allocations, including from the heap.</p>
<p class="TX">You should determine whether you have sufficient stack space in the worst-case scenario (maximum-sized allocations with deep recursions). On some implementations, it’s also possible to pass a negative size to the VLA, so make sure your size is represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> or other unsigned type. See CERT C rule ARR32-C, “Ensure size arguments for variable-length arrays <span aria-label="131" epub:type="pagebreak" id="pg_131" role="doc-pagebreak"/>are in a valid range,” for more information. VLAs reduce stack usage when compared to using worst-case fixed-sized arrays.</p>
<p class="TX">The following file-scope declarations demonstrate another confusing aspect of VLAs:</p>

<pre><code>static const unsigned int num_elem = 12;
double array[num_elem];</code></pre>
<p class="TX">Is this code valid? If <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> is a VLA, then the code is invalid, because the declaration is at file scope. If <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> is a constant-sized array, then the code is valid. GCC currently rejects this example because <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> is a VLA. However, C23 allows implementations to extend the definition of an integer constant expression, which Clang does by making <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> a constant-sized array.</p>
<p class="TX">We can rewrite these declarations to be portable using <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> on all C23-conforming implementations:</p>

<pre><code>constexpr unsigned int num_elem = 12;
double array[num_elem];</code></pre>
<p class="TX">Finally, another interesting and unexpected behavior occurs when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> on a VLA. The compiler usually performs the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operation at compile time. However, if the expression changes the size of the array, it will be evaluated at runtime, including any side effects. The same is true of <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>, as the program in <a href="chapter6.xhtml#Lis6-8">Listing 6-8</a> shows.</p>
<span id="Lis6-8"/>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  size_t size = 12;
  (void)(sizeof(size++));
  printf("%zu\n", size); // prints 12
  (void)sizeof(int[size++]);
  printf("%zu\n", size); // prints 13
  typedef int foo[size++];
  printf("%zu\n", size); // prints 14
  typeof(int[size++]) f;
  printf("%zu\n", size); // prints 15
  return EXIT_SUCCESS;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-8: Unexpected side effects</samp></p>
<p class="TX">In this simple test program, we declare a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> of type <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> and initialize it to <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>. The operand in <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(size++)</samp> isn’t evaluated because the type of the operand is not a VLA. Consequently, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> doesn’t change. We then call the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator with <samp class="SANS_TheSansMonoCd_W5Regular_11">int[size++]</samp> as the argument. Because this expression changes the size of the array, <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> is incremented and is now equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">13</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp> similarly increments the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">14</samp>. Finally, we declare <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> to be of <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof(int[size++])</samp>, which further increments <span aria-label="132" epub:type="pagebreak" id="pg_132" role="doc-pagebreak"/><samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>. Because these behaviors aren’t well understood, avoid using expressions with side effects with the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operators, and <samp class="SANS_TheSansMonoCd_W5Regular_11">typedef</samp>s to improve understandability.</p>
</section>
</section>
<section aria-labelledby="sec24" epub:type="division">

<h2 class="H1" id="sec24"><span id="h1-60"/><samp class="SANS_Futura_Std_Bold_B_11">Debugging Allocated Storage Problems</samp></h2>
<p class="TNI">As noted earlier in this chapter, improper memory management can lead to errors like leaking memory, reading from or writing to freed memory, and freeing memory more than once. One way to avoid some of these problems is to set pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> null pointer value after calling <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>, as we’ve already discussed. Another strategy is to keep your dynamic memory management as simple as possible. For example, you should allocate and free memory in the same module, at the same level of abstraction, rather than freeing memory in subroutines, which leads to confusion about if, when, and where memory is freed.</p>
<p class="TX">A third option is to use <i>dynamic analysis tools</i>, such as AddressSanitizer, Valgrind, or <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> to detect and report memory errors. AddressSanitizer, as well as general approaches to debugging, testing, and analysis, are discussed in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>, while <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> is covered in this section. AddressSanitizer or Valgrind are effective tools and better choices if they are available for your environment.</p>
<section aria-labelledby="sec25" epub:type="division">

<h3 class="H2" id="sec25"><span id="h2-80"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">dmalloc</samp></h3>
<p class="TNI">The <i>debug memory allocation</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>) library Gray Watson created replaces <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>, and other memory management features with routines that provide debugging facilities that you can configure at runtime. The library has been tested on a variety of platforms.</p>
<p class="TX">Follow the installation directions provided at <i><a href="https://dmalloc.com">https://<wbr/>dmalloc<wbr/>.com</a></i> to configure, build, and install the library. <a href="chapter6.xhtml#Lis6-9">Listing 6-9</a> contains a short program that prints out usage information and exits (it would typically be part of a longer program). This program has several intentional errors and vulnerabilities.</p>
<span id="Lis6-9"/>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

<b>#ifdef DMALLOC</b>
<b>#include "dmalloc.h"</b>
<b>#endif</b>

void usage(char *msg) {
  fprintf(stderr, "%s", msg);
  free(msg);
  return;
}

int main(int argc, char *argv[]) {
<span aria-label="133" epub:type="pagebreak" id="pg_133" role="doc-pagebreak"/>  if (argc != 3 &amp;&amp; argc != 4) {
    // the error message is less than 80 chars
    char *errmsg = (char *)malloc(80);
    sprintf(
      errmsg,
      "Sorry %s,\nUsage: caesar secret_file keys_file [output_file]\n",
      getenv("USER")
    );
    usage(errmsg);
    free(errmsg);
    return EXIT_FAILURE;
  }
<var>  </var>// <var>--snip--</var>

  return EXIT_SUCCESS;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-9: Catching a memory bug with</samp> <samp class="I">dmalloc</samp></p>
<p class="TX">Recent versions of glibc will detect at least one of the vulnerabilities from this program:</p>

<pre><code>Sorry (null),
Usage: caesar secret_file keys_file [output_file]
free(): double free detected in tcache 2
Program terminated with signal: SIGSEGV</code></pre>
<p class="TX">After repairing this error, include the lines shown in bold font to allow <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> to report the file and line numbers of calls that cause problems.</p>
<p class="TX">I’ll show the output later, but we need to discuss a few things first. The <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> distribution also comes with a command line utility. You can run the following command to get further information on how to use this utility:</p>

<pre><code>% <b>dmalloc --usage</b></code></pre>
<p class="TX">Before debugging your program with <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>, enter the following at the command line:</p>

<pre><code>% <b>dmalloc -l logfile -i 100 low</b></code></pre>
<p class="TX">This command sets the logfile name to <i>logfile</i> and instructs the library to perform a check after <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp> invocations, as the <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp> argument specifies. If you specify a larger number as the <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp> argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> will check the heap less often, and your code will run faster; lower numbers are more likely to catch memory problems. The third argument enables a <samp class="SANS_TheSansMonoCd_W5Regular_11">low</samp> number of debug features. Other options include <samp class="SANS_TheSansMonoCd_W5Regular_11">runtime</samp> for minimal checking or <samp class="SANS_TheSansMonoCd_W5Regular_11">medium</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">high</samp> for more extensive heap verification.</p>
<p class="TX">After executing this command, we can compile the program by using GCC as follows:</p>

<pre><code>% <b>gcc -DDMALLOC caesar.c -ocaesar -ldmalloc</b></code></pre>
<p class="TX"><span aria-label="134" epub:type="pagebreak" id="pg_134" role="doc-pagebreak"/>When you run the program, you should see the following error:</p>

<pre><code>% <b>./caesar</b>
Sorry student,
Usage: caesar secret_file keys_file [output_file]
debug-malloc library: dumping program, fatal error
  Error: tried to free previously freed pointer (err 61)
Aborted (core dumped)</code></pre>
<p class="TX">And if you examine the logfile, you’ll find the following information:</p>

<pre><code>% <b>more logfile</b>
1571549757: 3: Dmalloc version '5.5.2' from 'https://dmalloc.com/'
1571549757: 3: flags = 0x4e48503, logfile 'logfile'
1571549757: 3: interval = 100, addr = 0, seen # = 0, limit = 0
1571549757: 3: starting time = 1571549757
1571549757: 3: process pid = 29531
1571549757: 3:   error details: finding address in heap
1571549757: 3:   pointer '0x7ff010812f88' from 'caesar.c:29' prev access 'unknown'
1571549757: 3: ERROR: free: tried to free previously freed pointer (err 61)</code></pre>
<p class="TX">These messages indicate that we’ve attempted to free the storage referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">errmsg</samp> twice, first in the <samp class="SANS_TheSansMonoCd_W5Regular_11">usage</samp> function and then in <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, which constitutes a double-free vulnerability. Of course, this is just a single example of the types of bugs that <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> can detect, and other defects exist in the simple program we are testing.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">

<h3 class="H2" id="sec26"><span id="h2-81"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Safety-Critical Systems</samp></h3>
<p class="TNI">Systems with high safety requirements frequently ban the use of dynamic memory because memory managers can have unpredictable behavior that significantly impacts performance. Forcing all applications to live within a fixed, preallocated area of memory can eliminate these problems and make it easier to verify memory use. In the absence of recursion, <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp>, and VLAs (also prohibited in safety-critical systems), an upper bound on the use of stack memory can be derived statically, making it possible to prove that sufficient storage exists to execute the functionality of the application for all possible inputs.</p>
<p class="TX">Both GCC and Clang have a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wvla</samp> flag that warns if a VLA is used. GCC also has a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wvla-larger-than=</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">byte-size</samp> flag that warns for declarations of VLAs whose size is either unbounded or bounded by an argument that allows the array size to exceed <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">byte-size</samp> bytes.</p>
<aside aria-label="box-9" class="box1">
<p class="BoxTitle" id="box-9"><span aria-label="135" epub:type="pagebreak" id="pg_135" role="doc-pagebreak"/><samp class="SANS_Dogma_OT_Bold_B_11">EXERCISES</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Book_11">1.  Repair the use-after-free defect from <a href="chapter6.xhtml#Lis6-4">Listing 6-4</a>.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Book_11">2.  Use</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> <samp class="SANS_Futura_Std_Book_11">to perform additional testing of the program from <a href="chapter6.xhtml#Lis6-9">Listing 6-9</a>. Try varying inputs to the program to identify other memory management defects.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec27" epub:type="division">

<h2 class="H1" id="sec27"><span id="h1-61"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI">In this chapter, you learned about working with memory that has allocated storage duration and how this differs from objects of either automatic or static storage duration. We described the heap and memory managers and each of the standard memory management functions. We identified some common causes of errors when using dynamic memory, such as leaks and double-free vulnerabilities, and introduced some mitigations to help avoid these problems.</p>
<p class="TX">We also covered some more specialized memory allocation topics such as flexible array members, the <samp class="SANS_TheSansMonoCd_W5Regular_11">alloca</samp> function, and VLAs. We concluded the chapter with a discussion of debugging allocated storage problems by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> library.</p>
<p class="TX">In the next chapter, you’ll learn about characters and strings.</p>
</section>
</section>
</body></html>