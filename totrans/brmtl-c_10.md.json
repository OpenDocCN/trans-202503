["```\n/*\n * Print a string one character at a time.\n */\n#include <stdio.h>\n\nchar hello[] = \"Hello World\\n\"; // The characters to print\nint curChar;    // Character number we are printing\n\nint main()\n{\n  1 for (curChar = 0; hello[curChar] != '\\0'; ++curChar)\n        putchar(hello[curChar]);\n    return (0);\n}\n```", "```\n/**\n * Print a string one character at a time\n * using our own function.\n */\n#include <stdio.h>\n\nchar hello[] = \"Hello World\\n\"; // The characters to print\n\n1 /**\n * Reimplementation of putchar\n *\n * @param ch The character to send\n *\n * @note Not as apparently useless as it seems\n */\n2 void myPutchar(const char ch)\n{\n  3 putchar(ch);\n}\n\nint main()\n{\n    int curChar;        // Index of the current character we\n                        // are printing\n    for (curChar = 0; hello[curChar] != '\\0'; ++curChar)\n      4 myPutchar(hello[curChar]);\n    return (0);\n}\n```", "```\n#include \"stm32f0xx.h\"\n#include \"stm32f0xx_nucleo.h\"\n```", "```\nint main(void)\n{\n  1 HAL_Init(); // Initialize hardware.\n    led2_Init();\n    uart2_Init();\n\n    // Keep sending the message for a long time.\n  2 for (;;) {\n        // Send character by character.\n        for(current = 0; hello[current] != '\\0'; ++current) {\n          3 myPutchar(hello[current]);\n        }\n      4 HAL_Delay(500);\n    }\n}\n```", "```\nvoid uart2_Init(void)\n{\n    // UART initialization\n    // UART2 -- one connected to ST-LINK USB\n  1 uartHandle.Instance = USART2;\n  2 uartHandle.Init.BaudRate = 9600;                   // Speed 9600\n  3 uartHandle.Init.WordLength = UART_WORDLENGTH_8B;   // 8 bits/character\n  4 uartHandle.Init.StopBits = UART_STOPBITS_1;        // 1 stop bit\n  5 uartHandle.Init.Parity = UART_PARITY_NONE;         // No parity\n  6 uartHandle.Init.Mode = UART_MODE_TX_RX;            // Transmit & receive\n  7 uartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;   // No hw control\n\n    // Oversample the incoming stream.\n    uartHandle.Init.OverSampling = UART_OVERSAMPLING_16;\n\n    // Do not use one-bit sampling.\n  8 uartHandle.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;\n\n    // Nothing advanced\n  9 uartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;\n    /*\n     * For those of you connecting a terminal emulator, the above parameters\n     * translate to 9600,8,N,1.\n     */\n\n    if (HAL_UART_Init(&uartHandle) != HAL_OK)\n    {\n        Error_Handler();\n    }\n}\n```", "```\nHAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)\n{\n  /* Check the UART handle allocation. */\n  if(huart == NULL)\n  {\n    return HAL_ERROR;\n  }\n  // ...\n  if(huart->gState == HAL_UART_STATE_RESET)\n  {\n    /* Allocate lock resource and initialize it. */\n    huart->Lock = HAL_UNLOCKED;\n\n    /* Initialize the low-level hardware: GPIO, CLOCK. */\n    HAL_UART_MspInit(huart);\n  }\n```", "```\nvoid HAL_UART_MspInit(UART_HandleTypeDef* uart)\n{\n    GPIO_InitTypeDef GPIO_InitStruct;\n  1 if(uart->Instance == USART2)\n    {\n        /* Peripheral clock enable */\n      2 __HAL_RCC_USART2_CLK_ENABLE();\n\n /*\n         * USART2 GPIO Configuration\n         * PA2     ------> USART2_TX\n         * PA3     ------> USART2_RX\n         */\n        GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;\n        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n        GPIO_InitStruct.Pull = GPIO_NOPULL;\n        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n        // Alternate function -- that of UART\n      3 GPIO_InitStruct.Alternate = GPIO_AF1_USART2;\n        HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n    }\n}\n```", "```\nuartHandle.Instance->TDR = ch;     // Send character to the UART.\n```", "```\nvoid myPutchar(const char ch)\n{\n    // This line gets and saves the value of UART_FLAG_TXE at call\n    // time. This value changes so if you stop the program on the \"if\"\n    // line below, the value will be set to zero because it goes away\n    // faster than you can look at it.\n    int result __attribute__((unused)) =\n        (uartHandle.Instance->ISR & UART_FLAG_TXE);\n\n    // Block until the transmit empty (TXE) flag is set.\n    while ((uartHandle.Instance->ISR & UART_FLAG_TXE) == 0)\n        continue;\n\n    uartHandle.Instance->TDR = ch;     // Send character to the UART.\n}\n```", "```\nuartHandle.Instance->TDR = 'a';\nsleep_1_960_second();\nuartHandle.Instance->TDR = 'b';\nsleep_1_960_second();\nuartHandle.Instance->TDR = 'c';\nsleep_1_960_second();\n```", "```\nint result __attribute__((unused)) =\n    (uartHandle.Instance->ISR & UART_FLAG_TXE);\n```", "```\n__attribute__((unused))\n```", "```\n/**\n * @brief Write hello world on the serial port.\n */\n#include <stdbool.h>\n#include \"stm32f0xx_nucleo.h\"\n#include \"stm32f0xx.h\"\n\nconst char hello[] = \"Hello World!\\r\\n\";   // The message to send\nint current; // The character in the message we are sending\n\nUART_HandleTypeDef uartHandle;      // UART initialization\n\n/**\n  * @brief This function is executed in case of error occurrence.\n  *\n  * All it does is blink the LED.\n  */\nvoid Error_Handler(void)\n{\n /* Turn LED2 on. */\n    HAL_GPIO_WritePin(LED2_GPIO_PORT, LED2_PIN, GPIO_PIN_SET);\n\n    while (true)\n    {\n        // Toggle the state of LED2.\n        HAL_GPIO_TogglePin(LED2_GPIO_PORT, LED2_PIN);\n        HAL_Delay(1000);        // Wait one second.\n    }\n}\n/**\n * Send character to the UART.\n *\n * @param ch The character to send\n */\nvoid myPutchar(const char ch)\n{\n    // This line gets and saves the value of UART_FLAG_TXE at call\n    // time. This value changes so if you stop the program on the \"if\"\n    // line below, the value will be set to zero because it goes away\n    // faster than you can look at it.\n    int result __attribute__((unused)) =\n        (uartHandle.Instance->ISR & UART_FLAG_TXE);\n\n    // Block until the transmit empty (TXE) flag is set.\n    while ((uartHandle.Instance->ISR & UART_FLAG_TXE) == 0)\n        continue;\n\n    uartHandle.Instance->TDR = ch;     // Send character to the UART.\n}\n\n/**\n * Initialize LED2 (so we can blink red for error).\n */\nvoid led2_Init(void)\n{\n    // LED clock initialization\n    LED2_GPIO_CLK_ENABLE();\n\n    GPIO_InitTypeDef GPIO_LedInit;      // Initialization for the LED\n    // Initialize LED.\n    GPIO_LedInit.Pin = LED2_PIN;\n    GPIO_LedInit.Mode = GPIO_MODE_OUTPUT_PP;\n    GPIO_LedInit.Pull = GPIO_PULLUP;\n    GPIO_LedInit.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(LED2_GPIO_PORT, &GPIO_LedInit);\n}\n\n/**\n * Initialize UART2 for output.\n */\nvoid uart2_Init(void)\n{\n    // UART initialization\n    // UART2 -- one connected to ST-LINK USB\n uartHandle.Instance = USART2;\n    uartHandle.Init.BaudRate = 9600;                    // Speed 9600\n    uartHandle.Init.WordLength = UART_WORDLENGTH_8B;    // 8 bits/character\n    uartHandle.Init.StopBits = UART_STOPBITS_1;         // 1 stop bit\n    uartHandle.Init.Parity = UART_PARITY_NONE;          // No parity\n    uartHandle.Init.Mode = UART_MODE_TX_RX;             // Transmit & receive\n    uartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;    // No hw control\n\n    // Oversample the incoming stream.\n    uartHandle.Init.OverSampling = UART_OVERSAMPLING_16;\n\n    // Do not use one-bit sampling.\n    uartHandle.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;\n\n    // Nothing advanced\n    uartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;\n    /*\n     * For those of you connecting a terminal emulator, the above parameters\n     * translate to 9600,8,N,1.\n     */\n\n    if (HAL_UART_Init(&uartHandle) != HAL_OK)\n    {\n        Error_Handler();\n    }\n}\n\nint main(void)\n{\n    HAL_Init(); // Initialize hardware.\n    led2_Init();\n    uart2_Init();\n\n    // Keep sending the message for a long time.\n    for (;;) {\n        // Send character by character.\n        for(current = 0; hello[current] != '\\0'; ++current) {\n            myPutchar(hello[current]);\n        }\n        HAL_Delay(500);\n    }\n}\n\n/**\n * Magic function that's called by the HAL layer to actually\n * initialize the UART. In this case we need to\n * put the UART pins in alternate mode so they act as\n * UART pins and not like GPIO pins.\n *\n * @note: Only works for UART2, the one connected to the USB serial\n * converter\n *\n * @param uart The UART information\n */\nvoid HAL_UART_MspInit(UART_HandleTypeDef* uart)\n{\n    GPIO_InitTypeDef GPIO_InitStruct;\n    if(uart->Instance == USART2)\n    {\n        /* Peripheral clock enable */\n        __HAL_RCC_USART2_CLK_ENABLE();\n\n        /*\n         * USART2 GPIO Configuration\n         * PA2     ------> USART2_TX\n         * PA3     ------> USART2_RX\n         */\n        GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;\n        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n        GPIO_InitStruct.Pull = GPIO_NOPULL;\n        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;\n        // Alternate function -- that of UART\n        GPIO_InitStruct.Alternate = GPIO_AF1_USART2;\n        HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n    }\n\n}\n\n/**\n * Magic function called by HAL layer to de-initialize the\n * UART hardware. It's something we never do, but we put it\n * in here for the sake of completeness.\n *\n * @note: Only works for UART2, the one connected to the USB serial\n * converter\n *\n * @param uart The UART information\n */\nvoid HAL_UART_MspDeInit(UART_HandleTypeDef* uart)\n{\n    if(uart->Instance == USART2)\n    {\n        /* Peripheral clock disable */\n        __HAL_RCC_USART2_CLK_DISABLE();\n\n        /*\n         * USART2 GPIO Configuration\n         * PA2     ------> USART2_TX\n         * PA3     ------> USART2_RX\n         */\n        HAL_GPIO_DeInit(GPIOA, GPIO_PIN_2|GPIO_PIN_3);\n    }\n}\n```", "```\n$ **ls /dev/ttyACM***          (Linux)\n$ **ls /dev/tty.usbmodem***    (macOS)\n```", "```\n$ **screen /dev/ttyACM0 9600**\n```"]