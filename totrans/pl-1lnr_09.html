<html><head></head><body><section class="appendix" title="Appendix&#xA0;B.&#xA0;Using Perl One-Liners On Windows" epub:type="appendix" id="using_perl_one-liners_on_windows"><div class="titlepage"><div><div><h2 class="title">Appendix B. Using Perl One-Liners On Windows</h2></div></div></div><a id="idx00486" class="indexterm"/><a id="idx00489" class="indexterm"/><a id="idx00561" class="indexterm"/><a id="idx00663" class="indexterm"/><a id="idx00664" class="indexterm"/><a id="idx00077" class="indexterm"/><a id="idx00079" class="indexterm"/><a id="idx00649" class="indexterm"/><a id="idx00651" class="indexterm"/><a id="idx00652" class="indexterm"/><a id="idx00665" class="indexterm"/><p>In this appendix, I’ll show you how to run Perl on Windows, install a bash port on Windows, and use Perl one-liners in three different ways: from the Windows bash port, the Windows command prompt (<span class="emphasis"><em>cmd.exe</em></span>), and PowerShell.</p><div class="sect1" title="B.1 Perl on Windows"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="b_1_perl_on_windows">B.1 Perl on Windows</h2></div></div></div><p>Before you can run Perl on Windows, you need to install Perl for Windows. My favorite Windows Perl port is Strawberry Perl (<span class="emphasis"><em><a class="ulink" href="http://strawberryperl.com/" target="_top">http://strawberryperl.com/</a></em></span>), a Perl environment with everything you need to run and develop Perl applications on Windows. Strawberry Perl is designed to function as much as possible like the Perl environment on UNIX systems. It includes Perl binaries, the gcc compiler and related build tools, and many external libraries.</p><p>To install Strawberry Perl, download and run the installer, click through a bunch of menus a few times, and you’re done. My choice for the installation directory is <span class="emphasis"><em>c:\strawberryperl</em></span>. (Installing any UNIX software for Windows in a directory with no spaces in it is always a good idea.) Once the installation is done, the installer should put the installation directory in your path environment variable so you can run Perl from the command line right away.</p><p>Unfortunately, the Windows command line is really basic compared to the command line on UNIX systems. A UNIX system runs a real shell with well-defined command-line parsing rules, but Windows doesn’t really have anything like that. The Windows command line has weird rules about how it treats certain symbols, the quoting rules aren’t well defined, and the escaping rules are strange, all of which makes it difficult to run Perl one-liners. Therefore, the preferred way to run one-liners on Windows is to use a UNIX shell (such as bash) for Windows, as you’ll learn in the next section.</p></div><div class="sect1" title="B.2 Bash on Windows"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="b_2_bash_on_windows">B.2 Bash on Windows</h2></div></div></div><p>Getting a bash shell to run on Windows is simple. I recommend win-bash (<span class="emphasis"><em><a class="ulink" href="http://win-bash.sourceforge.net/" target="_top">http://win-bash.sourceforge.net/</a></em></span>), a stand-alone bash port for Windows that doesn’t need a special environment or additional DLLs. The download is a single zip file that contains the bash shell (<span class="emphasis"><em>bash.exe</em></span>) and a bunch of UNIX utilities (such as awk, cat, cp, diff, find, grep, sed, vi, wc, and about 100 others).</p><p>To install bash and all the utilities, simply unzip the file and you’re done. My choice for the installation directory is <span class="emphasis"><em>c:\winbash</em></span>, again with no spaces in the directory. Run <span class="emphasis"><em>bash.exe</em></span> from <span class="emphasis"><em>c:\winbash</em></span> to start the bash shell.</p><p>If you start <span class="emphasis"><em>bash.exe</em></span> after you install Strawberry Perl, Perl should be available for use right away because the Strawberry Perl installer should have updated the path with the installation directory. To confirm, run <code class="literal">perl --version</code>. It should output the version of the installed Perl. If you get an error saying that <code class="literal">perl</code> was not found, manually append the <span class="emphasis"><em>C:\strawberryperl\perl\bin</em></span> directory to the <code class="literal">PATH</code> environment variable by entering this in the command line:</p><a id="I_programlisting_id317430"/><pre class="programlisting">PATH=$PATH:C:\\strawberryperl\\perl\\bin</pre><p>Bash uses the <code class="literal">PATH</code> variable to find executables to run. By appending Strawberry Perl’s binary directory to the <code class="literal">PATH</code> variable, you tell bash where to look for the <code class="literal">perl</code> executable.</p></div><div class="sect1" title="B.3 Perl One-Liners in Windows Bash"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="b_3_perl_one-liners_in_windows_bash">B.3 Perl One-Liners in Windows Bash</h2></div></div></div><p><a id="idx00078" class="indexterm"/><a id="idx00080" class="indexterm"/><a id="idx00235" class="indexterm"/><a id="idx00432" class="indexterm"/><a id="idx00650" class="indexterm"/><a id="idx00653" class="indexterm"/><a id="idx00656" class="indexterm"/><a id="idx00660" class="indexterm"/><a id="idx00666" class="indexterm"/>There are some important differences between bash on Windows and UNIX. The first difference pertains to file paths. Win-bash supports both UNIX-style and Windows-style paths.</p><p>Say you install win-bash in <span class="emphasis"><em>C:\winbash</em></span>. When you start <span class="emphasis"><em>bash.exe</em></span>, it should map the root directory <span class="emphasis"><em>/</em></span> to the current C: drive. To change the root directory to another drive, such as D:, enter <code class="literal">cd d:</code> in the bash shell. To change back to C:, enter <code class="literal">cd c:</code> in the shell. Now you can access a file such as <span class="emphasis"><em>C:\work\report.txt</em></span> via <span class="emphasis"><em>/work/report.txt, c:/work/report.txt</em></span>, or <span class="emphasis"><em>c:\\work\\report.txt</em></span>.</p><p>The best thing about using win-bash is that all of the one-liners in this book should work because you’re running a real shell just like in a UNIX environment! For example, to number the lines in the <span class="emphasis"><em>C:\work\report.txt</em></span> file (one-liner 3.1 on page 17), you can run:</p><a id="I_programlisting_id317594"/><pre class="programlisting">perl -pe '$_ = "$. $_"' C:/work/report.txt</pre><p>Or you can refer to the file as if you were in UNIX:</p><a id="I_programlisting_id317602"/><pre class="programlisting">perl -pe '$_ = "$. $_"' /work/report.txt</pre><p>Or you can use Windows-style paths:</p><a id="I_programlisting_id317609"/><pre class="programlisting">perl -pe '$_ = "$. $_"' C:\\work\\report.txt</pre><p>To avoid using double backslashes, you can single-quote the file path:</p><a id="I_programlisting_id317617"/><pre class="programlisting">perl -pe '$_ = "$. $_"' 'C:\work\report.txt'</pre><p>If the filename has spaces in it, then you always have to quote it. For example, to work with <span class="emphasis"><em>C:\Documents and Settings\Peter\My Documents\report.txt</em></span>, quote the entire path when passing it to a one-liner:</p><a id="I_programlisting_id317630"/><pre class="programlisting">perl -pe '$_ = "$. $_"' 'C:\Documents and Settings\Peter\My Documents\report.txt'</pre><p>Or use the UNIX-style path to the file:</p><a id="I_programlisting_id317637"/><pre class="programlisting">perl -pe '$_ = "$. $_"' '/Documents and Settings/Peter/My Documents/report.txt'</pre><p>Quoting the filename is necessary here because without it Perl thinks you’re passing it a bunch of files rather than a single file with spaces in it.</p></div><div class="sect1" title="B.4 Perl One-Liners in the Windows Command Prompt"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="b_4_perl_one-liners_in_the_windows_comma">B.4 Perl One-Liners in the Windows Command Prompt</h2></div></div></div><p><a id="idx00113" class="indexterm"/><a id="idx00144" class="indexterm"/><a id="idx00212" class="indexterm"/><a id="idx00434" class="indexterm"/><a id="idx00435" class="indexterm"/><a id="idx00459" class="indexterm"/><a id="idx00487" class="indexterm"/><a id="idx00514" class="indexterm"/><a id="idx00562" class="indexterm"/><a id="idx00654" class="indexterm"/><a id="idx00655" class="indexterm"/><a id="idx00662" class="indexterm"/>If, for some reason, you can’t use win-bash as recommended, you can run one-liners through the Windows command prompt (<span class="emphasis"><em>cmd.exe</em></span>). You will need to change the one-liners in this book a bit if you’re running them in the Windows command prompt because of the way Windows parses and treats the command-line arguments. Here’s what to do.</p><p>First, verify that Perl is available from the command prompt. Start <span class="emphasis"><em>cmd.exe</em></span> and enter <code class="literal">perl --version</code> in the command line. If you do this after having installed Strawberry Perl, the command should output the Perl version, and you’re good to go. Otherwise, you’ll have to update the <code class="literal">PATH</code> environment variable with the path to Strawberry Perl’s binary directory:</p><a id="I_programlisting_id317779"/><pre class="programlisting">set PATH=%PATH%;C:\strawberryperl\perl\bin</pre><p>As in UNIX, the <code class="literal">PATH</code> variable tells the command prompt where to look for executables.</p><div class="sect2" title="Converting One-Liners in the Windows Command Prompt"><div class="titlepage"><div><div><h3 class="title" id="converting_one-liners_in_the_windows_com">Converting One-Liners in the Windows Command Prompt</h3></div></div></div><p>Now let’s see how to convert one-liners for the command prompt, beginning with one-liner 2.1 (page 7), which double-spaces a file. In UNIX, you simply run:</p><a id="I_programlisting_id317810"/><pre class="programlisting">perl -pe '$\ = "\n"' <span class="emphasis"><em>file</em></span></pre><p>If you’re running this one-liner in the Windows command prompt, however, you have to make sure that it’s always wrapped in double quotes from the outside and that you’ve escaped any double quotes and special characters inside it. With those changes, the one-liner looks like this on Windows:</p><a id="I_programlisting_id317823"/><pre class="programlisting">perl -pe "$\ = \"\n\"" <span class="emphasis"><em>file</em></span></pre><p>This one-liner is getting ugly quickly, but you can employ a couple of Perl tricks to make it look a little nicer. First, replace double quotes inside the one-liner with the <code class="literal">qq/.../</code> operator, which double-quotes anything between the slashes. Writing <code class="literal">qq/text/</code> in Perl is the same as writing <code class="literal">"text"</code>. Now you rewrite this one-liner like this:</p><a id="I_programlisting_id317846"/><pre class="programlisting">perl -pe "$\ = qq/\n/" <span class="emphasis"><em>file</em></span></pre><p><a id="idx00458" class="indexterm"/><a id="idx00513" class="indexterm"/>That’s a little nicer. You can also change the character that the <code class="literal">qq</code> operator uses to separate its content. For example, the syntax <code class="literal">qq|...|</code> double-quotes anything between the pipes:</p><a id="I_programlisting_id317879"/><pre class="programlisting">perl -pe "$\ = qq|\n|" file</pre><p>You could even use matching parentheses or curly brackets, like this:</p><a id="I_programlisting_id317886"/><pre class="programlisting">perl -pe "$\ = qq(\n)" file</pre><p>or this:</p><a id="I_programlisting_id317894"/><pre class="programlisting">perl -pe "$\ = qq{\n}" file</pre><p>Let’s see how to convert several more one-liners to Windows. How about converting an IP address to an integer (one-liner 4.27 on page 45)? In UNIX you run:</p><a id="I_programlisting_id317903"/><pre class="programlisting">perl -MSocket -le 'print unpack("N", inet_aton("127.0.0.1"))'</pre><p>On Windows, you need to change the quotes outside the one-liner to double quotes and escape the double quotes inside the one-liner:</p><a id="I_programlisting_id317912"/><pre class="programlisting">perl -MSocket -le "print unpack(\"N\", inet_aton(\"127.0.0.1\"))"</pre><p>Or you can use the <code class="literal">qq|...|</code> operator to avoid escaping double quotes inside the one-liner:</p><a id="I_programlisting_id317923"/><pre class="programlisting">perl -MSocket -le "print unpack(qq|N|, inet_aton(qq|127.0.0.1|))"</pre><p>For things that don’t need interpolation, such as the format string <code class="literal">N</code> and the IP address <code class="literal">127.0.0.1</code>, you can also use single quotes instead of double quotes:</p><a id="I_programlisting_id317939"/><pre class="programlisting">perl -MSocket -le "print unpack('N', inet_aton('127.0.0.1'))"</pre><p>Another trick is to use the <code class="literal">q/.../</code> operator, which single-quotes any text between the slashes:</p><a id="I_programlisting_id317951"/><pre class="programlisting">perl -MSocket -le "print unpack(q/N/, inet_aton(q/127.0.0.1/))"</pre><p>Writing <code class="literal">q/N/</code> and <code class="literal">q/127.0.0.1/</code> is the same as writing <code class="literal">'N'</code> and <code class="literal">'127.0.0.1'</code>.</p><p>Let’s convert another one-liner from UNIX to Windows. I’ve expanded it to multiple lines for clarity:</p><a id="I_programlisting_id317980"/><pre class="programlisting">perl -le '
  $ip="127.0.0.1";
  $ip =~ s/(\d+)\.?/sprintf("%02x", $1)/ge;
  print hex($ip)
'</pre><p>Unfortunately, to convert this to Windows, you have to join all of the lines together (making the result less readable), and apply the new quoting rules:</p><a id="I_programlisting_id317989"/><pre class="programlisting">perl -le "$ip=\"127.0.0.1\"; $ip =~ s/(\d+)\.?/sprintf(\"%02x\", $1)/ge; print hex($ip)"</pre><p>You can increase the readability a little by using the <code class="literal">qq</code> operator:</p><a id="I_programlisting_id318001"/><pre class="programlisting">perl -le "$ip=qq|127.0.0.1|; $ip =~ s/(\d+)\.?/sprintf(qq|%02x|, $1)/ge; print hex($ip)"</pre><p>or by using single quotes:</p><a id="I_programlisting_id318009"/><pre class="programlisting">perl -le "$ip='127.0.0.1'; $ip =~ s/(\d+)\.?/sprintf('%02x', $1)/ge; print hex($ip)"</pre></div><div class="sect2" title="Symbol Challenges"><div class="titlepage"><div><div><h3 class="title" id="symbol_challenges">Symbol Challenges</h3></div></div></div><p>You might also run into issues with the caret (<code class="literal">^</code>) symbol in one-liners because the Windows command prompt uses the caret as the escape symbol. To tell Windows to treat the caret symbol literally, you <span class="emphasis"><em>usually</em></span> have to replace each caret with two carets: <code class="literal">^^</code>.</p><p>Let’s look at several examples that simply try to print the <code class="literal">^</code> character. Here’s my first attempt:</p><a id="I_programlisting_id318044"/><pre class="programlisting">perl -e "print \"^\""</pre><p>No output! The <code class="literal">^</code> symbol disappeared. Let’s try <code class="literal">^</code> twice:</p><a id="I_programlisting_id318059"/><pre class="programlisting">perl -e "print \"^^\""</pre><p>This worked! It printed the <code class="literal">^</code> symbol. Now let’s try using single quotes:</p><a id="I_programlisting_id318071"/><pre class="programlisting">perl -e "print '^'"</pre><p><a id="idx00183" class="indexterm"/><a id="idx00236" class="indexterm"/><a id="idx00433" class="indexterm"/><a id="idx00495" class="indexterm"/><a id="idx00657" class="indexterm"/><a id="idx00661" class="indexterm"/>This also worked and printed <code class="literal">^</code>, and I didn’t need to enter <code class="literal">^</code> twice. Using <code class="literal">qq/^/</code> also works:</p><a id="I_programlisting_id318139"/><pre class="programlisting">perl -e "print qq/^/"</pre><p>As you can see, running one-liners on Windows can be tricky because there are no uniform parsing rules for the command-line arguments. You may run into similar issues when writing one-liners with the <code class="literal">%</code>, <code class="literal">&amp;</code>, <code class="literal">&lt;</code>, <code class="literal">&gt;</code>, and <code class="literal">|</code> symbols. If so, try preceding them with the <code class="literal">^</code> escape character so that <code class="literal">%</code> becomes <code class="literal">^%</code>, <code class="literal">&amp;</code> becomes <code class="literal">^&amp;</code>, <code class="literal">&lt;</code> becomes <code class="literal">^&lt;</code>, <code class="literal">&gt;</code> becomes <code class="literal">^&gt;</code>, and <code class="literal">|</code> becomes <code class="literal">^|</code>. Or try wrapping them in the <code class="literal">qq</code> operator, as I discussed previously. (Better yet, install win-bash and use the one-liners through it to avoid all these issues.)</p></div><div class="sect2" title="Windows File Paths"><div class="titlepage"><div><div><h3 class="title" id="windows_file_paths">Windows File Paths</h3></div></div></div><p>When using the Windows command prompt, you can pass filenames to one-liners in several different ways. For example, to access the file <span class="emphasis"><em>C:\work\wrong-spacing.txt</em></span>, you can enter:</p><a id="I_programlisting_id318230"/><pre class="programlisting">perl -pe "$\ = qq{\n}" C:\work\wrong-spacing.txt</pre><p>Or you can reverse the slashes:</p><a id="I_programlisting_id318238"/><pre class="programlisting">perl -pe "$\ = qq{\n}" C:/work/wrong-spacing.txt</pre><p>If the filename contains spaces, you have to quote the path:</p><a id="I_programlisting_id318245"/><pre class="programlisting">perl -pe "$\ = qq{\n}" "C:\Documents and Settings\wrong-spacing.txt"</pre><p>For more Windows Perl usage hints, see the Win32 Perl documentation at <span class="emphasis"><em><a class="ulink" href="http://perldoc.perl.org/perlwin32.html" target="_top">http://perldoc.perl.org/perlwin32.html</a></em></span>.</p></div></div><div class="sect1" title="B.5 Perl One-Liners in PowerShell"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="b_5_perl_one-liners_in_powershell">B.5 Perl One-Liners in PowerShell</h2></div></div></div><p>Running one-liners in PowerShell is a bit different than running them in the command prompt (<span class="emphasis"><em>cmd.exe</em></span>). The main difference is that PowerShell is a modern shell implementation with different parsing rules than the command prompt. In this section, I’ll show you how to run Perl one-liners in PowerShell.</p><p>First, you need to verify that Perl works in the PowerShell environment. Run <code class="literal">perl --version</code> in the PowerShell. If the command outputs the Perl version, then Perl is available, and you should be able to run the one-liners. Otherwise, update the <code class="literal">Path</code> environment variable and append Strawberry Perl’s binary directory to it by running the following command in PowerShell:</p><a id="I_programlisting_id318294"/><pre class="programlisting">$env:Path += ";C:\strawberryperl\perl\bin"</pre><p><a id="idx00211" class="indexterm"/><a id="idx00658" class="indexterm"/>The <code class="literal">Path</code> variable tells PowerShell where to look for executables, so when you run <code class="literal">perl</code>, it searches all the directories (separated by the <code class="literal">;</code> character) for <span class="emphasis"><em>perl.exe</em></span>.</p><div class="sect2" title="Converting One-Liners in PowerShell"><div class="titlepage"><div><div><h3 class="title" id="converting_one-liners_in_powershell">Converting One-Liners in PowerShell</h3></div></div></div><p>Consider one-liner 2.1 (page 7), which double-spaces a file. In UNIX, the one-liner looks like this:</p><a id="I_programlisting_id318356"/><pre class="programlisting">perl -pe '$\ = "\n"' <span class="emphasis"><em>file</em></span></pre><p>To make this one-liner work in PowerShell, you have to change three things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Escape the <code class="literal">$</code> symbol, which PowerShell uses for variables, by adding the <code class="literal">`</code> character (backtick) before it: <code class="literal">`$</code>.</p></li><li class="listitem"><p>As with the <span class="emphasis"><em>cmd.exe</em></span> command prompt, make sure double quotes are used on the outside of the one-liner.</p></li><li class="listitem"><p>Use the <code class="literal">qq/.../</code> operator for the double quotes inside the one-liner, as explained in “Converting One-Liners in the Windows Command Prompt” on page 108. You can’t just escape the double quotes with a backslash as with the command prompt, however; you must use the <code class="literal">qq/.../</code> operator.</p></li></ul></div><p>When you put it all together, the PowerShell version of this one-liner becomes:</p><a id="I_programlisting_id318416"/><pre class="programlisting">perl -pe "`$\ = qq/\n/" file</pre><p>To specify full paths to files, use Windows-style paths. For example, to reference a file at <span class="emphasis"><em>C:\work\wrong-spacing.txt</em></span>, enter that path directly after the one-liner:</p><a id="I_programlisting_id318429"/><pre class="programlisting">perl -pe "`$\ = qq/\n/" C:\work\wrong-spacing.txt</pre><p>If the filename or file path contains spaces, enter it like this, with double quotes around it:</p><a id="I_programlisting_id318437"/><pre class="programlisting">perl -pe "`$\ = qq/\n/" "C:\Documents and Settings\wrong-spacing.txt"</pre><p>Now for another version of the same one-liner. In UNIX the one-liner looks like this:</p><a id="I_programlisting_id318444"/><pre class="programlisting">perl -pe '$_ .= "\n" unless /^$/' <span class="emphasis"><em>file</em></span></pre><p>But in PowerShell you have to change the outer single quotes to double quotes, escape the <code class="literal">$</code> symbol, and change double quotes to <code class="literal">qq/.../</code> inside the one-liner:</p><a id="I_programlisting_id318462"/><pre class="programlisting">perl -pe "`$_ .= qq/\n/ unless /^`$/" <span class="emphasis"><em>file</em></span></pre><p>Now let’s look at the one-liner that numbers the non-empty lines in a file (one-liner 3.2 on page 18):</p><a id="I_programlisting_id318473"/><pre class="programlisting">perl -pe '$_ = ++$x." $_" if /./'</pre><p>When converted to PowerShell, the one-liner looks like this:</p><a id="I_programlisting_id318481"/><pre class="programlisting">perl -pe "`$_ = ++`$a.qq/ `$_/ if /./"</pre><p>How about the artistic one-liner that checks if a number is prime (one-liner 4.1 on page 29)?</p><a id="I_programlisting_id318490"/><pre class="programlisting">perl -lne '(1x$_) !~ /^1?$|^(11+?)\1+$/ &amp;&amp; print "$_ is prime"'</pre><p>In PowerShell, the one-liner looks like this:</p><a id="I_programlisting_id318498"/><pre class="programlisting">perl -lne "(1x`$_) !~ /^1?`$|^(11+?)\1+`$/ &amp;&amp; print qq/`$_ is prime/"</pre><p>Remember the one-liner on page 46 that converts IPs to integers? Here’s how it looks in UNIX:</p><a id="I_programlisting_id318506"/><pre class="programlisting">perl -le '
  $ip="127.0.0.1";
  $ip =~ s/(\d+)\.?/sprintf("%02x", $1)/ge;
  print hex($ip)
'</pre><p>And here’s the same one-liner for PowerShell:</p><a id="I_programlisting_id318515"/><pre class="programlisting">perl -le "
  `$ip=qq|127.0.0.1|;
  `$ip =~ s/(\d+)\.?/sprintf(qq|%02x|, `$1)/ge;
  print hex(`$ip)
"</pre></div><div class="sect2" title="One-Liners in PowerShell 3.0+"><div class="titlepage"><div><div><h3 class="title" id="one-liners_in_powershell_3_0plus">One-Liners in PowerShell 3.0+</h3></div></div></div><p>If you’re running PowerShell version 3.0 or later, you can use the <code class="literal">--%</code> escape sequence to prevent PowerShell from doing any additional parsing.</p><p>To find out which PowerShell version you’re running, enter <code class="literal">$PSVersionTable.PSVersion</code> in the shell. It should output a table like this:</p><a id="I_programlisting_id318543"/><pre class="programlisting">PS C:\Users\Administrator&gt; $PSVersionTable.PSVersion
Major  Minor  Build  Revision
-----  -----  -----  --------
3      0      -1     -1</pre><p>This table shows that you’re running PowerShell version 3.0, which has the <code class="literal">--%</code> escape sequence. (Older versions of PowerShell don’t have this sequence, in which case you have to use the tricks I described earlier.)</p><p>When using the <code class="literal">--%</code> escape sequence, you don’t have to escape the <code class="literal">$</code> symbol. It also lets you escape the double quotes with backslashes inside the one-liner. For example, here’s how the one-liner that double-spaces lines looks with the <code class="literal">--%</code> escape sequence:</p><a id="I_programlisting_id318573"/><pre class="programlisting">perl --% -pe "$\ = \"\n\""</pre><p>You can also use the <code class="literal">qq/.../</code> operator to avoid escaping double quotes inside the one-liner:</p><a id="I_programlisting_id318584"/><pre class="programlisting">perl --% -pe "$\ = qq/\n/"</pre><p>Here’s how you can write the other version of the same one-liner in PowerShell 3.0 and later:</p><a id="I_programlisting_id318593"/><pre class="programlisting">perl --% -pe "$_ .= \"\n\" unless /^$/" <span class="emphasis"><em>file</em></span></pre><p>And this is how the one-liner that numbers the lines looks:</p><a id="I_programlisting_id318603"/><pre class="programlisting">perl --% -pe "$_ = ++$a.qq/ $_/ if /./"</pre><p>Here’s the one-liner that uses a regular expression to see if a number is prime:</p><a id="I_programlisting_id318611"/><pre class="programlisting">perl --% -lne "(1x$_) !~ /^1?$|^(11+?)\1+$/ &amp;&amp; print \"$_ is prime\""</pre><p>And here’s the one-liner that converts IPs to integers:</p><a id="I_programlisting_id318619"/><pre class="programlisting">perl --% -le "
  $ip=\"127.0.0.1\";
  $ip =~ s/(\d+)\.?/sprintf(\"%02x\", $1)/ge;
  print hex($ip)
"</pre><p>As you can see, running one-liners in PowerShell is quite tricky and requires several workarounds. Again, I recommend that you install win-bash as described in “Bash on Windows” on page 106 to avoid having to implement these workarounds.</p></div></div></section></body></html>