- en: Chapter 4. Wireless Networks Made Easy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Wireless Networks Made Easy](httpatomoreillycomsourcenostarchimages2127149.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It’s rather tempting to say that on BSD—and OpenBSD, in particular—there’s no
    need to “make wireless networking easy” because it already is. Getting a wireless
    network running isn’t very different from getting a wired one up and running,
    but there are some issues that turn up simply because we’re dealing with radio
    waves and not wires. We’ll look briefly at some of the issues before moving on
    to the practical steps involved in creating a usable setup.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have covered the basics of getting a wireless network up and running,
    we’ll turn to some of the options for making your wireless network more interesting
    and harder to break.
  prefs: []
  type: TYPE_NORMAL
- en: A Little IEEE 802.11 Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting up any network interface, in principle, is a two-step process: You
    establish a link, and then you move on to configuring the interface for TCP/IP
    traffic.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of wired Ethernet-type interfaces, establishing the link usually
    consists of plugging in a cable and seeing the link indicator light up. However,
    some interfaces require extra steps. Networking over dial-up connections, for
    example, requires telephony steps, such as dialing a number to get a carrier signal.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of IEEE 802.11–style wireless networks, getting the carrier signal
    involves quite a few steps at the lowest level. First, you need to select the
    proper channel in the assigned frequency spectrum. Once you find a signal, you
    need to set a few link-level network identification parameters. Finally, if the
    station you want to link to uses some form of link-level encryption, you need
    to set the correct kind and probably negotiate some additional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, on OpenBSD systems, all configuration of wireless network devices
    happens via `ifconfig` commands and options, as with any other network interface.
    While most network configuration happens via `ifconfig` on other BSDs, too, on
    some systems, specific features require other configu-ration.^([[20](#ftn.ch04fn01)])
    Still, because we’re introducing wireless networks here, we need to look at security
    at various levels in the networking stack from this new perspective.
  prefs: []
  type: TYPE_NORMAL
- en: There are basically three kinds of popular and simple IEEE 802.11 privacy mechanisms,
    and we’ll discuss them briefly over the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*For a more complete overview of issues surrounding security in wireless networks,
    see Professor Kjell Jørgen Hole’s articles and slides at* [http://www.kjhole.com/](http://www.kjhole.com/)
    *and* [http://www.nowires.org/](http://www.nowires.org/)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: MAC Address Filtering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The short version of the story about PF and MAC address filtering is that we
    don’t do it. A number of consumer-grade, off-the-shelf wireless access points
    offer MAC address filtering, but contrary to common belief, they don’t really
    add much security. The marketing succeeds largely because most consumers are unaware
    that it’s possible to change the MAC address of essentially any wireless network
    adapter on the market today.^([[21](#ftn.ch04fn02)])
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*If you really want to try MAC address filtering, you could look into using
    the `bridge(4)` facility and the bridge-related rule options in `ifconfig(8)`
    on OpenBSD 4.7 and later. We’ll look at bridges and some of the more useful ways
    to use them with packet filtering in [Chapter 5](ch05.html "Chapter 5. Bigger
    or Trickier Networks"). Note that you can use the bridge filtering without really
    running a bridge by just adding one interface to the bridge.*'
  prefs: []
  type: TYPE_NORMAL
- en: WEP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One consequence of using radio waves instead of wires to move data is that it’s
    comparatively easier for outsiders to capture data in transit over radio waves.
    The designers of the 802.11 family of wireless network standards seem to have
    been aware of this fact, and they came up with a solution that they went on to
    market under the name *Wired Equivalent Privacy*, or *WEP*.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the WEP designers came up with their wired equivalent encryption
    without actually reading up on recent research or consulting active researchers
    in the field. So the link-level encryption scheme they recommended is considered
    a pretty primitive homebrew among cryptography professionals. It was no great
    surprise when WEP encryption was reverse-engineered and cracked within a few months
    after the first products were released.
  prefs: []
  type: TYPE_NORMAL
- en: Even though you can download free tools to descramble WEP-encoded traffic in
    a matter of minutes, for a variety of reasons, WEP is still widely supported and
    used. Essentially, all IEEE 802.11 equipment available today has support for at
    least WEP, and a surprising number offer MAC address filtering, too.
  prefs: []
  type: TYPE_NORMAL
- en: You should consider network traffic protected only by WEP to be just marginally
    more secure than data broadcast in the clear. Then again, the token effort needed
    to crack into a WEP network may be sufficient to deter lazy and unsophisticated
    attackers.
  prefs: []
  type: TYPE_NORMAL
- en: WPA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It dawned on the 802.11 designers fairly quickly that their WEP system wasn’t
    quite what it was cracked up to be, so they came up with a revised and slightly
    more comprehensive solution called *Wi-Fi Protected Access*, or *WPA*.
  prefs: []
  type: TYPE_NORMAL
- en: WPA looks better than WEP, at least on paper, but the specification is complicated
    enough that its widespread implementation was delayed. In addition, WPA has attracted
    its share of criticism over design issues and bugs that have produced occasional
    interoperability problems. Combined with the familiar issues of access to documentation
    and hardware, free software support varies. Most free systems have WPA support,
    and even though you may find that it’s not available for all devices, the situation
    has been improving over time. If your project specification includes WPA, look
    carefully at your operating system and driver documentation.
  prefs: []
  type: TYPE_NORMAL
- en: And, of course, it goes almost without saying that you’ll need further security
    measures, such as SSH or SSL encryption, to maintain any significant level of
    confidentiality for your data stream.
  prefs: []
  type: TYPE_NORMAL
- en: The Right Hardware for the Task
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Picking the right hardware is not necessarily a daunting task. On a BSD system,
    the following simple command is all you need to enter to see a listing of all
    manual pages with the word *wireless* in their subject lines.^([[22](#ftn.ch04fn03)])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Even on a freshly installed system, this command will give you a complete list
    of all wireless network drivers available in the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to read the driver manual pages and compare the lists of compatible
    devices with what is available as parts or built into the systems you’re considering.
    Take some time to think through your specific requirements. For test purposes,
    low-end `rum` or `ural` USB dongles (or the newer `urtwn` and `run`) will work
    and are quite convenient. Later, when you’re about to build a more permanent infrastructure,
    you may want to look into higher-end gear, although you may find that the inexpensive
    test gear will perform quite well. Some wireless chipsets require firmware that
    for legal reasons can’t be distributed on the OpenBSD install media. In most cases,
    the *fw_update* script will be able to fetch the required firmware on first boot
    after a successful install, as long as a network connection is available. If you
    install the units in an already configured system, you can try running *fw_update*
    manually. You may also want to read [Appendix B](apb.html "Appendix B. A Note
    On Hardware Support") of this book for some further discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up a Simple Wireless Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For our first wireless network, it makes sense to use the basic gateway configuration
    from the previous chapter as our starting point. In your network design, it’s
    likely that the wireless network isn’t directly attached to the Internet at large
    but that the wireless network will require a gateway of some sort. For that reason,
    it makes sense to reuse the working gateway setup for this wireless access point,
    with some minor modifications introduced over the next few paragraphs. After all,
    doing so is more convenient than starting a new configuration from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*We’re in infrastructure-building mode here, and we’ll be setting up the access
    point first. If you prefer to look at the client setup first, see [The Client
    Side](ch04.html#client_side "The Client Side").*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to make sure you have a supported card and to check that
    the driver loads and initializes the card properly. The boot-time system messages
    scroll by on the console, but they’re also recorded in the file */var/run/dmesg.boot*.
    You can view the file itself or use the `dmesg` command to see these messages.
    With a successfully configured PCI card, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If the interface you want to configure is a hot-pluggable type, such as a USB
    or PC Card device, you can see the kernel messages by viewing the */var/log/messages*
    file—for example, by running `tail -f` on the file before you plug in the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to configure the interface: first to enable the link and, finally,
    to configure the system for TCP/IP. You can do this from the command line, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command does several things at once. It configures the `ral0` interface,
    enables the interface with the `up` parameter, and specifies that the interface
    is an access point for a wireless network with `mediaopt hostap`. Then, it explicitly
    sets the operating mode to `11g` and the channel to `11`. Finally, it uses the
    `nwid` parameter to set the network name to `unwiredbsd`, with the WEP key (`nwkey`)
    set to the hexadecimal string `0x1deadbeef9`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `ifconfig` to check that the command successfully configured the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note the contents of the `media` and `ieee80211` lines. The information displayed
    here should match what you entered on the `ifconfig` command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the link part of your wireless network operational, you can assign an
    IP address to the interface. First, set an IPv4 address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting an IPv6 is equally straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'On OpenBSD, you can combine both steps into one by creating a */etc/hostname.ral0*
    file, roughly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then, run **`sh /etc/netstart ral0`** (as root) or wait patiently for your next
    boot to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the preceding configuration is divided over several lines. The first
    line generates an `ifconfig` command that sets up the interface with the correct
    parameters for the physical wireless network. The second line generates the command
    that sets the IPv4 address after the first command completes, followed by setting
    an IPv6 address for a dual-stack configuration. Because this is our access point,
    we set the channel explicitly, and we enable weak WEP encryption by setting the
    `nwkey` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'On NetBSD, you can normally combine all of these parameters in one *rc.conf*
    setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'FreeBSD 8 and newer versions take a slightly different approach, tying wireless
    network devices to the unified `wlan(4)` driver. Depending on your kernel configuration,
    you may need to add the relevant module load lines to */boot/loader.conf*. On
    one of my test systems, */boot/loader.conf* looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With the relevant modules loaded, setup is a multicommand affair, best handled
    by a *start_if.if* file for your wireless network. Here is an example of an */etc/start_if.rum0*
    file for a WEP access point on FreeBSD 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After a successful configuration, your `ifconfig` output should show both the
    physical interface and the `wlan` interface up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The line `status: running` means that you’re up and running, at least on the
    link level.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Be sure to check the most up-to-date `ifconfig` man page for other options
    that may be more appropriate for your configuration.*'
  prefs: []
  type: TYPE_NORMAL
- en: An OpenBSD WPA Access Point
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WPA support was introduced in OpenBSD 4.4, with extensions to most wireless
    network drivers, and all basic WPA keying functionality was merged into `ifconfig(8)`
    in OpenBSD 4.9.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*There may still be wireless network drivers that don’t have WPA support, so
    check the driver’s man page to see whether WPA is supported before you try to
    configure your network to use it. You can combine 802.1*x *key management with
    an external authentication server for “enterprise” mode via the `security/wpa_supplicant`
    package, but we’ll stick to the simpler preshared key setup for our purposes.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The procedure for setting up an access point with WPA is quite similar to the
    one we followed for WEP. For a WPA setup with a preshared key (sometimes referred
    to as a *network password*), you would typically write a *hostname.if* file like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re already running the WEP setup described earlier, disable those settings
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, enable the new settings with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check that the access point is up and running with `ifconfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `status: active` indication and that the WPA options we didn’t set
    explicitly are shown with their sensible default values.'
  prefs: []
  type: TYPE_NORMAL
- en: A FreeBSD WPA Access Point
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Moving from the WEP access point we configured earlier to a somewhat safer
    WPA setup is straightforward. WPA support on FreeBSD comes in the form of `hostapd`
    (a program that is somewhat similar to OpenBSD’s `hostapd` but not identical).
    We start by editing the */etc/start_if.rum0* file to remove the authentication
    information. The edited file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the enable line for `hostapd` in */etc/rc.conf*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, `hostapd` will need some configuration of its own, in */etc/ hostapd.conf*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, the interface specification is rather self-explanatory, while the `debug`
    value is set to produce minimal messages. The range is `0` through `4`, where
    `0` is no debug messages at all. You shouldn’t need to change the `ctrl_interface*`
    settings unless you’re developing `hostapd`. The first of the next five lines
    sets the network identifier. The subsequent lines enable WPA and set the passphrase.
    The final two lines specify accepted key-management algorithms and encryption
    schemes. (For the finer details and updates, see the `hostapd(8)` and `hostapd.conf(5)`
    man pages.)
  prefs: []
  type: TYPE_NORMAL
- en: 'After a successful configuration (running `sudo /etc/rc.d/hostapd force-start`
    comes to mind), `ifconfig` should produce output about the two interfaces similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The line `status: running` means that you’re up and running, at least on the
    link level.'
  prefs: []
  type: TYPE_NORMAL
- en: The Access Point’s PF Rule Set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the interfaces configured, it’s time to start configuring the access point
    as a packet-filtering gateway. You can start by copying the basic gateway setup
    from [Chapter 3](ch03.html "Chapter 3. Into the Real World"). Enable gatewaying
    via the appropriate entries in the access point’s *sysctl.conf* or *rc.conf* file
    and then copy across the *pf.conf* file. Depending on the parts of the previous
    chapter that were most useful to you, the *pf.conf* file may look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re running a PF version equal to OpenBSD 4.6 or earlier, the `match`
    rule with `nat-to` instead becomes this (assuming the external interface has one
    address, dynamically assigned):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference that’s strictly necessary for your access point to work
    is the definition of `int_if`. You must change the definition of `int_if` to match
    the wireless interface. In our example, this means the line should now read as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: More than likely, you’ll also want to set up `dhcpd` to serve addresses and
    other relevant network information to IPv4 clients after they’ve associated with
    your access point. For IPv6 networks, you probably want to set up `rtadvd` (or
    even a DHCP6 daemon) to aid your IPv6 clients in their autoconfiguration. Setting
    up `dhcpd` and `rtadvd` is fairly straightforward if you read the man pages.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all there is to it. This configuration gives you a functional BSD access
    point, with at least token security (actually more like a *Keep Out!* sign) via
    WEP encryption or a slightly more robust link-level encryption with WPA. If you
    need to support FTP, copy the `ftp-proxy` configuration from the machine you set
    up in [Chapter 3](ch03.html "Chapter 3. Into the Real World") and make changes
    similar to those you made for the rest of the rule set.
  prefs: []
  type: TYPE_NORMAL
- en: Access Points with Three or More Interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If your network design dictates that your access point is also the gateway
    for a wired local network, or even several wireless networks, you need to make
    some minor changes to your rule set. Instead of just changing the value of the
    `int_if` macro, you might want to add another (descriptive) definition for the
    wireless interface, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Your wireless interfaces are likely to be on separate subnets, so it might
    be useful to have a separate rule for each of them to handle any IPv4 NAT configuration.
    Here’s an example for OpenBSD 4.7 and newer systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s one on pre–OpenBSD 4.7 PF versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your policy, you might also want to adjust your `localnet` definition,
    or at least include `$air_if` in your `pass` rules where appropriate. And once
    again, if you need to support FTP, a separate pass with divert or redirection
    for the wireless network to `ftp-proxy` may be in order.
  prefs: []
  type: TYPE_NORMAL
- en: Handling IPSec, VPN Solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can set up *virtual private networks (VPNs)* using built-in IPsec tools,
    OpenSSH, or other tools. However, due to the perceived poor security profile of
    wireless networks in general or for other reasons, you’re likely to want to set
    up some additional security.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options fall roughly into three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '****SSH****. If your VPN is based on SSH tunnels, the baseline rule set already
    contains all the filtering you need. Your tunneled traffic will be indistinguishable
    from other SSH traffic to the packet filter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****IPsec with UDP key exchange (IKE/ISAKMP)****. Several IPsec variants depend
    critically on key exchange via `proto udp port 500` and use `proto udp port 4500`
    for *NAT Traversal (NAT-T)*. You need to let this traffic through in order to
    let the flows become established. Almost all implementations also depend critically
    on letting ESP protocol traffic (protocol number 50) pass between the hosts with
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '****Filtering on IPsec encapsulation interfaces****. With a properly configured
    IPsec setup, you can set up PF to filter on the encapsulation interface `enc0`
    itself with the following:^([[23](#ftn.ch04fn04)])'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See [Appendix A](apa.html "Appendix A. Resources") for references to some of
    the more useful literature on the subject.
  prefs: []
  type: TYPE_NORMAL
- en: The Client Side
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As long as you have BSD clients, setup is extremely easy. The steps involved
    in connecting a BSD machine to a wireless network are quite similar to the ones
    we just went through to set up a wireless access point. On OpenBSD, the configuration
    centers on the *hostname.if* file for the wireless interface. On FreeBSD, the
    configuration centers on *rc.conf* but will most likely involve a few other files,
    depending on your exact configuration.
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting with the OpenBSD case, in order to connect to the WEP access point
    we just configured, your OpenBSD clients need a *hostname.if* (for example, */etc/hostname.ral0*)
    configuration file with these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first line sets the link-level parameters in more detail than usually required.
    Only `up` and the `nwid` and `nwkey` parameters are strictly necessary. In almost
    all cases, the driver will associate with the access point on the appropriate
    channel and in the best available mode. The second line calls for a DHCP configuration
    and, in practice, causes the system to run a `dhclient` command to retrieve TCP/IP
    configuration information. The final line invokes `rtsol(8)` to initiate IPv6
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you choose to go with the WPA configuration, the file will look like this
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Again, the first line sets the link-level parameters, where the crucial ones
    are the network selection and encryption parameters `nwid` and `wpakey`. You can
    try omitting the `mode` and `chan` parameters; in almost all cases, the driver
    will associate with the access point on the appropriate channel and in the best
    available mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to try out the configuration commands from the command line before
    committing the configuration to your */etc/hostname.if* file, the command to set
    up a client for the WEP network is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ifconfig` command should complete without any output. You can then use
    `ifconfig` to check that the interface was successfully configured. The output
    should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `ieee80211:` line displays the network name and channel, along
    with a few other parameters. The information displayed here should match what
    you entered on the `ifconfig` command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the command to configure your OpenBSD client to connect to the WPA
    network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should complete without any output. If you use `ifconfig` again
    to check the interface status, the output will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Check that the `ieee80211:` line displays the correct network name and sensible
    WPA parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are satisfied that the interface is configured at the link level,
    use the `dhclient` command to configure the interface for TCP/IP, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dhclient` command should print a summary of its dialogue with the DHCP
    server that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize the interface for IPv6, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `rtsol` command normally completes without any messages. Check the interface
    configuration with `ifconfig` to see that the interface did in fact receive an
    IPv6 configuration.
  prefs: []
  type: TYPE_NORMAL
- en: FreeBSD Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On FreeBSD, you may need to do a bit more work than is necessary with OpenBSD.
    Depending on your kernel configuration, you may need to add the relevant module
    load lines to */boot/loader.conf*. On one of my test systems, */boot/loader.conf*
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With the relevant modules loaded, you can join the WEP network we configured
    earlier by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, issue this command to get an IPv4 configuration for the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize the interface for IPv6, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `rtsol` command normally completes without any messages. Check the interface
    configuration with `ifconfig` to see that the interface did in fact receive an
    IPv6 configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more permanent configuration, create a *start_if.rum0* file (replace
    *rum0* with the name of the physical interface if it differs) with content like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to join the WPA network, you need to set up `wpa_supplicant` and
    change your network interface settings slightly. For the WPA access point, connect
    with the following configuration in your *start_if.rum0* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need an */etc/wpa_supplicant.conf* file that contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Finally, add a second `ifconfig_wlan0` line in *rc.conf* to ensure that `dhclient`
    runs correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'For the IPv6 configuration, add the following line to *rc.conf*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Other WPA networks may require additional options. After a successful configuration,
    the `ifconfig` output should display something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Guarding Your Wireless Network with authpf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Security professionals tend to agree that even though WEP encryption offers
    little protection, it’s just barely enough to signal to would-be attackers that
    you don’t intend to let all and sundry use your network resources. Using WPA increases
    security significantly, at the cost of some complexity in contexts that require
    the “enterprise”-grade options.
  prefs: []
  type: TYPE_NORMAL
- en: The configurations we’ve built so far in this chapter are functional. Both the
    WEP and WPA configurations will let all reasonably configured wireless clients
    connect, and that may be a problem in itself because that configuration doesn’t
    have any real support built in for letting you decide who uses your network.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, MAC address filtering is not really a solid defense against
    attackers because changing a MAC address is just too easy. The Open-BSD developers
    chose a radically different approach to this problem when they introduced `authpf`
    in OpenBSD version 3.1\. Instead of tying access to a hardware identifier, such
    as the network card’s MAC address, they decided that the robust and highly flexible
    user authentication mechanisms already in place were more appropriate for the
    task. The user shell `authpf` lets the system load PF rules on a per-user basis,
    effectively deciding which user gets to do what.
  prefs: []
  type: TYPE_NORMAL
- en: To use `authpf`, you create users with the `authpf` program as their shell.
    In order to get network access, the user logs in to the gateway using SSH. Once
    the user successfully completes SSH authentication, `authpf` loads the rules you
    have defined for the user or the relevant class of users.
  prefs: []
  type: TYPE_NORMAL
- en: These rules, which usually are written to apply only to the IP address the user
    logged in from, stay loaded and in force for as long as the user stays logged
    in via the SSH connection. Once the SSH session is terminated, the rules are unloaded,
    and in most scenarios, all non-SSH traffic from the user’s IP address is denied.
    With a reasonable setup, only traffic originated by authenticated users will be
    let through.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*On OpenBSD, `authpf` is one of the login classes offered by default, as you’ll
    notice the next time you create a user with `adduser`.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For systems where the `authpf` login class isn’t available by default, you
    may need to add the following lines to your */etc/login.conf* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The next couple of sections contain a few examples that may or may not fit your
    situation directly but that I hope will give you ideas you can use.
  prefs: []
  type: TYPE_NORMAL
- en: A Basic Authenticating Gateway
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting up an authenticating gateway with `authpf` involves creating and maintaining
    a few files besides your basic *pf.conf*. The main addition is *authpf.rules*.
    The other files are fairly static entities that you won’t be spending much time
    on once they’ve been created.
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating an empty */etc/authpf/authpf.conf* file. This file needs to
    be there in order for `authpf` to work, but it doesn’t actually need any content,
    so creating an empty file with touch is appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other relevant bits of */etc/pf.conf* follow. First, here are the interface
    macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, if you define a table called `<authpf_users>`, `authpf` will add
    the IP addresses of authenticated users to the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to run NAT, the rules that take care of the translation could just
    as easily go in *authpf.rules*, but keeping them in the *pf.conf* file doesn’t
    hurt in a simple setup like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s pre–OpenBSD 4.7 syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create the `authpf` anchor, where rules from *authpf.rules* are loaded
    once the user authenticates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'For pre–OpenBSD 4.7 `authpf` versions, several anchors were required, so the
    corresponding section would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This brings us to the end of the required parts of a *pf.conf* file for an `authpf`
    setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the filtering part, we start with the block all default and then add the
    `pass` rules we need. The only essential item at this point is to let SSH traffic
    pass on the internal network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: From here on out, it really is up to you. Do you want to let your clients have
    name resolution before they authenticate? If so, put the `pass` rules for the
    TCP and UDP service domain in your *pf.conf* file, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a relatively simple and egalitarian setup, you could include the rest of
    our baseline rule set, changing the `pass` rules to allow traffic from the addresses
    in the `<authpf_users>` table, rather than any address in your local network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'For a more differentiated setup, you could put the rest of your rule set in
    */etc/authpf/authpf.rules* or per-user rules in customized *authpf.rules* files
    in each user’s directory under */etc/authpf/users/*. If your users generally need
    some protection, your general */etc/authpf/authpf.rules* could have content like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The macro `user_ip` is built into `authpf` and expands to the IP address from
    which the user authenticated. These rules will apply to any user who completes
    authentication at your gateway.
  prefs: []
  type: TYPE_NORMAL
- en: 'A nice and relatively easy addition to implement is special-case rules for
    users with different requirements than your general user population. If an *authpf.rules*
    file exists in the user’s directory under */etc/authpf/users/*, the rules in that
    file will be loaded for the user. This means that your naive user Peter who only
    needs to surf the Web and have access to a service that runs on a high port on
    a specific machine could get what he needs with a */etc/ authpf/users/peter/authpf.rules*
    file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, Peter’s colleague Christina runs OpenBSD and generally knows
    what she’s doing, even if she sometimes generates traffic to and from odd ports.
    You could give her free rein by putting this in */etc/authpf/users/christina/authpf.rules*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This means Christina can do pretty much anything she likes over TCP/IP as long
    as she authenticates from her OpenBSD machines.
  prefs: []
  type: TYPE_NORMAL
- en: Wide Open but Actually Shut
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some settings, it makes sense to set up your network to be open and unencrypted
    at the link level, while enforcing some restrictions via `authpf`. The next example
    is very similar to Wi-Fi zones you may encounter in airports or other public spaces,
    where anyone can associate to the access points and get an IP address, but any
    attempt at accessing the Web will be redirected to one specific Web page until
    the user has cleared some sort of authentication.^([[24](#ftn.ch04fn05)])
  prefs: []
  type: TYPE_NORMAL
- en: 'This *pf.conf* file is again built on our baseline, with two important additions
    to the basic `authpf` setup—a macro and a redirection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `auth_web` macro and the redirection make sure all Web traffic from addresses
    that are not in the `<authpf_users>` table leads all nonauthenticated users to
    a specific address. At that address, you set up a Web server that serves up whatever
    you need. This could range from a single page with instructions on whom to contact
    in order to get access to the network all the way up to a system that accepts
    credit cards and handles user creation.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in this setup, name resolution will work, but all surfing attempts
    will end up at the `auth_web` address. Once the users clear authentication, you
    can add general rules or user-specific ones to the *authpf.rules* files as appropriate
    for your situation.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[20](#ch04fn01)]) On some systems, the older, device-specific programs, such
    as `wicontrol` and `ancontrol,` are still around, but for the most part, they
    are deprecated and have long been replaced with `ifconfig` functionality. On OpenBSD,
    the consolidation into `ifconfig` has been completed.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[21](#ch04fn02)]) A quick man page lookup on OpenBSD will tell you that the
    command to change the MAC address for the interface `rum0` is simply `ifconfig
    rum0 lladdr 00:ba:ad:f0:0d:11`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[22](#ch04fn03)]) In addition, it’s possible to look up man pages on the
    Web. Check *[http://www.openbsd.org/](http://www.openbsd.org/)* and the other
    project websites. They offer keyword-based man page searching.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[23](#ch04fn04)]) In OpenBSD 4.8, the encapsulation interface became a cloneable
    interface, and you can configure several separate `enc` interfaces. All `enc`
    interfaces become members of the `enc` interface group.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[24](#ch04fn05)]) Thanks to Vegard Engen for the idea and for showing me
    his configuration, which is preserved here in spirit, if not in all its details.
  prefs: []
  type: TYPE_NORMAL
