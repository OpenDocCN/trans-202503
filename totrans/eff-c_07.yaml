- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CHARACTERS
    AND STRINGS</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">字符与字符串</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Strings are such an important and useful data type that nearly every programming
    language implements them in some form. Often used to represent text, strings constitute
    most of the data exchanged between an end user and a program, including text input
    fields, command line arguments, environment variables, and console input.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是一个非常重要且有用的数据类型，几乎所有的编程语言都会以某种形式实现它。字符串通常用来表示文本，是用户与程序之间交换数据的大多数内容，包括文本输入字段、命令行参数、环境变量和控制台输入。
- en: 'In C, the string data type is modeled on the idea of a formal string (Hopcroft
    and Ullman 1979):'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，字符串数据类型是基于正式字符串的概念建模的（Hopcroft 和 Ullman 1979）：
- en: Let Σ be a non-empty finite set of characters, called the alphabet. A string
    over Σ is any finite sequence of characters from Σ. For example, if Σ = {0, 1},
    then 01011 is a string over Σ.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 设 Σ 为一个非空有限字符集，称为字母表。 Σ 上的字符串是 Σ 中任何有限字符序列。例如，如果 Σ = {0, 1}，那么 01011 就是 Σ 上的一个字符串。
- en: In this chapter, we’ll talk about the various character sets, including ASCII
    and Unicode, that can be used to compose strings (the *alphabet* from the formal
    definition). We’ll cover how strings are represented and manipulated using the
    legacy functions from the C standard library, the bounds-checked interfaces, and
    POSIX and Windows application programming interfaces (APIs).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论可以用来组成字符串的各种字符集，包括 ASCII 和 Unicode（来自正式定义的*字母表*）。我们将介绍如何使用 C 标准库中的传统函数、边界检查接口以及
    POSIX 和 Windows 应用程序编程接口（API）来表示和操作字符串。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Characters</samp>
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">字符</samp>
- en: The characters that people use to communicate aren’t naturally understood by
    digital systems, which operate on bits. To process characters, digital systems
    use *character encodings* that assign unique integer values, referred to as *code
    points*, to designate specific characters. As you’ll see, there are multiple ways
    to encode the same notional character in your program. Common standards used by
    C implementations for encoding characters include Unicode, ASCII, Extended ASCII,
    ISO 8859-1 (Latin-1), Shift-JIS, and EBCDIC.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 人们用来沟通的字符并不是数字系统本能理解的，因为数字系统是基于位操作的。为了处理字符，数字系统使用*字符编码*，将唯一的整数值（称为*码点*）分配给特定的字符。如你所见，有多种方法可以在程序中对相同的字符进行编码。C
    语言实现中常用的字符编码标准包括 Unicode、ASCII、扩展 ASCII、ISO 8859-1（拉丁文-1）、Shift-JIS 和 EBCDIC。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*The C standard explicitly references Unicode and ASCII.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*C 标准明确引用了 Unicode 和 ASCII。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ASCII</samp>
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ASCII</samp>
- en: The *7-bit American Standard Code for Information Interchange*, better known
    as *7-bit ASCII*, specifies a set of 128 characters and their coded representation
    (ANSI X3.4-1986). Characters from <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1f</samp> and character <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x7f</samp> are control characters, such
    as null, backspace, horizontal tab, and DEL. Characters from <samp class="SANS_TheSansMonoCd_W5Regular_11">0x20</samp>
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7e</samp> are all printable
    characters such as letters, digits, and symbols.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*7位美国信息交换标准代码*，更为人熟知的*7位 ASCII*，指定了一组 128 个字符及其编码表示（ANSI X3.4-1986）。从 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1f</samp>
    的字符和字符 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7f</samp> 是控制字符，例如空字符、退格符、水平制表符和删除符。
    从 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x20</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7e</samp>
    的字符是所有可打印字符，如字母、数字和符号。'
- en: We often refer to this standard with the updated name *US-ASCII* to clarify
    that this system was developed in the United States and focuses on the typographical
    symbols predominantly used in this country. Most modern character encoding schemes
    are based on US-ASCII, although they support many additional characters.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用更新后的名称*US-ASCII*来指代这一标准，以明确该系统是在美国开发的，并且专注于该国主要使用的印刷符号。大多数现代字符编码方案都基于
    US-ASCII，尽管它们支持许多附加字符。
- en: Characters in the <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp> range are not defined
    by US-ASCII but are part of the 8-bit character encoding known as *Extended ASCII*.
    Numerous encodings for these ranges exist, and the actual mapping depends on the
    code page. A *code page* is a character encoding that maps a set of printable
    characters and control characters to unique numbers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp>
    范围内的字符不是 US-ASCII 定义的字符，而是属于被称为 *扩展 ASCII* 的 8 位字符编码。这些范围有多个编码方式，实际的映射取决于代码页。*代码页*
    是一种字符编码，它将一组可打印字符和控制字符映射到唯一的数字。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unicode</samp>
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unicode</samp>
- en: '*Unicode* has become the universal character encoding standard for representing
    text in computer processing. It supports a much wider range of characters than
    ASCII does; the current Unicode Standard (Unicode 2023) encodes characters in
    the range <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">U+10FFFF</samp>, which amounts to a 21-bit
    code space. An individual Unicode value is expressed as <samp class="SANS_TheSansMonoCd_W5Regular_11">U+</samp>
    followed by four or more hexadecimal digits in printed text. The Unicode characters
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp>
    are identical to those in US-ASCII, and the range <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+00FF</samp> is identical to
    ISO 8859-1, consisting of characters from the Latin script used throughout the
    Americas, Western Europe, Oceania, and much of Africa.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*Unicode* 已成为计算机处理文本的通用字符编码标准。它支持的字符范围远大于 ASCII；当前的 Unicode 标准（Unicode 2023）对字符进行了编码，范围从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+10FFFF</samp>，这相当于一个
    21 位的编码空间。单个 Unicode 值以 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+</samp>
    开头，后跟四个或更多十六进制数字，表示为印刷文本。Unicode 字符 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp>
    到 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp> 与 US-ASCII 中的字符完全相同，而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+00FF</samp>
    的范围与 ISO 8859-1 相同，包含了拉丁字母字符，这些字符在美洲、西欧、大洋洲以及非洲的大部分地区被使用。'
- en: Unicode organizes code points into *planes*, which are continuous groups of
    65,536 code points. There are 17 planes, identified by the numbers 0 to 16\. The
    most used characters, including those found in major, older encoding standards,
    have been placed into the first plane (<samp class="SANS_TheSansMonoCd_W5Regular_11">0x0000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFF</samp>), which is called
    the *basic multilingual plane (BMP)*, or Plane 0.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 将代码点组织成 *平面*，即连续的 65,536 个代码点的组。共有 17 个平面，编号从 0 到 16。最常用的字符，包括那些出现在主要旧编码标准中的字符，都被放置在第一个平面（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x0000</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFF</samp>）中，这个平面被称为
    *基本多语言平面（BMP）* 或平面 0。
- en: 'Unicode also specifies several *Unicode transformation formats (UTFs)*, which
    are character encoding formats that assign each Unicode scalar value to a unique
    code unit sequence. A *Unicode scalar value* is any Unicode code point except
    high-surrogate and low-surrogate code points. (Surrogate pairs are explained later
    in this section.) A *code unit* is the minimal bit combination that can represent
    encoded text for processing or interchange. The Unicode standard defines three
    UTFs to allow for code units of various sizes:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 还指定了几种 *Unicode 转换格式（UTFs）*，这些是将每个 Unicode 标量值分配给唯一代码单元序列的字符编码格式。*Unicode
    标量值* 是指除高代理项和低代理项外的任何 Unicode 代码点。（代理对将在本节稍后解释。）*代码单元* 是表示用于处理或交换的编码文本的最小位组合。Unicode
    标准定义了三种 UTF，以允许不同大小的代码单元：
- en: '**UTF-8** Represents each character as a sequence of one to four 8-bit code
    units'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**UTF-8** 将每个字符表示为一个到四个 8 位代码单元的序列'
- en: '**UTF-16** Represents each character as a sequence of one or two 16-bit code
    units'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**UTF-16** 将每个字符表示为一个或两个 16 位代码单元的序列'
- en: '**UTF-32** Represents each character as a single 32-bit code unit'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**UTF-32** 将每个字符表示为一个单一的 32 位代码单元'
- en: 'The UTF-8 encoding is the dominant encoding for POSIX operating systems. It
    has the following desirable properties:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 编码是 POSIX 操作系统中的主流编码。它具有以下优点：
- en: It encodes US-ASCII characters (<samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp>) as single bytes
    in the range <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x7F</samp>. This means that files and
    strings that contain only 7-bit ASCII characters have the same encoding under
    both ASCII and UTF-8.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将 US-ASCII 字符（<samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> 到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp>）编码为范围从 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp>
    到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7F</samp> 的单字节。这意味着只包含 7 位 ASCII
    字符的文件和字符串在 ASCII 和 UTF-8 下具有相同的编码方式。
- en: Using a null byte to terminate a string (a topic we’ll discuss later) works
    the same as for an ASCII string.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空字节终止字符串（我们稍后会讨论这个话题）与 ASCII 字符串的处理方式相同。
- en: All currently defined Unicode code points can be encoded using between 1 and
    4 bytes.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前定义的所有 Unicode 码点可以使用 1 到 4 个字节进行编码。
- en: Unicode allows character boundaries to be easily identified by scanning for
    well-defined bit patterns in either direction.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode 通过扫描明确的比特模式，在任意方向上轻松识别字符边界。
- en: On Windows, you can compile and link your programs with the Visual C++ <samp
    class="SANS_TheSansMonoCd_W5Regular_11">/utf8</samp> flag to set the source and
    execution character sets as UTF-8\. You’ll also need to configure Windows to use
    Unicode UTF-8 for worldwide language support.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，你可以使用 Visual C++ 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">/utf8</samp>
    标志编译并链接程序，以将源字符集和执行字符集设置为 UTF-8。你还需要配置 Windows 以使用 Unicode UTF-8 来支持全球语言。
- en: UTF-16 is currently the dominant encoding for Windows operating systems. Like
    UTF-8, UTF-16 is a variable-width encoding. As just mentioned, the BMP consists
    of characters from <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+FFFF</samp>. Characters whose
    code points are greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">U+FFFF</samp>
    are called *supplementary characters*. Supplementary characters are defined by
    a pair of code units called *surrogates*. The first code unit is from the high-surrogates
    range (<samp class="SANS_TheSansMonoCd_W5Regular_11">U+D800</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+DBFF</samp>),
    and the second code unit is from the low-surrogates range (<samp class="SANS_TheSansMonoCd_W5Regular_11">U+DC00</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+DFFF</samp>).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-16 目前是 Windows 操作系统中主流的编码方式。与 UTF-8 类似，UTF-16 是一种可变宽度编码。正如前面提到的，基本多文种平面（BMP）包含从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+FFFF</samp>
    的字符。码点大于 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+FFFF</samp> 的字符被称为 *补充字符*。补充字符由一对称为
    *替代符* 的编码单元定义。第一个编码单元位于高替代符范围（<samp class="SANS_TheSansMonoCd_W5Regular_11">U+D800</samp>
    到 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+DBFF</samp>），第二个编码单元位于低替代符范围（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">U+DC00</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+DFFF</samp>）。
- en: Unlike other variable-length UTFs, UTF-32 is a fixed-length encoding. The main
    advantage of UTF-32 is that the Unicode code points can be directly indexed, meaning
    that you can find the *n*th code point in a sequence of code points in constant
    time. In contrast, a variable-length encoding requires accessing each code point
    to find the *n*th code point in a sequence.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他可变长度 UTF 编码不同，UTF-32 是一种固定长度的编码方式。UTF-32 的主要优点是 Unicode 码点可以直接索引，这意味着你可以在常数时间内找到序列中第
    *n* 个码点。相比之下，可变长度编码需要访问每个码点，才能找到序列中的第 *n* 个码点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Source and Execution
    Character Sets</samp>
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">源字符集和执行字符集</samp>
- en: No universally accepted character encoding existed when C was originally standardized,
    so it was designed to work with a wide variety of character representations. Instead
    of specifying a character encoding like Java, each C implementation defines both
    a *source character set* in which source files are written and an *execution character
    set* used for character and string literals at compile time.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言最初标准化时，并没有一种被普遍接受的字符编码方式，因此它被设计成能够与多种字符表示方式兼容。与 Java 不同，C 的每个实现都定义了 *源字符集*（即源文件编写时使用的字符集）和
    *执行字符集*（即编译时使用的字符和字符串字面值的字符集）。
- en: Both the source and execution character sets must contain encodings for the
    uppercase and lowercase letters of the Latin alphabet; the 10 decimal digits;
    29 graphic characters; and the space, horizontal tab, vertical tab, form feed,
    and newline characters. The execution character set also includes alert, backspace,
    carriage return, and null characters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 源字符集和执行字符集必须包含拉丁字母的大写和小写字母的编码；10 个十进制数字；29 个图形字符；以及空格、水平制表符、垂直制表符、换页符和换行符。执行字符集还包括警告、退格、回车和空字符。
- en: Character conversion and classification functions (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">isdigit</samp>)
    are evaluated at runtime, based on the locale-determined encoding in effect at
    the time of the call. A program’s *locale* defines its code sets, date and time
    formatting conventions, monetary conventions, decimal formatting conventions,
    and sort order.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 字符转换和分类函数（例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">isdigit</samp>）会在运行时进行评估，基于调用时生效的本地化编码。程序的
    *区域设置* 定义了它的代码集、日期和时间格式约定、货币约定、十进制格式约定和排序顺序。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Data Types</samp>
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">数据类型</samp>
- en: C defines several data types to represent character data, some of which we have
    already seen. C offers the unadorned <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type to represent *narrow characters* (those that can be represented in as few
    as 8 bits) and the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type to represent *wide characters* (those that may require more than 8 bits).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: C 定义了几种数据类型来表示字符数据，其中一些我们已经见过。C 提供了不带修饰的 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    类型来表示 *窄字符*（那些可以用最多 8 位表示的字符），以及 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    类型来表示 *宽字符*（那些可能需要超过 8 位表示的字符）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">char</samp>
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">char</samp>
- en: As I have already mentioned, <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    is an integer type, but each implementation defines whether it’s signed or unsigned.
    In portable code, you can assume neither.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 是一种整数类型，但每种实现会定义它是有符号还是无符号的。在可移植的代码中，你可以假设它既不是有符号也不是无符号的。
- en: Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type for character
    data (where signedness has no meaning) and not for integer data (where signedness
    is important). You can safely use the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type to represent 7-bit character encodings, such as US-ASCII. For these encodings,
    the high-order bits are always 0, so you don’t have to be concerned about sign
    extension when a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and implementation
    defined as a signed type.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型表示字符数据（在这种情况下符号性无关紧要），而不是用于表示整数数据（在这种情况下符号性很重要）。你可以安全地使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型表示 7 位字符编码，例如 US-ASCII。对于这些编码，高位总是
    0，因此当将 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型的值转换为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 时，你无需担心符号扩展问题，因为实现将其定义为有符号类型。
- en: 'You can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type to represent 8-bit character encodings, such as Extended ASCII, ISO/IEC 8859,
    EBCDIC, and UTF-8\. These 8-bit character encodings can be problematic on implementations
    that define <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> as an 8-bit
    signed type. For example, the following code prints the string <samp class="SANS_TheSansMonoCd_W5Regular_11">end
    of file</samp> when an <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    is detected:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型来表示 8 位字符编码，例如扩展
    ASCII、ISO/IEC 8859、EBCDIC 和 UTF-8。这些 8 位字符编码在将 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    定义为 8 位有符号类型的实现上可能会出现问题。例如，下面的代码在检测到 <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    时会打印字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">end of file</samp>：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Assuming the implementation-defined execution character set is ISO/IEC 8859-1,
    the Latin small letter y with diaeresis (ÿ) is defined to have the representation
    <samp class="SANS_TheSansMonoCd_W5Regular_11">255 (0xFF)</samp>. For implementations
    in which <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> is defined
    as a signed type, <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> will
    be sign-extended to the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>, making the ÿ character indistinguishable from <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    because they have the same representation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设实现定义的执行字符集为 ISO/IEC 8859-1，带有分音符的拉丁小写字母 y（ÿ）被定义为表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">255
    (0xFF)</samp>。对于将 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 定义为有符号类型的实现，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">c</samp> 将被符号扩展为 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp> 的宽度，这使得ÿ字符与 <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    无法区分，因为它们具有相同的表示。
- en: A similar problem occurs when using the character classification functions defined
    in <samp class="SANS_TheSansMonoCd_W5Regular_11"><ctype.h></samp>. These library
    functions accept a character argument as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or the value of the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>.
    They return a nonzero value if the character belongs to the set of characters
    that the function’s description defines and zero if the value doesn’t belong to
    it. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">isdigit</samp>
    function tests whether the character is a decimal-digit character in the current
    locale. Any argument value that isn’t a valid character or <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    results in undefined behavior.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用在 <samp class="SANS_TheSansMonoCd_W5Regular_11"><ctype.h></samp> 中定义的字符分类函数时，会发生类似的问题。这些库函数将字符参数作为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 或宏 <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    的值来接受。如果字符属于该函数描述定义的字符集合，则返回非零值；如果字符不属于该集合，则返回零。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">isdigit</samp>
    函数测试字符是否为当前区域设置中的十进制数字字符。任何不是有效字符或 <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    的参数值都会导致未定义行为。
- en: 'To avoid undefined behavior when invoking these functions, cast <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> before the
    integer promotions, as shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在调用这些函数时发生未定义行为，应在整数提升之前将 <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    强制转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>，如下所示：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is
    zero-extended to the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>, eliminating the undefined behavior by ensuring that the resulting
    value is representable as an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>. Note that the initialization of <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ'</samp> may result in a warning
    or error.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> 中的值会被零扩展到 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp> 的宽度，通过确保结果值能够作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> 表示，从而消除未定义行为。请注意，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    初始化为 <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ'</samp> 可能会导致警告或错误。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">int</samp>
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">int</samp>
- en: Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type for data
    that could be either <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    (a negative value) or character data interpreted as <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> and then converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Functions that read character data from a stream, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>,
    return the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type. As we’ve
    seen, character-handling functions from <samp class="SANS_TheSansMonoCd_W5Regular_11"><ctype.h></samp>
    also accept this type because they might be passed the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>
    or related functions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能是 <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>（一个负值）或作为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> 解释后再转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    的字符数据，应使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型。从流中读取字符数据的函数，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>，返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    类型。正如我们所见，来自 <samp class="SANS_TheSansMonoCd_W5Regular_11"><ctype.h></samp> 的字符处理函数也接受这种类型，因为它们可能会接收到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp> 或相关函数的结果。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">wchar_t</samp>
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">wchar_t</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type is an
    integer type added to C to process the characters of a large character set. It
    can be a signed or unsigned integer type, depending on the implementation, and
    it has an implementation-defined inclusive range of <samp class="SANS_TheSansMonoCd_W5Regular_11">WCHAR_MIN</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">WCHAR_MAX</samp>. Most implementations
    define <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> to be either
    a 16- or 32-bit unsigned integer type, but implementations that don’t support
    localization may define <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    to have the same width as <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>.
    C does not permit a variable-length encoding for wide strings (despite UTF-16
    being used this way in practice on Windows). Implementations can conditionally
    define the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp>
    as an integer constant of the form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">yyyymmL</samp>
    (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">199712L</samp>) to
    mean that the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type
    is used to represent Unicode characters corresponding to the specified version
    of the standard. Implementations that chose a 16-bit type for <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    cannot meet the requirements for defining <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp>
    for ISO/IEC 10646 editions more recent than Unicode 3.1\. Consequently, the requirement
    for defining <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp>
    is either a <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type
    larger than 20 bits or a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    and a value for <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp>
    earlier than <samp class="SANS_TheSansMonoCd_W5Regular_11">200103L</samp>. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type can be used
    for encodings other than Unicode, such as wide EBCDIC.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 类型是 C 语言中为了处理大字符集的字符而新增的整数类型。它可以是有符号或无符号整数类型，具体取决于实现，并且具有实现定义的包含范围，从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WCHAR_MIN</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">WCHAR_MAX</samp>。大多数实现将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 定义为 16 位或 32 位无符号整数类型，但不支持本地化的实现可能将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 定义为与 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    相同的宽度。C 语言不允许使用可变长度编码来表示宽字符串（尽管在 Windows 上实际使用 UTF-16 是这种方式）。实现可以有条件地将宏 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp> 定义为整数常量，形式为
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">yyyymmL</samp>（例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">199712L</samp>），表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    类型用于表示对应于指定版本标准的 Unicode 字符。选择 16 位类型的实现无法满足定义 <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp>
    的要求，特别是对于比 Unicode 3.1 更高版本的 ISO/IEC 10646。结果，定义 <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp>
    的要求是要么使用大于 20 位的 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    类型，要么使用 16 位 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 类型和一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp> 的值，且该值早于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">200103L</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    类型还可以用于表示 Unicode 以外的编码，例如宽 EBCDIC。
- en: Writing portable code using <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    can be difficult because of the range of implementation-defined behavior. For
    example, Windows uses a 16-bit unsigned integer type, while Linux typically uses
    a 32-bit unsigned integer type. Code that calculates the lengths and sizes of
    wide-character strings is error prone and must be performed with care.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 编写可移植代码可能会很困难，因为实现定义的行为范围很广。例如，Windows
    使用 16 位无符号整数类型，而 Linux 通常使用 32 位无符号整数类型。计算宽字符字符串的长度和大小的代码容易出错，必须小心执行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">char16_t and char32_t</samp>
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">char16_t 和 char32_t</samp>
- en: Other languages (including Ada95, Java, TCL, Perl, Python, and C#) have data
    types for Unicode characters. C11 introduced the 16- and 32-bit character data
    types <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>, declared in <samp class="SANS_TheSansMonoCd_W5Regular_11"><uchar.h></samp>,
    to provide data types for UTF-16 and UTF-32 encodings, respectively. C doesn’t
    provide standard library functions for the new data types, except for one set
    of character conversion functions. Without library functions, these types have
    limited usefulness.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言（包括 Ada95、Java、TCL、Perl、Python 和 C#）都具有用于表示 Unicode 字符的数据类型。C11 引入了 16 位和
    32 位字符数据类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>，这些类型在 <samp class="SANS_TheSansMonoCd_W5Regular_11"><uchar.h></samp>
    中声明，用于分别表示 UTF-16 和 UTF-32 编码。C 不为这些新数据类型提供标准库函数，除了少数字符转换函数。没有库函数的支持，这些类型的用途非常有限。
- en: C defines two environment macros that indicate how characters represented in
    these types are encoded. If the environment macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp>
    has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, values of
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> are UTF-16
    encoded. If the environment macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_32__</samp>
    has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, values of
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> are UTF-32
    encoded. If the macro isn’t defined, another implementation-defined encoding is
    used. Visual C++ does not define these macros, suggesting that you can’t use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> on Windows for UTF-16.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: C 定义了两个环境宏，用于指示这些类型中表示的字符是如何编码的。如果环境宏 <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp>
    的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>
    类型的值采用 UTF-16 编码。如果环境宏 <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_32__</samp>
    的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>
    类型的值采用 UTF-32 编码。如果宏未定义，则使用另一个实现定义的编码方式。Visual C++ 不定义这些宏，表明在 Windows 上不能使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> 类型表示 UTF-16。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Character Constants</samp>
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">字符常量</samp>
- en: C allows you to specify *character constants*, also known as *character literals*,
    which are sequences of one or more characters enclosed in single quotes, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ'</samp>. Character constants
    allow you to specify character values in the source code of your program. [Table
    7-1](chapter7.xhtml#tab7-1) shows the types of character constants that can be
    specified in C.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: C 允许你指定*字符常量*，也叫做*字符字面量*，它们是由一个或多个字符组成，并用单引号括起来，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ'</samp>。字符常量允许你在程序的源代码中指定字符值。[表
    7-1](chapter7.xhtml#tab7-1)展示了可以在 C 中指定的字符常量类型。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-1:</samp> <samp class="SANS_Futura_Std_Book_11">Types
    of Character Constants</samp>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 7-1：</samp> <samp class="SANS_Futura_Std_Book_11">字符常量类型</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Prefix</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Type</samp>
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">前缀</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">类型</samp>
    |'
- en: '| --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">None</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">无</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">u8''a''</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">char8_t</samp>
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">u8''a''</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">char8_t</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">L''a''</samp> | <samp class="SANS_Futura_Std_Book_11">The
    unsigned type corresponding to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">L''a''</samp> | <samp class="SANS_Futura_Std_Book_11">对应的无符号类型</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">u''a''</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">u''a''</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">U''a''</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">U''a''</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>
    |'
- en: The value of a character constant containing more than one character (for example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'ab'</samp>) is implementation defined.
    So is the value of a source character that cannot be represented as a single code
    unit in the execution character set. The earlier example of <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">'</samp> is one such case. If the execution
    character set is UTF-8, the value might be <samp class="SANS_TheSansMonoCd_W5Regular_11">0xC3BF</samp>
    to reflect the UTF-8 encoding of the two code units needed to represent the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">U+00FF</samp> code-point value. C23 adds
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp> prefix for character
    literals to represent a UTF-8 encoding. A UTF-8, UTF-16, or UTF-32 character constant
    cannot contain more than one character. The value must be representable with a
    single UTF-8, UTF-16, or UTF-32 code unit, respectively. Because UTF-8 encodes
    US-ASCII characters (<samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp>) as single bytes
    in the range <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x7F</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp>
    prefix can be used to create ASCII characters, even on implementations where the
    locale-dependent character encoding is some other encoding, such as EBCDIC.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 包含多个字符的字符常量（例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">'ab'</samp>）的值是由实现定义的。不能用单一代码单元表示的源字符的值也是如此。早前提到的例子
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>
    就是一个这样的情况。如果执行字符集是 UTF-8，则该值可能是 <samp class="SANS_TheSansMonoCd_W5Regular_11">0xC3BF</samp>，以反映表示
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U+00FF</samp> 代码点值所需的两个代码单元的 UTF-8
    编码。C23 为字符字面量添加了 <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp> 前缀，以表示
    UTF-8 编码。UTF-8、UTF-16 或 UTF-32 字符常量不能包含多个字符。该值必须能够使用单一的 UTF-8、UTF-16 或 UTF-32
    代码单元表示。因为 UTF-8 将 US-ASCII 字符（<samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp>
    到 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp>）作为范围在 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp>
    到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7F</samp> 之间的单字节表示，所以即使在字符编码依赖于本地环境的实现中（例如
    EBCDIC 编码），也可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp> 前缀来创建
    ASCII 字符。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Escape Sequences</samp>
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">转义序列</samp>
- en: The single quote (<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>) and
    backslash (<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>) have special
    meanings, so they cannot be directly represented as characters. Instead, to represent
    the single quote, we use the escape sequence <samp class="SANS_TheSansMonoCd_W5Regular_11">\'</samp>,
    and to represent the backslash, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp>.
    We can represent other characters, such as the question mark (<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>),
    and arbitrary integer values by using the escape sequences shown in [Table 7-2](chapter7.xhtml#tab7-2).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号（<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>）和反斜杠（<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>）具有特殊含义，因此不能直接表示为字符。相反，为了表示单引号，我们使用转义序列
    <samp class="SANS_TheSansMonoCd_W5Regular_11">\'</samp>，为了表示反斜杠，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp>。我们还可以使用转义序列表示其他字符，例如问号（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">?</samp>）以及任意整数值，具体请参见[表 7-2](chapter7.xhtml#tab7-2)。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-2:</samp> <samp class="SANS_Futura_Std_Book_11">Escape
    Sequences</samp>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 7-2:</samp> <samp class="SANS_Futura_Std_Book_11">转义序列</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Character</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Escape
    sequence</samp> |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">字符</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">转义序列</samp>
    |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Single quote</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\''</samp>
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">单引号</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\''</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Double quote</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\"</samp>
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">双引号</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\"</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Question mark</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\?</samp>
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">问号</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\?</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Backslash</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp>
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">反斜杠</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Alert</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">警告</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Backspace</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">退格符</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Form feed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\f</samp>
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">换页符</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\f</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Newline</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">换行符</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Carriage return</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp>
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">回车符</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Horizontal tab</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\t</samp>
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">水平制表符</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\t</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Vertical tab</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\v</samp>
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">垂直制表符</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\v</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Octal character</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\<</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">up to three octal digits</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">></samp> |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">八进制字符</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\<</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">最多三位八进制数字</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Hexadecimal character</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">\<</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x
    hexidecimal digits</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">十六进制字符</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\<</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">十六进制数字</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>
    |'
- en: 'The following nongraphical characters are represented by escape sequences consisting
    of the backslash followed by a lowercase letter: <samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>
    (alert), <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp> (backspace),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">\f</samp> (form feed), <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    (newline), <samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp> (carriage return),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">\t</samp> (horizontal tab), and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">\v</samp> (vertical tab).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过转义序列表示的非图形字符，这些转义序列由反斜杠后跟小写字母组成：<samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>（警告），<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>（退格符），<samp class="SANS_TheSansMonoCd_W5Regular_11">\f</samp>（换页符），<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>（换行符），<samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp>（回车符），<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\t</samp>（水平制表符）和<samp class="SANS_TheSansMonoCd_W5Regular_11">\v</samp>（垂直制表符）。
- en: Octal digits can be incorporated into an octal escape sequence to construct
    a single character for a character constant or a single wide character for a wide-character
    constant. The numerical value of the octal integer specifies the value of the
    desired character or wide character. *A backslash followed by numbers is always
    interpreted as an octal value.* For example, you can represent the backspace character
    (8 decimal) as the octal value <samp class="SANS_TheSansMonoCd_W5Regular_11">\10</samp>
    or, equivalently, <samp class="SANS_TheSansMonoCd_W5Regular_11">\010</samp>.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 八进制数字可以被嵌入到八进制转义序列中，用于构建一个字符常量或一个宽字符常量。八进制整数的数值指定所需字符或宽字符的值。*反斜杠后跟数字总是被解释为八进制值。*
    例如，你可以将退格符（十进制为8）表示为八进制值<samp class="SANS_TheSansMonoCd_W5Regular_11">\10</samp>，或者等效地表示为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\010</samp>。
- en: You can also incorporate the hexadecimal digits that follow the <samp class="SANS_TheSansMonoCd_W5Regular_11">\x</samp>
    to construct a single character or wide character for a character constant. The
    numerical value of the hexadecimal integer forms the value of the desired character
    or wide character. For example, you can represent the backspace character as the
    hexadecimal value <samp class="SANS_TheSansMonoCd_W5Regular_11">\x8</samp> or,
    equivalently, <samp class="SANS_TheSansMonoCd_W5Regular_11">\x08</samp>.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以结合 <samp class="SANS_TheSansMonoCd_W5Regular_11">\x</samp> 后的十六进制数字来构造字符常量或宽字符常量。十六进制整数的数值形成所需字符或宽字符的值。例如，你可以将退格符表示为十六进制值
    <samp class="SANS_TheSansMonoCd_W5Regular_11">\x8</samp> 或等效的 <samp class="SANS_TheSansMonoCd_W5Regular_11">\x08</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Linux</samp>
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Linux</samp>
- en: Character encodings have evolved differently on various operating systems. Before
    UTF-8 emerged, Linux typically relied on various language-specific extensions
    of ASCII. The most popular of these were ISO 8859-1 and ISO 8859-2 in Europe,
    ISO 8859-7 in Greece, KOI-8/ISO 8859-5/CP1251 in Russia, EUC and Shift-JIS in
    Japan, and BIG5 in Taiwan. Linux distributors and application developers are phasing
    out these older legacy encodings in favor of UTF-8 to represent localized text
    strings (Kuhn 1999).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 字符编码在不同操作系统上的演变有所不同。在 UTF-8 出现之前，Linux 通常依赖于各种语言特定的 ASCII 扩展。最流行的包括欧洲的 ISO 8859-1
    和 ISO 8859-2，希腊的 ISO 8859-7，俄罗斯的 KOI-8/ISO 8859-5/CP1251，日本的 EUC 和 Shift-JIS，以及台湾的
    BIG5。Linux 发行版和应用程序开发者正在逐步淘汰这些旧的遗留编码，转而使用 UTF-8 来表示本地化的文本字符串（Kuhn 1999）。
- en: 'GCC has several flags that allow you to configure character sets. Here are
    a couple of flags you may find useful:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 有几个标志可以让你配置字符集。以下是一些你可能会觉得有用的标志：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset</samp> flag
    sets the execution character set that’s used to interpret string and character
    constants. The default is UTF-8\. The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">charset</samp>
    can be any encoding supported by the system’s <samp class="SANS_TheSansMonoCd_W5Regular_11">iconv</samp>
    library routine described later in this chapter. For example, setting <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset=IBM1047</samp>
    instructs GCC to interpret string constants hardcoded in source code, such as
    <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> format strings, according
    to EBCDIC code page 1,047.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset</samp> 标志设置用于解释字符串和字符常量的执行字符集。默认值是
    UTF-8。<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">charset</samp> 可以是系统的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">iconv</samp> 库例程所支持的任何编码，稍后在本章中会介绍。例如，设置
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset=IBM1047</samp> 会指示
    GCC 按照 EBCDIC 编码页 1047 来解释源代码中硬编码的字符串常量，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    格式字符串。
- en: 'To select the wide-execution character set, used for wide-string and character
    constants, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-fwide-exec-charset</samp>
    flag:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择用于宽字符串和字符常量的宽执行字符集，可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-fwide-exec-charset</samp>
    标志：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The default is UTF-32 or UTF-16, corresponding to the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值是 UTF-32 或 UTF-16，对应于 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    的宽度。
- en: 'The input character set defaults to your system locale (or UTF-8 if the system
    locale is not configured). To overwrite the input character set used for translating
    the character set of the input file to the source character set used by GCC, use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">-finput-charset</samp> flag:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 输入字符集默认与系统区域设置相同（如果系统区域设置未配置，则为 UTF-8）。要覆盖用于将输入文件的字符集转换为 GCC 使用的源字符集的输入字符集，可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-finput-charset</samp> 标志：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Clang has <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-finput-charset</samp> but not
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-fwide-exec-charset</samp>. Clang
    allows you to set <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">charset</samp>
    to UTF-8 only and rejects any attempt to set it to something else.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 有 <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">-finput-charset</samp>，但没有 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-fwide-exec-charset</samp>。Clang 只允许将
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">charset</samp> 设置为 UTF-8，并拒绝任何将其设置为其他值的尝试。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Windows</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Windows</samp>
- en: Support for character encodings in Windows has irregularly evolved. Programs
    developed for Windows can handle character encodings using either Unicode interfaces
    or interfaces that rely implicitly on locale-dependent character encodings. For
    most modern applications, you should choose the Unicode interfaces by default
    to ensure that the application behaves as you expect when processing text. Generally,
    this code will have better performance, as narrow strings passed to Windows library
    functions are frequently converted to Unicode strings.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 中对字符编码的支持经历了不规则的发展。为 Windows 开发的程序可以使用 Unicode 接口或依赖于区域设置的字符编码接口来处理字符编码。对于大多数现代应用程序，默认应选择
    Unicode 接口，以确保在处理文本时应用程序的行为符合预期。通常，这段代码的性能会更好，因为传递给 Windows 库函数的窄字符字符串通常会被转换为
    Unicode 字符串。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The main and wmain Entry Points</samp>
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">main 和 wmain 入口点</samp>
- en: 'Visual C++ supports two entry points to your program: <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>,
    which allows you to pass narrow-character arguments, and <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>,
    which allows you to pass wide-character arguments. You declare formal parameters
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp> by using a similar
    format to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, as shown
    in [Table 7-3](chapter7.xhtml#tab7-3).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Visual C++ 支持两种程序入口点：<samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>，它允许你传递窄字符参数，以及
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>，它允许你传递宽字符参数。你可以使用与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 相似的格式声明 <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>
    的正式参数，如[表 7-3](chapter7.xhtml#tab7-3)所示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-3:</samp> <samp class="SANS_Futura_Std_Book_11">Windows
    Program Entry Point Declarations</samp>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 7-3：</samp> <samp class="SANS_Futura_Std_Book_11">Windows
    程序入口点声明</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Narrow-character arguments</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Wide-character arguments</samp> |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">窄字符参数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">宽字符参数</samp>
    |'
- en: '| --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int main();</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int wmain();</samp> |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int main();</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int wmain();</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int main(int argc, char *argv[]);</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">int wmain(int argc, wchar_t *argv[]);</samp>
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int main(int argc, char *argv[]);</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">int wmain(int argc, wchar_t *argv[]);</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int main(int argc, char *argv[],</samp><samp
    class="SANS_Futura_Std_Book_11"></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">char
    *envp[]);</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int wmain(int
    argc, wchar_t *argv[],</samp><samp class="SANS_Futura_Std_Book_11"></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">wchar_t *envp[]);</samp> |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int main(int argc, char *argv[],</samp><samp
    class="SANS_Futura_Std_Book_11"></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">char
    *envp[]);</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int wmain(int
    argc, wchar_t *argv[],</samp><samp class="SANS_Futura_Std_Book_11"></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">wchar_t *envp[]);</samp> |'
- en: For either entry point, the character encoding ultimately depends on the calling
    process. However, by convention, the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function receives its optional arguments and environment as pointers to text encoded
    with the current Windows (also called ANSI) code page, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>
    function receives UTF-16-encoded text.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意入口点，字符编码最终取决于调用进程。然而，根据惯例，<samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    函数接收其可选参数和环境作为指向当前 Windows（也称为 ANSI）代码页编码文本的指针，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>
    函数接收 UTF-16 编码的文本。
- en: When you run a program from a shell such as the command prompt, the shell’s
    command interpreter converts the arguments into the proper encoding for that entry
    point. A Windows process starts with a UTF-16-encoded command line. The startup
    code emitted by the compiler/linker calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLineToArgvW</samp>
    function to convert the command line to the <samp class="SANS_TheSansMonoCd_W5Regular_11">argv</samp>
    form required to call <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    or passes the command line arguments directly to the <samp class="SANS_TheSansMonoCd_W5Regular_11">argv</samp>
    form required to call <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>.
    In a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, the results
    are then transcoded to the current Windows code page, which can vary from system
    to system. The ASCII character <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    is substituted for characters that lack representation in the current Windows
    code page.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从命令提示符等 shell 运行程序时，shell 的命令解释器会将参数转换为该入口点所需的正确编码。Windows 进程以 UTF-16 编码的命令行开始。编译器/链接器发出的启动代码调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLineToArgvW</samp> 函数，将命令行转换为调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 所需的 <samp class="SANS_TheSansMonoCd_W5Regular_11">argv</samp>
    形式，或者直接将命令行参数传递给调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>
    所需的 <samp class="SANS_TheSansMonoCd_W5Regular_11">argv</samp> 形式。在对 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    的调用中，结果会被重新编码为当前的 Windows 代码页，而该代码页可能因系统而异。对于当前 Windows 代码页中无法表示的字符，ASCII 字符 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">?</samp> 会被替代。
- en: The Windows console uses an original equipment manufacturer (OEM) code page
    when writing data to the console. The actual encoding used varies from system
    to system but is often different from the Windows code page. For example, on a
    US English version of Windows, the Windows code page may be Windows Latin 1, while
    the OEM code page may be DOS Latin US. In general, writing textual data to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>
    requires the text to be converted to the OEM code page first, or requires setting
    the console’s output code page to match the encoding of the text being written
    out. Failure to do so may cause unexpected output to be printed to the console.
    However, even if you carefully match the character encodings between your program
    and the console, the console might still fail to display the characters as expected
    because of other factors, such as the current font selected for the console not
    having the appropriate glyphs required to represent the characters. Additionally,
    the Windows console has historically been unable to display characters outside
    of the Unicode BMP because it stores only a 16-bit value for character data for
    each cell.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 控制台在向控制台写入数据时使用原始设备制造商（OEM）代码页。实际使用的编码因系统而异，但通常与 Windows 代码页不同。例如，在美国英语版
    Windows 上，Windows 代码页可能是 Windows Latin 1，而 OEM 代码页可能是 DOS Latin US。一般而言，向 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>
    写入文本数据需要先将文本转换为 OEM 代码页，或者需要将控制台的输出代码页设置为与写入文本的编码相匹配。如果未这样做，可能会导致控制台输出意外的内容。然而，即使你仔细匹配了程序和控制台之间的字符编码，控制台仍然可能无法按预期显示字符，原因可能是其他因素，比如当前为控制台选择的字体没有适当的字形来表示这些字符。此外，历史上，Windows
    控制台无法显示 Unicode 基本多文种平面（BMP）之外的字符，因为它仅为每个单元格的字符数据存储一个 16 位值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Narrow vs. Wide Characters</samp>
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">窄字符与宽字符</samp>
- en: 'There are two versions of all system APIs in the Win32 software development
    kit (SDK): a narrow Windows (ANSI) version with an <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    suffix and a wide-character version with a <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>
    suffix:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Win32 软件开发工具包（SDK）中的所有系统 API 都有两个版本：一个是带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    后缀的窄字符 Windows（ANSI）版本，另一个是带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>
    后缀的宽字符版本：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Determine whether your application is going to use wide (UTF-16) or narrow
    characters and then code accordingly. The best practice is to explicitly call
    the narrow- or wide-string version of each function and pass a string of the appropriate
    type:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 确定你的应用程序是否使用宽字符（UTF-16）或窄字符，并据此编写代码。最佳实践是显式调用每个函数的窄字符或宽字符版本，并传递适当类型的字符串：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Examples of actual functions from the Win32 SDK include the <samp class="SANS_TheSansMonoCd_W5Regular_11">MessageBoxA</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MessageBoxW</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowExA</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowExW</samp> functions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Win32 SDK的实际函数示例包括<samp class="SANS_TheSansMonoCd_W5Regular_11">MessageBoxA</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MessageBoxW</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowExA</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowExW</samp>函数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Character Conversion</samp>
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">字符转换</samp>
- en: Although international text is increasingly encoded in Unicode, it’s still encoded
    in language- or country-dependent character encodings, making it necessary to
    convert between these encodings. Windows still operates in locales with traditional,
    limited character encodings, such as IBM EBCDIC and ISO 8859-1\. Programs frequently
    need to convert between the Unicode and traditional encoding schemes when performing
    input/output (I/O).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管国际文本越来越多地采用Unicode编码，但它仍然采用语言或国家依赖的字符编码，因此需要在这些编码之间进行转换。Windows仍然在具有传统、有限字符编码的区域设置中运行，例如IBM
    EBCDIC和ISO 8859-1。程序在进行输入/输出（I/O）时，通常需要在Unicode和传统编码方案之间进行转换。
- en: It’s not possible to convert all strings to each language- or country-dependent
    character encoding. This is obvious when the encoding is US-ASCII, which can’t
    represent characters requiring more than 7 bits of storage. Latin-1 will never
    encode the character <samp class="SANS_Source_Han_Serif_SC_Regular_11">愛</samp>
    properly, and many kinds of non-Japanese letters and words cannot be converted
    to Shift-JIS without losing information.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不能将所有字符串转换为每种语言或国家依赖的字符编码。当编码为US-ASCII时，这一点尤其明显，因为US-ASCII无法表示需要超过7位存储的字符。Latin-1永远无法正确编码字符<samp
    class="SANS_Source_Han_Serif_SC_Regular_11">愛</samp>，而许多非日语的字母和词语也无法在不丢失信息的情况下转换为Shift-JIS。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">C Standard Library</samp>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">C标准库</samp>'
- en: The C standard library provides a handful of functions to convert between narrow-code
    units (<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>) and wide-code
    units (<samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>). The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mbtowc</samp> (multibyte to wide character),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wctomb</samp> (wide character to
    multibyte), <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtowc</samp> (multibyte
    restartable to wide character), and <samp class="SANS_TheSansMonoCd_W5Regular_11">wcrtomb</samp>
    (wide-character restartable to multibyte) functions convert one code unit at a
    time, writing the result to an output object or buffer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">mbstowcs</samp>
    (multibyte string to wide-character string), <samp class="SANS_TheSansMonoCd_W5Regular_11">wcstombs</samp>
    (wide-character string to multibyte string), <samp class="SANS_TheSansMonoCd_W5Regular_11">mbsrtowcs</samp>
    (multibyte-string restartable to multibyte string), and <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsrtombs</samp>
    (wide-character-string restartable to wide-character string) functions convert
    a sequence of code units, writing the result to an output buffer.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: C标准库提供了一些函数，用于在窄字符单元（<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>）和宽字符单元（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>）之间进行转换。<samp class="SANS_TheSansMonoCd_W5Regular_11">mbtowc</samp>（多字节到宽字符）、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wctomb</samp>（宽字符到多字节）、<samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtowc</samp>（可重启多字节到宽字符）和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wcrtomb</samp>（可重启宽字符到多字节）函数一次转换一个字符单元，并将结果写入输出对象或缓冲区。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mbstowcs</samp>（多字节字符串到宽字符字符串）、<samp class="SANS_TheSansMonoCd_W5Regular_11">wcstombs</samp>（宽字符字符串到多字节字符串）、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mbsrtowcs</samp>（可重启多字节字符串到宽字符字符串）和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wcsrtombs</samp>（可重启宽字符字符串到多字节字符串）函数一次转换一系列字符单元，并将结果写入输出缓冲区。
- en: Conversion functions need to store data to properly process a sequence of conversions
    between function calls. The *nonrestartable* forms store the state internally
    and are consequently unsuitable for multithreaded processing. The *restartable*
    versions have an additional parameter that’s a pointer to an object of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mbstate_t</samp> that describes the current
    conversion state of the associated multibyte character sequence. This object holds
    the state data that makes it possible to restart the conversion where it left
    off after another call to the function to perform an unrelated conversion. The
    *string* versions are for performing bulk conversions of multiple code units at
    once.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 转换函数需要存储数据，以便在函数调用之间正确处理转换序列。*不可重启*的形式将状态存储在内部，因此不适合多线程处理。*可重启*的版本具有一个额外的参数，它是指向类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mbstate_t</samp> 的对象的指针，该对象描述了相关多字节字符序列的当前转换状态。此对象保存状态数据，使得在另一次调用该函数执行不相关的转换后，可以从中断的地方重新启动转换。*字符串*版本用于一次执行多个字符单元的批量转换。
- en: These functions have a few limitations. As discussed earlier, Windows uses 16-bit
    code units for <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>. This
    can be a problem, because the C standard requires an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    to be capable of representing any character in the current locale, and a 16-bit
    code unit can be too small to do so. C technically doesn’t allow you to use multiple
    objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> to
    represent a single character. Consequently, the standard conversion functions
    may result in a loss of data. On the other hand, most POSIX implementations use
    32-bit code units for <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>,
    allowing the use of UTF-32\. Because a single UTF-32 code unit can represent a
    whole code point, conversions using standard functions cannot lose or truncate
    data.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数有一些限制。如前所述，Windows使用16位字符单元表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>。这可能会成为问题，因为C标准要求
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 类型的对象能够表示当前区域设置中的所有字符，而16位字符单元可能太小，无法做到这一点。技术上讲，C语言不允许你使用多个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 类型的对象来表示单个字符。因此，标准转换函数可能会导致数据丢失。另一方面，大多数POSIX实现使用32位字符单元表示
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>，允许使用UTF-32。由于单个UTF-32字符单元可以表示一个完整的代码点，因此使用标准函数的转换不会丢失或截断数据。
- en: 'The C standards committee added the following functions to C11 to address the
    potential loss of data using standard conversion functions:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: C标准委员会在C11中新增了以下函数，以解决使用标准转换函数时可能发生的数据丢失问题：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">mbrtoc16, c16rtomb </samp>Converts
    between a sequence of narrow-code units and one or more <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>
    code units
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">mbrtoc16, c16rtomb </samp>在窄字符单元和一个或多个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> 字符单元之间进行转换
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">mbrtoc32, c32rtomb </samp>Converts
    a sequence of narrow-code units to one or more <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>
    code units
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">mbrtoc32, c32rtomb </samp>将窄字符单元的序列转换为一个或多个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> 字符单元
- en: The first two functions convert between locale-dependent character encodings,
    represented as an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    and UTF-16 data stored in an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>
    (assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp>
    has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>). The second
    two functions convert between the locale-dependent encodings and UTF-32 data stored
    in an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> encoded
    data (assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_32__</samp>
    has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>). The program
    shown in [Listing 7-1](chapter7.xhtml#Lis7-1) uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    function to convert a UTF-8 input string to a UTF-16-encoded string.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个函数在区域设置相关的字符编码（以 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    数组表示）和 UTF-16 数据（存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>
    数组中）之间进行转换（假设 <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp>
    的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>）。后两个函数在区域设置相关的编码和存储在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> 数组中的 UTF-32 数据之间进行转换（假设
    <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_32__</samp> 的值为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>）。[清单 7-1](chapter7.xhtml#Lis7-1)
    中的程序使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp> 函数将 UTF-8
    输入字符串转换为 UTF-16 编码字符串。
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: Converting a UTF-8
    string to a</samp> <samp class="I">char16_t</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">string
    with the</samp> <samp class="I">mbrtoc16</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-1：将 UTF-8 字符串转换为</samp>
    <samp class="I">char16_t</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">字符串，使用</samp>
    <samp class="I">mbrtoc16</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数</samp>
- en: We call the <samp class="SANS_TheSansMonoCd_W5Regular_11">setlocale</samp> function
    ❸ to set the multibyte character encoding to UTF-8 by passing an implementation-defined
    string. The static assertion ❶ ensures that the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp>
    has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. (Refer to
    [Chapter 11](chapter11.xhtml) for more information on static assertions.) As a
    result, each call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    function converts a single code point from a UTF-8 representation to a UTF-16
    representation. If the resulting UTF-16 code unit is a high surrogate (from a
    surrogate pair), the <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp>
    object is updated to indicate that the next call to <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    will write out the low surrogate without considering the input string.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">setlocale</samp> 函数 ❸，通过传递一个实现定义的字符串来将多字节字符编码设置为
    UTF-8。静态断言 ❶ 确保宏 <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp>
    的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。（有关静态断言的更多信息，请参阅 [第
    11 章](chapter11.xhtml)）。结果是，每次调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    函数时，都会将 UTF-8 表示的单个代码点转换为 UTF-16 表示。如果结果的 UTF-16 代码单元是高代理（来自代理对），则 <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp>
    对象会更新，指示下一次调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp> 将写出低代理，而无需考虑输入字符串。
- en: There is no string version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    function, so we loop through a UTF-8 input string iteratively, calling the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp> function ❷ to convert
    it to a UTF-16 string. In the case of an encoding error, the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-1</samp>,
    and if the code unit sequence is missing elements, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-2</samp>.
    If either situation occurs, the loop terminates and the conversion ends.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp> 函数没有字符串版本，因此我们会通过一个
    UTF-8 输入字符串进行迭代，调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    函数 ❷ 将其转换为 UTF-16 字符串。如果发生编码错误，<samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    函数将返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-1</samp>，如果代码单元序列缺少元素，则返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-2</samp>。如果发生任何一种情况，循环将终止，转换结束。
- en: A return value of <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-3</samp>
    means that the function has output the high surrogate from a surrogate pair and
    then stored an indicator in the state parameter. The indicator is used the next
    time the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp> function
    is called so it can output the low surrogate from a surrogate pair to form a complete
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> sequence that represents
    a single code point. All restartable encoding conversion functions in the C standard
    behave similarly with the state parameter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-3</samp> 表示该函数已经输出了代理对的高代理字符，并将一个指示符存储在状态参数中。该指示符将在下次调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp> 函数时使用，以便输出代理对的低代理字符，从而形成一个完整的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> 序列，代表一个单一的代码点。所有
    C 标准中的可重启编码转换函数在使用状态参数时行为类似。
- en: If the function returns anything other than <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-2</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-3</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">utf16_idx</samp> index is incremented
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">utf8_idx</samp> index is
    increased by the number of code units read by the function, and the conversion
    of the string continues.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该函数返回的值不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-1</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-2</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-3</samp>，则
    <samp class="SANS_TheSansMonoCd_W5Regular_11">utf16_idx</samp> 索引将增加，<samp class="SANS_TheSansMonoCd_W5Regular_11">utf8_idx</samp>
    索引将根据函数读取的代码单元数量进行增加，字符串的转换将继续进行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">libiconv</samp>
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">libiconv</samp>
- en: GNU <samp class="SANS_TheSansMonoCd_W5Regular_11">libiconv</samp> is a commonly
    used cross-platform, open source library for performing string-encoding conversions.
    It includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">iconv_open</samp>
    function that allocates a conversion descriptor you can use to convert byte sequences
    from one character encoding to another. The documentation for this function (*[https://<wbr>www<wbr>.gnu<wbr>.org<wbr>/software<wbr>/libiconv<wbr>/](https://www.gnu.org/software/libiconv/)*)
    defines strings you can use to identify a particular <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">charset</samp>
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ASCII</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ISO−8859−1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SHIFT_JIS</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">UTF−8</samp>
    to denote the locale-dependent character encoding.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: GNU <samp class="SANS_TheSansMonoCd_W5Regular_11">libiconv</samp> 是一个常用的跨平台开源库，用于执行字符串编码转换。它包含了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">iconv_open</samp> 函数，该函数分配了一个转换描述符，您可以使用它将字节序列从一种字符编码转换到另一种。该函数的文档（*[https://<wbr>www<wbr>.gnu<wbr>.org<wbr>/software<wbr>/libiconv<wbr>/](https://www.gnu.org/software/libiconv/)*)
    定义了可以用来标识特定 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">charset</samp>
    的字符串，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">ASCII</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">ISO−8859−1</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SHIFT_JIS</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">UTF−8</samp>，用来表示与区域相关的字符编码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Win32 Conversion APIs</samp>
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Win32 转换 API</samp>
- en: 'The Win32 SDK provides two functions for converting between wide- and narrow-character
    strings: <samp class="SANS_TheSansMonoCd_W5Regular_11">MultiByteToWideChar</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WideCharToMultiByte</samp>.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Win32 SDK 提供了两个用于在宽字符和窄字符字符串之间转换的函数：<samp class="SANS_TheSansMonoCd_W5Regular_11">MultiByteToWideChar</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">WideCharToMultiByte</samp>。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">MultiByteToWideChar</samp>
    function maps string data that’s encoded in an arbitrary character code page to
    a UTF-16 string. Similarly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">WideCharTo
    MultiByte</samp> function maps string data encoded in UTF-16 to an arbitrary character
    code page. Because UTF-16 data cannot be represented by all code pages, this function
    can specify a default character to use in place of any UTF-16 character that cannot
    be converted.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">MultiByteToWideChar</samp> 函数将用任意字符代码页编码的字符串数据映射到
    UTF-16 字符串。同样，<samp class="SANS_TheSansMonoCd_W5Regular_11">WideCharToMultiByte</samp>
    函数将 UTF-16 编码的字符串数据映射到任意字符代码页。由于并非所有代码页都能表示 UTF-16 数据，因此该函数可以指定一个默认字符，用于替代任何无法转换的
    UTF-16 字符。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Strings</samp>
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">字符串</samp>
- en: 'C doesn’t support a primitive string type and likely never will. Instead, it
    implements strings as arrays of characters. C has two types of strings: narrow
    and wide.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: C 不支持原始的字符串类型，可能永远也不会支持。相反，它通过字符数组实现字符串。C 有两种类型的字符串：窄字符串和宽字符串。
- en: A *narrow string* has the type array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>.
    It consists of a contiguous sequence of characters that includes a terminating
    null character. A pointer to a string references its initial character. The size
    of a string is the number of bytes allocated to the backing array storage. The
    length of a string is the number of code units (bytes) preceding the first null
    character. In [Figure 7-1](chapter7.xhtml#fig7-1), the size of the string is 7,
    and the length of the string is 5\. Elements of the backing array beyond the last
    element must not be accessed. Elements of the array that haven’t been initialized
    must not be read.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*窄字符串* 的类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 数组。它由一系列连续的字符组成，包括终止的空字符。指向字符串的指针引用其初始字符。字符串的大小是分配给后备数组存储的字节数。字符串的长度是位于第一个空字符之前的代码单元（字节）数。在[图
    7-1](chapter7.xhtml#fig7-1)中，字符串的大小为 7，字符串的长度为 5。后备数组中超出最后一个元素的部分不得访问。未初始化的数组元素不得读取。'
- en: '![](../images/f07001.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f07001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: A sample narrow
    string</samp>'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-1：示例窄字符串</samp>
- en: A *wide string* has the type array of <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>.
    It’s a contiguous sequence of wide characters that includes a terminating null
    wide character. A *pointer* to a wide string references its initial wide character.
    The *length* of a wide string is the number of code units preceding the first
    null wide character. [Figure 7-2](chapter7.xhtml#fig7-2) illustrates both the
    UTF-16BE (big-endian) and UTF-16LE (little-endian) representations of *hello*.
    The size of the array is implementation defined. This array is 14 bytes and assumes
    an implementation that has an 8-bit byte and 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type. The length of this string is 5, as the number of characters has not changed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*宽字符串* 的类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 数组。它由一系列连续的宽字符组成，包括终止的空宽字符。指向宽字符串的*指针*引用其初始宽字符。*宽字符串的长度*是位于第一个空宽字符之前的代码单元数。[图
    7-2](chapter7.xhtml#fig7-2)展示了 *hello* 的 UTF-16BE（大端）和 UTF-16LE（小端）表示形式。数组的大小由实现定义。此数组大小为
    14 字节，假设实现使用 8 位字节和 16 位 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    类型。该字符串的长度为 5，因为字符数量没有变化。'
- en: '![](../images/f07002.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f07002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: Sample UTF-16BE
    and UTF-16LE wide strings</samp>'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-2：示例 UTF-16BE 和 UTF-16LE
    宽字符字符串</samp>
- en: Elements of the backing array beyond the last element must not be accessed.
    Elements of the array that haven’t been initialized must not be read.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 后备数组中超出最后一个元素的部分不得访问。未初始化的数组元素不得读取。
- en: <samp class="SANS_Futura_Std_Bold_B_11">String Literals</samp>
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">字符串字面量</samp>
- en: 'A *character string literal* is a string constant represented by a sequence
    of zero or more multibyte characters enclosed in double quotes—for example, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">"ABC"</samp>. You can use various prefixes
    to declare string literals of different character types:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符字符串字面量* 是由零个或多个多字节字符组成的字符串常量，字符用双引号括起来——例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">"ABC"</samp>。你可以使用各种前缀来声明不同字符类型的字符串字面量：'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> string literal type,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">"ABC"</samp>
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 字符串字面量类型，例如 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">"ABC"</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> string literal
    type with <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> prefix, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">L"ABC"</samp>
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 字符串字面量类型，带有 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">L</samp> 前缀，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">L"ABC"</samp>
- en: UTF-8 string literal type with <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp>
    prefix, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">u8"ABC"</samp>
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp> 前缀的 UTF-8 字符串字面量类型，例如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">u8"ABC"</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> string literal
    type with <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> prefix, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">u"ABC"</samp>
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>字符串文字类型，带有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">u</samp>前缀，例如<samp class="SANS_TheSansMonoCd_W5Regular_11">u"ABC"</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> string literal
    type with <samp class="SANS_TheSansMonoCd_W5Regular_11">U</samp> prefix, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">U"ABC"</samp>
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>字符串文字类型，带有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">U</samp>前缀，例如<samp class="SANS_TheSansMonoCd_W5Regular_11">U"ABC"</samp>
- en: The C standard doesn’t mandate that an implementation use ASCII for string literals.
    However, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp>
    prefix to force a string literal to be UTF-8 encoded, and if all the characters
    in the literal are ASCII characters, the compiler will produce an ASCII string
    literal, even if the implementation would normally encode string literals in another
    encoding (for example, EBCDIC).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: C标准并没有强制实现使用ASCII编码的字符串文字。然而，你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp>前缀强制字符串文字使用UTF-8编码。如果字符串中的所有字符都是ASCII字符，编译器会生成ASCII字符串文字，即使实现通常会用其他编码（例如EBCDIC）来编码字符串文字。
- en: A string literal has a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    array type. Modifying a string literal is undefined behavior and prohibited by
    the CERT C rule STR30-C, “Do not attempt to modify string literals.” This is because
    these string literals may be stored in read-only memory, or multiple string literals
    may share the same memory, resulting in multiple strings being altered if one
    string is modified.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串文字具有非<samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>数组类型。修改字符串文字是未定义的行为，并且被CERT
    C规则STR30-C所禁止，规则内容为：“不要尝试修改字符串文字。”这是因为这些字符串文字可能存储在只读内存中，或者多个字符串文字可能共享相同的内存，从而导致在修改一个字符串时，多个字符串也会被改变。
- en: 'String literals often initialize array variables, which you can declare with
    an explicit bound that matches the number of characters in the string literal.
    Consider the following declaration:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串文字常常用来初始化数组变量，你可以通过显式声明一个数组的大小，确保其与字符串文字中的字符数匹配。考虑以下声明：
- en: '[PRE8]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The size of the array <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    is four, the exact size required to initialize the array to the string literal,
    including the space for a trailing null byte.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 数组<samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>的大小是四，这正是初始化数组为字符串文字所需的精确大小，包括末尾的空字符空间。
- en: 'If you add another character to the string literal used to initialize the array,
    however, the meaning of the code changes substantially:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向初始化数组的字符串文字中添加另一个字符，代码的意义会发生显著变化：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The size of the array <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    remains four, although the size of the string literal is now five. As a result,
    the array <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> is initialized
    to the character array <samp class="SANS_TheSansMonoCd_W5Regular_11">"abcd"</samp>
    with the trailing null byte omitted. By design, this syntax allows you to initialize
    a character array and not a string. Therefore, it’s unlikely that your compiler
    will diagnose this declaration as an error.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 数组<samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>的大小仍然是四，尽管字符串文字的大小现在是五。因此，数组<samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp>被初始化为字符数组<samp class="SANS_TheSansMonoCd_W5Regular_11">"abcd"</samp>，并且末尾的空字符被省略了。根据设计，这种语法允许你初始化一个字符数组，而不是字符串。因此，编译器不太可能将此声明诊断为错误。
- en: 'There is some risk that if the string literal changes during maintenance, a
    string could unintentionally be changed to a character array with no terminating
    null character, particularly when the string literal is defined apart from the
    declaration, as in this example. If your intent is to always initialize <samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp> to a string, you should omit
    the array bound. If you don’t specify the bound of the array, the compiler will
    allocate sufficient space for the entire string literal, including the terminating
    null character:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在维护过程中字符串文字发生变化，可能会存在风险，字符串可能无意间变为没有终止空字符的字符数组，特别是当字符串文字与声明分开定义时，就像这个例子中那样。如果你的目的是始终将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp>初始化为字符串，你应该省略数组的大小。如果不指定数组的大小，编译器将为整个字符串文字分配足够的空间，包括终止空字符：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This approach simplifies maintenance because the size of the array can always
    be determined even if the size of the string literal changes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法简化了维护，因为即使字符串字面量的大小发生变化，数组的大小也始终可以确定。
- en: 'The size of arrays declared using this syntax can be determined at compile
    time by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种语法声明的数组大小可以通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    操作符在编译时确定：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If, instead, we declared this string as follows
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改为如下声明这个字符串
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: we would need to invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>
    function to get the length
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> 函数来获取长度。
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: which may incur a runtime cost and is different from the size.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致运行时开销，并且与大小不同。
- en: <samp class="SANS_Futura_Std_Bold_B_11">String-Handling Functions</samp>
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">字符串处理函数</samp>
- en: Several approaches can be used to manage strings in C, the first of which are
    the C standard library functions. Narrow-string-handling functions are defined
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11"><string.h></samp> header
    file and wide-string-handling functions in <samp class="SANS_TheSansMonoCd_W5Regular_11"><wchar.h></samp>.
    These legacy string-handling functions have been associated in recent years with
    various security vulnerabilities. This is because they don’t check the size of
    the array (frequently lacking the information needed to perform such checks) and
    trust you to provide adequately sized character arrays to hold the output. While
    it’s possible to write safe, robust, and error-free code using these functions,
    they promote programming styles that can result in buffer overflows if a result
    is too large for the provided array. These functions aren’t inherently insecure
    but are prone to misuse and need to be used carefully (or not at all).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 管理 C 中字符串的几种方法，其中最常用的是 C 标准库函数。窄字符字符串处理函数在 <samp class="SANS_TheSansMonoCd_W5Regular_11"><string.h></samp>
    头文件中定义，宽字符字符串处理函数在 <samp class="SANS_TheSansMonoCd_W5Regular_11"><wchar.h></samp>
    中定义。这些遗留的字符串处理函数近年来已与各种安全漏洞相关联。这是因为它们没有检查数组的大小（通常缺少执行此类检查所需的信息），并且依赖于你提供足够大的字符数组来存储输出。虽然使用这些函数可以编写安全、健壮且无错误的代码，但它们促进了一种编程风格，这种风格如果结果过大以致无法容纳在提供的数组中，就可能导致缓冲区溢出。这些函数本身并不不安全，但容易被误用，需要小心使用（或者根本不使用）。
- en: As a result, C11 introduced the normative (but optional) Annex K bounds-checking
    interfaces. This annex provides alternative library functions intended to promote
    safer, more secure programming by requiring you to provide the length of output
    buffers, for example, and validating that these buffers are adequately sized to
    contain the output from these functions. For instance, Annex K defines the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat_s</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy_s</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat_s</samp>
    functions as close replacements for the C standard library’s <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp> functions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，C11 引入了规范性的（但可选的）附录 K 边界检查接口。该附录提供了替代库函数，旨在通过要求提供输出缓冲区的长度（例如），并验证这些缓冲区是否足够大以容纳来自这些函数的输出，从而促进更安全、更可靠的编程。例如，附录
    K 定义了 <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">strcat_s</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strncpy_s</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat_s</samp>
    函数，作为 C 标准库中 <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp> 函数的替代品。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11"><string.h> and <wchar.h></samp>
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11"><string.h> 和 <wchar.h></samp>
- en: The C standard library includes well-known functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>,
    and so forth, as well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">memmove</samp> functions that
    you can use to copy and move strings, respectively. The C standard also provides
    a wide-character interface that operates on objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>. (These function
    names are like the narrow-string function names, except that <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>
    is replaced with <samp class="SANS_TheSansMonoCd_W5Regular_11">wcs</samp>, and
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp> is added in front of
    the memory function names.) [Table 7-4](chapter7.xhtml#tab7-4) gives some examples
    of narrow- and wide-character string functions. Refer to the C standard (ISO/IEC
    9899:2024) or man pages for more information on how to use these functions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: C 标准库包括一些众所周知的函数，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>
    等，以及 <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">memmove</samp>
    函数，用于分别复制和移动字符串。C 标准还提供了一个宽字符接口，操作的是 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    类型的对象，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型的对象。（这些函数名称与窄字符串函数名称类似，唯一的区别是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> 被替换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">wcs</samp>，并且内存函数名称前加了一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp>。）[表 7-4](chapter7.xhtml#tab7-4)
    给出了一些窄字符和宽字符字符串函数的示例。有关如何使用这些函数的更多信息，请参考 C 标准（ISO/IEC 9899:2024）或手册页。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-4:</samp> <samp class="SANS_Futura_Std_Book_11">Narrow-
    and Wide-String Functions</samp>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 7-4：</samp> <samp class="SANS_Futura_Std_Book_11">窄字符和宽字符字符串函数</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Narrow (</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">char</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Wide
    (</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">wchar_t</samp><samp class="SANS_Futura_Std_Heavy_B_11">)</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">窄字符（</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">char</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">）</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">宽字符（</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">wchar_t</samp><samp class="SANS_Futura_Std_Heavy_B_11">）</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">描述</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcscpy</samp>
    | <samp class="SANS_Futura_Std_Book_11">String copy</samp> |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcscpy</samp>
    | <samp class="SANS_Futura_Std_Book_11">字符串复制</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsncpy</samp>
    | <samp class="SANS_Futura_Std_Book_11">Truncated, zero-filled copy</samp> |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsncpy</samp>
    | <samp class="SANS_Futura_Std_Book_11">截断的、零填充的复制</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wmemcpy</samp>
    | <samp class="SANS_Futura_Std_Book_11">Copies a specified number of nonoverlapping
    code units</samp> |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wmemcpy</samp>
    | <samp class="SANS_Futura_Std_Book_11">复制指定数量的不重叠代码单元</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memmove</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wmemmove</samp>
    | <samp class="SANS_Futura_Std_Book_11">Copies a specified number of (possibly
    overlapping) code units</samp> |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memmove</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wmemmove</samp>
    | <samp class="SANS_Futura_Std_Book_11">复制指定数量的（可能重叠的）代码单元</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcscat</samp>
    | <samp class="SANS_Futura_Std_Book_11">Concatenates strings</samp> |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcscat</samp>
    | <samp class="SANS_Futura_Std_Book_11">连接字符串</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsncat</samp>
    | <samp class="SANS_Futura_Std_Book_11">Concatenates strings with truncation</samp>
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsncat</samp>
    | <samp class="SANS_Futura_Std_Book_11">连接字符串并进行截断</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strcmp</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcscmp</samp>
    | <samp class="SANS_Futura_Std_Book_11">Compares strings</samp> |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strcmp</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcscmp</samp>
    | <samp class="SANS_Futura_Std_Book_11">比较字符串</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strncmp</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsncmp</samp>
    | <samp class="SANS_Futura_Std_Book_11">Compares truncated strings</samp> |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strncmp</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsncmp</samp>
    | <samp class="SANS_Futura_Std_Book_11">比较截断后的字符串</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strchr</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcschr</samp>
    | <samp class="SANS_Futura_Std_Book_11">Locates a character in a string</samp>
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strchr</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcschr</samp>
    | <samp class="SANS_Futura_Std_Book_11">在字符串中定位字符</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strcspn</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcscspn</samp>
    | <samp class="SANS_Futura_Std_Book_11">Computes the length of a complementary
    string segment</samp> |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strcspn</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcscspn</samp>
    | <samp class="SANS_Futura_Std_Book_11">计算互补字符串段的长度</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsdup</samp>
    | <samp class="SANS_Futura_Std_Book_11">Copies string into allocated storage</samp>
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsdup</samp>
    | <samp class="SANS_Futura_Std_Book_11">将字符串复制到分配的存储空间中</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> | <samp class="SANS_Futura_Std_Book_11">N/A</samp>
    | <samp class="SANS_Futura_Std_Book_11">Truncated copy into allocated storage</samp>
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> | <samp class="SANS_Futura_Std_Book_11">无</samp>
    | <samp class="SANS_Futura_Std_Book_11">截断副本到分配的存储空间</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strpbrk</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcspbrk</samp>
    | <samp class="SANS_Futura_Std_Book_11">Finds the first occurrence of a set of
    characters in a string</samp> |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strpbrk</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcspbrk</samp>
    | <samp class="SANS_Futura_Std_Book_11">查找字符串中字符集的第一次出现</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strrchr</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsrchr</samp>
    | <samp class="SANS_Futura_Std_Book_11">Finds the first occurrence of a character
    in a string</samp> |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strrchr</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsrchr</samp>
    | <samp class="SANS_Futura_Std_Book_11">查找字符串中字符的第一次出现</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strspn</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsspn</samp>
    | <samp class="SANS_Futura_Std_Book_11">Computes the length of a string segment</samp>
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strspn</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsspn</samp>
    | <samp class="SANS_Futura_Std_Book_11">计算字符串段的长度</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strstr</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsstr</samp>
    | <samp class="SANS_Futura_Std_Book_11">Finds a substring</samp> |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strstr</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsstr</samp>
    | <samp class="SANS_Futura_Std_Book_11">查找子字符串</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strtok</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcstok</samp>
    | <samp class="SANS_Futura_Std_Book_11">String tokenizer (modifies the string
    being tokenized)</samp> |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strtok</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcstok</samp>
    | <samp class="SANS_Futura_Std_Book_11">字符串标记器（修改被标记的字符串）</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memchr</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wmemchr</samp>
    | <samp class="SANS_Futura_Std_Book_11">Finds a code unit in memory</samp> |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memchr</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wmemchr</samp>
    | <samp class="SANS_Futura_Std_Book_11">在内存中查找代码单元</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp>
    | <samp class="SANS_Futura_Std_Book_11">Computes string length</samp> |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp>
    | <samp class="SANS_Futura_Std_Book_11">计算字符串长度</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wmemset</samp>
    | <samp class="SANS_Futura_Std_Book_11">Fills memory with a specified code unit</samp>
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wmemset</samp>
    | <samp class="SANS_Futura_Std_Book_11">用指定的编码单元填充内存</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp> | <samp
    class="SANS_Futura_Std_Book_11">N/A</samp> | <samp class="SANS_Futura_Std_Book_11">Like</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> <samp class="SANS_Futura_Std_Book_11">but
    always performed</samp> |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp> | <samp
    class="SANS_Futura_Std_Book_11">N/A</samp> | <samp class="SANS_Futura_Std_Book_11">类似于</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> <samp class="SANS_Futura_Std_Book_11">但始终执行</samp>
    |'
- en: These string-handling functions are considered efficient because they leave
    memory management to the caller and can be used with both statically and dynamically
    allocated storage. In the next couple of sections, I’ll go into more detail on
    some of the more commonly used functions.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符串处理函数被认为是高效的，因为它们将内存管理交给调用者，并且可以与静态和动态分配的存储一起使用。在接下来的几节中，我将更详细地介绍一些常用的函数。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*The wcsdup function listed in [Table 7-4](chapter7.xhtml#tab7-4) is not a
    C standard library function but is defined by POSIX.*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*[表7-4](chapter7.xhtml#tab7-4)中列出的 wcsdup 函数不是 C 标准库函数，而是由 POSIX 定义的。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Size and Length</samp>
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">大小和长度</samp>
- en: 'As mentioned earlier in this chapter, strings have both a size (which is the
    number of bytes allocated to the backing array storage) and a length. You can
    determine the size of a statically allocated backing array at compile time by
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所提到的，字符串有大小（即分配给后台数组存储的字节数）和长度。你可以通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    运算符在编译时确定静态分配的后台数组的大小：
- en: '[PRE14]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can compute the length of a string by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>
    function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> 函数计算字符串的长度：
- en: '[PRE15]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp> function computes
    the length of a wide string measured by the number of code units preceding the
    terminating null wide character:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp> 函数计算宽字符字符串的长度，以终止空宽字符之前的编码单元数为度量标准：
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The length is a count of something, but what exactly is being counted can be
    unclear. Here are some of the things that *could* be counted when taking the length
    of a string:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 长度是某个事物的计数，但究竟计数的是什么可能并不清晰。以下是一些在计算字符串长度时*可能*被计数的内容：
- en: '**Bytes** Useful when allocating storage.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**字节** 在分配存储时很有用。'
- en: '**Code units** Number of individual code units used to represent the string.
    This length depends on encoding and can also be used to allocate memory.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码单元** 表示字符串所使用的单独编码单元的数量。这个长度取决于编码，也可以用于分配内存。'
- en: '**Code points** Code points (characters) can take up multiple code units. This
    value is not useful when allocating storage.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码点** 代码点（字符）可能占用多个编码单元。这个值在分配存储时没有用处。'
- en: '**Extended grapheme cluster** A group of one or more Unicode scalar values
    that approximates a single user-perceived character. Many individual characters,
    such as é, <samp class="SANS_Source_Han_Serif_TC_Regular_11">김</samp>, and <samp
    class="SANS_Source_Han_Serif_SC_Regular_11">![](../images/Flag_pg-154.jpg)</samp>,
    may be constructed from multiple Unicode scalar values. Unicode’s boundary algorithms
    combine these code points into extended grapheme clusters.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展字符簇** 由一个或多个 Unicode 标量值组成，近似于一个用户感知的字符。许多单独的字符，如 é、<samp class="SANS_Source_Han_Serif_TC_Regular_11">김</samp>
    和 <samp class="SANS_Source_Han_Serif_SC_Regular_11">![](../images/Flag_pg-154.jpg)</samp>，可能由多个
    Unicode 标量值构成。Unicode 的边界算法将这些代码点组合成扩展字符簇。'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp>
    functions count code units. For the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>
    function, this corresponds to the number of bytes. Determining the amount of storage
    required by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp>
    function is more complicated because the size of the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type is implementation defined. [Listing 7-2](chapter7.xhtml#Lis7-2) contains
    examples of dynamically allocating storage for both narrow and wide strings.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp>
    函数计算代码单元。对于 <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> 函数，这对应于字节数。使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp> 函数确定所需存储空间更为复杂，因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 类型的大小是由实现定义的。[清单
    7-2](chapter7.xhtml#Lis7-2) 包含了动态分配窄字符串和宽字符串存储空间的示例。
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: Dynamically allocating
    storage for narrow- and wide-string functions</samp>'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-2：动态分配窄字符串和宽字符串函数的存储空间</samp>
- en: For narrow strings, we can determine the size of the string by adding <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to the return value of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function to account for
    the terminating null character. For wide strings, we can determine the size of
    the string by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to
    the return value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp>
    function to account for the terminating null wide character and then multiply
    the sum by the size of the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">str1</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">wstr1</samp> are declared as pointers
    (and not arrays), it’s not possible to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator to obtain their sizes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于窄字符串，我们可以通过将 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> 加到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> 函数的返回值上，以考虑终止空字符的大小。对于宽字符串，我们可以通过将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> 加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp>
    函数的返回值上，以考虑终止宽空字符的大小，然后将总和乘以 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    类型的大小。因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">str1</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">wstr1</samp>
    被声明为指针（而不是数组），所以不能使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    运算符来获取它们的大小。
- en: Code point or extended grapheme cluster counts cannot be used for storage allocation
    because they consist of an unpredictable number of code units. (For an interesting
    exposition on string length, see “It’s Not Wrong that <samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp><samp
    class="SANS_AppleColorEmoji_black_Regular_11">![](../images/manpalm.jpg)</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">".length</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp>” at *[https://<wbr>hsivonen<wbr>.fi<wbr>/string<wbr>-length<wbr>/](https://hsivonen.fi/string-length/)*.)
    Extended grapheme clusters are used to determine where to truncate a string, for
    example, because of a lack of storage. Truncation at extended grapheme cluster
    boundaries avoids slicing user-perceived characters.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 代码点或扩展字形集计数不能用于存储分配，因为它们包含不可预测数量的代码单元。（有关字符串长度的有趣论述，请参阅“它并不错误，`"</samp><samp
    class="SANS_AppleColorEmoji_black_Regular_11">![](../images/manpalm.jpg)</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">".length</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp>” *[https://<wbr>hsivonen<wbr>.fi<wbr>/string<wbr>-length<wbr>/](https://hsivonen.fi/string-length/)*.)
    扩展字形集用于确定何时截断字符串，例如由于存储不足。通过在扩展字形集边界处截断，可以避免切割用户感知的字符。
- en: 'Calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function
    can be an expensive operation because it needs to traverse the length of the array
    looking for a null character. The following is a straightforward implementation
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> 函数可能是一个昂贵的操作，因为它需要遍历数组的长度以查找空字符。以下是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> 函数的直接实现：
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function has
    no way of knowing the size of the object referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>.
    If you call <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> with an
    invalid string that lacks a null character before the bound, the function will
    access the array beyond its end, resulting in undefined behavior. Passing a null
    pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> will also
    result in undefined behavior (a null-pointer dereference). This implementation
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function also
    has undefined behavior for strings larger than <samp class="SANS_TheSansMonoCd_W5Regular_11">PTRDIFF_MAX</samp>.
    You should refrain from creating such objects (in which case this implementation
    is fine).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>函数无法知道<samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>所引用的对象的大小。如果你使用一个缺少空字符的无效字符串调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>，函数将访问数组的边界之外，导致未定义行为。将空指针传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>也会导致未定义行为（空指针解引用）。此版本的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>函数对于大于<samp class="SANS_TheSansMonoCd_W5Regular_11">PTRDIFF_MAX</samp>的字符串也会导致未定义行为。你应该避免创建这样的对象（在这种情况下，此实现是可行的）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">strcpy</samp>
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">strcpy</samp>
- en: Calculating the size of dynamically allocated memory is not always easy. One
    approach is to store the size when allocating and reuse this value later. The
    code snippet in [Listing 7-3](chapter7.xhtml#Lis7-3) uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    function to make a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>
    by determining the length and then adding <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    to accommodate the terminating null character.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 计算动态分配内存的大小并不总是容易的。一种方法是在分配时存储大小，并稍后重新使用该值。[清单 7-3](chapter7.xhtml#Lis7-3)中的代码片段使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>函数通过确定长度并加上<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>来适应终止空字符，从而复制了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">str</samp>。
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: Copying a string</samp>'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-3：复制字符串</samp>
- en: We can then use the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">str_size</samp>
    to dynamically allocate the storage for the copy. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    function copies the string from the source string (<samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>)
    to the destination string (<samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>),
    including the terminating null character. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    function returns the address of the beginning of the destination string, which
    is ignored in this example.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用存储在<samp class="SANS_TheSansMonoCd_W5Regular_11">str_size</samp>中的值来动态分配用于复制的存储空间。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>函数将字符串从源字符串（<samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>）复制到目标字符串（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>），包括终止空字符。<samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>函数返回目标字符串开始的地址，在此示例中被忽略。
- en: 'The following is a simple implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单实现的<samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>函数：
- en: '[PRE20]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code saves a pointer to the destination string in <samp class="SANS_TheSansMonoCd_W5Regular_11">save</samp>
    (to use as the return value) before copying all the bytes from the source to the
    destination array. The <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop terminates when the first null byte is copied. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    doesn’t know the length of the source string or the size of the destination array,
    it assumes that all the function’s arguments have been validated by the caller,
    allowing the implementation to simply copy each byte from the source string to
    the destination array without performing any checks.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在复制源数组到目标数组之前，将指向目标字符串的指针保存在<samp class="SANS_TheSansMonoCd_W5Regular_11">save</samp>中（作为返回值使用）。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环在复制第一个空字节时终止。由于<samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>不知道源字符串的长度或目标数组的大小，它假设所有函数的参数都已由调用者验证，从而使得实现能够简单地将每个字节从源字符串复制到目标数组，而无需执行任何检查。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Argument Checking</samp>
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">参数检查</samp>
- en: Argument checking can be performed by either the calling function or the called
    function. Redundant argument testing by both the caller and the callee is a largely
    discredited style of defensive programming. The usual discipline is to require
    validation on only one side of each interface.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 参数检查可以由调用函数或被调用函数执行。调用方和被调用方都进行冗余的参数测试是一种已经被广泛摒弃的防御性编程风格。通常的做法是只在每个接口的一方进行验证。
- en: 'The most time-efficient approach is for the caller to perform the check, because
    the caller should have a better understanding of the program state. In [Listing
    7-3](chapter7.xhtml#Lis7-3), we can see that the arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    are valid without introducing further redundant tests: the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>
    references a statically allocated array that was properly initialized in the declaration,
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp> parameter is
    a valid non–null pointer referencing dynamically allocated storage of sufficient
    size to hold a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>,
    including the null character. Therefore, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    is safe, and the copy can be performed in a time-efficient manner. This approach
    to argument checking is commonly used by C standard library functions because
    it adheres to the “spirit of C,” in that it’s optimally efficient and trusts the
    programmer (to pass valid arguments).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最节省时间的方法是由调用方进行检查，因为调用方应该对程序的状态有更好的理解。在[示例 7-3](chapter7.xhtml#Lis7-3)中，我们可以看到对
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> 的参数进行的检查是有效的，并且没有引入额外的冗余测试：变量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> 引用的是在声明中已正确初始化的静态分配数组，而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp> 参数是一个有效的非空指针，引用的是足够大的动态分配存储，可以容纳
    <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> 的副本，包括空字符。因此，调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> 是安全的，并且可以以高效的方式执行复制。此种参数检查方法通常被C标准库函数使用，因为它符合“C的精神”，即最优化效率并信任程序员（传递有效的参数）。
- en: The safer, more secure approach is for the callee to check the arguments. This
    approach is less error-prone because the library function implementer validates
    the arguments, so we no longer need to trust the programmer to pass valid ones.
    The function implementer is usually in a better position to understand which arguments
    need to be validated. If the input validation code is defective, the repair needs
    to be made in only one place. All the code to validate the arguments is in one
    place, so this approach can be more space efficient. However, because these tests
    run even when unnecessary, they can also be less time efficient. Frequently, the
    caller of these functions will place checks before suspect calls that may or may
    not already perform similar checks. This approach would also impose additional
    error handling on callees that don’t currently return error indications but would
    presumably need to if they validated arguments. For strings, the called function
    can’t always determine whether the argument is a valid null-terminated string
    or points to sufficient space to make a copy.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 更安全、更可靠的方法是由被调用方检查参数。这种方法出错的可能性较小，因为库函数的实现者会验证参数，因此我们不再需要信任程序员传递有效的参数。函数的实现者通常更能理解需要验证哪些参数。如果输入验证代码存在缺陷，修复只需要在一个地方进行。所有验证参数的代码都集中在一个地方，因此这种方法可以更高效地利用空间。然而，由于这些测试即使在不必要时也会运行，它们的时间效率可能较低。通常，调用这些函数的程序员会在可疑的调用之前进行检查，可能会对已经执行过类似检查的代码进行重复检查。这种方法还会给那些目前没有返回错误指示的被调用方带来额外的错误处理负担，但如果它们进行参数验证，可能就需要返回错误指示了。对于字符串，被调用函数并不总是能够确定参数是否是有效的空终止字符串，或者是否有足够的空间进行复制。
- en: The lesson here is don’t assume that the C standard library functions validate
    arguments unless the standard explicitly requires them to.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是，不要假设C标准库函数会验证参数，除非标准明确要求它们进行验证。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">memcpy</samp>
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">memcpy</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp> function copies
    <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> characters from the
    object referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    into the object referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp> 函数将 <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>
    个字符从 <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> 所引用的对象复制到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dest</samp> 所引用的对象中：
- en: '[PRE21]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>
    function instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    to copy strings when the size of the destination array is larger than or equal
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> argument to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>, the source array contains
    a null character before the bound, and the string length is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">size
    - 1</samp> (so that the resulting string will be properly null terminated). The
    best advice is to use <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    when copying a string and <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>
    when copying only raw, untyped memory. Also remember that the assignment (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>) operator can efficiently copy
    objects in many cases.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当目标数组的大小大于或等于传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> 参数时，可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>
    函数代替 <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> 复制字符串，前提是源数组在边界之前包含一个空字符，并且字符串长度小于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">size - 1</samp>（以确保生成的字符串正确地以空字符结束）。最好的建议是，当复制字符串时使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>，而仅在复制原始未类型化的内存时使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>。同时记住，赋值（<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>）运算符在许多情况下可以高效地复制对象。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">memccpy</samp>
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">memccpy</samp>
- en: 'Most of the C standard library’s string-handling functions return a pointer
    to the beginning of the string passed as an argument so that you can nest calls
    to string functions. For example, the following sequence of nested function calls
    constructs a full name using a Western naming order by copying, then concatenating,
    the constituent parts:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 C 标准库的字符串处理函数返回指向传递作为参数的字符串开头的指针，因此你可以将字符串函数的调用嵌套起来。例如，以下的嵌套函数调用序列通过复制并连接组成部分，使用西方的命名顺序构造一个全名：
- en: '[PRE22]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, piecing together the array <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    from its constituent substrings requires <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    to be scanned many more times than necessary; it would have been more useful for
    the string-handling functions to return pointers to the *end* of the modified
    string to eliminate this need for rescanning. C23 introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    function with a better interface design. POSIX environments should already provide
    this, but you may need to enable its declaration as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将数组 <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> 从其组成子字符串拼接起来需要多次扫描
    <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>，这是不必要的；如果字符串处理函数返回指向修改后字符串*末尾*的指针，能够避免这种需要重新扫描的情况。C23
    引入了具有更好接口设计的 <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> 函数。POSIX
    环境应该已经提供了这个函数，但你可能需要启用它的声明，方法如下：
- en: '[PRE23]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function has
    the following signature:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> 函数具有以下签名：
- en: '[PRE24]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Like the <samp class="SANS_TheSansMonoCd_W5Regular_11">memchr</samp> function,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> scans the source
    sequence for the first occurrence of a character specified by one of its arguments.
    The character can have any value, including zero. It copies (at most) the specified
    number of characters from the source to the destination, without writing beyond
    the end of the destination buffer. Finally, it returns a pointer just past the
    copy of the specified character if it exists.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 <samp class="SANS_TheSansMonoCd_W5Regular_11">memchr</samp> 函数，<samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    函数扫描源序列，查找其参数之一指定的第一个字符。该字符可以具有任何值，包括零。它从源复制（最多）指定数量的字符到目标中，不会写入目标缓冲区的末尾之外。最后，如果指定的字符存在，它会返回指向该字符副本后一个位置的指针。
- en: '[Listing 7-4](chapter7.xhtml#Lis7-4) reimplements the preceding sequence of
    nested string-handling function calls using the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    function. This implementation is more performant and secure.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-4](chapter7.xhtml#Lis7-4) 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    函数重新实现了前面的嵌套字符串处理函数调用序列。这个实现更高效且更安全。'
- en: '[PRE25]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-4: String concatenation
    with</samp> <samp class="I">memccpy</samp>'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-4：使用</samp> <samp class="I">memccpy</samp>
    进行字符串连接
- en: '[Listing 7-4](chapter7.xhtml#Lis7-4) defines the variadic function <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp>
    that accepts a buffer (<samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>)
    and buffer length (<samp class="SANS_TheSansMonoCd_W5Regular_11">buff_length</samp>)
    as fixed arguments and a variable list of string arguments. A null pointer is
    used as the sentinel value to indicate the end of the variable-length argument
    list. The <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function
    is invoked ❶ to concatenate each string to the buffer. As previously noted, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> returns a pointer just
    past the copy of the specified character, which in this case is the null termination
    character <samp class="SANS_TheSansMonoCd_W5Regular_11">''\0''</samp>.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-4](chapter7.xhtml#Lis7-4) 定义了一个变参函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp>，该函数接受一个缓冲区（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>）和缓冲区长度（<samp class="SANS_TheSansMonoCd_W5Regular_11">buff_length</samp>）作为固定参数，以及一个可变数量的字符串参数。空指针作为哨兵值，用于指示可变长度参数列表的结束。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> 函数被调用 ❶ 来将每个字符串连接到缓冲区。正如前面所提到的，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> 返回一个指针，指向指定字符复制后的下一个位置，在本例中是空终止字符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">''\0''</samp>。'
- en: Instead of nesting calls, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    for each string argument passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp>
    and store the return value in <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>.
    This allows you to concatenate directly to the end of the string instead of having
    to find the null termination character each time, making this solution more performant.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再嵌套调用，而是为传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp>
    的每个字符串参数调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> 并将返回值存储在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> 中。这样可以直接在字符串的末尾进行连接，而无需每次都找到空终止字符，从而使这个方案更加高效。
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> is a null pointer,
    we couldn’t copy the entire string. Instead of returning a partial name in this
    case, we return an empty string. This empty string can be printed or treated as
    an error condition.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> 是一个空指针，我们无法复制整个字符串。在这种情况下，我们不会返回部分名称，而是返回一个空字符串。这个空字符串可以被打印出来或视为错误条件。
- en: Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function
    returns a pointer to the character *after* the copy of the null byte, we decrement
    <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> using the prefix decrement
    operator and then subtract the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    to obtain a new <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> ❷.
    The size argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    function (which it uses to prevent buffer overflow) is calculated by subtracting
    <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">buff_length</samp>.
    This is a more secure approach than nested function calls, which are always suspect
    because there is no way to check for an error.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> 函数返回一个指向复制的空字节后*一个*字符的指针，所以我们使用前缀递减操作符来递减
    <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>，然后减去 <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    中存储的值，以获得新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> ❷。传递给
    <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> 函数的大小参数（该函数用来防止缓冲区溢出）是通过将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> 从 <samp class="SANS_TheSansMonoCd_W5Regular_11">buff_length</samp>
    中减去来计算的。这种方法比嵌套函数调用更安全，因为嵌套函数调用总是有问题，因为无法检查是否发生了错误。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">memset, memset_s, and memset_explicit</samp>
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">memset, memset_s 和 memset_explicit</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function copies
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">(unsigned char)c</samp>
    into each of the first <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    characters of the object pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> 函数将 <samp class="SANS_TheSansMonoCd_W5Regular_11">(unsigned
    char)c</samp> 的值复制到由 <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> 指向的对象的前
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> 个字符中：
- en: '[PRE26]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function is
    frequently used to clear memory—for example, to initialize memory allocated by
    <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> to zero. However,
    in the following example, it’s used incorrectly:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> 函数常用于清除内存——例如，将通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 分配的内存初始化为零。然而，在下面的示例中，它被错误地使用了：
- en: '[PRE27]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: One problem with the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_password</samp>
    function is that it uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    function to clear an automatic variable after it has been read for the last time.
    This is being done for security reasons to make sure that the sensitive information
    stored here is inaccessible. However, the compiler doesn’t know that and may perform
    a “dead store” optimization. This is when a compiler notices a write is not followed
    by a read, and just like this book, there is no sense in writing it if no one
    is going to read it. Consequently, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_password</samp> function
    is likely to be removed by the compiler.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">get_password</samp> 函数的一个问题是，它使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> 函数在最后一次读取后清除一个自动变量。这样做是出于安全原因，确保存储在此处的敏感信息无法访问。然而，编译器并不知道这一点，并且可能执行“死存储”优化。这是当编译器发现一个写操作后没有随之而来的读操作时，它会删除该写操作，就像本书一样，如果没有人会读取它，就没有理由写它。因此，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_password</samp> 函数中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    调用可能会被编译器移除。
- en: This problem was meant to be addressed in C11 by the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_s</samp>
    function from Annex K bounds-checking interfaces (discussed in the next section).
    Unfortunately, this function has not been implemented by any compiler mentioned
    in this book.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题本应在 C11 中通过附录 K 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_s</samp>
    函数来解决（将在下一节中讨论）。不幸的是，本书中提到的任何编译器都没有实现这个函数。
- en: To solve this problem again, C23 introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp>
    function for making sensitive information inaccessible. In contrast to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function, the intention
    is that the memory store is always performed (that is, never elided), regardless
    of optimizations.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，C23 引入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp>
    函数，用于使敏感信息无法访问。与 <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> 函数不同，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp> 的目的是始终执行内存存储（即从不省略），无论优化如何。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">gets</samp>
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">gets</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function is a
    flawed input function that accepts input without providing any way to specify
    the size of the destination array. For that reason, it cannot prevent buffer overflows.
    As a result, the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function
    was deprecated in C99 and eliminated from C11\. However, it has been around for
    many years, and most libraries still provide an implementation for backward compatibility,
    so you may see it in the wild. You should *never* use this function, and you should
    replace any use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>
    function you find in any code you’re maintaining.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> 函数是一个有缺陷的输入函数，它接受输入，但没有提供任何方式来指定目标数组的大小。因此，它无法防止缓冲区溢出。因此，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> 函数在 C99 中被弃用，并在 C11 中被删除。然而，它已经存在了多年，大多数库仍然为向后兼容提供实现，因此你可能会在实际代码中看到它。你*绝不*应该使用这个函数，而且你应该替换你在维护的任何代码中找到的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> 函数的使用。
- en: Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function
    is so bad, we’ll spend some time examining why it’s so awful. The function shown
    in [Listing 7-5](chapter7.xhtml#Lis7-5) prompts the user to enter either <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    to indicate whether they’d like to continue.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于<samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>函数非常糟糕，我们将花一些时间来分析它为何如此糟糕。[清单
    7-5](chapter7.xhtml#Lis7-5)中的函数提示用户输入<samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">n</samp>来表示他们是否希望继续。
- en: '[PRE28]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-5: Misuse of the
    obsolete</samp> <samp class="I">gets</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-5：错误使用了过时的</samp> <samp
    class="I">gets</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数</samp>
- en: This function has undefined behavior if more than eight characters are entered
    at the prompt. This undefined behavior occurs because the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>
    function has no way of knowing how large the destination array is and will write
    beyond the end of the array object.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在提示时输入超过八个字符，该函数将表现出未定义行为。此未定义行为发生是因为<samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>函数无法知道目标数组的大小，并且会写入数组对象的末尾以外的内存区域。
- en: '[Listing 7-6](chapter7.xhtml#Lis7-6) shows a simplified implementation of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function. As you can
    see, the caller of this function has no way to limit the number of characters
    read.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-6](chapter7.xhtml#Lis7-6)展示了一个简化版的<samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>函数实现。如你所见，调用此函数的用户无法限制读取的字符数量。'
- en: '[PRE29]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-6: A</samp> <samp
    class="I">gets</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    implementation</samp>'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-6：一个</samp> <samp class="I">gets</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数实现</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function iterates
    reading a character at a time. The loop terminates if either an <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    or newline <samp class="SANS_TheSansMonoCd_W5Regular_11">'\n'</samp> character
    is read. Otherwise, the function will continue to write to the <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>
    array without concern for the boundaries of the object.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>函数通过一次读取一个字符的方式进行迭代。如果读取到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>或换行符<samp class="SANS_TheSansMonoCd_W5Regular_11">'\n'</samp>字符，循环终止。否则，函数将继续向<samp
    class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>数组写入数据，而不考虑对象的边界。
- en: '[Listing 7-7](chapter7.xhtml#Lis7-7) shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_y_or_n</samp>
    function from [Listing 7-5](chapter7.xhtml#Lis7-5) with the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>
    function inlined.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-7](chapter7.xhtml#Lis7-7)展示了来自[清单 7-5](chapter7.xhtml#Lis7-5)的<samp class="SANS_TheSansMonoCd_W5Regular_11">get_y_or_n</samp>函数，并将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>函数内联。'
- en: '[PRE30]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-7: A poorly written</samp>
    <samp class="I">while</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-7：一个写得很糟糕的</samp> <samp
    class="I">while</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">循环</samp>
- en: The size of the destination array is now available, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop ❶ doesn’t use this information. You should ensure that reaching the bound
    of the array is a loop termination condition when reading or writing to an array
    in a loop such as this one.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 目标数组的大小现在是已知的，但<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环❶没有使用这个信息。你应该确保在像这样的循环中读取或写入数组时，将达到数组边界作为循环终止的条件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Annex K Bounds-Checking
    Interfaces</samp>
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">附录 K 边界检查接口</samp>
- en: C11 introduced the Annex K bounds-checking interfaces with alternative functions
    that verify that output buffers are large enough for the intended result and return
    a failure indicator if they aren’t. These functions are designed to prevent writing
    data past the end of an array and to null-terminate all string results. These
    string-handling functions leave memory management to the caller, and memory can
    be statically or dynamically allocated before the functions are invoked.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: C11引入了附录K边界检查接口，提供了验证输出缓冲区是否足够大以容纳预期结果的替代函数，如果缓冲区不够大，则返回失败指示符。这些函数旨在防止数据写入数组末尾之外，并确保所有字符串结果都以null结尾。这些字符串处理函数将内存管理留给调用者，内存可以在调用这些函数之前静态或动态分配。
- en: Microsoft created the C11 Annex K functions to help retrofit its legacy code
    base in response to numerous, well-publicized security incidents in the 1990s.
    These functions were then proposed to the C standards committee for standardization,
    published as ISO/IEC TR 24731-1 (ISO/IEC TR 24731-1:2007) and then later incorporated
    into C11 as an optional annex. Despite the improved usability and security provided
    by these functions, they aren’t yet widely implemented at the time of writing.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 微软创建了C11附录K函数，帮助其改进旧代码库，以应对1990年代许多广为人知的安全事件。随后，这些函数被提议提交给C标准委员会进行标准化，并作为ISO/IEC
    TR 24731-1（ISO/IEC TR 24731-1:2007）发布，之后又被纳入C11作为可选附录。尽管这些函数提供了更好的可用性和安全性，但在写作时，它们尚未广泛实现。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">gets_s</samp>
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">gets_s</samp>
- en: The Annex K bounds-checking interface has a <samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp>
    function we can use to eliminate the undefined behavior caused by the call to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> in [Listing 7-5](chapter7.xhtml#Lis7-5),
    as shown in [Listing 7-8](chapter7.xhtml#Lis7-8).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 附录K边界检查接口提供了一个可以用来消除调用[Listing 7-5](chapter7.xhtml#Lis7-5)中<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp></sup>函数所引起的未定义行为的<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp></sup>函数，具体如[Listing 7-8](chapter7.xhtml#Lis7-8)所示。
- en: '[PRE31]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-8: Use of the</samp>
    <samp class="I">gets_s</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-8: 使用</samp> <samp
    class="I">gets_s</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数</samp>'
- en: The two functions are similar, except that the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp>
    function checks the array bounds. The default behavior when the maximum number
    of characters input is exceeded is implementation defined, but typically the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">abort</samp> function is called. You can
    change this behavior via the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp>
    function, which I’ll explain further in “Runtime Constraints” on [page 163](#pg_163).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数类似，区别在于<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp></sup>函数会检查数组的边界。当输入的字符数超过最大值时，默认行为是由实现定义的，但通常会调用<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">abort</samp></sup>函数。你可以通过<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp></sup>函数来改变这一行为，稍后我会在“运行时约束”一节中进一步解释，在[第163页](#pg_163)中可以找到。
- en: You need to define <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_WANT_LIB_EXT1__</samp>
    as a macro that expands to the integer constant <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    before including the header files that define the bounds-checking interfaces to
    allow them to be used in your program. Unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>
    function, the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp> function
    takes a size argument. Consequently, the revised function calculates the size
    of the destination array by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator and passes this value as an argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp>
    function. The implementation-defined behavior is the result of the runtime-constraint
    violation.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_WANT_LIB_EXT1__</samp></sup>定义为一个宏，并使其扩展为整数常量<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp></sup>，然后在包含定义边界检查接口的头文件之前使用该宏，以便在程序中使用这些接口。与<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">gets</samp></sup>函数不同，<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp></sup>函数需要一个大小参数。因此，修改后的函数通过使用<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp></sup>运算符计算目标数组的大小，并将该值作为参数传递给<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp></sup>函数。实现定义的行为是由于运行时约束违规导致的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">strcpy_s</samp>
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">strcpy_s</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function
    is a close replacement for the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    function defined in <samp class="SANS_TheSansMonoCd_W5Regular_11"><string.h></samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function copies
    characters from a source string to a destination character array up to and including
    the terminating null character. Here’s the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>
    signature:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>函数是对定义在<samp class="SANS_TheSansMonoCd_W5Regular_11"><string.h></samp>中的<code>strcpy</code>函数的一个近似替代。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>函数将字符从源字符串复制到目标字符数组中，直到并包括终止的空字符。以下是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>函数的签名：
- en: '[PRE32]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function
    has an extra argument of type <samp class="SANS_TheSansMonoCd_W5Regular_11">rsize_t</samp>
    that specifies the maximum length of the destination buffer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">rsize_t</samp>
    type is like the <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> type
    except that functions that accept an argument of this type test to make sure that
    the value is not greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">RSIZE_MAX</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function succeeds
    only when it can fully copy the source string to the destination without overflowing
    the destination buffer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>
    function verifies that the following runtime constraints aren’t violated:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>函数有一个额外的类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">rsize_t</samp>的参数，用来指定目标缓冲区的最大长度。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">rsize_t</samp>类型与<samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>类型类似，除了接受此类型参数的函数会测试以确保该值不大于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RSIZE_MAX</samp>。只有在能够完整地将源字符串复制到目标位置且不导致目标缓冲区溢出时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>函数才会成功。<samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>函数会验证以下运行时约束是否未被违反：
- en: Neither <samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp> nor <samp class="SANS_TheSansMonoCd_W5Regular_11">s2</samp>
    are null pointers.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">s2</samp>都不能是空指针。
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp> is not greater than
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RSIZE_MAX</samp>.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp>不大于<samp class="SANS_TheSansMonoCd_W5Regular_11">RSIZE_MAX</samp>。
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp> does not equal zero.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp>不等于零。
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp> is greater than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">strnlen_s(s2, s1max)</samp>.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp>大于<samp class="SANS_TheSansMonoCd_W5Regular_11">strnlen_s(s2,
    s1max)</samp>。
- en: Copying does not take place between overlapping objects.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制不应发生在重叠的对象之间。
- en: To perform the string copy in a single pass, a <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>
    function implementation retrieves a character (or characters) from the source
    string and copies it to the destination array until it has copied the entire string
    or the destination array is full. If it can’t copy the entire string and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp> is not zero, the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>
    function sets the first byte of the destination array to the null character, creating
    an empty string.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在一次传递中执行字符串复制，<samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>函数的实现会从源字符串中获取一个字符（或多个字符），并将其复制到目标数组中，直到复制完整个字符串或目标数组已满。如果无法复制整个字符串，并且<samp
    class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp>不为零，<samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>函数会将目标数组的第一个字节设置为空字符，从而创建一个空字符串。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Runtime Constraints</samp>
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">运行时约束</samp>
- en: '*Runtime constraints* are violations of a function’s runtime requirements that
    the function will detect and diagnose by a call to a handler. If this handler
    returns, the functions will return a failure indicator to the caller.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*运行时约束*是违反函数运行时要求的情况，函数会通过调用处理程序来检测和诊断这些情况。如果处理程序返回，函数将向调用者返回失败指示符。'
- en: 'The bounds-checking interfaces enforce runtime constraints by invoking a runtime-constraint
    handler, which may simply return. Alternatively, the runtime-constraint handler
    might print a message to <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>
    and/or abort the program. You can control which handler function is called via
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp>
    function and make the handler simply return as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 边界检查接口通过调用运行时约束处理程序来强制执行运行时约束，处理程序可以简单地返回。或者，运行时约束处理程序可能会向 <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>
    打印消息和/或中止程序。你可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp>
    函数控制调用哪个处理程序函数，并使处理程序按如下方式简单地返回：
- en: '[PRE33]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If the handler returns, the function that identified the runtime-constraint
    violation and invoked the handler indicates a failure to its caller by using its
    return value.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理程序返回，识别运行时约束违反并调用该处理程序的函数将通过返回值向其调用者指示失败。
- en: The bounds-checking interface functions typically check the conditions either
    immediately upon entry or as they perform their tasks and gather sufficient information
    to determine whether a runtime constraint has been violated. The runtime constraints
    of the bounds-checking interfaces are conditions that would otherwise be undefined
    behavior for C standard library functions.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 边界检查接口函数通常会在进入时立即检查条件，或者在执行任务并收集足够的信息来确定是否违反了运行时约束时进行检查。边界检查接口的运行时约束是指那些在 C
    标准库函数中会导致未定义行为的条件。
- en: Implementations have a default constraint handler that they invoke if no calls
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp>
    function have been made. The default handler’s behavior may cause the program
    to exit or abort, but implementations are encouraged to provide reasonable behavior
    by default. This allows, for example, compilers customarily used to implement
    safety-critical systems to not abort by default. You must check the return value
    of calls to functions that can return and not simply assume their results are
    valid. Implementation-defined behavior can be eliminated by invoking the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp> function
    before invoking any bounds-checking interfaces or using any mechanism that invokes
    a runtime-constraint handler.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 实现中有一个默认的约束处理程序，如果没有调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp>
    函数，它将被调用。默认处理程序的行为可能导致程序退出或中止，但建议实现提供合理的默认行为。例如，通常用于实现安全关键系统的编译器可以默认不进行中止。你必须检查可以返回的函数的返回值，而不是简单地假设其结果有效。在调用任何边界检查接口或使用任何调用运行时约束处理程序的机制之前，必须通过调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp>
    函数来消除实现定义的行为。
- en: Annex K provides the <samp class="SANS_TheSansMonoCd_W5Regular_11">abort_handler_s</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ignore_handler_s</samp> functions,
    which represent two common strategies for handling errors. The C implementation’s
    default handler need not be either of these handlers.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 K 提供了 <samp class="SANS_TheSansMonoCd_W5Regular_11">abort_handler_s</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ignore_handler_s</samp> 函数，它们代表两种常见的错误处理策略。C
    实现的默认处理程序不一定是这两者之一。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">POSIX</samp>
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">POSIX</samp>
- en: POSIX also defines several string-handling functions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> (IEEE Std 1003.1:2018),
    that provide another set of string-related APIs for POSIX-compliant platforms
    such as GNU/Linux and Unix (IEEE Std 1003.1:2018). Both functions were adopted
    into the C standard library by C23.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 还定义了几个字符串处理函数，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp>（IEEE Std 1003.1:2018），为如
    GNU/Linux 和 Unix 等符合 POSIX 标准的平台提供了另一组与字符串相关的 API（IEEE Std 1003.1:2018）。这两个函数已被
    C23 版本的 C 标准库采用。
- en: These replacement functions use dynamically allocated memory to ensure that
    buffer overflows don’t occur, and they implement a *callee allocates, caller frees*
    model. Each function ensures that enough memory is available (except when a call
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> fails). The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> function, for example, returns
    a pointer to a new string that contains a duplicate of the argument. The returned
    pointer should be passed to the C standard <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    function to reclaim the storage when it’s no longer needed.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这些替代函数使用动态分配的内存，以确保不会发生缓冲区溢出，并且它们实现了*被调用者分配，调用者释放*的模型。每个函数都确保有足够的内存可用（除非调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 失败）。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>
    函数返回指向一个新字符串的指针，该字符串包含参数的副本。返回的指针应传递给 C 标准库的 <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    函数，以便在不再需要时回收存储空间。
- en: '[Listing 7-9](chapter7.xhtml#Lis7-9) contains a code snippet that uses the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> function to make a
    copy of the string returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">getenv</samp>
    function.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-9](chapter7.xhtml#Lis7-9) 包含一个代码片段，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>
    函数复制由 <samp class="SANS_TheSansMonoCd_W5Regular_11">getenv</samp> 函数返回的字符串。'
- en: '[PRE34]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-9: Copying a string
    using the</samp> <samp class="I">strdup</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 7-9：使用</samp> <samp class="I">strdup</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数复制字符串</samp>
- en: The C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11">getenv</samp>
    function searches an environment list, provided by the host environment, for a
    string that matches the string referenced by a specified name (<samp class="SANS_TheSansMonoCd_W5Regular_11">TMP</samp>
    in this example). Strings in this environment list are referred to as *environment
    variables* and provide an additional mechanism for communicating strings to a
    process. These strings don’t have a well-defined encoding but typically match
    the system encoding used for command line arguments, <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: C 标准库的 <samp class="SANS_TheSansMonoCd_W5Regular_11">getenv</samp> 函数在由主机环境提供的环境列表中搜索与指定名称（例如此处的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TMP</samp>）所引用的字符串匹配的字符串。环境列表中的字符串被称为*环境变量*，它们为向进程传递字符串提供了额外的机制。这些字符串没有明确的编码，但通常与用于命令行参数、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>
    的系统编码匹配。
- en: The returned string (the value of the variable) may be overwritten by a subsequent
    call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">getenv</samp> function,
    so it’s a good idea to retrieve any environmental variable you need before creating
    any threads to eliminate the possibility of a race condition. If later use is
    anticipated, you should copy the string so the copy can be safely referenced as
    needed, as illustrated by the idiomatic example shown in [Listing 7-9](chapter7.xhtml#Lis7-9).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的字符串（变量的值）可能会被随后的 <samp class="SANS_TheSansMonoCd_W5Regular_11">getenv</samp>
    函数调用覆盖，因此在创建任何线程之前，最好先检索所需的任何环境变量，以消除竞态条件的可能性。如果预期以后还会使用该字符串，应该先复制该字符串，这样可以在需要时安全地引用副本，如
    [示例 7-9](chapter7.xhtml#Lis7-9) 中的典型示例所示。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> function is
    equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>, except
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> copies, at most,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> bytes into the newly allocated
    memory (while <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> copies
    the entire string) and ensures that the newly created string is always properly
    terminated.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> 函数与 <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>
    等效，不同之处在于 <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> 最多将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">n</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> 字节复制到新分配的内存中（而 <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>
    复制整个字符串），并确保新创建的字符串总是正确终止。
- en: These POSIX functions can help prevent buffer overflows by automatically allocating
    storage for the resulting strings, but this requires introducing additional calls
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> when this storage
    is no longer needed. This means matching a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    to each call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp>, for example, which
    can be confusing to programmers who are more familiar with the behavior of the
    string functions defined by <samp class="SANS_TheSansMonoCd_W5Regular_11"><string.h></samp>.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 POSIX 函数通过自动分配存储空间来防止缓冲区溢出，但这要求在不再需要这些存储时引入额外的 <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    调用。这意味着需要为每次调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> 等函数匹配一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    调用，这对于更熟悉由 <samp class="SANS_TheSansMonoCd_W5Regular_11"><string.h></samp> 定义的字符串函数行为的程序员来说可能会很混乱。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Microsoft</samp>
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">微软</samp>
- en: Visual C++ provides all the string-handling functions defined by the C standard
    library up to C99 but doesn’t implement the full POSIX specification. However,
    sometimes the Microsoft implementation of these APIs differs from the requirements
    of a given standard or has a function name that conflicts with an identifier reservation
    in another standard. In these circumstances, Microsoft will often prefix the function
    name with an underscore. For instance, the POSIX function <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>
    isn’t available on Windows, but the function <samp class="SANS_TheSansMonoCd_W5Regular_11">_strdup</samp>
    is available and behaves the same way.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Visual C++ 提供了 C 标准库中定义的所有字符串处理函数，直到 C99，但并未实现完整的 POSIX 规范。然而，有时微软对这些 API 的实现与给定标准的要求不同，或者函数名与另一个标准中的标识符预留冲突。在这种情况下，微软通常会在函数名之前加上一个下划线。例如，POSIX
    函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> 在 Windows 上不可用，但
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_strdup</samp> 函数是可用的，并且行为相同。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*For more information on Microsoft’s POSIX support, see* [https://<wbr>docs<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/cpp<wbr>/c<wbr>-runtime<wbr>-library<wbr>/compatibility](https://docs.microsoft.com/en-us/cpp/c-runtime-library/compatibility)*.*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关微软 POSIX 支持的更多信息，请参见* [https://<wbr>docs<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/cpp<wbr>/c<wbr>-runtime<wbr>-library<wbr>/compatibility](https://docs.microsoft.com/en-us/cpp/c-runtime-library/compatibility)*.*'
- en: 'Visual C++ also supports many of the safe string-handling functions from Annex
    K and will diagnose the use of an unsafe variant unless you define <samp class="SANS_TheSansMonoCd_W5Regular_11">_CRT_SECURE_NO_WARNINGS</samp>
    prior to including the header file that declares the function. Unfortunately,
    Visual C++ does not conform to Annex K of the C standard, because Microsoft chose
    not to update its implementation based on changes to the APIs that occurred during
    the standardization process. For example, Visual C++ doesn’t provide the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp> function
    but instead retains an older function with similar behavior but an incompatible
    signature:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Visual C++ 也支持 Annex K 中的许多安全字符串处理函数，并会诊断使用不安全变体的情况，除非在包含声明该函数的头文件之前定义了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">_CRT_SECURE_NO_WARNINGS</samp>。不幸的是，Visual
    C++ 并不符合 C 标准的 Annex K，因为微软选择不更新其实现，以适应标准化过程中对 API 的修改。例如，Visual C++ 不提供 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp> 函数，而是保留了一个行为相似但签名不兼容的旧版本函数：
- en: '[PRE35]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Microsoft also doesn’t define the <samp class="SANS_TheSansMonoCd_W5Regular_11">abort_handler_s</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ignore_handler_s</samp> functions,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_s</samp> function (which
    was not defined by ISO/IEC TR 24731-1), or the <samp class="SANS_TheSansMonoCd_W5Regular_11">RSIZE_MAX</samp>
    macro. Visual C++ also doesn’t treat overlapping source and destination sequences
    as runtime-constraint violations and instead has undefined behavior in such cases.
    “Bounds-Checking Interfaces: Field Experience and Future Directions” (Seacord
    2019) provides additional information on all aspects of the bounds-checked interfaces,
    including Microsoft’s implementation.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '微软也没有定义 <samp class="SANS_TheSansMonoCd_W5Regular_11">abort_handler_s</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ignore_handler_s</samp> 函数，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">memset_s</samp> 函数（该函数未被 ISO/IEC TR 24731-1
    定义），或 <samp class="SANS_TheSansMonoCd_W5Regular_11">RSIZE_MAX</samp> 宏。Visual
    C++ 也不会将重叠的源和目标序列视为运行时约束违规，而是对这种情况有未定义的行为。关于边界检查接口的更多信息，请参见《Bounds-Checking Interfaces:
    Field Experience and Future Directions》（Seacord 2019）。'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, you learned about character encodings, such as ASCII and Unicode.
    You also learned about the various data types used to represent characters in
    C language programs, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>,
    and so forth. We then covered character conversion libraries, including C standard
    library functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">libiconv</samp>,
    and Windows APIs.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了字符编码，如 ASCII 和 Unicode。你还学习了用于表示 C 语言程序中字符的各种数据类型，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    等。然后我们介绍了字符转换库，包括 C 标准库函数、<samp class="SANS_TheSansMonoCd_W5Regular_11">libiconv</samp>
    和 Windows API。
- en: In addition to characters, you also learned about strings and the legacy functions
    and bounds-checked interfaces defined in the C standard library for handling strings,
    as well as some POSIX- and Microsoft-specific functions.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字符，你还学习了字符串以及 C 标准库中用于处理字符串的传统函数和边界检查接口，以及一些 POSIX 和微软特定的函数。
- en: Manipulating character and string data is a common programming task in C as
    well as a frequent source of errors. We outlined various approaches to handling
    these data types; you should determine which approach is best suited to your application
    and apply that approach consistently.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 操作字符和字符串数据是 C 语言中常见的编程任务，也是错误的常见来源。我们概述了处理这些数据类型的各种方法；你应该根据你的应用程序需求选择最适合的方式，并始终如一地应用这种方法。
- en: In the next chapter, you’ll learn about I/O, which, among other things, can
    be used to read and write characters and strings.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习 I/O，它可以用来读取和写入字符和字符串。
