- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CHARACTERS
    AND STRINGS</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">字符与字符串</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Strings are such an important and useful data type that nearly every programming
    language implements them in some form. Often used to represent text, strings constitute
    most of the data exchanged between an end user and a program, including text input
    fields, command line arguments, environment variables, and console input.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是一个非常重要且有用的数据类型，几乎所有的编程语言都会以某种形式实现它。字符串通常用来表示文本，是用户与程序之间交换数据的大多数内容，包括文本输入字段、命令行参数、环境变量和控制台输入。
- en: 'In C, the string data type is modeled on the idea of a formal string (Hopcroft
    and Ullman 1979):'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，字符串数据类型是基于正式字符串的概念建模的（Hopcroft 和 Ullman 1979）：
- en: Let Σ be a non-empty finite set of characters, called the alphabet. A string
    over Σ is any finite sequence of characters from Σ. For example, if Σ = {0, 1},
    then 01011 is a string over Σ.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 设 Σ 为一个非空有限字符集，称为字母表。 Σ 上的字符串是 Σ 中任何有限字符序列。例如，如果 Σ = {0, 1}，那么 01011 就是 Σ 上的一个字符串。
- en: In this chapter, we’ll talk about the various character sets, including ASCII
    and Unicode, that can be used to compose strings (the *alphabet* from the formal
    definition). We’ll cover how strings are represented and manipulated using the
    legacy functions from the C standard library, the bounds-checked interfaces, and
    POSIX and Windows application programming interfaces (APIs).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论可以用来组成字符串的各种字符集，包括 ASCII 和 Unicode（来自正式定义的*字母表*）。我们将介绍如何使用 C 标准库中的传统函数、边界检查接口以及
    POSIX 和 Windows 应用程序编程接口（API）来表示和操作字符串。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Characters</samp>
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">字符</samp>
- en: The characters that people use to communicate aren’t naturally understood by
    digital systems, which operate on bits. To process characters, digital systems
    use *character encodings* that assign unique integer values, referred to as *code
    points*, to designate specific characters. As you’ll see, there are multiple ways
    to encode the same notional character in your program. Common standards used by
    C implementations for encoding characters include Unicode, ASCII, Extended ASCII,
    ISO 8859-1 (Latin-1), Shift-JIS, and EBCDIC.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 人们用来沟通的字符并不是数字系统本能理解的，因为数字系统是基于位操作的。为了处理字符，数字系统使用*字符编码*，将唯一的整数值（称为*码点*）分配给特定的字符。如你所见，有多种方法可以在程序中对相同的字符进行编码。C
    语言实现中常用的字符编码标准包括 Unicode、ASCII、扩展 ASCII、ISO 8859-1（拉丁文-1）、Shift-JIS 和 EBCDIC。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*The C standard explicitly references Unicode and ASCII.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*C 标准明确引用了 Unicode 和 ASCII。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ASCII</samp>
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ASCII</samp>
- en: The *7-bit American Standard Code for Information Interchange*, better known
    as *7-bit ASCII*, specifies a set of 128 characters and their coded representation
    (ANSI X3.4-1986). Characters from <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1f</samp> and character <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x7f</samp> are control characters, such
    as null, backspace, horizontal tab, and DEL. Characters from <samp class="SANS_TheSansMonoCd_W5Regular_11">0x20</samp>
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7e</samp> are all printable
    characters such as letters, digits, and symbols.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*7位美国信息交换标准代码*，更为人熟知的*7位 ASCII*，指定了一组 128 个字符及其编码表示（ANSI X3.4-1986）。从 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1f</samp>
    的字符和字符 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7f</samp> 是控制字符，例如空字符、退格符、水平制表符和删除符。
    从 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x20</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7e</samp>
    的字符是所有可打印字符，如字母、数字和符号。'
- en: We often refer to this standard with the updated name *US-ASCII* to clarify
    that this system was developed in the United States and focuses on the typographical
    symbols predominantly used in this country. Most modern character encoding schemes
    are based on US-ASCII, although they support many additional characters.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用更新后的名称*US-ASCII*来指代这一标准，以明确该系统是在美国开发的，并且专注于该国主要使用的印刷符号。大多数现代字符编码方案都基于
    US-ASCII，尽管它们支持许多附加字符。
- en: Characters in the <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp> range are not defined
    by US-ASCII but are part of the 8-bit character encoding known as *Extended ASCII*.
    Numerous encodings for these ranges exist, and the actual mapping depends on the
    code page. A *code page* is a character encoding that maps a set of printable
    characters and control characters to unique numbers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp>
    范围内的字符不是 US-ASCII 定义的字符，而是属于被称为 *扩展 ASCII* 的 8 位字符编码。这些范围有多个编码方式，实际的映射取决于代码页。*代码页*
    是一种字符编码，它将一组可打印字符和控制字符映射到唯一的数字。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unicode</samp>
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unicode</samp>
- en: '*Unicode* has become the universal character encoding standard for representing
    text in computer processing. It supports a much wider range of characters than
    ASCII does; the current Unicode Standard (Unicode 2023) encodes characters in
    the range <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">U+10FFFF</samp>, which amounts to a 21-bit
    code space. An individual Unicode value is expressed as <samp class="SANS_TheSansMonoCd_W5Regular_11">U+</samp>
    followed by four or more hexadecimal digits in printed text. The Unicode characters
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp>
    are identical to those in US-ASCII, and the range <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+00FF</samp> is identical to
    ISO 8859-1, consisting of characters from the Latin script used throughout the
    Americas, Western Europe, Oceania, and much of Africa.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*Unicode* 已成为计算机处理文本的通用字符编码标准。它支持的字符范围远大于 ASCII；当前的 Unicode 标准（Unicode 2023）对字符进行了编码，范围从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+10FFFF</samp>，这相当于一个
    21 位的编码空间。单个 Unicode 值以 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+</samp>
    开头，后跟四个或更多十六进制数字，表示为印刷文本。Unicode 字符 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp>
    到 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp> 与 US-ASCII 中的字符完全相同，而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+00FF</samp>
    的范围与 ISO 8859-1 相同，包含了拉丁字母字符，这些字符在美洲、西欧、大洋洲以及非洲的大部分地区被使用。'
- en: Unicode organizes code points into *planes*, which are continuous groups of
    65,536 code points. There are 17 planes, identified by the numbers 0 to 16\. The
    most used characters, including those found in major, older encoding standards,
    have been placed into the first plane (<samp class="SANS_TheSansMonoCd_W5Regular_11">0x0000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFF</samp>), which is called
    the *basic multilingual plane (BMP)*, or Plane 0.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 将代码点组织成 *平面*，即连续的 65,536 个代码点的组。共有 17 个平面，编号从 0 到 16。最常用的字符，包括那些出现在主要旧编码标准中的字符，都被放置在第一个平面（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x0000</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFF</samp>）中，这个平面被称为
    *基本多语言平面（BMP）* 或平面 0。
- en: 'Unicode also specifies several *Unicode transformation formats (UTFs)*, which
    are character encoding formats that assign each Unicode scalar value to a unique
    code unit sequence. A *Unicode scalar value* is any Unicode code point except
    high-surrogate and low-surrogate code points. (Surrogate pairs are explained later
    in this section.) A *code unit* is the minimal bit combination that can represent
    encoded text for processing or interchange. The Unicode standard defines three
    UTFs to allow for code units of various sizes:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 还指定了几种 *Unicode 转换格式（UTFs）*，这些是将每个 Unicode 标量值分配给唯一代码单元序列的字符编码格式。*Unicode
    标量值* 是指除高代理项和低代理项外的任何 Unicode 代码点。（代理对将在本节稍后解释。）*代码单元* 是表示用于处理或交换的编码文本的最小位组合。Unicode
    标准定义了三种 UTF，以允许不同大小的代码单元：
- en: '**UTF-8** Represents each character as a sequence of one to four 8-bit code
    units'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**UTF-8** 将每个字符表示为一个到四个 8 位代码单元的序列'
- en: '**UTF-16** Represents each character as a sequence of one or two 16-bit code
    units'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**UTF-16** 将每个字符表示为一个或两个 16 位代码单元的序列'
- en: '**UTF-32** Represents each character as a single 32-bit code unit'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**UTF-32** 将每个字符表示为一个单一的 32 位代码单元'
- en: 'The UTF-8 encoding is the dominant encoding for POSIX operating systems. It
    has the following desirable properties:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 编码是 POSIX 操作系统中的主流编码。它具有以下优点：
- en: It encodes US-ASCII characters (<samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp>) as single bytes
    in the range <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x7F</samp>. This means that files and
    strings that contain only 7-bit ASCII characters have the same encoding under
    both ASCII and UTF-8.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将 US-ASCII 字符（<samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> 到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp>）编码为范围从 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp>
    到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7F</samp> 的单字节。这意味着只包含 7 位 ASCII
    字符的文件和字符串在 ASCII 和 UTF-8 下具有相同的编码方式。
- en: Using a null byte to terminate a string (a topic we’ll discuss later) works
    the same as for an ASCII string.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空字节终止字符串（我们稍后会讨论这个话题）与 ASCII 字符串的处理方式相同。
- en: All currently defined Unicode code points can be encoded using between 1 and
    4 bytes.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前定义的所有 Unicode 码点可以使用 1 到 4 个字节进行编码。
- en: Unicode allows character boundaries to be easily identified by scanning for
    well-defined bit patterns in either direction.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode 通过扫描明确的比特模式，在任意方向上轻松识别字符边界。
- en: On Windows, you can compile and link your programs with the Visual C++ <samp
    class="SANS_TheSansMonoCd_W5Regular_11">/utf8</samp> flag to set the source and
    execution character sets as UTF-8\. You’ll also need to configure Windows to use
    Unicode UTF-8 for worldwide language support.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，你可以使用 Visual C++ 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">/utf8</samp>
    标志编译并链接程序，以将源字符集和执行字符集设置为 UTF-8。你还需要配置 Windows 以使用 Unicode UTF-8 来支持全球语言。
- en: UTF-16 is currently the dominant encoding for Windows operating systems. Like
    UTF-8, UTF-16 is a variable-width encoding. As just mentioned, the BMP consists
    of characters from <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+FFFF</samp>. Characters whose
    code points are greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">U+FFFF</samp>
    are called *supplementary characters*. Supplementary characters are defined by
    a pair of code units called *surrogates*. The first code unit is from the high-surrogates
    range (<samp class="SANS_TheSansMonoCd_W5Regular_11">U+D800</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+DBFF</samp>),
    and the second code unit is from the low-surrogates range (<samp class="SANS_TheSansMonoCd_W5Regular_11">U+DC00</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+DFFF</samp>).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-16 目前是 Windows 操作系统中主流的编码方式。与 UTF-8 类似，UTF-16 是一种可变宽度编码。正如前面提到的，基本多文种平面（BMP）包含从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+FFFF</samp>
    的字符。码点大于 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+FFFF</samp> 的字符被称为 *补充字符*。补充字符由一对称为
    *替代符* 的编码单元定义。第一个编码单元位于高替代符范围（<samp class="SANS_TheSansMonoCd_W5Regular_11">U+D800</samp>
    到 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+DBFF</samp>），第二个编码单元位于低替代符范围（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">U+DC00</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+DFFF</samp>）。
- en: Unlike other variable-length UTFs, UTF-32 is a fixed-length encoding. The main
    advantage of UTF-32 is that the Unicode code points can be directly indexed, meaning
    that you can find the *n*th code point in a sequence of code points in constant
    time. In contrast, a variable-length encoding requires accessing each code point
    to find the *n*th code point in a sequence.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他可变长度 UTF 编码不同，UTF-32 是一种固定长度的编码方式。UTF-32 的主要优点是 Unicode 码点可以直接索引，这意味着你可以在常数时间内找到序列中第
    *n* 个码点。相比之下，可变长度编码需要访问每个码点，才能找到序列中的第 *n* 个码点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Source and Execution
    Character Sets</samp>
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">源字符集和执行字符集</samp>
- en: No universally accepted character encoding existed when C was originally standardized,
    so it was designed to work with a wide variety of character representations. Instead
    of specifying a character encoding like Java, each C implementation defines both
    a *source character set* in which source files are written and an *execution character
    set* used for character and string literals at compile time.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言最初标准化时，并没有一种被普遍接受的字符编码方式，因此它被设计成能够与多种字符表示方式兼容。与 Java 不同，C 的每个实现都定义了 *源字符集*（即源文件编写时使用的字符集）和
    *执行字符集*（即编译时使用的字符和字符串字面值的字符集）。
- en: Both the source and execution character sets must contain encodings for the
    uppercase and lowercase letters of the Latin alphabet; the 10 decimal digits;
    29 graphic characters; and the space, horizontal tab, vertical tab, form feed,
    and newline characters. The execution character set also includes alert, backspace,
    carriage return, and null characters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 源字符集和执行字符集必须包含拉丁字母的大写和小写字母的编码；10 个十进制数字；29 个图形字符；以及空格、水平制表符、垂直制表符、换页符和换行符。执行字符集还包括警告、退格、回车和空字符。
- en: Character conversion and classification functions (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">isdigit</samp>)
    are evaluated at runtime, based on the locale-determined encoding in effect at
    the time of the call. A program’s *locale* defines its code sets, date and time
    formatting conventions, monetary conventions, decimal formatting conventions,
    and sort order.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 字符转换和分类函数（例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">isdigit</samp>）会在运行时进行评估，基于调用时生效的本地化编码。程序的
    *区域设置* 定义了它的代码集、日期和时间格式约定、货币约定、十进制格式约定和排序顺序。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Data Types</samp>
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">数据类型</samp>
- en: C defines several data types to represent character data, some of which we have
    already seen. C offers the unadorned <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type to represent *narrow characters* (those that can be represented in as few
    as 8 bits) and the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type to represent *wide characters* (those that may require more than 8 bits).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: C 定义了几种数据类型来表示字符数据，其中一些我们已经见过。C 提供了不带修饰的 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    类型来表示 *窄字符*（那些可以用最多 8 位表示的字符），以及 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    类型来表示 *宽字符*（那些可能需要超过 8 位表示的字符）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">char</samp>
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">char</samp>
- en: As I have already mentioned, <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    is an integer type, but each implementation defines whether it’s signed or unsigned.
    In portable code, you can assume neither.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 是一种整数类型，但每种实现会定义它是有符号还是无符号的。在可移植的代码中，你可以假设它既不是有符号也不是无符号的。
- en: Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type for character
    data (where signedness has no meaning) and not for integer data (where signedness
    is important). You can safely use the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type to represent 7-bit character encodings, such as US-ASCII. For these encodings,
    the high-order bits are always 0, so you don’t have to be concerned about sign
    extension when a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and implementation
    defined as a signed type.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型表示字符数据（在这种情况下符号性无关紧要），而不是用于表示整数数据（在这种情况下符号性很重要）。你可以安全地使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型表示 7 位字符编码，例如 US-ASCII。对于这些编码，高位总是
    0，因此当将 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型的值转换为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 时，你无需担心符号扩展问题，因为实现将其定义为有符号类型。
- en: 'You can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type to represent 8-bit character encodings, such as Extended ASCII, ISO/IEC 8859,
    EBCDIC, and UTF-8\. These 8-bit character encodings can be problematic on implementations
    that define <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> as an 8-bit
    signed type. For example, the following code prints the string <samp class="SANS_TheSansMonoCd_W5Regular_11">end
    of file</samp> when an <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    is detected:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 类型来表示 8 位字符编码，例如扩展
    ASCII、ISO/IEC 8859、EBCDIC 和 UTF-8。这些 8 位字符编码在将 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    定义为 8 位有符号类型的实现上可能会出现问题。例如，下面的代码在检测到 <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    时会打印字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">end of file</samp>：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Assuming the implementation-defined execution character set is ISO/IEC 8859-1,
    the Latin small letter y with diaeresis (ÿ) is defined to have the representation
    <samp class="SANS_TheSansMonoCd_W5Regular_11">255 (0xFF)</samp>. For implementations
    in which <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> is defined
    as a signed type, <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> will
    be sign-extended to the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>, making the ÿ character indistinguishable from <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    because they have the same representation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设实现定义的执行字符集为 ISO/IEC 8859-1，带有分音符的拉丁小写字母 y（ÿ）被定义为表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">255
    (0xFF)</samp>。对于将 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 定义为有符号类型的实现，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">c</samp> 将被符号扩展为 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp> 的宽度，这使得ÿ字符与 <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    无法区分，因为它们具有相同的表示。
- en: A similar problem occurs when using the character classification functions defined
    in <samp class="SANS_TheSansMonoCd_W5Regular_11"><ctype.h></samp>. These library
    functions accept a character argument as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or the value of the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>.
    They return a nonzero value if the character belongs to the set of characters
    that the function’s description defines and zero if the value doesn’t belong to
    it. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">isdigit</samp>
    function tests whether the character is a decimal-digit character in the current
    locale. Any argument value that isn’t a valid character or <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    results in undefined behavior.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用在 <samp class="SANS_TheSansMonoCd_W5Regular_11"><ctype.h></samp> 中定义的字符分类函数时，会发生类似的问题。这些库函数将字符参数作为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 或宏 <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    的值来接受。如果字符属于该函数描述定义的字符集合，则返回非零值；如果字符不属于该集合，则返回零。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">isdigit</samp>
    函数测试字符是否为当前区域设置中的十进制数字字符。任何不是有效字符或 <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    的参数值都会导致未定义行为。
- en: 'To avoid undefined behavior when invoking these functions, cast <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> before the
    integer promotions, as shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在调用这些函数时发生未定义行为，应在整数提升之前将 <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    强制转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>，如下所示：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is
    zero-extended to the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>, eliminating the undefined behavior by ensuring that the resulting
    value is representable as an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>. Note that the initialization of <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ'</samp> may result in a warning
    or error.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> 中的值会被零扩展到 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp> 的宽度，通过确保结果值能够作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> 表示，从而消除未定义行为。请注意，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    初始化为 <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ'</samp> 可能会导致警告或错误。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">int</samp>
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">int</samp>
- en: Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type for data
    that could be either <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    (a negative value) or character data interpreted as <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> and then converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Functions that read character data from a stream, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>,
    return the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type. As we’ve
    seen, character-handling functions from <samp class="SANS_TheSansMonoCd_W5Regular_11"><ctype.h></samp>
    also accept this type because they might be passed the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>
    or related functions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能是 <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>（一个负值）或作为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> 解释后再转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    的字符数据，应使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 类型。从流中读取字符数据的函数，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>，返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    类型。正如我们所见，来自 <samp class="SANS_TheSansMonoCd_W5Regular_11"><ctype.h></samp> 的字符处理函数也接受这种类型，因为它们可能会接收到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp> 或相关函数的结果。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">wchar_t</samp>
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">wchar_t</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type is an
    integer type added to C to process the characters of a large character set. It
    can be a signed or unsigned integer type, depending on the implementation, and
    it has an implementation-defined inclusive range of <samp class="SANS_TheSansMonoCd_W5Regular_11">WCHAR_MIN</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">WCHAR_MAX</samp>. Most implementations
    define <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> to be either
    a 16- or 32-bit unsigned integer type, but implementations that don’t support
    localization may define <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    to have the same width as <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>.
    C does not permit a variable-length encoding for wide strings (despite UTF-16
    being used this way in practice on Windows). Implementations can conditionally
    define the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp>
    as an integer constant of the form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">yyyymmL</samp>
    (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">199712L</samp>) to
    mean that the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type
    is used to represent Unicode characters corresponding to the specified version
    of the standard. Implementations that chose a 16-bit type for <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    cannot meet the requirements for defining <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp>
    for ISO/IEC 10646 editions more recent than Unicode 3.1\. Consequently, the requirement
    for defining <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp>
    is either a <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type
    larger than 20 bits or a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    and a value for <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp>
    earlier than <samp class="SANS_TheSansMonoCd_W5Regular_11">200103L</samp>. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type can be used
    for encodings other than Unicode, such as wide EBCDIC.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 类型是 C 语言中为了处理大字符集的字符而新增的整数类型。它可以是有符号或无符号整数类型，具体取决于实现，并且具有实现定义的包含范围，从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WCHAR_MIN</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">WCHAR_MAX</samp>。大多数实现将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 定义为 16 位或 32 位无符号整数类型，但不支持本地化的实现可能将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 定义为与 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    相同的宽度。C 语言不允许使用可变长度编码来表示宽字符串（尽管在 Windows 上实际使用 UTF-16 是这种方式）。实现可以有条件地将宏 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp> 定义为整数常量，形式为
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">yyyymmL</samp>（例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">199712L</samp>），表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    类型用于表示对应于指定版本标准的 Unicode 字符。选择 16 位类型的实现无法满足定义 <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp>
    的要求，特别是对于比 Unicode 3.1 更高版本的 ISO/IEC 10646。结果，定义 <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp>
    的要求是要么使用大于 20 位的 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    类型，要么使用 16 位 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 类型和一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp> 的值，且该值早于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">200103L</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    类型还可以用于表示 Unicode 以外的编码，例如宽 EBCDIC。
- en: Writing portable code using <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    can be difficult because of the range of implementation-defined behavior. For
    example, Windows uses a 16-bit unsigned integer type, while Linux typically uses
    a 32-bit unsigned integer type. Code that calculates the lengths and sizes of
    wide-character strings is error prone and must be performed with care.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> 编写可移植代码可能会很困难，因为实现定义的行为范围很广。例如，Windows
    使用 16 位无符号整数类型，而 Linux 通常使用 32 位无符号整数类型。计算宽字符字符串的长度和大小的代码容易出错，必须小心执行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">char16_t and char32_t</samp>
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">char16_t 和 char32_t</samp>
- en: Other languages (including Ada95, Java, TCL, Perl, Python, and C#) have data
    types for Unicode characters. C11 introduced the 16- and 32-bit character data
    types <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>, declared in <samp class="SANS_TheSansMonoCd_W5Regular_11"><uchar.h></samp>,
    to provide data types for UTF-16 and UTF-32 encodings, respectively. C doesn’t
    provide standard library functions for the new data types, except for one set
    of character conversion functions. Without library functions, these types have
    limited usefulness.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言（包括 Ada95、Java、TCL、Perl、Python 和 C#）都具有用于表示 Unicode 字符的数据类型。C11 引入了 16 位和
    32 位字符数据类型 <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>，这些类型在 <samp class="SANS_TheSansMonoCd_W5Regular_11"><uchar.h></samp>
    中声明，用于分别表示 UTF-16 和 UTF-32 编码。C 不为这些新数据类型提供标准库函数，除了少数字符转换函数。没有库函数的支持，这些类型的用途非常有限。
- en: C defines two environment macros that indicate how characters represented in
    these types are encoded. If the environment macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp>
    has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, values of
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> are UTF-16
    encoded. If the environment macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_32__</samp>
    has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, values of
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> are UTF-32
    encoded. If the macro isn’t defined, another implementation-defined encoding is
    used. Visual C++ does not define these macros, suggesting that you can’t use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> on Windows for UTF-16.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: C 定义了两个环境宏，用于指示这些类型中表示的字符是如何编码的。如果环境宏 <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp>
    的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>
    类型的值采用 UTF-16 编码。如果环境宏 <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_32__</samp>
    的值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>
    类型的值采用 UTF-32 编码。如果宏未定义，则使用另一个实现定义的编码方式。Visual C++ 不定义这些宏，表明在 Windows 上不能使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> 类型表示 UTF-16。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Character Constants</samp>
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">字符常量</samp>
- en: C allows you to specify *character constants*, also known as *character literals*,
    which are sequences of one or more characters enclosed in single quotes, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ'</samp>. Character constants
    allow you to specify character values in the source code of your program. [Table
    7-1](chapter7.xhtml#tab7-1) shows the types of character constants that can be
    specified in C.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: C 允许你指定*字符常量*，也叫做*字符字面量*，它们是由一个或多个字符组成，并用单引号括起来，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ'</samp>。字符常量允许你在程序的源代码中指定字符值。[表
    7-1](chapter7.xhtml#tab7-1)展示了可以在 C 中指定的字符常量类型。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-1:</samp> <samp class="SANS_Futura_Std_Book_11">Types
    of Character Constants</samp>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 7-1：</samp> <samp class="SANS_Futura_Std_Book_11">字符常量类型</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Prefix</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Type</samp>
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">前缀</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">类型</samp>
    |'
- en: '| --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">None</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">无</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">u8''a''</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">char8_t</samp>
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">u8''a''</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">char8_t</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">L''a''</samp> | <samp class="SANS_Futura_Std_Book_11">The
    unsigned type corresponding to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">L''a''</samp> | <samp class="SANS_Futura_Std_Book_11">对应的无符号类型</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">u''a''</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">u''a''</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">U''a''</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">U''a''</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>
    |'
- en: The value of a character constant containing more than one character (for example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'ab'</samp>) is implementation defined.
    So is the value of a source character that cannot be represented as a single code
    unit in the execution character set. The earlier example of <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">'</samp> is one such case. If the execution
    character set is UTF-8, the value might be <samp class="SANS_TheSansMonoCd_W5Regular_11">0xC3BF</samp>
    to reflect the UTF-8 encoding of the two code units needed to represent the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">U+00FF</samp> code-point value. C23 adds
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp> prefix for character
    literals to represent a UTF-8 encoding. A UTF-8, UTF-16, or UTF-32 character constant
    cannot contain more than one character. The value must be representable with a
    single UTF-8, UTF-16, or UTF-32 code unit, respectively. Because UTF-8 encodes
    US-ASCII characters (<samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp>) as single bytes
    in the range <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x7F</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp>
    prefix can be used to create ASCII characters, even on implementations where the
    locale-dependent character encoding is some other encoding, such as EBCDIC.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 包含多个字符的字符常量（例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">'ab'</samp>）的值是由实现定义的。不能用单一代码单元表示的源字符的值也是如此。早前提到的例子
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>
    就是一个这样的情况。如果执行字符集是 UTF-8，则该值可能是 <samp class="SANS_TheSansMonoCd_W5Regular_11">0xC3BF</samp>，以反映表示
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U+00FF</samp> 代码点值所需的两个代码单元的 UTF-8
    编码。C23 为字符字面量添加了 <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp> 前缀，以表示
    UTF-8 编码。UTF-8、UTF-16 或 UTF-32 字符常量不能包含多个字符。该值必须能够使用单一的 UTF-8、UTF-16 或 UTF-32
    代码单元表示。因为 UTF-8 将 US-ASCII 字符（<samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp>
    到 <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp>）作为范围在 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp>
    到 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7F</samp> 之间的单字节表示，所以即使在字符编码依赖于本地环境的实现中（例如
    EBCDIC 编码），也可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp> 前缀来创建
    ASCII 字符。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Escape Sequences</samp>
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">转义序列</samp>
- en: The single quote (<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>) and
    backslash (<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>) have special
    meanings, so they cannot be directly represented as characters. Instead, to represent
    the single quote, we use the escape sequence <samp class="SANS_TheSansMonoCd_W5Regular_11">\'</samp>,
    and to represent the backslash, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp>.
    We can represent other characters, such as the question mark (<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>),
    and arbitrary integer values by using the escape sequences shown in [Table 7-2](chapter7.xhtml#tab7-2).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号（<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>）和反斜杠（<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>）具有特殊含义，因此不能直接表示为字符。相反，为了表示单引号，我们使用转义序列
    <samp class="SANS_TheSansMonoCd_W5Regular_11">\'</samp>，为了表示反斜杠，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp>。我们还可以使用转义序列表示其他字符，例如问号（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">?</samp>）以及任意整数值，具体请参见[表 7-2](chapter7.xhtml#tab7-2)。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-2:</samp> <samp class="SANS_Futura_Std_Book_11">Escape
    Sequences</samp>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 7-2:</samp> <samp class="SANS_Futura_Std_Book_11">转义序列</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Character</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Escape
    sequence</samp> |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">字符</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">转义序列</samp>
    |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Single quote</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\''</samp>
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">单引号</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\''</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Double quote</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\"</samp>
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">双引号</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\"</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Question mark</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\?</samp>
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">问号</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\?</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Backslash</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp>
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">反斜杠</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Alert</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">警告</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Backspace</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">退格符</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Form feed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\f</samp>
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">换页符</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\f</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Newline</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">换行符</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Carriage return</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp>
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">回车符</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Horizontal tab</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\t</samp>
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">水平制表符</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\t</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Vertical tab</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\v</samp>
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">垂直制表符</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\v</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Octal character</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\<</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">up to three octal digits</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">></samp> |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">八进制字符</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\<</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">最多三位八进制数字</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Hexadecimal character</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">\<</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x
    hexidecimal digits</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">十六进制字符</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\<</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">十六进制数字</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>
    |'
- en: 'The following nongraphical characters are represented by escape sequences consisting
    of the backslash followed by a lowercase letter: <samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>
    (alert), <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp> (backspace),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">\f</samp> (form feed), <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    (newline), <samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp> (carriage return),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">\t</samp> (horizontal tab), and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">\v</samp> (vertical tab).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过转义序列表示的非图形字符，这些转义序列由反斜杠后跟小写字母组成：<samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>（警告），<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>（退格符），<samp class="SANS_TheSansMonoCd_W5Regular_11">\f</samp>（换页符），<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>（换行符），<samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp>（回车符），<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\t</samp>（水平制表符）和<samp class="SANS_TheSansMonoCd_W5Regular_11">\v</samp>（垂直制表符）。
- en: Octal digits can be incorporated into an octal escape sequence to construct
    a single character for a character constant or a single wide character for a wide-character
    constant. The numerical value of the octal integer specifies the value of the
    desired character or wide character. *A backslash followed by numbers is always
    interpreted as an octal value.* For example, you can represent the backspace character
    (8 decimal) as the octal value <samp class="SANS_TheSansMonoCd_W5Regular_11">\10</samp>
    or, equivalently, <samp class="SANS_TheSansMonoCd_W5Regular_11">\010</samp>.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 八进制数字可以被嵌入到八进制转义序列中，用于构建一个字符常量或一个宽字符常量。八进制整数的数值指定所需字符或宽字符的值。*反斜杠后跟数字总是被解释为八进制值。*
    例如，你可以将退格符（十进制为8）表示为八进制值<samp class="SANS_TheSansMonoCd_W5Regular_11">\10</samp>，或者等效地表示为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">\010</samp>。
- en: You can also incorporate the hexadecimal digits that follow the <samp class="SANS_TheSansMonoCd_W5Regular_11">\x</samp>
    to construct a single character or wide character for a character constant. The
    numerical value of the hexadecimal integer forms the value of the desired character
    or wide character. For example, you can represent the backspace character as the
    hexadecimal value <samp class="SANS_TheSansMonoCd_W5Regular_11">\x8</samp> or,
    equivalently, <samp class="SANS_TheSansMonoCd_W5Regular_11">\x08</samp>.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以结合 <samp class="SANS_TheSansMonoCd_W5Regular_11">\x</samp> 后的十六进制数字来构造字符常量或宽字符常量。十六进制整数的数值形成所需字符或宽字符的值。例如，你可以将退格符表示为十六进制值
    <samp class="SANS_TheSansMonoCd_W5Regular_11">\x8</samp> 或等效的 <samp class="SANS_TheSansMonoCd_W5Regular_11">\x08</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Linux</samp>
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Linux</samp>
- en: Character encodings have evolved differently on various operating systems. Before
    UTF-8 emerged, Linux typically relied on various language-specific extensions
    of ASCII. The most popular of these were ISO 8859-1 and ISO 8859-2 in Europe,
    ISO 8859-7 in Greece, KOI-8/ISO 8859-5/CP1251 in Russia, EUC and Shift-JIS in
    Japan, and BIG5 in Taiwan. Linux distributors and application developers are phasing
    out these older legacy encodings in favor of UTF-8 to represent localized text
    strings (Kuhn 1999).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 字符编码在不同操作系统上的演变有所不同。在 UTF-8 出现之前，Linux 通常依赖于各种语言特定的 ASCII 扩展。最流行的包括欧洲的 ISO 8859-1
    和 ISO 8859-2，希腊的 ISO 8859-7，俄罗斯的 KOI-8/ISO 8859-5/CP1251，日本的 EUC 和 Shift-JIS，以及台湾的
    BIG5。Linux 发行版和应用程序开发者正在逐步淘汰这些旧的遗留编码，转而使用 UTF-8 来表示本地化的文本字符串（Kuhn 1999）。
- en: 'GCC has several flags that allow you to configure character sets. Here are
    a couple of flags you may find useful:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 有几个标志可以让你配置字符集。以下是一些你可能会觉得有用的标志：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset</samp> flag
    sets the execution character set that’s used to interpret string and character
    constants. The default is UTF-8\. The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">charset</samp>
    can be any encoding supported by the system’s <samp class="SANS_TheSansMonoCd_W5Regular_11">iconv</samp>
    library routine described later in this chapter. For example, setting <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset=IBM1047</samp>
    instructs GCC to interpret string constants hardcoded in source code, such as
    <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> format strings, according
    to EBCDIC code page 1,047.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset</samp> 标志设置用于解释字符串和字符常量的执行字符集。默认值是
    UTF-8。<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">charset</samp> 可以是系统的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">iconv</samp> 库例程所支持的任何编码，稍后在本章中会介绍。例如，设置
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset=IBM1047</samp> 会指示
    GCC 按照 EBCDIC 编码页 1047 来解释源代码中硬编码的字符串常量，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    格式字符串。
- en: 'To select the wide-execution character set, used for wide-string and character
    constants, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-fwide-exec-charset</samp>
    flag:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择用于宽字符串和字符常量的宽执行字符集，可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-fwide-exec-charset</samp>
    标志：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The default is UTF-32 or UTF-16, corresponding to the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值是 UTF-32 或 UTF-16，对应于 <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    的宽度。
- en: 'The input character set defaults to your system locale (or UTF-8 if the system
    locale is not configured). To overwrite the input character set used for translating
    the character set of the input file to the source character set used by GCC, use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">-finput-charset</samp> flag:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 输入字符集默认与系统区域设置相同（如果系统区域设置未配置，则为 UTF-8）。要覆盖用于将输入文件的字符集转换为 GCC 使用的源字符集的输入字符集，可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-finput-charset</samp> 标志：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Clang has <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-finput-charset</samp> but not
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-fwide-exec-charset</samp>. Clang
    allows you to set <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">charset</samp>
    to UTF-8 only and rejects any attempt to set it to something else.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 有 <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">-finput-charset</samp>，但没有 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-fwide-exec-charset</samp>。Clang 只允许将
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">charset</samp> 设置为 UTF-8，并拒绝任何将其设置为其他值的尝试。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Windows</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Windows</samp>
- en: Support for character encodings in Windows has irregularly evolved. Programs
    developed for Windows can handle character encodings using either Unicode interfaces
    or interfaces that rely implicitly on locale-dependent character encodings. For
    most modern applications, you should choose the Unicode interfaces by default
    to ensure that the application behaves as you expect when processing text. Generally,
    this code will have better performance, as narrow strings passed to Windows library
    functions are frequently converted to Unicode strings.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 中对字符编码的支持经历了不规则的发展。为 Windows 开发的程序可以使用 Unicode 接口或依赖于区域设置的字符编码接口来处理字符编码。对于大多数现代应用程序，默认应选择
    Unicode 接口，以确保在处理文本时应用程序的行为符合预期。通常，这段代码的性能会更好，因为传递给 Windows 库函数的窄字符字符串通常会被转换为
    Unicode 字符串。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The main and wmain Entry Points</samp>
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">main 和 wmain 入口点</samp>
- en: 'Visual C++ supports two entry points to your program: <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>,
    which allows you to pass narrow-character arguments, and <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>,
    which allows you to pass wide-character arguments. You declare formal parameters
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp> by using a similar
    format to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, as shown
    in [Table 7-3](chapter7.xhtml#tab7-3).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Visual C++ 支持两种程序入口点：<samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>，它允许你传递窄字符参数，以及
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>，它允许你传递宽字符参数。你可以使用与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 相似的格式声明 <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>
    的正式参数，如[表 7-3](chapter7.xhtml#tab7-3)所示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-3:</samp> <samp class="SANS_Futura_Std_Book_11">Windows
    Program Entry Point Declarations</samp>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 7-3：</samp> <samp class="SANS_Futura_Std_Book_11">Windows
    程序入口点声明</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Narrow-character arguments</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Wide-character arguments</samp> |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">窄字符参数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">宽字符参数</samp>
    |'
- en: '| --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int main();</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int wmain();</samp> |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int main();</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int wmain();</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int main(int argc, char *argv[]);</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">int wmain(int argc, wchar_t *argv[]);</samp>
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int main(int argc, char *argv[]);</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">int wmain(int argc, wchar_t *argv[]);</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int main(int argc, char *argv[],</samp><samp
    class="SANS_Futura_Std_Book_11"></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">char
    *envp[]);</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int wmain(int
    argc, wchar_t *argv[],</samp><samp class="SANS_Futura_Std_Book_11"></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">wchar_t *envp[]);</samp> |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int main(int argc, char *argv[],</samp><samp
    class="SANS_Futura_Std_Book_11"></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">char
    *envp[]);</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int wmain(int
    argc, wchar_t *argv[],</samp><samp class="SANS_Futura_Std_Book_11"></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">wchar_t *envp[]);</samp> |'
- en: For either entry point, the character encoding ultimately depends on the calling
    process. However, by convention, the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function receives its optional arguments and environment as pointers to text encoded
    with the current Windows (also called ANSI) code page, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>
    function receives UTF-16-encoded text.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意入口点，字符编码最终取决于调用进程。然而，根据惯例，<samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    函数接收其可选参数和环境作为指向当前 Windows（也称为 ANSI）代码页编码文本的指针，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>
    函数接收 UTF-16 编码的文本。
- en: When you run a program from a shell such as the command prompt, the shell’s
    command interpreter converts the arguments into the proper encoding for that entry
    point. A Windows process starts with a UTF-16-encoded command line. The startup
    code emitted by the compiler/linker calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLineToArgvW</samp>
    function to convert the command line to the <samp class="SANS_TheSansMonoCd_W5Regular_11">argv</samp>
    form required to call <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    or passes the command line arguments directly to the <samp class="SANS_TheSansMonoCd_W5Regular_11">argv</samp>
    form required to call <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>.
    In a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, the results
    are then transcoded to the current Windows code page, which can vary from system
    to system. The ASCII character <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    is substituted for characters that lack representation in the current Windows
    code page.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从命令提示符等 shell 运行程序时，shell 的命令解释器会将参数转换为该入口点所需的正确编码。Windows 进程以 UTF-16 编码的命令行开始。编译器/链接器发出的启动代码调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLineToArgvW</samp> 函数，将命令行转换为调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> 所需的 <samp class="SANS_TheSansMonoCd_W5Regular_11">argv</samp>
    形式，或者直接将命令行参数传递给调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>
    所需的 <samp class="SANS_TheSansMonoCd_W5Regular_11">argv</samp> 形式。在对 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    的调用中，结果会被重新编码为当前的 Windows 代码页，而该代码页可能因系统而异。对于当前 Windows 代码页中无法表示的字符，ASCII 字符 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">?</samp> 会被替代。
- en: The Windows console uses an original equipment manufacturer (OEM) code page
    when writing data to the console. The actual encoding used varies from system
    to system but is often different from the Windows code page. For example, on a
    US English version of Windows, the Windows code page may be Windows Latin 1, while
    the OEM code page may be DOS Latin US. In general, writing textual data to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>
    requires the text to be converted to the OEM code page first, or requires setting
    the console’s output code page to match the encoding of the text being written
    out. Failure to do so may cause unexpected output to be printed to the console.
    However, even if you carefully match the character encodings between your program
    and the console, the console might still fail to display the characters as expected
    because of other factors, such as the current font selected for the console not
    having the appropriate glyphs required to represent the characters. Additionally,
    the Windows console has historically been unable to display characters outside
    of the Unicode BMP because it stores only a 16-bit value for character data for
    each cell.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 控制台在向控制台写入数据时使用原始设备制造商（OEM）代码页。实际使用的编码因系统而异，但通常与 Windows 代码页不同。例如，在美国英语版
    Windows 上，Windows 代码页可能是 Windows Latin 1，而 OEM 代码页可能是 DOS Latin US。一般而言，向 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>
    写入文本数据需要先将文本转换为 OEM 代码页，或者需要将控制台的输出代码页设置为与写入文本的编码相匹配。如果未这样做，可能会导致控制台输出意外的内容。然而，即使你仔细匹配了程序和控制台之间的字符编码，控制台仍然可能无法按预期显示字符，原因可能是其他因素，比如当前为控制台选择的字体没有适当的字形来表示这些字符。此外，历史上，Windows
    控制台无法显示 Unicode 基本多文种平面（BMP）之外的字符，因为它仅为每个单元格的字符数据存储一个 16 位值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Narrow vs. Wide Characters</samp>
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">窄字符与宽字符</samp>
- en: 'There are two versions of all system APIs in the Win32 software development
    kit (SDK): a narrow Windows (ANSI) version with an <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    suffix and a wide-character version with a <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>
    suffix:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Win32 软件开发工具包（SDK）中的所有系统 API 都有两个版本：一个是带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    后缀的窄字符 Windows（ANSI）版本，另一个是带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>
    后缀的宽字符版本：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Determine whether your application is going to use wide (UTF-16) or narrow
    characters and then code accordingly. The best practice is to explicitly call
    the narrow- or wide-string version of each function and pass a string of the appropriate
    type:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 确定你的应用程序是否使用宽字符（UTF-16）或窄字符，并据此编写代码。最佳实践是显式调用每个函数的窄字符或宽字符版本，并传递适当类型的字符串：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Examples of actual functions from the Win32 SDK include the <samp class="SANS_TheSansMonoCd_W5Regular_11">MessageBoxA</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MessageBoxW</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowExA</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowExW</samp> functions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Win32 SDK的实际函数示例包括<samp class="SANS_TheSansMonoCd_W5Regular_11">MessageBoxA</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MessageBoxW</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowExA</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowExW</samp>函数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Character Conversion</samp>
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">字符转换</samp>
- en: Although international text is increasingly encoded in Unicode, it’s still encoded
    in language- or country-dependent character encodings, making it necessary to
    convert between these encodings. Windows still operates in locales with traditional,
    limited character encodings, such as IBM EBCDIC and ISO 8859-1\. Programs frequently
    need to convert between the Unicode and traditional encoding schemes when performing
    input/output (I/O).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管国际文本越来越多地采用Unicode编码，但它仍然采用语言或国家依赖的字符编码，因此需要在这些编码之间进行转换。Windows仍然在具有传统、有限字符编码的区域设置中运行，例如IBM
    EBCDIC和ISO 8859-1。程序在进行输入/输出（I/O）时，通常需要在Unicode和传统编码方案之间进行转换。
- en: It’s not possible to convert all strings to each language- or country-dependent
    character encoding. This is obvious when the encoding is US-ASCII, which can’t
    represent characters requiring more than 7 bits of storage. Latin-1 will never
    encode the character <samp class="SANS_Source_Han_Serif_SC_Regular_11">愛</samp>
    properly, and many kinds of non-Japanese letters and words cannot be converted
    to Shift-JIS without losing information.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不能将所有字符串转换为每种语言或国家依赖的字符编码。当编码为US-ASCII时，这一点尤其明显，因为US-ASCII无法表示需要超过7位存储的字符。Latin-1永远无法正确编码字符<samp
    class="SANS_Source_Han_Serif_SC_Regular_11">愛</samp>，而许多非日语的字母和词语也无法在不丢失信息的情况下转换为Shift-JIS。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">C Standard Library</samp>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">C标准库</samp>'
- en: The C standard library provides a handful of functions to convert between narrow-code
    units (<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>) and wide-code
    units (<samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>). The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mbtowc</samp> (multibyte to wide character),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wctomb</samp> (wide character to
    multibyte), <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtowc</samp> (multibyte
    restartable to wide character), and <samp class="SANS_TheSansMonoCd_W5Regular_11">wcrtomb</samp>
    (wide-character restartable to multibyte) functions convert one code unit at a
    time, writing the result to an output object or buffer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">mbstowcs</samp>
    (multibyte string to wide-character string), <samp class="SANS_TheSansMonoCd_W5Regular_11">wcstombs</samp>
    (wide-character string to multibyte string), <samp class="SANS_TheSansMonoCd_W5Regular_11">mbsrtowcs</samp>
    (multibyte-string restartable to multibyte string), and <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsrtombs</samp>
    (wide-character-string restartable to wide-character string) functions convert
    a sequence of code units, writing the result to an output buffer.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: C标准库提供了一些函数，用于在窄字符单元（<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>）和宽字符单元（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>）之间进行转换。<samp class="SANS_TheSansMonoCd_W5Regular_11">mbtowc</samp>（多字节到宽字符）、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wctomb</samp>（宽字符到多字节）、<samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtowc</samp>（可重启多字节到宽字符）和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wcrtomb</samp>（可重启宽字符到多字节）函数一次转换一个字符单元，并将结果写入输出对象或缓冲区。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mbstowcs</samp>（多字节字符串到宽字符字符串）、<samp class="SANS_TheSansMonoCd_W5Regular_11">wcstombs</samp>（宽字符字符串到多字节字符串）、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mbsrtowcs</samp>（可重启多字节字符串到宽字符字符串）和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wcsrtombs</samp>（可重启宽字符字符串到多字节字符串）函数一次转换一系列字符单元，并将结果写入输出缓冲区。
- en: Conversion functions need to store data to properly process a sequence of conversions
    between function calls. The *nonrestartable* forms store the state internally
    and are consequently unsuitable for multithreaded processing. The *restartable*
    versions have an additional parameter that’s a pointer to an object of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mbstate_t</samp> that describes the current
    conversion state of the associated multibyte character sequence. This object holds
    the state data that makes it possible to restart the conversion where it left
    off after another call to the function to perform an unrelated conversion. The
    *string* versions are for performing bulk conversions of multiple code units at
    once.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: These functions have a few limitations. As discussed earlier, Windows uses 16-bit
    code units for <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>. This
    can be a problem, because the C standard requires an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    to be capable of representing any character in the current locale, and a 16-bit
    code unit can be too small to do so. C technically doesn’t allow you to use multiple
    objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> to
    represent a single character. Consequently, the standard conversion functions
    may result in a loss of data. On the other hand, most POSIX implementations use
    32-bit code units for <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>,
    allowing the use of UTF-32\. Because a single UTF-32 code unit can represent a
    whole code point, conversions using standard functions cannot lose or truncate
    data.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'The C standards committee added the following functions to C11 to address the
    potential loss of data using standard conversion functions:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">mbrtoc16, c16rtomb </samp>Converts
    between a sequence of narrow-code units and one or more <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>
    code units
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">mbrtoc32, c32rtomb </samp>Converts
    a sequence of narrow-code units to one or more <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>
    code units
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The first two functions convert between locale-dependent character encodings,
    represented as an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    and UTF-16 data stored in an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>
    (assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp>
    has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>). The second
    two functions convert between the locale-dependent encodings and UTF-32 data stored
    in an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> encoded
    data (assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_32__</samp>
    has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>). The program
    shown in [Listing 7-1](chapter7.xhtml#Lis7-1) uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    function to convert a UTF-8 input string to a UTF-16-encoded string.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: Converting a UTF-8
    string to a</samp> <samp class="I">char16_t</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">string
    with the</samp> <samp class="I">mbrtoc16</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: We call the <samp class="SANS_TheSansMonoCd_W5Regular_11">setlocale</samp> function
    ❸ to set the multibyte character encoding to UTF-8 by passing an implementation-defined
    string. The static assertion ❶ ensures that the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp>
    has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. (Refer to
    [Chapter 11](chapter11.xhtml) for more information on static assertions.) As a
    result, each call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    function converts a single code point from a UTF-8 representation to a UTF-16
    representation. If the resulting UTF-16 code unit is a high surrogate (from a
    surrogate pair), the <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp>
    object is updated to indicate that the next call to <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    will write out the low surrogate without considering the input string.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: There is no string version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    function, so we loop through a UTF-8 input string iteratively, calling the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp> function ❷ to convert
    it to a UTF-16 string. In the case of an encoding error, the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-1</samp>,
    and if the code unit sequence is missing elements, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-2</samp>.
    If either situation occurs, the loop terminates and the conversion ends.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: A return value of <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-3</samp>
    means that the function has output the high surrogate from a surrogate pair and
    then stored an indicator in the state parameter. The indicator is used the next
    time the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp> function
    is called so it can output the low surrogate from a surrogate pair to form a complete
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> sequence that represents
    a single code point. All restartable encoding conversion functions in the C standard
    behave similarly with the state parameter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: If the function returns anything other than <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-2</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-3</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">utf16_idx</samp> index is incremented
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">utf8_idx</samp> index is
    increased by the number of code units read by the function, and the conversion
    of the string continues.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">libiconv</samp>
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: GNU <samp class="SANS_TheSansMonoCd_W5Regular_11">libiconv</samp> is a commonly
    used cross-platform, open source library for performing string-encoding conversions.
    It includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">iconv_open</samp>
    function that allocates a conversion descriptor you can use to convert byte sequences
    from one character encoding to another. The documentation for this function (*[https://<wbr>www<wbr>.gnu<wbr>.org<wbr>/software<wbr>/libiconv<wbr>/](https://www.gnu.org/software/libiconv/)*)
    defines strings you can use to identify a particular <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">charset</samp>
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ASCII</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ISO−8859−1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SHIFT_JIS</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">UTF−8</samp>
    to denote the locale-dependent character encoding.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Win32 Conversion APIs</samp>
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Win32 SDK provides two functions for converting between wide- and narrow-character
    strings: <samp class="SANS_TheSansMonoCd_W5Regular_11">MultiByteToWideChar</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WideCharToMultiByte</samp>.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">MultiByteToWideChar</samp>
    function maps string data that’s encoded in an arbitrary character code page to
    a UTF-16 string. Similarly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">WideCharTo
    MultiByte</samp> function maps string data encoded in UTF-16 to an arbitrary character
    code page. Because UTF-16 data cannot be represented by all code pages, this function
    can specify a default character to use in place of any UTF-16 character that cannot
    be converted.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Strings</samp>
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C doesn’t support a primitive string type and likely never will. Instead, it
    implements strings as arrays of characters. C has two types of strings: narrow
    and wide.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: A *narrow string* has the type array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>.
    It consists of a contiguous sequence of characters that includes a terminating
    null character. A pointer to a string references its initial character. The size
    of a string is the number of bytes allocated to the backing array storage. The
    length of a string is the number of code units (bytes) preceding the first null
    character. In [Figure 7-1](chapter7.xhtml#fig7-1), the size of the string is 7,
    and the length of the string is 5\. Elements of the backing array beyond the last
    element must not be accessed. Elements of the array that haven’t been initialized
    must not be read.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f07001.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: A sample narrow
    string</samp>'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: A *wide string* has the type array of <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>.
    It’s a contiguous sequence of wide characters that includes a terminating null
    wide character. A *pointer* to a wide string references its initial wide character.
    The *length* of a wide string is the number of code units preceding the first
    null wide character. [Figure 7-2](chapter7.xhtml#fig7-2) illustrates both the
    UTF-16BE (big-endian) and UTF-16LE (little-endian) representations of *hello*.
    The size of the array is implementation defined. This array is 14 bytes and assumes
    an implementation that has an 8-bit byte and 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type. The length of this string is 5, as the number of characters has not changed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f07002.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: Sample UTF-16BE
    and UTF-16LE wide strings</samp>'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Elements of the backing array beyond the last element must not be accessed.
    Elements of the array that haven’t been initialized must not be read.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">String Literals</samp>
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *character string literal* is a string constant represented by a sequence
    of zero or more multibyte characters enclosed in double quotes—for example, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">"ABC"</samp>. You can use various prefixes
    to declare string literals of different character types:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> string literal type,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">"ABC"</samp>
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> string literal
    type with <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> prefix, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">L"ABC"</samp>
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UTF-8 string literal type with <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp>
    prefix, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">u8"ABC"</samp>
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> string literal
    type with <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> prefix, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">u"ABC"</samp>
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> string literal
    type with <samp class="SANS_TheSansMonoCd_W5Regular_11">U</samp> prefix, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">U"ABC"</samp>
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C standard doesn’t mandate that an implementation use ASCII for string literals.
    However, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp>
    prefix to force a string literal to be UTF-8 encoded, and if all the characters
    in the literal are ASCII characters, the compiler will produce an ASCII string
    literal, even if the implementation would normally encode string literals in another
    encoding (for example, EBCDIC).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: A string literal has a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    array type. Modifying a string literal is undefined behavior and prohibited by
    the CERT C rule STR30-C, “Do not attempt to modify string literals.” This is because
    these string literals may be stored in read-only memory, or multiple string literals
    may share the same memory, resulting in multiple strings being altered if one
    string is modified.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'String literals often initialize array variables, which you can declare with
    an explicit bound that matches the number of characters in the string literal.
    Consider the following declaration:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The size of the array <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    is four, the exact size required to initialize the array to the string literal,
    including the space for a trailing null byte.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'If you add another character to the string literal used to initialize the array,
    however, the meaning of the code changes substantially:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The size of the array <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    remains four, although the size of the string literal is now five. As a result,
    the array <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> is initialized
    to the character array <samp class="SANS_TheSansMonoCd_W5Regular_11">"abcd"</samp>
    with the trailing null byte omitted. By design, this syntax allows you to initialize
    a character array and not a string. Therefore, it’s unlikely that your compiler
    will diagnose this declaration as an error.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'There is some risk that if the string literal changes during maintenance, a
    string could unintentionally be changed to a character array with no terminating
    null character, particularly when the string literal is defined apart from the
    declaration, as in this example. If your intent is to always initialize <samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp> to a string, you should omit
    the array bound. If you don’t specify the bound of the array, the compiler will
    allocate sufficient space for the entire string literal, including the terminating
    null character:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This approach simplifies maintenance because the size of the array can always
    be determined even if the size of the string literal changes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'The size of arrays declared using this syntax can be determined at compile
    time by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If, instead, we declared this string as follows
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: we would need to invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>
    function to get the length
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: which may incur a runtime cost and is different from the size.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">String-Handling Functions</samp>
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several approaches can be used to manage strings in C, the first of which are
    the C standard library functions. Narrow-string-handling functions are defined
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11"><string.h></samp> header
    file and wide-string-handling functions in <samp class="SANS_TheSansMonoCd_W5Regular_11"><wchar.h></samp>.
    These legacy string-handling functions have been associated in recent years with
    various security vulnerabilities. This is because they don’t check the size of
    the array (frequently lacking the information needed to perform such checks) and
    trust you to provide adequately sized character arrays to hold the output. While
    it’s possible to write safe, robust, and error-free code using these functions,
    they promote programming styles that can result in buffer overflows if a result
    is too large for the provided array. These functions aren’t inherently insecure
    but are prone to misuse and need to be used carefully (or not at all).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: As a result, C11 introduced the normative (but optional) Annex K bounds-checking
    interfaces. This annex provides alternative library functions intended to promote
    safer, more secure programming by requiring you to provide the length of output
    buffers, for example, and validating that these buffers are adequately sized to
    contain the output from these functions. For instance, Annex K defines the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat_s</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy_s</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat_s</samp>
    functions as close replacements for the C standard library’s <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp> functions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11"><string.h> and <wchar.h></samp>
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C standard library includes well-known functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>,
    and so forth, as well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">memmove</samp> functions that
    you can use to copy and move strings, respectively. The C standard also provides
    a wide-character interface that operates on objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>. (These function
    names are like the narrow-string function names, except that <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>
    is replaced with <samp class="SANS_TheSansMonoCd_W5Regular_11">wcs</samp>, and
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp> is added in front of
    the memory function names.) [Table 7-4](chapter7.xhtml#tab7-4) gives some examples
    of narrow- and wide-character string functions. Refer to the C standard (ISO/IEC
    9899:2024) or man pages for more information on how to use these functions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-4:</samp> <samp class="SANS_Futura_Std_Book_11">Narrow-
    and Wide-String Functions</samp>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Narrow (</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">char</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Wide
    (</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">wchar_t</samp><samp class="SANS_Futura_Std_Heavy_B_11">)</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcscpy</samp>
    | <samp class="SANS_Futura_Std_Book_11">String copy</samp> |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsncpy</samp>
    | <samp class="SANS_Futura_Std_Book_11">Truncated, zero-filled copy</samp> |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wmemcpy</samp>
    | <samp class="SANS_Futura_Std_Book_11">Copies a specified number of nonoverlapping
    code units</samp> |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memmove</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wmemmove</samp>
    | <samp class="SANS_Futura_Std_Book_11">Copies a specified number of (possibly
    overlapping) code units</samp> |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcscat</samp>
    | <samp class="SANS_Futura_Std_Book_11">Concatenates strings</samp> |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsncat</samp>
    | <samp class="SANS_Futura_Std_Book_11">Concatenates strings with truncation</samp>
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strcmp</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcscmp</samp>
    | <samp class="SANS_Futura_Std_Book_11">Compares strings</samp> |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strncmp</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsncmp</samp>
    | <samp class="SANS_Futura_Std_Book_11">Compares truncated strings</samp> |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strchr</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcschr</samp>
    | <samp class="SANS_Futura_Std_Book_11">Locates a character in a string</samp>
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strcspn</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcscspn</samp>
    | <samp class="SANS_Futura_Std_Book_11">Computes the length of a complementary
    string segment</samp> |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsdup</samp>
    | <samp class="SANS_Futura_Std_Book_11">Copies string into allocated storage</samp>
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> | <samp class="SANS_Futura_Std_Book_11">N/A</samp>
    | <samp class="SANS_Futura_Std_Book_11">Truncated copy into allocated storage</samp>
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strpbrk</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcspbrk</samp>
    | <samp class="SANS_Futura_Std_Book_11">Finds the first occurrence of a set of
    characters in a string</samp> |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strrchr</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsrchr</samp>
    | <samp class="SANS_Futura_Std_Book_11">Finds the first occurrence of a character
    in a string</samp> |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strspn</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsspn</samp>
    | <samp class="SANS_Futura_Std_Book_11">Computes the length of a string segment</samp>
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strstr</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsstr</samp>
    | <samp class="SANS_Futura_Std_Book_11">Finds a substring</samp> |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strtok</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcstok</samp>
    | <samp class="SANS_Futura_Std_Book_11">String tokenizer (modifies the string
    being tokenized)</samp> |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memchr</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wmemchr</samp>
    | <samp class="SANS_Futura_Std_Book_11">Finds a code unit in memory</samp> |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp>
    | <samp class="SANS_Futura_Std_Book_11">Computes string length</samp> |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wmemset</samp>
    | <samp class="SANS_Futura_Std_Book_11">Fills memory with a specified code unit</samp>
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp> | <samp
    class="SANS_Futura_Std_Book_11">N/A</samp> | <samp class="SANS_Futura_Std_Book_11">Like</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> <samp class="SANS_Futura_Std_Book_11">but
    always performed</samp> |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: These string-handling functions are considered efficient because they leave
    memory management to the caller and can be used with both statically and dynamically
    allocated storage. In the next couple of sections, I’ll go into more detail on
    some of the more commonly used functions.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The wcsdup function listed in [Table 7-4](chapter7.xhtml#tab7-4) is not a
    C standard library function but is defined by POSIX.*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Size and Length</samp>
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As mentioned earlier in this chapter, strings have both a size (which is the
    number of bytes allocated to the backing array storage) and a length. You can
    determine the size of a statically allocated backing array at compile time by
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can compute the length of a string by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>
    function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp> function computes
    the length of a wide string measured by the number of code units preceding the
    terminating null wide character:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The length is a count of something, but what exactly is being counted can be
    unclear. Here are some of the things that *could* be counted when taking the length
    of a string:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '**Bytes** Useful when allocating storage.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '**Code units** Number of individual code units used to represent the string.
    This length depends on encoding and can also be used to allocate memory.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '**Code points** Code points (characters) can take up multiple code units. This
    value is not useful when allocating storage.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**Extended grapheme cluster** A group of one or more Unicode scalar values
    that approximates a single user-perceived character. Many individual characters,
    such as é, <samp class="SANS_Source_Han_Serif_TC_Regular_11">김</samp>, and <samp
    class="SANS_Source_Han_Serif_SC_Regular_11">![](../images/Flag_pg-154.jpg)</samp>,
    may be constructed from multiple Unicode scalar values. Unicode’s boundary algorithms
    combine these code points into extended grapheme clusters.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp>
    functions count code units. For the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>
    function, this corresponds to the number of bytes. Determining the amount of storage
    required by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp>
    function is more complicated because the size of the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type is implementation defined. [Listing 7-2](chapter7.xhtml#Lis7-2) contains
    examples of dynamically allocating storage for both narrow and wide strings.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: Dynamically allocating
    storage for narrow- and wide-string functions</samp>'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: For narrow strings, we can determine the size of the string by adding <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to the return value of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function to account for
    the terminating null character. For wide strings, we can determine the size of
    the string by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to
    the return value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp>
    function to account for the terminating null wide character and then multiply
    the sum by the size of the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">str1</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">wstr1</samp> are declared as pointers
    (and not arrays), it’s not possible to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator to obtain their sizes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Code point or extended grapheme cluster counts cannot be used for storage allocation
    because they consist of an unpredictable number of code units. (For an interesting
    exposition on string length, see “It’s Not Wrong that <samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp><samp
    class="SANS_AppleColorEmoji_black_Regular_11">![](../images/manpalm.jpg)</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">".length</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp>” at *[https://<wbr>hsivonen<wbr>.fi<wbr>/string<wbr>-length<wbr>/](https://hsivonen.fi/string-length/)*.)
    Extended grapheme clusters are used to determine where to truncate a string, for
    example, because of a lack of storage. Truncation at extended grapheme cluster
    boundaries avoids slicing user-perceived characters.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function
    can be an expensive operation because it needs to traverse the length of the array
    looking for a null character. The following is a straightforward implementation
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function has
    no way of knowing the size of the object referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>.
    If you call <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> with an
    invalid string that lacks a null character before the bound, the function will
    access the array beyond its end, resulting in undefined behavior. Passing a null
    pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> will also
    result in undefined behavior (a null-pointer dereference). This implementation
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function also
    has undefined behavior for strings larger than <samp class="SANS_TheSansMonoCd_W5Regular_11">PTRDIFF_MAX</samp>.
    You should refrain from creating such objects (in which case this implementation
    is fine).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">strcpy</samp>
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Calculating the size of dynamically allocated memory is not always easy. One
    approach is to store the size when allocating and reuse this value later. The
    code snippet in [Listing 7-3](chapter7.xhtml#Lis7-3) uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    function to make a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>
    by determining the length and then adding <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    to accommodate the terminating null character.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: Copying a string</samp>'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: We can then use the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">str_size</samp>
    to dynamically allocate the storage for the copy. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    function copies the string from the source string (<samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>)
    to the destination string (<samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>),
    including the terminating null character. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    function returns the address of the beginning of the destination string, which
    is ignored in this example.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code saves a pointer to the destination string in <samp class="SANS_TheSansMonoCd_W5Regular_11">save</samp>
    (to use as the return value) before copying all the bytes from the source to the
    destination array. The <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop terminates when the first null byte is copied. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    doesn’t know the length of the source string or the size of the destination array,
    it assumes that all the function’s arguments have been validated by the caller,
    allowing the implementation to simply copy each byte from the source string to
    the destination array without performing any checks.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Argument Checking</samp>
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Argument checking can be performed by either the calling function or the called
    function. Redundant argument testing by both the caller and the callee is a largely
    discredited style of defensive programming. The usual discipline is to require
    validation on only one side of each interface.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'The most time-efficient approach is for the caller to perform the check, because
    the caller should have a better understanding of the program state. In [Listing
    7-3](chapter7.xhtml#Lis7-3), we can see that the arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    are valid without introducing further redundant tests: the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>
    references a statically allocated array that was properly initialized in the declaration,
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp> parameter is
    a valid non–null pointer referencing dynamically allocated storage of sufficient
    size to hold a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>,
    including the null character. Therefore, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    is safe, and the copy can be performed in a time-efficient manner. This approach
    to argument checking is commonly used by C standard library functions because
    it adheres to the “spirit of C,” in that it’s optimally efficient and trusts the
    programmer (to pass valid arguments).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The safer, more secure approach is for the callee to check the arguments. This
    approach is less error-prone because the library function implementer validates
    the arguments, so we no longer need to trust the programmer to pass valid ones.
    The function implementer is usually in a better position to understand which arguments
    need to be validated. If the input validation code is defective, the repair needs
    to be made in only one place. All the code to validate the arguments is in one
    place, so this approach can be more space efficient. However, because these tests
    run even when unnecessary, they can also be less time efficient. Frequently, the
    caller of these functions will place checks before suspect calls that may or may
    not already perform similar checks. This approach would also impose additional
    error handling on callees that don’t currently return error indications but would
    presumably need to if they validated arguments. For strings, the called function
    can’t always determine whether the argument is a valid null-terminated string
    or points to sufficient space to make a copy.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The lesson here is don’t assume that the C standard library functions validate
    arguments unless the standard explicitly requires them to.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">memcpy</samp>
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp> function copies
    <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> characters from the
    object referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    into the object referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>
    function instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    to copy strings when the size of the destination array is larger than or equal
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> argument to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>, the source array contains
    a null character before the bound, and the string length is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">size
    - 1</samp> (so that the resulting string will be properly null terminated). The
    best advice is to use <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    when copying a string and <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>
    when copying only raw, untyped memory. Also remember that the assignment (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>) operator can efficiently copy
    objects in many cases.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">memccpy</samp>
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most of the C standard library’s string-handling functions return a pointer
    to the beginning of the string passed as an argument so that you can nest calls
    to string functions. For example, the following sequence of nested function calls
    constructs a full name using a Western naming order by copying, then concatenating,
    the constituent parts:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, piecing together the array <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    from its constituent substrings requires <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    to be scanned many more times than necessary; it would have been more useful for
    the string-handling functions to return pointers to the *end* of the modified
    string to eliminate this need for rescanning. C23 introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    function with a better interface design. POSIX environments should already provide
    this, but you may need to enable its declaration as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function has
    the following signature:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Like the <samp class="SANS_TheSansMonoCd_W5Regular_11">memchr</samp> function,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> scans the source
    sequence for the first occurrence of a character specified by one of its arguments.
    The character can have any value, including zero. It copies (at most) the specified
    number of characters from the source to the destination, without writing beyond
    the end of the destination buffer. Finally, it returns a pointer just past the
    copy of the specified character if it exists.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-4](chapter7.xhtml#Lis7-4) reimplements the preceding sequence of
    nested string-handling function calls using the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    function. This implementation is more performant and secure.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-4: String concatenation
    with</samp> <samp class="I">memccpy</samp>'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-4](chapter7.xhtml#Lis7-4) defines the variadic function <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp>
    that accepts a buffer (<samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>)
    and buffer length (<samp class="SANS_TheSansMonoCd_W5Regular_11">buff_length</samp>)
    as fixed arguments and a variable list of string arguments. A null pointer is
    used as the sentinel value to indicate the end of the variable-length argument
    list. The <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function
    is invoked ❶ to concatenate each string to the buffer. As previously noted, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> returns a pointer just
    past the copy of the specified character, which in this case is the null termination
    character <samp class="SANS_TheSansMonoCd_W5Regular_11">''\0''</samp>.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Instead of nesting calls, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    for each string argument passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp>
    and store the return value in <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>.
    This allows you to concatenate directly to the end of the string instead of having
    to find the null termination character each time, making this solution more performant.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> is a null pointer,
    we couldn’t copy the entire string. Instead of returning a partial name in this
    case, we return an empty string. This empty string can be printed or treated as
    an error condition.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function
    returns a pointer to the character *after* the copy of the null byte, we decrement
    <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> using the prefix decrement
    operator and then subtract the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    to obtain a new <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> ❷.
    The size argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    function (which it uses to prevent buffer overflow) is calculated by subtracting
    <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">buff_length</samp>.
    This is a more secure approach than nested function calls, which are always suspect
    because there is no way to check for an error.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">memset, memset_s, and memset_explicit</samp>
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function copies
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">(unsigned char)c</samp>
    into each of the first <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    characters of the object pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function is
    frequently used to clear memory—for example, to initialize memory allocated by
    <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> to zero. However,
    in the following example, it’s used incorrectly:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: One problem with the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_password</samp>
    function is that it uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    function to clear an automatic variable after it has been read for the last time.
    This is being done for security reasons to make sure that the sensitive information
    stored here is inaccessible. However, the compiler doesn’t know that and may perform
    a “dead store” optimization. This is when a compiler notices a write is not followed
    by a read, and just like this book, there is no sense in writing it if no one
    is going to read it. Consequently, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_password</samp> function
    is likely to be removed by the compiler.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: This problem was meant to be addressed in C11 by the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_s</samp>
    function from Annex K bounds-checking interfaces (discussed in the next section).
    Unfortunately, this function has not been implemented by any compiler mentioned
    in this book.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem again, C23 introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp>
    function for making sensitive information inaccessible. In contrast to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function, the intention
    is that the memory store is always performed (that is, never elided), regardless
    of optimizations.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">gets</samp>
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function is a
    flawed input function that accepts input without providing any way to specify
    the size of the destination array. For that reason, it cannot prevent buffer overflows.
    As a result, the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function
    was deprecated in C99 and eliminated from C11\. However, it has been around for
    many years, and most libraries still provide an implementation for backward compatibility,
    so you may see it in the wild. You should *never* use this function, and you should
    replace any use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>
    function you find in any code you’re maintaining.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function
    is so bad, we’ll spend some time examining why it’s so awful. The function shown
    in [Listing 7-5](chapter7.xhtml#Lis7-5) prompts the user to enter either <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    to indicate whether they’d like to continue.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-5: Misuse of the
    obsolete</samp> <samp class="I">gets</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: This function has undefined behavior if more than eight characters are entered
    at the prompt. This undefined behavior occurs because the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>
    function has no way of knowing how large the destination array is and will write
    beyond the end of the array object.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-6](chapter7.xhtml#Lis7-6) shows a simplified implementation of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function. As you can
    see, the caller of this function has no way to limit the number of characters
    read.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-6: A</samp> <samp
    class="I">gets</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    implementation</samp>'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function iterates
    reading a character at a time. The loop terminates if either an <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    or newline <samp class="SANS_TheSansMonoCd_W5Regular_11">'\n'</samp> character
    is read. Otherwise, the function will continue to write to the <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>
    array without concern for the boundaries of the object.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-7](chapter7.xhtml#Lis7-7) shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_y_or_n</samp>
    function from [Listing 7-5](chapter7.xhtml#Lis7-5) with the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>
    function inlined.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-7: A poorly written</samp>
    <samp class="I">while</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The size of the destination array is now available, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop ❶ doesn’t use this information. You should ensure that reaching the bound
    of the array is a loop termination condition when reading or writing to an array
    in a loop such as this one.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Annex K Bounds-Checking
    Interfaces</samp>
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C11 introduced the Annex K bounds-checking interfaces with alternative functions
    that verify that output buffers are large enough for the intended result and return
    a failure indicator if they aren’t. These functions are designed to prevent writing
    data past the end of an array and to null-terminate all string results. These
    string-handling functions leave memory management to the caller, and memory can
    be statically or dynamically allocated before the functions are invoked.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft created the C11 Annex K functions to help retrofit its legacy code
    base in response to numerous, well-publicized security incidents in the 1990s.
    These functions were then proposed to the C standards committee for standardization,
    published as ISO/IEC TR 24731-1 (ISO/IEC TR 24731-1:2007) and then later incorporated
    into C11 as an optional annex. Despite the improved usability and security provided
    by these functions, they aren’t yet widely implemented at the time of writing.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">gets_s</samp>
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Annex K bounds-checking interface has a <samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp>
    function we can use to eliminate the undefined behavior caused by the call to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> in [Listing 7-5](chapter7.xhtml#Lis7-5),
    as shown in [Listing 7-8](chapter7.xhtml#Lis7-8).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-8: Use of the</samp>
    <samp class="I">gets_s</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The two functions are similar, except that the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp>
    function checks the array bounds. The default behavior when the maximum number
    of characters input is exceeded is implementation defined, but typically the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">abort</samp> function is called. You can
    change this behavior via the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp>
    function, which I’ll explain further in “Runtime Constraints” on [page 163](#pg_163).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: You need to define <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_WANT_LIB_EXT1__</samp>
    as a macro that expands to the integer constant <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    before including the header files that define the bounds-checking interfaces to
    allow them to be used in your program. Unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>
    function, the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp> function
    takes a size argument. Consequently, the revised function calculates the size
    of the destination array by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator and passes this value as an argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp>
    function. The implementation-defined behavior is the result of the runtime-constraint
    violation.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">strcpy_s</samp>
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function
    is a close replacement for the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    function defined in <samp class="SANS_TheSansMonoCd_W5Regular_11"><string.h></samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function copies
    characters from a source string to a destination character array up to and including
    the terminating null character. Here’s the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>
    signature:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function
    has an extra argument of type <samp class="SANS_TheSansMonoCd_W5Regular_11">rsize_t</samp>
    that specifies the maximum length of the destination buffer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">rsize_t</samp>
    type is like the <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> type
    except that functions that accept an argument of this type test to make sure that
    the value is not greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">RSIZE_MAX</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function succeeds
    only when it can fully copy the source string to the destination without overflowing
    the destination buffer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>
    function verifies that the following runtime constraints aren’t violated:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Neither <samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp> nor <samp class="SANS_TheSansMonoCd_W5Regular_11">s2</samp>
    are null pointers.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp> is not greater than
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RSIZE_MAX</samp>.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp> does not equal zero.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp> is greater than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">strnlen_s(s2, s1max)</samp>.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying does not take place between overlapping objects.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To perform the string copy in a single pass, a <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>
    function implementation retrieves a character (or characters) from the source
    string and copies it to the destination array until it has copied the entire string
    or the destination array is full. If it can’t copy the entire string and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp> is not zero, the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>
    function sets the first byte of the destination array to the null character, creating
    an empty string.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Runtime Constraints</samp>
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Runtime constraints* are violations of a function’s runtime requirements that
    the function will detect and diagnose by a call to a handler. If this handler
    returns, the functions will return a failure indicator to the caller.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'The bounds-checking interfaces enforce runtime constraints by invoking a runtime-constraint
    handler, which may simply return. Alternatively, the runtime-constraint handler
    might print a message to <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>
    and/or abort the program. You can control which handler function is called via
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp>
    function and make the handler simply return as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If the handler returns, the function that identified the runtime-constraint
    violation and invoked the handler indicates a failure to its caller by using its
    return value.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: The bounds-checking interface functions typically check the conditions either
    immediately upon entry or as they perform their tasks and gather sufficient information
    to determine whether a runtime constraint has been violated. The runtime constraints
    of the bounds-checking interfaces are conditions that would otherwise be undefined
    behavior for C standard library functions.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Implementations have a default constraint handler that they invoke if no calls
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp>
    function have been made. The default handler’s behavior may cause the program
    to exit or abort, but implementations are encouraged to provide reasonable behavior
    by default. This allows, for example, compilers customarily used to implement
    safety-critical systems to not abort by default. You must check the return value
    of calls to functions that can return and not simply assume their results are
    valid. Implementation-defined behavior can be eliminated by invoking the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp> function
    before invoking any bounds-checking interfaces or using any mechanism that invokes
    a runtime-constraint handler.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Annex K provides the <samp class="SANS_TheSansMonoCd_W5Regular_11">abort_handler_s</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ignore_handler_s</samp> functions,
    which represent two common strategies for handling errors. The C implementation’s
    default handler need not be either of these handlers.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">POSIX</samp>
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: POSIX also defines several string-handling functions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> (IEEE Std 1003.1:2018),
    that provide another set of string-related APIs for POSIX-compliant platforms
    such as GNU/Linux and Unix (IEEE Std 1003.1:2018). Both functions were adopted
    into the C standard library by C23.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: These replacement functions use dynamically allocated memory to ensure that
    buffer overflows don’t occur, and they implement a *callee allocates, caller frees*
    model. Each function ensures that enough memory is available (except when a call
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> fails). The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> function, for example, returns
    a pointer to a new string that contains a duplicate of the argument. The returned
    pointer should be passed to the C standard <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    function to reclaim the storage when it’s no longer needed.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-9](chapter7.xhtml#Lis7-9) contains a code snippet that uses the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> function to make a
    copy of the string returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">getenv</samp>
    function.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-9: Copying a string
    using the</samp> <samp class="I">strdup</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11">getenv</samp>
    function searches an environment list, provided by the host environment, for a
    string that matches the string referenced by a specified name (<samp class="SANS_TheSansMonoCd_W5Regular_11">TMP</samp>
    in this example). Strings in this environment list are referred to as *environment
    variables* and provide an additional mechanism for communicating strings to a
    process. These strings don’t have a well-defined encoding but typically match
    the system encoding used for command line arguments, <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: The returned string (the value of the variable) may be overwritten by a subsequent
    call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">getenv</samp> function,
    so it’s a good idea to retrieve any environmental variable you need before creating
    any threads to eliminate the possibility of a race condition. If later use is
    anticipated, you should copy the string so the copy can be safely referenced as
    needed, as illustrated by the idiomatic example shown in [Listing 7-9](chapter7.xhtml#Lis7-9).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> function is
    equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>, except
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> copies, at most,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> bytes into the newly allocated
    memory (while <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> copies
    the entire string) and ensures that the newly created string is always properly
    terminated.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: These POSIX functions can help prevent buffer overflows by automatically allocating
    storage for the resulting strings, but this requires introducing additional calls
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> when this storage
    is no longer needed. This means matching a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    to each call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp>, for example, which
    can be confusing to programmers who are more familiar with the behavior of the
    string functions defined by <samp class="SANS_TheSansMonoCd_W5Regular_11"><string.h></samp>.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Microsoft</samp>
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visual C++ provides all the string-handling functions defined by the C standard
    library up to C99 but doesn’t implement the full POSIX specification. However,
    sometimes the Microsoft implementation of these APIs differs from the requirements
    of a given standard or has a function name that conflicts with an identifier reservation
    in another standard. In these circumstances, Microsoft will often prefix the function
    name with an underscore. For instance, the POSIX function <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>
    isn’t available on Windows, but the function <samp class="SANS_TheSansMonoCd_W5Regular_11">_strdup</samp>
    is available and behaves the same way.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For more information on Microsoft’s POSIX support, see* [https://<wbr>docs<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/cpp<wbr>/c<wbr>-runtime<wbr>-library<wbr>/compatibility](https://docs.microsoft.com/en-us/cpp/c-runtime-library/compatibility)*.*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual C++ also supports many of the safe string-handling functions from Annex
    K and will diagnose the use of an unsafe variant unless you define <samp class="SANS_TheSansMonoCd_W5Regular_11">_CRT_SECURE_NO_WARNINGS</samp>
    prior to including the header file that declares the function. Unfortunately,
    Visual C++ does not conform to Annex K of the C standard, because Microsoft chose
    not to update its implementation based on changes to the APIs that occurred during
    the standardization process. For example, Visual C++ doesn’t provide the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp> function
    but instead retains an older function with similar behavior but an incompatible
    signature:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Microsoft also doesn’t define the <samp class="SANS_TheSansMonoCd_W5Regular_11">abort_handler_s</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ignore_handler_s</samp> functions,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_s</samp> function (which
    was not defined by ISO/IEC TR 24731-1), or the <samp class="SANS_TheSansMonoCd_W5Regular_11">RSIZE_MAX</samp>
    macro. Visual C++ also doesn’t treat overlapping source and destination sequences
    as runtime-constraint violations and instead has undefined behavior in such cases.
    “Bounds-Checking Interfaces: Field Experience and Future Directions” (Seacord
    2019) provides additional information on all aspects of the bounds-checked interfaces,
    including Microsoft’s implementation.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about character encodings, such as ASCII and Unicode.
    You also learned about the various data types used to represent characters in
    C language programs, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>,
    and so forth. We then covered character conversion libraries, including C standard
    library functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">libiconv</samp>,
    and Windows APIs.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: In addition to characters, you also learned about strings and the legacy functions
    and bounds-checked interfaces defined in the C standard library for handling strings,
    as well as some POSIX- and Microsoft-specific functions.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating character and string data is a common programming task in C as
    well as a frequent source of errors. We outlined various approaches to handling
    these data types; you should determine which approach is best suited to your application
    and apply that approach consistently.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about I/O, which, among other things, can
    be used to read and write characters and strings.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
