- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">CHARACTERS
    AND STRINGS</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Strings are such an important and useful data type that nearly every programming
    language implements them in some form. Often used to represent text, strings constitute
    most of the data exchanged between an end user and a program, including text input
    fields, command line arguments, environment variables, and console input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C, the string data type is modeled on the idea of a formal string (Hopcroft
    and Ullman 1979):'
  prefs: []
  type: TYPE_NORMAL
- en: Let Σ be a non-empty finite set of characters, called the alphabet. A string
    over Σ is any finite sequence of characters from Σ. For example, if Σ = {0, 1},
    then 01011 is a string over Σ.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll talk about the various character sets, including ASCII
    and Unicode, that can be used to compose strings (the *alphabet* from the formal
    definition). We’ll cover how strings are represented and manipulated using the
    legacy functions from the C standard library, the bounds-checked interfaces, and
    POSIX and Windows application programming interfaces (APIs).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Characters</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The characters that people use to communicate aren’t naturally understood by
    digital systems, which operate on bits. To process characters, digital systems
    use *character encodings* that assign unique integer values, referred to as *code
    points*, to designate specific characters. As you’ll see, there are multiple ways
    to encode the same notional character in your program. Common standards used by
    C implementations for encoding characters include Unicode, ASCII, Extended ASCII,
    ISO 8859-1 (Latin-1), Shift-JIS, and EBCDIC.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The C standard explicitly references Unicode and ASCII.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">ASCII</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *7-bit American Standard Code for Information Interchange*, better known
    as *7-bit ASCII*, specifies a set of 128 characters and their coded representation
    (ANSI X3.4-1986). Characters from <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1f</samp> and character <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x7f</samp> are control characters, such
    as null, backspace, horizontal tab, and DEL. Characters from <samp class="SANS_TheSansMonoCd_W5Regular_11">0x20</samp>
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7e</samp> are all printable
    characters such as letters, digits, and symbols.
  prefs: []
  type: TYPE_NORMAL
- en: We often refer to this standard with the updated name *US-ASCII* to clarify
    that this system was developed in the United States and focuses on the typographical
    symbols predominantly used in this country. Most modern character encoding schemes
    are based on US-ASCII, although they support many additional characters.
  prefs: []
  type: TYPE_NORMAL
- en: Characters in the <samp class="SANS_TheSansMonoCd_W5Regular_11">0x80</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp> range are not defined
    by US-ASCII but are part of the 8-bit character encoding known as *Extended ASCII*.
    Numerous encodings for these ranges exist, and the actual mapping depends on the
    code page. A *code page* is a character encoding that maps a set of printable
    characters and control characters to unique numbers.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unicode</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Unicode* has become the universal character encoding standard for representing
    text in computer processing. It supports a much wider range of characters than
    ASCII does; the current Unicode Standard (Unicode 2023) encodes characters in
    the range <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">U+10FFFF</samp>, which amounts to a 21-bit
    code space. An individual Unicode value is expressed as <samp class="SANS_TheSansMonoCd_W5Regular_11">U+</samp>
    followed by four or more hexadecimal digits in printed text. The Unicode characters
    <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp>
    are identical to those in US-ASCII, and the range <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+00FF</samp> is identical to
    ISO 8859-1, consisting of characters from the Latin script used throughout the
    Americas, Western Europe, Oceania, and much of Africa.'
  prefs: []
  type: TYPE_NORMAL
- en: Unicode organizes code points into *planes*, which are continuous groups of
    65,536 code points. There are 17 planes, identified by the numbers 0 to 16\. The
    most used characters, including those found in major, older encoding standards,
    have been placed into the first plane (<samp class="SANS_TheSansMonoCd_W5Regular_11">0x0000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFF</samp>), which is called
    the *basic multilingual plane (BMP)*, or Plane 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unicode also specifies several *Unicode transformation formats (UTFs)*, which
    are character encoding formats that assign each Unicode scalar value to a unique
    code unit sequence. A *Unicode scalar value* is any Unicode code point except
    high-surrogate and low-surrogate code points. (Surrogate pairs are explained later
    in this section.) A *code unit* is the minimal bit combination that can represent
    encoded text for processing or interchange. The Unicode standard defines three
    UTFs to allow for code units of various sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UTF-8** Represents each character as a sequence of one to four 8-bit code
    units'
  prefs: []
  type: TYPE_NORMAL
- en: '**UTF-16** Represents each character as a sequence of one or two 16-bit code
    units'
  prefs: []
  type: TYPE_NORMAL
- en: '**UTF-32** Represents each character as a single 32-bit code unit'
  prefs: []
  type: TYPE_NORMAL
- en: 'The UTF-8 encoding is the dominant encoding for POSIX operating systems. It
    has the following desirable properties:'
  prefs: []
  type: TYPE_NORMAL
- en: It encodes US-ASCII characters (<samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp>) as single bytes
    in the range <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x7F</samp>. This means that files and
    strings that contain only 7-bit ASCII characters have the same encoding under
    both ASCII and UTF-8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a null byte to terminate a string (a topic we’ll discuss later) works
    the same as for an ASCII string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All currently defined Unicode code points can be encoded using between 1 and
    4 bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unicode allows character boundaries to be easily identified by scanning for
    well-defined bit patterns in either direction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Windows, you can compile and link your programs with the Visual C++ <samp
    class="SANS_TheSansMonoCd_W5Regular_11">/utf8</samp> flag to set the source and
    execution character sets as UTF-8\. You’ll also need to configure Windows to use
    Unicode UTF-8 for worldwide language support.
  prefs: []
  type: TYPE_NORMAL
- en: UTF-16 is currently the dominant encoding for Windows operating systems. Like
    UTF-8, UTF-16 is a variable-width encoding. As just mentioned, the BMP consists
    of characters from <samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+FFFF</samp>. Characters whose
    code points are greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">U+FFFF</samp>
    are called *supplementary characters*. Supplementary characters are defined by
    a pair of code units called *surrogates*. The first code unit is from the high-surrogates
    range (<samp class="SANS_TheSansMonoCd_W5Regular_11">U+D800</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+DBFF</samp>),
    and the second code unit is from the low-surrogates range (<samp class="SANS_TheSansMonoCd_W5Regular_11">U+DC00</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+DFFF</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other variable-length UTFs, UTF-32 is a fixed-length encoding. The main
    advantage of UTF-32 is that the Unicode code points can be directly indexed, meaning
    that you can find the *n*th code point in a sequence of code points in constant
    time. In contrast, a variable-length encoding requires accessing each code point
    to find the *n*th code point in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Source and Execution
    Character Sets</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No universally accepted character encoding existed when C was originally standardized,
    so it was designed to work with a wide variety of character representations. Instead
    of specifying a character encoding like Java, each C implementation defines both
    a *source character set* in which source files are written and an *execution character
    set* used for character and string literals at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Both the source and execution character sets must contain encodings for the
    uppercase and lowercase letters of the Latin alphabet; the 10 decimal digits;
    29 graphic characters; and the space, horizontal tab, vertical tab, form feed,
    and newline characters. The execution character set also includes alert, backspace,
    carriage return, and null characters.
  prefs: []
  type: TYPE_NORMAL
- en: Character conversion and classification functions (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">isdigit</samp>)
    are evaluated at runtime, based on the locale-determined encoding in effect at
    the time of the call. A program’s *locale* defines its code sets, date and time
    formatting conventions, monetary conventions, decimal formatting conventions,
    and sort order.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Data Types</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C defines several data types to represent character data, some of which we have
    already seen. C offers the unadorned <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type to represent *narrow characters* (those that can be represented in as few
    as 8 bits) and the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type to represent *wide characters* (those that may require more than 8 bits).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">char</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As I have already mentioned, <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    is an integer type, but each implementation defines whether it’s signed or unsigned.
    In portable code, you can assume neither.
  prefs: []
  type: TYPE_NORMAL
- en: Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type for character
    data (where signedness has no meaning) and not for integer data (where signedness
    is important). You can safely use the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type to represent 7-bit character encodings, such as US-ASCII. For these encodings,
    the high-order bits are always 0, so you don’t have to be concerned about sign
    extension when a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and implementation
    defined as a signed type.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type to represent 8-bit character encodings, such as Extended ASCII, ISO/IEC 8859,
    EBCDIC, and UTF-8\. These 8-bit character encodings can be problematic on implementations
    that define <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> as an 8-bit
    signed type. For example, the following code prints the string <samp class="SANS_TheSansMonoCd_W5Regular_11">end
    of file</samp> when an <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Assuming the implementation-defined execution character set is ISO/IEC 8859-1,
    the Latin small letter y with diaeresis (ÿ) is defined to have the representation
    <samp class="SANS_TheSansMonoCd_W5Regular_11">255 (0xFF)</samp>. For implementations
    in which <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> is defined
    as a signed type, <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> will
    be sign-extended to the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>, making the ÿ character indistinguishable from <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    because they have the same representation.
  prefs: []
  type: TYPE_NORMAL
- en: A similar problem occurs when using the character classification functions defined
    in <samp class="SANS_TheSansMonoCd_W5Regular_11"><ctype.h></samp>. These library
    functions accept a character argument as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or the value of the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>.
    They return a nonzero value if the character belongs to the set of characters
    that the function’s description defines and zero if the value doesn’t belong to
    it. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">isdigit</samp>
    function tests whether the character is a decimal-digit character in the current
    locale. Any argument value that isn’t a valid character or <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    results in undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid undefined behavior when invoking these functions, cast <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> before the
    integer promotions, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is
    zero-extended to the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>, eliminating the undefined behavior by ensuring that the resulting
    value is representable as an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>. Note that the initialization of <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ'</samp> may result in a warning
    or error.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">int</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type for data
    that could be either <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    (a negative value) or character data interpreted as <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> and then converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Functions that read character data from a stream, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">getc</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>,
    return the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type. As we’ve
    seen, character-handling functions from <samp class="SANS_TheSansMonoCd_W5Regular_11"><ctype.h></samp>
    also accept this type because they might be passed the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">fgetc</samp>
    or related functions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">wchar_t</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type is an
    integer type added to C to process the characters of a large character set. It
    can be a signed or unsigned integer type, depending on the implementation, and
    it has an implementation-defined inclusive range of <samp class="SANS_TheSansMonoCd_W5Regular_11">WCHAR_MIN</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">WCHAR_MAX</samp>. Most implementations
    define <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> to be either
    a 16- or 32-bit unsigned integer type, but implementations that don’t support
    localization may define <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    to have the same width as <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>.
    C does not permit a variable-length encoding for wide strings (despite UTF-16
    being used this way in practice on Windows). Implementations can conditionally
    define the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp>
    as an integer constant of the form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">yyyymmL</samp>
    (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">199712L</samp>) to
    mean that the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type
    is used to represent Unicode characters corresponding to the specified version
    of the standard. Implementations that chose a 16-bit type for <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    cannot meet the requirements for defining <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp>
    for ISO/IEC 10646 editions more recent than Unicode 3.1\. Consequently, the requirement
    for defining <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp>
    is either a <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type
    larger than 20 bits or a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    and a value for <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_ISO_10646__</samp>
    earlier than <samp class="SANS_TheSansMonoCd_W5Regular_11">200103L</samp>. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> type can be used
    for encodings other than Unicode, such as wide EBCDIC.
  prefs: []
  type: TYPE_NORMAL
- en: Writing portable code using <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    can be difficult because of the range of implementation-defined behavior. For
    example, Windows uses a 16-bit unsigned integer type, while Linux typically uses
    a 32-bit unsigned integer type. Code that calculates the lengths and sizes of
    wide-character strings is error prone and must be performed with care.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">char16_t and char32_t</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Other languages (including Ada95, Java, TCL, Perl, Python, and C#) have data
    types for Unicode characters. C11 introduced the 16- and 32-bit character data
    types <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>, declared in <samp class="SANS_TheSansMonoCd_W5Regular_11"><uchar.h></samp>,
    to provide data types for UTF-16 and UTF-32 encodings, respectively. C doesn’t
    provide standard library functions for the new data types, except for one set
    of character conversion functions. Without library functions, these types have
    limited usefulness.
  prefs: []
  type: TYPE_NORMAL
- en: C defines two environment macros that indicate how characters represented in
    these types are encoded. If the environment macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp>
    has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, values of
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> are UTF-16
    encoded. If the environment macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_32__</samp>
    has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, values of
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> are UTF-32
    encoded. If the macro isn’t defined, another implementation-defined encoding is
    used. Visual C++ does not define these macros, suggesting that you can’t use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> on Windows for UTF-16.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Character Constants</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C allows you to specify *character constants*, also known as *character literals*,
    which are sequences of one or more characters enclosed in single quotes, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ'</samp>. Character constants
    allow you to specify character values in the source code of your program. [Table
    7-1](chapter7.xhtml#tab7-1) shows the types of character constants that can be
    specified in C.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-1:</samp> <samp class="SANS_Futura_Std_Book_11">Types
    of Character Constants</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Prefix</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Type</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">None</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">u8''a''</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">char8_t</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">L''a''</samp> | <samp class="SANS_Futura_Std_Book_11">The
    unsigned type corresponding to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">u''a''</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">U''a''</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: The value of a character constant containing more than one character (for example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">'ab'</samp>) is implementation defined.
    So is the value of a source character that cannot be represented as a single code
    unit in the execution character set. The earlier example of <samp class="SANS_TheSansMonoCd_W5Regular_11">'ÿ</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">'</samp> is one such case. If the execution
    character set is UTF-8, the value might be <samp class="SANS_TheSansMonoCd_W5Regular_11">0xC3BF</samp>
    to reflect the UTF-8 encoding of the two code units needed to represent the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">U+00FF</samp> code-point value. C23 adds
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp> prefix for character
    literals to represent a UTF-8 encoding. A UTF-8, UTF-16, or UTF-32 character constant
    cannot contain more than one character. The value must be representable with a
    single UTF-8, UTF-16, or UTF-32 code unit, respectively. Because UTF-8 encodes
    US-ASCII characters (<samp class="SANS_TheSansMonoCd_W5Regular_11">U+0000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">U+007F</samp>) as single bytes
    in the range <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x7F</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp>
    prefix can be used to create ASCII characters, even on implementations where the
    locale-dependent character encoding is some other encoding, such as EBCDIC.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Escape Sequences</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The single quote (<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>) and
    backslash (<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>) have special
    meanings, so they cannot be directly represented as characters. Instead, to represent
    the single quote, we use the escape sequence <samp class="SANS_TheSansMonoCd_W5Regular_11">\'</samp>,
    and to represent the backslash, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp>.
    We can represent other characters, such as the question mark (<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>),
    and arbitrary integer values by using the escape sequences shown in [Table 7-2](chapter7.xhtml#tab7-2).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-2:</samp> <samp class="SANS_Futura_Std_Book_11">Escape
    Sequences</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Character</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Escape
    sequence</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Single quote</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\''</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Double quote</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\"</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Question mark</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\?</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Backslash</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\\</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Alert</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Backspace</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Form feed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\f</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Newline</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Carriage return</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Horizontal tab</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\t</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Vertical tab</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\v</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Octal character</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\<</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">up to three octal digits</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">></samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Hexadecimal character</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">\<</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x
    hexidecimal digits</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>
    |'
  prefs: []
  type: TYPE_TB
- en: 'The following nongraphical characters are represented by escape sequences consisting
    of the backslash followed by a lowercase letter: <samp class="SANS_TheSansMonoCd_W5Regular_11">\a</samp>
    (alert), <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp> (backspace),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">\f</samp> (form feed), <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    (newline), <samp class="SANS_TheSansMonoCd_W5Regular_11">\r</samp> (carriage return),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">\t</samp> (horizontal tab), and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">\v</samp> (vertical tab).'
  prefs: []
  type: TYPE_NORMAL
- en: Octal digits can be incorporated into an octal escape sequence to construct
    a single character for a character constant or a single wide character for a wide-character
    constant. The numerical value of the octal integer specifies the value of the
    desired character or wide character. *A backslash followed by numbers is always
    interpreted as an octal value.* For example, you can represent the backspace character
    (8 decimal) as the octal value <samp class="SANS_TheSansMonoCd_W5Regular_11">\10</samp>
    or, equivalently, <samp class="SANS_TheSansMonoCd_W5Regular_11">\010</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: You can also incorporate the hexadecimal digits that follow the <samp class="SANS_TheSansMonoCd_W5Regular_11">\x</samp>
    to construct a single character or wide character for a character constant. The
    numerical value of the hexadecimal integer forms the value of the desired character
    or wide character. For example, you can represent the backspace character as the
    hexadecimal value <samp class="SANS_TheSansMonoCd_W5Regular_11">\x8</samp> or,
    equivalently, <samp class="SANS_TheSansMonoCd_W5Regular_11">\x08</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Linux</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Character encodings have evolved differently on various operating systems. Before
    UTF-8 emerged, Linux typically relied on various language-specific extensions
    of ASCII. The most popular of these were ISO 8859-1 and ISO 8859-2 in Europe,
    ISO 8859-7 in Greece, KOI-8/ISO 8859-5/CP1251 in Russia, EUC and Shift-JIS in
    Japan, and BIG5 in Taiwan. Linux distributors and application developers are phasing
    out these older legacy encodings in favor of UTF-8 to represent localized text
    strings (Kuhn 1999).
  prefs: []
  type: TYPE_NORMAL
- en: 'GCC has several flags that allow you to configure character sets. Here are
    a couple of flags you may find useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset</samp> flag
    sets the execution character set that’s used to interpret string and character
    constants. The default is UTF-8\. The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">charset</samp>
    can be any encoding supported by the system’s <samp class="SANS_TheSansMonoCd_W5Regular_11">iconv</samp>
    library routine described later in this chapter. For example, setting <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset=IBM1047</samp>
    instructs GCC to interpret string constants hardcoded in source code, such as
    <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> format strings, according
    to EBCDIC code page 1,047.
  prefs: []
  type: TYPE_NORMAL
- en: 'To select the wide-execution character set, used for wide-string and character
    constants, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-fwide-exec-charset</samp>
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The default is UTF-32 or UTF-16, corresponding to the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The input character set defaults to your system locale (or UTF-8 if the system
    locale is not configured). To overwrite the input character set used for translating
    the character set of the input file to the source character set used by GCC, use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">-finput-charset</samp> flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Clang has <samp class="SANS_TheSansMonoCd_W5Regular_11">-fexec-charset</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-finput-charset</samp> but not
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-fwide-exec-charset</samp>. Clang
    allows you to set <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">charset</samp>
    to UTF-8 only and rejects any attempt to set it to something else.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Windows</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support for character encodings in Windows has irregularly evolved. Programs
    developed for Windows can handle character encodings using either Unicode interfaces
    or interfaces that rely implicitly on locale-dependent character encodings. For
    most modern applications, you should choose the Unicode interfaces by default
    to ensure that the application behaves as you expect when processing text. Generally,
    this code will have better performance, as narrow strings passed to Windows library
    functions are frequently converted to Unicode strings.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The main and wmain Entry Points</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Visual C++ supports two entry points to your program: <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>,
    which allows you to pass narrow-character arguments, and <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>,
    which allows you to pass wide-character arguments. You declare formal parameters
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp> by using a similar
    format to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, as shown
    in [Table 7-3](chapter7.xhtml#tab7-3).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-3:</samp> <samp class="SANS_Futura_Std_Book_11">Windows
    Program Entry Point Declarations</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Narrow-character arguments</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Wide-character arguments</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int main();</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int wmain();</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int main(int argc, char *argv[]);</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">int wmain(int argc, wchar_t *argv[]);</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int main(int argc, char *argv[],</samp><samp
    class="SANS_Futura_Std_Book_11"></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">char
    *envp[]);</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int wmain(int
    argc, wchar_t *argv[],</samp><samp class="SANS_Futura_Std_Book_11"></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">wchar_t *envp[]);</samp> |'
  prefs: []
  type: TYPE_TB
- en: For either entry point, the character encoding ultimately depends on the calling
    process. However, by convention, the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function receives its optional arguments and environment as pointers to text encoded
    with the current Windows (also called ANSI) code page, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>
    function receives UTF-16-encoded text.
  prefs: []
  type: TYPE_NORMAL
- en: When you run a program from a shell such as the command prompt, the shell’s
    command interpreter converts the arguments into the proper encoding for that entry
    point. A Windows process starts with a UTF-16-encoded command line. The startup
    code emitted by the compiler/linker calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLineToArgvW</samp>
    function to convert the command line to the <samp class="SANS_TheSansMonoCd_W5Regular_11">argv</samp>
    form required to call <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    or passes the command line arguments directly to the <samp class="SANS_TheSansMonoCd_W5Regular_11">argv</samp>
    form required to call <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain</samp>.
    In a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>, the results
    are then transcoded to the current Windows code page, which can vary from system
    to system. The ASCII character <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    is substituted for characters that lack representation in the current Windows
    code page.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows console uses an original equipment manufacturer (OEM) code page
    when writing data to the console. The actual encoding used varies from system
    to system but is often different from the Windows code page. For example, on a
    US English version of Windows, the Windows code page may be Windows Latin 1, while
    the OEM code page may be DOS Latin US. In general, writing textual data to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>
    requires the text to be converted to the OEM code page first, or requires setting
    the console’s output code page to match the encoding of the text being written
    out. Failure to do so may cause unexpected output to be printed to the console.
    However, even if you carefully match the character encodings between your program
    and the console, the console might still fail to display the characters as expected
    because of other factors, such as the current font selected for the console not
    having the appropriate glyphs required to represent the characters. Additionally,
    the Windows console has historically been unable to display characters outside
    of the Unicode BMP because it stores only a 16-bit value for character data for
    each cell.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Narrow vs. Wide Characters</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two versions of all system APIs in the Win32 software development
    kit (SDK): a narrow Windows (ANSI) version with an <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    suffix and a wide-character version with a <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>
    suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Determine whether your application is going to use wide (UTF-16) or narrow
    characters and then code accordingly. The best practice is to explicitly call
    the narrow- or wide-string version of each function and pass a string of the appropriate
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Examples of actual functions from the Win32 SDK include the <samp class="SANS_TheSansMonoCd_W5Regular_11">MessageBoxA</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MessageBoxW</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowExA</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateWindowExW</samp> functions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Character Conversion</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although international text is increasingly encoded in Unicode, it’s still encoded
    in language- or country-dependent character encodings, making it necessary to
    convert between these encodings. Windows still operates in locales with traditional,
    limited character encodings, such as IBM EBCDIC and ISO 8859-1\. Programs frequently
    need to convert between the Unicode and traditional encoding schemes when performing
    input/output (I/O).
  prefs: []
  type: TYPE_NORMAL
- en: It’s not possible to convert all strings to each language- or country-dependent
    character encoding. This is obvious when the encoding is US-ASCII, which can’t
    represent characters requiring more than 7 bits of storage. Latin-1 will never
    encode the character <samp class="SANS_Source_Han_Serif_SC_Regular_11">愛</samp>
    properly, and many kinds of non-Japanese letters and words cannot be converted
    to Shift-JIS without losing information.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">C Standard Library</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The C standard library provides a handful of functions to convert between narrow-code
    units (<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>) and wide-code
    units (<samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>). The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mbtowc</samp> (multibyte to wide character),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wctomb</samp> (wide character to
    multibyte), <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtowc</samp> (multibyte
    restartable to wide character), and <samp class="SANS_TheSansMonoCd_W5Regular_11">wcrtomb</samp>
    (wide-character restartable to multibyte) functions convert one code unit at a
    time, writing the result to an output object or buffer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">mbstowcs</samp>
    (multibyte string to wide-character string), <samp class="SANS_TheSansMonoCd_W5Regular_11">wcstombs</samp>
    (wide-character string to multibyte string), <samp class="SANS_TheSansMonoCd_W5Regular_11">mbsrtowcs</samp>
    (multibyte-string restartable to multibyte string), and <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsrtombs</samp>
    (wide-character-string restartable to wide-character string) functions convert
    a sequence of code units, writing the result to an output buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion functions need to store data to properly process a sequence of conversions
    between function calls. The *nonrestartable* forms store the state internally
    and are consequently unsuitable for multithreaded processing. The *restartable*
    versions have an additional parameter that’s a pointer to an object of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mbstate_t</samp> that describes the current
    conversion state of the associated multibyte character sequence. This object holds
    the state data that makes it possible to restart the conversion where it left
    off after another call to the function to perform an unrelated conversion. The
    *string* versions are for performing bulk conversions of multiple code units at
    once.
  prefs: []
  type: TYPE_NORMAL
- en: These functions have a few limitations. As discussed earlier, Windows uses 16-bit
    code units for <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>. This
    can be a problem, because the C standard requires an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    to be capable of representing any character in the current locale, and a 16-bit
    code unit can be too small to do so. C technically doesn’t allow you to use multiple
    objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> to
    represent a single character. Consequently, the standard conversion functions
    may result in a loss of data. On the other hand, most POSIX implementations use
    32-bit code units for <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>,
    allowing the use of UTF-32\. Because a single UTF-32 code unit can represent a
    whole code point, conversions using standard functions cannot lose or truncate
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C standards committee added the following functions to C11 to address the
    potential loss of data using standard conversion functions:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">mbrtoc16, c16rtomb </samp>Converts
    between a sequence of narrow-code units and one or more <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>
    code units
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">mbrtoc32, c32rtomb </samp>Converts
    a sequence of narrow-code units to one or more <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp>
    code units
  prefs: []
  type: TYPE_NORMAL
- en: The first two functions convert between locale-dependent character encodings,
    represented as an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    and UTF-16 data stored in an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp>
    (assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp>
    has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>). The second
    two functions convert between the locale-dependent encodings and UTF-32 data stored
    in an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> encoded
    data (assuming <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_32__</samp>
    has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>). The program
    shown in [Listing 7-1](chapter7.xhtml#Lis7-1) uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    function to convert a UTF-8 input string to a UTF-16-encoded string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: Converting a UTF-8
    string to a</samp> <samp class="I">char16_t</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">string
    with the</samp> <samp class="I">mbrtoc16</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We call the <samp class="SANS_TheSansMonoCd_W5Regular_11">setlocale</samp> function
    ❸ to set the multibyte character encoding to UTF-8 by passing an implementation-defined
    string. The static assertion ❶ ensures that the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_UTF_16__</samp>
    has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. (Refer to
    [Chapter 11](chapter11.xhtml) for more information on static assertions.) As a
    result, each call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    function converts a single code point from a UTF-8 representation to a UTF-16
    representation. If the resulting UTF-16 code unit is a high surrogate (from a
    surrogate pair), the <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp>
    object is updated to indicate that the next call to <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    will write out the low surrogate without considering the input string.
  prefs: []
  type: TYPE_NORMAL
- en: There is no string version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    function, so we loop through a UTF-8 input string iteratively, calling the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp> function ❷ to convert
    it to a UTF-16 string. In the case of an encoding error, the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp>
    function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-1</samp>,
    and if the code unit sequence is missing elements, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-2</samp>.
    If either situation occurs, the loop terminates and the conversion ends.
  prefs: []
  type: TYPE_NORMAL
- en: A return value of <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-3</samp>
    means that the function has output the high surrogate from a surrogate pair and
    then stored an indicator in the state parameter. The indicator is used the next
    time the <samp class="SANS_TheSansMonoCd_W5Regular_11">mbrtoc16</samp> function
    is called so it can output the low surrogate from a surrogate pair to form a complete
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> sequence that represents
    a single code point. All restartable encoding conversion functions in the C standard
    behave similarly with the state parameter.
  prefs: []
  type: TYPE_NORMAL
- en: If the function returns anything other than <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-2</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">(size_t)-3</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">utf16_idx</samp> index is incremented
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">utf8_idx</samp> index is
    increased by the number of code units read by the function, and the conversion
    of the string continues.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">libiconv</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: GNU <samp class="SANS_TheSansMonoCd_W5Regular_11">libiconv</samp> is a commonly
    used cross-platform, open source library for performing string-encoding conversions.
    It includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">iconv_open</samp>
    function that allocates a conversion descriptor you can use to convert byte sequences
    from one character encoding to another. The documentation for this function (*[https://<wbr>www<wbr>.gnu<wbr>.org<wbr>/software<wbr>/libiconv<wbr>/](https://www.gnu.org/software/libiconv/)*)
    defines strings you can use to identify a particular <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">charset</samp>
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ASCII</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ISO−8859−1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SHIFT_JIS</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">UTF−8</samp>
    to denote the locale-dependent character encoding.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Win32 Conversion APIs</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Win32 SDK provides two functions for converting between wide- and narrow-character
    strings: <samp class="SANS_TheSansMonoCd_W5Regular_11">MultiByteToWideChar</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">WideCharToMultiByte</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">MultiByteToWideChar</samp>
    function maps string data that’s encoded in an arbitrary character code page to
    a UTF-16 string. Similarly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">WideCharTo
    MultiByte</samp> function maps string data encoded in UTF-16 to an arbitrary character
    code page. Because UTF-16 data cannot be represented by all code pages, this function
    can specify a default character to use in place of any UTF-16 character that cannot
    be converted.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Strings</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C doesn’t support a primitive string type and likely never will. Instead, it
    implements strings as arrays of characters. C has two types of strings: narrow
    and wide.'
  prefs: []
  type: TYPE_NORMAL
- en: A *narrow string* has the type array of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>.
    It consists of a contiguous sequence of characters that includes a terminating
    null character. A pointer to a string references its initial character. The size
    of a string is the number of bytes allocated to the backing array storage. The
    length of a string is the number of code units (bytes) preceding the first null
    character. In [Figure 7-1](chapter7.xhtml#fig7-1), the size of the string is 7,
    and the length of the string is 5\. Elements of the backing array beyond the last
    element must not be accessed. Elements of the array that haven’t been initialized
    must not be read.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f07001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: A sample narrow
    string</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A *wide string* has the type array of <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>.
    It’s a contiguous sequence of wide characters that includes a terminating null
    wide character. A *pointer* to a wide string references its initial wide character.
    The *length* of a wide string is the number of code units preceding the first
    null wide character. [Figure 7-2](chapter7.xhtml#fig7-2) illustrates both the
    UTF-16BE (big-endian) and UTF-16LE (little-endian) representations of *hello*.
    The size of the array is implementation defined. This array is 14 bytes and assumes
    an implementation that has an 8-bit byte and 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type. The length of this string is 5, as the number of characters has not changed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f07002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: Sample UTF-16BE
    and UTF-16LE wide strings</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Elements of the backing array beyond the last element must not be accessed.
    Elements of the array that haven’t been initialized must not be read.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">String Literals</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *character string literal* is a string constant represented by a sequence
    of zero or more multibyte characters enclosed in double quotes—for example, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">"ABC"</samp>. You can use various prefixes
    to declare string literals of different character types:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> string literal type,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">"ABC"</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp> string literal
    type with <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> prefix, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">L"ABC"</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UTF-8 string literal type with <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp>
    prefix, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">u8"ABC"</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">char16_t</samp> string literal
    type with <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> prefix, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">u"ABC"</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">char32_t</samp> string literal
    type with <samp class="SANS_TheSansMonoCd_W5Regular_11">U</samp> prefix, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">U"ABC"</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C standard doesn’t mandate that an implementation use ASCII for string literals.
    However, you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">u8</samp>
    prefix to force a string literal to be UTF-8 encoded, and if all the characters
    in the literal are ASCII characters, the compiler will produce an ASCII string
    literal, even if the implementation would normally encode string literals in another
    encoding (for example, EBCDIC).
  prefs: []
  type: TYPE_NORMAL
- en: A string literal has a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    array type. Modifying a string literal is undefined behavior and prohibited by
    the CERT C rule STR30-C, “Do not attempt to modify string literals.” This is because
    these string literals may be stored in read-only memory, or multiple string literals
    may share the same memory, resulting in multiple strings being altered if one
    string is modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'String literals often initialize array variables, which you can declare with
    an explicit bound that matches the number of characters in the string literal.
    Consider the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The size of the array <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    is four, the exact size required to initialize the array to the string literal,
    including the space for a trailing null byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you add another character to the string literal used to initialize the array,
    however, the meaning of the code changes substantially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The size of the array <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    remains four, although the size of the string literal is now five. As a result,
    the array <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> is initialized
    to the character array <samp class="SANS_TheSansMonoCd_W5Regular_11">"abcd"</samp>
    with the trailing null byte omitted. By design, this syntax allows you to initialize
    a character array and not a string. Therefore, it’s unlikely that your compiler
    will diagnose this declaration as an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is some risk that if the string literal changes during maintenance, a
    string could unintentionally be changed to a character array with no terminating
    null character, particularly when the string literal is defined apart from the
    declaration, as in this example. If your intent is to always initialize <samp
    class="SANS_TheSansMonoCd_W5Regular_11">s</samp> to a string, you should omit
    the array bound. If you don’t specify the bound of the array, the compiler will
    allocate sufficient space for the entire string literal, including the terminating
    null character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This approach simplifies maintenance because the size of the array can always
    be determined even if the size of the string literal changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The size of arrays declared using this syntax can be determined at compile
    time by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If, instead, we declared this string as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: we would need to invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>
    function to get the length
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: which may incur a runtime cost and is different from the size.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">String-Handling Functions</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several approaches can be used to manage strings in C, the first of which are
    the C standard library functions. Narrow-string-handling functions are defined
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11"><string.h></samp> header
    file and wide-string-handling functions in <samp class="SANS_TheSansMonoCd_W5Regular_11"><wchar.h></samp>.
    These legacy string-handling functions have been associated in recent years with
    various security vulnerabilities. This is because they don’t check the size of
    the array (frequently lacking the information needed to perform such checks) and
    trust you to provide adequately sized character arrays to hold the output. While
    it’s possible to write safe, robust, and error-free code using these functions,
    they promote programming styles that can result in buffer overflows if a result
    is too large for the provided array. These functions aren’t inherently insecure
    but are prone to misuse and need to be used carefully (or not at all).
  prefs: []
  type: TYPE_NORMAL
- en: As a result, C11 introduced the normative (but optional) Annex K bounds-checking
    interfaces. This annex provides alternative library functions intended to promote
    safer, more secure programming by requiring you to provide the length of output
    buffers, for example, and validating that these buffers are adequately sized to
    contain the output from these functions. For instance, Annex K defines the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat_s</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy_s</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat_s</samp>
    functions as close replacements for the C standard library’s <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp> functions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11"><string.h> and <wchar.h></samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C standard library includes well-known functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>,
    and so forth, as well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">memmove</samp> functions that
    you can use to copy and move strings, respectively. The C standard also provides
    a wide-character interface that operates on objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>. (These function
    names are like the narrow-string function names, except that <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>
    is replaced with <samp class="SANS_TheSansMonoCd_W5Regular_11">wcs</samp>, and
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp> is added in front of
    the memory function names.) [Table 7-4](chapter7.xhtml#tab7-4) gives some examples
    of narrow- and wide-character string functions. Refer to the C standard (ISO/IEC
    9899:2024) or man pages for more information on how to use these functions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 7-4:</samp> <samp class="SANS_Futura_Std_Book_11">Narrow-
    and Wide-String Functions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Narrow (</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">char</samp><samp
    class="SANS_Futura_Std_Heavy_B_11">)</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Wide
    (</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">wchar_t</samp><samp class="SANS_Futura_Std_Heavy_B_11">)</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcscpy</samp>
    | <samp class="SANS_Futura_Std_Book_11">String copy</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strncpy</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsncpy</samp>
    | <samp class="SANS_Futura_Std_Book_11">Truncated, zero-filled copy</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wmemcpy</samp>
    | <samp class="SANS_Futura_Std_Book_11">Copies a specified number of nonoverlapping
    code units</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memmove</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wmemmove</samp>
    | <samp class="SANS_Futura_Std_Book_11">Copies a specified number of (possibly
    overlapping) code units</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcscat</samp>
    | <samp class="SANS_Futura_Std_Book_11">Concatenates strings</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strncat</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsncat</samp>
    | <samp class="SANS_Futura_Std_Book_11">Concatenates strings with truncation</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strcmp</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcscmp</samp>
    | <samp class="SANS_Futura_Std_Book_11">Compares strings</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strncmp</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsncmp</samp>
    | <samp class="SANS_Futura_Std_Book_11">Compares truncated strings</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strchr</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcschr</samp>
    | <samp class="SANS_Futura_Std_Book_11">Locates a character in a string</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strcspn</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcscspn</samp>
    | <samp class="SANS_Futura_Std_Book_11">Computes the length of a complementary
    string segment</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsdup</samp>
    | <samp class="SANS_Futura_Std_Book_11">Copies string into allocated storage</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> | <samp class="SANS_Futura_Std_Book_11">N/A</samp>
    | <samp class="SANS_Futura_Std_Book_11">Truncated copy into allocated storage</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strpbrk</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcspbrk</samp>
    | <samp class="SANS_Futura_Std_Book_11">Finds the first occurrence of a set of
    characters in a string</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strrchr</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsrchr</samp>
    | <samp class="SANS_Futura_Std_Book_11">Finds the first occurrence of a character
    in a string</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strspn</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsspn</samp>
    | <samp class="SANS_Futura_Std_Book_11">Computes the length of a string segment</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strstr</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcsstr</samp>
    | <samp class="SANS_Futura_Std_Book_11">Finds a substring</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strtok</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcstok</samp>
    | <samp class="SANS_Futura_Std_Book_11">String tokenizer (modifies the string
    being tokenized)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memchr</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wmemchr</samp>
    | <samp class="SANS_Futura_Std_Book_11">Finds a code unit in memory</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp>
    | <samp class="SANS_Futura_Std_Book_11">Computes string length</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">wmemset</samp>
    | <samp class="SANS_Futura_Std_Book_11">Fills memory with a specified code unit</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp> | <samp
    class="SANS_Futura_Std_Book_11">N/A</samp> | <samp class="SANS_Futura_Std_Book_11">Like</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> <samp class="SANS_Futura_Std_Book_11">but
    always performed</samp> |'
  prefs: []
  type: TYPE_TB
- en: These string-handling functions are considered efficient because they leave
    memory management to the caller and can be used with both statically and dynamically
    allocated storage. In the next couple of sections, I’ll go into more detail on
    some of the more commonly used functions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The wcsdup function listed in [Table 7-4](chapter7.xhtml#tab7-4) is not a
    C standard library function but is defined by POSIX.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Size and Length</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As mentioned earlier in this chapter, strings have both a size (which is the
    number of bytes allocated to the backing array storage) and a length. You can
    determine the size of a statically allocated backing array at compile time by
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can compute the length of a string by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp> function computes
    the length of a wide string measured by the number of code units preceding the
    terminating null wide character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The length is a count of something, but what exactly is being counted can be
    unclear. Here are some of the things that *could* be counted when taking the length
    of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bytes** Useful when allocating storage.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code units** Number of individual code units used to represent the string.
    This length depends on encoding and can also be used to allocate memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code points** Code points (characters) can take up multiple code units. This
    value is not useful when allocating storage.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extended grapheme cluster** A group of one or more Unicode scalar values
    that approximates a single user-perceived character. Many individual characters,
    such as é, <samp class="SANS_Source_Han_Serif_TC_Regular_11">김</samp>, and <samp
    class="SANS_Source_Han_Serif_SC_Regular_11">![](../images/Flag_pg-154.jpg)</samp>,
    may be constructed from multiple Unicode scalar values. Unicode’s boundary algorithms
    combine these code points into extended grapheme clusters.'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp>
    functions count code units. For the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp>
    function, this corresponds to the number of bytes. Determining the amount of storage
    required by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp>
    function is more complicated because the size of the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type is implementation defined. [Listing 7-2](chapter7.xhtml#Lis7-2) contains
    examples of dynamically allocating storage for both narrow and wide strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: Dynamically allocating
    storage for narrow- and wide-string functions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: For narrow strings, we can determine the size of the string by adding <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to the return value of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function to account for
    the terminating null character. For wide strings, we can determine the size of
    the string by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to
    the return value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">wcslen</samp>
    function to account for the terminating null wide character and then multiply
    the sum by the size of the <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>
    type. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">str1</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">wstr1</samp> are declared as pointers
    (and not arrays), it’s not possible to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator to obtain their sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Code point or extended grapheme cluster counts cannot be used for storage allocation
    because they consist of an unpredictable number of code units. (For an interesting
    exposition on string length, see “It’s Not Wrong that <samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp><samp
    class="SANS_AppleColorEmoji_black_Regular_11">![](../images/manpalm.jpg)</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">".length</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp>” at *[https://<wbr>hsivonen<wbr>.fi<wbr>/string<wbr>-length<wbr>/](https://hsivonen.fi/string-length/)*.)
    Extended grapheme clusters are used to determine where to truncate a string, for
    example, because of a lack of storage. Truncation at extended grapheme cluster
    boundaries avoids slicing user-perceived characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function
    can be an expensive operation because it needs to traverse the length of the array
    looking for a null character. The following is a straightforward implementation
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function has
    no way of knowing the size of the object referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>.
    If you call <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> with an
    invalid string that lacks a null character before the bound, the function will
    access the array beyond its end, resulting in undefined behavior. Passing a null
    pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> will also
    result in undefined behavior (a null-pointer dereference). This implementation
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">strlen</samp> function also
    has undefined behavior for strings larger than <samp class="SANS_TheSansMonoCd_W5Regular_11">PTRDIFF_MAX</samp>.
    You should refrain from creating such objects (in which case this implementation
    is fine).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">strcpy</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Calculating the size of dynamically allocated memory is not always easy. One
    approach is to store the size when allocating and reuse this value later. The
    code snippet in [Listing 7-3](chapter7.xhtml#Lis7-3) uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    function to make a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>
    by determining the length and then adding <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    to accommodate the terminating null character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: Copying a string</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can then use the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">str_size</samp>
    to dynamically allocate the storage for the copy. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    function copies the string from the source string (<samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>)
    to the destination string (<samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>),
    including the terminating null character. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    function returns the address of the beginning of the destination string, which
    is ignored in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This code saves a pointer to the destination string in <samp class="SANS_TheSansMonoCd_W5Regular_11">save</samp>
    (to use as the return value) before copying all the bytes from the source to the
    destination array. The <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop terminates when the first null byte is copied. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    doesn’t know the length of the source string or the size of the destination array,
    it assumes that all the function’s arguments have been validated by the caller,
    allowing the implementation to simply copy each byte from the source string to
    the destination array without performing any checks.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Argument Checking</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Argument checking can be performed by either the calling function or the called
    function. Redundant argument testing by both the caller and the callee is a largely
    discredited style of defensive programming. The usual discipline is to require
    validation on only one side of each interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most time-efficient approach is for the caller to perform the check, because
    the caller should have a better understanding of the program state. In [Listing
    7-3](chapter7.xhtml#Lis7-3), we can see that the arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    are valid without introducing further redundant tests: the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>
    references a statically allocated array that was properly initialized in the declaration,
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp> parameter is
    a valid non–null pointer referencing dynamically allocated storage of sufficient
    size to hold a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>,
    including the null character. Therefore, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    is safe, and the copy can be performed in a time-efficient manner. This approach
    to argument checking is commonly used by C standard library functions because
    it adheres to the “spirit of C,” in that it’s optimally efficient and trusts the
    programmer (to pass valid arguments).'
  prefs: []
  type: TYPE_NORMAL
- en: The safer, more secure approach is for the callee to check the arguments. This
    approach is less error-prone because the library function implementer validates
    the arguments, so we no longer need to trust the programmer to pass valid ones.
    The function implementer is usually in a better position to understand which arguments
    need to be validated. If the input validation code is defective, the repair needs
    to be made in only one place. All the code to validate the arguments is in one
    place, so this approach can be more space efficient. However, because these tests
    run even when unnecessary, they can also be less time efficient. Frequently, the
    caller of these functions will place checks before suspect calls that may or may
    not already perform similar checks. This approach would also impose additional
    error handling on callees that don’t currently return error indications but would
    presumably need to if they validated arguments. For strings, the called function
    can’t always determine whether the argument is a valid null-terminated string
    or points to sufficient space to make a copy.
  prefs: []
  type: TYPE_NORMAL
- en: The lesson here is don’t assume that the C standard library functions validate
    arguments unless the standard explicitly requires them to.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">memcpy</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp> function copies
    <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> characters from the
    object referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    into the object referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>
    function instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    to copy strings when the size of the destination array is larger than or equal
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> argument to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>, the source array contains
    a null character before the bound, and the string length is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">size
    - 1</samp> (so that the resulting string will be properly null terminated). The
    best advice is to use <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    when copying a string and <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>
    when copying only raw, untyped memory. Also remember that the assignment (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>) operator can efficiently copy
    objects in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">memccpy</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most of the C standard library’s string-handling functions return a pointer
    to the beginning of the string passed as an argument so that you can nest calls
    to string functions. For example, the following sequence of nested function calls
    constructs a full name using a Western naming order by copying, then concatenating,
    the constituent parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, piecing together the array <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    from its constituent substrings requires <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    to be scanned many more times than necessary; it would have been more useful for
    the string-handling functions to return pointers to the *end* of the modified
    string to eliminate this need for rescanning. C23 introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    function with a better interface design. POSIX environments should already provide
    this, but you may need to enable its declaration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function has
    the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Like the <samp class="SANS_TheSansMonoCd_W5Regular_11">memchr</samp> function,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> scans the source
    sequence for the first occurrence of a character specified by one of its arguments.
    The character can have any value, including zero. It copies (at most) the specified
    number of characters from the source to the destination, without writing beyond
    the end of the destination buffer. Finally, it returns a pointer just past the
    copy of the specified character if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-4](chapter7.xhtml#Lis7-4) reimplements the preceding sequence of
    nested string-handling function calls using the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    function. This implementation is more performant and secure.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-4: String concatenation
    with</samp> <samp class="I">memccpy</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-4](chapter7.xhtml#Lis7-4) defines the variadic function <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp>
    that accepts a buffer (<samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>)
    and buffer length (<samp class="SANS_TheSansMonoCd_W5Regular_11">buff_length</samp>)
    as fixed arguments and a variable list of string arguments. A null pointer is
    used as the sentinel value to indicate the end of the variable-length argument
    list. The <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function
    is invoked ❶ to concatenate each string to the buffer. As previously noted, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> returns a pointer just
    past the copy of the specified character, which in this case is the null termination
    character <samp class="SANS_TheSansMonoCd_W5Regular_11">''\0''</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of nesting calls, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    for each string argument passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp>
    and store the return value in <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>.
    This allows you to concatenate directly to the end of the string instead of having
    to find the null termination character each time, making this solution more performant.
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> is a null pointer,
    we couldn’t copy the entire string. Instead of returning a partial name in this
    case, we return an empty string. This empty string can be printed or treated as
    an error condition.
  prefs: []
  type: TYPE_NORMAL
- en: Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function
    returns a pointer to the character *after* the copy of the null byte, we decrement
    <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> using the prefix decrement
    operator and then subtract the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    to obtain a new <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> ❷.
    The size argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    function (which it uses to prevent buffer overflow) is calculated by subtracting
    <samp class="SANS_TheSansMonoCd_W5Regular_11">offset</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">buff_length</samp>.
    This is a more secure approach than nested function calls, which are always suspect
    because there is no way to check for an error.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">memset, memset_s, and memset_explicit</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function copies
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">(unsigned char)c</samp>
    into each of the first <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    characters of the object pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function is
    frequently used to clear memory—for example, to initialize memory allocated by
    <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> to zero. However,
    in the following example, it’s used incorrectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: One problem with the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_password</samp>
    function is that it uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    function to clear an automatic variable after it has been read for the last time.
    This is being done for security reasons to make sure that the sensitive information
    stored here is inaccessible. However, the compiler doesn’t know that and may perform
    a “dead store” optimization. This is when a compiler notices a write is not followed
    by a read, and just like this book, there is no sense in writing it if no one
    is going to read it. Consequently, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_password</samp> function
    is likely to be removed by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: This problem was meant to be addressed in C11 by the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_s</samp>
    function from Annex K bounds-checking interfaces (discussed in the next section).
    Unfortunately, this function has not been implemented by any compiler mentioned
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem again, C23 introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp>
    function for making sensitive information inaccessible. In contrast to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function, the intention
    is that the memory store is always performed (that is, never elided), regardless
    of optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">gets</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function is a
    flawed input function that accepts input without providing any way to specify
    the size of the destination array. For that reason, it cannot prevent buffer overflows.
    As a result, the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function
    was deprecated in C99 and eliminated from C11\. However, it has been around for
    many years, and most libraries still provide an implementation for backward compatibility,
    so you may see it in the wild. You should *never* use this function, and you should
    replace any use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>
    function you find in any code you’re maintaining.
  prefs: []
  type: TYPE_NORMAL
- en: Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function
    is so bad, we’ll spend some time examining why it’s so awful. The function shown
    in [Listing 7-5](chapter7.xhtml#Lis7-5) prompts the user to enter either <samp
    class="SANS_TheSansMonoCd_W5Regular_11">y</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    to indicate whether they’d like to continue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-5: Misuse of the
    obsolete</samp> <samp class="I">gets</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This function has undefined behavior if more than eight characters are entered
    at the prompt. This undefined behavior occurs because the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>
    function has no way of knowing how large the destination array is and will write
    beyond the end of the array object.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-6](chapter7.xhtml#Lis7-6) shows a simplified implementation of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function. As you can
    see, the caller of this function has no way to limit the number of characters
    read.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-6: A</samp> <samp
    class="I">gets</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    implementation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> function iterates
    reading a character at a time. The loop terminates if either an <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    or newline <samp class="SANS_TheSansMonoCd_W5Regular_11">'\n'</samp> character
    is read. Otherwise, the function will continue to write to the <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>
    array without concern for the boundaries of the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-7](chapter7.xhtml#Lis7-7) shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_y_or_n</samp>
    function from [Listing 7-5](chapter7.xhtml#Lis7-5) with the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>
    function inlined.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-7: A poorly written</samp>
    <samp class="I">while</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The size of the destination array is now available, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop ❶ doesn’t use this information. You should ensure that reaching the bound
    of the array is a loop termination condition when reading or writing to an array
    in a loop such as this one.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Annex K Bounds-Checking
    Interfaces</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C11 introduced the Annex K bounds-checking interfaces with alternative functions
    that verify that output buffers are large enough for the intended result and return
    a failure indicator if they aren’t. These functions are designed to prevent writing
    data past the end of an array and to null-terminate all string results. These
    string-handling functions leave memory management to the caller, and memory can
    be statically or dynamically allocated before the functions are invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft created the C11 Annex K functions to help retrofit its legacy code
    base in response to numerous, well-publicized security incidents in the 1990s.
    These functions were then proposed to the C standards committee for standardization,
    published as ISO/IEC TR 24731-1 (ISO/IEC TR 24731-1:2007) and then later incorporated
    into C11 as an optional annex. Despite the improved usability and security provided
    by these functions, they aren’t yet widely implemented at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">gets_s</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Annex K bounds-checking interface has a <samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp>
    function we can use to eliminate the undefined behavior caused by the call to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp> in [Listing 7-5](chapter7.xhtml#Lis7-5),
    as shown in [Listing 7-8](chapter7.xhtml#Lis7-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-8: Use of the</samp>
    <samp class="I">gets_s</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The two functions are similar, except that the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp>
    function checks the array bounds. The default behavior when the maximum number
    of characters input is exceeded is implementation defined, but typically the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">abort</samp> function is called. You can
    change this behavior via the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp>
    function, which I’ll explain further in “Runtime Constraints” on [page 163](#pg_163).
  prefs: []
  type: TYPE_NORMAL
- en: You need to define <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_WANT_LIB_EXT1__</samp>
    as a macro that expands to the integer constant <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    before including the header files that define the bounds-checking interfaces to
    allow them to be used in your program. Unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets</samp>
    function, the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp> function
    takes a size argument. Consequently, the revised function calculates the size
    of the destination array by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator and passes this value as an argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">gets_s</samp>
    function. The implementation-defined behavior is the result of the runtime-constraint
    violation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">strcpy_s</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function
    is a close replacement for the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    function defined in <samp class="SANS_TheSansMonoCd_W5Regular_11"><string.h></samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function copies
    characters from a source string to a destination character array up to and including
    the terminating null character. Here’s the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function
    has an extra argument of type <samp class="SANS_TheSansMonoCd_W5Regular_11">rsize_t</samp>
    that specifies the maximum length of the destination buffer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">rsize_t</samp>
    type is like the <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> type
    except that functions that accept an argument of this type test to make sure that
    the value is not greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">RSIZE_MAX</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp> function succeeds
    only when it can fully copy the source string to the destination without overflowing
    the destination buffer. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>
    function verifies that the following runtime constraints aren’t violated:'
  prefs: []
  type: TYPE_NORMAL
- en: Neither <samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp> nor <samp class="SANS_TheSansMonoCd_W5Regular_11">s2</samp>
    are null pointers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp> is not greater than
    <samp class="SANS_TheSansMonoCd_W5Regular_11">RSIZE_MAX</samp>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp> does not equal zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp> is greater than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">strnlen_s(s2, s1max)</samp>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying does not take place between overlapping objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To perform the string copy in a single pass, a <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>
    function implementation retrieves a character (or characters) from the source
    string and copies it to the destination array until it has copied the entire string
    or the destination array is full. If it can’t copy the entire string and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">s1max</samp> is not zero, the <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy_s</samp>
    function sets the first byte of the destination array to the null character, creating
    an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Runtime Constraints</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Runtime constraints* are violations of a function’s runtime requirements that
    the function will detect and diagnose by a call to a handler. If this handler
    returns, the functions will return a failure indicator to the caller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bounds-checking interfaces enforce runtime constraints by invoking a runtime-constraint
    handler, which may simply return. Alternatively, the runtime-constraint handler
    might print a message to <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>
    and/or abort the program. You can control which handler function is called via
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp>
    function and make the handler simply return as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If the handler returns, the function that identified the runtime-constraint
    violation and invoked the handler indicates a failure to its caller by using its
    return value.
  prefs: []
  type: TYPE_NORMAL
- en: The bounds-checking interface functions typically check the conditions either
    immediately upon entry or as they perform their tasks and gather sufficient information
    to determine whether a runtime constraint has been violated. The runtime constraints
    of the bounds-checking interfaces are conditions that would otherwise be undefined
    behavior for C standard library functions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementations have a default constraint handler that they invoke if no calls
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp>
    function have been made. The default handler’s behavior may cause the program
    to exit or abort, but implementations are encouraged to provide reasonable behavior
    by default. This allows, for example, compilers customarily used to implement
    safety-critical systems to not abort by default. You must check the return value
    of calls to functions that can return and not simply assume their results are
    valid. Implementation-defined behavior can be eliminated by invoking the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp> function
    before invoking any bounds-checking interfaces or using any mechanism that invokes
    a runtime-constraint handler.
  prefs: []
  type: TYPE_NORMAL
- en: Annex K provides the <samp class="SANS_TheSansMonoCd_W5Regular_11">abort_handler_s</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ignore_handler_s</samp> functions,
    which represent two common strategies for handling errors. The C implementation’s
    default handler need not be either of these handlers.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">POSIX</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: POSIX also defines several string-handling functions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> (IEEE Std 1003.1:2018),
    that provide another set of string-related APIs for POSIX-compliant platforms
    such as GNU/Linux and Unix (IEEE Std 1003.1:2018). Both functions were adopted
    into the C standard library by C23.
  prefs: []
  type: TYPE_NORMAL
- en: These replacement functions use dynamically allocated memory to ensure that
    buffer overflows don’t occur, and they implement a *callee allocates, caller frees*
    model. Each function ensures that enough memory is available (except when a call
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> fails). The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> function, for example, returns
    a pointer to a new string that contains a duplicate of the argument. The returned
    pointer should be passed to the C standard <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    function to reclaim the storage when it’s no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-9](chapter7.xhtml#Lis7-9) contains a code snippet that uses the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> function to make a
    copy of the string returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">getenv</samp>
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-9: Copying a string
    using the</samp> <samp class="I">strdup</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11">getenv</samp>
    function searches an environment list, provided by the host environment, for a
    string that matches the string referenced by a specified name (<samp class="SANS_TheSansMonoCd_W5Regular_11">TMP</samp>
    in this example). Strings in this environment list are referred to as *environment
    variables* and provide an additional mechanism for communicating strings to a
    process. These strings don’t have a well-defined encoding but typically match
    the system encoding used for command line arguments, <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The returned string (the value of the variable) may be overwritten by a subsequent
    call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">getenv</samp> function,
    so it’s a good idea to retrieve any environmental variable you need before creating
    any threads to eliminate the possibility of a race condition. If later use is
    anticipated, you should copy the string so the copy can be safely referenced as
    needed, as illustrated by the idiomatic example shown in [Listing 7-9](chapter7.xhtml#Lis7-9).
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> function is
    equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>, except
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> copies, at most,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> bytes into the newly allocated
    memory (while <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> copies
    the entire string) and ensures that the newly created string is always properly
    terminated.
  prefs: []
  type: TYPE_NORMAL
- en: These POSIX functions can help prevent buffer overflows by automatically allocating
    storage for the resulting strings, but this requires introducing additional calls
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> when this storage
    is no longer needed. This means matching a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    to each call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp>, for example, which
    can be confusing to programmers who are more familiar with the behavior of the
    string functions defined by <samp class="SANS_TheSansMonoCd_W5Regular_11"><string.h></samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Microsoft</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visual C++ provides all the string-handling functions defined by the C standard
    library up to C99 but doesn’t implement the full POSIX specification. However,
    sometimes the Microsoft implementation of these APIs differs from the requirements
    of a given standard or has a function name that conflicts with an identifier reservation
    in another standard. In these circumstances, Microsoft will often prefix the function
    name with an underscore. For instance, the POSIX function <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp>
    isn’t available on Windows, but the function <samp class="SANS_TheSansMonoCd_W5Regular_11">_strdup</samp>
    is available and behaves the same way.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For more information on Microsoft’s POSIX support, see* [https://<wbr>docs<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/cpp<wbr>/c<wbr>-runtime<wbr>-library<wbr>/compatibility](https://docs.microsoft.com/en-us/cpp/c-runtime-library/compatibility)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual C++ also supports many of the safe string-handling functions from Annex
    K and will diagnose the use of an unsafe variant unless you define <samp class="SANS_TheSansMonoCd_W5Regular_11">_CRT_SECURE_NO_WARNINGS</samp>
    prior to including the header file that declares the function. Unfortunately,
    Visual C++ does not conform to Annex K of the C standard, because Microsoft chose
    not to update its implementation based on changes to the APIs that occurred during
    the standardization process. For example, Visual C++ doesn’t provide the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">set_constraint_handler_s</samp> function
    but instead retains an older function with similar behavior but an incompatible
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Microsoft also doesn’t define the <samp class="SANS_TheSansMonoCd_W5Regular_11">abort_handler_s</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ignore_handler_s</samp> functions,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_s</samp> function (which
    was not defined by ISO/IEC TR 24731-1), or the <samp class="SANS_TheSansMonoCd_W5Regular_11">RSIZE_MAX</samp>
    macro. Visual C++ also doesn’t treat overlapping source and destination sequences
    as runtime-constraint violations and instead has undefined behavior in such cases.
    “Bounds-Checking Interfaces: Field Experience and Future Directions” (Seacord
    2019) provides additional information on all aspects of the bounds-checked interfaces,
    including Microsoft’s implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about character encodings, such as ASCII and Unicode.
    You also learned about the various data types used to represent characters in
    C language programs, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">wchar_t</samp>,
    and so forth. We then covered character conversion libraries, including C standard
    library functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">libiconv</samp>,
    and Windows APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to characters, you also learned about strings and the legacy functions
    and bounds-checked interfaces defined in the C standard library for handling strings,
    as well as some POSIX- and Microsoft-specific functions.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating character and string data is a common programming task in C as
    well as a frequent source of errors. We outlined various approaches to handling
    these data types; you should determine which approach is best suited to your application
    and apply that approach consistently.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about I/O, which, among other things, can
    be used to read and write characters and strings.
  prefs: []
  type: TYPE_NORMAL
