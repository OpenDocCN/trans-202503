<html><head></head><body>
		<h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_225"/><strong><span class="big">8</span></strong><br/><strong>ARRAY DATA TYPES</strong></h2>&#13;
		<div class="image1">&#13;
			<img alt="image" src="../images/common01.jpg"/>&#13;
		</div>&#13;
		<p class="noindent">High-level language abstractions hide how the machine deals with <em>composite data types</em> (a complex data type composed of smaller data objects). Although these abstractions are often convenient, if you don’t understand the details behind them you might inadvertently use a construct that generates unnecessary code or runs slower than need be. In this chapter, we’ll take a look at one of the most important composite data types: the array. We’ll consider the following topics:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">The definition of an array</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">How to declare arrays in various languages</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">How arrays are represented in memory</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Accessing elements of arrays</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Declaring, representing, and accessing multidimensional arrays</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Row-major and column-major multidimensional array access</p>&#13;
				</li>&#13;
			<li><span epub:type="pagebreak" id="page_226"/>&#13;
			<p class="noindent">Dynamic versus static arrays</p>&#13;
			</li>&#13;
			<li>&#13;
				<p class="noindent">How using arrays can impact the performance and size of your applications</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">Arrays are very common in modern applications, so you should have a solid understanding of how programs implement and use them in memory in order to write great code. This chapter will give you the foundation you need to use arrays more efficiently in your programs.</p>&#13;
		<h3 class="h3" id="ch00lev1sec70"><strong>8.1 Arrays</strong></h3>&#13;
		<p class="noindent">Arrays are one of the most common composite (or <em>aggregate</em>) data types, yet few programmers fully grasp how they operate. Once they understand how arrays work at the machine level, programmers frequently view them from a completely different perspective.</p>&#13;
		<p class="indent">Abstractly, an array is an aggregate data type whose members (elements) are all of the same type. To select a member from the array, you specify the member’s array index with an integer (or with some value whose underlying representation is an integer, such as character, enumerated, and Boolean types). In this chapter, we’ll assume that all of the integer indices of an array are numerically contiguous. That is, if both <code>x</code> and <code>y</code> are valid indices of the array, and if <code>x</code> &lt; <code>y</code>, then all <code>i</code> such that <code>x</code> &lt; <code>i</code> &lt; <code>y</code> are also valid indices. We’ll also typically assume that array elements occupy contiguous locations in memory, although this is not required by the general definition of an array. An array with five elements appears in memory as shown in <a href="ch08.xhtml#ch8fig1">Figure 8-1</a>.</p>&#13;
		<div class="image" id="ch8fig1">&#13;
			<img alt="Image" src="../images/08fig01.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 8-1: Array layout in memory</em></p>&#13;
		<p class="indent">The <em>base address</em> of an array is the address of its first element that occupies the lowest memory location. The second array element directly follows the first in memory, the third element follows the second, and so on. Note that the indices do not have to start at <code>0</code>; they can start with any number as long as they are contiguous. However, discussing array access is easier if the first index is <code>0</code>, so arrays in this chapter begin at index <code>0</code> unless otherwise indicated.</p>&#13;
		<p class="indent">Whenever you apply the indexing operator to an array, the result is the unique array element specified by that index. For example, <code>A[i]</code> chooses the <code>i</code>th element from array <code>A</code>.</p>&#13;
		<h4 class="h4" id="ch00lev2sec93"><strong>8.1.1 Array Declarations</strong></h4>&#13;
		<p class="noindent">Array declarations are very similar across many high-level languages (HLLs). This section presents examples in several languages.</p>&#13;
		<h5 class="h5" id="ch00lev3sec46"><span epub:type="pagebreak" id="page_227"/><strong>8.1.1.1 Declaring Arrays in C, C++, and Java</strong></h5>&#13;
		<p class="noindent">C, C++, and Java all let you declare an array by specifying the total number of elements. The syntax for an array declaration in these languages is:</p>&#13;
		<pre class="programs"><span class="codeitalic1">data_type</span>  <span class="codeitalic1">array_name</span> [ <span class="codeitalic1">number_of_elements</span> ];</pre>&#13;
		<p class="indent">Here are some sample C/C++ array declarations:</p>&#13;
		<pre class="programs">&#13;
			char CharArray[ 128 ];<br/>int intArray[ 8 ];<br/>unsigned char ByteArray[ 10 ];<br/>int *PtrArray[ 4 ];</pre>&#13;
		<p class="indent">If you declare these arrays as automatic variables, C/C++ initializes them with whatever bit patterns happen to exist in memory. If, on the other hand, you declare these arrays as static objects, C/C++ initializes each array element with <code>0</code>. If you want to initialize an array yourself, you can use the following C/C++ syntax:</p>&#13;
		<pre class="programs"><span class="codeitalic1">data_type array_name</span>[ <span class="codeitalic1">number_of_elements</span> ] = {<span class="codeitalic1">element_list</span>};</pre>&#13;
		<p class="indent">Here’s a typical example:</p>&#13;
		<pre class="programs">int intArray[8] = {0,1,2,3,4,5,6,7};</pre>&#13;
		<p class="indent">The C/C++ compiler stores these initial array values in the object code file, and the operating system will load these values into the memory locations associated with <code>intArray</code> when it loads the program into memory. To see how this works, consider the following short C/C++ program:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/>static int intArray[8] = {1,2,3,4,5,6,7,8};<br/>static int array2[8];<br/><br/>int main( int argc, char **argv )<br/>{<br/>    int i;<br/>    for( i=0; i&lt;8; ++i )<br/>    {<br/>        array2[i] = intArray[i];<br/>    }<br/>    for( i=7; i&gt;= 0; --i )<br/>    {<br/>        printf( "%d\n", array2[i] );<br/>    }<br/>    return 0;<br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_228"/>Microsoft’s Visual C++ compiler emits the following 80x86 assembly code for the two array declarations:</p>&#13;
		<pre class="programs">&#13;
			_DATA    SEGMENT<br/>intArray DD      01H<br/>         DD      02H<br/>         DD      03H<br/>         DD      04H<br/>         DD      05H<br/>         DD      06H<br/>         DD      07H<br/>         DD      08H<br/>$SG6842  DB      '%d', 0aH, 00H<br/>_DATA    ENDS<br/>_BSS     SEGMENT<br/>_array2  DD      08H DUP (?)<br/>_BSS     ENDS</pre>&#13;
		<p class="indent">Each <code>DD</code> (“define double word”) statement reserves 4 bytes of storage, and the operand specifies their initial value when the OS loads the program into memory. The <code>intArray</code> declaration appears in the <code>_DATA</code> segment, which in the Microsoft memory model can contain initialized data. The <code>array2</code> variable, on the other hand, is declared inside the <code>_BSS</code> segment, where MSVC++ places uninitialized variables (the <code>?</code> character in the operand field tells the assembler that the data is uninitialized; the <code>8 dup (?)</code> operand tells the assembler to duplicate the declaration eight times). When the OS loads the <code>_BSS</code> segment into memory, it simply zeros out all the memory associated with that segment. In both the initialized and uninitialized cases, the compiler allocates all eight elements of these arrays in sequential memory locations.</p>&#13;
		<h5 class="h5" id="ch00lev3sec47"><strong>8.1.1.2 Declaring Arrays in HLA</strong></h5>&#13;
		<p class="noindent">HLA’s array declaration syntax takes the following form, which is semantically equivalent to the C/C++ declaration:</p>&#13;
		<pre class="programs"><span class="codeitalic1">array_name</span> : <span class="codeitalic1">data_type</span> [ <span class="codeitalic1">number_of_elements</span> ];</pre>&#13;
		<p class="indent">Here are some examples of HLA array declarations that allocate storage for uninitialized arrays (the second example assumes you have defined the <code>integer</code> data type in a <code>type</code> section of the HLA program):</p>&#13;
		<pre class="programs">&#13;
			static<br/><br/> // Character array with elements 0..127.<br/><br/> CharArray: char[128];<br/><br/> // "integer" array with elements 0..7.<br/><br/> IntArray: integer[ 8 ];<br/><br/><span epub:type="pagebreak" id="page_229"/>// Byte array with elements 0..9.<br/><br/> ByteArray: byte[10];<br/><br/> // Double word array with elements 0..3.<br/><br/> PtrArray: dword[4];</pre>&#13;
		<p class="indent">You can also initialize the array elements using declarations like the following:</p>&#13;
		<pre class="programs">&#13;
			RealArray: real32[8] :=<br/>    [ 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 ];<br/><br/>IntegerAry: integer[8] :=<br/>    [ 8, 9, 10, 11, 12, 13, 14, 15 ];</pre>&#13;
		<p class="indent">Both of these definitions create arrays with eight elements. The first definition initializes each 4-byte <code>real32</code> array element with one of the values in the range <code>0.0..7.0</code>. The second declaration initializes each <code>integer</code> array element with one of the values in the range <code>8..15</code>.</p>&#13;
		<h5 class="h5" id="ch00lev3sec48"><strong>8.1.1.3 Declaring Arrays in Pascal/Delphi</strong></h5>&#13;
		<p class="noindent">Pascal/Delphi uses the following syntax to declare an array:</p>&#13;
		<pre class="programs"><span class="codeitalic1">array_name</span> : <span class="codeitalic1">array</span>[ <span class="codeitalic1">lower_bound</span>..<span class="codeitalic1">upper_bound</span> ] of <span class="codeitalic1">data_type</span>;</pre>&#13;
		<p class="indent">As in the previous examples, <span class="codeitalic">array_name</span> is the identifier and <span class="codeitalic">data_type</span> is the type of each element in this array. In Pascal/Delphi (unlike C/C++, Java, and HLA) you specify the upper and lower bounds of the array rather than the array’s size. The following are typical array declarations in Pascal:</p>&#13;
		<pre class="programs">&#13;
			type<br/>    ptrToChar = ^char;<br/>var<br/>    CharArray: array[ 0..127 ] of char;   // 128 elements<br/>    IntArray: array[ 0..7 ] of integer;   // 8 elements<br/>    ByteArray: array[ 0..9 ] of char;     // 10 elements<br/>    PtrArray: array[ 0..3 ] of ptrToChar; // 4 elements</pre>&#13;
		<p class="indent">Although these Pascal examples start their indices at <code>0</code>, Pascal does not require it. The following is a perfectly valid array declaration in Pascal:</p>&#13;
		<pre class="programs">&#13;
			var<br/>   ProfitsByYear : array[ 1998..2028 ] of real; // 31 elements</pre>&#13;
		<p class="indent">The program that declares this array would use indices <code>1998..2028</code> when accessing elements of this array, not <code>0..30</code>.</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_230"/>Many Pascal compilers provide a very useful feature to help you locate defects in your programs. Whenever you access an element of an array, these compilers automatically insert code that will verify that the array index is within the bounds specified by the declaration. This extra code will stop the program if the index is out of range. For example, if an index into <code>ProfitsByYear</code> is outside the range <code>1998..2028</code>, the program will abort with an error.<sup><a id="ch8fn_1"/><a href="footnotes.xhtml#ch8fn1">1</a></sup></p>&#13;
		<h5 class="h5" id="ch00lev3sec49"><strong>8.1.1.4 Declaring Arrays in Swift</strong></h5>&#13;
		<p class="noindent">Array declarations in Swift are a bit different from those of other C-based languages. Swift array declarations take one of the following two (equivalent) forms:</p>&#13;
		<pre class="programs">&#13;
			var <span class="codeitalic1">data_type array_name</span> = Array&lt;<span class="codeitalic1">element_type</span>&gt;()<br/>var <span class="codeitalic1">data_type array_name</span> = [<span class="codeitalic1">element_type</span>]()</pre>&#13;
		<p class="indent">Unlike in other languages, arrays in Swift are purely dynamic. You don’t normally specify the number of elements when you first create the array; instead, you add elements to the array as needed using functions like <code>append()</code>. If you want to predeclare an array with some number of elements, you can use a special array constructor form as follows:</p>&#13;
		<pre class="programs">&#13;
			var <span class="codeitalic1">data_type array_name</span> = Array&lt;<span class="codeitalic1">element_type</span>&gt;( repeating: <span class="codeitalic1">initial_value</span>, count: <span class="codeitalic1">elements</span> )</pre>&#13;
		<p class="indent">In this example, <span class="codeitalic">initial_value</span> is a value of type <span class="codeitalic">element_type</span> and <span class="codeitalic">elements</span> is the number of elements to create in the array. For example, the following Swift code creates two arrays of 100 <code>Int</code> values, each initialized to <code>0</code>:</p>&#13;
		<pre class="programs">&#13;
			var intArray = Array&lt;Int&gt;( repeating: 0, count: 100 )<br/>var intArray2 = [Int]( repeating: 0, count: 100 )</pre>&#13;
		<p class="indent">Note that you can still extend the size of this array (for example, by using the <code>append()</code> function); because Swift arrays are dynamic, their size can grow or shrink at runtime.</p>&#13;
		<p class="indent">It is also possible to create a Swift array with initial values:</p>&#13;
		<pre class="programs">&#13;
			var intArray = [1, 2, 3]<br/>var strArray = ["str1", "str2", "str3"]</pre>&#13;
		<p class="indent">Swift, like Pascal, checks the validity of array indices at runtime. Swift will raise an exception if you attempt to access an array element that doesn’t exist.</p>&#13;
		<h5 class="h5" id="ch00lev3sec50"><span epub:type="pagebreak" id="page_231"/><strong>8.1.1.5 Declaring Arrays with Noninteger Index Values</strong></h5>&#13;
		<p class="noindent">Generally, array indices are integer values, although some languages allow other <em>ordinal types</em> (data types that use an underlying integer representation). For example, Pascal allows <code>char</code> and <code>boolean</code> array indices. In Pascal, it’s perfectly reasonable and useful to declare an array as follows:</p>&#13;
		<pre class="programs">alphaCnt : array[ 'A'..'Z' ] of integer;</pre>&#13;
		<p class="indent">You access elements of <code>alphaCnt</code> using a character expression as the array index. For example, consider the following Pascal code, which initializes each element of <code>alphaCnt</code> to <code>0</code>:</p>&#13;
		<pre class="programs">&#13;
			for ch := 'A' to 'Z' do<br/>    alphaCnt[ ch ] := 0;</pre>&#13;
		<p class="indent">Assembly language and C/C++ treat most ordinal values as special instances of integer values, so they are legal array indices. Most implementations of BASIC allow a floating-point number as an array index, although BASIC always truncates the value to an integer before using it as an index.</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>BASIC allows you to use floating-point values as array indices because the original language did not provide support for integer expressions; it provided only real and string values.</em></p>&#13;
		</div>&#13;
		<h4 class="h4" id="ch00lev2sec94"><strong>8.1.2 Array Representation in Memory</strong></h4>&#13;
		<p class="noindent">Abstractly, an array is a collection of variables that you access using an index. Semantically, you can define an array any way you please, as long as it maps distinct indices to distinct objects in memory and always maps the same index to the same object. In practice, however, most languages utilize a few common algorithms that provide efficient access to the array data.</p>&#13;
		<p class="indent">The most common implementation of arrays is to store elements in consecutive memory locations. As noted earlier, most programming languages store the first element of an array at a low memory address and then store the following elements in successively higher memory locations.</p>&#13;
		<p class="indent">Consider the following C program:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>static char array[8] = {0,1,2,3,4,5,6,7};<br/><br/><br/><br/>int main( void )<br/>{<br/><br/>    printf( "%d\n", array[0] );<br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_232"/>Here is the corresponding PowerPC assembly code that GCC emits for it:</p>&#13;
		<pre class="programs">&#13;
			        .align 2<br/>_array:<br/>        .byte   0   ; Note that the assembler stores the byte<br/>        .byte   1   ; values on successive lines into<br/>        .byte   2   ; contiguous memory locations.<br/>        .byte   3<br/>        .byte   4<br/>        .byte   5<br/>        .byte   6<br/>        .byte   7</pre>&#13;
		<p class="indent">The number of bytes an array consumes is the number of elements multiplied by the number of bytes per element. In the previous example, each array element is a single byte, so the array consumes the same number of bytes as it has elements. However, for arrays with larger elements, the entire array size (in bytes) is correspondingly larger. Consider the following C code:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>static int array[8] = {0,0,0,0,0,0,0,1};<br/><br/><br/>int main( void )<br/>{<br/>    printf( "%d\n", array[0] );<br/>}</pre>&#13;
		<p class="indent">Here’s the corresponding GCC assembly language output:</p>&#13;
		<pre class="programs">&#13;
			        .align 2<br/>_array:<br/>        .long   0<br/>        .long   0<br/>        .long   0<br/>        .long   0<br/>        .long   0<br/>        .long   0<br/>        .long   0<br/>        .long   1</pre>&#13;
		<p class="indent">Many languages also add a few bytes of padding at the end of an array so that the array’s total length will be a multiple of a convenient value like 2 or 4 (making it easy to compute indices into the array using shifts or to add extra padding bytes for the next object in memory; see <a href="ch03.xhtml#ch03">Chapter 3</a> of <em>WGC1</em> for details). However, a program must not count on those extra padding bytes, because they may or may not be present. Some compilers always put them in, others never do, and still others put them in depending on the type of object that immediately follows the array in memory.</p>&#13;
		<p class="indent">Many optimizing compilers try to start an array at a memory address that is a multiple of a common size like 2, 4, or 8 bytes. Effectively, this adds <span epub:type="pagebreak" id="page_233"/>padding bytes before the beginning of the array or, if you prefer to think of it this way, after the previous object in memory (see <a href="ch08.xhtml#ch8fig2">Figure 8-2</a>).</p>&#13;
		<div class="image" id="ch8fig2">&#13;
			<img alt="Image" src="../images/08fig02.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 8-2: Adding padding bytes before an array</em></p>&#13;
		<p class="indent">On machines that do not support byte-addressable memory, compilers that attempt to place the first element of an array on an easily accessed boundary will allocate storage for an array on whatever boundary the machine supports. In the previous example, notice that the <code>.align 2</code> directive precedes the <code>_array</code> declaration. In Gas syntax, the <code>.align</code> directive tells the assembler to adjust the memory address of the next object declared in the source file so that it starts at an address that is a multiple of some power (specified by <code>.align</code>’s operand) of 2. In this example, <code>.align 2</code> tells the assembler to align the first element of <code>_array</code> on an address boundary that is a multiple of 4 (that is, 2<sup>2</sup>).</p>&#13;
		<p class="indent">If the size of each array element is less than the minimum-sized memory object the CPU supports, the compiler implementer has two options:</p>&#13;
		<ol>&#13;
			<li>&#13;
				<p class="noindent">Allocate the smallest accessible memory object for each element of the array.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Pack multiple array elements into a single memory cell.</p>&#13;
				</li>&#13;
		</ol>&#13;
		<p class="indent">Option 1 has the advantage of being fast, but it wastes memory because each array element carries some extra storage that it doesn’t need. The following C example allocates storage for an array whose element size is 5 bytes, where each element is a structure object consisting of a 4-byte <code>long</code> object and a 1-byte <code>char</code> object (we’ll look at C structures in <a href="ch11.xhtml#ch11">Chapter 11</a>).</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdio.h&gt;<br/><br/>typedef struct<br/>{<br/>    long a;<br/>    char b;<br/>} FiveBytes;<br/><br/>static FiveBytes shortArray[2] = {{2,3}, {4,5}};<br/><span epub:type="pagebreak" id="page_234"/>int main( void )<br/>{<br/>    printf( "%ld\n", shortArray[0].a );<br/>}</pre>&#13;
		<p class="indent">When GCC compiles this code to run on a PowerPC processor, which requires double-word alignment for <code>long</code> objects, the compiler automatically inserts 3 bytes of padding between each element:</p>&#13;
		<pre class="programs">&#13;
			.data<br/>        .align 2   ; Ensure that _shortArray begins on an<br/>                   ; address boundary that is a multiple<br/>                   ; of 4.<br/>_shortArray:<br/>        .long   2  ; shortArray[0].a<br/>        .byte   3  ; shortArray[0].b<br/>        .space  3  ; Padding, to align next element to 4 bytes<br/>        .long   4  ; shortArray[1].a<br/>        .byte   5  ; shortArray[1].b<br/>        .space  3  ; Padding, at end of array.</pre>&#13;
		<p class="indent">Option 2 is compact but slower, as it requires extra instructions to pack and unpack data when accessing array elements. Compilers on such machines often provide an option that lets you specify whether you want the data packed or unpacked so you can choose between space and speed.</p>&#13;
		<p class="indent">Keep in mind that if you’re working on a byte-addressable machine (like the 80x86), then you probably don’t have to worry about this issue. However, if you’re using an HLL and your code might run on a different machine at some point in the future, you should choose an array organization that is efficient on all machines (that is, an organization that pads each element of the array with extra bytes).</p>&#13;
		<h4 class="h4" id="ch00lev2sec95"><strong>8.1.3 Swift Array Implementation</strong></h4>&#13;
		<p class="noindent">Although the examples so far have included arrays in Swift, Swift arrays have a different implementation. First of all, Swift arrays are an opaque type<sup><a id="ch8fn_2"/><a href="footnotes.xhtml#ch8fn2">2</a></sup> based on <code>struct</code> objects, rather than just a collection of elements in memory. Swift doesn’t guarantee that array elements appear in continuous memory locations; thus, you can’t assume that object elements and certain other element types in a Swift array are stored contiguously. As a workaround, Swift provides the <code>ContiguousArray</code> type specification. To guarantee that array elements appear in contiguous memory locations, you can specify <code>ContiguousArray</code> rather than <code>Array</code> when declaring array variables in Swift, like so:</p>&#13;
		<pre class="programs">&#13;
			var <span class="codeitalic1">data_type array_name</span> = ContiguousArray&lt;<span class="codeitalic1">element_type</span>&gt;()</pre>&#13;
		<p class="indent">The internal implementation of a Swift array is a structure containing a count (current number of array elements), a capacity (current number <span epub:type="pagebreak" id="page_235"/>of allocated array elements), and a pointer to the storage holding the array elements. Because Swift arrays are an opaque type, this implementation could change at any time; however, somewhere in the structure there will be a pointer to the actual array data in memory.</p>&#13;
		<p class="indent">Swift allocates storage for arrays dynamically, which means you’ll never see the array storage embedded in the object code file that the Swift compiler produces (unless the Swift language definition changes to support statically allocated arrays). You can increase the size of an array by appending elements to it, but if you attempt to extend it beyond its current capacity, the Swift runtime system may need to dynamically relocate an array object. For performance reasons, Swift uses an exponential allocation scheme: whenever you append a value to an array that would exceed its capacity, the Swift runtime system will allocate twice (or some other constant) as much storage as the current capacity, copy the data from the current array buffer to the new buffer, and then point the array’s internal pointer at the new block. One important aspect of this process is that you can never assume that the pointer to the array’s data remains static or that the array’s data remains in the same buffer location in memory—at different points in time, the array could appear in different locations in memory.</p>&#13;
		<h4 class="h4" id="ch00lev2sec96"><strong>8.1.4 Accessing Elements of an Array</strong></h4>&#13;
		<p class="noindent">If you allocate all the storage for an array in contiguous memory locations, and the first index of the array is <code>0</code>, then accessing an element of a one-dimensional array is simple. You can compute the address of any given element of an array using the following formula:</p>&#13;
		<pre class="programs"><span class="codeitalic1">Element_Address</span> = <span class="codeitalic1">Base_Address</span> + <span class="codeitalic1">index</span> * <span class="codeitalic1">Element_Size</span></pre>&#13;
		<p class="indent"><span class="codeitalic">Element_Size</span> is the number of bytes that each array element occupies. Therefore, if the array contains elements of type <code>byte</code>, the <span class="codeitalic">Element_Size</span> field is <code>1</code> and the math is very easy. If each element of the array is a <code>word</code> (or other 2-byte type), then <code>Element_Size</code> is <code>2</code>, and so on. Consider the following Pascal array declaration:</p>&#13;
		<pre class="programs">var  SixteenInts : array[0..15] of integer;</pre>&#13;
		<p class="indent">To access an element of the <code>SixteenInts</code> array on a byte-addressable machine, assuming 4-byte integers, you’d use this calculation:</p>&#13;
		<pre class="programs"><span class="codeitalic1">Element_Address</span> = <span class="codeitalic1">AddressOf( SixteenInts )</span> + <span class="codeitalic1">index</span> * 4</pre>&#13;
		<p class="indent">In HLA assembly language (where you’d have to do this calculation manually rather than having the compiler do it for you), you could use code like this to access array element <code>SixteenInts[index]</code>:</p>&#13;
		<pre class="programs">&#13;
			mov( index, ebx );<br/>mov( SixteenInts[ ebx*4 ], eax );</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_236"/>To see this in action, consider the following Pascal/Delphi program and the resulting 32-bit 80x86 code (which I obtained by disassembling the <em>.exe</em> output from the Delphi compiler and pasting the result back into the original Pascal code):</p>&#13;
		<pre class="programs">&#13;
			program x(input,output);<br/>var<br/>    i :integer;<br/>    sixteenInts :array[0..15] of integer;<br/><br/>    function changei(i:integer):integer;<br/>    begin<br/>        changei := 15 - i;<br/>    end;<br/><br/>    // changei         proc    near<br/>    //                 mov     edx, 0Fh<br/>    //                 sub     edx, eax<br/>    //                 mov     eax, edx<br/>    //                 retn<br/>    // changei         endp<br/><br/><br/>begin<br/>    for i:= 0 to 15 do<br/>        sixteenInts[ changei(i) ] := i;<br/><br/>    //                 xor     ebx, ebx<br/>    //<br/>    // loc_403AA7:<br/>    //                 mov     eax, ebx<br/>    //                 call    changei<br/>    //<br/>    // Note the use of the scaled-index addressing mode<br/>    // to multiply the array index by 4 prior to accessing<br/>    // elements of the array:<br/>    //<br/>    //                 mov     ds:sixteenInts[eax*4], ebx<br/>    //                 inc     ebx<br/>    //                 cmp     ebx, 10h<br/>    //                 jnz     short loc_403AA7<br/><br/>end.</pre>&#13;
		<p class="indent">As in the HLA example, the Delphi compiler uses the 80x86 scaled-index addressing mode to multiply the index into the array by the element size (4 bytes). The 80x86 provides four different scaling values for the scaled-index addressing mode: 1, 2, 4, or 8 bytes. If the array’s element size is not one of these four values, the machine code must explicitly multiply the index by the array element’s size. The following Delphi/Pascal code (and corresponding 80x86 code from the disassembly) demonstrates this process using a record that has 9 bytes of active data (Delphi rounds this up <span epub:type="pagebreak" id="page_237"/>to the next multiple of 4 bytes, so it actually allocates 12 bytes for each element of the array of records):</p>&#13;
		<pre class="programs">&#13;
			program x(input,output);<br/>type<br/>    NineBytes=<br/>        record<br/>            FourBytes       :integer;<br/>            FourMoreBytes   :integer;<br/>            OneByte         :char;<br/>        end;<br/><br/>var<br/>    i               :integer;<br/>    NineByteArray   :array[0..15] of NineBytes;<br/><br/>    function changei(i:integer):integer;<br/>    begin<br/>        changei := 15 - i;<br/>    end;<br/><br/>    // changei         proc    near<br/>    //                 mov     edx, 0Fh<br/>    //                 sub     edx, eax<br/>    //                 mov     eax, edx<br/>    //                 retn<br/>    // changei         endp<br/><br/><br/>begin<br/><br/>    for i:= 0 to 15 do<br/>        NineByteArray[ changei(i) ].FourBytes := i;<br/><br/>//                  xor     ebx, ebx<br/>//<br/>//  loc_403AA7:<br/>//                  mov     eax, ebx<br/>//                  call    changei<br/>//<br/>//            // Compute EAX = EAX * 3<br/>//<br/>//                  lea     eax, [eax+eax*2]<br/>//<br/>//            // Actual index used is index*12 ((EAX*3) * 4)<br/>//<br/>//                  mov     ds:NineByteArray[eax*4], ebx<br/>//                  inc     ebx<br/>//                  cmp     ebx, 10h<br/>//                  jnz     short loc_403AA7<br/><br/><br/>end.</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_238"/>Microsoft’s C/C++ compilers emit comparable code (also allocating 12 bytes for each element of the array of records).</p>&#13;
		<h4 class="h4" id="ch00lev2sec97"><strong>8.1.5 Padding vs. Packing</strong></h4>&#13;
		<p class="noindent">These Pascal examples reiterate an important point: compilers generally pad each array element to a multiple of 4 bytes, or whatever size is most convenient for the machine’s architecture, to improve access to array elements (and record fields) by ensuring that they are always aligned on a reasonable memory boundary. Some compilers give you the option of eliminating the padding at the end of each array element, so that successive array elements immediately follow the previous element in memory. In Pascal/Delphi, for example, you can achieve this by using the <code>packed</code> keyword:</p>&#13;
		<pre class="programs">&#13;
			program x(input,output);<br/><br/>// Note the use of the "packed" keyword.<br/>// This tells Delphi to pack each record<br/>// into 9 consecutive bytes, without<br/>// any padding at the end of the record.<br/><br/>type<br/>    NineBytes=<br/>        packed record<br/>            FourBytes       :integer;<br/>            FourMoreBytes   :integer;<br/>            OneByte         :char;<br/>        end;<br/><br/>var<br/>    i               :integer;<br/>    NineByteArray   :array[0..15] of NineBytes;<br/><br/>    function changei(i:integer):integer;<br/>    begin<br/>        changei := 15 - i;<br/>    end;<br/><br/>    // changei         proc near<br/>    //                 mov     edx, 0Fh<br/>    //                 sub     edx, eax<br/>    //                 mov     eax, edx<br/>    //                 retn<br/>    // changei         endp<br/><br/>begin<br/><br/>    for i:= 0 to 15 do<br/>        NineByteArray[ changei(i) ].FourBytes := i;<br/><span epub:type="pagebreak" id="page_239"/>//                 xor     ebx, ebx<br/>//<br/>// loc_403AA7:<br/>//                 mov     eax, ebx<br/>//                 call    changei<br/>//<br/>//      // Compute index (eax) = index * 9<br/>//      // (computed as index = index + index*8):<br/>//<br/>//                 lea     eax, [eax+eax*8]<br/>//<br/>//                 mov     ds:NineBytes[eax], ebx<br/>//                 inc     ebx<br/>//                 cmp     ebx, 10h<br/>//                 jnz     short loc_403AA7<br/><br/><br/>end.</pre>&#13;
		<p class="indent">The <code>packed</code> reserved word is just a hint to a Pascal compiler. A generic Pascal compiler can choose to ignore it; the Pascal standard does not make any explicit claims about its impact on a compiler’s code generation. Delphi uses the <code>packed</code> keyword to tell the compiler to pack array (and record) elements on a byte boundary rather than a 4-byte boundary. Other Pascal compilers actually use this keyword to align objects on bit boundaries.</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>See your compiler’s documentation for more information about the <span class="codeitalic">packed</span> keyword.</em></p>&#13;
		</div>&#13;
		<p class="indent">Few other languages provide a way, within the generic language definition, to pack data into a given boundary. In the C/C++ languages, for example, many compilers provide pragmas or command-line switches to control array element padding, but these facilities are almost always specific to a particular compiler.</p>&#13;
		<p class="indent">In general, choosing between packed and padded array elements (when you have a choice) is usually a tradeoff between speed and space. Packing lets you save a small amount of space for each array element at the cost of slower access to it (for example, when accessing a <code>dword</code> object at an odd address in memory). Furthermore, computing the index into an array whose element size is not a convenient multiple of 2 (or, better yet, a power of 2) can require more instructions, which also slows down programs that access elements of such arrays.</p>&#13;
		<p class="indent">Of course, some machine architectures don’t allow misaligned data access, so if you’re writing portable code that must compile and run on different CPUs, you shouldn’t count on the fact that array elements can be tightly packed into memory. Some compilers may not give you this option.</p>&#13;
		<p class="indent">Before closing this discussion, it’s worthwhile to emphasize that the best array element sizes are those that are some power of 2. Generally, it takes only a single instruction to multiply any array index by a power of 2 (that single instruction is a shift-left instruction). Consider the following <span epub:type="pagebreak" id="page_240"/>C program and the assembly output produced by Borland’s C++ compiler, which uses arrays that have 32-byte elements:</p>&#13;
		<pre class="programs">&#13;
			typedef struct<br/>{<br/>    double EightBytes;<br/>    double EightMoreBytes;<br/>    float  SixteenBytes[4];<br/>} PowerOfTwoBytes;<br/><br/>int i;<br/>PowerOfTwoBytes ThirtyTwoBytes[16];<br/><br/>int changei(int i)<br/>{<br/>    return 15 - i;<br/>}<br/><br/><br/>int main( int argc, char **argv )<br/>{<br/>    for( i=0; i&lt;16; ++i )<br/>    {<br/>        ThirtyTwoBytes[ changei(i) ].EightBytes = 0.0;<br/>    }<br/><br/>    // @5:<br/>    //  push      ebx<br/>    //  call      _changei<br/>    //  pop       ecx           // Remove parameter<br/>    //<br/>    // Multiply index (in EAX) by 32.<br/>    // Note that (eax &lt;&lt; 5) = eax * 32<br/>    //<br/>    //  shl       eax,5<br/>    //<br/>    // 8 bytes of zeros are the coding for<br/>    // (double) 0.0:<br/>    //<br/>    //  xor       edx,edx<br/>    //  mov       dword ptr [eax+_ThirtyTwoBytes],edx<br/>    //  mov       dword ptr [eax+_ThirtyTwoBytes+4],edx<br/>    //<br/>    // Finish up the for loop here:<br/>    //<br/>    //  inc       dword ptr [esi]   ;ESI points at i.<br/>    // @6:<br/>    //  mov       ebx,dword ptr [esi]<br/>    //  cmp       ebx,16<br/>    //  jl        short @5<br/><br/>    return 0;<br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_241"/>As you can see, the Borland C++ compiler emits a <code>shl</code> instruction to multiply the index by 32.</p>&#13;
		<h4 class="h4" id="ch00lev2sec98"><strong>8.1.6 Multidimensional Arrays</strong></h4>&#13;
		<p class="noindent">A <em>multidimensional</em> array is one that lets you select an element of the array using two or more independent index values. A classic example is a two-dimensional data structure (matrix) that tracks product sales versus date. One index into the table could be the date, while the other index could be the product’s identification (some integer designation). The element of the array selected by these two indices would be the total sales of that product on a given date. A three-dimensional extension of this example could be sales of products by date and by country. Again, a combination of product value, date value, and country value would address an element in the array to give you the sales of that product within that country on the specified date.</p>&#13;
		<p class="indent">Most CPUs can easily handle one-dimensional arrays using an indexed addressing mode. Unfortunately, there is no magic addressing mode that lets you easily access the elements of multidimensional arrays. That’s going to take some work and several machine instructions.</p>&#13;
		<h5 class="h5" id="ch00lev3sec51"><strong>8.1.6.1 Declaring Multidimensional Arrays</strong></h5>&#13;
		<p class="noindent">An “<em>m</em> by <em>n</em>” array has <code>m</code> × <code>n</code> elements and requires <code>m</code> × <code>n</code> × <span class="codeitalic">Element_Size</span> bytes of storage. With one-dimensional arrays, the syntax is very similar among HLLs. However, their syntax starts to differ with multidimensional arrays.</p>&#13;
		<p class="indent">In C, C++, and Java, you use the following syntax to declare a multidimensional array:</p>&#13;
		<pre class="programs"><span class="codeitalic1">data_type array_name</span> [dim<sub>1</sub>][dim<sub>2</sub>]...[dim<sub>n</sub>];</pre>&#13;
		<p class="indent">For example, here’s a three-dimensional array declaration in C/C++:</p>&#13;
		<pre class="programs">int threeDInts[ 4 ][ 2 ][ 8 ];</pre>&#13;
		<p class="indent">This example creates an array with 64 elements organized with a depth of 4 by 2 rows by 8 columns. Assuming each <code>int</code> object requires 4 bytes, this array consumes 256 bytes of storage.</p>&#13;
		<p class="indent">Pascal’s syntax supports two equivalent ways of declaring multidimensional arrays. The following example demonstrates both:</p>&#13;
		<pre class="programs">&#13;
			var<br/>    threeDInts:<br/>        array[0..3] of array[0..1] of array[0..7] of integer;<br/><br/>    threeDInts2: array[0..3, 0..1, 0..7] of integer;</pre>&#13;
		<p class="indent">The first Pascal declaration is technically an <em>array of arrays</em>, whereas the second declaration is a standard multidimensional array.</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_242"/>Semantically, there are only two major differences in the way different languages handle multidimensional arrays: whether the array declaration specifies the overall size of each array dimension or the upper and lower bounds; and whether the starting index is <code>0</code>, <code>1</code>, or a user-specified value.</p>&#13;
		<h5 class="h5" id="ch00lev3sec52"><strong>8.1.6.2 Declaring Swift Multidimensional Arrays</strong></h5>&#13;
		<p class="noindent">Swift doesn’t support a native multidimensional array, but rather an array of arrays. For most programming languages, where an array object is strictly the sequence of array elements in memory, an array of arrays and a multidimensional array are the same thing (see the Pascal examples given earlier). However, Swift uses descriptor (<code>struct</code>-based) objects to specify an array. Like string descriptors, Swift arrays consist of a data structure that contains various fields (such as capacity, current size, and a pointer to data; see “Swift Array Implementation” on <a href="ch08.xhtml#page_234">page 234</a> for more details). When you create an array of arrays, you’re actually creating an array of these descriptors, with each pointing at a subarray. Consider the following (equivalent) Swift array-of-arrays declarations and sample program:</p>&#13;
		<pre class="programs">&#13;
			import Foundation<br/><br/>var a1 = [[Int]]()<br/>var a2 = ContiguousArray&lt;Array&lt;Int&gt;&gt;()<br/>a1.append( [1,2,3] )<br/>a1.append( [4,5,6] )<br/>a2.append( [1,2,3] )<br/>a2.append( [4,5,6] )<br/><br/>print( a1 )<br/>print( a2 )<br/>print( a1[0] )<br/>print( a1[0][1] )</pre>&#13;
		<p class="indent">Running this program produces the following output:</p>&#13;
		<pre class="programs">&#13;
			[[1, 2, 3], [4, 5, 6]]<br/>[[1, 2, 3], [4, 5, 6]]<br/>[1, 2, 3]<br/>2</pre>&#13;
		<p class="indent">This is reasonable—for two-dimensional arrays you’d expect this type of output. However, internally, <code>a1</code> and <code>a2</code> are one-dimensional arrays with two elements each. Those two elements are array descriptors that themselves point at arrays (each containing three elements in this example). It is unlikely that the six array elements associated with <code>a2</code> will appear in contiguous memory locations, even though <code>a2</code> is a contiguous array type. The two array descriptors held in <code>a2</code> may appear in contiguous memory locations, but that doesn’t necessarily carry over to the six data elements at which they collectively point.</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_243"/>Because Swift allocates array storage dynamically, the rows in a two-dimensional array could have differing element counts. Consider the following modification to the previous Swift program:</p>&#13;
		<pre class="programs">&#13;
			import Foundation<br/><br/>var a2 = ContiguousArray&lt;Array&lt;Int&gt;&gt;()<br/>a2.append( [1,2,3] )<br/>a2.append( [4,5] )<br/><br/>print( a2 )<br/>print( a2[0] )<br/>print( a2[0][1] )</pre>&#13;
		<p class="indent">Running this program produces the following output:</p>&#13;
		<pre class="programs">&#13;
			[[1, 2, 3], [4, 5]]<br/>[1, 2, 3]<br/>2</pre>&#13;
		<p class="indent">Notice how the two rows in the <code>a2</code> array have different sizes. This could be useful or a source of defects, depending on what you’re trying to accomplish.</p>&#13;
		<p class="indent">One way to get standard multidimensional array storage in Swift is to declare a one-dimensional <code>ContiguousArray</code> with sufficient elements for all the elements of the multidimensional array. Then use the row-major (or column-major) functionality to compute the index into the array (see “Implementing Row-Major Ordering” on <a href="ch08.xhtml#page_244">page 244</a> and “Implementing Column-Major Ordering” on <a href="ch08.xhtml#page_247">page 247</a>).</p>&#13;
		<h5 class="h5" id="ch00lev3sec53"><strong>8.1.6.3 Mapping Multidimensional Array Elements to Memory</strong></h5>&#13;
		<p class="noindent">Now that you’ve seen how arrays are declared, you need to know how to implement them in memory. The first challenge is storing a multidimensional object into a one-dimensional memory space.</p>&#13;
		<p class="indent">Consider a Pascal array of the following form:</p>&#13;
		<pre class="programs">A:array[0..3,0..3] of char;</pre>&#13;
		<p class="indent">This array contains 16 bytes organized as four rows of four characters. You need to map each of the 16 bytes in this array to each of the 16 contiguous bytes in main memory. <a href="ch08.xhtml#ch8fig3">Figure 8-3</a> shows one way to do this.</p>&#13;
		<p class="indent">You can map positions within the array grid to memory addresses in different ways, as long as you adhere to two rules:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">No two entries in the array can occupy the same memory location.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Each element in the array always maps to the same memory location.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">Therefore, what you really need is a function with two input parameters (one for a row and one for a column value) that produces an offset into a contiguous block of 16 memory locations.</p>&#13;
		<div class="image" id="ch8fig3">&#13;
			<span epub:type="pagebreak" id="page_244"/>&#13;
			<img alt="Image" src="../images/08fig03.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 8-3: Mapping a 4×4 array to sequential memory locations</em></p>&#13;
		<p class="indent">Now, any old function that satisfies these two constraints will work fine. However, what you really want is a mapping function that can compute efficiently at runtime and works for arrays with any number of dimensions and any bounds on those dimensions. While there are numerous options that fit this bill, most HLLs use one of two organizations: <em>row-major ordering</em> and <em>column-major ordering</em>.</p>&#13;
		<h5 class="h5" id="ch00lev3sec54"><strong>8.1.6.4 Implementing Row-Major Ordering</strong></h5>&#13;
		<p class="noindent">Row-major ordering assigns array elements to successive memory locations by moving across the rows and then down the columns. <a href="ch08.xhtml#ch8fig4">Figure 8-4</a> demonstrates this mapping for <code>A[<span class="codeitalic1">col,row</code>]</span>.</p>&#13;
		<div class="image" id="ch8fig4">&#13;
			<img alt="Image" src="../images/08fig04.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 8-4: Row-major ordering for a 4×4 array</em></p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_245"/>Row-major ordering is the method employed by most high-level programming languages, including Pascal, C/C++/C#, Java, Ada, and Modula-2. It is very easy to implement and easy to use in machine language. The conversion from a two-dimensional structure to a linear sequence is very intuitive. <a href="ch08.xhtml#ch8fig5">Figure 8-5</a> provides another view of row-major ordering for a 4×4 array.</p>&#13;
		<div class="image" id="ch8fig5">&#13;
			<img alt="Image" src="../images/08fig05.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 8-5: Another view of row-major ordering for a 4x4 array</em></p>&#13;
		<p class="indent">The function that converts the set of multidimensional array indices into a single offset is a slight modification of the formula for computing the address of an element of a one-dimensional array. The generic formula to compute the offset into a two-dimensional row-major-ordered array given an access of the form:</p>&#13;
		<pre class="programs"><span class="codeitalic1">array</span>[ <span class="codeitalic1">colindex</span> ][ <span class="codeitalic1">rowindex</span> ]</pre>&#13;
		<p class="noindent">is:</p>&#13;
		<pre class="programs"><span class="codeitalic1">Element_Address</span> =<br/>    <span class="codeitalic1">Base_Address</span> +<br/>        (<span class="codeitalic1">colindex</span> * <span class="codeitalic1">row_size</span> + <span class="codeitalic1">rowindex</span>) * <span class="codeitalic1">Element_Size</span></pre>&#13;
		<p class="indent">As usual, <span class="codeitalic">Base_Address</span> is the address of the first element of the array (<code>A[0][0]</code> in this case), and <span class="codeitalic">Element_Size</span> is the size of an individual element of the array in bytes. <span class="codeitalic">Row_size</span> is the number of elements in one row of the array (<code>4</code>, in this case, because each row has four elements). Assuming <span class="codeitalic">Element_Size</span> is <code>1</code> and <span class="codeitalic">row_size</span> is <code>4</code>, this formula computes the offsets shown in <a href="ch08.xhtml#ch8tab1">Table 8-1</a> from the base address.</p>&#13;
		<p class="indent">For a three-dimensional array, the formula to compute the offset into memory is only slightly more complex. Consider a C/C++ array declaration given as follows:</p>&#13;
		<pre class="programs"><span class="codeitalic1">someType array</span>[<span class="codeitalic1">depth_size</span>][<span class="codeitalic1">col_size</span>][<span class="codeitalic1">row_size</span>];</pre>&#13;
		<p class="tabcap" id="ch8tab1"><span epub:type="pagebreak" id="page_246"/><strong>Table 8-1:</strong> Offsets for Two-Dimensional Row-Major-Ordered Array</p>&#13;
		<table class="all">&#13;
			<colgroup>&#13;
				<col style="width:30%"/>&#13;
				<col style="width:30%"/>&#13;
				<col style="width:40%"/>&#13;
			</colgroup>&#13;
			<tbody>&#13;
				<tr>&#13;
					<td class="table-h" style="vertical-align: top;">&#13;
						<p class="table"><strong>Column index</strong></p>&#13;
					</td>&#13;
					<td class="table-h" style="vertical-align: top;">&#13;
						<p class="table"><strong>Row index</strong></p>&#13;
					</td>&#13;
					<td class="table-h" style="vertical-align: top;">&#13;
						<p class="table"><strong>Offset into array</strong></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>0</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>0</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>0</code></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>0</code></p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>1</code></p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>1</code></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>0</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>2</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>2</code></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>0</code></p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>3</code></p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>3</code></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>1</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>0</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>4</code></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>1</code></p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>1</code></p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>5</code></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>1</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>2</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>6</code></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>1</code></p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>3</code></p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>7</code></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>2</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>0</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>8</code></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>2</code></p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>1</code></p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>9</code></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>2</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>2</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>10</code></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>2</code></p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>3</code></p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>11</code></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>3</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>0</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>12</code></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>3</code></p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>1</code></p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>13</code></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>3</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>2</code></p>&#13;
					</td>&#13;
					<td style="vertical-align: top;">&#13;
						<p class="table"><code>14</code></p>&#13;
					</td>&#13;
				</tr>&#13;
				<tr>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>3</code></p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>3</code></p>&#13;
					</td>&#13;
					<td class="table-1b" style="vertical-align: top;">&#13;
						<p class="table"><code>15</code></p>&#13;
					</td>&#13;
				</tr>&#13;
			</tbody>&#13;
		</table>&#13;
		<p class="indent">If you have an array access similar to <code>array[<span class="codeitalic1">depth_index</code>] [<span class="codeitalic1">col_index</span>] [<span class="codeitalic1">row_index</span>]</span>, then the computation that yields the offset into memory is:</p>&#13;
		<pre class="programs"><span class="codeitalic1">Address</span> =<br/>    <span class="codeitalic1">Base</span> +<br/>        ((<span class="codeitalic1">depth_index</span> * <span class="codeitalic1">col_size</span> + <span class="codeitalic1">col_index</span>) *<br/>            <span class="codeitalic1">row_size</span> + <span class="codeitalic1">row_index</span>) * <span class="codeitalic1">Element_Size</span></pre>&#13;
		<p class="indent">Again, <span class="codeitalic">Element_Size</span> is the size, in bytes, of a single array element.</p>&#13;
		<p class="indent">For a four-dimensional array, declared in C/C++ as:</p>&#13;
		<pre class="programs">type A[bounds0] [bounds1] [bounds2] [bounds3];</pre>&#13;
		<p class="noindent">the formula for computing the address of an array element when accessing element <code>A[i][j][k][m]</code> is:</p>&#13;
		<pre class="programs"><span class="codeitalic1">Address</span> =<br/>    <span class="codeitalic1">Base</span> +<br/>        (((i * <span class="codeitalic1">bounds1</span> + j) * <span class="codeitalic1">bounds2</span> + k) * <span class="codeitalic1">bounds3</span> + m) *<br/>            <span class="codeitalic1">Element_Size</span></pre>&#13;
		<p class="indent">If you have an <em>n</em>-dimensional array declared in C/C++ as follows:</p>&#13;
		<pre class="programs"><span class="codeitalic1">dataType array</span>[b<sub>n-1</sub>][b<sub>n-2</sub>]...[b<sub>0</sub>];</pre>&#13;
		<p class="noindent"><span epub:type="pagebreak" id="page_247"/>and you want to access the following element of this array:</p>&#13;
		<pre class="programs"><span class="codeitalic1">array</span>[a<sub>n-1</sub>][a<sub>n-2</sub>]...[a<sub>1</sub>][a<sub>0</sub>]</pre>&#13;
		<p class="noindent">then you can compute the address of a particular array element using the following algorithm:</p>&#13;
		<pre class="programs"><span class="codeitalic1">Address</span> := a<sub>n-1</sub><br/>for i := n-2 downto 0 do<br/>    <span class="codeitalic1">Address</span> := <span class="codeitalic1">Address</span> * b<sub>i</sub> + a<sub>i</sub><br/><span class="codeitalic1">Address</span> := <span class="codeitalic1">Base_Address</span> + <span class="codeitalic1">Address</span> * <span class="codeitalic1">Element_Size</span></pre>&#13;
		<p class="indent">It would be very rare for a compiler to actually execute such a loop in order to compute an array index. There’s usually a small number of dimensions and the compiler will unroll the loop, thereby avoiding the overhead of the loop control instructions.</p>&#13;
		<h5 class="h5" id="ch00lev3sec55"><strong>8.1.6.5 Implementing Column-Major Ordering</strong></h5>&#13;
		<p class="noindent">Column-major ordering, the other common array element address function, is used by FORTRAN, OpenGL, and various dialects of BASIC (such as older versions of Microsoft BASIC) to index arrays. A column-major-ordered array (accessing <code>A[col,row]</code>) is organized as shown in <a href="ch08.xhtml#ch8fig6">Figure 8-6</a>.</p>&#13;
		<div class="image" id="ch8fig6">&#13;
			<img alt="Image" src="../images/08fig06.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 8-6: Column-major ordering</em></p>&#13;
		<p class="indent">The formula for computing the address of an array element when using column-major ordering is very similar to that for row-major ordering. The difference is that you reverse the order of the index and size variables in <span epub:type="pagebreak" id="page_248"/>the computation. That is, rather than working from the leftmost index to the rightmost, you operate on the indices from the rightmost toward the leftmost.</p>&#13;
		<p class="indent">For a two-dimensional column-major array:</p>&#13;
		<pre class="programs"><span class="codeitalic1">Element_Address</span> =<br/>    <span class="codeitalic1">Base_Address</span> +<br/>        (<span class="codeitalic1">rowindex</span> * <span class="codeitalic1">col_size</span> + <span class="codeitalic1">colindex</span>) *<br/>            <span class="codeitalic1">Element_Size</span></pre>&#13;
		<p class="indent">For a three-dimensional column-major array:</p>&#13;
		<pre class="programs"><span class="codeitalic1">Element_Address</span> =<br/>    <span class="codeitalic1">Base_Address</span> +<br/>        ((<span class="codeitalic1">rowindex</span> * <span class="codeitalic1">col_size</span> + <span class="codeitalic1">colindex</span>) *<br/>            <span class="codeitalic1">depth_size</span> + <span class="codeitalic1">depthindex</span>) *<br/>                <span class="codeitalic1">Element_Size</span></pre>&#13;
		<p class="indent">And so on. Other than using these new formulas, accessing elements of an array using column-major ordering is identical to accessing arrays using row-major ordering.</p>&#13;
		<h5 class="h5" id="ch00lev3sec56"><strong>8.1.6.6 Accessing Elements of a Multidimensional Array</strong></h5>&#13;
		<p class="noindent">It’s so easy to access an element of a multidimensional array in an HLL that many programmers do so without considering the associated costs. In this section, to give you a clearer picture of these costs, we’ll look at some of the assembly language sequences compilers commonly generate to access elements of a multidimensional array. Because arrays are one of the more common data structures found in modern applications, and multidimensional arrays are also quite common, compiler designers have put a lot of work into ensuring that they compute array indices as efficiently as possible. Given a declaration such as:</p>&#13;
		<pre class="programs">int ThreeDInts[ 8 ][ 2 ][ 4 ];</pre>&#13;
		<p class="noindent">and an array reference like the following:</p>&#13;
		<pre class="programs">ThreeDInts[i][j][k] = n;</pre>&#13;
		<p class="noindent">accessing the array element (using row-major ordering) requires computing the following:</p>&#13;
		<pre class="programs"><span class="codeitalic1">Element_Address</span> =<br/>    <span class="codeitalic1">Base_Address</span> +<br/>        ((i * <span class="codeitalic1">col_size</span> + j) * // <span class="codeitalic1">col_size</span> = 2<br/>            <span class="codeitalic1">row_size</span> + k) *   // <span class="codeitalic1">row_size</span> = 4<br/>                <span class="codeitalic1">Element_Size</span></pre>&#13;
		<p class="noindent"><span epub:type="pagebreak" id="page_249"/>In brute-force assembly code, this might be:</p>&#13;
		<pre class="programs">&#13;
			intmul( 2, i, ebx );    // EBX = 2*i<br/>add( j, ebx );          // EBX = 2*i + j<br/>intmul( 4, ebx );       // EBX = (2*i + j)*4<br/>add( k, ebx );          // EBX = (2*i + j)*4 + k<br/>mov( n, eax );<br/>mov( eax, ThreeDInts[ebx*4] );  // ThreeDInts[i][j][k] = n; assumes 4-byte ints</pre>&#13;
		<p class="indent">In practice, however, compiler authors avoid using the 80x86 <code>intmul</code> (<code>imul</code>) instruction because it is slow. Many different machine idioms can be used to simulate multiplication using a short sequence of addition, shift, and “load effective address” instructions. Most optimizing compilers use sequences that compute the array element address rather than the brute-force code that uses a multiply instruction.</p>&#13;
		<p class="indent">Consider the following C program, which initializes the 16 elements of a 4×4 array:</p>&#13;
		<pre class="programs">&#13;
			int i, j;<br/>int TwoByTwo[4][4];<br/><br/>int main( int argc, char **argv )<br/>{<br/>    for( j=0; j&lt;4; ++j )<br/>    {<br/>        for( i=0; i&lt;4; ++i )<br/>        {<br/>            TwoByTwo[i][j] = i+j;<br/>        }<br/>    }<br/>    return 0;<br/>}</pre>&#13;
		<p class="indent">Now consider the assembly code that the Borland C++ v5.0 compiler (an old compiler) emits for the <code>for</code> loop in this example:</p>&#13;
		<pre class="programs">&#13;
			    mov       ecx,offset _i<br/>    mov       ebx,offset _j<br/>   ;<br/>   ;    {<br/>   ;        for( j=0; j&lt;4; ++j )<br/>   ;<br/>?live1@16: ; ECX = &amp;i, EBX = &amp;j<br/>    xor       eax,eax<br/>    mov       dword ptr [ebx],eax ;i = 0<br/>    jmp       short @3<br/>   ;<br/>   ;        {<br/>   ;            for( i=0; i&lt;4; ++i )<br/>   ;<br/><span epub:type="pagebreak" id="page_250"/>@2:<br/>    xor       edx,edx<br/>    mov       dword ptr [ecx],edx ; j = 0<br/><br/>; Compute the index to the start of the<br/>; current column of the array as<br/>; base( TwoByTwo ) + eax*4. Leave this<br/>; "column base address" in EDX:<br/><br/>    mov       eax,dword ptr [ebx]<br/>    lea       edx,dword ptr [_TwoByTwo+4*eax]<br/>    jmp       short @5<br/>   ;<br/>   ;            {<br/>   ;                TwoByTwo[i][j] = i+j;<br/>   ;<br/>?live1@48: ; EAX = @temp0, EDX = @temp1, ECX = &amp;i, EBX = &amp;j<br/>@4:<br/><br/>;<br/>    mov       esi,eax                  ; Compute i+j<br/>    add       esi,dword ptr [ebx]      ; EBX points at j's value<br/><br/>    shl       eax,4                    ; Multiply row index by 16<br/><br/>; Store the sum (held in ESI) into the specified array element.<br/>; Note that EDX contains the base address plus the column<br/>; offset into the array. EAX contains the row offset into the<br/>; array. Their sum produces the address of the desired array<br/>; element.<br/><br/>    mov       dword ptr [edx+eax],esi  ; Store sum into element<br/><br/>    inc       dword ptr [ecx]          ; increment i by 1<br/>@5:<br/>    mov       eax,dword ptr [ecx]      ; Fetch i's value<br/>    cmp       eax,4                    ; Is i less than 4?<br/>    jl        short @4                 ; If so, repeat inner loop<br/>    inc       dword ptr [ebx]          ; Increment j by 1<br/>@3:<br/>    cmp       dword ptr [ebx],4        ; Is j less than 4?<br/>    jl        short @2                 ; If so, repeat outer loop.<br/>   ;<br/><br/>       .<br/>       .<br/>       .<br/>; Storage for the 4x4 (x4 bytes) two-dimensional array:<br/>; Total = 4*4*4 = 64 bytes:<br/><br/>    align   4<br/>_TwoByTwo   label   dword<br/>    db  64  dup(?)</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_251"/>In this example, the computation <code>rowIndex * 4 + columnIndex</code> is handled by the following four instructions (which also store away the array element):</p>&#13;
		<pre class="programs">&#13;
			; EDX = base address + columnIndex * 4<br/><br/>    mov       eax,dword ptr [ebx]<br/>    lea       edx,dword ptr [_TwoByTwo+4*eax]<br/>      .<br/>      .<br/>      .<br/>; EAX = rowIndex, ESI = i+j<br/><br/>    shl       eax,4                    ; Multiply row index by 16<br/>    mov       dword ptr [edx+eax],esi  ; Store sum into element</pre>&#13;
		<p class="indent">Note that this code sequence used the scaled-index addressing mode (along with the <code>lea</code> instruction) and the <code>shl</code> instruction to do the necessary multiplications. Because multiplication tends to be an expensive operation, most compilers avoid using it when calculating indices into multidimensional arrays. Nevertheless, by comparing this code against the examples given for one-dimensional array access, you can see that two-dimensional array access is a bit more expensive in terms of the number of machine instructions you must use to compute the index into the array.</p>&#13;
		<p class="indent">Three-dimensional array access is even costlier than two-dimensional array access. Here is a C/C++ program that initializes the elements of a three-dimensional array:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdlib.h&gt;<br/>int i, j, k;<br/>int ThreeByThree[3][3][3];<br/><br/>int main( int argc, char **argv )<br/>{<br/>    for( j=0; j&lt;3; ++j )<br/>    {<br/>        for( i=0; i&lt;3; ++i )<br/>        {<br/>            for( k=0; k&lt;3; ++k )<br/>            {<br/>                // Initialize the 27 array elements<br/>                // with a set of random values:<br/><br/>                ThreeByThree[i][j][k] = rand();<br/>            }<br/>        }<br/>    }<br/>    return 0;<br/>}</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_252"/>And here’s the 32-bit 80x86 assembly language output that the Microsoft Visual C++ compiler produces:</p>&#13;
		<pre class="programs">&#13;
			; Line 9<br/>        mov     DWORD PTR j, 0     // for( j = 0;...;... )<br/>        jmp     SHORT $LN4@main<br/><br/>$LN2@main:<br/>        mov     eax, DWORD PTR j   // for( ...;...;++j )<br/>        inc     eax<br/>        mov     DWORD PTR j, eax<br/><br/>$LN4@main:<br/>        cmp     DWORD PTR j, 4     // for( ...;j&lt;4;... )<br/>        jge     $LN3@main<br/><br/>; Line 11<br/>        mov     DWORD PTR i, 0     // for( i=0;...;... )<br/>        jmp     SHORT $LN7@main<br/><br/>$LN5@main:<br/>        mov     eax, DWORD PTR i   // for( ...;...;++i )<br/>        inc     eax<br/>        mov     DWORD PTR i, eax<br/><br/>$LN7@main:<br/>        cmp     DWORD PTR i, 4     // for( ...;i&lt;4;... )<br/>        jge     SHORT $LN6@main<br/><br/>; Line 13<br/>        mov     DWORD PTR k, 0     // for( k=0;...;... )<br/>        jmp     SHORT $LN10@main<br/><br/>$LN8@main:<br/>        mov     eax, DWORD PTR k   // for( ...;...;++k )<br/>        inc     eax<br/>        mov     DWORD PTR k, eax<br/><br/>$LN10@main:<br/>        cmp     DWORD PTR k, 3     // for( ...; k&lt;3;... )<br/>        jge     SHORT $LN9@main<br/><br/>; Line 18<br/>        call    rand<br/>        movsxd  rcx, DWORD PTR i   // Index =( (( ( i*3 + j ) * 3 + k ) * 4 )<br/>        imul    rcx, rcx, 36       // 00000024H<br/>        lea     rdx, OFFSET FLAT:ThreeByThree<br/>        add     rdx, rcx<br/>        mov     rcx, rdx<br/>        movsxd  rdx, DWORD PTR j<br/>        imul    rdx, rdx, 12<br/>        add     rcx, rdx<br/>        movsxd  rdx, DWORD PTR k<br/><span epub:type="pagebreak" id="page_253"/>//  ThreeByThree[i][j][k] = rand();<br/><br/>        mov     DWORD PTR [rcx+rdx*4], eax<br/><br/>; Line 19<br/>        jmp     SHORT $LN8@main // End of for( k = 0; k&lt;3; ++k )<br/>$LN9@main:<br/>; Line 20<br/>        jmp     SHORT $LN5@main // End of for( i = 0; i&lt;4; ++i )<br/>$LN6@main:<br/>; Line 21<br/>        jmp     $LN2@main       // End of for( j = 0; j&lt;4; ++j )<br/>$LN3@main:</pre>&#13;
		<p class="indent">If you’re interested, you can write your own short HLL programs and analyze the assembly code emitted for <em>n</em>-dimensional arrays (<em>n</em> being greater than or equal to 4).</p>&#13;
		<p class="indent">The choice of column-major or row-major array ordering is generally dictated by your compiler, if not by the programming language definition. No compiler I’m aware of will let you choose which array ordering you prefer on an array-by-array basis (or even across a whole program, for that matter). However, there’s really no need to do this, as you can easily simulate either storage mechanism by simply changing the definitions of “rows” and “columns” in your programs.</p>&#13;
		<p class="indent">Consider the following C/C++ array declaration:</p>&#13;
		<pre class="programs">&#13;
			int <span class="codeitalic1">array</span>[ <span class="codeitalic1">NumRows</span> ][ <span class="codeitalic1">NumCols</span> ];</pre>&#13;
		<p class="indent">Normally, you’d access an element of this array using a reference like this:</p>&#13;
		<pre class="programs"><span class="codeitalic1">element</span> = <span class="codeitalic1">array</span>[ <span class="codeitalic1">rowIndex</span> ][ <span class="codeitalic1">colIndex</span> ]</pre>&#13;
		<p class="indent">If you increment through all the column index values for each row index value (which you also increment), you’ll access sequential memory locations when accessing elements of this array. That is, the following C <code>for</code> loop initializes sequential locations in memory with <code>0</code>:</p>&#13;
		<pre class="programs">&#13;
			for( <span class="codeitalic1">row</span>=0; <span class="codeitalic1">row</span>&lt;<span class="codeitalic1">NumRows</span>; ++<span class="codeitalic1">row</span> )<br/>{<br/>    for( <span class="codeitalic1">col</span>=0; <span class="codeitalic1">col</span>&lt;<span class="codeitalic1">NumCols</span>; ++<span class="codeitalic1">col</span> )<br/>    {<br/>        <span class="codeitalic1">array</span>[ <span class="codeitalic1">row</span> ][ <span class="codeitalic1">col</span> ] = 0;<br/>    }<br/>}</pre>&#13;
		<p class="indent">If <span class="codeitalic">NumRow</span> and <span class="codeitalic">NumCols</span> are the same value, then accessing the array elements in column-major rather than row-major order is trivial. Simply swap the indices in the previous code fragment to obtain:</p>&#13;
		<pre class="programs">&#13;
			for( <span class="codeitalic1">row</span>=0; <span class="codeitalic1">row</span>&lt;<span class="codeitalic1">NumRows</span>; ++<span class="codeitalic1">row</span> )<br/>{<br/><span epub:type="pagebreak" id="page_254"/>    for( <span class="codeitalic1">col</span>=0; <span class="codeitalic1">col</span>&lt;<span class="codeitalic1">NumCols</span>; ++<span class="codeitalic1">col</span> )<br/>    {<br/>        array[ <span class="codeitalic1">col</span> ][ <span class="codeitalic1">row</span> ] = 0;<br/>    }<br/>}</pre>&#13;
		<p class="indent">If <span class="codeitalic">NumCols</span> and <span class="codeitalic">NumRows</span> are not the same value, you’ll have to manually compute the index into the column-major array and allocate the storage in a one-dimensional array, as follows:</p>&#13;
		<pre class="programs">&#13;
			int columnMajor[ <span class="codeitalic1">NumCols</span> * <span class="codeitalic1">NumRows</span> ]; // Allocate storage<br/>    .<br/>    .<br/>    .<br/>for( <span class="codeitalic1">row</span>=0; <span class="codeitalic1">row</span>&lt;<span class="codeitalic1">NumRows</span>; ++<span class="codeitalic1">row</span>)<br/>{<br/>    for( <span class="codeitalic1">col</span>=0; <span class="codeitalic1">col</span>&lt;<span class="codeitalic1">NumCols</span>; ++<span class="codeitalic1">col</span> )<br/>    {<br/>        columnMajor[ <span class="codeitalic1">col</span>*<span class="codeitalic1">NumRows</span> + <span class="codeitalic1">row</span> ] = 0;<br/>    }<br/>}</pre>&#13;
		<p class="indent">Swift users who want a true multidimensional array implementation (not an array-of-arrays implementation) will need to allocate storage for the whole array as a single <code>ContiguousArray</code> type and then compute the indices into the array manually:</p>&#13;
		<pre class="programs">&#13;
			import Foundation<br/><br/>// Create a 3-D array[4][4][4]:<br/><br/>var a1 = ContiguousArray&lt;Int&gt;( repeating:0, count:4*4*4 )<br/><br/>for var i in 0...3<br/>{<br/>    for var j in 0...3<br/>    {<br/>        for var k in 0...3<br/>        {<br/>            a1[ (i*4+j)*4 + k ] = (i*4+j)*4 + k<br/>        }<br/>    }<br/>}<br/>print( a1 )</pre>&#13;
		<p class="indent">Here’s the output from this program:</p>&#13;
		<pre class="programs">&#13;
			[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,<br/>22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,<br/>41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,<br/>60, 61, 62, 63]</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_255"/>Although it’s possible to access arrays using a column-major organization if your application requires it, you should exercise extreme caution when accessing arrays in a manner other than the language’s default scheme. Many optimizing compilers are smart enough to recognize when you’re accessing arrays in the default manner, and they generate far better code in those circumstances. Indeed, the examples presented so far have explicitly accessed arrays in uncommon ways in order to thwart the compilers’ optimizers. Consider the following C code and the Visual C++ output (with optimization enabled):</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdlib.h&gt;<br/>int i, j, k;<br/>int ThreeByThreeByThree[3][3][3];<br/><br/>int main( int argc, char **argv )<br/>{<br/>    // The important difference to note here is how<br/>    // the loops are arranged with the indices i, j, and k<br/>    // used so that i changes the slowest and k changes<br/>    // most rapidly (corresponding to row-major ordering).<br/><br/>    for( i=0; i&lt;3; ++i )<br/>    {<br/>        for( j=0; j&lt;3; ++j )<br/>        {<br/>            for( k=0; k&lt;3; ++k )<br/>            {<br/>                ThreeByThreeByThree[i][j][k] = 0;<br/>            }<br/>        }<br/>    }<br/>    return 0;<br/>}</pre>&#13;
		<p class="indent">Here’s the Visual C++ assembly language output for the <code>for</code> loops in the previous code. In particular, note how the compiler substituted an 80x86 <code>stosd</code> instruction in place of the three loops:</p>&#13;
		<pre class="programs">&#13;
			    push    edi<br/>;<br/>; The following code zeros out the 27 (3*3*3) elements<br/>; of the ThreeByThreeByThree array.<br/><br/>    mov ecx, 27                 ; 0000001bH<br/>    xor eax, eax<br/>    mov edi, OFFSET FLAT:_ThreeByThreeByThree<br/>    rep stosd</pre>&#13;
		<p class="indent">If you rearrange your indices so that you’re not storing zeros into consecutive memory locations, Visual C++ will not compile to the <code>stosd</code> instruction. Even if the end result is the zeroing of the entire array, the compiler believes that the semantics of <code>stosd</code> are different. (Imagine two threads in <span epub:type="pagebreak" id="page_256"/>a program that are both reading and writing <code>ThreeByThreeByThree</code> array elements concurrently; the program’s behavior could be different based on the order of the writes to the array.)</p>&#13;
		<p class="indent">In addition to compiler semantics, there are also good hardware reasons not to change the default array ordering. Modern CPU performance is highly dependent on the effectiveness of the CPU’s cache. Because cache performance depends on the temporal and spatial locality of the data in the cache, you must be careful not to access data in a way that disturbs locality. In particular, accessing array elements in a manner that is inconsistent with their storage order will dramatically impact spatial locality and in turn hurt performance. The moral of the story: adopt the compiler’s array organization unless you really know what you’re doing.</p>&#13;
		<h5 class="h5" id="ch00lev3sec57"><strong>8.1.6.7 Improving Array Access Efficiency in Your Applications</strong></h5>&#13;
		<p class="noindent">Follow these rules when using arrays in your applications:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Never use a multidimensional array when a one-dimensional array will work. This is not to suggest that you should simulate multidimensional arrays by manually computing a row-major (or column-major) index into a one-dimensional array, but if you can express an algorithm using a one-dimensional array rather than a multidimensional array, you should.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">When you must use multidimensional arrays in your application, try to use array bounds that are powers of 2 or, at least, multiples of 4. Compilers can compute indices into such arrays much more efficiently than arrays with arbitrary bound values.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">When accessing elements of a multidimensional array, try to do so in a manner than supports sequential memory access. For row-major-ordered arrays, this implies sequencing through the rightmost index the fastest and the leftmost index the slowest (and vice versa for column-major ordered arrays).</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">If your language supports operations on entire rows or columns (or other large pieces of the array) with a single operation, use those facilities rather than accessing individual elements using nested loops. Often, the loop overhead, amortized over each array element you access, is greater than the cost of the index calculation and element access. This is particularly important when the array operation is the only thing happening in the loop(s).</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Always keep in mind the issues of spatial and temporal locality when accessing array elements. Accessing a large number of array elements in a random (or non–cache-friendly) fashion can cause thrashing in the cache and virtual memory subsystem.<sup><a id="ch8fn_3"/><a href="footnotes.xhtml#ch8fn3">3</a></sup></p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_257"/>The last point is particularly important. Consider the following HLA program:</p>&#13;
		<pre class="programs">&#13;
			program slow;<br/>#include ( "stdlib.hhf" )<br/>begin slow;<br/><br/>    // A dynamically allocated array accessed as follows:<br/>    // array [12][1000][1000]<br/><br/>    malloc( 12_000_000 ); // Allocate 12,000,000 bytes<br/>    mov( eax, esi );<br/><br/>    // Initialize each byte of the array to 0:<br/><br/>    for( mov( 0, ecx ); ecx &lt; 1000; inc( ecx ) ) do<br/><br/>        for( mov( 0, edx ); edx &lt; 1000; inc( edx ) ) do<br/><br/>            for( mov( 0, ebx ); ebx &lt; 12; inc( ebx ) ) do<br/><br/>                // Compute the index into the array<br/>                // as EBX*1_000_000 + EDX*1_000 + ECX<br/><br/>                intmul( 1_000_000, ebx, eax );<br/>                intmul( 1_000, edx, edi );<br/>                add( edi, eax );<br/>                add( ecx, eax );<br/>                mov( 0, (type byte [esi+eax]) );<br/><br/>            endfor;<br/><br/>        endfor;<br/><br/>    endfor;<br/><br/>end slow;</pre>&#13;
		<p class="indent">Simply swapping the loops around—so that the EBX loop is the outermost loop and the ECX loop is the innermost loop—can make this program run up to 10 times faster. The reason is that the program, as currently written, accesses an array stored in row-major order nonsequentially. Changing the rightmost index (ECX) most frequently and the leftmost index (EBX) least frequently, then, means this program will access memory sequentially. This allows the cache to work better, which dramatically improves program performance.</p>&#13;
		<h4 class="h4" id="ch00lev2sec99"><strong>8.1.7 Dynamic vs. Static Arrays</strong></h4>&#13;
		<p class="noindent">Some languages allow you to declare arrays whose size isn’t known until the program is running. Such arrays are quite useful, because many programs cannot predict how much space they will need for a data structure until they receive input from a user. For example, consider a program that reads <span epub:type="pagebreak" id="page_258"/>a text file from disk, line by line, into an array of strings. Until the program actually reads the file and counts the number of lines, it doesn’t know how many elements it will need for the array of strings. When writing the program, the programmer had no way of knowing how large the array would need to be.</p>&#13;
		<p class="indent">Languages that provide support for such arrays generally call them <em>dynamic arrays</em>. This section explores the issues surrounding them and their counterpart, <em>static arrays</em>. A good place to start is with some definitions:</p>&#13;
		<p class="noindent1"><strong>Static array (or pure static array)</strong></p>&#13;
		<p class="noindent2">An array whose size the program knows during compilation. This means the compiler/linker/operating system can allocate storage for the array before the program begins execution.</p>&#13;
		<p class="noindent1"><strong>Pseudo-static array</strong></p>&#13;
		<p class="noindent2">An array whose size is known to the compiler, but for which the program doesn’t actually allocate storage until runtime. Automatic variables (that is, nonstatic local variables in a function or procedure) are good examples of pseudo-static objects. The compiler knows their exact size while compiling the program, but the program doesn’t actually allocate storage for them in memory until the function or procedure containing the declaration executes.</p>&#13;
		<p class="noindent1"><strong>Pseudo-dynamic array</strong></p>&#13;
		<p class="noindent2">An array whose size the compiler cannot determine prior to program execution. Typically, the program determines the size of the array at runtime as a result of user input or as part of some other calculation. Once the program allocates storage for a pseudo-dynamic array, however, the size of the array remains fixed until the program either terminates or deallocates storage for that array. In particular, you cannot change the size of a pseudo-dynamic array to add or delete selected elements without deallocating the storage for the whole array.</p>&#13;
		<p class="noindent1"><strong>Dynamic array (or pure dynamic array)</strong></p>&#13;
		<p class="noindent2">An array whose size the compiler cannot determine until the program runs and, in fact, cannot even be sure of once it creates the array. A program may change the size of a dynamic array at any time, adding or deleting elements, without affecting the values already present in the array (of course, if you delete some array elements, their values are lost).</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>Static and pseudo-static arrays are examples of the static and automatic objects discussed previously in this book. See <a href="ch07.xhtml#ch07">Chapter 7</a> for a review.</em></p>&#13;
		</div>&#13;
		<h5 class="h5" id="ch00lev3sec58"><strong>8.1.7.1 One-Dimensional Pseudo-Dynamic Arrays</strong></h5>&#13;
		<p class="noindent">Most languages that claim support for dynamic arrays actually support pseudo-dynamic arrays. That is, you may specify the size of an array when you first create it, but once you’ve done so, you can’t easily change the <span epub:type="pagebreak" id="page_259"/>array’s size without first deallocating the original storage for the array. Consider the following Visual Basic statement:</p>&#13;
		<pre class="programs">dim dynamicArray[ i * 2 ]</pre>&#13;
		<p class="indent">Assuming <code>i</code> is an integer variable that you’ve assigned some value prior to this statement’s execution, upon encountering this statement Visual Basic will create an array with <code>i</code>×<code>2</code> elements. In languages that do support (pseudo-) dynamic arrays, array declarations are usually executable statements, whereas in languages that don’t support dynamic arrays, such as C and Pascal, they are not. They are simply declarations that the compiler processes for bookkeeping reasons, but for which the compiler generates no machine code.</p>&#13;
		<p class="indent">Although standard C/C++ does not support pseudo-dynamic arrays, the GNU C/C++ implementation does. Therefore, it’s legal to write a function like the following in GNU C/C++:</p>&#13;
		<pre class="programs">&#13;
			void usesPDArray( int aSize )<br/>{<br/>    int array[ aSize ];<br/>        .<br/>        .<br/>        .<br/>} /* end of function usesPDArray */</pre>&#13;
		<p class="indent">Of course, if you use this feature in GCC, you’ll only be able to compile your programs with GCC.<sup><a id="ch8fn_4"/><a href="footnotes.xhtml#ch8fn4">4</a></sup> That’s why you won’t see many C/C++ programmers using this type of code in their programs.</p>&#13;
		<p class="indent">If you’re using a language like C/C++ that doesn’t support pseudo-dynamic arrays, but does provide a generic memory allocation function, then you can easily create arrays that act just like one-dimensional pseudo-dynamic arrays. This is particularly easy in languages that don’t check the range of array indices, like C/C++. Consider the following code:</p>&#13;
		<pre class="programs">&#13;
			void usesPDArray( int aSize )<br/>{<br/>    int *array;<br/><br/>    array = (int *) malloc( aSize * sizeof( int ) );<br/>        .<br/>        .<br/>        .<br/>    free( array );<br/><br/>} /* end of function usesPDArray */</pre>&#13;
		<p class="indent">One issue with using a memory allocation function like <code>malloc()</code> is that you must remember to explicitly free the storage prior to returning from the function (as the <code>free()</code> call does in this case). Some versions of the C <span epub:type="pagebreak" id="page_260"/>standard library include a <code>talloc()</code> function that allocates dynamic storage on the stack. Calls to <code>talloc()</code> are much faster than calls to <code>malloc()</code> and <code>free()</code>, and <code>talloc()</code> automatically frees up the storage when you return.</p>&#13;
		<h5 class="h5" id="ch00lev3sec59"><strong>8.1.7.2 Multidimensional Pseudo-Dynamic Arrays</strong></h5>&#13;
		<p class="noindent">If you want to create multidimensional pseudo-dynamic arrays, that’s another problem altogether. With a one-dimensional pseudo-dynamic array, the program really doesn’t need to keep track of the array bounds for any reason but to verify that the array index is valid. For multidimensional arrays, however, the program must maintain additional information about the upper and lower bounds of each dimension of the array; the program needs that size information to compute the offset of an array element from a list of array indices, as you saw earlier in the chapter. So, in addition to maintaining a pointer containing the address of the base element of the array, programs using pseudo-dynamic arrays must also keep track of the array bounds.<sup><a id="ch8fn_5"/><a href="footnotes.xhtml#ch8fn5">5</a></sup> This collection of information—the base address, number of dimensions, and bounds for each dimension—is known as a <em>dope vector</em>. In a language like HLA, C/C++, or Pascal, you’d typically create a <code>struct</code> or <code>record</code> to maintain the dope vector (see <a href="ch11.xhtml#ch11">Chapter 11</a> for more information about <code>struct</code>s and records). Here’s an example of a dope vector you might create for a two-dimensional integer array using HLA:</p>&#13;
		<pre class="programs">&#13;
			type<br/>    dopeVector2D :<br/>        record<br/>            ptrToArray :pointer to int32;<br/>            bounds :uns32[2];<br/>        endrecord;</pre>&#13;
		<p class="indent">Here’s the HLA code you would use to read the bounds of a two-dimensional array from the user and allocate storage for the pseudo-dynamic array using this dope vector:</p>&#13;
		<pre class="programs">&#13;
			var<br/>    pdArray :dopeVector2D;<br/>        .<br/>        .<br/>        .<br/>stdout.put( "Enter array dimension #1:" );<br/>stdin.get( pdArray.bounds[0] );<br/>stdout.put( "Enter array dimension #2:" );<br/>stdin.get( pdArray.bounds[4] );  //Remember, '4' is a<br/>                                 // byte offset into bounds.<br/><span epub:type="pagebreak" id="page_261"/>// To allocate storage for the array, we must<br/>// allocate bounds[0]*bounds[4]*4 bytes:<br/><br/>mov( pdArray.bounds[0], eax );<br/><br/>// bounds[0]*bounds[4] -&gt; EAX<br/><br/>intmul( pdArray.bounds[4], eax );<br/><br/>// EAX := EAX * 4 (4=size of int32).<br/><br/>shl( 2, eax );<br/><br/>// Allocate the bytes for the array.<br/><br/>malloc( eax );<br/><br/>// Save away base address.<br/><br/>mov( eax, pdArray.ptrToArray );</pre>&#13;
		<p class="indent">This example emphasizes that the program must compute the size of the array as the product of the array dimensions and the element size. When processing static arrays, the compiler can compute this product during compilation. When working with dynamic arrays, however, the compiler must emit machine instructions to compute this product at runtime, which means your program will be slightly larger and slightly slower than if you had used a static array.</p>&#13;
		<p class="indent">If a language doesn’t directly support pseudo-dynamic arrays, you’ll have to translate a list of indices into a single offset using the row-major function (or something comparable). This is true in HLLs as well as assembly language. Consider the following C++ example, which uses row-major ordering to access an element of a pseudo-dynamic array:</p>&#13;
		<pre class="programs">&#13;
			typedef struct<br/>{<br/>    int *ptrtoArray;<br/>    int bounds[2];<br/>} dopeVector2D;<br/><br/>dopeVector2D pdArray;<br/>        .<br/>        .<br/>        .<br/>    // Allocate storage for the pseudo-dynamic array:<br/><br/>    cout &lt;&lt; "Enter array dimension #1:";<br/>    cin &gt;&gt; pdArray.bounds[0];<br/>    cout &lt;&lt; "Enter array dimension #2:" ;<br/>    cin &gt;&gt; pdArray.bounds[1];<br/>    pdArray.ptrtoArray =<br/>        new int[ pdArray.bounds[0] * pdArray.bounds[1] ];<br/><span epub:type="pagebreak" id="page_262"/>        .<br/>        .<br/>        .<br/>    // Set all the elements of this dynamic array to<br/>    // successive integer values:<br/><br/>    k = 0;<br/>    for( i=0; i &lt; pdArray.bounds[0]; ++i )<br/>    {<br/>        for( j=0; j &lt; pdArray.bounds[1]; ++j )<br/>        {<br/>            // Use row-major ordering to access<br/>            // element [i][j]:<br/><br/>            *(pdArray.ptrtoArray + i*pdArray.bounds[1] + j) = k;<br/>            ++k;<br/>        }<br/>    }</pre>&#13;
		<p class="indent">As for one-dimensional pseudo-dynamic arrays, memory allocation and deallocation can be more expensive than the actual array access—particularly if you allocate and deallocate many small arrays.</p>&#13;
		<p class="indent">A big problem with multidimensional dynamic arrays is that the compiler doesn’t know the array bounds at compile time, so it can’t generate array access code that’s as efficient as what’s possible for pseudo-static and static arrays. As an example, consider the following C code:</p>&#13;
		<pre class="programs">&#13;
			#include &lt;stdlib.h&gt;<br/><br/>int main( int argc, char **argv )<br/>{<br/><br/>    // Allocate storage for a 3x3x3 dynamic array:<br/><br/>    int *iptr = (int*) malloc( 3*3*3 *4 );<br/>    int depthIndex;<br/>    int rowIndex;<br/>    int colIndex;<br/><br/>    // A pseudo-static 3x3x3 array for comparison:<br/><br/>    int ssArray[3][3][3];<br/><br/>    // The following nested for loops initialize all<br/>    // the elements of the dynamic 3x3x3 array with<br/>    // zeros:<br/><br/>    for( depthIndex=0; depthIndex&lt;3; ++depthIndex )<br/>    {<br/>        for( rowIndex=0; rowIndex&lt;3; ++rowIndex )<br/>        {<br/>            for( colIndex=0; colIndex&lt;3; ++colIndex )<br/>            {<br/><span epub:type="pagebreak" id="page_263"/>                iptr<br/>                [<br/>                    // Row-major order computation:<br/><br/>                      ((depthIndex*3) + rowIndex)*3<br/>                    + colIndex<br/><br/>                ] = 0;<br/>            }<br/>        }<br/>    }<br/><br/>    // The following three nested loops are comparable<br/>    // to the above, but they initialize the elements<br/>    // of a pseudo-static array. Because the compiler<br/>    // knows the array bounds at compile time, it can<br/>    // generate better code for this sequence.<br/><br/>    for( depthIndex=0; depthIndex&lt;3; ++depthIndex )<br/>    {<br/>        for( rowIndex=0; rowIndex&lt;3; ++rowIndex )<br/>        {<br/>            for( colIndex=0; colIndex&lt;3; ++colIndex )<br/>            {<br/>                ssArray[depthIndex][rowIndex][colIndex] = 0;<br/>            }<br/>        }<br/>    }<br/><br/>    return 0;<br/>}</pre>&#13;
		<p class="indent">Here’s the pertinent portion of the PowerPC code that GCC emits for this C program (manually annotated). The important thing to notice here is that the dynamic array code is forced to use an expensive multiply instruction, whereas the pseudo-static array code doesn’t need this instruction.</p>&#13;
		<pre class="programs">&#13;
			    .section __TEXT,__text,regular,pure_instructions<br/><br/>_main:<br/><br/>// Allocate storage for local variables<br/>// (192 bytes, includes the ssArray,<br/>// loop control variables, other stuff,<br/>// and padding to 64 bytes):<br/><br/>    mflr r0<br/>    stw r0,8(r1)<br/>    stwu r1,-192(r1)<br/><br/>// Allocate 108 bytes of storage for<br/>// the 3x3x3 array of 4-byte ints.<br/>// This call to  malloc leaves the<br/>// pointer to the array in R3.<br/><span epub:type="pagebreak" id="page_264"/>    li r3,108<br/>    bl L_malloc$stub<br/><br/>    li r8,0     // R8= depthIndex<br/>    li r0,0<br/><br/>    // R10 counts off the number of<br/>    // elements in rows we've processed:<br/><br/>    li r10,0<br/><br/>// Top of the outermost for loop<br/><br/>L16:<br/>    // Compute the number of bytes<br/>    // from the beginning of the<br/>    // array to the start of the<br/>    // row we are about to process.<br/>    // Each row contains 12 bytes and<br/>    // R10 contains the number of rows<br/>    // processed so far. The product<br/>    // of 12 by R10 gives us the number<br/>    // of bytes to the start of the<br/>    // current row. This value is put<br/>    // into R9:<br/><br/>    mulli r9,r10,12<br/><br/>    li r11,0    // R11 = rowIndex<br/><br/>// Top of the middle for loop<br/><br/>L15:<br/>    li r6,3     // R6/CTR = colIndex<br/><br/>    // R3 is the base address of the array.<br/>    // R9 is the index to the start of the<br/>    // current row, computed by the MULLI<br/>    // instruction, above. R2 will now<br/>    // contain the base address of the<br/>    // current row in the array.<br/><br/>    add r2,r9,r3<br/><br/>    // CTR = 3<br/><br/>    mtctr r6<br/><br/>    // Repeat the following loop<br/>    // once for each element in<br/>    // the current row of the array:<br/><br/>L45:<br/>    stw r0,0(r2)    // Zero out current element<br/>    addi r2,r2,4    // Move on to next element<br/><span epub:type="pagebreak" id="page_265"/>    bdnz L45        // Repeat loop CTR times<br/><br/>    addi r11,r11,1  // Bump up RowIndex by 1<br/>    addi r9,r9,12   // Index of next row in array<br/>    cmpwi cr7,r11,2 // Repeat for RowIndex=0..2<br/>    ble+ cr7,L15<br/><br/>    addi r8,r8,1    // Bump up depthIndex by 1<br/>    addi r10,r10,3  // Bump up element cnt by 3<br/>    cmpwi cr7,r8,2  // Repeat for depthIndex=0..2<br/>    ble+ cr7,L16<br/><br/>/////////////////////////////////////////////////////<br/>//<br/>// Here's the code that initializes the pseudo-static<br/>// array:<br/><br/>    li r8,0         // DepthIndex = 0<br/>    addi r10,r1,64  // Compute base address of ssArray<br/>    li r0,0<br/>    li r7,0         // R7 is index to current row<br/>L31:<br/>    li r11,0        // RowIndex = 0<br/>    slwi r9,r7,2    // Convert row/int index to<br/>                    // row/byte index (int_index*4)<br/>L30:<br/>    li r6,3         // # iterations for colIndex<br/>    add r2,r9,r10   // Base+row_index = row address<br/>    mtctr r6        // CTR = 3<br/><br/>// Repeat innermost loop three times:<br/><br/>L44:<br/>    stw r0,0(r2)    // Zero out current element<br/>    addi r2,r2,4    // Bump up to next element<br/>    bdnz L44        // Repeat CTR times<br/><br/>    addi r11,r11,1  // Bump up RowIndex by 1<br/>    addi r9,r9,12   // R9=Adrs of start of next row<br/>    cmpwi cr7,r11,2 // Repeat until RowIndex &gt;=3<br/>    ble+ cr7,L30<br/><br/>    addi r8,r8,1    // Bump up depthIndex by 1<br/>    addi r7,r7,9    // Index of next depth in array<br/>    cmpwi cr7,r8,2<br/>    ble+ cr7,L31<br/><br/>    lwz r0,200(r1)<br/>    li r3,0<br/>    addi r1,r1,192<br/>    mtlr r0<br/>    blr</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_266"/>Different compilers and different optimization levels handle dynamic and pseudo-static array access in different ways. Some compilers generate the same code for both sequences, but many do not. The bottom line is that multidimensional dynamic array access is never faster than pseudo-static multidimensional array access, and it is sometimes slower.</p>&#13;
		<h5 class="h5" id="ch00lev3sec60"><strong>8.1.7.3 Pure Dynamic Arrays</strong></h5>&#13;
		<p class="noindent">Pure dynamic arrays are even more difficult to manage. You’ll rarely find them outside of very high-level languages like APL, SNOBOL4, LISP, and Prolog. The one notable exception is Swift, whose arrays are pure dynamic arrays. Most languages that support pure dynamic arrays don’t force you to explicitly declare or allocate storage for an array. Instead, you just use elements of an array, and if an element isn’t currently present in the array, the language automatically creates it for you. So, what happens if you currently have an array with elements <code>0</code> through <code>9</code> and you decide to use element <code>100</code>? Well, the result is language dependent. Some languages that support pure dynamic arrays will automatically create array elements <code>10..100</code> and initialize elements <code>10..99</code> with <code>0</code> (or some other default value). Other languages may allocate only element <code>100</code> and keep track of the fact that the other elements are not yet present in the array. Regardless, the extra bookkeeping necessary for each access to the array can be quite expensive. That’s why languages that support pure dynamic arrays aren’t more popular—they tend to execute programs slowly.</p>&#13;
		<p class="indent">If you’re using a language that supports dynamic arrays, keep in mind the costs associated with array access in that language. If you’re using a language that doesn’t support dynamic arrays, but does support memory allocation/deallocation (for example, C/C++, Java, or assembly), you can implement dynamic arrays yourself. You’ll be painfully aware of the costs of using such an array, because you’ll probably have to write all the code that manipulates its elements, although that’s not an altogether bad thing. If you’re using C++, you can even overload the array index operator (<code>[ ]</code>) to hide the complexity of dynamic array element access. Generally, though, programmers who need the true semantics of dynamic arrays will usually choose a language that directly supports them. Again, if you choose to go this route, just be mindful of the costs.</p>&#13;
		<h3 class="h3" id="ch00lev1sec71"><strong>8.2 For More Information</strong></h3>&#13;
		<p class="bib">Duntemann, Jeff. <em>Assembly Language Step-by-Step</em>. 3rd ed. Indianapolis: Wiley, 2009.</p>&#13;
		<p class="bib">Hyde, Randall. <em>The Art of Assembly Language</em>. 2nd ed. San Francisco: No Starch Press, 2010.</p>&#13;
		<p class="bib">Knuth, Donald. <em>The Art of Computer Programming, Volume I: Fundamental Algorithms. 3rd ed.</em> Boston: Addison-Wesley Professional, 1997.</p>&#13;
	</body></html>