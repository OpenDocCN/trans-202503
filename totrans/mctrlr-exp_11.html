<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2a" id="ch11"><span epub:type="pagebreak" id="page_109"/><strong>11  STM32F1 Interrupt Jigsaw</strong></h2>&#13;
<p class="noindent">RDP Level 1 of the STM32 series, in which JTAG debugging is allowed but immediately disconnects flash memory, is an appealing target for memory extraction exploits. The STM32F1 series does not seem to be vulnerable to Obermaier’s STM32F0 exploit from <a href="ch10.xhtml#ch10">Chapter 10</a> or the DFU bootloader exploit from <a href="ch02.xhtml#ch02">Chapter 2</a>, but in this chapter we will cover a different vulnerability, first described in Schink and Obermaier (2020) for the STM32F1 and shortly after in Obermaier, Schink, and Moczek (2020) for two of its clones, the APM32F103 and CKS32F103. As a bonus, the STM32F1 series does not support RDP Level 2, so it’s possible that all parts in the series are vulnerable.</p>&#13;
<p class="indent">When protections are enabled, flash memory is disconnected from the main memory bus when a debugger is attached. You can’t fetch it as data, and you can’t even fetch it as code for execution. The trick here is that while flash memory is disconnected from the main memory bus for code and data fetches, interrupts can still be fired. The interrupt addresses are accurately fetched from the interrupt vector table (IVT) despite the disconnect! This table is also movable, and by stepping the table slowly across memory, we can move most words of memory into the programmer counter for the debugger to catch.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_110"/><img id="ch11fig1" src="../images/f0110-01.jpg" alt="Image" width="778" height="754"/></div>&#13;
<p class="figcap">Figure 11.1: STM32F103</p>&#13;
<h3 class="h3" id="ch00lev1sec38"><span epub:type="pagebreak" id="page_111"/><strong>The First Two Words</strong></h3>&#13;
<div class="imagel"><img src="../images/f0111-01.jpg" alt="Image" width="797" height="66"/></div>&#13;
<p class="indent">Schink’s paper begins with this gloriously simple example, in which he first attaches a Segger J-Link adapter through SWD and then calls <span class="literal">reset halt</span> in OpenOCD’s telnet session to reveal that <span class="literal">0x08000268</span> are the upper 31 bits of the reset vector, the second word in flash memory. <span class="literal">0x20005000</span> is the initial stack pointer, the very first word.</p>&#13;
<p class="indent">The low bit of the program counter is set (1) for all real handler addresses on this chip, indicating Thumb2 mode, but it might be clear (0), so we’ll need to recover that bit for a real exploit. This is because unlike the real interrupt table, the fake interrupt tables are mostly composed of instructions or data that are not interrupt handler addresses. Schink does this by first reading the program counter (whose low bit is forced clear) and then grabbing the Thumb2 mode from <span class="literal">ESPR</span> to restore the missing bit.</p>&#13;
<div class="imagel"><img src="../images/f0111-02.jpg" alt="Image" width="811" height="205"/></div>&#13;
<p class="indent">This gives us the first two words of flash memory, but in reading the code, you’ll see that these are a special case because triggering the reset also moves the interrupt table back to the beginning of flash memory.</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_112"/><img src="../images/f0112-01.jpg" alt="Image" width="811" height="159"/></div>&#13;
<h3 class="h3" id="ch00lev1sec39"><strong>The Rest of Memory</strong></h3>&#13;
<p class="noindent">For all other addresses, the entire interrupt table must be slowly stepped across flash memory, then individual interrupts must be triggered artificially to move table entries into the program counter.</p>&#13;
<p class="indent">The first complication to this is that seven entries in the list are unusable. We’ve already discussed that 0 (MSP) and 1 (reset) can’t be relocated, so except at the very beginning, those are forbidden. Exceptions 7, 8, 9, 10, and 13 are reserved, and we are unable to trigger them. Exceptions 16 and higher are external interrupts, and we can trigger them, but the count differs by chip model.</p>&#13;
<p class="indent">A second complication is that we are relocating the table with the vector table offset register (VTOR). This register is commonly used by custom bootloaders, such as the one in <a href="ch03.xhtml#ch03">Chapter 3</a>, so that the chip can boot with one interrupt table and later switch over to the application’s table.</p>&#13;
<p class="indent">If we could slide the interrupt table one word at a time, we could reuse a single interrupt to dump all words of memory, but as you can see in <a href="ch11.xhtml#ch11fig2">Figure 11.2</a>, we have a 128-word alignment restriction that gets in the way. We’ll need to step the table in chunks, then trigger individual interrupts to extract words from the table.</p>&#13;
<p class="indent">This alignment rule means that while we can slide the VTOR, we’ll have gaps for our forbidden exceptions, with seven words missing from every table! Schink found that while you do need to be aligned to the table size for proper operation, the table sort of wraps around if the table is aligned to half of its size and you trigger an interrupt that is after the end.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_113"/><img id="ch11fig2" src="../images/f0113-01.jpg" alt="Image" width="717" height="379"/></div>&#13;
<p class="figcap">Figure 11.2: VTOR from STMicro (2005)</p>&#13;
<div class="image"><img id="ch11fig3" src="../images/f0113-02.jpg" alt="Image" width="761" height="310"/></div>&#13;
<p class="figcap">Figure 11.3: Relocation of the IVT</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_114"/>So in an STM32F103 with 64 entries in its IVT, the table begins at <span class="literal">0x08000000</span> and we can officially use the VTOR to relocate it to aligned addresses: <span class="literal">0x08000100</span>, <span class="literal">0x08000200</span>, <span class="literal">0x0800-0300</span>, and so on. At these offsets, we are unable to read the seven words at offsets <span class="literal">0x00</span>, <span class="literal">0x04</span>, <span class="literal">0x1C</span>, <span class="literal">0x20</span>, <span class="literal">0x24</span>, <span class="literal">0x28</span>, and <span class="literal">0x34</span> because those interrupts are forbidden or impossible to trigger. But by setting the table to 32-word alignment at <span class="literal">0x08000080</span>, <span class="literal">0x08000180</span>, <span class="literal">0x08000280</span>, and so on, we can use the table wraparound to fill in the blanks, triggering interrupt 32 instead of 0 to dump offset <span class="literal">0x00</span>, or interrupt 39 instead of 7 to dump offset <span class="literal">0x1C</span>. <a href="ch11.xhtml#ch11fig3">Figure 11.3</a> demonstrates this.</p>&#13;
<p class="indent">Using this illegal-offset trick, we still miss seven words from each even 32-word block, but we collect all words from the odd 32-word blocks, giving us 89% coverage of the firmware on the STM32F103. Because we only miss words on the even blocks, our coverage is better in chips with larger interrupt tables.</p>&#13;
<h3 class="h3" id="ch00lev1sec40"><strong>Triggering Interrupts</strong></h3>&#13;
<p class="noindent">Now that we’ve covered the theory of Schink’s exploit, let’s cover some of the practical details behind triggering specific interrupts. After connecting to the OpenOCD server, his script begins by halting the target and disabling exception masking.</p>&#13;
<div class="imagel"><img src="../images/f0114-01.jpg" alt="Image" width="811" height="66"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_115"/>It then writes four half-word instructions to the beginning of SRAM at <span class="literal">0x20000000</span>, for triggering exceptions when they can’t be triggered directly. One is <span class="literal">svc #0</span> to trigger a supervisor call, the second is a <span class="literal">nop</span>, the third is a load instruction used to trigger a bus fault, and the fourth is <span class="literal">0xFFFF</span>, an illegal instruction. Many of these interrupts are disabled by default, so the code must first enable the feature and then perform the illegal action.</p>&#13;
<p class="indent">Each interrupt is triggered by first sending <span class="literal">reset halt</span> to OpenOCD, writing the VTOR address, and then triggering the individual interrupt by its own unique method.</p>&#13;
<p class="indent">First, the standard interrupts: Exception 2 is an NMI, triggered by setting bit 31 of <span class="literal">ICSR</span>. Exception 3 is a HardFault, triggered by executing <span class="literal">0xFFFF</span> from SRAM. Exception 4 is a MemFault, triggered by setting a bit of the <span class="literal">SHCSR</span> register and branching to unexecutable I/O memory at <span class="literal">0xe0000000</span>. Exception 5 is a BusFault, triggered by setting a different bit of <span class="literal">SHCSR</span> and branching to the <span class="literal">ldr</span> instruction in SRAM. Exception 6 is a UsageFault, triggered by jumping to the illegal instruction in RAM after setting the appropriate bit of <span class="literal">SHCSR</span>. Exception 11 is a Supervisor Call, triggered by executing <span class="literal">svc #0</span> from SRAM. Exception 12 is a DebugMonitor exception, triggered by setting bit 17 of <span class="literal">DEMCR</span>. Exception 14 is a PendSV interrupt, triggered by setting bit 28 of <span class="literal">ICSR</span>. Exception 15 is a SysTick interrupt, triggered by setting bit 26 of <span class="literal">ICSR</span>.</p>&#13;
<p class="indent">Starting with Exception 16 and continuing to the end of the table, we have external interrupts. Each of these has an exception number, beginning with 0 for Exception 16, and each can be triggered by setting the appropriate bit of both <span class="literal">NVIC_ISER0</span> and <span class="literal">NVIC_ISPR0</span>.</p>&#13;
<p class="indent">Except where a specific instruction is specified, you’ll probably want to execute a <span class="literal">nop</span> when triggering these interrupts to avoid any unpredictable errors in the extraction.</p>&#13;
<h3 class="h3" id="ch00lev1sec41"><span epub:type="pagebreak" id="page_116"/><strong>Counting the External Interrupts</strong></h3>&#13;
<p class="noindent">Only one thing is left before the exploit is ready to roll. We desperately need to know the size of the interrupt table, in order to know both when to slide it to a new position and when we can use the wraparound trick for half-aligned table positions.</p>&#13;
<p class="indent">It would work perfectly well for a demo to simply hard-code the values for a few known model numbers, but for the sake of portability, Schink’s exploit instead counts the external interrupts by triggering them sequentially until the Program Status Register (PSR) fails to indicate the exception.</p>&#13;
<p class="indent">Counting the interrupts also revealed that for some model numbers, the documentation erroneously listed some of these external interrupts as reserved, when in fact they functioned just like all the others.</p>&#13;
<h3 class="h3" id="ch00lev1sec42"><strong>Performance</strong></h3>&#13;
<p class="noindent">Schink’s paper concludes with a table of STM32F1 chips, along with their external interrupt counts, extraction time, and coverage when extracting 128kB of flash memory. (<a href="ch11.xhtml#ch11fig4">Figures 11.4</a> and <a href="ch11.xhtml#ch11fig5">11.5</a>.)</p>&#13;
<p class="indent">Extraction coverage is strictly limited by the number of interrupts, because of those pesky seven that can’t be triggered in an aligned interrupt table.</p>&#13;
<p class="indent">If it becomes too frustrating to reverse engineer the firmware given only the majority of the instructions, it might help to dump multiple versions of your target’s firmware. Gaps should appear in different places, allowing the missing part of one version to be filled in from another version. (There will of course be errors with this technique attributed to differences in source code and object size, but quite a few of the words should be correctly extracted.)</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_117"/><img id="ch11fig4" src="../images/f0117-01.jpg" alt="Image" width="618" height="162"/></div>&#13;
<p class="figcap">Figure 11.4: Code Coverage from Schink and Obermaier (2020)</p>&#13;
<div class="image"><img id="ch11fig5" src="../images/f0117-02.jpg" alt="Image" width="822" height="693"/></div>&#13;
<p class="figcap">Figure 11.5: Counting Interrupt Handlers</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_118"/>Schink used a Segger J-Link debugger at 3,500 kHz, and extraction time might be improved by reducing round-trips or increasing the clock rate. This won’t matter much for dumping a single device, of course, but it could be critical if you need to dump many different chips in order to fill in the coverage gaps with bytes from different versions of a product’s firmware.</p>&#13;
</div>
</div>
</body></html>