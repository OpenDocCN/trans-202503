- en: '11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '11'
- en: AUTOMATING ACTIVE DIRECTORY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化 Active Directory
- en: '![Images](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: One of the best products to automate with PowerShell is Microsoft’s Active Directory
    (AD). Employees are constantly entering, leaving, and moving around an organization.
    A dynamic system is needed to keep track of the ever-shifting flux of employees,
    and that’s where AD comes in. IT pros perform repetitive and similar tasks in
    AD, making it a perfect site for automation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PowerShell 自动化的最佳产品之一就是微软的 Active Directory（AD）。员工不断地进出并在组织中调动。需要一个动态系统来跟踪员工的不断变化，而这正是
    AD 的作用。IT 专业人员在 AD 中执行重复且相似的任务，这使得它成为自动化的理想场所。
- en: 'In this chapter, we’ll walk through using PowerShell to automate a few scenarios
    involving AD. Although numerous AD objects can be manipulated with PowerShell,
    we’ll cover only three of the most common: user accounts, computer accounts, and
    groups. These types of objects are the ones an AD administrator will most likely
    encounter on a day-to-day basis.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将演示如何使用 PowerShell 自动化处理一些涉及 AD 的场景。虽然可以使用 PowerShell 操作许多 AD 对象，但我们只会涉及三种最常见的对象：用户账户、计算机账户和组。这些对象是
    AD 管理员日常工作中最常遇到的。
- en: Prerequisites
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前提条件
- en: As you follow along with the examples in this chapter, I make a few assumptions
    about your computer environment.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你跟随本章的示例进行操作时，我假设你的计算机环境符合一些基本条件。
- en: The first is that you’re working on a Windows computer that’s already a member
    of an Active Directory domain. There are ways to work with AD from a workgroup
    computer using alternate credentials, but that’s beyond the scope of this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个要求是你正在使用一台已经是 Active Directory 域成员的 Windows 计算机。虽然有方法可以通过使用备用凭据从工作组计算机操作
    AD，但这超出了本章的范围。
- en: The second is that you’ll be working with the same domain that your computer
    is a member of. Complicated cross-domain and forest trust issues are also beyond
    the scope of this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个要求是你将使用与你的计算机属于同一域的环境。复杂的跨域和林信任问题也超出了本章的范围。
- en: The last is that you are logged into your computer with an AD account that has
    appropriate permissions to read, modify, and create common AD objects such as
    users, computers, groups, and organizational units. I am doing these exercises
    from a computer with an account that is part of the Domain Admins group—meaning
    I have control over everything in my domain. Although this is not completely necessary,
    and generally not recommended in a production environment, this allows me to demonstrate
    various topics without being concerned with object rights, which are beyond the
    scope of this book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要确保使用的是具有适当权限的 AD 账户登录到计算机，以便读取、修改和创建常见的 AD 对象，如用户、计算机、组和组织单位。我是在一个属于域管理员组的账户下进行这些练习的——这意味着我对我的域中的所有内容都有控制权限。虽然这不是完全必要的，通常也不推荐在生产环境中使用，但这使我可以在不担心对象权限的情况下演示各种主题，而对象权限超出了本书的范围。
- en: Installing the ActiveDirectory PowerShell Module
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 ActiveDirectory PowerShell 模块
- en: 'As you know by now, there’s more than one way to accomplish a task with PowerShell.
    Likewise, there’s not much use in reinventing the wheel when you can use the preexisting
    tools to make bigger and better ones. In this chapter, you’ll use only a single
    module: `ActiveDirectory`. Although it’s not without its shortcomings—obscure
    parameters, odd filtering syntax, strange error behavior—it’s by far the most
    comprehensive module for managing AD.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在所知道的，使用 PowerShell 完成任务有不止一种方式。同样，当你可以利用现有工具来构建更大、更好的工具时，就没有必要重新发明轮子。在本章中，你将只使用一个模块：`ActiveDirectory`。尽管它有一些不足之处——不太直观的参数、奇怪的过滤语法、异常的错误行为——但它无疑是管理
    AD 最全面的模块。
- en: The `ActiveDirectory` module comes with the *Remote Server Administration Tools*
    software package. This is a software bundle of many tools and, unfortunately,
    at the time of this writing, the only way to get a copy of the `ActiveDirectory`
    module. Before you continue with this chapter, I encourage you to download and
    install this package. Once you do, you’ll have the `ActiveDirectory` module installed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActiveDirectory`模块随*远程服务器管理工具*软件包提供。该软件包包含许多工具，而且不幸的是，在撰写本文时，这是获取`ActiveDirectory`模块的唯一方式。在继续阅读本章之前，我建议你下载并安装此软件包。安装后，你将拥有`ActiveDirectory`模块。'
- en: 'To confirm you have `ActiveDirectory` installed, you can use the `Get-Module`
    command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认你已经安装了`ActiveDirectory`，可以使用`Get-Module`命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you see this output, `ActiveDirectory` is installed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到此输出，说明`ActiveDirectory`已经安装。
- en: Querying and Filtering AD Objects
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询和过滤 AD 对象
- en: Once you’ve ensured that you’ve met all of the prerequisites and have the `ActiveDirectory`
    module installed, you’re ready to get started.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确保已经满足所有前提条件并安装了 `ActiveDirectory` 模块，你就可以开始了。
- en: One of the best ways to get acclimated to a new PowerShell module is to look
    for all its `Get` verb commands. Commands that begin with *Get* only read information,
    so the risk that you’ll change something by accident is minimal. Let’s take this
    approach with the `ActiveDirectory` module and look for commands associated with
    the objects we’ll be working with in this chapter. [Listing 11-1](ch11.xhtml#ch11list1)
    shows how to retrieve only the `ActiveDirectory` commands that begin with *Get*
    and have the word *computer* somewhere in the verb portion.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 适应新的 PowerShell 模块的最佳方法之一是查找所有以 `Get` 为动词的命令。以 *Get* 开头的命令仅用于读取信息，因此你意外更改某些内容的风险较小。我们将采取这种方法，使用
    `ActiveDirectory` 模块，查找与本章中将要操作的对象相关的命令。[Listing 11-1](ch11.xhtml#ch11list1) 展示了如何仅检索那些以
    *Get* 开头并且动词部分包含 *computer* 的 `ActiveDirectory` 命令。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 11-1: `ActiveDirectory` module `Get` commands*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-1: `ActiveDirectory` 模块 `Get` 命令*'
- en: You can see a few commands that look interesting. In this chapter, you’ll be
    using `Get-ADComputer`, `Get-ADUser`, `Get-ADGroupm`, and `Get-ADGroupMember`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到一些看起来很有趣的命令。在本章中，你将使用 `Get-ADComputer`、`Get-ADUser`、`Get-ADGroupm` 和 `Get-ADGroupMember`
    命令。
- en: Filtering Objects
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过滤对象
- en: Many of the `Get` AD commands you’ll be using have a common parameter called
    `Filter`. `Filter` is similar to the PowerShell `Where-Object` command as it filters
    what each command returns, but is different in the way it accomplishes this task.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的许多 `Get` AD 命令都有一个名为 `Filter` 的公共参数。`Filter` 类似于 PowerShell 的 `Where-Object`
    命令，因为它过滤每个命令返回的内容，但在实现这一任务的方式上有所不同。
- en: The `Filter` parameter uses its own syntax and can be difficult to understand,
    especially when you’re using complex filters. For a full breakdown of the `Filter`
    parameter’s syntax, you can run `Get-Help` `about`_`ActiveDirectory_Filter`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Filter` 参数使用它自己的语法，并且在使用复杂的过滤器时可能会很难理解。要详细了解 `Filter` 参数的语法，你可以运行 `Get-Help`
    `about`_`ActiveDirectory_Filter`。'
- en: 'For this chapter, we’ll keep it simple and avoid any advanced filtering. First,
    let’s use the `Filter` parameter and the `Get-ADUser` command to return all users
    in the domain, as shown in [Listing 11-2](ch11.xhtml#ch11list2). Be careful, though:
    if you have a lot of user accounts in your domain, you could be waiting a while.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将保持简单，避免使用任何高级过滤。首先，让我们使用 `Filter` 参数和 `Get-ADUser` 命令返回域中的所有用户，如 [Listing
    11-2](ch11.xhtml#ch11list2) 所示。不过要小心：如果你的域中有大量用户账户，可能需要等待一段时间。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 11-2: Finding all user accounts in a domain*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-2: 查找域中的所有用户账户*'
- en: As you can see, the `Filter` parameter accepts a string value wildcard character,
    `*`. On its own, this character tells (most) `Get` commands to return everything
    they find. Although this can be occasionally useful, most of the time you don’t
    want *all* possible objects. However, used correctly, the wildcard character is
    a powerful tool.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Filter` 参数接受一个字符串值通配符字符 `*`。单独使用时，这个字符告诉（大多数）`Get` 命令返回它们找到的所有内容。尽管这种做法偶尔会有用，但大多数时候你并不想要*所有*可能的对象。不过，如果正确使用，通配符字符是一个强大的工具。
- en: Let’s say you want to find all computer accounts in AD that start with the letter
    *C*. You can do so by running `Get-ADComputer -Filter 'Name -like "C*"'`, where
    `C*` represents all characters after a *C*. You could also do it in reverse; say
    you want to find anyone with a last name that ends in *son*. You could run the
    command `Get-ADComputer -Filter 'Name -like "*son"'`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在 AD 中查找所有以字母 *C* 开头的计算机账户。你可以通过运行 `Get-ADComputer -Filter 'Name -like "C*"'`
    来实现，其中 `C*` 代表所有以 *C* 开头的字符。你也可以反过来操作；假设你想查找姓氏以 *son* 结尾的人。你可以运行命令 `Get-ADComputer
    -Filter 'Name -like "*son"'`。
- en: If you want to find all users that have a last name of *Jones*, you could run
    `Get-ADUser -Filter "surName -eq 'Jones'"`; if you want a single user using the
    first and last name, you could run `Get-ADUser -Filter "surName -eq 'Jones' -and
    givenName -eq 'Joe'`. The `Filter` parameter allows you to use various PowerShell
    operators such as `like` and `eq` to build a filter that returns only the results
    you’re looking for. Active Directory attributes are stored in the AD database
    using lower camel case, so that’s what I’ve used in the filters, although this
    isn’t technically necessary.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想找到所有姓*Jones*的用户，可以运行`Get-ADUser -Filter "surName -eq 'Jones'"`；如果你想根据名字和姓氏找到一个用户，可以运行`Get-ADUser
    -Filter "surName -eq 'Jones' -and givenName -eq 'Joe'"`。`Filter`参数允许你使用各种PowerShell操作符，如`like`和`eq`，构建一个仅返回你所需要结果的过滤器。Active
    Directory属性以小驼峰命名法存储在AD数据库中，因此在过滤器中使用的是这种格式，尽管从技术上讲，这并不是必须的。
- en: Another command useful for filtering AD objects is the `Search-ADAccount` command.
    This command has built-in support for common filtering scenarios such as finding
    all users with an expired password, finding locked-out users, and finding computers
    that are enabled. Check out the help for the `Search-ADAccount` cmdlet to see
    the full range of parameters.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于过滤AD对象的有用命令是`Search-ADAccount`命令。该命令内置了对常见过滤场景的支持，比如查找密码已过期的所有用户、查找被锁定的用户，以及查找已启用的计算机。查看`Search-ADAccount`
    cmdlet的帮助文档，了解所有参数。
- en: Most of the time, the `Search-ADAccount` syntax is self-explanatory. Various
    switch parameters, including `PasswordNeverExpires`, `AccountDisabled`, and `AccountExpired`,
    do not require other parameters to function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，`Search-ADAccount`语法是自解释的。各种切换参数，包括`PasswordNeverExpires`、`AccountDisabled`和`AccountExpired`，不需要其他参数即可使用。
- en: Besides these fancy parameters, `Search-ADAccount` also has various parameters
    that require additional input—for example, to indicate how old a datetime attribute
    is or if you need to limit the results by a particular object type (for example,
    Users or Computers).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些高级参数，`Search-ADAccount`还具有一些需要额外输入的参数——例如，指示日期时间属性的年龄，或者如果你需要按特定对象类型（例如，用户或计算机）限制结果。
- en: Let’s use the `AccountInactive` parameter as an example. Say you want to find
    all users who haven’t used their account in 90 days. This is a great query for
    `Search-ADAccount`. By using the syntax in [Listing 11-3](ch11.xhtml#ch11list3),
    using `–``UsersOnly` to filter the type of object and `–``TimeSpan` to filter
    for objects that have not been active in the last 90 days, you can quickly find
    all the requested users.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`AccountInactive`参数为例。假设你想查找90天内没有使用其账户的所有用户。这是`Search-ADAccount`的一个很好的查询。通过使用[示例
    11-3](ch11.xhtml#ch11list3)中的语法，使用`–`UsersOnly`来过滤对象类型，并使用`–`TimeSpan`来过滤过去90天内未活跃的对象，你可以快速找到所有符合要求的用户。
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 11-3: Using `Search-ADAccount`*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-3：使用`Search-ADAccount`*'
- en: The `Search-ADAccount` cmdlet returns an object type of `Microsoft.ActiveDirectory.Management.ADUser`.
    This is the same object type that commands such as `Get-ADUser` and `Get-ADComputer`
    return. `Search-ADAccount` can be a good shortcut when you’re using a `Get` command
    and feel stuck trying to figure out what syntax to use for the `Filter` parameter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Search-ADAccount` cmdlet返回的对象类型是`Microsoft.ActiveDirectory.Management.ADUser`。这是与`Get-ADUser`和`Get-ADComputer`等命令返回的对象类型相同的类型。当你使用`Get`命令并感到卡住，不知道该如何编写`Filter`参数的语法时，`Search-ADAccount`可以作为一个很好的快捷方式。'
- en: Returning Single Objects
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回单个对象
- en: Sometimes you know the exact AD object you’re looking for, so there’s no need
    to use `Filter` at all. Here, you can use the `Identity` parameter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你知道自己要查找的确切AD对象，因此根本不需要使用`Filter`。在这种情况下，你可以使用`Identity`参数。
- en: '`Identity` is a flexible parameter that allows you to specify attributes that
    make an AD object unique; thus it returns only a single object. Every user account
    has a unique attribute called `samAccountName`. You could use the `Filter` parameter
    to find all users with a specific `samAccountName`, which would look like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Identity`是一个灵活的参数，允许你指定使AD对象唯一的属性；因此，它只会返回一个对象。每个用户帐户都有一个唯一的属性，叫做`samAccountName`。你可以使用`Filter`参数查找所有具有特定`samAccountName`的用户，语法如下：'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But it’s much cleaner to use the `Identity` parameter instead:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但是使用`Identity`参数会更加简洁：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Project 4: Finding User Accounts That Haven’t Changed Their Password in 30
    Days'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目4：查找30天内没有更改密码的用户帐户
- en: 'Now that you have a basic understanding of how to query AD objects, let’s create
    a small script and put that knowledge to use. Here’s the scenario: you work at
    a company that’s about to implement a new password-expiration policy and your
    job is to find all the accounts that haven’t changed their password in the past
    30 days.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s think about what command to use. Your first choice might be the
    `Search-ADAccount` command you learned earlier in this chapter. `Search-ADAccount`
    has many uses for searching and filtering on various objects, but you can’t craft
    custom filters. To get more granular in your searching, you’ll have to build your
    own filters by using the `Get-ADUser` command.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Once you know what command you’re going to use, the next step is to figure out
    what you want to filter for. You know you want to filter for accounts that haven’t
    changed their password in the past 30 days, but if you look only for that, you’ll
    find more accounts than you need. Why? If you don’t filter for accounts that are
    `Enabled`, you’ll probably get old accounts that don’t matter anymore (maybe someone
    who left the company or lost computer privileges). So you look for enabled computers
    that haven’t changed their password in the past 30 days.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with filtering enabled user accounts. You can do this by using `–Filter
    "Enabled -eq 'True'"`. Simple enough. The next step is to figure out how to access
    the attribute that is stored when a user’s password is set.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: By default, `Get-ADUser` doesn’t return all of a user’s properties. Using the
    `Properties` parameter, you can specify which properties you’d like to see; here,
    you’ll use `name` and `passwordlastset`. Notice that some users don’t have a `password``lastset`
    property. This is because they’ve never set their own password.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that you have the attribute name, you need to build a filter for it. Remember
    that you want only accounts whose passwords changed in the past 30 days. To find
    a date difference, you need two dates: the oldest possible date (30 days ago)
    and the newest possible date (today). You can get today’s date easily by using
    the `Get-Date` command. And you can use the `AddDays` method to figure out what
    the date was 30 days ago. You’ll store both in variables for easy access later.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that you have the dates, you can use them in the filter:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All that’s left to do is to add your `Enabled` condition to the filter. [Listing
    11-4](ch11.xhtml#ch11list4) shows the steps to do this.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 11-4: Finding enabled user accounts that haven’t changed their password
    in 30 days*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: You now have some code built up to find all enabled Active Directory users that
    have set their password in the last 30 days.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Changing AD Objects
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you know how to find existing AD objects, let’s learn how to change
    and create them. This section is divided into two parts: one dealing with users
    and computers, and one dealing with groups.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Users and Computers
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To change users and computer accounts, you’ll use a `Set` command: either `Set-ADUser`
    or `Set-ADComputer`. These commands can change any attribute of an object. Usually,
    you’ll want to pipe in an object you get from a `Get` command (like those covered
    in the previous lesson).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改用户和计算机账户，你将使用 `Set` 命令：`Set-ADUser` 或 `Set-ADComputer`。这些命令可以更改对象的任何属性。通常，你会希望将从
    `Get` 命令（如上一节中介绍的命令）获取的对象传递给它们。
- en: As an example, say that an employee named Jane Jones got married, and you’re
    asked to change the last name of her user account. If you didn’t know an identity
    attribute for this user account, you could use the `Filter` parameter on `Get-ADUser`
    to find it. But first, you’d need to discover how AD stores each user’s first
    and last name. You can then use the values of those attributes to pass to the
    `Filter` parameter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，假设一名员工名叫Jane Jones，她结婚了，你需要更改她用户账户的姓氏。如果你不知道此用户账户的身份属性，你可以在 `Get-ADUser`
    上使用 `Filter` 参数来查找它。但首先，你需要发现AD是如何存储每个用户的名字和姓氏的。然后，你可以使用这些属性的值传递给 `Filter` 参数。
- en: 'One way to find all available attributes stored in AD is with a little .NET.
    Using a schema object, you can find the user class and enumerate all of its attributes:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 查找存储在AD中的所有可用属性的一种方法是使用一些.NET代码。通过使用模式对象，你可以找到用户类并枚举其所有属性：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By reviewing the available attribute list, you then find the `givenName` and
    `surName` attribute to use in the `Filter` parameter with the `Get-ADUser` command,
    finding the user account. Next, you can pass that object to `Set-ADUser`, as shown
    in [Listing 11-5](ch11.xhtml#ch11list5).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看可用属性列表，你会找到 `givenName` 和 `surName` 属性，这些属性可以与 `Get-ADUser` 命令中的 `Filter`
    参数一起使用，找到用户账户。接下来，你可以将该对象传递给 `Set-ADUser`，如 [列表 11-5](ch11.xhtml#ch11list5) 所示。
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 11-5: Changing AD object attributes with `Set-ADUser`*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-5：使用 `Set-ADUser` 更改AD对象属性*'
- en: 'You can also change multiple attributes at once. It turns out Jane also moved
    departments and got a promotion, both of which need to be updated. Not a problem.
    You just need to use the parameters that match up to the AD attributes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以一次更改多个属性。结果发现Jane也调动了部门并且得到了晋升，这两个变动都需要更新。没问题，你只需要使用与AD属性相匹配的参数：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finally, you can create AD objects by using `New-AD*` commands. Creating new
    AD objects is similar to changing existing objects, but here you don’t have access
    to an `Identity` parameter. Creating a new AD computer account is as easy as running
    `New-ADComputer -Name FOO`; likewise, an AD user can be created by using `New-ADUser
    -Name adam`. You’ll see that the `New-AD*` commands also have parameters that
    correlate to AD attributes, just like the `Set-AD*` commands do.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用 `New-AD*` 命令创建AD对象。创建新的AD对象与更改现有对象类似，但在这里你无法使用 `Identity` 参数。创建一个新的AD计算机账户就像运行
    `New-ADComputer -Name FOO` 一样简单；同样，可以通过使用 `New-ADUser -Name adam` 创建一个AD用户。你会发现
    `New-AD*` 命令也有与AD属性相关的参数，和 `Set-AD*` 命令一样。
- en: Groups
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 组
- en: '*Groups* are trickier than users and computers. One way to think about groups
    is as a container for many AD objects. In that sense, a group is a bunch of things.
    But at the same time, it’s still a *single* container, meaning that just like
    users and computers, a group is a singular AD object. That means you can query,
    create, and change groups the same way you would users and computers, with a few
    slight differences.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*组* 比用户和计算机更复杂。你可以把组看作是许多AD对象的容器。从这个意义上来说，组就是一堆东西。但同时，它仍然是一个*单一*的容器，意味着像用户和计算机一样，组是一个单一的AD对象。这也意味着你可以像查询、创建和更改用户和计算机一样查询、创建和更改组，尽管会有一些细微的差别。'
- en: Maybe your organization created a new department called AdamBertramLovers, and
    it’s bursting at the seams with new employees. Now you need to create a group
    with this name. [Listing 11-6](ch11.xhtml#ch11list6) shows an example of how to
    create such a group. You use the `Description` parameter to pass in a string (the
    group’s description), and the `GroupScope` parameter to ensure that the group
    created has a scope of `DomainLocal`. You could have chosen `Global` or `Universal`
    here as well if that’s what you required.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你的组织创建了一个新的部门，叫做AdamBertramLovers，它正在快速扩张，吸引了很多新员工。现在你需要创建一个名为该部门的组。[列表 11-6](ch11.xhtml#ch11list6)
    显示了如何创建这样的组的示例。你使用 `Description` 参数传入一个字符串（组的描述），并使用 `GroupScope` 参数来确保创建的组具有
    `DomainLocal` 范围。如果需要的话，你也可以选择 `Global` 或 `Universal`。
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 11-6: Creating an AD group*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-6：创建一个AD组*'
- en: 'Once the group exists, you can modify it just as you would a user or computer.
    To change the description, for example, you could do this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Of course, the key difference between groups and users/computers is that a group
    can contain users and computers. When a computer or user account is contained
    within a group, we say that is a *member* of that group. But to add and change
    members of a group, you can’t use the commands you’ve been using. Instead, you
    need to use `Add-ADGroupMember` and `Remove-ADGroupMember`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to add Jane to our group, you can do so using `Add-ADGroupMember`.
    If Jane wants to leave the group, you can remove her by using `Remove-ADGroupMember`.
    As you try this, you’ll find that running the `Remove-ADGroupMember` command will
    lead to a prompt asking you to confirm your decision to remove the member:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Add the `Force` parameter if you want to skip this check, but be aware that
    getting that confirmation may end up saving you one day!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 5: Creating an Employee Provisioning Script'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s bring this all together and tackle another real-world scenario. Your
    company has hired a new employee. You, the system administrator, now have to perform
    a series of actions: creating an AD user, creating their computer account, and
    adding them to specific groups. You’ll build a script that will automate this
    whole process.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'But before you start this project—and really, any project—it’s important to
    figure out what the script will do and write down an informal definition. For
    this script, you need to create the AD user, which will:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically create a username for user based on the first name and last name
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and assign the user a random password
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Force the user to change their password at logon
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the department attribute based on the department given
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign the user an internal employee number
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, add the user account to a group with the same name as the department.
    Finally, add the user account into an organizational unit with the same name as
    the department the employee is in.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Now, with these requirements laid out, let’s build the script. The finished
    script will be called *New-Employee.ps1* and is available in the book’s resources.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: You want this to be a reusable script. Ideally, anytime you have a new employee,
    you can use the script. This means you need to figure out a smart way to handle
    the inputs to the script. By looking at the requirements, you know you’ll need
    a first name, a last name, a department, and an employee number. [Listing 11-7](ch11.xhtml#ch11list7)
    provides a script outline with all parameters defined and a `try/catch` block
    to catch any terminating errors you may encounter. The `#requires` statement is
    set at the top to ensure that whenever this script is run, it checks to see that
    the machine has the `ActiveDirectory` module installed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 11-7: Base* New-Employee.ps1 *script*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Now that you created the base, let’s fill out the `try` block.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to create an AD user according to the requirements laid out
    in our informal definition. You have to *dynamically create* a username. There
    are several ways to do this: some organizations prefer the username to be the
    first initial and the last name, some prefer first name and last name, and some
    do something else entirely. Let’s say your company uses first initial and last
    name. If that username is taken, the next character in the first name is added
    until a unique username is found.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要根据我们非正式定义中列出的要求创建一个AD用户。你必须*动态创建*一个用户名。实现这一点的方法有很多：一些组织喜欢用户名是名字的首字母加姓氏，有些喜欢名字和姓氏组合，还有些完全有不同的做法。假设你的公司使用名字首字母加姓氏。如果该用户名已被占用，则会继续从名字中添加下一个字符，直到找到一个唯一的用户名。
- en: 'Let’s handle the base case first. You’ll use the built-in `Substring` method
    on every string object to get the first initial. You’ll then concatenate the last
    name to the first initial. You’ll do this by using *string formatting*, which
    allows you to define placeholders for multiple expressions in a string and replace
    the placeholders with values at runtime, like so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先处理基本情况。你将对每个字符串对象使用内置的`Substring`方法来获取名字的首字母。然后，你将姓氏与首字母连接在一起。你将通过*字符串格式化*来完成这一步，字符串格式化允许你在字符串中定义多个表达式的占位符，并在运行时用值替换这些占位符，示例如下：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After you create the initial username, you need to query AD to see whether this
    username is already taken by using `Get-ADUser`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 创建初始用户名后，你需要查询AD，使用`Get-ADUser`检查该用户名是否已被占用。
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If this command returns anything, the username is taken, and you need to try
    the next username. This means you need to figure out a way to dynamically generate
    new names, always being prepared for the possibility that the new username is
    taken. A good way to check for various usernames is a `while` loop conditioned
    on your previous call to `Get-ADUser`. But you’ll need another condition to account
    for what happens if you run out of letters in the first name. You don’t want the
    loop to run forever, so you’ll put in another condition, `$userName –notlike "$FirstName*"`,
    to stop the loop.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该命令返回任何内容，则用户名已被占用，你需要尝试下一个用户名。这意味着你需要找到一种方法来动态生成新用户名，并始终为用户名已被占用的情况做好准备。检查不同用户名的一个好方法是使用`while`循环，条件是你之前对`Get-ADUser`的调用结果。但你还需要另一个条件来应对如果名字中的字母用完的情况。你不希望循环永远运行下去，所以你会添加另一个条件，`$userName
    –notlike "$FirstName*" `，来停止循环。
- en: 'The `while` condition looks like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 条件看起来像这样：'
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With the `while` condition created, you can fill out the rest of the loop:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了`while`条件后，你可以完成循环的其余部分：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For each iteration of the loop, you add an additional character from the first
    name to the proposed username by taking the substring of the first name from 0
    to `i`, where `$i` is a counter variable that starts at 2 (the next position in
    the string) and is increased each time the loop runs. By the time this `while`
    loop finishes, it will have either found a unique username or exhausted all options.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于循环的每次迭代，你通过获取从0到`i`的子字符串，将第一个名字中的一个额外字符添加到建议的用户名中，其中`$i`是一个计数器变量，它从2（字符串中的下一个位置）开始，并在每次循环运行时增加。到这个`while`循环结束时，它要么找到了一个唯一的用户名，要么已经耗尽了所有选项。
- en: 'If an existing username *isn’t* found, you’re clear to create the username
    you intended to. If a username *is* found, you have a few other things to check.
    You need to check whether the *organizational unit* *(OU)* and group you’re putting
    the user account into exists:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到现有用户名，你就可以创建你想要的用户名。如果找到了一个用户名，你还需要检查其他事项。你需要检查你将用户账户放入的*组织单位*（OU）和组是否存在：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once you complete all the checks, you need to create the user account. Again,
    you have to consult our informal definition: *create and assign the user a* *random
    password*. You want to generate a random password every time this script runs.
    An easy way to generate a secure password is to use the `GeneratePassword` static
    method on the `System.Web.Security.Membership` object, as shown here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成所有检查，你需要创建用户账户。再一次，你需要参考我们的非正式定义：*创建并分配一个* *随机密码*给用户。你希望每次运行这个脚本时生成一个随机密码。生成安全密码的一种简单方法是使用`System.Web.Security.Membership`对象上的`GeneratePassword`静态方法，如下所示：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I chose to generate a password of at least 20 characters, with a maximum of
    32, but this is completely configurable. If desired, you could also find AD’s
    minimum required password by running `Get-ADDefaultDomainPasswordPolicy | Select-object
    -expand minPasswordLength`. This method even allows you to specify the length
    and complexity of the new password.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the password as a secure string, you have all the parameter
    values needed to create the user according to the requirements I laid out earlier.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After you make the user, all that’s left is to add them to the department group,
    which you can do with a simple `Add-ADGroupMember` command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Be sure to check out the *New-Employee.ps1* script in the book’s resources to
    get a copy of the full implementation of this script.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Syncing from Other Data Sources
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Active Directory, especially when used in large enterprises, can contain millions
    of objects being created and modified by dozens of people every day. With all
    that activity and all those inputs, problems are bound to arise. One of the biggest
    you’ll run into is keeping the AD database synced up with the rest of the organization.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: A company’s AD should be organized the same way the company is organized. This
    might mean that every department has its own associated AD group, every physical
    office its own OU, and so on. Regardless, as system administrators, we have the
    difficult task of ensuring that AD is always in sync with the rest of the organization.
    This is a great task for PowerShell.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Using PowerShell, you can “link” AD with just about any other source of information,
    meaning you can have PowerShell continually reading external data sources and
    making the appropriate changes to AD as necessary to create a sync process.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'This syncing process, when triggered, roughly consists of the following six
    steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Query the external data source (SQL database, CSV file, and so forth).
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve objects from AD.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find each object in the source that AD has a unique attribute to match on. This
    is usually referred to as an *ID*. The ID can be an employee ID or even usernames.
    The only thing that matters is that the attribute is unique. If no match is found,
    optionally create or remove the object from AD based on the source.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find a single matching object.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map all external data sources to AD object attributes.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify existing AD objects or create new ones.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll put this plan into action in the next section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 6: Creating a Syncing Script'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to build a script that’ll sync employees from
    a CSV file to AD. To do so, you’ll have to draw on some of the commands you learned
    in [Chapter 10](ch10.xhtml#ch10), as well as those you just learned in the previous
    lessons of this chapter. Before we get started, I encourage you to glance at *Employees.csv*
    and *Invoke-AdCsvSync.ps1* in the book’s resources and familiarize yourself with
    the project files.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: The key to building a great AD sync tool is sameness. By this, I don’t mean
    the data sources should be the same—since, technically, they never will be—but
    instead that you need to create a script that can query each datastore the same
    way and have each datastore return the same kind of object. The tricky part of
    this occurs when you have two sources that use different schemas. In that case,
    you may have to start doing some translation by mapping one field name to another
    (as you’ll do later in the chapter).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this: you already know that AD has common attributes associated with
    each user account—things like first name, last name, and department, which we’ll
    call a *schema* of attributes. However, chances are the source datastore you’d
    like to sync with will never have the exact same attributes. And even if it has
    the same attributes, it might know them by different names. To resolve this issue,
    you have to build a mapping between the two datastores.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Data Source Attributes
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An easy, effective way to create this mapping is to use a hashtable in which
    the key is the attribute name in the first datastore, and the value is the attribute
    name in the second datastore. To see this in action, let’s say you work at a company
    called Acme. Acme wants to sync employee records from a CSV file into AD. Specifically,
    they want to sync *Employees.csv*, which you can find in the book’s resources
    or here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Given that you know the headers of the CSV, and the property names in AD, you
    can build a mapping hashtable with the value for the CSV field as the key and
    the AD attribute name as the value:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will handle the conversion between the two datastore schemas. But you also
    need a unique ID for each employee. As of right now, there is no unique ID to
    match to an AD object in each row of the CSV. You could have more than one Adam,
    more than one person in the IT department, or more than one person with the last
    name of Bertram, for example. This means you’ll have to generate your own unique
    ID. To make things easier, assume that no two employees have the same first and
    last name. Otherwise, the ID to create will probably be dependent on your own
    organizational schema. With that assumption, you can simply concatenate each datastore’s
    respective first- and last-name fields to create a temporary unique ID.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll represent this unique ID in another hashtable. You haven’t handled the
    concatenation just yet, but you’ve set up the infrastructure to do so:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now that you created a way to map different fields together, you can incorporate
    that code into a couple of functions to “force” two datastores to return the same
    properties, allowing an apples-to-apples comparison.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Creating Functions to Return Similar Properties
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you have the hashtables, you need to translate field names and build
    unique IDs. You can create a function that’ll query our CSV file and output both
    attributes that AD understands, and a property you can use to match both datastores.
    To do that, you’ll create a function called `Get-Acme``EmployeeFromCsv` that looks
    like [Listing 11-8](ch11.xhtml#ch11list8). I’ve assigned the `CsvFilePath` parameter’s
    value to *C:\Employees.csv*, assuming that our CSV is located there:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了哈希表，接下来需要翻译字段名称并构建唯一 ID。你可以创建一个函数来查询我们的 CSV 文件，并输出 AD 理解的属性，以及你可以用来匹配两个数据存储的属性。为此，你将创建一个名为
    `Get-AcmeEmployeeFromCsv` 的函数，代码见[列表 11-8](ch11.xhtml#ch11list8)。我将 `CsvFilePath`
    参数的值设置为 *C:\Employees.csv*，假设我们的 CSV 文件位于该位置：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 11-8: The `Get-AcmeEmployeeFromCsv` function*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-8：`Get-AcmeEmployeeFromCsv` 函数*'
- en: 'This function works in three broad steps: first, map the properties of the
    CSV to AD properties ❶; next, create a unique ID and make that a property ❷; last,
    read in the CSV and use `Select-Object` and a calculated property to return the
    properties you need ❸.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的工作流程分为三个主要步骤：首先，将 CSV 的属性映射到 AD 属性 ❶；接着，创建一个唯一 ID 并将其作为属性 ❷；最后，读取 CSV，并使用
    `Select-Object` 和计算属性返回你需要的属性 ❸。
- en: 'As you can see in the following code, you can pass the `$syncFieldMap` hashtable
    and the `$fieldMatchIds` hashtable to your new `Get-AcmeEmployeeFromCsv` function,
    which you can use to return property names that’ll sync up with the Active Directory
    attributes as well as with your new unique ID:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如下代码所示，你可以将 `$syncFieldMap` 哈希表和 `$fieldMatchIds` 哈希表传递给你新的 `Get-AcmeEmployeeFromCsv`
    函数，你可以用它来返回与 Active Directory 属性以及你新创建的唯一 ID 同步的属性名称：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now you have to build a function that will query from AD. Thankfully, this time
    around you don’t have to convert any property names because the AD property names
    are your common set. All you’ll be doing in this function is calling `Get-ADUser`,
    and making sure you return the properties you need, as shown in [Listing 11-9](ch11.xhtml#ch11list9).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要构建一个从 AD 查询的函数。幸运的是，这一次你不需要转换任何属性名称，因为 AD 的属性名称就是你的公共集合。在这个函数中，你只需要调用
    `Get-ADUser`，并确保返回你需要的属性，代码见[列表 11-9](ch11.xhtml#ch11list9)。
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 11-9: The `Get-AcmeEmployeeFromAD` function*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-9：`Get-AcmeEmployeeFromAD` 函数*'
- en: 'Again, I’ll highlight the broad strokes of this code: first, create the unique
    ID to perform the matches on ❶; then, query the AD users and return only the values
    in the field map hashtable, also returning the unique ID that you created earlier
    ❷.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我将重点介绍这段代码的主要步骤：首先，创建唯一 ID 来执行匹配 ❶；然后，查询 AD 用户并仅返回字段映射哈希表中的值，同时返回你之前创建的唯一
    ID ❷。
- en: When you run this, you’ll see that it returns the AD user accounts with the
    appropriate properties and your unique ID property.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你会看到它返回具有适当属性和唯一 ID 属性的 AD 用户帐户。
- en: Finding Matches in Active Directory
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Active Directory 中查找匹配项
- en: You now have two similar functions that pull information from your datastores
    and return the same property names. The next move is to find all the matches between
    our CSV and AD. To make this easier, you’ll use the code in [Listing 11-10](ch11.xhtml#ch11list10)
    to create another function called `Find-UserMatch` that’ll execute both of these
    functions and gather both sets of data. Once it has the data, it will look for
    a match on the `UniqueID` field.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了两个类似的函数，可以从数据存储中提取信息，并返回相同的属性名称。接下来的步骤是查找 CSV 和 AD 之间的所有匹配项。为了简化这个过程，你将使用[列表
    11-10](ch11.xhtml#ch11list10)中的代码，创建另一个名为 `Find-UserMatch` 的函数，该函数将执行这两个函数，并收集这两个数据集。一旦获取了数据，它将查找
    `UniqueID` 字段上的匹配项。
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 11-10: Finding user matches*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-10：查找用户匹配项*'
- en: Let’s walk through this code. First, get a list of users from AD ❶; then, get
    a list of users from our CSV ❷. For each user from AD, check whether the `UniqueID`
    property was populated ❸. If it was, check whether a match was found between the
    CSV and AD users ❹, and if so, in our custom object, create a property called
    `CSVProperties` that contains all the properties associated with the matched user
    ❺.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析这段代码。首先，从 AD 获取用户列表 ❶；然后，从我们的 CSV 获取用户列表 ❷。对于每个来自 AD 的用户，检查 `UniqueID`
    属性是否已被填充 ❸。如果已填充，检查 CSV 和 AD 用户之间是否找到了匹配 ❹，如果找到了，在我们的自定义对象中创建一个名为 `CSVProperties`
    的属性，包含与匹配用户相关的所有属性 ❺。
- en: If a match is found, the function will return the AD user’s `samAccountName`
    and all of its CSV properties; otherwise, it will return `NoMatch`. Returning
    the `samAccountName` gives you a unique ID in AD, which allows you to look up
    this user later.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: At this point, you have a function that allows you to find 1:1 matches between
    your AD data and your CSV data. You’re now ready to begin the gratifying (yet
    scary) work of making bulk changes to AD!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Changing Active Directory Attributes
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you have a way to find out which CSV row pertains to which AD user account.
    You can use the `Find-UserMatch` function to find the AD user by their unique
    ID, and then update its AD information to match the data in the CSV, as shown
    in [Listing 11-11](ch11.xhtml#ch11list11).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 11-11: Syncing CSV to AD attributes*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Quite a bit of work goes into creating a robust and flexible AD syncing script.
    Along the way, you’ll encounter tons of little details and hiccups, especially
    when you’re building even more complicated scripts.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: We’ve only scratched the surface of syncing with PowerShell. If you want to
    see just how much you can do with this concept, check out the `PSADSync` module
    in the PowerShell Gallery (`Find-Module PSADSync`). This module was built specifically
    for the task we had here, but handles considerably more complex cases. If you
    felt a little lost during this exercise, I highly encourage you to go over the
    code again—as many times as it takes. The only true way to learn PowerShell is
    to experiment! Run the code, see it break, fix it yourself, and try again.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you familiarized yourself with the `ActiveDirectory` PowerShell
    module. You learned how to create and update users, computers, and groups in AD.
    Through a couple of real-world examples, you saw how to use PowerShell to automate
    tedious Active Directory work.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: In the next two chapters, we’re going to the cloud! We’ll continue our journey
    of automating all the things and look at automating some common tasks done both
    in Microsoft Azure and in Amazon Web Services (AWS).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
