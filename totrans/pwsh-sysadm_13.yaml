- en: '11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AUTOMATING ACTIVE DIRECTORY
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One of the best products to automate with PowerShell is Microsoft’s Active Directory
    (AD). Employees are constantly entering, leaving, and moving around an organization.
    A dynamic system is needed to keep track of the ever-shifting flux of employees,
    and that’s where AD comes in. IT pros perform repetitive and similar tasks in
    AD, making it a perfect site for automation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll walk through using PowerShell to automate a few scenarios
    involving AD. Although numerous AD objects can be manipulated with PowerShell,
    we’ll cover only three of the most common: user accounts, computer accounts, and
    groups. These types of objects are the ones an AD administrator will most likely
    encounter on a day-to-day basis.'
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you follow along with the examples in this chapter, I make a few assumptions
    about your computer environment.
  prefs: []
  type: TYPE_NORMAL
- en: The first is that you’re working on a Windows computer that’s already a member
    of an Active Directory domain. There are ways to work with AD from a workgroup
    computer using alternate credentials, but that’s beyond the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The second is that you’ll be working with the same domain that your computer
    is a member of. Complicated cross-domain and forest trust issues are also beyond
    the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The last is that you are logged into your computer with an AD account that has
    appropriate permissions to read, modify, and create common AD objects such as
    users, computers, groups, and organizational units. I am doing these exercises
    from a computer with an account that is part of the Domain Admins group—meaning
    I have control over everything in my domain. Although this is not completely necessary,
    and generally not recommended in a production environment, this allows me to demonstrate
    various topics without being concerned with object rights, which are beyond the
    scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the ActiveDirectory PowerShell Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you know by now, there’s more than one way to accomplish a task with PowerShell.
    Likewise, there’s not much use in reinventing the wheel when you can use the preexisting
    tools to make bigger and better ones. In this chapter, you’ll use only a single
    module: `ActiveDirectory`. Although it’s not without its shortcomings—obscure
    parameters, odd filtering syntax, strange error behavior—it’s by far the most
    comprehensive module for managing AD.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ActiveDirectory` module comes with the *Remote Server Administration Tools*
    software package. This is a software bundle of many tools and, unfortunately,
    at the time of this writing, the only way to get a copy of the `ActiveDirectory`
    module. Before you continue with this chapter, I encourage you to download and
    install this package. Once you do, you’ll have the `ActiveDirectory` module installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm you have `ActiveDirectory` installed, you can use the `Get-Module`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you see this output, `ActiveDirectory` is installed.
  prefs: []
  type: TYPE_NORMAL
- en: Querying and Filtering AD Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve ensured that you’ve met all of the prerequisites and have the `ActiveDirectory`
    module installed, you’re ready to get started.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best ways to get acclimated to a new PowerShell module is to look
    for all its `Get` verb commands. Commands that begin with *Get* only read information,
    so the risk that you’ll change something by accident is minimal. Let’s take this
    approach with the `ActiveDirectory` module and look for commands associated with
    the objects we’ll be working with in this chapter. [Listing 11-1](ch11.xhtml#ch11list1)
    shows how to retrieve only the `ActiveDirectory` commands that begin with *Get*
    and have the word *computer* somewhere in the verb portion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-1: `ActiveDirectory` module `Get` commands*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see a few commands that look interesting. In this chapter, you’ll be
    using `Get-ADComputer`, `Get-ADUser`, `Get-ADGroupm`, and `Get-ADGroupMember`.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many of the `Get` AD commands you’ll be using have a common parameter called
    `Filter`. `Filter` is similar to the PowerShell `Where-Object` command as it filters
    what each command returns, but is different in the way it accomplishes this task.
  prefs: []
  type: TYPE_NORMAL
- en: The `Filter` parameter uses its own syntax and can be difficult to understand,
    especially when you’re using complex filters. For a full breakdown of the `Filter`
    parameter’s syntax, you can run `Get-Help` `about`_`ActiveDirectory_Filter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this chapter, we’ll keep it simple and avoid any advanced filtering. First,
    let’s use the `Filter` parameter and the `Get-ADUser` command to return all users
    in the domain, as shown in [Listing 11-2](ch11.xhtml#ch11list2). Be careful, though:
    if you have a lot of user accounts in your domain, you could be waiting a while.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-2: Finding all user accounts in a domain*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `Filter` parameter accepts a string value wildcard character,
    `*`. On its own, this character tells (most) `Get` commands to return everything
    they find. Although this can be occasionally useful, most of the time you don’t
    want *all* possible objects. However, used correctly, the wildcard character is
    a powerful tool.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say you want to find all computer accounts in AD that start with the letter
    *C*. You can do so by running `Get-ADComputer -Filter 'Name -like "C*"'`, where
    `C*` represents all characters after a *C*. You could also do it in reverse; say
    you want to find anyone with a last name that ends in *son*. You could run the
    command `Get-ADComputer -Filter 'Name -like "*son"'`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to find all users that have a last name of *Jones*, you could run
    `Get-ADUser -Filter "surName -eq 'Jones'"`; if you want a single user using the
    first and last name, you could run `Get-ADUser -Filter "surName -eq 'Jones' -and
    givenName -eq 'Joe'`. The `Filter` parameter allows you to use various PowerShell
    operators such as `like` and `eq` to build a filter that returns only the results
    you’re looking for. Active Directory attributes are stored in the AD database
    using lower camel case, so that’s what I’ve used in the filters, although this
    isn’t technically necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Another command useful for filtering AD objects is the `Search-ADAccount` command.
    This command has built-in support for common filtering scenarios such as finding
    all users with an expired password, finding locked-out users, and finding computers
    that are enabled. Check out the help for the `Search-ADAccount` cmdlet to see
    the full range of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, the `Search-ADAccount` syntax is self-explanatory. Various
    switch parameters, including `PasswordNeverExpires`, `AccountDisabled`, and `AccountExpired`,
    do not require other parameters to function.
  prefs: []
  type: TYPE_NORMAL
- en: Besides these fancy parameters, `Search-ADAccount` also has various parameters
    that require additional input—for example, to indicate how old a datetime attribute
    is or if you need to limit the results by a particular object type (for example,
    Users or Computers).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the `AccountInactive` parameter as an example. Say you want to find
    all users who haven’t used their account in 90 days. This is a great query for
    `Search-ADAccount`. By using the syntax in [Listing 11-3](ch11.xhtml#ch11list3),
    using `–``UsersOnly` to filter the type of object and `–``TimeSpan` to filter
    for objects that have not been active in the last 90 days, you can quickly find
    all the requested users.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-3: Using `Search-ADAccount`*'
  prefs: []
  type: TYPE_NORMAL
- en: The `Search-ADAccount` cmdlet returns an object type of `Microsoft.ActiveDirectory.Management.ADUser`.
    This is the same object type that commands such as `Get-ADUser` and `Get-ADComputer`
    return. `Search-ADAccount` can be a good shortcut when you’re using a `Get` command
    and feel stuck trying to figure out what syntax to use for the `Filter` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Returning Single Objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes you know the exact AD object you’re looking for, so there’s no need
    to use `Filter` at all. Here, you can use the `Identity` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '`Identity` is a flexible parameter that allows you to specify attributes that
    make an AD object unique; thus it returns only a single object. Every user account
    has a unique attribute called `samAccountName`. You could use the `Filter` parameter
    to find all users with a specific `samAccountName`, which would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'But it’s much cleaner to use the `Identity` parameter instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Project 4: Finding User Accounts That Haven’t Changed Their Password in 30
    Days'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you have a basic understanding of how to query AD objects, let’s create
    a small script and put that knowledge to use. Here’s the scenario: you work at
    a company that’s about to implement a new password-expiration policy and your
    job is to find all the accounts that haven’t changed their password in the past
    30 days.'
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s think about what command to use. Your first choice might be the
    `Search-ADAccount` command you learned earlier in this chapter. `Search-ADAccount`
    has many uses for searching and filtering on various objects, but you can’t craft
    custom filters. To get more granular in your searching, you’ll have to build your
    own filters by using the `Get-ADUser` command.
  prefs: []
  type: TYPE_NORMAL
- en: Once you know what command you’re going to use, the next step is to figure out
    what you want to filter for. You know you want to filter for accounts that haven’t
    changed their password in the past 30 days, but if you look only for that, you’ll
    find more accounts than you need. Why? If you don’t filter for accounts that are
    `Enabled`, you’ll probably get old accounts that don’t matter anymore (maybe someone
    who left the company or lost computer privileges). So you look for enabled computers
    that haven’t changed their password in the past 30 days.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with filtering enabled user accounts. You can do this by using `–Filter
    "Enabled -eq 'True'"`. Simple enough. The next step is to figure out how to access
    the attribute that is stored when a user’s password is set.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `Get-ADUser` doesn’t return all of a user’s properties. Using the
    `Properties` parameter, you can specify which properties you’d like to see; here,
    you’ll use `name` and `passwordlastset`. Notice that some users don’t have a `password``lastset`
    property. This is because they’ve never set their own password.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have the attribute name, you need to build a filter for it. Remember
    that you want only accounts whose passwords changed in the past 30 days. To find
    a date difference, you need two dates: the oldest possible date (30 days ago)
    and the newest possible date (today). You can get today’s date easily by using
    the `Get-Date` command. And you can use the `AddDays` method to figure out what
    the date was 30 days ago. You’ll store both in variables for easy access later.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have the dates, you can use them in the filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: All that’s left to do is to add your `Enabled` condition to the filter. [Listing
    11-4](ch11.xhtml#ch11list4) shows the steps to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-4: Finding enabled user accounts that haven’t changed their password
    in 30 days*'
  prefs: []
  type: TYPE_NORMAL
- en: You now have some code built up to find all enabled Active Directory users that
    have set their password in the last 30 days.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Changing AD Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you know how to find existing AD objects, let’s learn how to change
    and create them. This section is divided into two parts: one dealing with users
    and computers, and one dealing with groups.'
  prefs: []
  type: TYPE_NORMAL
- en: Users and Computers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To change users and computer accounts, you’ll use a `Set` command: either `Set-ADUser`
    or `Set-ADComputer`. These commands can change any attribute of an object. Usually,
    you’ll want to pipe in an object you get from a `Get` command (like those covered
    in the previous lesson).'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, say that an employee named Jane Jones got married, and you’re
    asked to change the last name of her user account. If you didn’t know an identity
    attribute for this user account, you could use the `Filter` parameter on `Get-ADUser`
    to find it. But first, you’d need to discover how AD stores each user’s first
    and last name. You can then use the values of those attributes to pass to the
    `Filter` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to find all available attributes stored in AD is with a little .NET.
    Using a schema object, you can find the user class and enumerate all of its attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By reviewing the available attribute list, you then find the `givenName` and
    `surName` attribute to use in the `Filter` parameter with the `Get-ADUser` command,
    finding the user account. Next, you can pass that object to `Set-ADUser`, as shown
    in [Listing 11-5](ch11.xhtml#ch11list5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-5: Changing AD object attributes with `Set-ADUser`*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also change multiple attributes at once. It turns out Jane also moved
    departments and got a promotion, both of which need to be updated. Not a problem.
    You just need to use the parameters that match up to the AD attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you can create AD objects by using `New-AD*` commands. Creating new
    AD objects is similar to changing existing objects, but here you don’t have access
    to an `Identity` parameter. Creating a new AD computer account is as easy as running
    `New-ADComputer -Name FOO`; likewise, an AD user can be created by using `New-ADUser
    -Name adam`. You’ll see that the `New-AD*` commands also have parameters that
    correlate to AD attributes, just like the `Set-AD*` commands do.
  prefs: []
  type: TYPE_NORMAL
- en: Groups
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Groups* are trickier than users and computers. One way to think about groups
    is as a container for many AD objects. In that sense, a group is a bunch of things.
    But at the same time, it’s still a *single* container, meaning that just like
    users and computers, a group is a singular AD object. That means you can query,
    create, and change groups the same way you would users and computers, with a few
    slight differences.'
  prefs: []
  type: TYPE_NORMAL
- en: Maybe your organization created a new department called AdamBertramLovers, and
    it’s bursting at the seams with new employees. Now you need to create a group
    with this name. [Listing 11-6](ch11.xhtml#ch11list6) shows an example of how to
    create such a group. You use the `Description` parameter to pass in a string (the
    group’s description), and the `GroupScope` parameter to ensure that the group
    created has a scope of `DomainLocal`. You could have chosen `Global` or `Universal`
    here as well if that’s what you required.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-6: Creating an AD group*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the group exists, you can modify it just as you would a user or computer.
    To change the description, for example, you could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the key difference between groups and users/computers is that a group
    can contain users and computers. When a computer or user account is contained
    within a group, we say that is a *member* of that group. But to add and change
    members of a group, you can’t use the commands you’ve been using. Instead, you
    need to use `Add-ADGroupMember` and `Remove-ADGroupMember`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to add Jane to our group, you can do so using `Add-ADGroupMember`.
    If Jane wants to leave the group, you can remove her by using `Remove-ADGroupMember`.
    As you try this, you’ll find that running the `Remove-ADGroupMember` command will
    lead to a prompt asking you to confirm your decision to remove the member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Add the `Force` parameter if you want to skip this check, but be aware that
    getting that confirmation may end up saving you one day!
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 5: Creating an Employee Provisioning Script'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s bring this all together and tackle another real-world scenario. Your
    company has hired a new employee. You, the system administrator, now have to perform
    a series of actions: creating an AD user, creating their computer account, and
    adding them to specific groups. You’ll build a script that will automate this
    whole process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But before you start this project—and really, any project—it’s important to
    figure out what the script will do and write down an informal definition. For
    this script, you need to create the AD user, which will:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically create a username for user based on the first name and last name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and assign the user a random password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Force the user to change their password at logon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the department attribute based on the department given
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign the user an internal employee number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, add the user account to a group with the same name as the department.
    Finally, add the user account into an organizational unit with the same name as
    the department the employee is in.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with these requirements laid out, let’s build the script. The finished
    script will be called *New-Employee.ps1* and is available in the book’s resources.
  prefs: []
  type: TYPE_NORMAL
- en: You want this to be a reusable script. Ideally, anytime you have a new employee,
    you can use the script. This means you need to figure out a smart way to handle
    the inputs to the script. By looking at the requirements, you know you’ll need
    a first name, a last name, a department, and an employee number. [Listing 11-7](ch11.xhtml#ch11list7)
    provides a script outline with all parameters defined and a `try/catch` block
    to catch any terminating errors you may encounter. The `#requires` statement is
    set at the top to ensure that whenever this script is run, it checks to see that
    the machine has the `ActiveDirectory` module installed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-7: Base* New-Employee.ps1 *script*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you created the base, let’s fill out the `try` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to create an AD user according to the requirements laid out
    in our informal definition. You have to *dynamically create* a username. There
    are several ways to do this: some organizations prefer the username to be the
    first initial and the last name, some prefer first name and last name, and some
    do something else entirely. Let’s say your company uses first initial and last
    name. If that username is taken, the next character in the first name is added
    until a unique username is found.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s handle the base case first. You’ll use the built-in `Substring` method
    on every string object to get the first initial. You’ll then concatenate the last
    name to the first initial. You’ll do this by using *string formatting*, which
    allows you to define placeholders for multiple expressions in a string and replace
    the placeholders with values at runtime, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After you create the initial username, you need to query AD to see whether this
    username is already taken by using `Get-ADUser`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If this command returns anything, the username is taken, and you need to try
    the next username. This means you need to figure out a way to dynamically generate
    new names, always being prepared for the possibility that the new username is
    taken. A good way to check for various usernames is a `while` loop conditioned
    on your previous call to `Get-ADUser`. But you’ll need another condition to account
    for what happens if you run out of letters in the first name. You don’t want the
    loop to run forever, so you’ll put in another condition, `$userName –notlike "$FirstName*"`,
    to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `while` condition looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `while` condition created, you can fill out the rest of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For each iteration of the loop, you add an additional character from the first
    name to the proposed username by taking the substring of the first name from 0
    to `i`, where `$i` is a counter variable that starts at 2 (the next position in
    the string) and is increased each time the loop runs. By the time this `while`
    loop finishes, it will have either found a unique username or exhausted all options.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an existing username *isn’t* found, you’re clear to create the username
    you intended to. If a username *is* found, you have a few other things to check.
    You need to check whether the *organizational unit* *(OU)* and group you’re putting
    the user account into exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you complete all the checks, you need to create the user account. Again,
    you have to consult our informal definition: *create and assign the user a* *random
    password*. You want to generate a random password every time this script runs.
    An easy way to generate a secure password is to use the `GeneratePassword` static
    method on the `System.Web.Security.Membership` object, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: I chose to generate a password of at least 20 characters, with a maximum of
    32, but this is completely configurable. If desired, you could also find AD’s
    minimum required password by running `Get-ADDefaultDomainPasswordPolicy | Select-object
    -expand minPasswordLength`. This method even allows you to specify the length
    and complexity of the new password.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the password as a secure string, you have all the parameter
    values needed to create the user according to the requirements I laid out earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After you make the user, all that’s left is to add them to the department group,
    which you can do with a simple `Add-ADGroupMember` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to check out the *New-Employee.ps1* script in the book’s resources to
    get a copy of the full implementation of this script.
  prefs: []
  type: TYPE_NORMAL
- en: Syncing from Other Data Sources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Active Directory, especially when used in large enterprises, can contain millions
    of objects being created and modified by dozens of people every day. With all
    that activity and all those inputs, problems are bound to arise. One of the biggest
    you’ll run into is keeping the AD database synced up with the rest of the organization.
  prefs: []
  type: TYPE_NORMAL
- en: A company’s AD should be organized the same way the company is organized. This
    might mean that every department has its own associated AD group, every physical
    office its own OU, and so on. Regardless, as system administrators, we have the
    difficult task of ensuring that AD is always in sync with the rest of the organization.
    This is a great task for PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Using PowerShell, you can “link” AD with just about any other source of information,
    meaning you can have PowerShell continually reading external data sources and
    making the appropriate changes to AD as necessary to create a sync process.
  prefs: []
  type: TYPE_NORMAL
- en: 'This syncing process, when triggered, roughly consists of the following six
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Query the external data source (SQL database, CSV file, and so forth).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve objects from AD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find each object in the source that AD has a unique attribute to match on. This
    is usually referred to as an *ID*. The ID can be an employee ID or even usernames.
    The only thing that matters is that the attribute is unique. If no match is found,
    optionally create or remove the object from AD based on the source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find a single matching object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map all external data sources to AD object attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify existing AD objects or create new ones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll put this plan into action in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 6: Creating a Syncing Script'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to build a script that’ll sync employees from
    a CSV file to AD. To do so, you’ll have to draw on some of the commands you learned
    in [Chapter 10](ch10.xhtml#ch10), as well as those you just learned in the previous
    lessons of this chapter. Before we get started, I encourage you to glance at *Employees.csv*
    and *Invoke-AdCsvSync.ps1* in the book’s resources and familiarize yourself with
    the project files.
  prefs: []
  type: TYPE_NORMAL
- en: The key to building a great AD sync tool is sameness. By this, I don’t mean
    the data sources should be the same—since, technically, they never will be—but
    instead that you need to create a script that can query each datastore the same
    way and have each datastore return the same kind of object. The tricky part of
    this occurs when you have two sources that use different schemas. In that case,
    you may have to start doing some translation by mapping one field name to another
    (as you’ll do later in the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this: you already know that AD has common attributes associated with
    each user account—things like first name, last name, and department, which we’ll
    call a *schema* of attributes. However, chances are the source datastore you’d
    like to sync with will never have the exact same attributes. And even if it has
    the same attributes, it might know them by different names. To resolve this issue,
    you have to build a mapping between the two datastores.'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Data Source Attributes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An easy, effective way to create this mapping is to use a hashtable in which
    the key is the attribute name in the first datastore, and the value is the attribute
    name in the second datastore. To see this in action, let’s say you work at a company
    called Acme. Acme wants to sync employee records from a CSV file into AD. Specifically,
    they want to sync *Employees.csv*, which you can find in the book’s resources
    or here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that you know the headers of the CSV, and the property names in AD, you
    can build a mapping hashtable with the value for the CSV field as the key and
    the AD attribute name as the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will handle the conversion between the two datastore schemas. But you also
    need a unique ID for each employee. As of right now, there is no unique ID to
    match to an AD object in each row of the CSV. You could have more than one Adam,
    more than one person in the IT department, or more than one person with the last
    name of Bertram, for example. This means you’ll have to generate your own unique
    ID. To make things easier, assume that no two employees have the same first and
    last name. Otherwise, the ID to create will probably be dependent on your own
    organizational schema. With that assumption, you can simply concatenate each datastore’s
    respective first- and last-name fields to create a temporary unique ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll represent this unique ID in another hashtable. You haven’t handled the
    concatenation just yet, but you’ve set up the infrastructure to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now that you created a way to map different fields together, you can incorporate
    that code into a couple of functions to “force” two datastores to return the same
    properties, allowing an apples-to-apples comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Functions to Return Similar Properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you have the hashtables, you need to translate field names and build
    unique IDs. You can create a function that’ll query our CSV file and output both
    attributes that AD understands, and a property you can use to match both datastores.
    To do that, you’ll create a function called `Get-Acme``EmployeeFromCsv` that looks
    like [Listing 11-8](ch11.xhtml#ch11list8). I’ve assigned the `CsvFilePath` parameter’s
    value to *C:\Employees.csv*, assuming that our CSV is located there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-8: The `Get-AcmeEmployeeFromCsv` function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function works in three broad steps: first, map the properties of the
    CSV to AD properties ❶; next, create a unique ID and make that a property ❷; last,
    read in the CSV and use `Select-Object` and a calculated property to return the
    properties you need ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following code, you can pass the `$syncFieldMap` hashtable
    and the `$fieldMatchIds` hashtable to your new `Get-AcmeEmployeeFromCsv` function,
    which you can use to return property names that’ll sync up with the Active Directory
    attributes as well as with your new unique ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now you have to build a function that will query from AD. Thankfully, this time
    around you don’t have to convert any property names because the AD property names
    are your common set. All you’ll be doing in this function is calling `Get-ADUser`,
    and making sure you return the properties you need, as shown in [Listing 11-9](ch11.xhtml#ch11list9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-9: The `Get-AcmeEmployeeFromAD` function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, I’ll highlight the broad strokes of this code: first, create the unique
    ID to perform the matches on ❶; then, query the AD users and return only the values
    in the field map hashtable, also returning the unique ID that you created earlier
    ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: When you run this, you’ll see that it returns the AD user accounts with the
    appropriate properties and your unique ID property.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Matches in Active Directory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You now have two similar functions that pull information from your datastores
    and return the same property names. The next move is to find all the matches between
    our CSV and AD. To make this easier, you’ll use the code in [Listing 11-10](ch11.xhtml#ch11list10)
    to create another function called `Find-UserMatch` that’ll execute both of these
    functions and gather both sets of data. Once it has the data, it will look for
    a match on the `UniqueID` field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-10: Finding user matches*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through this code. First, get a list of users from AD ❶; then, get
    a list of users from our CSV ❷. For each user from AD, check whether the `UniqueID`
    property was populated ❸. If it was, check whether a match was found between the
    CSV and AD users ❹, and if so, in our custom object, create a property called
    `CSVProperties` that contains all the properties associated with the matched user
    ❺.
  prefs: []
  type: TYPE_NORMAL
- en: If a match is found, the function will return the AD user’s `samAccountName`
    and all of its CSV properties; otherwise, it will return `NoMatch`. Returning
    the `samAccountName` gives you a unique ID in AD, which allows you to look up
    this user later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you have a function that allows you to find 1:1 matches between
    your AD data and your CSV data. You’re now ready to begin the gratifying (yet
    scary) work of making bulk changes to AD!
  prefs: []
  type: TYPE_NORMAL
- en: Changing Active Directory Attributes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you have a way to find out which CSV row pertains to which AD user account.
    You can use the `Find-UserMatch` function to find the AD user by their unique
    ID, and then update its AD information to match the data in the CSV, as shown
    in [Listing 11-11](ch11.xhtml#ch11list11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-11: Syncing CSV to AD attributes*'
  prefs: []
  type: TYPE_NORMAL
- en: Quite a bit of work goes into creating a robust and flexible AD syncing script.
    Along the way, you’ll encounter tons of little details and hiccups, especially
    when you’re building even more complicated scripts.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve only scratched the surface of syncing with PowerShell. If you want to
    see just how much you can do with this concept, check out the `PSADSync` module
    in the PowerShell Gallery (`Find-Module PSADSync`). This module was built specifically
    for the task we had here, but handles considerably more complex cases. If you
    felt a little lost during this exercise, I highly encourage you to go over the
    code again—as many times as it takes. The only true way to learn PowerShell is
    to experiment! Run the code, see it break, fix it yourself, and try again.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you familiarized yourself with the `ActiveDirectory` PowerShell
    module. You learned how to create and update users, computers, and groups in AD.
    Through a couple of real-world examples, you saw how to use PowerShell to automate
    tedious Active Directory work.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two chapters, we’re going to the cloud! We’ll continue our journey
    of automating all the things and look at automating some common tasks done both
    in Microsoft Azure and in Amazon Web Services (AWS).
  prefs: []
  type: TYPE_NORMAL
