<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_197"/><strong><span class="big">10</span><br/>GRAPHS</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindent">Visually representing data with graphs, as we did in the previous chapter (see <a href="ch09.xhtml#fig9_1">Figure 9-1</a>), provides a concise and clear mechanism to demonstrate the many connections between the nodes within a graph as well as helps us recognize patterns that might otherwise be difficult to discover when operating on a graph as an abstract data type. Ghidra’s graph views offer a new perspective (in addition to disassembly and decompiler listings) for viewing the contents of a binary. They let you quickly see the control flow in a function and the relationships between functions in a file, by representing functions and other types of blocks as nodes and by representing flows and cross-references as edges (the lines that connect nodes). With enough practice, you may find that common control structures, such as switch statements and nested <code>if</code>/<code>else</code> structures, are easier to recognize in graph form than in a long text listing. In <a href="ch05.xhtml#ch05">Chapter 5</a>, we briefly introduced the Function Graph and Function Call Graph windows. In this chapter, we take a deeper dive into Ghidra’s graph capabilities.</p>
<span epub:type="pagebreak" id="page_198"/>
<p class="indent">Because cross-references relate one address to another, they are a natural place to begin graphing our binaries. By restricting ourselves to sequential flows and specific types of cross-references, we can derive a number of useful graphs for analyzing our binaries. While the flows and cross-references serve as the edges in our graphs, the meaning behind nodes can vary. Depending on the type of graph we wish to generate, nodes may contain one or more instructions, or entire functions. Let’s start our discussion about graphs by looking at the ways that Ghidra organizes code into <em>blocks</em> and then move on to the types of graphs available in Ghidra.</p>
<h3 class="h3" id="ch10lev182"><strong>Basic Blocks</strong></h3>
<p class="noindent">In a computer program, a <em>basic block</em> is a grouping of one or more instructions with a single entry at the beginning of the block and a single exit from the end of the block. Other than the last instruction, every instruction within a basic block transfers control to exactly one <em>successor</em> instruction within the block. Similarly, other than the first instruction, every instruction in a basic block receives control from exactly one <em>predecessor</em> instruction within the block. In “<a href="ch09.xhtml#ch09lev170">Cross-References (Back References)</a>” on <a href="ch09.xhtml#page_185">page 185</a>, we identified this as <em>sequential flow</em>. You may notice, from time to time, a function call being made in the middle of a basic block and think to yourself, “Isn’t this precisely the type of instruction, like a jump, that should terminate a block?” For the purposes of basic block determination, the fact that function calls transfer control outside the current block is generally ignored, unless it is known that the function being called does not return normally.</p>
<p class="indent">Once the first instruction in a basic block is executed, the remainder of the block is guaranteed to execute to completion. This can factor significantly into runtime instrumentation of a program, since it is no longer necessary to set a breakpoint on every instruction in a program or even single-step the program in order to record which instructions have executed. Instead, breakpoints can be set on the first instruction of each basic block, and as each breakpoint is hit, it can be assumed that every instruction in the associated block will be executed. Let’s shift our focus to Ghidra’s Function Graph capabilities to provide another perspective on blocks.</p>
<h3 class="h3" id="ch10lev183"><strong>Function Graphs</strong></h3>
<p class="noindent">The Function Graph window, introduced in <a href="ch05.xhtml#ch05">Chapter 5</a>, displays a single function in a graphical format. The following program comprises a single function that is composed of a single basic block, so it’s a useful starting point to demonstrate Ghidra’s function graphs:</p>
<pre>int global_array[3];<br/><br/>
int main() {<br/>
    int idx = 2;<br/>
    global_array[0] = 10;<br/>
    global_array[1] = 20;<br/>
<span epub:type="pagebreak" id="page_199"/>
    global_array[2] = 30;<br/>
    global_array[idx] = 40;<br/>
}</pre>
<p class="indent">When you open the Function Graph window (Window ▸ Function Graph) with <code>main</code> selected, you are presented with a function graph with only one basic block, as shown in <a href="ch10.xhtml#fig10_1">Figure 10-1</a>.</p>
<div class="image"><img src="Images/fig10-1.jpg" alt="image" width="694" height="932"/></div>
<p class="figcap" id="fig10_1"><em>Figure 10-1: A single-block Function Graph window with satellite view at lower right</em></p>
<span epub:type="pagebreak" id="page_200"/>
<p class="indent">The Function Graph window and the Listing window have a useful bi­directional link. If you view the windows side by side, the concurrent listing and graphical representation can help you better understand the function’s control flow. Changes you make in the Function Graph window (for example, renaming functions, variables, and so on) will be immediately reflected in the Listing window. Changes you make in the Listing window will also be reflected in the Function Graph window, although you may have to refresh the window to see the change.</p>
<div class="box5">
<p class="boxtitle-c"><strong>ARTICULATION</strong></p>
<p class="noindent">As your functions become more complex, the number of blocks in each will likely increase. When you first generate a function graph, the edges connecting the blocks are articulated. This means that they bend neatly at 90-degree angles so that they are not hidden behind nodes. This results in a neat grid layout where all components of all edges are either horizontal or vertical. If you decide to change the layout of the graph by dragging nodes around, the edges may lose their articulation and revert to straight lines that route behind other nodes in the graph. <a href="ch10.xhtml#fig10_2">Figure 10-2</a> demonstrates the contrast between the articulated representation on the left and the unarticulated version on the right. You can revert to the original layout at any time by refreshing the Function Graph window.</p>
<div class="image"><img src="Images/fig10-2.jpg" alt="image" width="616" height="369"/></div>
<p class="figcap" id="fig10_2"><em>Figure 10-2: Function graph with articulated and unarticulated edges</em></p>
</div>
<span epub:type="pagebreak" id="page_201"/>
<p class="indent">If you click any line of text in the Function Graph window, the cursor in the Listing window moves to the corresponding location in the disassembly listing. If you double-click data in a function graph, the Listing window will navigate to the associated data in the data section of the listing, while the Function Graph window retains focus on the function. (Although Ghidra does not currently provide graph-based visualization of data or relationships among data components, it does allow you to concurrently view the data in listing view and associated code in graph view.)</p>
<p class="indent">Let’s look at a quick example to demonstrate the relationship between the Listing window and the Function Graph window. Suppose you see the <code>global_array</code> variable in <a href="ch10.xhtml#fig10_1">Figure 10-1</a> and want to know more about its type. When you navigate to it by double-clicking the name in the graph view, you can see that Ghidra has classified <code>global_array</code> as an array of undefined bytes (<code>undefined1</code>), accessed with indices to the fourth and eighth elements. If you change the array definition in the data section of the Listing window from <code>undefined1[12]</code> to <code>int[3]</code> (respectively shown in the upper and lower halves of <a href="ch10.xhtml#fig10_3">Figure 10-3</a>), you can immediately see the effects of the declaration on the disassembly in the Function Graph window (as well as the Decompiler window): the index values change to <code>1</code> and <code>2</code> to reflect the new 4-byte size of each array element.</p>
<div class="image"><img src="Images/fig10-3.jpg" alt="image" width="694" height="305"/></div>
<p class="figcap" id="fig10_3"><em>Figure 10-3: Effect of modifying an array declaration on Function Graph and Listing windows</em></p>
<p class="indent">Navigating in the Listing window is flexible, provided you do not click a different function. You can scroll through the entire Listing window contents, click and make changes in the data section, make changes within the function, and so on. If you click within another function, the graph view will be updated to display the graph of the newly selected function.</p>
<span epub:type="pagebreak" id="page_202"/>
<div class="box5">
<p class="boxtitle-c"><strong>WHAT IS AN INTERACTION THRESHOLD?</strong></p>
<p class="noindent">When interacting with the Function Graph window, particularly with a complex function, you may zoom out because you cannot see everything you want to see. When the individual nodes become too small to interact with in a meaningful way, you have passed the <em>interaction threshold</em>. Drop shadows on each node in the Function Graph are used to indicate this condition. Virtual addresses may show only the least significant values, and the sheer number of nodes in the graph display can become unwieldy. An attempt to select content within a node ends up selecting the entire block. Don’t despair if the complexity of your function pushes you beyond this threshold. You can click any of the nodes to bring them into focus, or double-click a node to zoom in on it.</p>
</div>
<p class="indent"><a href="ch10.xhtml#fig10_4">Figure 10-4</a> highlights the menus and toolbars available in the Function Graph window.</p>
<div class="image"><img src="Images/fig10-4.jpg" alt="image" width="692" height="227"/></div>
<p class="figcap" id="fig10_4"><em>Figure 10-4: Function Graph toolbars</em></p>
<p class="indent">A function graph is really nothing more than a graphical presentation of the Listing window isolated to a single function, so it should not be surprising that all of the menus from the CodeBrowser (with the exception of the Window menu) are available <span class="ent">➊</span> in the Function Graph window. The available subset of the CodeBrowser toolbar <span class="ent">➋</span> includes the capability to save the current state of the open file, undo and redo, and navigate forward and backward within the current navigation chain. It is important to note that, since the windows are linked, this may navigate you out of (and back into) the current function, which will change the contents of the Function Graph window.</p>
<p class="indent">The Function Graph toolbar icons <span class="ent">➌</span> and their default behaviors are described in <a href="ch10.xhtml#fig10_5">Figure 10-5</a>.</p>
<span epub:type="pagebreak" id="page_203"/>
<div class="image"><img src="Images/fig10-5.jpg" alt="image" width="845" height="640"/></div>
<p class="figcap" id="fig10_5"><em>Figure 10-5: Function Graph toolbar operations</em></p>
<p class="indent">Each basic block also has a toolbar <span class="ent">➍</span> that lets you modify the block and group it with other blocks by combining several blocks (vertices) into a single block (see <a href="ch10.xhtml#fig10_6">Figure 10-6</a> for an explanation of the toolbar’s icons and their default behaviors). This feature is extremely useful for reducing the complexity of graphs that results from highly nested functions. For example, you might elect to collapse all of the blocks nested within a loop statement into a single graph node after you understand the behavior of the loop and feel less need to see the code within the loop. Depending on the number of nested blocks that you group, the readability of the graph may be enhanced significantly. To group nodes, you must select all nodes that will belong to the group by using <span class="smallcaps">CTRL-</span>click to select all member nodes, and then click the <strong>Combine vertices</strong> tool of the node you consider to lie at the root of the group. <em>Restore group</em> is a particularly helpful button that lets you quickly look inside a group and then re-collapse it.</p>
<span epub:type="pagebreak" id="page_204"/>
<div class="image"><img src="Images/fig10-6.jpg" alt="image" width="653" height="611"/></div>
<p class="figcap" id="fig10_6"><em>Figure 10-6: Function Graph basic block toolbar</em></p>
<p class="indent">To see some of the other features associated with a function graph, you will need to look at examples with more than one basic block. The following program is used in the examples that follow:</p>
<pre>int do_random() {<br/>
    int r;<br/>
    srand(time(0));<br/>
    r = rand();<br/>
    if (r % 2 == 0) {<br/>
       printf("The random value %d is even\n", r);<br/>
    }<br/>
    else {<br/>
       printf("The random value %d is odd\n", r);<br/>
    }<br/>
    return r;<br/>
}<br/>
int main() {<br/>
    do_random();<br/>
}</pre>
<span epub:type="pagebreak" id="page_205"/>
<p class="indent">The <code>do_random</code> function contains control structures (<code>if</code>/<code>else</code>) that result in a graph with four basic blocks, which we have labeled in <a href="ch10.xhtml#fig10_8">Figure 10-8</a>. Viewing a function with more than one block makes it more obvious that a function graph is a control flow graph, with edges indicating possible flows from one block to another. Note that Ghidra’s layout for function graphs is called <em>nested code layout</em> and closely resembles the flow of C code. This makes it easy to view a graphical representation of your Listing and Decompiler windows within the context of a larger program. To maintain this view, we highly recommend changing your graph options to route edges around vertices (Edit ▸ Tool Options ▸ Function Graph ▸ Nested Code Layout ▸ Route Edges Around Vertices). By default, Ghidra has the unfortunate tendency to route edges behind nodes, which can often paint a misleading picture of the relationships between nodes.</p>
<div class="box5">
<p class="boxtitle-c"><strong>THIS GRAPH IS STALE</strong></p>
<p class="noindent">While some changes in the listing are immediately reflected in the Function Graph window, in other cases the graph can become stale (not synchronized with the listing view). When this happens, Ghidra displays the message shown in <a href="ch10.xhtml#fig10_7">Figure 10-7</a> at the bottom of the graph window.</p>
<div class="image"><img src="Images/fig10-7.jpg" alt="image" width="249" height="62"/></div>
<p class="figcap" id="fig10_7"><em>Figure 10-7: Stale graph warning message</em></p>
<p class="indent">The <em>recycle</em> icon to the left of the message allows you to refresh the graph without reverting to the original layout. (Of course, you can also choose to refresh and lay out again.)</p>
</div>
<p class="indent">In the graph shown in <a href="ch10.xhtml#fig10_8">Figure 10-8</a>, BLOCK-1 is the single point of entry into the function. This block, like all basic blocks, exhibits sequential flow from instruction to instruction within the block. None of the three function calls within the block (to <code>time</code>, <code>srand</code>, and <code>rand</code>) “break” the basic block, since Ghidra assumes that all of them return to continue sequential execution of the remaining instructions. BLOCK-2 is entered if the <code>JNZ</code> condition at the end of BLOCK-1 evaluates to false, meaning that the random value is even. BLOCK-3 is entered if the <code>JNZ</code> condition evaluates to true, indicating that the random value is odd. The final block, BLOCK-4, is entered follow­ing the completion of BLOCK-2 or BLOCK-3. Note that clicking an edge brings it into focus and causes it to appear thicker than the rest of the edges. In the figure, the edge that connects BLOCK-1 and BLOCK-3 is the active edge and appears bolded.</p>
<span epub:type="pagebreak" id="page_206"/>
<div class="image"><img src="Images/fig10-8.jpg" alt="image" width="845" height="795"/></div>
<p class="figcap" id="fig10_8"><em>Figure 10-8: Function graph with dark line selected to show flow when condition is met</em></p>
<p class="indent">If you have a particularly long basic block and wish to break it into smaller blocks or wish to visually isolate a section of code for further analysis, you can split a basic block within a function graph by introducing new labels into the block. Using the hotkey L to insert a new label at line <code>0010072e</code> in BLOCK-1 before the call to <code>srand</code> results in the addition of a fifth block to the function graph in <a href="ch10.xhtml#fig10_9">Figure 10-9</a>. The new edge that is introduced represents flow and is not associated with a cross-reference.</p>
<span epub:type="pagebreak" id="page_207"/>
<div class="image"><img src="Images/fig10-9.jpg" alt="image" width="601" height="669"/></div>
<p class="figcap" id="fig10_9"><em>Figure 10-9: Function graph with new label introducing new basic block</em></p>
<div class="box5">
<p class="boxtitle-c"><strong>INTERACTING WITH FUNCTION GRAPHS</strong></p>
<p class="noindent">While it isn’t easy to show in a book, the Function Graph window includes color, animation, and informational pop-ups as you interact with the various components in the graph:</p>
<p class="listhead"><strong>Edges</strong></p>
<p class="uln-indent">The edges are colored based on the nature of the transition represented by the edge. You can control the colors through the Edit ▸ Tool Options window, as shown in <a href="ch10.xhtml#fig10_10">Figure 10-10</a>. By default, a green edge indicates a conditional jump when the condition is true (jump taken), a red edge indicates a fallthrough (jump not taken), and a blue edge indicates an unconditional jump. Clicking an individual edge or set of edges increases the thickness of the edge and changes to a highlighted shade of the same color.</p>
<span epub:type="pagebreak" id="page_208"/>
<div class="image"><img src="Images/fig10-10.jpg" alt="image" width="615" height="351"/></div>
<p class="figcap" id="fig10_10"><em>Figure 10-10: Function Graph color customization options</em></p>
<p class="listhead"><strong>Nodes</strong></p>
<p class="uln-indent">The content of each node is a disassembly listing of the corresponding basic block. The way you interact with the listing code is identical to the way you interact with code in the Listing window. For example, hovering over names opens a pop-up that displays disassembly at the named location. When you hover over a node, Ghidra utilizes a path-highlighting animation on associated edges to indicate the control flow direction consistent with the currently selected path highlight options. This functionality can be disabled in Edit ▸ Tool Options.</p>
<p class="listhead"><strong>Satellite</strong></p>
<p class="uln-indent">The satellite (a small overview of the graph) has a yellow halo around the block that is currently in focus, as does the Function Graph window. For easy identification, the function’s entry block (which contains the function’s entry point address) is green in the satellite, and any return blocks (blocks containing a <code>ret</code>, or equivalent) are red. Even if you change the background color of the associated block in the graph, the entry and exit colors don’t change in the satellite. All other blocks will mirror the color assigned to them in the Function Graph window.</p>
</div>
<h3 class="h3" id="ch10lev184"><strong>Function Call Graphs</strong></h3>
<p class="noindent">A function call graph is useful for gaining a quick understanding of the hierarchy of function calls made within a program. Function call graphs are similar to function graphs, but each block represents an entire function body, and each edge represents a call cross-reference from one function to another.</p>
<span epub:type="pagebreak" id="page_209"/>
<p class="indent">To discuss function call graphs, we make use of the following trivial program that creates a simple hierarchy of function calls:</p>
<pre>#include &lt;stdio.h&gt;<br/>
void depth_2_1() {<br/>
    printf("inside depth_2_1\n");<br/>
}<br/>
void depth_2_2() {<br/>
    fprintf(stderr, "inside depth_2_2\n");<br/>
}<br/>
void depth_1() {<br/>
    depth_2_1();<br/>
    depth_2_2();<br/>
    printf("inside depth_1\n");<br/>
}<br/>
int main() {<br/>
    depth_1();<br/>
}</pre>
<p class="indent">After compiling a dynamically linked version of this program using GNU <code>gcc</code> and loading the binary with Ghidra, we can generate a function call graph by using Window ▸ Function Call Graph. By default, this creates a function call graph centered around the function that is currently selected. The function call graph when <code>main</code> is selected is shown in <a href="ch10.xhtml#fig10_11">Figure 10-11</a>. (The satellite view is hidden in these examples for clarity. To unhide the satellite view, use the icon in the bottom right of <a href="ch10.xhtml#fig10_11">Figure 10-11</a>.)</p>
<div class="image"><img src="Images/fig10-11.jpg" alt="image" width="473" height="547"/></div>
<p class="figcap" id="fig10_11"><em>Figure 10-11: Simple function call graph with focus on main</em></p>
<span epub:type="pagebreak" id="page_210"/>
<p class="indent">The string <em>main (3 functions; 2 edges)</em> in the title bar of the graph lets us know what function we are in, along with the number of functions and edges displayed. Hovering over a node in the graph displays + and/or – icons at the top and/or bottom of the node, as shown in <a href="ch10.xhtml#fig10_12">Figure 10-12</a>.</p>
<p class="indent">A + icon at the top or bottom means you can display additional incoming or outgoing functions. Conversely, the – icon provides the ability to contract nodes. For instance, clicking a – symbol at the bottom of the function <code>depth_1</code> when it is expanded will change the function call graph from the one shown in <a href="ch10.xhtml#fig10_13">Figure 10-13</a> to the one in <a href="ch10.xhtml#fig10_11">Figure 10-11</a>.</p>
<div class="image"><img src="Images/fig10-12.jpg" alt="image" width="127" height="142"/></div>
<p class="figcap" id="fig10_12"><em>Figure 10-12: Function Call graph node with expand/collapse icons</em></p>
<div class="image"><img src="Images/fig10-13.jpg" alt="image" width="394" height="724"/></div>
<p class="figcap" id="fig10_13"><em>Figure 10-13: Function call graph expanded from</em> <span class="codeitalic">main</span></p>
<p class="indent">The right-click context menu associated with each node provides you with options to expand or contract all outgoing edges for all nodes, on the same horizontal level, simultaneously. This is equivalent to clicking the <span epub:type="pagebreak" id="page_211"/>+ or – icon on all nodes in the same rank at the same time. Finally, double-clicking a node in the graph centers the graph on the selected node and fully expands all incoming and outgoing edges. An option that is disabled by default, but that many find helpful, provides you with the ability to zoom out and back in. This option can be enabled through Edit ▸ Tool Options by checking the Scroll Wheel Pans option. Ghidra maintains a short history of graphs in a cache as you shift focus to retain graph state upon return. This allows you to expand and contract nodes, navigate away, and then return to find your graph just the way you left it to continue your analysis.</p>
<p class="indent"><a href="ch10.xhtml#fig10_14">Figure 10-14</a> shows the same program, with the focus on <code>_start</code> rather than <code>main</code> and most nodes fully expanded to show the full extent of the graph. In addition to our <code>main</code> function and associated subroutines, we can see wrapper code that was inserted by the compiler. This code is responsible for library initialization and termination as well as configuring the environment properly prior to transferring control to the <code>main</code> function. (Alert readers may notice that the compiler has substituted calls to <code>puts</code> and <code>fwrite</code> for <code>printf</code> and <code>fprintf</code>, respectively, as they are more efficient when printing static strings.)</p>
<div class="image"><img src="Images/fig10-14.jpg" alt="image" width="649" height="699"/></div>
<p class="figcap" id="fig10_14"><em>Figure 10-14: Expanded function call graph expanded from</em> <span class="codeitalic">_start</span><span epub:type="pagebreak" id="page_212"/></p>
<div class="box5">
<p class="boxtitle-c" id="ch10sb01"><strong>THUNK</strong></p>
<p class="noindent">You may notice that the graph in <a href="ch10.xhtml#fig10_14">Figure 10-14</a> shows multiple (apparently recursive) calls to <code>puts</code>. Welcome to the magical world of thunk functions. A <em>thunk function</em> is a compiler device that facilitates calls to functions whose address is unknown at compile time (such as a dynamically linked library function). Ghidra refers to the function whose address is unknown as the <em>thunked</em> function. The compiler replaces all calls the program makes to thunked functions with a call to a thunk function stub that the compiler inserts into the executable. The <em>thunk function stub</em> typically performs a table lookup to learn the runtime address of the thunked function before transferring control to the thunked function. The table consulted by a thunk stub is populated at runtime after the associated thunked function addresses become known. In Windows executables, this table is typically called the <em>import table</em>. In ELF binaries, this table is typically called the <em>global offset table</em> (or <em>got</em>).</p>
<p class="indent">If we navigate to <code>puts</code> from the function <code>depth_1</code> in the Listing window, we find ourselves in the following listing:</p>
<pre>
    **************************************************************<br/>
    *                       THUNK FUNCTION                       *<br/>
    **************************************************************<br/>
             thunk int puts(char * __s)<br/>
                Thunked-Function: &lt;EXTERNAL&gt;::puts<br/>
     int               EAX:4          &lt;RETURN&gt;<br/>
     char *            RDI:8          __s<br/>
                puts@@GLIBC_2.2.5<br/>
                puts     XREF[2]: puts:00100590(T),<br/>
                                  puts:00100590(c), 00300fc8(*)<br/>
00302008                 ??         ??<br/>
00302009                 ??         ??<br/>
0030200a                 ??         ??</pre>
<p class="indent">This thunk function listing appears in a program section that Ghidra names <code>EXTERNAL</code>. Ghidra thunked function listings such as this are a consequence of the way in which external libraries are dynamically loaded and linked into processes at runtime, which means the libraries are generally not available during static analysis. While the listing provides you an indication of the function and library being called, the function code is not directly accessible (unless the library is also loaded into Ghidra, which is easily accomplished via the options page during the import process).</p>
<p class="indent">Here we also observe a new type of XREF. The <code>(T)</code> suffix on the first XREF indicates that this XREF is a link to the thunked function.</p>
</div>
<p class="indent"><span epub:type="pagebreak" id="page_213"/>Now, let’s revisit a statically linked version of the <code>call_tree</code> program. The initial graph generated from the <code>main</code> function is identical to the dynamically linked version shown in <a href="ch10.xhtml#fig10_11">Figure 10-11</a>. However, to get an idea of the potential complexity associated with graphs of statically linked binaries, let’s investigate two expansions that seem relatively benign. <a href="ch10.xhtml#fig10_15">Figure 10-15</a> shows the outgoing calls from the <code>puts</code> function. The title bar shows <em>puts(9 functions; 11 edges)</em>. Note that the title bar totals may be inaccurate until the program has been fully analyzed.</p>
<div class="image"><img src="Images/fig10-15.jpg" alt="image" width="694" height="289"/></div>
<p class="figcap" id="fig10_15"><em>Figure 10-15: Function call graph in a statically linked binary</em></p>
<p class="indent">When we shift the focus to <em>_lll_lock_wait_private</em>, we are presented with an overwhelming graph with 70 nodes and over 200 edges, a portion of which is shown in <a href="ch10.xhtml#fig10_16">Figure 10-16</a>.</p>
<div class="image"><img src="Images/fig10-16.jpg" alt="image" width="800" height="521"/></div>
<p class="figcap" id="fig10_16"><em>Figure 10-16: Expanded function call graph in a statically linked binary</em></p>
<span epub:type="pagebreak" id="page_214"/>
<p class="indent">While statically linked binaries are complex and working with the associated graphs can be challenging, two features make this tenable. First, you can usually locate <code>main</code> by using the hotkey G or by navigating from the program’s <code>entry</code> symbol. Second, once you have located <code>main</code> in the listing, you can open and easily control what is displayed in the associated function call graph.</p>
<h3 class="h3" id="ch10lev185"><strong>Trees</strong></h3>
<p class="noindent">Ghidra presents many hierarchical concepts associated with a particular binary as a tree-like structure. While not always trees in a pure graph-theoretical sense, these structures provide the capability to expand and collapse nodes and to see the hierarchical relationship between nodes of varying types. When we discussed the CodeBrowser window in <a href="ch05.xhtml#ch05">Chapter 5</a>, you were introduced to Program Trees, Symbol Tree, Function Call Tree, and the Data Type Manager (which is also presented as a tree). These tree views can be used concurrently with other views to provide additional insight into the binary you are analyzing.</p>
<h3 class="h3" id="ch10lev186"><strong>Summary</strong></h3>
<p class="noindent">Graphs are a powerful tool available to assist you in analyzing any binary. If you are accustomed to viewing disassemblies in pure text format, it may take some time to adjust to using a graph-based display. In Ghidra, it is generally a matter of realizing that all of the information that was available in the text display remains available in the graph display; however, it may be formatted somewhat differently. Cross-references, for example, become the edges that connect the blocks in a graph display.</p>
<p class="indent">Which graph you view depends on what you want to know about a binary. If you want to know how a particular function is reached, you are probably interested in a function call graph. If you want to know how a specific instruction is reached, you are probably more interested in a function graph. Both can provide valuable insight into how the program works.</p>
<p class="indent">Now that you have seen the basic functionality available when running Ghidra as a standalone instance with you as the only reverse engineer, it is time to investigate options for using Ghidra as a collaborative tool. In the next chapter, we look at Ghidra Server and the environment it provides to support collaborative reverse engineering.</p>
</div>



  </body></html>