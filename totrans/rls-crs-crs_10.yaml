- en: Chapter 8. Advanced Active Record
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 高级活动记录
- en: When building a new application, work out the data model first. A *data model*
    is a description of the models in your program, along with their attributes and
    associations. First, identify the models needed and the relationships between
    them, and then create tables for these models and test them in the Rails console.
    Once the data models are working properly, building the rest of the application
    is much easier.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建一个新应用程序时，首先要确定数据模型。*数据模型*是对程序中模型的描述，包括它们的属性和关联。首先，确定所需的模型及其关系，然后为这些模型创建表，并在
    Rails 控制台中进行测试。一旦数据模型正确工作，构建其余的应用程序就会容易得多。
- en: Some people think of diagrams with boxes and arrows when they hear the words
    *data model*. These diagrams are unnecessary if you understand how the models
    relate without them. This chapter does include some basic diagrams, however, to
    illustrate different associations. In each diagram, the arrows point from the
    foreign key in a child model to the primary key in the parent model.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人听到*数据模型*这个词时，会想到带有框和箭头的图示。如果你理解模型之间的关系，图示是没有必要的。不过，本章确实包含了一些基本的图示，用于说明不同的关联。在每个图示中，箭头从子模型中的外键指向父模型中的主键。
- en: In this chapter, you’re going to start building a new application from scratch.
    The application is a social network in the style of Tumblr. Users create accounts
    and then post text and images for other users to see. A user can follow other
    users so their friends’ posts appear on the timeline on their home page.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将从零开始构建一个新的应用程序。这个应用程序是一个类似于 Tumblr 的社交网络。用户创建帐户，然后发布文本和图片供其他用户查看。用户可以关注其他用户，这样他们朋友的帖子就会出现在主页的时间线上。
- en: First, I’ll discuss several advanced data-modeling techniques. Then we’ll work
    our way through the models needed for your new social networking site.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将讨论几种高级数据建模技术。然后，我们将一起完成你新社交网络网站所需的模型构建。
- en: Advanced Data Modeling
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级数据建模
- en: When building the blog, you worked with `has_many` and `belongs_to` associations.
    Real-world applications often require more complex associations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建博客时，你使用了`has_many`和`belongs_to`关联。现实世界的应用程序通常需要更复杂的关联。
- en: For example, you sometimes need to model an association between two models of
    the same type, or you might need to model a many-to-many relationship between
    models. You also might need to store an object hierarchy in the database, but
    relational databases don’t really support inheritance. Finally, you might need
    to model a class that can associate with multiple different types of models.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有时你需要建模两个相同类型模型之间的关联，或者你可能需要建模模型之间的多对多关系。你还可能需要将对象层次结构存储在数据库中，但关系型数据库并不真正支持继承。最后，你可能需要建模一个可以与多种不同类型模型关联的类。
- en: I’ll discuss these four situations in this section, starting with modeling a
    relationship between two models of the same type using a self join association.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论这四种情况，首先介绍使用自连接关联建模两个相同类型模型之间的关系。
- en: Self Join Associations
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自连接关联
- en: Imagine an application for managing employees at a company. In addition to data
    such as each employee’s name, job title, and salary, you need to store each employee’s
    manager’s name. Each employee `belongs_to` a manager, and a manager `has_many`
    subordinates. A manager is also an employee, so you need to set up an association
    between two different models of the same type.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个用于管理员工的应用程序。除了每个员工的姓名、职位和薪资等数据外，还需要存储每个员工经理的姓名。每个员工`属于`一个经理，而一个经理`拥有`多个下属。经理也是员工，所以你需要在同类型的两个模型之间建立关联。
- en: Recall that a `belongs_to` association means the model needs a foreign key to
    link it to another model. A foreign key is a field that identifies the model on
    the other side of an association. So the `employees` table needs a field called
    `manager_id` to link each employee to a manager. The diagram in [Figure 8-1](ch08.html#self_join_association
    "Figure 8-1. Self join association") shows how this relationship works.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`belongs_to`关联意味着模型需要一个外键来将其与另一个模型链接。外键是一个字段，用于标识关联另一方的模型。因此，`employees`表需要一个名为`manager_id`的字段，用于将每个员工与经理关联起来。图示[图
    8-1](ch08.html#self_join_association "图 8-1. 自连接关联")展示了这一关系是如何运作的。
- en: A *self join association* allows you to model an organizational chart or other
    tree structure using a single table. The `manager_id` foreign key points to the
    id of the employee’s manager. This same type of association is also used to model
    other tree structures such as nested comments, where replies include a `parent_id`
    that points to the parent comment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *自连接关联* 允许你使用单个表来建模组织结构图或其他树形结构。`manager_id` 外键指向员工经理的 id。此类型的关联也用于建模其他树形结构，比如嵌套评论，其中回复包括一个
    `parent_id`，指向父评论。
- en: '![Self join association](httpatomoreillycomsourcenostarchimages2169078.png.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![自连接关联](httpatomoreillycomsourcenostarchimages2169078.png.jpg)'
- en: Figure 8-1. Self join association
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1. 自连接关联
- en: 'Once the `manager_id` field has been added to the `employees` table, you can
    define the associations in the `Employee` model:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `manager_id` 字段添加到 `employees` 表中，你可以在 `Employee` 模型中定义关联：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First, you add a `has_many` association for subordinates. Because this association
    refers to the `Employee` model, and not a model named `Subordinate`, you must
    specify `class_name: ''Employee''` ➊. You must also specify the foreign key name,
    in this case, `manager_id` ➋. Finally, add the `belongs_to` association for the
    `manager`. Again, you must explicitly state the model’s class name because Rails
    can’t figure it out based on the association name ➌.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，为下属添加一个 `has_many` 关联。因为这个关联指向的是 `Employee` 模型，而不是一个名为 `Subordinate` 的模型，所以你必须指定
    `class_name: ''Employee''` ➊。你还必须指定外键名称，在这种情况下是 `manager_id` ➋。最后，为 `manager`
    添加一个 `belongs_to` 关联。同样，你必须明确声明模型的类名，因为 Rails 无法仅根据关联名称推测出来 ➌。'
- en: With these associations in place, you can call the `subordinates` method to
    get a list of a manager’s subordinates. You can also use the methods `manager`
    and `manager=` to get and set an employee’s manager. Almost every employee should
    have a `manager_id`, as shown in [Table 8-1](ch08.html#employees_table "Table 8-1. The
    employees Table"). If your `manager_id` is `nil`, then you must be the boss!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些关联，你可以调用 `subordinates` 方法来获取经理的下属列表。你还可以使用 `manager` 和 `manager=` 方法来获取和设置员工的经理。几乎每个员工都应该有一个
    `manager_id`，如 [表 8-1](ch08.html#employees_table "表 8-1. 员工表") 中所示。如果你的 `manager_id`
    是 `nil`，那么你一定是老板！
- en: Table 8-1. The employees Table
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-1. 员工表
- en: '| id | name | manager_id |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| id | name | manager_id |'
- en: '| --- | --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | Alice | NULL |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Alice | NULL |'
- en: '| 2 | Bob | 1 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Bob | 1 |'
- en: Notice that the `manager_id` for Bob is 1\. That means Alice is Bob’s manager.
    Alice’s `manager_id` is NULL, which is `nil` in Ruby. She’s the CEO of this two-person
    company.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Bob 的 `manager_id` 是 1。这意味着 Alice 是 Bob 的经理。Alice 的 `manager_id` 是 NULL，在
    Ruby 中是 `nil`。她是这家只有两个人的公司的 CEO。
- en: Many-to-Many Associations
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多对多关联
- en: Whereas a one-to-many association only involves two tables, a many-to-many association
    always involves a third table known as a *join table*. The join table stores foreign
    keys for each side of the association. It `belongs_to` each of the models in the
    association.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 而一对多关联仅涉及两个表，多对多关联总是涉及一个第三个表，称为 *连接表*。连接表存储关联两端的外键。它 `belongs_to` 关联中的每个模型。
- en: Rails provides two different ways to set up a many-to-many association.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Rails 提供了两种不同的方式来设置多对多关联。
- en: has_and_belongs_to_many
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: has_and_belongs_to_many
- en: If you’re using a join table strictly for the association and need no additional
    data, then use a `has_and_belongs_to_many` association. You still need to create
    the join table, but you don’t need to define a model for it. The join table must
    be named after the two models it joins.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用连接表仅仅为了关联而不需要额外的数据，那么可以使用 `has_and_belongs_to_many` 关联。你仍然需要创建连接表，但不需要为其定义模型。连接表必须以它连接的两个模型的名称命名。
- en: For example, authors write many books, and some books have multiple authors.
    All of the data you need is stored in either the author or book model, so you
    can create a `has_and_belongs_to_many` association between authors and books,
    as in [Figure 8-2](ch08.html#hasunderscoreandunderscorebelong-id00018 "Figure 8-2. has_and_belongs_to_many
    association").
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，作者写许多书籍，而某些书籍有多个作者。你需要的所有数据都存储在作者或书籍模型中，因此你可以在作者和书籍之间创建一个 `has_and_belongs_to_many`
    关联，如 [图 8-2](ch08.html#hasunderscoreandunderscorebelong-id00018 "图 8-2. has_and_belongs_to_many
    关联") 中所示。
- en: '![has_and_belongs_to_many association](httpatomoreillycomsourcenostarchimages2169080.png.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![has_and_belongs_to_many 关联](httpatomoreillycomsourcenostarchimages2169080.png.jpg)'
- en: Figure 8-2. `has_and_belongs_to_many` association
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2. `has_and_belongs_to_many` 关联
- en: '[Figure 8-2](ch08.html#hasunderscoreandunderscorebelong-id00018 "Figure 8-2. has_and_belongs_to_many
    association") shows the `Author` and `Book` models with the join table between
    them. Define the association between these models as shown here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-2](ch08.html#hasunderscoreandunderscorebelong-id00018 "图8-2. has_and_belongs_to_many
    关联")展示了`Author`和`Book`模型以及它们之间的连接表。按照以下方式定义这些模型之间的关联：'
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'An author might write many books, but a book can also have many authors:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一位作者可能写很多书，但一本书也可以有多个作者：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For this association to work, the join table between `authors` and `books`
    must be named `authors_books` and must contain fields `author_id` and `book_id`.
    Use the `rails generate` command to create an empty migration file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此关联生效，`authors`和`books`之间的连接表必须命名为`authors_books`，并且必须包含`author_id`和`book_id`字段。使用`rails
    generate`命令创建一个空的迁移文件：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then edit the migration file to remove the primary key and create the two foreign
    keys:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后编辑迁移文件，移除主键并创建两个外键：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `t.references :author` statement ➊ indicates this field is a foreign key
    that references an `Author` model. The field is named `author_id`. The `null:
    false` option adds a constraint so NULL values are not allowed, and the `index:
    true` option creates a database index to speed up queries on this field. The next
    line creates the `book_id` field, also with a NULL constraint and database index.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`t.references :author` 语句 ➊ 表示此字段是一个外键，引用了`Author`模型。该字段名为`author_id`。`null:
    false`选项添加了一个约束，禁止NULL值，`index: true`选项则为该字段创建了数据库索引，以加速查询。下一行创建了`book_id`字段，也有NULL约束和数据库索引。'
- en: 'You can also use the `create_join_table` method inside the migration to create
    the join table. This method takes the names of the associations and creates the
    correct table with no primary key and a foreign key for each association with
    a NULL constraint. This method does not automatically create indices for the foreign
    keys. You can add indices as shown here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在迁移中使用`create_join_table`方法来创建连接表。此方法接受关联的名称，并创建正确的表，其中没有主键，每个关联都有外键并带有NULL约束。此方法不会自动为外键创建索引，你可以按照以下方式添加索引：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After creating the join table, you don’t need to do anything to make the association
    work. There is no model associated with the join table. With a `has_and_belongs_to_many`
    association, Rails manages the join table for you.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了连接表后，你无需做任何额外操作来使关联生效。连接表不需要关联模型。使用`has_and_belongs_to_many`关联时，Rails会为你管理连接表。
- en: has_many :through
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: has_many :through
- en: If you would like to store additional information in the join table besides
    the foreign keys of the associated models, use a `has_many :through` association.
    For example, you could model the association between bands and venues using a
    join table named `performances.` [Figure 8-3](ch08.html#hasunderscoremany_through_association
    "Figure 8-3. has_many :through association") shows the relationship among bands,
    performances, and venues.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在连接表中存储除关联模型的外键之外的其他信息，可以使用`has_many :through`关联。例如，你可以使用名为`performances`的连接表来建模乐队与场馆之间的关联。[图8-3](ch08.html#hasunderscoremany_through_association
    "图8-3. has_many :through 关联")展示了乐队、演出和场馆之间的关系。
- en: '![has_many :through association](httpatomoreillycomsourcenostarchimages2169082.png.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![has_many :through 关联](httpatomoreillycomsourcenostarchimages2169082.png.jpg)'
- en: Figure 8-3. `has_many :through` association
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-3. `has_many :through` 关联
- en: 'Each performance belongs to a band and a venue. It also has a show-time. The
    models look like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个演出都属于一个乐队和一个场馆。它还具有演出时间。模型如下所示：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A band performs many times, and so the band is associated with many different
    venues through its performances:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个乐队进行多场演出，因此乐队通过其演出与许多不同的场馆建立关联：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A venue hosts many performances. The venue is associated with many different
    bands through the performances it hosts:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个场馆承办多场演出。场馆通过它所承办的演出与多个不同的乐队建立关联：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Performances associate a band with a venue. A venue can also store additional
    data, such as the showtime of the performance, in the `performances` table.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 演出将乐队与场馆关联起来。场馆还可以在`performances`表中存储额外的数据，例如演出的时间：
- en: Single-Table Inheritance
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单表继承
- en: Sometimes you need to store a hierarchy of classes in the database. Most relational
    databases don’t support inheritance, but you can use *single-table inheritance*
    to create these models and store the inheritance structure in the database.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要在数据库中存储类的层次结构。大多数关系型数据库不支持继承，但你可以使用*单表继承*来创建这些模型并在数据库中存储继承结构。
- en: For example, imagine you are writing an application to manage a pet store. You
    need a way to model different types of pets such as dogs and fish. Pet dogs and
    pet fish share many of the same attributes and methods, so it makes sense for
    both of them to inherit from a parent class named `Pet`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在编写一个管理宠物商店的应用。你需要一种方式来建模不同类型的宠物，例如狗和鱼。宠物狗和宠物鱼有很多相同的属性和方法，所以它们都继承自一个名为
    `Pet` 的父类是很有意义的。
- en: In Rails, you can create a single table for pets and then store records for
    the two child classes `Dog` and `Fish` in the same table. Rails uses a column
    named *type* to keep track of the type of object stored in each row. In addition
    to the columns needed by the parent model, you also need to add all columns needed
    by the child models to the table. You need this because all models are stored
    in the same table.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rails 中，你可以为宠物创建一个单独的表，然后将 `Dog` 和 `Fish` 这两个子类的记录存储在同一个表中。Rails 使用名为 *type*
    的列来跟踪每行中存储的对象类型。除了父模型所需的列之外，你还需要将子模型所需的所有列添加到表中。你需要这么做，因为所有模型都存储在同一个表中。
- en: 'The parent model `Pet` is a normal Active Record model. The `Pet` model inherits
    from `ActiveRecord::Base`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 父模型 `Pet` 是一个普通的 Active Record 模型。`Pet` 模型继承自 `ActiveRecord::Base`：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Dog` model inherits from `Pet`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dog` 模型继承自 `Pet`：'
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `Fish` model also inherits from `Pet`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fish` 模型也继承自 `Pet`：'
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With these models in place, you can store records of all three types in a single
    table named `pets`, shown in [Table 8-2](ch08.html#pets_table "Table 8-2. The
    pets Table").
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些模型就位后，你可以将所有三种类型的记录存储在一个名为 `pets` 的单一表中，如[表 8-2](ch08.html#pets_table "表
    8-2. 宠物表")所示。
- en: Table 8-2. The pets Table
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-2. 宠物表
- en: '| id | type | name | cost |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| id | 类型 | 名称 | 费用 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1 | Dog | Collie | 200 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 狗 | 柯利犬 | 200 |'
- en: '| 2 | Fish | Gold Fish | 5 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 鱼 | 金鱼 | 5 |'
- en: '| 3 | Dog | Cocker Spaniel | 100 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 狗 | 可卡犬 | 100 |'
- en: These three rows from the `pets` table hold data for the `Dog` and `Fish` models.
    You can now make calls like `Pet.count` to count the pets in the table. Calling
    `Dog.count` returns 2 and `Fish.count` returns 1. Because Rails knows teach record
    type, `pet = Pet.find(2)` returns an object of type `Fish`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这三行来自 `pets` 表，包含了 `Dog` 和 `Fish` 模型的数据。你现在可以像 `Pet.count` 一样调用来计算表中的宠物数量。调用
    `Dog.count` 返回 2，`Fish.count` 返回 1。因为 Rails 知道每条记录的类型，`pet = Pet.find(2)` 会返回一个
    `Fish` 类型的对象。
- en: You’ll look at another example of single-table inheritance in the next section,
    when you create the post models for your new application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将看到单表继承的另一个示例，当时你会为新应用创建帖子模型。
- en: Polymorphic Associations
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态关联
- en: 'With polymorphic associations, a model can belong to more than one other model
    using a single association. The classic example of a polymorphic association is
    allowing comments on multiple types of objects. For example, you might want to
    let people comment on both posts and images. Here is what your comment model might
    look like using a polymorphic association:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多态关联，一个模型可以通过单一关联属于多个其他模型。多态关联的经典示例是允许对多种类型的对象进行评论。例如，你可能希望让人们对帖子和图片都能发表评论。以下是你使用多态关联时，评论模型可能的样子：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Instead of using `belongs_to :post` or `belongs_to :image`, you specify that
    a comment `belongs_to` something called `:commentable`. This name can be anything
    you like, but the convention is to make it an adjective form of the model name.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用 `belongs_to :post` 或 `belongs_to :image`，而是指定评论 `belongs_to` 一个叫做 `:commentable`
    的东西。这个名字可以是你喜欢的任何名字，但惯例是将其命名为模型名称的形容词形式。
- en: The `comments` table will need two fields for this association to work, an integer
    field named `commentable_id` and a string field named `commentable_type`. The
    `commentable_type` field holds the class name of the object that owns this comment.
    This setup is similar to the `type` column in the single-table inheritance example
    you saw in the previous section. The `commentable_id` is a foreign key referring
    to the `id` of the object that owns this comment.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`comments` 表需要两个字段来支持这种关联，一个名为 `commentable_id` 的整数字段和一个名为 `commentable_type`
    的字符串字段。`commentable_type` 字段保存拥有此评论的对象的类名。这个设置类似于你在前一节中看到的单表继承的 `type` 列。`commentable_id`
    是一个外键，指向拥有此评论的对象的 `id`。'
- en: 'Include `as: :commentable` on the `has_many :comments` associations in models
    that can have comments:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '在可以有评论的模型中，包含 `as: :commentable` 到 `has_many :comments` 关联中：'
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `has_many` association works the same as always. A method call like `@post.comments`
    returns a list of comments associated with the post. It works by looking for comments
    that match both the `id` of the `@post` object and the class name `Post`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`has_many` 关联的工作方式与以前相同。像`@post.comments`这样的调用会返回与帖子相关的评论列表。它是通过查找与`@post`对象的`id`以及类名`Post`匹配的评论来实现的。'
- en: If your application grows and you need comments on other models, you can add
    the same `has_many` association to the new model without changing anything in
    the `Comment` model.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用增长，并且你需要在其他模型上添加评论，你可以在新模型中添加相同的`has_many`关联，而不需要更改`Comment`模型。
- en: That’s enough theory for now. Let’s put some of this knowledge to work.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在理论部分已经够多了，让我们将一些知识付诸实践。
- en: The Social Application
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社交应用
- en: In this section, you’ll build the data model for a social networking service
    similar to Tumblr. You need models for users and posts. You also need to represent
    a user following another user as well as several different types of posts, and
    users should be able to comment on posts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将为一个类似 Tumblr 的社交网络服务构建数据模型。你需要为用户和帖子创建模型。你还需要表示用户如何关注其他用户，以及几种不同类型的帖子，用户应该能够对帖子进行评论。
- en: 'Start by creating a new, empty Rails application in your code directory:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从在你的代码目录中创建一个新的空 Rails 应用开始：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I’m calling my application *social*, but call yours whatever you like. Who knows,
    you may launch this app and sell it for a billion dollars someday!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我把我的应用称为*social*，但你可以随意命名。谁知道呢，或许有一天你会发布这个应用并以十亿美元的价格出售！
- en: Now let’s work through the models needed for this application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来构建这个应用所需的模型。
- en: User Model
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户模型
- en: If this is to be a social site, the first thing you need is a model for users
    and the relationships between them. Tumblr, like Twitter, doesn’t use the idea
    of friendship between users. Instead, you subscribe to another user’s updates
    by “following” that user.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个社交网站，首先你需要一个用户模型以及用户之间关系的模型。像 Twitter 一样，Tumblr 不使用“朋友”这一概念，而是通过“关注”其他用户来订阅他们的更新。
- en: 'Start by creating a new resource named `User`. For now, add string fields for
    `name` and `email`. You can always add more fields later by creating another database
    migration. The following command creates a controller, model, database migration,
    and other files for users:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从创建一个名为`User`的新资源开始。现在，添加 `name` 和 `email` 的字符串字段。你可以随时通过创建新的数据库迁移来添加更多字段。以下命令将为用户创建控制器、模型、数据库迁移以及其他文件：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create the `users` table by running this new database migration:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行这个新的数据库迁移来创建`users`表：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, you need to create a model to represent the idea of subscriptions. A subscription
    is a type of self join, but it is a many-to-many association, so you need a join
    table. What should this model contain? You subscribe to another user’s posts by
    following them. You can call the user you are following a leader. So you need
    to store a `leader_id` and a `follower_id` in the `subscriptions` table.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建一个模型来表示订阅的概念。订阅是一种自我连接类型，但它是多对多关联，因此你需要一个连接表。这个模型应该包含什么呢？你通过关注另一个用户的帖子来订阅他们。你可以把你关注的用户称为“领导者”。所以，你需要在`subscriptions`表中存储`leader_id`和`follower_id`。
- en: When one user follows another user, the following user’s `id` is stored in the
    `follower_id` field and the other user’s `id` is stored in the `leader_id` field.
    This setup allows you to find a list of a user’s followers and leaders easily.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个用户关注另一个用户时，关注者的`id`会存储在`follower_id`字段中，另一位用户的`id`会存储在`leader_id`字段中。这样的设置让你能够轻松找到一个用户的关注者和领导者列表。
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Because this is a join table, use the model generator to create a database
    migration and model for subscriptions. Don’t forget to update your database:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个连接表，使用模型生成器来创建订阅的数据库迁移和模型。别忘了更新你的数据库：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that you’ve created the tables, you need to update the model files to define
    the associations. First, open the file *app/models/subscription.rb* in your editor:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经创建了表格，现在需要更新模型文件以定义关联。首先，在编辑器中打开文件*app/models/subscription.rb*：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You used `leader:references` and `follower:references` when creating the model,
    so the Rails model generator added two `belongs_to` associations to the `Subscription`
    model for you. Both `:leader` and `:follower` actually refer to a `User`, so you
    need to add the class name `User`. By default, Rails looks for model names that
    match association names. If you don’t specify a class name, Rails looks for models
    named `Leader` and `Follower`. [Figure 8-4](ch08.html#subscription_associations
    "Figure 8-4. Subscription associations") shows the tables for `users` and `subscriptions`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建模型时，你使用了`leader:references`和`follower:references`，因此Rails模型生成器为你在`Subscription`模型中添加了两个`belongs_to`关联。`：leader`和`：follower`实际上都指向一个`User`，所以你需要添加类名`User`。默认情况下，Rails会查找与关联名称匹配的模型名称。如果你不指定类名，Rails会查找名为`Leader`和`Follower`的模型。[图8-4](ch08.html#subscription_associations
    "图8-4. 订阅关联")显示了`users`和`subscriptions`的表格。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In reality, these tables also include `created_at` and `updated_at` timestamps,
    but I left these out of the diagrams in this chapter for brevity.*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际上，这些表格也包括`created_at`和`updated_at`时间戳，但为了简洁起见，我在本章的图表中省略了它们。*'
- en: '![Subscription associations](httpatomoreillycomsourcenostarchimages2169084.png.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![订阅关联](httpatomoreillycomsourcenostarchimages2169084.png.jpg)'
- en: Figure 8-4. Subscription associations
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-4. 订阅关联
- en: 'In the `subscriptions` table, both `leader_id` and `follower_id` are foreign
    keys referring to a user. Now that the `Subscription` associations are done, let’s
    add the `User` associations. Open the file *app/models/user.rb* in your editor:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`subscriptions`表中，`leader_id`和`follower_id`都是外键，指向一个用户。现在`Subscription`关联已完成，我们来添加`User`关联。打开你的编辑器中的*app/models/user.rb*文件：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Start with the fact that a user has many subscriptions. In this case, you need
    to specify the foreign key to use. Normally, you would call this `user_id`, but
    you’re modeling leaders and followers, so call it `follower_id` instead ➊. Also
    specify what happens if this user is deleted with `dependent: :destroy` ➋. This
    tells Rails to destroy any associated subscriptions if this user is ever destroyed.
    Finally, add the `has_many:through` association to leaders ➌.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '从用户拥有多个订阅的事实开始。在这种情况下，你需要指定使用的外键。通常，你会将其命名为`user_id`，但因为你在建模领导者和追随者，所以应该将其命名为`follower_id`
    ➊。同时，使用`dependent: :destroy` ➋来指定如果该用户被删除时会发生什么。这告诉Rails，如果该用户被销毁，则销毁所有相关的订阅。最后，向领导者添加`has_many:through`关联➌。'
- en: 'Next, add a few methods to the model to make working with the associations
    easier. You can also use these methods to test the associations in the Rails console:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为模型添加一些方法，使得操作关联更简单。你也可以使用这些方法在Rails控制台中测试关联：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, add a *predicate method*, a method returning a `true` or `false` value,
    called `following?` ➊ to see if the current user is following another user. This
    method checks to see if the current user’s `leaders` collection includes the `leader`
    passed as an argument to the method.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加一个*谓词方法*，返回`true`或`false`值，命名为`following?` ➊，用来判断当前用户是否正在关注另一个用户。此方法会检查当前用户的`leaders`集合中是否包含作为参数传入的`leader`。
- en: Then, add the `follow!` method ➋ to indicate that the current user is following
    another user. This method ensures the current user isn’t trying to follow himself
    or herself and isn’t already following the other user ➌. If neither case is true,
    the `leader` passed to this method is inserted into the current user’s `leaders`
    collection with `<<`, the insertion operator.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加`follow!`方法➋，表示当前用户正在关注另一个用户。此方法确保当前用户不会试图关注自己，且不会已经关注了另一个用户➌。如果两种情况都不成立，传递给该方法的`leader`会使用`<<`插入到当前用户的`leaders`集合中，这是插入操作符。
- en: 'With these methods in place, you can now launch a Rails console and test your
    associations:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些方法后，你现在可以启动Rails控制台并测试你的关联：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Start by creating two users:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从创建两个用户开始：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, call the `follow!` method on `alice` and pass in `bob`. Then call the
    `following?` method on `alice` to confirm that `follow` worked correctly. Finally,
    call `following?` again to see if `bob` is following `alice`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`alice`上调用`follow!`方法，并传入`bob`。然后在`alice`上调用`following?`方法，确认`follow`是否正常工作。最后，再次调用`following?`来查看`bob`是否正在关注`alice`：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The call to `alice.follow! bob` adds `bob` to collection of `leaders` for `alice`.
    Next, the call to `alice.following? bob` checks to see if the `alice.leaders`
    collection includes `bob`. It does, so the method returns `true`. Of course, it
    doesn’t actually look for `bob`, but the `id` of the `User` referred to as `bob`.
    The call to `bob.following? alice` returns `false`. The `bob.leaders` collection
    is empty, so `bob` is not following `alice`. [Table 8-3](ch08.html#users_table
    "Table 8-3. The users Table") and [Table 8-4](ch08.html#subscriptions_table "Table 8-4. The
    subscriptions Table") show the `users` and `subscriptions` tables after Alice
    follows Bob, again with the timestamp fields omitted.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `alice.follow! bob` 会将 `bob` 添加到 `alice` 的 `leaders` 集合中。接下来，调用 `alice.following?
    bob` 会检查 `alice.leaders` 集合中是否包含 `bob`。结果是包含的，所以方法返回 `true`。当然，它实际上并没有查找 `bob`，而是查找指向
    `bob` 的 `User` 的 `id`。调用 `bob.following? alice` 返回 `false`。因为 `bob.leaders` 集合是空的，所以
    `bob` 并没有关注 `alice`。[表 8-3](ch08.html#users_table "表 8-3. 用户表") 和 [表 8-4](ch08.html#subscriptions_table
    "表 8-4. 订阅表") 显示了 `alice` 关注 `bob` 后的 `users` 和 `subscriptions` 表（时间戳字段被省略）。
- en: Table 8-3. The users Table
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-3. 用户表
- en: '| id | name | email |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| id | name | email |'
- en: '| --- | --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | Alice | NULL |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Alice | NULL |'
- en: '| 2 | Bob | NULL |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Bob | NULL |'
- en: The `users` table holds records for `alice` and `bob`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`users` 表保存了 `alice` 和 `bob` 的记录。'
- en: Table 8-4. The subscriptions Table
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-4. 订阅表
- en: '| id | leader_id | follower_id |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| id | leader_id | follower_id |'
- en: '| --- | --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | 2 | 1 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 1 |'
- en: The `subscriptions` table holds a single record representing the association
    between `alice` and `bob`. The `leader_id` is 2, the `id` of `bob`**;** and the
    `follower_id` is 1, the `id` of `alice`. This means `alice` is following `bob`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscriptions` 表保存了一个记录，表示 `alice` 和 `bob` 之间的关联。`leader_id` 是 2，即 `bob` 的
    `id`；`follower_id` 是 1，即 `alice` 的 `id`。这意味着 `alice` 正在关注 `bob`。'
- en: At this point, you can get a list of every user that `alice` is following by
    calling the `leaders` method. Having this list is helpful, but it’s only half
    of what you need. You also want to be able to list a user’s followers. To do this,
    use the `subscriptions` table again, only this time going in the opposite direction.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可以通过调用 `leaders` 方法获取 `alice` 正在关注的每个用户的列表。拥有这个列表是有帮助的，但这只是你所需要的一半。你还希望能够列出一个用户的关注者。为此，使用
    `subscriptions` 表，但这次是反向操作。
- en: You need another `has_many` association on the `Subscription` model that is
    the reverse of the existing association. You can then use that association to
    find followers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在 `Subscription` 模型中添加另一个 `has_many` 关联，它是现有关联的反向关联。然后，你可以使用该关联来查找关注者。
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This association is the reverse of the existing `:subscriptions` association.
    There’s no clever word for the reverse of a subscription, so name the association
    `:reverse_subscriptions`. This association uses the `leader_id` field as the foreign
    key ➊. Because the association name doesn’t match the name of the model, you also
    need to specify a class name ➋. As with the subscription association, also specify
    `dependent: :destroy` so you aren’t left with orphan records in the `subscriptions`
    table if a user is destroyed. After adding the `:reverse_subscriptions` association,
    you can use it to add another `has_many :through` association for `:followers`
    ➌.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '这个关联是现有 `:subscriptions` 关联的反向关联。没有什么巧妙的词语来描述订阅的反向，所以将关联命名为 `:reverse_subscriptions`。该关联使用
    `leader_id` 字段作为外键 ➊。因为关联名称与模型名称不匹配，你还需要指定类名 ➋。和订阅关联一样，指定 `dependent: :destroy`，这样如果用户被删除，`subscriptions`
    表中就不会留下孤立的记录。添加 `:reverse_subscriptions` 关联后，你可以使用它来为 `:followers` 添加另一个 `has_many
    :through` 关联 ➌。'
- en: 'Restart the Rails console for these changes to take effect, and then try the
    new association:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 重启 Rails 控制台以使这些更改生效，然后尝试新的关联：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Because you restarted the console, you first need to find your users in the
    database ➊. Call the `followers` method on `alice` to see if she has any followers
    ➋. This method returns a type of relation called an `ActiveRecord::Associations::CollectionProxy`.
    I made the output a little easier to read by chaining `to_a` after `followers`,
    which converts the output to an array ➌.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你重启了控制台，你首先需要在数据库中查找你的用户 ➊。调用 `followers` 方法查看 `alice` 是否有任何关注者 ➋。该方法返回一种称为
    `ActiveRecord::Associations::CollectionProxy` 的关系类型。我通过在 `followers` 后面链式调用 `to_a`
    来使输出更容易阅读，这会将输出转换为数组 ➌。
- en: The output shows that `alice` has no followers and `bob` has a single follower—`alice`.
    The `User` associations and methods are working correctly so far. Now that users
    can follow each other, let’s move on to posts.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示`alice`没有关注者，而`bob`有一个关注者——`alice`。`User`关联和方法到目前为止工作正常。现在，用户可以相互关注，我们可以继续讨论帖子功能。
- en: Post Models
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帖子模型
- en: People don’t just want to share plain text on a social network—they also want
    to share images, links, and videos. We should allow our users to create a different
    kind of post for each type of content, though the post types will share some common
    functionality. This sounds like a perfect use for inheritance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 人们在社交网络上不仅仅想分享纯文本——他们还想分享图片、链接和视频。我们应该允许用户为每种类型的内容创建不同的帖子类型，尽管这些帖子类型将共享一些共同的功能。这听起来像是继承的完美应用场景。
- en: First, create a base model called `Post`, and then inherit from that class to
    create models for `TextPost`, `ImagePost`, and so on. You can use singletable
    inheritance to create these models and store the inheritance structure in the
    database. Because the `posts` table holds records for all types of posts, you
    must add columns needed by the other models to the `posts` table. In addition
    to the usual `title` and `body` fields, add a `url` field to store the address
    of an image for image posts and a `type` field for single-table inheritance.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`Post`的基础模型，然后从该类继承创建`TextPost`、`ImagePost`等模型。你可以使用单表继承来创建这些模型，并在数据库中存储继承结构。由于`posts`表存储所有类型的帖子记录，你必须向`posts`表中添加其他模型所需的列。除了常见的`title`和`body`字段外，还需要添加一个`url`字段来存储图像帖子的图像地址，以及一个`type`字段用于单表继承。
- en: 'With those requirements in mind, generate the post resource and update your
    application’s database:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些需求，生成帖子资源并更新应用的数据库：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `user:references` option adds a `user_id` field so you can associate posts
    with users. Don’t forget to update your application’s database.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`user:references`选项会添加一个`user_id`字段，这样你就可以将帖子与用户关联起来。别忘了更新应用的数据库。'
- en: Now you’re ready to create resources for the different types of posts.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已准备好为不同类型的帖子创建资源。
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, I’ve passed two options to the resource generator. The `--parent=Post`
    option indicates that these models inherit from `Post` and the `--migration=false`
    option tells the generator to not create a database migration for this resource.
    A database migration is not needed because these resources are stored in the `posts`
    table you created earlier.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我为资源生成器传递了两个选项。`--parent=Post`选项表示这些模型继承自`Post`，而`--migration=false`选项告诉生成器不要为此资源创建数据库迁移。因为这些资源存储在之前创建的`posts`表中，所以不需要数据库迁移。
- en: 'First, let’s update the newly created `Post` model in *app/models/post.rb*
    to make sure all posts have an associated user and type:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更新新创建的`Post`模型，位于*app/models/post.rb*，确保所有帖子都有一个关联的用户和类型：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: All posts in our social application belong to an individual user. This validation
    ensures that a `Post` can’t be created without an associated `user_id` ➊. The
    type validation ➋ validates that all records are identified as either a `TextPost`
    or an `ImagePost`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们社交应用中的所有帖子都属于个别用户。这个验证确保了`Post`在没有关联`user_id`的情况下无法创建➊。类型验证➋确保所有记录要么被识别为`TextPost`，要么是`ImagePost`。
- en: 'Now add validations to the `TextPost` and `ImagePost` models. First, edit *app/models/image_post.rb*
    and add a URL validation to the `ImagePost` model:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为`TextPost`和`ImagePost`模型添加验证。首先，编辑*app/models/image_post.rb*，并为`ImagePost`模型添加一个URL验证：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `url` field holds the address of the image for an `ImagePost`. Users can
    copy a URL from an image sharing site such as Flickr or Imgur. The application
    shouldn’t allow an `ImagePost` to be saved without an image `url`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`url`字段保存`ImagePost`的图像地址。用户可以从如Flickr或Imgur这样的图片分享网站复制URL。应用不应允许没有图像`url`的`ImagePost`被保存。'
- en: 'Then update the `TextPost` model in *app/models/text_post.rb* to check for
    a post body:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*app/models/text_post.rb*中更新`TextPost`模型，检查是否有帖子正文：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The application also shouldn’t allow a `TextPost` to be saved without `body`
    text.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 应用还不应允许没有`body`文本的`TextPost`被保存。
- en: While you’re editing models, also add the associations for the new post models
    under the rest of the `has_many` associations to the `User` model at *app/models/user.rb:*
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑模型时，还要在*app/models/user.rb*的其余`has_many`关联下，为新帖模型添加关联：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now you can restart the Rails console and use these new models:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以重新启动Rails控制台并使用这些新模型：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Because you restarted the console, first find the `User` representing `alice`
    ➊. Then create a `TextPost` and an `ImagePost` belonging to `alice`. The `posts`
    method on the `User` model returns all posts associated with that user regardless
    of type ➋. Note that the `TextPost` and `ImagePost` you just created are both
    returned in the same collection. The `text_posts` method returns only `TextPost`
    objects ➌.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你重新启动了控制台，首先找到表示 `alice` 的 `User` ➊。然后创建一个属于 `alice` 的 `TextPost` 和一个 `ImagePost`。`User`
    模型上的 `posts` 方法返回与该用户关联的所有帖子，无论类型如何 ➋。请注意，你刚刚创建的 `TextPost` 和 `ImagePost` 都会在同一个集合中返回。`text_posts`
    方法只会返回 `TextPost` 对象 ➌。
- en: Comment Model
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评论模型
- en: Now that the models for users and posts are in place, create the comments model
    for the application. Add a text field to hold the `body` of the comment, a `post_id`
    to reference the post that owns this comment, and a `user_id` to reference the
    user who left the comment.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户和帖子模型已经到位，接下来为应用程序创建评论模型。添加一个文本字段来保存评论的 `body`，一个 `post_id` 来引用拥有此评论的帖子，以及一个
    `user_id` 来引用发表评论的用户。
- en: Note that I am not using a polymorphic association with these comments. Because
    my different post types all inherit from the base class `Post`, I can simply associate
    `Comment` with `Post`, allowing comments on any type of post.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我没有在这些评论中使用多态关联。因为我的不同帖子类型都继承自基类 `Post`，所以我可以简单地将 `Comment` 与 `Post` 关联，从而允许对任何类型的帖子进行评论。
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Also add `has_many :comments` to the `User` and `Post` model to complete the
    associations among users, posts, and comments. [Figure 8-5](ch08.html#social_application_data_modelcomma_with
    "Figure 8-5. The social application data model, with timestamps omitted") shows
    the tables you created in this chapter and their associations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要在 `User` 和 `Post` 模型中添加 `has_many :comments` 以完成用户、帖子和评论之间的关联。[图 8-5](ch08.html#social_application_data_modelcomma_with
    "图 8-5. 社交应用数据模型，省略了时间戳") 展示了你在本章中创建的表及其关联。
- en: '![The social application data model, with timestamps omitted](httpatomoreillycomsourcenostarchimages2169086.png.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![社交应用数据模型，省略了时间戳](httpatomoreillycomsourcenostarchimages2169086.png.jpg)'
- en: Figure 8-5. The social application data model, with timestamps omitted
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-5. 社交应用数据模型，省略了时间戳
- en: With this, you have all of your models and are well on your way to building
    your new social network.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，你已经完成了所有模型的创建，并且已经朝着构建新的社交网络迈出了重要一步。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I covered some pretty advanced database modeling techniques in this chapter.
    The `User` model has several complex associations. The different types of posts
    demonstrate single-table inheritance. Luckily, the `Comment` model didn’t contain
    any surprises.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章中讲解了一些相当高级的数据库建模技巧。`User` 模型有多个复杂的关联。不同类型的帖子展示了单表继承。幸运的是，`Comment` 模型没有包含任何意外的复杂性。
- en: In the next chapter, I’ll talk about authentication, and you’ll start adding
    controller actions and views so users can sign up and log in to your social network.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将讲解认证，并且你将开始添加控制器操作和视图，以便用户可以注册并登录到你的社交网络。
- en: Exercises
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '| Q: | 1\. You specified `dependent: :destroy` on all `has_many` associations
    in this chapter to ensure that dependent models would be removed. For example,
    because the `Post` model has a `dependent: :destroy` association with the `User`
    model, if a `User` is destroyed, then all of the user’s posts are also destroyed.
    What do you think would happen if you specified `dependent: :destroy` on a `belongs_to`
    association? |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| Q: | 1\. 在本章中，你在所有的 `has_many` 关联上都指定了 `dependent: :destroy`，以确保相关的依赖模型会被移除。例如，因为
    `Post` 模型与 `User` 模型有 `dependent: :destroy` 关联，如果一个 `User` 被销毁，那么该用户的所有帖子也会被销毁。你认为如果在
    `belongs_to` 关联上指定 `dependent: :destroy` 会发生什么情况？|'
- en: '| Q: | 2\. Add validations to the `Comment` model to ensure that every comment
    belongs to a `User` and a `Post`. Your application shouldn’t allow a `Comment`
    to be created without a `user_id` and `post_id`. You should also ensure that all
    comments have text in the `body` field. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| Q: | 2\. 为 `Comment` 模型添加验证，以确保每个评论都属于一个 `User` 和一个 `Post`。你的应用程序不应允许没有 `user_id`
    和 `post_id` 的评论被创建。你还应该确保所有评论的 `body` 字段都有文本内容。|'
- en: '| Q: | 3\. Use the Rails console to create a new `User`. Create a `TextPost`
    or `ImagePost` belonging to this `User` and at least one `Comment`. Now destroy
    the `User`, and make sure the associated `Post` and `Comment` are also destroyed.
    |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| Q: | 3\. 使用 Rails 控制台创建一个新的 `User`。为该 `User` 创建一个 `TextPost` 或 `ImagePost`，并至少创建一个
    `Comment`。然后销毁该 `User`，确保与之关联的 `Post` 和 `Comment` 也被销毁。|'
