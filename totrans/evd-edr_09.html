<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch9">&#13;
<header>&#13;
<h1 class="CHAPTER" id="ch9">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_171" aria-label=" Page 171. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">SCANNERS</samp></span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.png" alt=""/>&#13;
</figure>&#13;
<p class="CO">Nearly every EDR solution includes a component that accepts data and tries to determine whether the content is malicious. Endpoint agents use it to assess many different data types, such as files and memory streams, based on a set of rules that the vendor defines and updates. This component, which we’ll refer to as the <i>scanner</i> for simplicity’s sake, is one of the oldest and best-studied areas in security from both the defensive and offensive angles.</p>&#13;
<p class="TX">Because covering all aspects of their implementation, processing logic, and signatures would be like trying to boil the ocean, this chapter focuses on the rules employed by file-based scanners. Scanner rules differentiate one product’s scanner from another (barring major performance differences or other technical capabilities). And on the offensive side, it’s the scanner rules rather than the implementation of the scanner itself that adversaries must evade.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h-126"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_172" aria-label=" Page 172. "/><samp class="SANS_Futura_Std_Bold_B_11">A Brief History of Antivirus Scanning</samp></h2>&#13;
<p class="TNI">We don’t know who invented the antivirus scanning engine. German security researcher Bernd Fix developed some of the first antivirus software, in 1987, to neutralize the Vienna virus, but it wasn’t until 1991 that the world saw an antivirus scanning engine that resembles the ones in use today; FRISK Software’s F-PROT antivirus would scan a binary to detect any reordering of its sections, a pattern that malware developers of the time commonly employed to jump execution to the end of the file, where they had placed malicious code.</p>&#13;
<p class="TX">As viruses became more prevalent, dedicated antivirus agents became a requirement for many companies. To meet this demand, vendors such as Symantec, McAfee, Kaspersky, and F-Secure brought their scanners to market in the 1990s. Regulatory bodies began enforcing the use of antivirus to protect systems, further promoting their adoption. By the 2010s, it was nearly impossible to find an enterprise environment without antivirus software deployed on most of its endpoints.</p>&#13;
<p class="TX">This broad adoption lulled many directors of information-security programs into a false sense of security. While these antimalware scanners had some success in detecting commodity threats, they missed more advanced threat groups, which were achieving their objectives without detection.</p>&#13;
<p class="TX">In May 2013, Will Schroeder, Chris Truncer, and Mike Wright released their tool, Veil, which opened many people’s eyes to this overreliance on antivirus scanners. Veil’s entire purpose was to create payloads that bypassed antivirus by employing techniques that broke legacy detection rulesets. These techniques included string- and variable-name obfuscation, less common code-injection methods, and payload encryption. During offensive security engagements, they proved that their tool could effectively evade detection, causing many companies to reevaluate the value of the antivirus scanners they paid for. Simultaneously, antivirus vendors began rethinking how to approach the problem of detection.</p>&#13;
<p class="TX">While it’s hard to quantify the impact of Veil and other tools aimed at tackling the same problem, these tools undoubtedly moved the needle, leading to the creation of more robust endpoint detection solutions. These newer solutions still make use of scanners, which contribute to the overall detection strategies, but they have grown to include other sensors that can provide coverage when the scanners’ rulesets fail to detect malware.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h2 class="H1" id="sec2"><span id="h-127"/><samp class="SANS_Futura_Std_Bold_B_11">Scanning Models</samp></h2>&#13;
<p class="TNI">Scanners are software applications that the system should invoke when appropriate. Developers must choose between two models to determine when their scanner will run. This decision is more complex and important than it may seem at face value.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h-128"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_173" aria-label=" Page 173. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">On Demand</samp></h3>&#13;
<p class="TNI">The first model, <i>on-demand scanning</i>, instructs a scanner to run at some set time or when explicitly requested to do so. This type of scanning typically interacts with a large number of targets (for example, files and folders) on each execution. The Quick Scan feature in Microsoft Defender, shown in <a href="#fig9-1">Figure 9-1</a>, may be the most familiar example of this model.</p>&#13;
<figure class="IMG"><img id="fig9-1" class="img50" src="../images/Figure9-1.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: Defender’s Quick Scan feature in action</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">When implementing this model, developers must consider the potential performance impacts on the system caused by the scanner processing thousands of files at once. On resource-constrained systems, it might be best to run this type of scan during off-hours (for example, 2 <small>AM</small> every Tuesday) than to run a full scan during working hours.</p>&#13;
<p class="TX">The other major downside of this model involves the period of time between each scan. Hypothetically, an attacker could drop malware on the system after the first scan, execute it, and remove it before the next scan, to evade detection.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H2" id="sec4"><span id="h-129"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">On Access</samp></h3>&#13;
<p class="TNI">During <i>on-access scanning</i>, often referred to as <i>real-time protection</i>, the scanner assesses an individual target while some code is interacting with it or when a suspicious activity occurs and warrants investigation. You’ll most often find this model paired with another component that can receive notifications when something interacts with the target object, such as a filesystem minifilter driver. For example, the scanner might investigate a file when it is downloaded, opened, or deleted. Microsoft Defender implements this model on all Windows systems, as shown in <a href="#fig9-2">Figure 9-2</a>.</p>&#13;
<figure class="IMG"><img id="fig9-2" class="img50" src="../images/Figure9-2.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-2: Defender’s real-time protection feature enabled by default</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_174" aria-label=" Page 174. "/>The on-access scanning approach generally causes more of a headache for adversaries because it removes the ability to abuse the periods of time between on-demand scans. Instead, attackers are left trying to evade the ruleset used by the scanner. Let’s now consider how these rulesets work.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h2 class="H1" id="sec5"><span id="h-130"/><samp class="SANS_Futura_Std_Bold_B_11">Rulesets</samp></h2>&#13;
<p class="TNI">At the heart of every scanner is a set of rules that the engine uses to assess the content to be scanned. These rules more closely resemble dictionary entries than firewall rules; each rule contains a definition in the form of a list of attributes that, if identified, signals that the content should be treated as malicious. If the scanner detects a match for a rule, it will take some predetermined action, such as quarantining the file, killing the process, or alerting the user.</p>&#13;
<p class="TX">When designing scanner rules, developers hope to capture a unique attribute of a piece of malware. These features can be specific, like the names or cryptographic hashes of files, or they can be broader, such as DLLs or functions that the malware imports or a series of opcodes that serve some critical function.</p>&#13;
<p class="TX">Developers might base these rules on known malware samples detected outside the scanner. Sometimes other groups even share information about the sample with a vendor. The rules can also target malware families or techniques more generally, such as a known group of APIs used by ransomware, or strings like <samp class="SANS_TheSansMonoCd_W5Regular_11">bcdedit.exe</samp>, which might indicate that malware is trying to modify the system.</p>&#13;
<p class="TX">Vendors can implement both types of rules in whatever ratio makes sense for their product. Generally, vendors that heavily rely on rules specific to known malware samples will generate fewer false positives, while those that make use of less-specific indicators will encounter fewer false negatives. Because rulesets are made up of hundreds or thousands of rules, vendors can balance the ratio of specific to less-specific detections to meet the false-positive and false-negative tolerances of their customers.</p>&#13;
<p class="TX">Vendors each develop and implement their own rulesets, but products tend to have a lot of overlap. This is beneficial to consumers, as the overlap ensures that no single scanner dominates the marketplace based on its ability to detect the “threat du jour.” To illustrate this, take a look at the results of a query in VirusTotal (an online service used to investigate suspicious files, IPs, domain names, and URLs). <a href="#fig9-3">Figure 9-3</a> shows a phishing lure associated with FIN7, a financially motivated threat group, detected by 33 security vendors, demonstrating the overlap of these rulesets.</p>&#13;
<p class="TX">There have been many attempts to standardize scanner rule formats to facilitate the sharing of rules between vendors and the security community. At the time of this writing, the YARA rule format is the most widely adopted, and you’ll see it used in open source, community-driven detection efforts as well as by EDR vendors.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_175" aria-label=" Page 175. "/>&#13;
<figure class="IMG"><img id="fig9-3" class="img60" src="../images/Figure9-3.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-3: VirusTotal scan results for a file associated with FIN7</samp></p></figcaption>&#13;
</figure>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h2 class="H1" id="sec6"><span id="h-131"/><samp class="SANS_Futura_Std_Bold_B_11">Case Study: YARA</samp></h2>&#13;
<p class="TNI">Originally developed by Victor Alvarez of VirusTotal, the YARA format helps researchers identify malware samples by using textual and binary patterns to detect malicious files. The project provides both a stand-alone executable scanner and a C programming language API that developers can integrate into external projects. This section explores YARA, as it provides a great example of what a scanner and its rulesets look like, has fantastic documentation, and is widely used.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H2" id="sec7"><span id="h-132"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding YARA Rules</samp></h3>&#13;
<p class="TNI">YARA rules use a simple format: they begin with metadata about the rule, followed by a set of strings describing the conditions to be checked and a Boolean expression that describes the rule logic. Consider the example in <a href="#list9-1">Listing 9-1</a>.</p>&#13;
<pre id="list9-1"><code>rule SafetyKatz_PE&#13;
{&#13;
   <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> meta:&#13;
         description = "Detects the default .NET TypeLibGuid for SafetyKatz"&#13;
         reference = "https://github.com/GhostPack/SafetyKatz"&#13;
         author = "Matt Hand"&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> strings:&#13;
         $guid = "8347e81b-89fc-42a9-b22c-f59a6a572dec" ascii nocase wide&#13;
     condition:&#13;
         (uint16(0) == 0x5A4D and uint32(uint32(0x3C)) == 0x00004550) and $guid&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 9-1: A YARA rule for detecting the public version of SafetyKatz</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_176" aria-label=" Page 176. "/>This simple rule, called <i>SafetyKatz_PE</i>, follows a format commonly used to detect off-the-shelf .NET tooling. It begins with some metadata containing a brief description of the rule, a reference to the tool it aims to detect, and, optionally, the date on which it was created <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This metadata has no bearing on the scanner’s behavior, but it does provide some useful context about the rule’s origins and behavior.</p>&#13;
<p class="TX">Next is the strings section <span class="CodeAnnotation" aria-label="annotation2">❷</span>. While optional, it houses useful strings found inside the malware that the rule’s logic can reference. Each string has an identifier, beginning with a <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp>, and a function, like in a variable declaration. YARA supports three different types of strings: plaintext, hexadecimal, and regular expressions.</p>&#13;
<p class="TX">Plaintext strings are the most straightforward, as they have the least variation, and YARA’s support of modifiers makes them especially powerful. These modifiers appear after the contents of the string. In <a href="#list9-1">Listing 9-1</a>, the string is paired with the modifiers <samp class="SANS_TheSansMonoCd_W5Regular_11">ascii nocase wide</samp>, which means that the string should be checked without sensitivity to case in both ASCII and wide formats (the <i>wide</i> format uses two bytes per character). Additional modifiers, including <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">base64</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">base64wide</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">fullword</samp>, exist to provide even more flexibility when defining a string to be processed. Our example rule uses only one plaintext string, the GUID for TypeLib, an artifact created by default in Visual Studio when a new project is begun.</p>&#13;
<p class="TX">Hexadecimal strings are useful when you’re searching for non-printable characters, such as a series of opcodes. They’re defined as space-delimited bytes enclosed in curly brackets (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">$foo</samp> = <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE EF}</samp>). Like plaintext strings, hexadecimal strings support modifiers that extend their functionality. These include wildcards, jumps, and alternatives. <i>Wildcards</i> are really just placeholders that say “match anything here” and are denoted with a question mark. For example, the string <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE ??}</samp> would match anything from <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE 00}</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE FF}</samp> appearing in a file. Wildcards are also <i>nibble-wise</i>, meaning that the rule author can use a wildcard for either nibble of the byte, leaving the other one defined, which allows the author to scope their search even further. For example, the string <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE E?}</samp> would match anything from <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE E0}</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE EF}</samp>.</p>&#13;
<p class="TX">In some situations, the content of a string can vary, and the rule author might not know the length of these variable chunks. In that case, they can use a jump. <i>Jumps</i> are formatted as two numbers delimited with a hyphen and enclosed in square brackets. They effectively mean “the values starting here and ranging from X to Y bytes in length are variable.” For example, the hexadecimal string <samp class="SANS_TheSansMonoCd_W5Regular_11">$foo</samp> = <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE [1-3] EF}</samp> would match any of the following:</p>&#13;
<p class="LIST"><samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EE</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp></p>&#13;
<p class="LIST"><samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">00 B1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp></p>&#13;
<p class="LIST"><samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EF 00 BE</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp></p>&#13;
<p class="TX">Another modifier supported by hexadecimal strings is <i>alternatives</i>. Rule authors use these when working with a portion of a hex string that has multiple possible values. The authors delimit these values with pipes and store <span role="doc-pagebreak" epub:type="pagebreak" id="pg_177" aria-label=" Page 177. "/>them in parentheses. There is no limit to the number or size of alternatives in a string. Additionally, alternatives can include wildcards to expand their utility. The string <samp class="SANS_TheSansMonoCd_W5Regular_11">$foo</samp> = <samp class="SANS_TheSansMonoCd_W5Regular_11">{BE (EE | EF BE | ?? 00) EF}</samp> would match any of the following:</p>&#13;
<p class="LIST"><samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EE</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp></p>&#13;
<p class="LIST"><samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EF BE</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp></p>&#13;
<p class="LIST"><samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">EE 00</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp></p>&#13;
<p class="LIST"><samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">A1 00</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EF</samp></p>&#13;
<p class="TX">The final and only mandatory section of a YARA rule is called the condition. <i>Conditions</i> are Boolean expressions that support Boolean operators (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">AND</samp>), relational operators (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>=), and the arithmetic and bitwise operators (for example, <i>+</i> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp>) for numerical expressions.</p>&#13;
<p class="TX">Conditions can work with strings defined in the rule while scanning the file. For example, the SafetyKatz rule makes sure that the TypeLib GUID is present in the file. But conditions can also work without the use of strings. The first two conditions in the SafetyKatz rule check for the two-byte value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x4D5A</samp> (the MZ header of a Windows executable) at the start of the file and the four-byte value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00004550</samp> (the PE signature) at offset <samp class="SANS_TheSansMonoCd_W5Regular_11">0x3C</samp>. Conditions can also operate using special reserved variables. For example, here is a condition that uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">filesize</samp> special variable: <samp class="SANS_TheSansMonoCd_W5Regular_11">filesize</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">30KB</samp>. It will return true if the total file size is less than 30KB.</p>&#13;
<p class="TX">Conditions can support more complex logic with additional operators. One example is the <samp class="SANS_TheSansMonoCd_W5Regular_11">of</samp> operator. Consider the example shown in <a href="#list9-2">Listing 9-2</a>.</p>&#13;
<pre id="list9-2"><code>rule Example&#13;
{&#13;
    strings:&#13;
        $x = "Hello"&#13;
        $y = "world"&#13;
    condition:&#13;
        any of them&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 9-2: Using YARA’s <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">of</samp> operator</span></p>&#13;
<p class="TX">This rule returns true if either the <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello"</samp> string or the <samp class="SANS_TheSansMonoCd_W5Regular_11">"world"</samp> string is found in the file being scanned. Other operators exist, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">all of</samp>, for when all strings must be present; <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">of</samp>, for when some subset of the strings must be present; and the <samp class="SANS_TheSansMonoCd_W5Regular_11">for…of</samp> iterator, to express that only some occurrences of the string should satisfy the rule’s conditions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H2" id="sec8"><span id="h-133"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reverse Engineering Rules</samp></h3>&#13;
<p class="TNI">In production environments, you’ll commonly find hundreds or even thousands of rules analyzing files correlating to malware signatures. There are over 200,000 signatures in Defender alone, as shown in <a href="#list9-3">Listing 9-3</a>.</p>&#13;
<pre id="list9-3"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_178" aria-label=" Page 178. "/>PS &gt; <b>$signatures = (Get-MpThreatCatalog).ThreatName</b>&#13;
PS &gt; <b>$signatures | Measure-Object -Line | select Lines</b>&#13;
 Lines&#13;
 -----&#13;
222975&#13;
&#13;
PS &gt; <b>$signatures | Group {$_.Split(</b>'<b>:</b>'<b>)[0]} |</b>&#13;
<b>&gt;&gt; Sort Count -Descending |</b>&#13;
<b>&gt;&gt; select Count,Name -First 10</b>&#13;
&#13;
Count Name&#13;
----- ----&#13;
57265 Trojan&#13;
28101 TrojanDownloader&#13;
27546 Virus&#13;
19720 Backdoor&#13;
17323 Worm&#13;
11768 Behavior&#13;
 9903 VirTool&#13;
 9448 PWS&#13;
 8611 Exploit&#13;
 8252 TrojanSpy</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 9-3: Enumerating signatures in Defender</span></p>&#13;
<p class="TX">The first command extracts the <i>threat names</i>, a way of identifying specific or closely related pieces of malware (for example, <i>VirTool:MSIL/BytzChk.C!MTB</i>), from Defender’s signature catalog. The second command then parses each threat name for its top-level category (for example, <i>VirTool</i>) and returns a count of all signatures belonging to the top levels.</p>&#13;
<p class="TX">To the user, however, most of these rules are opaque. Often, the only way to figure out what causes one sample to be flagged as malicious and another to be deemed benign is manual testing. The DefenderCheck tool helps automate this process. <a href="#fig9-4">Figure 9-4</a> shows a contrived example of how this tool works under the hood.</p><span role="doc-pagebreak" epub:type="pagebreak" id="pg_179" aria-label=" Page 179. "/>&#13;
<figure class="IMG"><img id="fig9-4" class="img50" src="../images/Figure9-4.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-4: DefenderCheck’s binary search</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">DefenderCheck splits a file in half, then scans each half to determine which one holds the content that the scanner deemed malicious. It recursively repeats this process on every malicious half until it has identified the specific byte at the center of the rule, forming a simple binary search tree.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h2 class="H1" id="sec9"><span id="h-134"/><samp class="SANS_Futura_Std_Bold_B_11">Evading Scanner Signatures</samp></h2>&#13;
<p class="TNI">When trying to evade detection by a file-based scanner such as YARA, attackers typically attempt to generate false negatives. In short, if they can figure out what rules the scanner is employing to detect some relevant file (or at least make a satisfactory guess at this), they can potentially modify that attribute to evade the rule. The more brittle the rule, the easier it is to evade. In <a href="#list9-4">Listing 9-4</a>, we use dnSpy, a tool for decompiling and modifying .NET assemblies, to change the GUID in the compiled SafetyKatz assembly so that it evades the brittle YARA rule shown earlier in this chapter.</p>&#13;
<pre id="list9-4"><code>using System;&#13;
using System.Diagnostics;&#13;
using System.Reflection;&#13;
using System.Runtime.CompilerServices;&#13;
using System.Runtime.InteropServices;&#13;
using System.Security;&#13;
using System.Security.Permissions;&#13;
&#13;
[assembly: AssemblyVersion("1.0.0.0")]&#13;
[assembly: CompilationRelaxations(8)]&#13;
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]<span role="doc-pagebreak" epub:type="pagebreak" id="pg_180" aria-label=" Page 180. "/>&#13;
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]&#13;
[assembly: AssemblyTitle("SafetyKatz")]&#13;
[assembly: AssemblyDescription(" ")]&#13;
[assembly: AssemblyConfiguration(" ")]&#13;
[assembly: AssemblyCompany(" ")]&#13;
[assembly: AssemblyProduct("SafetyKatz")]&#13;
[assembly: AssemblyCopyright("Copyright © 2018")]&#13;
[assembly: AssemblyTrademark(" ")]&#13;
[assembly: ComVisible(false)]&#13;
[assembly: Guid("01234567-d3ad-b33f-0000-0123456789ac")] <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span>&#13;
[assembly: AssemblyFileVersion("1.0.0.0")]&#13;
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]&#13;
[module: UnverifiableCode]</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 9-4: Modifying the GUID in the assembly using dnSpy</span></p>&#13;
<p class="TX">If a detection is built solely around the presence of SafetyKatz’s default assembly GUID, the change made to the GUID here <span class="CodeAnnotation" aria-label="annotation1">❶</span> would evade the rule entirely.</p>&#13;
<p class="TX">This simple evasion highlights the importance of building detections based on a sample’s immutable attributes (or at least those that are more difficult to modify) to compensate for the more brittle rules. This is not to discount the value of these brittle rules, which could detect off-the-shelf Mimikatz, a tool very rarely used for legitimate purposes. However, adding a more robust companion (one whose false-positive rate is higher and false-negative rate is lower) fortifies the scanner’s ability to detect samples that have been modified to evade the existing rules. <a href="#list9-5">Listing 9-5</a> shows an example of this using SafetyKatz.</p>&#13;
<pre id="list9-5"><code>rule SafetyKatz_InternalFuncs_B64MimiKatz&#13;
{&#13;
     meta:&#13;
        description = "Detects the public version of the SafetyKatz&#13;
                       tool based on core P/Invokes and its embedded&#13;
                       base64-encoded copy of Mimikatz"&#13;
        reference = "https://github.com/GhostPack/SafetyKatz"&#13;
        author = "Matt Hand"&#13;
    strings:&#13;
        $mdwd = "MiniDumpWriteDump" ascii nocase wide&#13;
        $ll = "LoadLibrary" ascii nocase wide&#13;
        $gpa = "GetProcAddress" ascii nocase wide&#13;
        $b64_mimi = "zL17fBNV+jg8aVJIoWUCNFC1apCoXUE" ascii wide&#13;
    condition:&#13;
        ($mdwd and $ll and $gpa) or $b64_mimi&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 9-5: YARA rule to detect SafetyKatz based on internal function names and Base64 substrings</span></p>&#13;
<p class="TX">You could pass this rule to YARA via the command line to scan the base version of SafetyKatz, as is shown in <a href="#list9-6">Listing 9-6</a>.</p>&#13;
<pre id="list9-6"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_181" aria-label=" Page 181. "/>PS &gt; <b>.\yara64.exe -w -s .\safetykatz.rules C:\Temp\SafetyKatz.exe</b>&#13;
<b>&gt;&gt; SafetyKatz_InternalFuncs_B64MimiKatz C:\Temp\SafetyKatz.exe</b>&#13;
0x213b:$mdwd: <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> MiniDumpWriteDump&#13;
0x256a:$ll: LoadLibrary&#13;
0x2459:$gpa: GetProcAddress&#13;
0x25cd:$b64_mimi: <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span>&#13;
z\x00L\x001\x007\x00f\x00B\x00N\x00V\x00+\x00j\x00g\x008\x00a\x00V\x00J\x00I\x00o&#13;
\x00W\x00U\x00C\x00N\x00F\x00C\x001\x00a\x00p\x00C\x00o\x00X\x00U\x00E\x00</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 9-6: Detecting SafetyKatz using the new YARA rule</span></p>&#13;
<p class="TX">In the YARA output, we can see that the scanner detected both the suspicious functions <span class="CodeAnnotation" aria-label="annotation1">❶</span> and Base64 substring <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">But even this rule isn’t a silver bullet against evasion. An attacker could further modify the attributes from which we’ve built the detection, such as by moving from P/Invoke, the native way of calling unmanaged code from .NET, to D/Invoke, an alternative to P/Invoke that performs the same function, avoiding the suspicious P/Invokes that an EDR may be monitoring for. They could also use syscall delegates or modify the embedded copy of Mimikatz such that the first 32 bytes of its encoded representation differ from that in the rule.</p>&#13;
<p class="TX">There is one other way to avoid detection by scanners. In modern red teaming, most adversaries avoid touching disk (writing files to the filesystem). If they can operate entirely in memory, file-based scanners no longer pose a concern. For example, consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">/ticket:base64</samp> command line option in Rubeus, a tool for interacting with Kerberos. By using this flag, attackers can prevent a Kerberos ticket from being written to the target’s filesystem and instead have it returned through console output.</p>&#13;
<p class="TX">In some situations, attackers can’t avoid writing files to disk, such as in the case of SafetyKatz’s use of <samp class="SANS_TheSansMonoCd_W5Regular_11">dbghelp!MiniDumpWriteDump()</samp>, which requires the memory dump to be written to a file. In these situations, it’s important for attackers to limit the exposure of their files. This most commonly means immediately retrieving a copy of the files and removing them from the target, obscuring filenames and paths, or protecting the content of the file in some way.</p>&#13;
<p class="TX">While potentially less sophisticated than other sensors, scanners play an important part in detecting malicious content on the host. This chapter covers only file-based scanners, but commercial projects frequently employ other types, including network-based and memory scanners. At an enterprise scale, scanners can also offer interesting metrics, such as whether a file is globally unique. They present a particular challenge for adversaries and serve as a great representation of evasion in general. You can think of them as black boxes through which adversary tooling passes; the adversary’s job is to modify the attributes within their control, namely the elements of their malware, to make it to the other end.</p>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec10">&#13;
<h2 class="H1" id="sec10"><span id="h-135"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_182" aria-label=" Page 182. "/><samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp></h2>&#13;
<p class="TNI">Scanners, especially those related to antivirus engines, are one of the first defensive technologies many of us encounter. Though they fell out of favor due to the brittleness of their rulesets, they have recently regained popularity as a supplemental feature, employing (at times) more robust rules than other sensors such as minifilters and image-load callback routines. Still, evading scanners is an exercise in obfuscation rather than avoidance. By changing indicators, even simple things like static strings, an adversary can usually fly under the radar of most modern scanning engines.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>