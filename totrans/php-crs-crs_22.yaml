- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 17 INTRODUCTION TO OBJECT-ORIENTED PROGRAMMING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So far in this book, we’ve been using PHP to write *procedural* code, a sequence
    of instructions executed in order. We’re now going to shift our attention to a
    different way of using PHP: object-oriented programming (OOP). This chapter provides
    an overview of some important OOP concepts. Then the next several chapters will
    present in more depth how to harness OOP in your PHP projects.'
  prefs: []
  type: TYPE_NORMAL
- en: The object-oriented style of programming revolves around *objects*, computer
    representations of real-world things, and *classes*, generalized models that define
    all the abilities and characteristics every object of a certain category should
    have. In an object-oriented computer system, objects send messages to each other,
    interpret those messages, and decide what instructions to execute in response,
    often creating a value to be returned to the sender.
  prefs: []
  type: TYPE_NORMAL
- en: 'The power of OOP lies in its capacity for abstraction: programmers can focus
    much of their attention on planning out a system of classes with features relating
    to the real-world task or problem the application is meant to solve, rather than
    always having to think about the code itself. For example, an online banking system
    might need classes like Client, BankAccount, and Transaction, and objects created
    from those classes would represent specific instances of clients, bank accounts,
    and transactions. The messages and operations to make changes to these objects
    might include functions like withdrawCash($sum), setNewOverdraft($limit), or updateClientAddress($address).
    Similarly, an online computer game might need such classes as Player, Level, and
    InventoryItem, with messages and operations like purchaseInventoryItem($itemID)
    and setPlayerName($name). A programmer can identify all these requirements and
    map out the necessary web of class relationships before writing a single line
    of code. Thanks to this planning and organization, the process of writing the
    code becomes much easier.'
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the programmer must declare each class, which does require writing
    code. The programmer will declare data variables and functions to carry out typical
    programming tasks such as performing numeric calculations, manipulating strings
    and arrays, and so on. However, the beauty of OOP is that once you’ve created
    a class, its structure is essentially hidden “under the hood.” The rest of the
    coding process can focus on harnessing the objects’ messages and functions, which
    closely relate to real-world concepts and tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An object-oriented program is made up of PHP files that declare classes. A class
    can be thought of as the blueprint, or template, from which objects are created.
    Just like a blueprint of a car is just a drawing on paper, a PHP file declaring
    a class doesn’t itself do anything. However, just as you can ask a factory to
    take the car blueprint and manufacture one or more physical cars, you can ask
    the PHP engine to use a class declaration to create objects based on that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes people refer to an object as an *instance* of a class, since each
    object is one specific manifestation of the general characteristics and behaviors
    defined by the class. You can treat the terms *object* and *instance* as synonyms:
    an object in the computer’s memory, created from a class template, with a set
    of data values and the capability to respond to messages and execute functions.
    [Figure 17-1](#fig17-1) illustrates the relationship between a class and the objects
    created from that class.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure17-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-1: The Client class and two Client objects, matt and aoife'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class in the figure, Client, represents customers of a bank. You need to
    know three important aspects of a class: its name, its data variables, and its
    functions. In this example, our Client objects will have data variables for the
    client’s ID number, name, and contact information. When variables are declared
    as part of a class, they’re called *properties*. Likewise, our Client objects
    have several functions: you can close, suspend, or resume a customer’s account.
    When functions are declared as part of a class, they’re called *methods*. The
    various parts of a class are known collectively as its *members*; the members
    of a class include all its properties (variables), methods (functions), and constants.'
  prefs: []
  type: TYPE_NORMAL
- en: The bottom of [Figure 17-1](#fig17-1) also shows two objects (or instances)
    created from the Client class, named matt and aoife. Each object has its own set
    of properties (for example, the matt object has a surname of Smith and the address
    10 Main Street, Dublin), and both objects have access to the methods defined in
    the Client class. In PHP programming, you can have a $matt variable that functions
    as a reference to the Client object of the same name, and you can send it a message
    to close Matt’s account by writing $matt->closeAccount(). When the $matt object
    receives this message, it would execute its closeAccount() method.
  prefs: []
  type: TYPE_NORMAL
- en: WARNING
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*When you’re writing object-oriented PHP code, make sure you don’t confuse
    the* -> *object operator (for objects and messages) with the* => *operator, which
    is for key/value relationships in arrays.*  ### Creating Relationships Between
    Objects'
  prefs: []
  type: TYPE_NORMAL
- en: One of the powerful features of OOP is that you can build relationships between
    objects by linking a property of one object to another object. In some cases,
    you might relate objects of the same class. For example, if you have a Person
    class, you might link one Person object to another to demonstrate that one person
    is another person’s parent. Other times, you might relate objects of different
    classes, such as to establish that a Client object is the owner of a BankAccount
    object, as shown in [Figure 17-2](#fig17-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure17-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-2: The BankAccount class declares that each BankAccount object is
    linked to a Client object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The top of the figure shows the BankAccount class. Like the Client class we
    considered earlier, it includes data properties and methods that objects of this
    class can have: each BankAccount object has an account number, an owner, a balance,
    an overdraft limit, and a category, along with methods to deposit and withdraw
    money and set the overdraft limit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The owner property is particularly significant: its value must be a reference
    to a Client object. The owner property thus creates a link between objects of
    the BankAccount and Client classes. For example, as you can see at the bottom
    of the figure, DUB1070, a BankAccount object, is linked to matt, one of the Client
    objects. The beauty of this mechanism is that for any BankAccount object we’re
    working with, we can follow the link through the owner property to its related
    Client object and find out the name, address, and other details of the person
    who has the bank account.  ### Encapsulation and Information Hiding'
  prefs: []
  type: TYPE_NORMAL
- en: A class organizes an object’s data and the methods that can affect that data,
    gathering them in the same place. This principle, known as *encapsulation*, is
    central to OOP. Encapsulation helps keep projects organized; returning to the
    example in [Figure 17-1](#fig17-1), it’s logical that the methods for working
    with customer data are declared in the same file that also declares the data properties
    that should be stored about customers.
  prefs: []
  type: TYPE_NORMAL
- en: A danger arises, however, if all the data of an object can be directly changed
    by any part of the computer system that has access to that object. For example,
    we wouldn’t want the age of a Client object to be set to 0 or a negative number!
    In fact, the bank might have a policy setting the minimum age of a client to,
    say, 16 years old. To avoid such unauthorized changes and ensure valid data, object-oriented
    languages, including PHP, provide ways to control access to an object’s data.
  prefs: []
  type: TYPE_NORMAL
- en: The OOP feature of managing access to the data and methods of an object is known
    as *information hiding*. In PHP, you use the public, private, and protected keywords
    to declare different levels of access to the properties and methods of a class
    of objects. Continuing our example, we might prevent direct access to a Client
    object’s age property by making it private. Then we might declare a public setAge()
    method that will update the age only if certain validation requirements are met,
    such as being an integer 16 or greater. We’ll discuss how to use these features
    of object-oriented PHP in detail in the next few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Superclasses, Inheritance, and Overriding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can assign properties and methods that are common among several classes
    to a *superclass*, a generalized class that other classes (called *subclasses*)
    can *inherit* characteristics from. For example, both staff and clients of a bank
    will share many common data properties, such as a name, address, and phone number.
    [Figure 17-3](#fig17-3) shows the common properties and methods of the Client
    and StaffMember classes in bold. Some properties and methods are unique to each
    class, such as clientId for Client objects versus staffId for StaffMember objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure17-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-3: The Client and StaffMember classes have many duplicate members—very
    inefficient!'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-4](#fig17-4) illustrates how we can generalize the common properties
    and methods into a new superclass named Person, from which the Client and StaffMember
    classes both inherit. Only those properties and methods unique to a particular
    subclass are defined directly in the subclass itself. In PHP, we write something
    as simple as class Client extends Person to indicate that one class is to inherit
    from another.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure17-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-4: The generalized Person superclass eliminates duplication.'
  prefs: []
  type: TYPE_NORMAL
- en: Superclasses and inheritance help you avoid duplicating code across several
    classes. For example, you wouldn’t want to write code for operations like validating
    telephone numbers and addresses in multiple places; if something were to change
    (such as the 2014 introduction of Irish ZIP codes, called Eircodes!), you’d have
    to update several classes, and perhaps addresses and phone numbers would end up
    being treated differently in different parts of the system. Thanks to superclasses
    and inheritance, the code needs to be updated only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often you’ll want subclasses to inherit all the methods from their superclass,
    but this isn’t always the case. Sometimes a class may need to have logic that’s
    different from that of its superclass. For example, you might have a subclass
    of clients whose costs or taxes are calculated differently, or you might have
    products that require a special disclaimer to be displayed. In such circumstances,
    a subclass can *override* an inherited method; that is, you can create a method
    directly in the subclass that takes precedence over the method of the same name
    from the superclass. In PHP, overriding a method is straightforward: if a subclass
    declaration implements a method matching one that would have been inherited from
    a superclass, then the subclass’s method will be used.'
  prefs: []
  type: TYPE_NORMAL
- en: The Flow of Control for Object-Oriented Systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each type of programming language has a *flow of control*, which indicates how
    a computer system starts running and how it decides what to do next, after it’s
    started. As you’ve seen in the last several chapters, the flow of control for
    a procedural PHP web application usually is driven by a front controller in the
    *index.php* PHP script. When the web server receives an HTTP request, the statements
    in *index.php* are executed in sequence. In an object-oriented application, however,
    where many of the PHP files are devoted to declaring classes of objects, the flow
    of control may seem a bit more obscure. When do objects of those classes actually
    get created and start sending messages to one another?
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented PHP web applications still have an *index.php* script, though
    it looks a bit different from what we’ve seen previously. It typically creates
    the main application object, which serves as a front controller, and tells this
    object to process the received request and act appropriately. [Listing 17-1](#lis17-1)
    illustrates the kind of *index.php* scripts we’ll write in the coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-1: The typical code for an object-oriented index.php front controller'
  prefs: []
  type: TYPE_NORMAL
- en: First, we read in the declaration for the class (or classes) we’ll be using.
    You’ll learn a simple way to do this in [Chapter 18](chapter18.xhtml), and then
    in [Chapter 20](chapter20.xhtml) you’ll learn to use the Composer PHP command
    line tool to load class declarations in a more general way.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a new object of the WebApplication class, storing a reference
    to this new object in the $app variable. The WebApplication class will contain
    the logic for processing an HTTP request received from a web client, which is
    everything we previously would have put into the *index.php* script itself.
  prefs: []
  type: TYPE_NORMAL
- en: Then we send the message run() to the WebApplication object, which will result
    in the run() method that’s declared in the WebApplication class being executed
    for the particular $app object. The code for the run() method will include statements
    to do things like extract an action from the URL-encoded variables and check the
    session for login status. The code may also invoke other methods or create new
    objects as appropriate to complete the action requested by the web client.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, for a web application like this, the flow of control is sequential
    within the *index.php* file; the statements in that file are executed in order.
    As a result, an object is created, and the object is sent a message to start processing
    the HTTP request. From this point on, all the other logic for our web application
    will be in the methods of the WebApplication class, or other classes for which
    objects will be created as part of the execution of methods in the WebApplication
    class.
  prefs: []
  type: TYPE_NORMAL
- en: An Example Class Declaration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s now consider an example PHP class declaration. In [Listing 17-2](#lis17-2),
    we declare a class named Player, such as might be part of an online game system.
    Don’t worry too much about the specifics of the code; we’ll cover how to write
    PHP classes in much more detail in later chapters. For now, this example simply
    offers a glimpse of the type of code that’s to come.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-2: The PHP code to declare a Player class'
  prefs: []
  type: TYPE_NORMAL
- en: We use the class keyword to declare a class called Player, and we give the class
    two properties, name and highScore. Just as for variables in non-object-oriented
    PHP, you can assign a default value to a property. We do that here, setting the
    default value of highScore to 0 ❶ so that each new Player object will be created
    with an initial high score of 0\. We next declare the setName() method ❷, which
    when invoked will take in a string parameter and store it in a Player object’s
    name property. Then we declare the setHighScore() method ❸. It takes in a parameter
    ($newScore), and if this new score is higher than the stored high score for the
    object, then the new score is stored in the object’s highScore property.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a method is executed, it will be working on the properties of a particular
    object created from the class the method is defined in. In the method’s definition,
    the special PHP keyword $this refers to the object on which the method will be
    invoked. Thus, in the definition for the setName() method, we use the $this keyword
    (as in $this->name = $name;) as a stand-in for whichever Player object is being
    assigned a name. For example, I might have an object $player1 whose name I set
    to "Matt", and a second object $player2 whose name I set to "Aoife". In both cases,
    the setName() method code ❷ would be invoked to assign the name, and in both cases
    $this would stand for the Player object whose name is being set: first $player1
    and then $player2.'
  prefs: []
  type: TYPE_NORMAL
- en: Our class declaration includes examples of information hiding, in that the name
    and highScore properties are declared as private. They can’t be changed by code
    from outside the Player class. However, we’ve also declared the setName() and
    setHighScore() methods as public. These *setter* methods allow for outside communication
    with Player objects, but only through internal validation checks coded in the
    methods (such as checking that a new score exceeds the previous high score before
    overwriting the highScore property); these checks ensure that the object’s data
    is never set to invalid or inconsistent values.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that each method in [Listing 17-2](#lis17-2) is short and simple. Once
    the architecture of an application has been created, writing code to declare each
    property and method of a class is often relatively straightforward. While the
    methods for a full web application will be longer than those shown in this example,
    one benefit of OOP is that it typically allows programmers to focus on writing
    one method of a class at a time, with each method having one clear responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: With OOP, you don’t have to think about all the ways the method could be used;
    you only need to make sure that what you’re writing is a correct behavior for
    the class. For example, it doesn’t matter if a Player object’s name is being set
    for the first time at the start of the game, is being updated in the middle of
    the game because the player changed their mind, or is being changed automatically
    because the player was turned into a frog. The point is to write the setName()
    method so that it requires valid parameters and results in the correct changes
    to the Player object’s properties. As such, the code will be easy to write and
    maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we surveyed some of the important OOP concepts. You saw that
    classes are templates for creating objects and that classes allow you to store
    all the variables and functions an object needs in one place, a concept called
    *encapsulation*. You also saw that objects can link to each other through their
    properties and that objects of different subclasses can inherit shared properties
    and methods from superclasses. Finally, you had a first look at some of the PHP
    code that implements these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few chapters, you’ll learn how to declare classes, create objects,
    and send messages to objects to invoke their methods and change their data. You’ll
    then begin to put all that knowledge together to create well-organized object-oriented
    web applications building on the features we’ve explored in all the previous chapters.
    As you read ahead, don’t forget that you already know many of the core requirements
    for writing object-oriented PHP programs, since OOP comes down to declaring variables
    and writing PHP statements in functions; it’s just that the variables (properties)
    and functions (methods) are grouped (encapsulated) together in classes, and that
    the methods will be invoked in response to messages sent to objects of the classes.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Choose a computer system, such as an online store, an application on your
    desktop or laptop, or an app on your phone or tablet. Think about some of the
    classes of objects that system might be using. Choose one class of object and
    write a list of the pieces of data it might store, as well as some of the methods
    it might need in order to work on that data.
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Thinking again of the classes from Exercise 1, try to identify one data
    property that you would want to restrict access to, so that it could be changed
    only through a method that would log the change.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Consider a computer system for a library. Think of two classes of objects
    the computer system might use that share several data properties and methods (for
    example, different types of items the library offers for lending). Now generalize
    those common properties and methods into a suitably named superclass, and draw
    a class diagram like [Figure 17-4](#fig17-4) that shows which properties and methods
    are inherited from the superclass and which are specific to each subclass.
  prefs: []
  type: TYPE_NORMAL
