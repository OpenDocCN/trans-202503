- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PYTHON
    REFRESHER</samp>
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: If you’re looking to work on Dash apps, you probably already know at least a
    little bit of Python. This book doesn’t assume you’re an expert, however, so here
    we’ll review some important Python concepts that are more relevant to working
    with Dash, including lists, dictionaries, object-oriented programming, and decorator
    functions. If you’re already really confident in your abilities in these areas,
    feel free to skip to [Chapter 2](chapter2.xhtml), which covers PyCharm, the Python
    IDE that we’ll use throughout this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Lists</samp>
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s quickly revise the most important container data type used in practically
    all Dash apps: Python lists! Lists are important in Dash because they are used
    to define the layout, they are used to incorporate Dash Bootstrap themes, and
    they are commonly seen inside the callback and in figures built by Plotly.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'The list container type stores a sequence of elements. Lists are mutable, meaning
    you can modify them after they’ve been created. Here we create a list named <samp
    class="SANS_TheSansMonoCd_W5Regular_11">lst</samp> and print its length:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2, 2]</samp>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(len(lst))</samp>
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'Our output is simply:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: We create a list using square brackets and comma-separated elements. Lists can
    hold arbitrary Python objects, duplicate values, and even other lists, so they
    are among the most flexible container types in Python. Here we populated our list
    <samp class="SANS_TheSansMonoCd_W5Regular_11">lst</samp> with three integer elements.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp> function returns
    the number of elements in a list.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Adding Elements</samp>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three common ways to add elements to a list that already exists:
    appending, inserting, and concatenation.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">append()</samp> method places
    its argument at the end of the list. Here’s an example of appending:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2, 2]</samp>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.append(4)</samp>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'This will print:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2, 2, 4]</samp>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">insert()</samp> method inserts
    an element at a given position and moves all subsequent elements to the right.
    Here’s an example of inserting:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2, 4]</samp>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.insert(2,2)</samp>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'This prints the same result:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2, 2, 4]</samp>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, concatenation:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print([1, 2, 2] +</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">[4])</samp>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'We get:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2, 2, 4]</samp>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: For concatenation, we use the plus (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>)
    operator. This creates a new list by gluing together two existing lists.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: All operations generate the same list, <samp class="SANS_TheSansMonoCd_W5Regular_11">[1,
    2, 2, 4]</samp>. The append operation is the fastest because it neither has to
    traverse the list to insert an element at the correct position as inserting does,
    nor has to create a new list out of two sublists as concatenation does.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'To append multiple elements to a given list, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">extend()</samp>
    method:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2]</samp>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.extend([2, 4])</samp>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'The code changes the existing list object <samp class="SANS_TheSansMonoCd_W5Regular_11">lst</samp>
    as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2, 2, 4]</samp>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is an example of a list that’s able to hold duplicate values.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Removing Elements</samp>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'We can remove an element <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    from a list with <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.remove(x)</samp>,
    like so:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2, 2, 4]</samp>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.remove(1)</samp>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us the result:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[2, 2, 4]</samp>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: This method operates on the list object itself—no new list is created, and the
    original list is altered.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Reversing Lists</samp>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'You can reverse the order of the list elements using the method <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.reverse()</samp>:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [1, 2, 2, 4]</samp>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.reverse()</samp>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(l)</samp>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'This prints:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[4, 2, 2, 1]</samp>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Reversing the list also modifies the original list object rather than creating
    a new list object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Sorting Lists</samp>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'You can sort the list elements using the method <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.sort()</samp>:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [2, 1, 4, 2]</samp>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.sort()</samp>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'We see the sorted list:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2, 2, 4]</samp>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, sorting the list modifies the original list object. The resultant list
    is sorted in ascending order by default. To sort in descending order, you pass
    <samp class="SANS_TheSansMonoCd_W5Regular_11">reverse=True</samp>, as shown here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [2, 1, 4, 2]</samp>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.sort(reverse=True)</samp>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'And we see the result is in reverse order:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[4, 2, 2, 1]</samp>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also specify a <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>
    function and pass it as the parameter key to <samp class="SANS_TheSansMonoCd_W5Regular_11">sort()</samp>
    to customize the sorting behavior. The <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>
    function simply transforms one list element into an element that is sortable.
    For example, it might transform an unsortable object such as a Dash component
    into a sortable type by using the Dash component’s string identifier as a key.
    Generally, these <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp> functions
    allow you to sort lists of custom objects; for example, sorting a list of staff
    objects by their age. The following example sorts the list but uses the inverse,
    negative value of an element as a <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst = [2, 1, 4, 2]</samp>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">lst.sort(key=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">lambda
    x:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">−</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">x)</samp>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(lst)</samp>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[4, 2, 2, 1]</samp>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp> of element <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4</samp> is the negative value <samp class="SANS_TheSansMonoCd_W5Regular_11">−</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, which is the smallest value
    among all list elements. Because the list is sorted in ascending manner, this
    is the first value of the resultant sorted list.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Indexing List Elements</samp>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'You can determine the index of a specified list element <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    using the method <samp class="SANS_TheSansMonoCd_W5Regular_11">list.index(x)</samp>,
    like so:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print([2, 2, 4].index(2))</samp>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print([2, 2, 4].index(2,1))</samp>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The method <samp class="SANS_TheSansMonoCd_W5Regular_11">index(x)</samp> finds
    the first occurrence of the element <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    in the list and returns its index.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify a starting index by passing a second argument that sets the
    index from which to start the search. Consequently, while the first line prints
    the index of the first occurrence of the value 2, the second line prints the index
    of the first occurrence of the value 2 but starts the search from index 1\. The
    method immediately finds the value 2 in both cases and prints:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_11">INDEXING BASICS</samp>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Book_11">Here’s a quick overview of indices in
    Python, by example. Suppose we have the string</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">'universe'</samp><samp
    class="SANS_Futura_Std_Book_11">. The indices are simply the positions of the
    characters of this string, starting at 0:</samp>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Book_11">Index             0      1      2      3      4      5      6      7</samp>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Book_11">Character      u      n      i       v       e      r      s      e</samp>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Book_11">The first character has index 0, the second
    character has index 1, and the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp><samp
    class="SANS_Futura_Std_Book_11">-th character has index</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">−</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Slicing</samp>
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Slicing* is the process of carving out a substring from a given string. We
    call that substring a *slice*. The slicing notation is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">string[start:stop:step]</samp>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> argument is
    the index at which we want to start the string and is included in the slice, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">stop</samp> is the index at which
    we want the string to stop and is excluded from the slice. Forgetting that the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">stop</samp> index is excluded is
    a common source of bugs, so bear it in mind. The <samp class="SANS_TheSansMonoCd_W5Regular_11">step</samp>
    argument tells Python which elements to include, so a <samp class="SANS_TheSansMonoCd_W5Regular_11">step</samp>
    of 2 would include every other element and a <samp class="SANS_TheSansMonoCd_W5Regular_11">step</samp>
    of 3 would include every third element. Here’s an example with a step size of
    2:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">s = '----p-y-t-h-o-n----'</samp>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(s[4:15:2])</samp>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'This will give us:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">python</samp>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">python</samp>
- en: 'All three arguments are optional, so you can skip them to use the default values
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">start=0</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">stop=len(string)</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">step=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    Leaving out the <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> argument
    before the slicing colon indicates that the slice starts from the first position,
    and leaving out the <samp class="SANS_TheSansMonoCd_W5Regular_11">stop</samp>
    argument ends the slice at the final element. Leaving out the <samp class="SANS_TheSansMonoCd_W5Regular_11">step</samp>
    argument assumes a step of 1\. Here we skip the <samp class="SANS_TheSansMonoCd_W5Regular_11">step</samp>
    argument:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个参数都是可选的，因此你可以跳过它们，使用默认值 <samp class="SANS_TheSansMonoCd_W5Regular_11">start=0</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">stop=len(string)</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">step=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。在切片冒号前省略 <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp>
    参数表示切片从第一个位置开始，省略 <samp class="SANS_TheSansMonoCd_W5Regular_11">stop</samp> 参数表示切片在最后一个元素处结束。省略
    <samp class="SANS_TheSansMonoCd_W5Regular_11">step</samp> 参数表示步长为 1。这里我们省略了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">step</samp> 参数：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 'universe'</samp>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 'universe'</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x[2:4])</samp>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x[2:4])</samp>
- en: 'This gives us:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">iv</samp>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">iv</samp>
- en: 'Here we specify the start but not the stop, and give a step of 2, so we get
    every other character, starting at the third character and going to the end of
    the string:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们指定了起始位置但没有指定结束位置，并给定了步长为 2，因此我们从第三个字符开始，跳过每个字符，直到字符串的末尾：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 'universe'</samp>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">x = 'universe'</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x[2::2])</samp>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(x[2::2])</samp>
- en: 'This gives us:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">ies</samp>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ies</samp>
- en: 'If we accidentally give a <samp class="SANS_TheSansMonoCd_W5Regular_11">stop</samp>
    index that overshoots the maximal sequence index, Python will just assume we meant
    to end the slice at the end of the original string. Here is an example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不小心给出了一个超出最大序列索引的 <samp class="SANS_TheSansMonoCd_W5Regular_11">stop</samp>
    索引，Python 会假设我们是想让切片在原始字符串的末尾结束。这里是一个例子：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">word = "galaxy"</samp>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">word = "galaxy"</samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(word[4:50])</samp>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(word[4:50])</samp>
- en: 'This prints:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这打印出：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">xy</samp>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">xy</samp>
- en: Just remember that nothing unexpected happens if slicing overshoots sequence
    indices.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，如果切片超出序列索引，什么意外情况也不会发生。
- en: You can also provide negative integers for all three arguments. A negative index
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">stop</samp>
    tells Python to count from the end. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">string[</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">3:]</samp>
    would start slicing with the third-to-last element and <samp class="SANS_TheSansMonoCd_W5Regular_11">string[</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">10:</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">5]</samp>
    would start slicing with the tenth-to-last element (included) and stop with the
    fifth-to-last element (excluded). A negative step size means that Python slices
    from the right to the left. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">string[::</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">1]</samp>
    would reverse the string and <samp class="SANS_TheSansMonoCd_W5Regular_11">string[::</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">–</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">2]</samp>
    would take every other character, starting from the last and moving forward toward
    the left.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Dictionaries</samp>
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *dictionary* is a useful data structure for storing key-value pairs. We
    define a dictionary in curly brackets, like so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">calories = {''apple'': 52, ''banana'':
    89, ''choco'': 546}</samp>'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'The key comes first, followed by a colon, and then the value. The key-value
    pairs should be separated by commas. Here <samp class="SANS_TheSansMonoCd_W5Regular_11">''apple''</samp>
    is the first key and <samp class="SANS_TheSansMonoCd_W5Regular_11">52</samp> is
    its value. You can access individual dictionary elements by specifying which dictionary
    to take the element from and specifying the key within brackets. In the following
    example, we compare the calories of an apple to the calories of a piece of chocolate:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(calories['apple'] < calories['choco'])</samp>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, it returns:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'The dictionary is a mutable data structure, so you can change it after creation.
    For instance, you can add, remove, or update existing key-value pairs. Here we
    add a new key-value pair to the dictionary, storing the information that a cappuccino
    has 74 calories:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">calories['cappu'] = 74</samp>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(calories['banana'] < calories['cappu'])</samp>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'When we assert that a cappuccino has more calories than a banana, we get:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">keys()</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">values()</samp> functions to access
    all keys and values of the dictionary. Here we check whether the string <samp
    class="SANS_TheSansMonoCd_W5Regular_11">''apple''</samp> is one of the dictionary
    keys and the integer <samp class="SANS_TheSansMonoCd_W5Regular_11">52</samp> is
    one of the dictionary values. Both are in fact <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print('apple' in calories.keys())</samp>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(52 in calories.values())</samp>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'To access all key-value pairs of a dictionary, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">dictionary.items()</samp>
    method. In the following <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, we iterate over each <samp class="SANS_TheSansMonoCd_W5Regular_11">(key,
    value)</samp> pair in the <samp class="SANS_TheSansMonoCd_W5Regular_11">calories</samp>
    dictionary and check whether each value is more than 500 calories. If this is
    the case, it prints the associated key:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">for key, value in calories.items():</samp>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   if value > 500:</samp>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      print(key)</samp>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Our only result is:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">'choco'</samp>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: This gives us an easy way to iterate over all keys and all values in a dictionary
    without accessing them individually.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">List Comprehension</samp>
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: List comprehension is a compact way of creating lists with the simple one-liner
    formula <samp class="SANS_TheSansMonoCd_W5Regular_11">[expression</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">context]</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> tells Python
    which elements to add to the new list. The <samp class="SANS_TheSansMonoCd_W5Regular_11">expression</samp>
    defines what to do with each of those new elements before adding them. For example,
    the list comprehension statement
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[x for x in range(3)]</samp>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'creates the new list <samp class="SANS_TheSansMonoCd_W5Regular_11">[0, 1, 2]</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> in this example
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">for x in range(3)</samp>, so
    the loop variable <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> takes
    on the three values 0, 1, and 2\. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is very basic in this example: it simply adds the current loop variable to the
    list without modification. However, list comprehensions are capable of handling
    far more advanced expressions.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'List comprehension is often used in dashboard applications; for example, it
    is used to create multiple options for a dropdown menu on the fly. Here we create
    a list of strings—weekdays—and then use the list in a list comprehension to create
    a list of dictionaries. We’ll use the dictionaries to create the labels and options
    for a Dash dropdown menu shown in [Figure 1-1](chapter1.xhtml#fig1-1):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">days = ['Mon', 'Tue', 'Wed', 'Thu',
    'Fri', 'Sat', 'Sun']</samp>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">options = [{''label'': day, ''value'':
    day} for day in days]</samp>'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure1-1.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: A Dash dropdown
    menu</samp>'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'The context is <samp class="SANS_TheSansMonoCd_W5Regular_11">for day in days</samp>,
    so we iterate over each weekday <samp class="SANS_TheSansMonoCd_W5Regular_11">''Mon'',</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">…,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">''Sun''</samp>.
    The expression creates a dictionary with two key-value pairs, <samp class="SANS_TheSansMonoCd_W5Regular_11">{''label'':
    day, ''value'': day}</samp>. This is a very concise way to create the following
    list of dictionaries:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">[{''label'': ''Mon'', ''value'':
    ''Mon''}, {''label'': ''Tue'', ''value'': ''Tue''},'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '{''label'': ''Wed'', ''value'': ''Wed''}, {''label'': ''Thu'', ''value'': ''Thu''},'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '{''label'': ''Fri'', ''value'': ''Fri''}, {''label'': ''Sat'', ''value'': ''Sat''},'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '{''label'': ''Sun'', ''value'': ''Sun''}]</samp>'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative is to use a regular Python <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, as shown in these three lines:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">options = []</samp>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">for day in days:</samp>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   options.append({''label'':
    day, ''value'': day})</samp>'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: You create a list of dictionaries where both the label and the value are associated
    with the respective day. Here the dropdown menu will show the label <samp class="SANS_TheSansMonoCd_W5Regular_11">'Mon'</samp>
    and, if selected by the user, will associate the label with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">'Mon'</samp>
    to it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'The context consists of an arbitrary number of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements. We could
    use an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement within
    the list comprehension to filter results; for example, we can create dropdown
    options with only weekdays:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">options = [{''label'': day, ''value'':
    day} for day in days if day not in [''Sat'', ''Sun'']]</samp>'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Here we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    to exclude <samp class="SANS_TheSansMonoCd_W5Regular_11">Sat</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Sun</samp> from the resultant list. It’s
    a quicker, more concise way of writing this regular <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement within a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Object-Oriented Programming</samp>
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Python, everything is an object. Even integer values are objects. This is
    different from programming languages like C, where integers, floats, and Booleans
    are primitive data types. In this way, Python is built on a rigorously consistent
    object-oriented paradigm.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Classes and Objects</samp>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: At the heart of object-oriented Python are classes. Classes are blueprints for
    creating objects. A class description tells you what an object looks like and
    what it can do, respectively known as the object’s *data* and *functionality*.
    The data is defined in *attributes*, which are variables associated with a given
    object. The functionality is defined in *methods*, which are functions associated
    with the given object.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see these concepts in action using Harry Potter examples. First we’ll
    make a class with attributes but no methods. Here we create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>
    class and make two <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>
    objects from it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">class Muggle:</samp>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   def __init__(self, age, name,
    liking_person):</samp>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.age =</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">age</samp>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.name = name</samp>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.likes = liking_person</samp>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Vernon = Muggle(52, "Vernon",
    None)</samp>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Petunia = Muggle(49, "Petunia",
    Vernon)</samp>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: We create a new blueprint for <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>
    objects using the keyword <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp>.
    This dictates what data every <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>
    object will have and what it can do. Here we say that each <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>
    object should have an age, a name, and someone they like.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: For every class, you must use the method <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__()</samp>
    to initialize the class with data. Every <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>
    object will have the attributes <samp class="SANS_TheSansMonoCd_W5Regular_11">age</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">likes</samp>.
    By passing them in as arguments to the <samp class="SANS_TheSansMonoCd_W5Regular_11">def</samp>
    statement, we make them required arguments when creating an object. The first
    value of any class method is a reference to the object itself, denoted as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">self</samp>. As soon as you call the initialization
    method in your code, Python creates an empty object you can access using the name
    <samp class="SANS_TheSansMonoCd_W5Regular_11">self</samp>.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '*Although the first argument is self when defining a method, you don’t actually
    specify this argument when calling the method. Python does it for you internally.*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create an object from the class, the initialization method <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__</samp>
    is automatically called first to instantiate a new object by using the name of
    the class as a function call. The calls <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle(52,
    "Vernon", None)</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle(49,
    "Petunia", Vernon)</samp> create two new class objects, both defining the three
    attributes, shown here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   age = 52</samp>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   name = "Vernon"</samp>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   likes = None</samp>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   age = 49</samp>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   name = "Petunia"</samp>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   likes = "Vernon"</samp>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: You can see that these objects follow the same blueprint but are different instances
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Muggle</samp>; they have the
    same properties but different DNA.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: From now on, these objects live in your computer’s memory until Python kills
    them when the program terminates.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Can you see the tragic element of the story so far? Petunia likes Vernon, but
    Vernon likes nobody. Let’s cheer this up a bit, shall we? We’ll change the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">likes</samp> attribute for <samp class="SANS_TheSansMonoCd_W5Regular_11">Vernon</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Petunia</samp>. We can access
    the different attributes of an object using the name of the object, dot notation,
    and then the name of the attribute, like so:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Vernon.likes = "Petunia"</samp>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(Vernon.likes)</samp>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'This will print:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Petunia</samp>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define the <samp class="SANS_TheSansMonoCd_W5Regular_11">Wizard</samp>
    class so that we can create some wizards in our small world. This time we’ll add
    some functionality:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">class Wizard:</samp>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   def __init__(self, age, name):</samp>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.age = age</samp>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.name = name</samp>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      self.mana = 100</samp>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   def love_me(self, victim):</samp>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      if self.mana >= 100:</samp>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         victim.likes = self.name</samp>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         self.mana =</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">self.mana</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">–</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Wiz = Wizard(42, "Tom")</samp>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Every <samp class="SANS_TheSansMonoCd_W5Regular_11">Wizard</samp> object has
    three attributes: <samp class="SANS_TheSansMonoCd_W5Regular_11">age</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">mana</samp>
    level (how much magic power the wizard has left). The <samp class="SANS_TheSansMonoCd_W5Regular_11">age</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> attributes are set
    when you create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Wizard</samp>
    object according to the values passed in as arguments. The <samp class="SANS_TheSansMonoCd_W5Regular_11">mana</samp>
    attribute is hardcoded to <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__</samp> method. For
    example, calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Wizard(42, "Tom")</samp>
    would set <samp class="SANS_TheSansMonoCd_W5Regular_11">self.age</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">42</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">self.name</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">"Tom"</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">self.mana</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: We also add the method <samp class="SANS_TheSansMonoCd_W5Regular_11">love_me()</samp>,
    which casts a love spell on the victim. If the wizard has enough mana left, they
    can force the victim to love them by setting the victim’s <samp class="SANS_TheSansMonoCd_W5Regular_11">likes</samp>
    attribute to the caster’s name. However, this only works if the mana level of
    the wizard is greater than or equal to 100 (<samp class="SANS_TheSansMonoCd_W5Regular_11">self.mana</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>).
    When successful, the victim’s <samp class="SANS_TheSansMonoCd_W5Regular_11">likes</samp>
    attribute points to the casting wizard’s name and the casting wizard’s mana level
    reduces by 100.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve created a 42-year-old wizard named Tom. Tom is lonely and wants to be
    liked. Let’s get Petunia and Vernon to love him. We access an object’s methods
    using the dot notation and pass in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Petunia</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Vernon</samp> objects:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Wiz.love_me(Petunia)</samp>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Wiz.love_me(Vernon)</samp>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print(Petunia.likes=="Tom" and
    Vernon.likes=="Tom")</samp>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Can you tell whether Tom was successful in making both Petunia and Vernon love
    him?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common sources of confusion in object-oriented programming is
    forgetting to include the <samp class="SANS_TheSansMonoCd_W5Regular_11">self</samp>
    argument when defining a method. Another is that the definition of the initialization
    method uses the syntax <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__()</samp>,
    whereas you’d call the class creation method using the syntax <samp class="SANS_TheSansMonoCd_W5Regular_11">ClassName()</samp>
    and not <samp class="SANS_TheSansMonoCd_W5Regular_11">ClassName.__init__()</samp>,
    as you might expect. This is shown in the code where we do not call <samp class="SANS_TheSansMonoCd_W5Regular_11">Wizard.__init__(20,
    'Ron')</samp> but simply call <samp class="SANS_TheSansMonoCd_W5Regular_11">Wizard(20,
    'Ron')</samp> to create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Wizard</samp>
    object.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: This has been a brief overview of object-oriented programming in Python, but
    it’s worth ensuring that you fully understand how to build classes and objects
    in Python.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: For further information, you can check out the cheat sheet on object-oriented
    programming at [*https://<wbr>blog<wbr>.finxter<wbr>.com<wbr>/object<wbr>-oriented<wbr>-programming<wbr>-terminology<wbr>-cheat<wbr>-sheet*](https://blog.finxter.com/object-oriented-programming-terminology-cheat-sheet).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Terminology</samp>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Here we’ll quickly sweep through a few key definitions in object-oriented Python.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '**Class      **A blueprint to create objects. The class defines the data (attributes)
    and functionality (methods) of the objects. You can access both attributes and
    methods via the dot notation.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '**Object      **A piece of encapsulated data with associated functionality
    that is built according to a class definition. Objects are also referred to as
    *instances* of a class. Often, an object is made to model a thing in the real
    world. For example, we might create the object <samp class="SANS_TheSansMonoCd_W5Regular_11">Obama</samp>
    according to the class definition <samp class="SANS_TheSansMonoCd_W5Regular_11">Person</samp>**.**
    An object consists of an arbitrary number of attributes and methods, encapsulated
    within a single unit.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '**Instantiation      **The process of creating an object of a class.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '**Method      **A function associated with a specific object. We define methods
    using the keyword def in the class definition. An object can have as many methods
    as you like.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '**Attribute      A** variable used to hold data associated with a class or
    instance.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**Class attribute**A variable that is created statically in the class definition
    and is shared by all objects created from that class. These are also variously
    known as *class variables***,** *static variables*, and *static attributes***.**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic attribute      **An object attribute that is defined dynamically
    during program execution, and is not defined within any method. For example, you
    can simply add a new attribute <samp class="SANS_TheSansMonoCd_W5Regular_11">my_attribute</samp>
    to any object <samp class="SANS_TheSansMonoCd_W5Regular_11">o</samp> by calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">o.my_attribute</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp>**.**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '**Instance attribute**A variable that holds data belonging to only a single
    object. Other objects do not share this variable, as they do with class attributes.
    In most cases, you create an instance attribute <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    when creating the instance using the <samp class="SANS_TheSansMonoCd_W5Regular_11">self</samp>
    variable name, like self.x = 42\. These are also known as *instance variables***.**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '**Inheritance      **A programming concept that allows you to create new classes
    as modifications of existing classes by reusing some or all of the data and functionality
    when defining the new class. That is, class A can inherit attributes or methods
    from class <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> so that it has
    the same data and functionality as class <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>**,**
    but class <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> can alter the
    behavior or add data and methods. For example, the class <samp class="SANS_TheSansMonoCd_W5Regular_11">Dog</samp>
    may inherit the attribute <samp class="SANS_TheSansMonoCd_W5Regular_11">number_of_legs</samp>
    from the class Animal. In this case, you would define the inherited class <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Dog</samp> as follows: <samp class="SANS_TheSansMonoCd_W5Regular_11">class
    Dog(Animal):</samp> followed by the body of the class.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: If you have understood these terms, you can follow most discussions about object-oriented
    programming. Mastering object orientation is an important step toward proficiency
    in Python.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Decorator Functions and Annotations</samp>
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dash relies heavily on the Python concept of *decorators* or *decorator functions*,
    which add functionality to existing code without modifying the code itself. This
    is useful if you want to modify or customize, say, the output of an existing function
    without having to change the actual code of the function. For example, you may
    not have access to a function definition, but you may still want to change the
    behavior of the function. Decorator functions to the rescue!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Think of a decorator function as a wrapper. It takes an original function, calls
    it, and modifies its behavior after the fact according to the desires of the programmer.
    This way, you can change the behavior of a function dynamically, after the function
    was originally defined.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a straightforward example. Let’s define a function that prints
    some text to the standard output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text():</samp>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello world!")</samp>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text()</samp>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello world!</samp>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'The function will always print the same message. Say you want to decorate this
    output to make it more interesting. One way is to define a new <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print()</samp>
    function; this is not yet a decorator function, because it doesn’t change the
    behavior of another function. However, it does demonstrate wrapping another function
    and modifying its behavior:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text():</samp>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello world!")</samp>
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def pretty_print():</samp>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   annotate = '+'</samp>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print(annotate * 30)</samp>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print_text()</samp>
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print(annotate * 30)</samp>
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print()</samp>
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the output looks like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++</samp>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello world!</samp>
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++</samp>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The outer function <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print()</samp>
    calls the inner function <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text()</samp>
    and embellishes the result with 30 plus (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>)
    symbols before and after the output of the inner function <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text()</samp>.
    Essentially, you *wrap* the result of the inner function and enrich it with additional
    functionality.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Decorator functions allow you to generalize code like this. For instance, you
    may want to pass an arbitrary inner function into your <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print()</samp>
    function so that you can use it on any Python function. Here we create a decorator
    function, but note that for the purposes of showing how it works, we’re creating
    this function the long way. In a moment we’ll look at the shorter way Python provides
    to do the same thing. Here’s the long version:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def pretty_print_decorator(f):</samp>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   annotate =</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">'+'</samp>
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   def pretty_print():</samp>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      print(annotate * 50)</samp>
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      f()</samp>
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      print(annotate * 50)</samp>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return pretty_print</samp>
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text():</samp>
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello world!")</samp>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text_2():</samp>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello universe!")</samp>
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use it like so:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print_decorator(print_text)()</samp>
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print_decorator(print_text_2)()</samp>
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'we’ll get output like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello world!</samp>
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello universe!</samp>
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Here the decorator function takes a function as input and returns another function
    that modifies the behavior by wrapping its output in <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    symbols. You can pass any function that prints any output and create a similar
    function that additionally wraps the output in a series of <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    symbols.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: This simple decorator function takes in a function object and applies some output
    modifications, but decorator functions can do all kinds of complicated things,
    such as analyze output, apply some extra logic, or filter out some undesired messages.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an unrealistically complicated way to build a decorator function. Because
    the pattern is so common, Python provides a convenient method that accomplishes
    the same thing with less code: you add one line of code in front of the function
    to be decorated. This line consists of the at symbol (<samp class="SANS_TheSansMonoCd_W5Regular_11">@</samp>),
    followed by the name of a decorator function you defined earlier. Here we define
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print_decorator(f)</samp>
    function, then apply it when we define the two print functions:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def pretty_print_decorator(f):</samp>
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   annotate = '+'</samp>
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   def pretty_print():</samp>
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      print(annotate * 50)</samp>
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      f()</samp>
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      print(annotate * 50)</samp>
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return pretty_print</samp>
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">@pretty_print_decorator</samp>
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text():</samp>
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello world!")</samp>
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">@pretty_print_decorator</samp>
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def print_text_2():</samp>
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   print("Hello universe!")</samp>
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'We call our two defined functions like so:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text()</samp>
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text_2()</samp>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'And we should get output like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello world!</samp>
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello universe!</samp>
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">++++++++++++++++++++++++++++++++++++++++++++++++++</samp>
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the output is exactly the same as before. But this time, rather
    than calling the decorator function <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print_factory</samp>
    explicitly, such as in <samp class="SANS_TheSansMonoCd_W5Regular_11">pretty_print_decorator(print_text)</samp>
    to decorate the existing function <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text</samp>,
    we modify the behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">print_text()</samp>
    directly using the decorator function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">@</samp>
    prefix. Each time we then call the decorated function, it is automatically passed
    through the decorator function. This way, we can stack arbitrarily complicated
    function hierarchies, each adding a new layer of complexity by decorating the
    output of another function.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Decorator functions are at the heart of the Dash framework. Dash provides advanced
    functionality that you can access by applying a decorator function that is already
    defined by Dash to any of your functions with the <samp class="SANS_TheSansMonoCd_W5Regular_11">@</samp>
    annotation. Dash refers to these decorator functions as *callback decorators*.
    You’ll see plenty of these examples in the dashboard applications discussed in
    this book.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This was a very quick overview of some of the Python concepts that are most
    relevant to creating apps with Dash. If you found this difficult to follow, we
    recommend checking out the “Python Basics” appendix before you begin building
    apps.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: But before we start creating dashboard applications, let’s dive into the PyCharm
    framework we recommend you use for the book. If you’re already a PyCharm expert
    or you have a different preferred programming environment, feel free to skip to
    [Chapter 3](chapter3.xhtml).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
