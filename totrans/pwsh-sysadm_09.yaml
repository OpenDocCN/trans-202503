- en: '8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RUNNING SCRIPTS REMOTELY
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you’re the sole IT person in a small organization, chances are you have several
    servers to manage. If you have a script you need to run, you could log in to each
    server, open up the PowerShell console, and run your script there. But you can
    save a lot of time if you run one script that performs a particular task on each
    server. In this chapter, you’ll learn how to run commands remotely using PowerShell
    remoting.
  prefs: []
  type: TYPE_NORMAL
- en: '*PowerShell remoting* is a feature that allows a user to remotely run commands
    in a session on one or many computers at once. A *session*, or more specifically,
    a `PSSession`, is a PowerShell remoting term that refers to the environment running
    PowerShell on a remote computer from which you can execute commands. Though executed
    differently, the Microsoft Sysinternals tool `psexec` is the same concept: you
    write code that works on your local machine, send that code over to a remote computer,
    and execute the code as if you were sitting in front of it.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll spend most of this chapter looking at sessions—what they are, how to use
    them, and what to do when you’re done with them—but first, you’ll need to understand
    a few things about scriptblocks.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Microsoft introduced PowerShell remoting in PowerShell v2, which is built
    on top of the* Windows Remote Management (WinRM) *service. For this reason, you
    may, on occasion, see the term WinRM used to refer to PowerShell remoting.*'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Scriptblocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PowerShell remoting makes extensive use of *scriptblocks*, which, like functions,
    are code packaged into a single executable unit. But they’re different from functions
    in a couple of key ways: they’re anonymous—or unnamed—and they can be assigned
    to variables.'
  prefs: []
  type: TYPE_NORMAL
- en: To examine this difference, let’s consider an example. Let’s define a function,
    called `New-Thing`, which calls `Write-Host` to display some text in the console
    (see [Listing 8-1](ch08.xhtml#ch8list1)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-1: Defining the `New-Thing` function, which displays text in the
    console window*'
  prefs: []
  type: TYPE_NORMAL
- en: If you run this script, you should see that it returns the text `"Hi! I am in
    New-Thing!"` to the console. But notice that for this result, you had to call
    `New-Thing` for the function to run.
  prefs: []
  type: TYPE_NORMAL
- en: You can replicate the result of the `New-Thing` function call with a scriptblock
    by first assigning the scriptblock to a variable, as in [Listing 8-2](ch08.xhtml#ch8list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-2: Creating a scriptblock and assigning it to a variable called
    `$newThing`*'
  prefs: []
  type: TYPE_NORMAL
- en: To build a scriptblock, place the code you want to execute between curly brackets.
    You stored our scriptblock in the `$newThing` variable, and you might think that
    to execute that scriptblock, you could simply call the variable, as shown in [Listing
    8-3](ch08.xhtml#ch8list3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-3: Creating and executing a scriptblock*'
  prefs: []
  type: TYPE_NORMAL
- en: But as you can see, PowerShell reads the contents of `$newThing` literally.
    It doesn’t realize that `Write-Host` is a command it should execute and instead
    displays the value of the scriptblock.
  prefs: []
  type: TYPE_NORMAL
- en: To tell PowerShell to run the code inside, you need to use an ampersand (`&`)
    followed by the variable name. [Listing 8-4](ch08.xhtml#ch8list4) shows this syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-4: Executing a scriptblock*'
  prefs: []
  type: TYPE_NORMAL
- en: The ampersand tells PowerShell that the stuff between the curly brackets is
    code that it should run. The ampersand is one way to execute a code block; however,
    it does not allow you the customization a command would, which you’ll need when
    using PowerShell remoting to work on remote computers. The next section covers
    another way to execute scriptblocks.
  prefs: []
  type: TYPE_NORMAL
- en: Using Invoke-Command to Execute Code on Remote Systems
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll use two main commands when working with PowerShell remoting: `Invoke-Command`
    and `New-PSSession`. In this section, you’ll learn about `Invoke-Command`; the
    next section covers the `New-PSSession` command.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Invoke-Command` is probably the command you’ll use the most with PowerShell
    remoting. There are two main ways to use it. The first is when you run what I
    call *ad hoc commands*—small, one-off expressions you want to execute. The second
    is using interactive sessions. We’ll cover both in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: An example of an ad hoc command is when you run `Start-Service` to start a service
    on a remote computer When you execute an ad hoc command by using `Invoke-Command`,
    PowerShell creates a session behind the scenes, tearing it down as soon as the
    command has completed. This limits what you can do with just `Invoke-Command`,
    which is why in the next section, you’ll see how to create your own sessions.
  prefs: []
  type: TYPE_NORMAL
- en: But for now, let’s see how `Invoke-Command` works with an ad hoc command. Open
    your PowerShell console, type `Invoke-Command`, and press ENTER, as in [Listing
    8-5](ch08.xhtml#ch8list5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-5: Running `Invoke-Command` with no parameters*'
  prefs: []
  type: TYPE_NORMAL
- en: Your console should immediately ask you to provide a scriptblock. You’ll provide
    the `hostname` command, which will return the hostname of the computer the command
    is run on.
  prefs: []
  type: TYPE_NORMAL
- en: To pass a scriptblock with `hostname` to `Invoke-Command`, you need to use the
    required parameter, `ComputerName`, which tells `Invoke-Command` which remote
    computer to run this command on, as you can see in [Listing 8-6](ch08.xhtml#ch8list6).
    (Note that for this to work, my machine and the remote computer `WEBSRV1` have
    to be part of the same Active Directory (AD) domain, and my machine needs to have
    admin rights on `WEBSRV1`.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-6: Running a simple `Invoke-Command` example*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the output of `hostname` is now the name of the remote computer—in
    my system, the remote computer is called `WEBSRV1`. You’ve now executed your first
    remote command!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you try this on a remote machine with an operating system older than Windows
    Server 2012 R2, it might not work as expected. If this is the case, you’ll first
    have to enable PowerShell remoting. As of Server 2012 R2, PowerShell remoting
    is enabled, by default, with the WinRM service running with all the necessary
    firewall ports open and access rights set up. But if you’re running an earlier
    version of Windows, this has to be done manually, so run Enable-PSRemoting on
    your remote computer in an elevated console session first before attempting to
    run Invoke-Command against an older server. You may also use the Test-WSMan command
    to confirm whether PowerShell remoting is configured and available.*'
  prefs: []
  type: TYPE_NORMAL
- en: Running Local Scripts on Remote Computers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the previous section, you executed scriptblocks on remote computers. You
    can also use `Invoke-Command` to execute entire scripts. Instead of using the
    `Scriptblock` parameter, you can use the `FilePath` parameter and a path to a
    script on your machine. When using the `FilePath` parameter, `Invoke-Command`
    will read the contents of the script locally and then execute that code on the
    remote computer. Contrary to popular belief, the script itself isn’t executed
    on the remote computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, let’s say you have a script on your local computer in the root
    of *C:\* called *GetHostName.ps1*. This script has one line in it: `hostname`.
    You’d like to run this script on a remote computer to return the computer’s hostname.
    Note that while we’re keeping the script extremely simple, `Invoke-Command` doesn’t
    care what’s inside the script. It will happily execute whatever is there.'
  prefs: []
  type: TYPE_NORMAL
- en: To run the script, you pass the script file to the `FilePath` parameter on `Invoke-Command`,
    as shown in [Listing 8-7](ch08.xhtml#ch8list7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-7: Running a local script on remote computers*'
  prefs: []
  type: TYPE_NORMAL
- en: '`Invoke-Command` runs the code inside *GetHostName.ps1* on the `WEBSRV1` computer
    and returns the output back to your local session.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Local Variables Remotely
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Though PowerShell remoting takes care of a lot of things, you have to watch
    out when using local variables. Let’s say you have a file path on a remote computer
    that’s *C:\File.txt*. Because this file path may change at some point, you may
    decide to assign that path as a variable; for example, `$serverFilePath`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, you may need to reference the *C:\File.txt* path inside a remote scriptblock.
    In [Listing 8-8](ch08.xhtml#ch8list8), you can see what happens when you attempt
    to reference the variable directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-8: Local variables do not work in remote sessions.*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `$serverFilePath` variable doesn’t have a value, because while
    inside the scriptblock being executed on the remote computer, the variable doesn’t
    exist! When you define a variable in a script or at the console, that variable
    is stored in a particular *runspace*, which is a container that PowerShell uses
    to store the information for the session. You may have run into runspaces if you’ve
    tried to open two PowerShell consoles at the same time and (failed to) use the
    variables of one in the other.
  prefs: []
  type: TYPE_NORMAL
- en: By default, variables, functions, and other constructs can’t spread over multiple
    runspaces. However, you can use a couple of methods to use variables, functions,
    and so forth, in various runspaces. There are two main ways to transfer variables
    to a remote computer.
  prefs: []
  type: TYPE_NORMAL
- en: Passing Variables with the ArgumentList Parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To get the value of a variable into a remote scriptblock, you can use the `ArgumentList`
    parameter on `Invoke-Command`. This parameter allows you to pass an array of local
    values to the scriptblock, called `$args`, which you can use in your scriptblock’s
    code. To show how this works, in [Listing 8-9](ch08.xhtml#ch8list9), you’ll pass
    the `$serverFilePath` variable, which contains the file path *C:\File.txt*, to
    the remote scriptblock and then reference it through the `$args` array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-9: Using the `$args` array to pass local variables to a remote session*'
  prefs: []
  type: TYPE_NORMAL
- en: As you should see, the variable’s value, *C:\File.txt*, is now inside the scriptblock.
    This is because you passed `$serverFilePath` into `ArgumentList` and replaced
    the `$serverFilePath` reference inside the scriptblock with `$args[0]`. If you
    want to pass more than one variable into the scriptblock, you can add another
    value to the `ArgumentList` parameter value and increment the `$args` reference
    by one where you want to reference the new variable.
  prefs: []
  type: TYPE_NORMAL
- en: Using the $Using Statement to Pass Variable Values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another way to pass the values of local variables to a remote scriptblock is
    with the `$using` statement. You can avoid using the `ArgumentList` parameter
    by prepending `$using` to any local variable name. Before PowerShell sends the
    scriptblock to the remote computer, it will look for the `$using` statement and
    expand all the local variables inside the scriptblock.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 8-10](ch08.xhtml#ch8list10), you’ll rewrite [Listing 8-9](ch08.xhtml#ch8list9)
    to use `$using:serverFilePath` instead of `ArgumentList`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-10: Using `$using` to reference local variables in a remote session*'
  prefs: []
  type: TYPE_NORMAL
- en: As you should see, the results of [Listings 8-9](ch08.xhtml#ch8list9) and [8-10](ch08.xhtml#ch8list10)
    are the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$using` statement requires less work and is more intuitive, but down the
    road, when you begin to write Pester to test your scripts, you’ll see that you
    may have to revert to using the `ArgumentList` parameter: when using the `$using`
    option, Pester will have no way to evaluate the value in a `$using` variable.
    When using the `ArgumentList` parameter, the variables passed to the remote session
    are defined locally, which Pester can interpret and understand. If this doesn’t
    make sense now, it will when you read [Chapter 9](ch09.xhtml#ch9). For now, the
    `$using` statement works excellently!'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of the `Invoke-Command` cmdlet, let’s
    learn a few more sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Sessions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, PowerShell remoting uses a concept called a *session*.
    When you create a session remotely, PowerShell opens a *local session* on the
    remote computer, which you can use to execute commands there. You don’t need to
    know too many of the technical details of a session. What you do need to know
    is that you can create, connect to, and disconnect from a session, and it will
    maintain the same state that you left it in. The session won’t end until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, when you ran `Invoke-Command`, it brought up a new
    session, ran the code, and tore it down all in one go. In this section, you’ll
    see how to create what I call *full sessions*, sessions that you can enter commands
    into directly. Using `Invoke-Command` to execute one-off ad hoc commands works
    well, but it’s not too efficient when you need to run a lot of commands that can’t
    all squeeze into a single scriptblock. For example, if you’re working on a large
    script that performs work locally, has to grab information from another source,
    use that information in a remoting session, grab information from a remoting session
    to be used locally, and then return to the local computer, you will have to create
    a script that runs `Invoke-Command` repeatedly. On top of that, you’ll have more
    issues if you need to set a variable in the remote session and use it again later.
    Using `Invoke-Command` as you have so far, this wouldn’t work—you’ll need a session
    that stays there after you leave.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a New Session
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create a semipermanent session on a remote computer with PowerShell remoting,
    you have to explicitly create a full session by using the `New-PSSession` command,
    which will create a session on the remote computer and a reference to that session
    on your local computer.
  prefs: []
  type: TYPE_NORMAL
- en: To create a new `PSSession`, use `New-PSSession` with the `ComputerName` parameter,
    as in [Listing 8-11](ch08.xhtml#ch8list11). In this example, the computer I’m
    running this on is in the same Active Directory domain as `WEBSRV1`, and I’m logged
    in as a domain user with admin rights on `WEBSRV1`. To connect by using the `ComputerName`
    parameter (as I have in [Listing 8-11](ch08.xhtml#ch8list11)), the user must be
    a local administrator or at least in the Remote Management Users group on the
    remote computer. If you’re not in an AD domain, you can use the `Credential` parameter
    on `New-PSSession` to pass a `PSCredential` object containing an alternate credential
    to authenticate to the remote computer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-11: Creating a new `PSSession`*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `New-PSSession` returns a session. Once the session is established,
    you can jump in and out of the session with `Invoke-Command`; instead of using
    the `ComputerName` parameter, as you did with the ad hoc command, you’ll have
    to use the `Session` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: You need to provide the `Session` parameter with a session object. You can use
    the `Get-PSSession` command to see all your current sessions. In [Listing 8-12](ch08.xhtml#ch8list12),
    you’ll store the output of `Get-PSSession` in a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-12: Finding sessions created on the local computer*'
  prefs: []
  type: TYPE_NORMAL
- en: Because you ran `New-PSSession` only once, you have only one `PSSession` created
    in [Listing 8-12](ch08.xhtml#ch8list12). If you have multiple sessions, you can
    pick the session you want `Invoke-Command` to use by using the `Get-PSSession`
    command’s `Id` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking Commands in a Session
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you have a session in a variable, you can pass that variable to `Invoke-Command`
    and run some code inside the session, as in [Listing 8-13](ch08.xhtml#ch8list13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-13: Using an existing session to invoke commands on a remote computer*'
  prefs: []
  type: TYPE_NORMAL
- en: You should notice that this command runs much faster than when you passed it
    a command. This is because `Invoke-Command` doesn’t have to create and tear down
    a new session. When you create a full session, not only is it faster, but you
    also have access to more functionality. For example, as you can see in [Listing
    8-14](ch08.xhtml#ch8list14), you can set variables in the remote session and return
    to the session without losing those variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-14: Variable values remain over subsequent session connections.*'
  prefs: []
  type: TYPE_NORMAL
- en: As long as the session stays open, you can do whatever you need in the remote
    session, and the state of the session will go unchanged. However, this is valid
    for only your current local session. If you start another PowerShell process,
    you can’t just pick up where you left off. The remote session will still be active,
    but the reference to that remote session on the local computer will be gone. In
    that case, the `PSSession` will go into a disconnected state (which you’ll see
    in an upcoming section).
  prefs: []
  type: TYPE_NORMAL
- en: Opening Interactive Sessions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 8-14](ch08.xhtml#ch8list14) used `Invoke-Command` to send commands
    to a remote computer and receive a response. Running remote commands like this
    is like running an unmonitored script. It’s not interactive, as when you’re punching
    keystrokes into a PowerShell console. If you want to open an interactive console
    for the session running on a remote computer—for some troubleshooting, for example—you
    can use the `Enter-PSSession` command.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Enter-PSSession` command allows the user to work with the session interactively.
    It can either create its own session or rely on an existing one created with `New-PSSession`.
    If you do not specify a session to enter into, `Enter-PSSession` will create a
    new one and wait for further input, as in [Listing 8-15](ch08.xhtml#ch8list15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-15: Entering an interactive session*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that your PowerShell prompt changes to `[WEBSRV1]: PS`. This prompt
    indicates that you’re no longer running commands locally but in that remote session.
    At this point, you can run any command you want, as if you’re at the console of
    the remote computer. Working with sessions interactively like this is a great
    way to eliminate using the *Remote Desktop Protocol* (*RDP*) application to bring
    up an interactive GUI to perform tasks, like troubleshooting on a remote computer.'
  prefs: []
  type: TYPE_NORMAL
- en: Disconnecting from and Reconnecting to Sessions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you close your PowerShell console, open it back up again, and try to use
    `Invoke-Command` in the session you were previously working in, you will receive
    an error message, as in [Listing 8-16](ch08.xhtml#ch8list16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-16: Attempting to run commands in a disconnected session*'
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell can find the `PSSession` on the remote computer but can’t find the
    reference on the local machine, which tells you the session is disconnected. This
    is what happens if you don’t correctly disconnect the local session reference
    to the remote `PSSession`.
  prefs: []
  type: TYPE_NORMAL
- en: You can disconnect existing sessions by using the `Disconnect-PSSession` command.
    You can clean up any sessions previously created by retrieving them with `Get-PSSession`
    and then piping those sessions to the `Disconnect-PSSession` command (see [Listing
    8-17](ch08.xhtml#ch8list17)). Or, alternatively, you can use the `Session` parameter
    on `Disconnect-PSSession` to disconnect one session at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-17: Disconnecting a `PSSession`*'
  prefs: []
  type: TYPE_NORMAL
- en: To properly disconnect from a session, you pass your remote session name to
    the `Session` parameter by either calling it explicitly via `Disconnect-PSSession
    -Session` session name or piping an existing session to the command via `Get-PSSession`
    as in [Listing 8-17](ch08.xhtml#ch8list17).
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to connect to your session again later, after you’ve disconnected
    with `Disconnect-PSSession`, close your PowerShell console and then use the `Connect-PSSession`
    command, as in [Listing 8-18](ch08.xhtml#ch8list18). Note that you can see and
    connect only to disconnected sessions that your account has already created. You
    will not be able to see sessions other users have created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-18: Reconnecting to a `PSSession`*'
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to run code on the remote computer as if you never closed
    your console.
  prefs: []
  type: TYPE_NORMAL
- en: If you still receive an error message, you may have mismatched PowerShell versions.
    Disconnected sessions work only if the local machine and remote server have the
    same PowerShell version. For example, if you have PowerShell 5.1 on your local
    computer, but the remote server you’re connecting to is running a version of PowerShell
    that doesn’t support disconnected sessions (such as PowerShell v2 or older), disconnected
    sessions won’t work. Always be sure that both the local machine and remote server
    have the same PowerShell version.
  prefs: []
  type: TYPE_NORMAL
- en: To check whether your local computer’s PowerShell version matches the version
    on your remote computer, check the value of the `$PSVersionTable` variable, which
    contains versioning information (see [Listing 8-19](ch08.xhtml#ch8list19)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-19: Checking the PowerShell version on a local computer*'
  prefs: []
  type: TYPE_NORMAL
- en: To check for the version on your remote computer, run `Invoke-Command` on that
    computer, passing it the `$PSVersionTable` variable, as in [Listing 8-20](ch08.xhtml#ch8list20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-20: Checking the PowerShell version on a remote computer*'
  prefs: []
  type: TYPE_NORMAL
- en: I suggest that, before you disconnect from a session, you check that your versions
    match; that way, you can avoid losing valuable work on a remote system.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Sessions with Remove-PSSession
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Whenever the `New-PSSession` command creates a new session, that session exists
    both on the remote server and on the local computer. You can open a lot of sessions
    across many servers at the same time as well, and if some of those sessions are
    no longer in use, you may eventually need to clean them up. You can do so with
    the `Remove-PSSession` command, which goes out to the remote computer, tears down
    that session, and if it exists, removes the local `PSSession` reference. [Listing
    8-21](ch08.xhtml#ch8list21) is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-21: Removing a `PSSession`*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you see that you’re running `Get-PSSession` again, and nothing is returned.
    This means there are no sessions on your local computer.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PowerShell Remoting Authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, I’ve been ignoring the question of authentication. By default, if your
    local and remote computers are both in the same domain and both have PowerShell
    remoting enabled, you don’t need to explicitly authenticate. But if they’re not,
    you’ll need to authenticate somehow.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the most common ways you can authenticate to remote computers with PowerShell
    remoting are by using Kerberos or CredSSP. If you’re in an Active Directory domain,
    you’re probably already using a Kerberos ticket system, whether you know it or
    not. Active Directory and some Linux systems use Kerberos *realms*, entities that
    issue tickets to clients. These tickets are then presented to resources and compared
    (in Active Directory) on domain controllers.
  prefs: []
  type: TYPE_NORMAL
- en: CredSSP, on the other hand, doesn’t need Active Directory. CredSSP was introduced
    way back with Windows Vista and uses a client-side credential service provider
    (CSP) to enable applications to delegate user credentials to remote computers.
    CredSSP doesn’t require an outside system, such as a domain controller, in order
    to authenticate two systems.
  prefs: []
  type: TYPE_NORMAL
- en: In an Active Directory environment, PowerShell remoting uses the Kerberos network
    authentication protocol to make calls out to Active Directory that perform all
    the authentication under the hood. PowerShell uses the account you’re logged onto
    locally as the user in order to authenticate to the remote computer—just like
    many other services. This is the beauty of single sign-on.
  prefs: []
  type: TYPE_NORMAL
- en: But sometimes you’re forced to change up that authentication type a bit if you’re
    not in an Active Directory environment; for example, when you need to connect
    to remote computers over the internet or on the local network, but via local credentials
    on the remote computer. PowerShell supports numerous methods for PowerShell remoting
    authentication, but the most common—other than just using Kerberos—is CredSSP,
    which allows a local computer to delegate the user’s credentials to the remote
    computer. This concept is similar to Kerberos, but Active Directory is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t usually need to use a different authentication type when working in
    an Active Directory environment, but it does come up sometimes, so it’s best you’re
    prepared. In this section, you’ll learn about a common authentication issue and
    how to work around it.
  prefs: []
  type: TYPE_NORMAL
- en: The Double Hop Problem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *double hop problem* has been an issue ever since Microsoft added the PowerShell
    remoting feature. This problem arises when you’re running code inside a remote
    session, and then attempt to access remote resources from that remote session.
    For example, if you have a domain controller called DC on your network and you
    want to check out the files on the root of *C:\* by using the `C$` administrative
    share, you can browse the share remotely from your local machine without an issue
    (see [Listing 8-22](ch08.xhtml#ch8list22)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-22: Enumerating files over a UNC share*'
  prefs: []
  type: TYPE_NORMAL
- en: The issue arises when you create a `PSSession` and attempt to rerun the same
    command, as in [Listing 8-23](ch08.xhtml#ch8list23).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-23: Attempting to access network resources in a session*'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, PowerShell tells you that access is denied—even when you know
    your user account has access. This happens because, when you use the default Kerberos
    authentication, PowerShell remoting doesn’t then pass that credential to the other
    network resource. In other words, it doesn’t make both hops. For security reasons,
    PowerShell adheres to Windows restrictions and refuses to delegate those credentials,
    and as a result, returns an Access Denied message.
  prefs: []
  type: TYPE_NORMAL
- en: Double Hopping with CredSSP
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to work around the double hop problem. I say
    *work around* instead of *fix* for a reason. Microsoft has warned that using CredSSP
    is a security problem, as the credential passed to the first computer is automatically
    used for all connections from that computer. This means if the original computer
    is compromised, that credential can be used from that computer to connect to other
    computers across the network. Nevertheless, other than using some fancy workarounds,
    like resource-based Kerberos constrained delegation, many users choose to use
    the CredSSP approach because it’s easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: Before you implement CredSSP, you have to enable it on both the client and the
    server by using the `Enable-WsManCredSSP` command in an elevated PowerShell session.
    This command has a `Role` parameter, which allows you to define whether CredSSP
    is being enabled on the client or the server side. First, enable CredSSP on the
    client side, as in [Listing 8-24](ch08.xhtml#ch8list24).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To get CredSSP to work, you may have to relax a local policy. If you receive
    a permission error when trying to enable CredSSP, be sure you enable the Allow
    Delegating Saved Credentials with NTLM-only Server Authentication setting by running
    gpedit.msc and looking under Computer Configuration ▶ Administrative Templates
    ▶ System ▶ Credentials Delegation. While in the policy, click on the **Show**
    button and enter **WSMAN/*** to allow delegation from any endpoint.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-24: Enabling CredSSP support on the client computer*'
  prefs: []
  type: TYPE_NORMAL
- en: You enable CredSSP on the client by passing the value `Client` ❷ to the `Role`
    parameter ❶. You also use the required `DelegateComputer` parameter ❸ here because
    PowerShell needs to know which computers are allowed to use the credential you’ll
    be delegating it to. You could pass an asterisk (`*`) to `DelegateComputer` in
    order to allow delegation to all computers, but for security purposes, it’s better
    to just allow the computers you’re working with, in this case, `WEBSRV1`.
  prefs: []
  type: TYPE_NORMAL
- en: Once CredSSP is enabled on the client, you need to do the same on the server
    ([Listing 8-25](ch08.xhtml#ch8list25)). Luckily, you can just open up a new remote
    session without using CredSSP, and then enable CredSSP within the session—rather
    than having to use Microsoft Remote Desktop to access the server or visit it physically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-25: Enabling CredSSP support on the server computer*'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, you’ve enabled CredSSP on both the client and the server: the client
    is allowing its user credentials to be delegated to the remote server, and the
    remote server has CredSSP enabled itself. Now you can try to access remote network
    resources from that remote session again (see [Listing 8-26](ch08.xhtml#ch8list26)).
    Note that if you ever need to undo enabling CredSSP, the command `Disable-WsmanCredSSP`
    will revert your changes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-26: Accessing network resources over a CredSSP-authenticated session*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you have to explicitly tell `Invoke-Command` (or `Enter-PSSession)`
    that you’d like to use CredSSP authentication ❶, and both commands—whichever you
    use—require a credential. You get that credential by using the `Get-Credential`
    command rather than the default Kerberos ❷.
  prefs: []
  type: TYPE_NORMAL
- en: After you execute `Invoke-Command` and provide `Get-Credential` with a username
    and password with access to the `c$` share on DC, you can see the `Get-ChildItem`
    command works as expected!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PowerShell remoting is, by far, the easiest way to remotely execute code on
    remote systems. As you learned in this chapter, the PowerShell remoting feature
    is easy to use and intuitive. Once you’ve grasped the concept of a scriptblock
    and where that code inside of it is being executed, remote scriptblocks will be
    second nature to you.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part III](part3.xhtml#part3) of this book—where you will build your own
    robust PowerShell module—you’ll use PowerShell remoting in nearly every command.
    If you had trouble following along in this chapter, please go over it again or
    begin to experiment. Try different scenarios, break things, fix them, do whatever
    you can to understand PowerShell remoting. It’s one of the most important skills
    you can learn from this book.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.xhtml#ch9) covers another major skill: testing with Pester.'
  prefs: []
  type: TYPE_NORMAL
