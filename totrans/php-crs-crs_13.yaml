- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 10 CLIENT/SERVER COMMUNICATION AND WEB DEVELOPMENT BASICS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As a language of the internet, PHP is closely connected to the communications
    between web *clients* and web *servers*. In this chapter, we’ll look at how clients
    and servers work, and we’ll examine the messages that pass between them. We’ll
    also see how to efficiently embed PHP statements in static HTML code to construct
    a full HTML text file that a web browser client can understand and render onscreen
    as a web page. Finally, we’ll discuss how a typical PHP web application is structured,
    including a first look at the model-view-controller (MVC) architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you realize it or not, you probably use clients and servers every day.
    When you check your email or social media accounts, you’re using a client application
    to communicate with a server to request updates. These kinds of apps are continually
    making requests to servers; for example, your email app requests from servers
    such as Google Gmail or Apple iCloud in order to download any new email and update
    the messages and folders on your phone to mirror any changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run a web server application in two places: locally on your own computer
    or publicly on an internet-accessible computer. As a PHP programmer, you’ll do
    a lot of your software development locally on your own machine. Then, when you
    think a project is ready, you’ll test it on a public server, and finally publish
    the website live when all testing is complete.'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP Request-Response Cycle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the heart of web-based client/server communications is the *http request-response
    cycle*. At a high level, a client sends a *request* to the server, and the server
    returns a *response* to the client. The response itself may be an error code,
    or it could be a message whose body is text, an image file, a binary executable,
    or other content. [Figure 10-1](#fig10-1) illustrates a simple request-response
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure10-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-1: A simple HTTP request-response cycle'
  prefs: []
  type: TYPE_NORMAL
- en: The client, a web browser, sends a request asking for the *index.xhtml* file
    ❶. The server receives and decodes the request, then searches for and successfully
    finds the requested resource (file) ❷. The server then creates and returns a response,
    whose body is the HTML text of *index.xhtml* ❸. Finally, the web browser reads
    through the received HTML and displays the web page contents nicely to the user
    in the browser window ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clients can send different types of requests. The two most common request methods
    are GET and POST. The HTTP GET method is simpler and, when using a web browser
    client, displays much of what’s being sent in the web browser URL address bar.
    For example, if you use the Google search engine to search for the phrase *cheese
    cake*, you’ll see those words appear at the end of the URL when you send the query
    to Google: *https://www.google.com/search?q=cheese+cake*. In fact, anytime you
    type a URL into the web browser address bar and hit ENTER, you’re sending a GET
    request.'
  prefs: []
  type: TYPE_NORMAL
- en: The POST method, on the other hand, can hide much of what’s being sent in the
    body of the request message. Therefore, it’s often used for more private website
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to GET and POST, the original HTTP 1.0 defined a third method, HEAD.
    It asks for a response with no body, just the headers, which contain general information
    about the response. Since the introduction of HTTP 1.1, five other methods are
    permitted (OPTIONS, PUT, DELETE, TRACE, and CONNECT). These aren’t needed for
    the level of web development in this book, although they can be useful for sophisticated
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Response Status Codes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the beginning of every HTTP response returned by the server is a three-digit
    HTTP *status code* that tells the client the status of the server’s attempt to
    process and fulfill the request. All HTTP-compliant servers must use a set of
    standard codes, and on top of that, custom codes are used by different servers.
    The most common codes are 200 OK to indicate that a request has been successfully
    fulfilled and 404 Not Found to indicate that the server was unable to find the
    requested resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first digit of the code indicates the general status of the server’s interpretation
    and processing of the request. Here’s a summary of what the first-digit prefixes
    signify:'
  prefs: []
  type: TYPE_NORMAL
- en: 1nn **(information)**   The request headers were received and understood, and
    further processing is needed. In other words, “So far so good, but not finished
    yet.” These status codes are fairly uncommon. They’re informational and used when
    the server needs to communicate some information, but not a full response, back
    to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 2nn **(success)**   The request was received, understood, and accepted (for
    example, 200 OK).
  prefs: []
  type: TYPE_NORMAL
- en: 3nn **(redirection)**   The request was understood, but the client must take
    further action, such as choosing from options (300 Multiple Choices) or following
    a new URL if the resource has permanently moved (301 Moved Permanently).
  prefs: []
  type: TYPE_NORMAL
- en: 4nn **(client error)**   Either the request is invalid (such as 400 Bad Request),
    or the server can’t fulfill the request because of client error (such as 404 Not
    Found or 403 Forbidden).
  prefs: []
  type: TYPE_NORMAL
- en: 5nn **(server error)**   The server has experienced an error or is unable to
    complete the request for other reasons. Examples include 500 Server Error and
    502 Service Unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about HTTP and its status codes at Todd Fredrich’s free
    online REST API tutorial: *[https://www.restapitutorial.com](https://www.restapitutorial.com)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### An Example GET Request'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a simple example of the request-response cycle by examining what
    happens behind the scenes when we visit the No Starch Press website. First, you
    need to display the browser request-response inspection tools. In Google Chrome,
    these tools are usually accessible as a menu item named Developer Tools. Once
    the developer tools are open, you’ll see a window like that at the bottom of [Figure
    10-2](#fig10-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure10-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-2: A GET request to the No Starch Press home page'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Network** tab, and you’re ready to record and examine the HTTP request-response
    cycle. Type **nostarch.com** in the browser URL address bar. When you press ENTER,
    you should see the home page appear. Find the Name column on the left of the developer
    window, locate the first file, which should be *nostarch.com*, and click it. Click
    **Headers** to see the HTTP headers summary, shown in [Figure 10-3](#fig10-3).
  prefs: []
  type: TYPE_NORMAL
- en: This summary indicates that the HTTP request is for the URL *[https://nostarch.com](https://nostarch.com)*
    and that the request method is GET (since we just entered a URL in the address
    bar). The most important part of the HTTP response header is the success status
    code of 200.
  prefs: []
  type: TYPE_NORMAL
- en: Scroll farther down the HTTP headers contents and you’ll see full details of
    both the HTTP request and HTTP response headers. Under the Request Headers section,
    you can see the list of file types that the web client is willing to accept, such
    as HTML, XML, images, and so on. You can also see which human language the content
    is available in (for example, EN for English). Correspondingly, the response headers
    indicate the actual content type in the body of the response, such as text/html,
    the date the file was last modified, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The majority of modern websites now use HyperText Transfer Protocol Secure
    (HTTPS), which enables the client and server to exchange certificates allowing
    HTTP messages to be securely encrypted. This is why the No Starch Press URL begins
    with* https://*. HTTPS is built into many PHP web servers, so we won’t go into
    it at this point.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now click the **Response** tab to see the content of the response’s body, shown
    in [Figure 10-3](#fig10-3). This is the HTML text that the web browser receives
    and then renders to make an attractive-looking graphical web page for you to see
    and interact with.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure10-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-3: HTML text content in the HTTP response body'
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the HTML code, you’ll see a list of CSS links. When processing
    the received HTML, the web client (browser) looks for any additional content files
    needed for the web page, like CSS stylesheets, image files, and JavaScript files.
    The browser quickly (we rarely notice this with modern network speeds) makes additional
    HTTP requests to the server for each of these files, and as the corresponding
    HTTP responses arrive, the browser renders the web page. These extra files received
    from the web server can be seen in the Name column in [Figure 10-2](#fig10-2),
    beneath the original request to *nostarch.com*. They have names like *css_lQaZ*
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to underscore that not every HTTP request has to be initiated
    by a human user entering a URL, clicking a link, or submitting a form. The web
    browser can, behind the scenes (asynchronously), make additional requests for
    required resources such as images, CSS files, and JavaScript files. These additional
    requests may be to the same web server that delivered the HTML the browser is
    processing, or to other web servers (perhaps to download a free Google font, for
    example, or the Bootstrap CSS and JavaScript).
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*JavaScript code can also make additional HTTP requests, such as retrieving
    data from remote websites. This is known as* asynchronous JavaScript and XML (AJAX)*,
    although many types of data files may be retrieved, such as JSON and plaintext,
    so such HTTP requests aren’t limited to retrieving only XML data. This topic is
    beyond the scope of this PHP book.*'
  prefs: []
  type: TYPE_NORMAL
- en: How Servers Operate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve discussed at a high level how clients and servers communicate through
    HTTP requests and responses. Now let’s take a closer look at how web servers function.
    We’ll also begin to see how PHP can play a role in the server’s operations.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Web Servers for File Retrieval
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The task of a simple web server is to listen for requests for resources and,
    when a request is received, to identify the resource requested and return either
    a message containing the resource or an error message if it can’t be found. A
    simple web server is basically a file server that’s able to understand HTTP requests
    and send HTTP responses. [Figure 10-4](#fig10-4) illustrates a simple web server.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure10-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-4: A simple web server communication with a web client'
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the client sends a GET request ❶, requesting a file such as *index.xhtml*,
    *style.css*, or *logo.png*. The server receives and interprets the request, then
    searches for the requested resource (file) ❷. If the file can’t be found, the
    server creates and returns a 404 Not Found error. If the file is found, the server
    retrieves its contents ❸. Finally, the server creates and returns a response to
    the client ❹. The response body is the content of the requested file, and its
    header includes the 200 OK status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good analogy for this process is that a simple web server functions like
    a librarian in a library: the librarian goes off to locate a requested book and
    returns with either the book or a message saying the book can’t be located.'
  prefs: []
  type: TYPE_NORMAL
- en: Simple web servers are sufficient for hypertext or hypermedia browsing of an
    unchanging set of HTML pages, such as a set of frequently asked questions (FAQ)
    and answer paragraphs or reference materials that rarely need to be updated, like
    a user manual. Simple web servers are *stateless*, meaning the same request will
    always get the same file returned. Different clients will also get the same file
    returned. This is often termed *static* content to indicate that it’s unchanging.
    Returning to the librarian analogy, you wouldn’t expect a librarian to change
    the content of a book as they’re retrieving it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can summarize the behavior of simple stateless web servers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Never changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same regardless of whether the user has visited before
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same for every user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most web activity is more interactive than simply clicking links to specific
    static documents. The majority of modern web projects require *dynamic interactivity*,
    in which the system responds differently according to user inputs. Dynamic interactivity
    encompasses tasks like processing web forms, managing shopping carts, customizing
    content based on recent browsing history, and more. Most PHP web applications
    are *dynamic* web servers, which we’ll explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Web Servers for Processing Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For a web-based system to be interactive beyond static resource retrieval,
    further technologies are required beyond basic content markup and hypertext linking.
    These capabilities include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Support for user input methods, like inputting text, clicking buttons, and choosing
    from menus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Short code scripts that can process and respond in different ways to different
    user inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods for the browser to send user inputs or data to the server programs that
    will process the data and generate interactive responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic servers with capabilities such as these handle many typical modern internet
    activities, like entering keywords into a search engine and being presented with
    a tailor-made page of prioritized links, logging into your personal email system
    and retrieving your own email in your inbox, and browsing catalogs of products
    online and making a purchase using a credit card.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we’re most interested in dynamic web servers that understand and
    can run PHP scripts. [Figure 10-5](#fig10-5) illustrates client communication
    with one such dynamic web server.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure10-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-5: A dynamic web server communication with a web client'
  prefs: []
  type: TYPE_NORMAL
- en: In this model, the client sends an HTTP request to the server ❶. Then the server
    program interprets the request and identifies which PHP server script should be
    executed ❷. The script is executed ❸ and generates output, such as HTML text.
    Running a PHP script can also trigger other actions on the web server, such as
    communication with a database, which is something we’ll explore in [Part VI](part6.xhtml).
    Next, the web server application receives the output ❹. Finally, the output is
    packaged up in the body of an HTTP response message and returned with appropriate
    headers to the client that originally made the request ❺.
  prefs: []
  type: TYPE_NORMAL
- en: The Routing Process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Routing* is the process the web server uses in deciding what to do to respond
    appropriately to the HTTP request it has received; the server examines the request
    and determines what action it believes the client is requesting, such as asking
    for a file, trying to log in with username and password data included in the request,
    deleting an item from a database, and so on. In the simplest scenario, the request
    contains a valid path for a specific resource file, like */images/logo.jpg* or
    */styles/homepage.css*. In this case, the web server acts like a file server and
    returns an HTTP response message containing the contents of the file with appropriate
    header information.'
  prefs: []
  type: TYPE_NORMAL
- en: If a valid path to a publicly available.*php* file is requested, such as */about.php*,
    that PHP script will be interpreted and executed to build the HTTP response that’s
    returned to the client. If no specific file is requested, almost all web servers
    have *default routing* defined, which will often route to a home page file, usually
    named *index*. Simple static web servers will look for *index.xhtml* to return
    as the default home page, whereas PHP web servers will usually look first for
    *index.php* and perhaps then look for *index.xhtml* if no default PHP file is
    found. If no file is requested and no index file is found, the server will return
    a 404 Not Found response.
  prefs: []
  type: TYPE_NORMAL
- en: Sophisticated PHP web applications will use logic encoded inside the default
    *index.php* script to examine the contents and pattern of the URL path requested
    and from there decide how to respond to the request. An *index.php* file that
    uses logic like this to manage the complexity of a many-featured website is known
    as a *front controller*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of the types of URLs that web browsers use to make requests
    to web servers, with explanations of what they mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '***tudublin.ie***   No path is indicated beyond the domain name, so the web
    server will execute the default home page script (*index.php* if it’s a PHP web
    server). The TU Dublin home page HTML content is returned to the client.'
  prefs: []
  type: TYPE_NORMAL
- en: '***bbc.com/travel/columns/discovery***   The path contains text separated by
    forward slashes, so the home page script executes with logic to search the site’s
    database for today’s content relating to the main topic *travel* and the subtopic
    *discovery*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***nostarch.com/sites/all/themes/nostarch/logo.png***   The path includes a
    static resource file, so the web server locates and returns the contents of the
    *logo.png* image file.'
  prefs: []
  type: TYPE_NORMAL
- en: '***google.com/search?q=cheese+cake***   The path contains text indicating a
    search after the forward slash (*search*) and then the search text (*cheese cake*)
    in a variable (*q*) assigned after a question mark character (*?*). So the Google
    home page script executes with logic to search for web pages relating to *cheese
    cake*. In [Chapter 11](chapter11.xhtml), you’ll learn all about passing data through
    variables in URLs like this one.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 13](chapter13.xhtml), we’ll look at how to write PHP front-controller
    logic to perform routing decisions such as the ones summarized here.
  prefs: []
  type: TYPE_NORMAL
- en: Templating
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost all PHP applications are designed to run websites. For most HTTP requests,
    the content of the response is some sort of text, like an HTML, JavaScript, or
    CSS file, or perhaps data encoded as JSON or XML. PHP consequently was designed
    to facilitate outputting text (with, for example, the print and echo commands).
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, as was hinted in [Chapter 1](chapter1.xhtml), the language also makes
    it easy to mix prewritten text such as HTML with text created on the fly by executing
    PHP code. This feature is what makes PHP a *templating language*: it can insert
    dynamically generated values into static templates of HTML or other text. PHP-driven
    websites benefit from this sort of dynamic output, which may result from database
    interactions or communication between various data sources like Google Maps, weather
    APIs, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we’ve been writing pure PHP programs, which are scripts
    that contain only PHP code. Once we start using PHP as a templating language,
    mixing PHP statements with other template text (often HTML) becomes more common.
    This allows us to write the unchanging HTML for web pages as just HTML; any parts
    that need to change dynamically can be output from the logic we write in PHP statements.
    Conveniently, the HTML in many website pages contains much of the same content,
    such as a header, a navigation bar (which might change only by highlighting the
    particular page being visited), and page layout HTML code (for example, a hierarchy
    of div, header, and footer elements). All this nonchanging, static content is
    perfect for PHP templating.
  prefs: []
  type: TYPE_NORMAL
- en: It’s theoretically possible to make a pure PHP script output HTML by writing
    lots of print statements, but this approach results in code that’s long and hard
    to read. Take a look at [Listing 10-1](#lis10-1), which outputs HTML by using
    pure PHP print statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-1: Outputting HTML through print statements'
  prefs: []
  type: TYPE_NORMAL
- en: The only real PHP logic we’re using here is calling the date() function to get
    the current date as a string in the form *Month day, year* (for example, *January
    1, 2025*) ❶. All other lines are print statements that output unchanging HTML,
    and these print statements aren’t necessary. We can make the code more compact
    and readable by using PHP only where it’s needed, inserting it into an HTML template.
    That’s what we do in [Listing 10-2](#lis10-2), where the unchanging HTML is written
    just as it will appear in the final HTML text file to be sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-2: Mixing HTML template text with a PHP code block'
  prefs: []
  type: TYPE_NORMAL
- en: We use opening ❶ and closing ❷ PHP tags to surround just the print statement
    where we call the date() function, since this is the only place where PHP code
    is needed to dynamically generate content. Meanwhile, we’ve written everything
    else as regular HTML; no prints, quotes, or semicolons are needed. [Figure 10-6](#fig10-6)
    shows how PHP sees and processes the script content.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure10-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-6: How PHP processes mixed template text and dynamic code'
  prefs: []
  type: TYPE_NORMAL
- en: First, a block of template text needs to be copied verbatim into the text output.
    Next, a block of PHP code (between <?php and ?>) needs to be interpreted and executed
    before the result is added to the script’s text output. Finally, another block
    of template text needs to be copied verbatim to the output text. The temporary
    store for the text being output by the multiple parts of a PHP script is referred
    to as the *output buffer*.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine for a moment that the script in [Listing 10-2](#lis10-2) is part of
    an HTTP request from a web browser. When all PHP execution in the script is completed,
    the text in the output buffer will be wrapped up into an HTTP response by adding
    headers and then sent back to the browser web client. The browser will then render
    (draw) the web page for the user to see, interpreting the HTML it received in
    the body text of the HTTP response, resulting in the simple page shown at the
    bottom of [Figure 10-6](#fig10-6).
  prefs: []
  type: TYPE_NORMAL
- en: PHP Tags
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you’ve just seen, when you embed PHP code in template text, it’s important
    to use both the opening <?php tag and the closing ?> tag to delimit the code.
    By contrast, when writing PHP scripts that contain *just* code without any template
    text, the script should start with an opening <?php tag, but you shouldn’t include
    the closing ?> tag at the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: You leave off the closing tag for two reasons. First, you don’t need it, since
    the code has no template text to be separated from the PHP statements. Second,
    if you did include the closing PHP tag, any (unintentional and invisible) whitespace
    that occurs after the closing tag, including spaces, tabs, or newline characters,
    will be interpreted as template text and could prematurely begin creating the
    output buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Short Echo Tags
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve so far focused on PHP’s main <?php tag, but the language also provides
    a *short echo tag*, denoted with the <?= symbol, that further simplifies templating.
    This tag allows you to avoid writing lengthy commands when all you want to do
    is output the result of an expression as text. This might be to display the contents
    of a variable, or the result of a complex calculation or series of string concatenations.
    For example, instead of writing something like <?php print $someVariable; ?> to
    output the value of $someVariable, you can simply write <?= $someVariable ?> with
    the short echo tag.
  prefs: []
  type: TYPE_NORMAL
- en: The short echo tag calls for less typing since it omits print (or echo) and
    doesn’t require an ending semicolon. Also, any experienced PHP programmer who
    encounters the short echo tag can immediately recognize that the only logic is
    to output a string. Overall, the key advantage of the short echo tag is that it
    doesn’t distract the reader (or writer) with extraneous PHP code-block syntax
    when a script mostly contains HTML template text. The dynamically generated PHP
    code values blend in better with the surrounding HTML, as [Listing 10-3](#lis10-3)
    illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-3: Simplifying code with the PHP short echo tag'
  prefs: []
  type: TYPE_NORMAL
- en: In a full PHP code block surrounded by ordinary PHP tags, we create a $dateString
    variable containing our formatted date string ❶. This frees us up to simply write
    <?= $dateString ?>, using the short echo tag at the spot in the template where
    we want the string to be output ❷. There’s no need for a print statement or semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: The Model-View-Controller Architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost all large-scale web applications delegate different responsibilities
    to different system components. Most do this by implementing some form of the
    *model-view-controller (MVC)* architecture. This is a software design pattern
    that distinguishes between the data underlying the software (the *model*), the
    way that data is displayed to the user (the *view*), and the decisions about what
    data to display when (the *controller*).
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already touched on aspects of the MVC architecture in this chapter. We’ve
    noted how PHP applications can make routing decisions based on incoming HTTP requests
    (a controller task) and how we can use PHP for templating by injecting dynamically
    generated values into static HTML text (a view task). Now let’s fill in a few
    more gaps to see how the MVC pattern fits into the request-response cycle. [Figure
    10-7](#fig10-7) illustrates a typical interpretation of the MVC architecture for
    a web application.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure10-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-7: The MVC architecture common for web applications'
  prefs: []
  type: TYPE_NORMAL
- en: First, the web client sends an HTTP request ❶. Then the controller (the main
    application logic) interprets the request and decides what to do ❷. This may involve
    checking any stored security credentials and other data (such as shopping-cart
    contents) and deciding the appropriate actions to take in response to the received
    request. Often the controller needs to read the contents of a data store, such
    as a database system, file store, or even an API running on another server. This
    data is the model component of the MVC pattern. If the received request contains
    data submitted from a form, the controller may need to update or delete some of
    the model data.
  prefs: []
  type: TYPE_NORMAL
- en: Then the controller invokes the view component ❸, such as a template file, to
    create the contents of the response to be returned to the user. If appropriate,
    the controller passes along data collected from the model when it invokes the
    view component. Finally, the controller sends the response that it has created
    back to the web client (adding any appropriate headers, response codes, and the
    like) ❹.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll revisit the MVC pattern throughout this book as we delve further into
    structuring PHP web applications. As mentioned, in [Chapter 13](chapter13.xhtml),
    we’ll look at how to create a front-controller script to manage the controller
    portion of the architecture. In [Chapter 21](chapter21.xhtml), we’ll introduce
    the Twig library, which simplifies templating for the view portion of the architecture.
    Finally, in [Part VI](part6.xhtml), starting with [Chapter 27](chapter27.xhtml),
    we’ll investigate how to integrate a PHP application with a database to handle
    the model portion of the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring a PHP Web Development Project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 1](chapter1.xhtml), the PHP engine comes with a
    built-in web server for testing purposes that you can run at the command line
    by using the php -S localhost:8000 command. By default, this command makes every
    file and folder that lives in the directory that the command line is currently
    pointing to publicly available through the web server. For example, if your command
    line was navigated to the root of your main hard disk (such as *C:\* on a Windows
    computer) and you executed the PHP web server command, you’d be making everything
    on the hard disk available to be requested! This probably isn’t a good idea from
    a security point of view.
  prefs: []
  type: TYPE_NORMAL
- en: Even within a specific PHP project folder, you may have files or other content
    that you wouldn’t want to publish publicly, such as code containing username and
    password credentials for data access or scripts that should be accessed only by
    authorized users. Therefore, it’s customary (and highly recommended) to create
    a *public* folder within the overall folder for any PHP web development project.
    This *public* folder (and its subfolders, if any) should contain only those files
    that are to be made publicly accessible via the web server, including any images,
    sound files, video files, CSS stylesheets, JavaScript text files, and the like
    that are needed for the website. Any PHP scripts that are to be executed in direct
    response to incoming HTTP requests from web clients should also be located in
    the *public* folder, while other content that shouldn’t be publicly accessible
    should be located elsewhere in the project’s directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usual way to organize a secure web application is to have just one PHP
    script named *index.php* in the project’s *public* folder. This script (the front
    controller we’ll discuss further in [Chapter 13](chapter13.xhtml)) then decides
    which other nonpublic scripts should be executed based on the properties of the
    incoming HTTP requests and other stored data. A typical PHP project folder therefore
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Generally, it’s best to do any command line work from the root folder of a
    project rather than from the *public* folder. Since this practice is so common,
    the built-in PHP web server offers the -t command line option for specifying a
    subfolder from which to serve web pages. With your command line interface navigated
    to the root project directory, you can therefore enter the following command to
    serve only files in the *public* folder via port 8000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s test these two ways to run the built-in PHP web server: with and without
    the -t option. First, create a new empty folder named *[chapter 10](chapter10.xhtml)*,
    and in this folder create an *index.php* file containing the code shown in [Listing
    10-4](#lis10-4).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-4: A simple index.php file'
  prefs: []
  type: TYPE_NORMAL
- en: 'This script contains only two PHP statements: within full PHP tags, we set
    the $total variable to the result of evaluating the mathematical expression 2
    + 2 ❶, and with the short echo tag we output the contents of this variable ❷.
    To make sure this script works, navigate your command line interface to the *chapter10*
    folder (use the cd command to change directories if you aren’t there already),
    and then run the built-in PHP web server at port 8000 without specifying a folder
    to serve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a web browser to *localhost:8000* and you should see a web page showing
    the result of the PHP output statement: total = 4.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see why publishing the entire contents of a project folder is a bad
    idea. In your *chapter10* folder, also create a text file called *password.txt*
    containing the text password=mysecret. Then visit *localhost:8000/password.txt*
    in your web browser to see that this text file is also publicly accessible from
    the web server, just like the *index.php* script (see [Figure 10-8](#fig10-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure10-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-8: The web server publishing a secret password'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make this file more secure by creating a subfolder named *public* and
    moving the *index.php* script into this subfolder, while keeping *password.tx*t
    in the main *chapter10* folder. Once you’ve made this change, press CTRL-C to
    kill the old web server process and then run the web server again, this time restricting
    it to only the content of the *public* subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Try visiting both *localhost:8000* and *localhost:8000/password.txt* in your
    browser again. You should still be able to see the index page since it’s located
    in the *public* folder, but you should get a 404 error when you try to access
    the *password.txt* file since it isn’t in the *public* folder. We’ll follow this
    structure of using a *public* folder to isolate just the resources that should
    be publicly accessible throughout the book.  ### Summary'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored concepts fundamental to PHP web development. We
    considered the HTTP messages that form the basis for web client/server communications
    and began to discuss the concept of routing, which is how web servers evaluate
    the content of the HTTP request’s path and decide what files to return or which
    server scripts to execute. We also looked at PHP as a templating language that
    enables us to mix dynamic PHP statements with unchanging template text. We saw
    a tidy way to mix PHP output with HTML template text using the short echo tag.
  prefs: []
  type: TYPE_NORMAL
- en: We had our first look at the MVC architecture, a powerful way of dividing and
    organizing the tasks and data that drive a web application. Finally, we looked
    at the typical structure of a PHP web development project. In particular, we discussed
    the need for a *public* subfolder containing any resources that should be publicly
    accessible; any files or scripts that shouldn’t be publicly accessible must be
    located outside this subfolder.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Open the developer tools for your web browser and visit a favorite website.
    Examine the headers of your HTTP GET request and the body of the HTTP response
    message that’s returned to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 2.   With the developer tools for your web browser open, visit a web page that
    offers a form. Complete the form and, when you submit it, view the HTTP request
    body. You should see the name or value variables that were sent to the web server
    via the POST HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Write a “pure” PHP script, all in a single PHP block of code, to do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: a.   Define a PHP $pageTitle variable containing the string 'Home Page'.
  prefs: []
  type: TYPE_NORMAL
- en: b.   Output <!doctype html><html><head><title>.
  prefs: []
  type: TYPE_NORMAL
- en: c.   Output the value inside the $pageTitle variable.
  prefs: []
  type: TYPE_NORMAL
- en: d.   Output </title></head>.
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Rewrite your answer for Exercise 3, using template text instead of PHP
    code where possible. Use complete code blocks with <?php and ?> tags for the PHP
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 5.   Rewrite your answer for Exercise 4 to use the short echo tag to output
    the value inside the $pageTitle variable.
  prefs: []
  type: TYPE_NORMAL
