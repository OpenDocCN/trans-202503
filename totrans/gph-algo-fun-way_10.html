<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_111" aria-label="111"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch8">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">HEURISTIC-GUIDED SEARCHES</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" role="presentation" alt="" width="386" height="386"/>&#13;
</figure>&#13;
<p class="ChapterIntro">This chapter introduces <i>heuristic-guided search</i> algorithms, sometimes called <i>best-first searches</i>. These algorithms incorporate heuristic information about nodes’ estimated distance from the goal to prioritize the order in which to explore them. By focusing on the most promising paths toward the goal, they can achieve significant computational savings.</p>&#13;
<p class="TX">As we saw in the last chapter, finding the shortest (or lowest-cost) path from a specified start node to a specified goal node mirrors the daily task of navigating through the world. When planning a route to work or the store, we might measure cost by the time taken, the distance traveled, or the aggravation incurred due to the number of bad intersections.</p>&#13;
<p class="TX">After explaining what constitutes a heuristic, this chapter introduces two canonical heuristic search algorithms. <i>Greedy best-first search</i> prioritizes nodes solely by their estimated cost to the goal, while <i>A* search</i> (pronounced “A-star”) combines the cost to reach an intermediary node with <span role="doc-pagebreak" epub:type="pagebreak" id="pg_112" aria-label="112"/>the estimated cost from that node to the goal. This combination makes A* search a much more powerful tool for efficiently finding good paths.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-87"/><samp class="SANS_Futura_Std_Bold_B_11">Choosing Appropriate Heuristics</samp></h3>&#13;
<p class="TNI1">The algorithms in this chapter rely on estimated costs to guide their searches. To add such heuristic information to an algorithm, we must pick a method of estimating costs from what we know about each node. While the difficulty of defining a good heuristic varies widely across problems, the approaches for many real-world scenarios are simple and intuitive. After introducing Euclidean distance as a common heuristic used in path planning, we discuss the constraints and challenges involved in choosing heuristics.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h-88"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Euclidean Distance</samp></h4>&#13;
<p class="TNI1"><i>Euclidean distance</i> is a common, powerful, and intuitive heuristic used in many real-world path-planning problems that estimates the cost to a node at a given location by the straight-line distance to get there. For example, suppose we are navigating a cross-country road trip from Boston to Seattle. If the starting city is located at (<i>x</i><sub>1</sub>, <i>y</i><sub>1</sub>) and the destination is at (<i>x</i><sub>2</sub>, <i>y</i><sub>2</sub>), then the Euclidean distance between the two is as follows:</p>&#13;
&#13;
<p class="EQ"><span class="epub"><math display="block">&#13;
 <mrow>&#13;
  <mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mtext> </mtext><mtext> </mtext><mo>=</mo><mtext> </mtext><msqrt>&#13;
   <mrow>&#13;
    <mfenced>&#13;
     <mrow>&#13;
      <msup>&#13;
       <mrow>&#13;
        <mfenced>&#13;
         <mrow>&#13;
          <msub>&#13;
           <mi>x</mi>&#13;
           <mn>1</mn>&#13;
          </msub>&#13;
          <mtext> </mtext><mo>−</mo><mtext> </mtext><msub>&#13;
           <mi>x</mi>&#13;
           <mn>2</mn>&#13;
          </msub>&#13;
          </mrow>&#13;
        </mfenced></mrow>&#13;
       <mn>2</mn>&#13;
      </msup>&#13;
      <mtext> </mtext><mo>+</mo><mtext> </mtext><msup>&#13;
       <mrow>&#13;
        <mfenced>&#13;
         <mrow>&#13;
          <msub>&#13;
           <mi>y</mi>&#13;
           <mn>1</mn>&#13;
          </msub>&#13;
          <mtext> </mtext><mo>−</mo><mtext> </mtext><msub>&#13;
           <mi>y</mi>&#13;
           <mn>2</mn>&#13;
          </msub>&#13;
          </mrow>&#13;
        </mfenced></mrow>&#13;
       <mn>2</mn>&#13;
      </msup>&#13;
      </mrow>&#13;
    </mfenced></mrow>&#13;
  </msqrt>&#13;
  </mrow>&#13;
</math>&#13;
</span><span class="mobi"><img class="img100" src="../images/pg112.jpg" alt="dist, is equal to; the square root of open paren; open paren, x sub 1&#13;&#10;minus x sub 2, close paren squared; plus, open paren, y sub 1 minus y sub&#13;&#10;2, close paren squared; close paren end root" width="1388" height="52"/></span></p>&#13;
&#13;
<p class="TX">We can code this equation as follows:</p>&#13;
<pre><code>def euclidean_dist(x1: float, y1: float, x2: float, y2: float) -&gt; float:&#13;
    return math.sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2))&#13;
</code></pre>&#13;
<p class="TX">Unless you are a bird flying directly to your destination, Euclidean distance provides, at best, a lower bound of the true cost. Roads don’t exist between every pair of cities on the map. Even highways that stretch directly from one point to another are unlikely to follow a straight line, since they must curve around geographic features like mountains and lakes, lengthening your journey.</p>&#13;
<p class="TX">Despite its optimistic nature, Euclidean distance can provide vital heuristic information. For example, these estimates can help us choose appropriate waypoints as we plan a road trip. On a trip from Boston to Seattle, Cleveland would obviously make a better rest stop than Miami, because Miami is farther from both Seattle and Cleveland than our starting point.</p>&#13;
<p class="TX"><a href="#fig8-1">Figure 8-1(a)</a> shows an example graph on a two-dimensional plane. <a href="#fig8-1">Figure 8-1(b)</a> shows the corresponding edge weights, which largely correspond to the straight-line distance between nodes. However, the cost between two nodes can also be <i>greater</i> than the Euclidean distance. The edge between nodes 2 and 4 has a weight of 3.5, which could indicate additional cost, such as traversing a steep hill or using a dirt road. The cost of traversing between nodes (the edge weight) must simply be greater than or equal to the estimated distance.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_113" aria-label="113"/>&#13;
<figure class="IMG"><img id="fig8-1" class="img100" src="../images/f08001.jpg" alt="In (A), a seven-node graph is shown on a 5 × 5 grid. Node 0 is at x=0, y=0 and node 1 is at x=0, y=2. In (B), each edge is labeled with the cost between the two nodes. The edge (0, 1) has a weight 2.0. In (C), each node is labeled with the estimated distance to the goal." width="1654" height="576"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: The weights and Euclidean distances between nodes on a 2D plane</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Given this arrangement, we can provide lower-bound estimates of the potential cost from each node to the goal by taking the Euclidean distance from that node to the goal, as shown in <a href="#fig8-1">Figure 8-1(c)</a>, for a goal node of 6. The estimated cost from node 0 to node 6 is 5.0, reflecting their Euclidean distance. As noted previously, these estimates do not always capture the full cost. For example, the estimated distance from node 0 to node 6 is too optimistic, as the node lacks a direct path to node 6.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-89"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Admissible Heuristics</samp></h4>&#13;
<p class="TNI1">We define a heuristic to be <i>admissible</i> if the estimated cost from the start node to the goal is always less than or equal to the true cost, or, in other words, if the heuristic does not overestimate the true cost. Euclidean distance, for example, is a common, effective, and admissible heuristic for real-world path planning, since the straight-line distance to our goal provides an optimistic estimate of the cost to get there. The admissibility requirement is essential for the correct operation of some searches, such as A* search, and will be one of our major constraints when choosing a heuristic for a given purpose.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h-90"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Heuristic Design Challenges</samp></h4>&#13;
<p class="TNI1">While it’s relatively easy to define a heuristic for estimating distances, let’s consider a more difficult case. Imagine you want to solicit an introduction to a new contact through your professional network. Each person (node) can reach out only to their present or past coworkers to pass along the request. To facilitate your introduction, you must find a sequence of weighted edges that indirectly connect you to the person you ultimately want to meet, where each edge weight represents the cost of passing along the request. The cost of passing the request to a friend with whom you converse daily would be low, while the cost of connecting with an annoying former coworker with whom you never want to speak again would be very high.</p>&#13;
<p class="TX">Unfortunately, it’s difficult to capture all these factors with a single admissible heuristic. You might be able to glean some estimate of distance to the goal from each person’s job history. The estimated cost of communication through a person in a different industry from the goal node should generally <span role="doc-pagebreak" epub:type="pagebreak" id="pg_114" aria-label="114"/>be higher; for example, professional interactions between a professional baseball player and a computer scientist are rarer than those between two baseball players. Similarly, the estimated cost would be lower if the two individuals worked at the same company. However, piecing together positive and negative indicators like this makes it difficult to form a good quantitative estimate, as the indicators are too noisy. The fact that two people once worked together does not help you if they have never met or are nemeses.</p>&#13;
<p class="TX">Worse, it is much more difficult to ensure your heuristics for such problems are admissible. If you place a high cost on different industries, you will occasionally overestimate the cost of passing your message between them—perhaps you know a programmer who still talks regularly to the movie star who was their childhood best friend. Similarly, this metric would not capture the family members who work for different companies but communicate often.</p>&#13;
<p class="TX">Choosing a good heuristic involves maximizing information while maintaining admissibility and minimizing computation cost. It is trivial to design an admissible heuristic by assigning each node a cost of negative infinity, but this strategy is obviously useless in guiding a search. Similarly, we can design a perfectly informative and admissible heuristic by using the algorithms in the previous chapter: we just solve the all-pairs shortest-path problem and compute the heuristic from the true lowest-cost path between each node and the goal. Yet this does not help either, as the computational cost of the search is too high. The point of a heuristic is to reduce the computational cost of the search itself. As we consider new problems and heuristics, it is always important to examine the trade-offs between information, computational cost, and admissibility.</p>&#13;
<p class="TX">The following sections introduce two canonical heuristic searches, starting with the simplest approach: greedy best-first search.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h-91"/><samp class="SANS_Futura_Std_Bold_B_11">Greedy Best-First Search</samp></h3>&#13;
<p class="TNI1">A <i>greedy best-first search</i> always chooses the option that looks best at a given point in the search, exploring the next unvisited node with the lowest estimated cost based on the best heuristic value. The algorithm maintains a minimum priority queue of nodes to test. As it progresses toward the goal, at each step it chooses the lowest-cost node from the priority queue and explores that node next. Each time the algorithm sees new neighbors, it adds them to the queue with a priority equal to their heuristic value. The algorithm proceeds node by node until it finds a path to the goal.</p>&#13;
<p class="TX">We can view greedy best-first search as a modification of breadth-first search. Whereas the latter search prioritizes nodes by the order in which they were seen, using a queue to visit the earliest-seen node, best-first search orders the nodes with a heuristic.</p>&#13;
<p class="TX">Greedy best-first search takes the approach we might expect of an eager but clever squirrel navigating a maze, as shown in <a href="#fig8-2">Figure 8-2</a>. The squirrel (S) can smell the delicious pile of acorns that is his goal destination (G). Using its nose, the squirrel can deduce the straight-line path he could take directly to the nuts, if there were no walls (<a href="#fig8-2">Figure 8-2(a)</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_115" aria-label="115"/>&#13;
<figure class="IMG"><img id="fig8-2" class="img60" src="../images/f08002.jpg" alt="(A) shows a maze on a 5 × 5 grid with the cell in the middle of the top row labeled S and the cell in the bottom right labeled G. A gray arrow points directly from S to G. (B) shows the same maze with the cell to the left of S labeled with a minus, and the cells below it and to its right labeled with pluses." width="965" height="486"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-2: A maze with a heuristic estimate of the goal’s direction</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">At any given location (node), the squirrel can also determine adjacent locations to which it can move and estimate which one will take it closer to the destination. The squirrel uses a smell-based heuristic—nodes with a stronger smell of acorns are closer to the goal. <a href="#fig8-2">Figure 8-2(b)</a> shows that two of the neighboring squares will move the squirrel closer to the acorns (+), while one will move it farther away (–). The squirrel always chooses the path with the strongest smell, following the scent toward the food, sometimes backtracking to points where the smell was stronger than the current location. Along the way, it mentally notes alternative paths and adds them to the list of options to try.</p>&#13;
<p class="TX">Although greedy best-first search might quickly find a path to the goal if it is working with a good heuristic, the final path is not guaranteed to be optimal. We might take a path that looks good due to an optimistic estimate at an early node and skip a better path with a more realistic estimate. The squirrel might take a longer path that temporarily curves away from the food simply because the smell was stronger in that direction. We will see an example of this scenario later in this section.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h-92"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1">To implement the greedy search algorithm, we need to provide an additional piece of information beyond what we included in earlier searches: the nodes’ heuristic values. There are multiple approaches to providing this information. For clarity of illustration, we’ll start by passing a precomputed list <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp> that maps the nodes’ indices to their heuristic values, and we’ll introduce an alternative method later in the chapter.</p>&#13;
<p class="TX">The code for greedy best-first search is similar to that of breadth-first search. Instead of using a queue to store the nodes in the order they were seen, we use a custom <i>min-heap-based priority queue</i> (described in <span class="Xref"><a href="appendix_B.xhtml">Appendix B</a></span>) to retrieve nodes in order of decreasing estimated cost:</p>&#13;
<pre><code>def greedy_search(g: Graph, h: list, start: int, goal: int) -&gt; list: &#13;
    visited: list = [False] * g.num_nodes&#13;
    last: list = [-1] * g.num_nodes&#13;
    pq: PriorityQueue = PriorityQueue(min_heap=True)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_116" aria-label="116"/>&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> pq.enqueue(start, h[start])&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> while not pq.is_empty() and not visited[goal]:&#13;
        ind: int = pq.dequeue()&#13;
        current: Node = g.nodes[ind]&#13;
        visited[ind] = True&#13;
&#13;
        for edge in current.get_edge_list():&#13;
            neighbor: int = edge.to_node&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if not visited[neighbor] and not pq.in_queue(neighbor):&#13;
                pq.enqueue(neighbor, h[neighbor])&#13;
                last[neighbor] = ind&#13;
&#13;
    return last&#13;
</code></pre>&#13;
<p class="TX">The code starts by setting up the internal data structures, including a list indicating whether we have visited each node (<samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp>), a list mapping each node to the one that preceded it on the search path (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>), and a minimum priority queue (<samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>). It then inserts the starting node into the priority queue, with its heuristic cost as the priority <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. In the squirrel maze analogy, this marks the point right before the squirrel’s search begins. Standing ready outside the maze, it smells the acorns and has one available option on its mental priority queue: the starting node.</p>&#13;
<p class="TX">The exploration of greedy best-first search takes place in a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop that continues exploring until the code has either exhausted the priority queue or visited the goal node <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. At each iteration, the code retrieves the next node on the priority queue—the one with the best heuristic value—and visits that node. You can picture this as the squirrel running to the location of the next best option.</p>&#13;
<p class="TX">The code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to iterate over each of the current node’s neighbors. If a neighbor has not been visited and is not in the priority queue, then it has not been seen before <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. The code therefore adds it to the priority queue (with the estimated distance as the priority) and marks the current node as the step before it in the path.</p>&#13;
<p class="TX">When the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop completes, the greedy search will have either found a path to the goal node or discovered that no such path exists. In the former case, unlike other algorithms we have seen previously, there may still be unexplored nodes on the priority queue. In the latter case, the priority queue will be empty; there are no more nodes to explore. The goal node’s entry in <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> will be <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>, reflecting the lack of any path back to the starting node. The code concludes by returning the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> list.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h-93"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1"><a href="#fig8-3">Figure 8-3</a> shows an example greedy best-first search on the graph from <a href="#fig8-1">Figure 8-1</a>. In each subfigure, the current node being explored is enclosed in a dashed circle, while nodes that have been visited are shaded. The edge weights are shown alongside each edge.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_117" aria-label="117"/>&#13;
<figure class="IMG"><img id="fig8-3" class="img80" src="../images/f08003.jpg" alt="Each subfigure shows the seven-node graph from Figure 8-1 along with the sorted priority queue and the last array. (B) shows node 0 shaded and circled. The last array reads [–1, 0, 0, 0, –1, –1, –1] and the priority queue has nodes 2, 1, and 3 with priorities 2.24, 3.60, and 4.0, respectively." width="1662" height="2243"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-3: The steps of a greedy best-first search</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_118" aria-label="118"/>To avoid cluttering the illustrations, the heuristic values for each node are not shown directly in <a href="#fig8-3">Figure 8-3</a>. However, these heuristic values are the same Euclidean distances as shown in <a href="#fig8-1">Figure 8-1(c)</a>. We provide them to the algorithm as a list <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>:</p>&#13;
<pre><code>h: list = [5.0, 3.6, 2.24, 4.0, 2.24, 3.16, 0.0]&#13;
</code></pre>&#13;
<p class="TX">Each subfigure also shows the current priority queue (in sorted order for illustration) and the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> list. Although the code maintains the priority queue in heap ordering, we show the priority queue in sorted order to make the relative orderings clearer.</p>&#13;
<p class="TX">The search begins by putting the start node into the priority queue with its corresponding cost estimate 5.0, as shown in <a href="#fig8-3">Figure 8-3(a)</a>. During the first iteration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop, it dequeues node 0 from the priority queue, visits it, and adds each previously unseen neighbor to the priority queue, as shown in <a href="#fig8-3">Figure 8-3(b)</a>. The priorities for the nodes are equal to their heuristic costs (that is, the Euclidean distances to the goal node) as given in <a href="#fig8-1">Figure 8-1(c)</a>: node 1 = 3.6, node 2 = 2.24, and node 3 = 4.0. The search sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> values to 0 for each of these neighbors to indicate that the path toward them comes from node 0.</p>&#13;
<p class="TX">At each step in the search, the algorithm chooses the node that looks most promising as it progresses toward the goal. Checking the priority queue, it moves on to node 2. As shown in <a href="#fig8-3">Figure 8-3(c)</a>, it then adds node 2’s unvisited neighbors to the priority queue. With priority 2.24, node 4 now sits at the top of the queue. The search progresses through node 4 in <a href="#fig8-3">Figure 8-3(d)</a> to the goal node in <a href="#fig8-3">Figure 8-3(e)</a>.</p>&#13;
<p class="TX">As you can see from this example, greedy best-first search does not produce an optimal path to the goal. The search is lured to node 2 with the promise of its proximity to the goal node, but is forced to detour through node 4 and over a costly 3.5 weighted edge. Greedy best-first search cannot tell that it would have been better to progress through node 1, because it doesn’t consider the cost of the paths to get to a node. It looks only at the estimated cost from a given node to the goal and uses that for prioritization. By the time the search has finished visiting node 2, it has already seen that node 4 has a better heuristic value than node 1.</p>&#13;
<p class="TX">We can picture this suboptimality in the context of a frustrating bicycle trip. Suppose that after a morning of cycling with no destination in mind and without paying attention to the path, you and your friend are exhausted and want to find your way home. You stop at a fork in the road and consider the options. You know the left path ends at an intersection adjacent to your house but traverses a small mountain to get there. The right path is flat but terminates at an intersection a few blocks away from your house. Both paths get you closer to home, but with radically different costs (edge weights). Unfortunately, a greedy algorithm doesn’t take that into consideration. Before you can open your mouth, your overeager friend lets out a cheer and pedals up the left path. When you try to protest, they just call out, “Who cares about a little hill? This path gets us closer.”</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_119" aria-label="119"/>&#13;
<h3 class="H1" id="sec8"><span id="h-94"/><samp class="SANS_Futura_Std_Bold_B_11">A* Search</samp></h3>&#13;
<p class="TNI1">A* search combines the heuristic estimates of greedy best-first search with a more comprehensive accounting for the observed edge costs, providing an efficient mechanism for finding the shortest path between two nodes. Whereas greedy best-first search completely ignores the edge cost, A* balances the promise of the heuristic estimates with the cold, hard facts about the best paths we have seen to each node. This combination results in an accurate and computationally efficient algorithm.</p>&#13;
<p class="TX">The key intuition behind the A* algorithm is that we want to rank potential nodes in our path by their estimated <samp class="SANS_TheSansMonoCd_W5Regular_11">total</samp> cost. It is not sufficient to focus on the cost from the current node to the goal; we also must ask how expensive it was to get to that node in the first place. To answer this question, A* tracks an additional piece of information: the cost of the best path found so far to each node. As shown in <a href="#fig8-4">Figure 8-4</a>, the priority used for unvisited nodes is then just the sum of the cost of the best path to the node so far plus the estimated cost of traveling from that node to the goal.</p>&#13;
<figure class="IMG"><img id="fig8-4" class="img40" src="../images/f08004.jpg" alt="Three nodes, S, C, and G. The path between S and C is labeled “Best cost S to C” and the path between C and G is labeled “Estimate C to G.”" width="586" height="182"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-4: The combination of true cost to a node and estimated cost to the goal</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In contrast to the eager squirrel’s demonstration of greedy best-first search, we can visualize A* search as a more meticulous explorer with an advanced degree in cartography searching for a path to a proposed archeological dig site. In addition to the standard compass, canteen, and obligatory exploring hat, our protagonist carries a clipboard to track information about the area. They represent each node as a row with three columns of information: the best cost to the node (titled Best Cost), the best path to the node (Best Path), and the estimated total cost to the goal through that node (Heuristic). Throughout their journey, the explorer continually updates these three columns of information.</p>&#13;
<p class="TX">The explorer travels from village to village (node to node). GPS coordinates provide an estimate of the shortest possible distance. Signposts, trail markers, and in-person interviews reveal the actual distance to neighboring nodes. Each time the explorer discovers a new node, they compute its estimated cost to the goal and write that down in the Heuristic column.</p>&#13;
<p class="TX">As their journey continues, the explorer always moves to the next location (node) with the lowest estimated total cost. Each time they consider a neighboring location, whether new or previously seen, they ask themselves whether they’ve found a better path to that node than they had previously discovered. If so, they document this discovery in the Best Cost and Best <span role="doc-pagebreak" epub:type="pagebreak" id="pg_120" aria-label="120"/>Path columns. Perhaps earlier in their journey they discovered a 10-mile trail through a dense, spider-infested jungle to reach the archeology site. Their notes detail this path and its tremendous cost. However, they later discover a new, three-mile-long paved highway to the same site via a small village to the east. They eagerly erase their old values and update both the Best Cost and the Best Path columns to reflect this new find.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2"><span id="sec9"/><span id="h-95"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1">The code for A* search in <a href="#list8-1">Listing 8-1</a> orders the potential nodes by the estimated total cost through that node and onto the goal. Again, it uses a precomputed list <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp> of heuristic values for each node.</p>&#13;
<span id="list8-1"/>&#13;
<pre><code>def astar_search(g: Graph, h: list, start: int, goal: int) -&gt; list: &#13;
    visited: list = [False] * g.num_nodes&#13;
    last: list = [-1] * g.num_nodes&#13;
    cost: list = [math.inf] * g.num_nodes&#13;
    pq: PriorityQueue = PriorityQueue(min_heap=True)&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> pq.enqueue(start, h[start])&#13;
    cost[start] = 0.0&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> while not pq.is_empty() and not visited[goal]:&#13;
        ind: int = pq.dequeue()&#13;
        current: Node = g.nodes[ind]&#13;
        visited[ind] = True&#13;
&#13;
        for edge in current.get_edge_list():&#13;
            neighbor: int = edge.to_node&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if cost[neighbor] &gt; cost[ind] + edge.weight:&#13;
                cost[neighbor] = cost[ind] + edge.weight&#13;
                last[neighbor] = ind&#13;
&#13;
              <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> est_value: float = cost[neighbor] + h[neighbor]&#13;
                if pq.in_queue(neighbor):&#13;
                    pq.update_priority(neighbor, est_value)&#13;
                else:&#13;
                    pq.enqueue(neighbor, est_value)&#13;
    return last&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: The code for A* search</samp></p>&#13;
<p class="TX">The code starts by setting up the internal data structures, including a list indicating whether it has visited each node (<samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp>), a list mapping each node to the one that preceded it on the search path (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>), a list storing the cost of the best path found from the starting node to each subsequent node (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>), and a minimum priority queue (<samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>). It inserts the starting node into the priority queue, with its estimated cost as the priority, and sets the cost of the starting node to 0 to reflect the fact that the search is already at that node <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">The search is now ready to begin. A <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop continues exploring nodes until the code has either exhausted the priority queue or visited the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_121" aria-label="121"/>goal node <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. At each iteration, the code retrieves the next node on the priority queue—the node with the lowest estimated total cost to the goal—and visits it next.</p>&#13;
<p class="TX">The algorithm uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to iterate over each of the current node’s neighbors. It checks whether the current node provides a better path to the neighbor, computing the full cost by combining the best cost to the current node with the edge weight to the neighbor <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. If the code finds a better path to a node, it updates both the <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> lists. It then updates the neighboring node’s estimated total cost using the new cost to <samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp> plus the estimated cost from <samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp> to the goal <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>. If the neighbor is in the priority queue already, the code updates its priority with the <samp class="SANS_TheSansMonoCd_W5Regular_11">update_priority()</samp> function to take the new estimated total cost into account. Otherwise, it adds the node to the priority queue.</p>&#13;
<p class="TX">As in greedy best-first search, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop in A* search completes when it has either found a path to the goal node or concluded that no such path exists—that is, if the search exhausts the priority queue before visiting the goal node. The code finishes by returning the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> list.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2"><span id="sec10"/><span id="h-96"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1"><a href="#fig8-5">Figure 8-5</a> shows an example A* search. As in our example for greedy best-first search, we show the edge weights and again use the heuristics from <a href="#fig8-1">Figure 8-1(c)</a>:</p>&#13;
<pre><code>h: list = [5.0, 3.6, 2.24, 4.0, 2.24, 3.16, 0.0]&#13;
</code></pre>&#13;
<p class="BodyContinued">Each subfigure also shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> array, <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp> array, and priority queue. The current node being explored is marked with a dashed circle and the visited nodes are shaded. Again, the priority queue is shown in sorted order for clarity.</p>&#13;
<p class="TX"><a href="#fig8-5">Figure 8-5(a)</a> shows the initial state of the search before it visits the first node. The priority queue initially contains only the start node. Since the distance from the start node to itself is 0.0, the estimated total cost of the starting node is just the estimated distance to the goal. The <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp> array reflects the known costs to get to each node: 0.0 for the starting node and infinite for everything else, because the search has not observed a path to those nodes yet.</p>&#13;
<p class="TX"><a href="#fig8-5">Figure 8-5(a)</a> represents our hypothetical explorer’s state before the start of an expedition. They have been hired to find the shortest path from a city (node 0) to a proposed archeological dig site (node 6). Before they land at the starting city, they have only a rough (and optimistic) estimate of the distance to the dig site given the geographical coordinates of its location. The explorer checks their lists, dons their helmet, and says, “I know the dig site is at least five miles from the city. It’s time to get started.”</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_122" aria-label="122"/>&#13;
<figure class="IMG"><img id="fig8-5" class="img80" src="../images/f08005.jpg" alt="Each subfigure shows the seven-node graph from Figure 8-1 along with the sorted priority queue, the last array, and the cost array." width="1640" height="2350"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-5: The steps of the A* algorithm on an example graph</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_123" aria-label="123"/>In <a href="#fig8-5">Figure 8-5(b)</a>, the search dequeues the top node from the priority queue and explores it. This is equivalent to our intrepid explorer arriving at the starting city and looking around. The search finds three neighbor nodes and computes their expected total cost as the sum of the distance to the current node, the edge weight to the neighbor, and the estimated cost from the neighbor to the goal, resulting in the following total estimated costs:</p>&#13;
<p class="ListPlain">Node 1: 0.0 + 2.0 + 3.6 = 5.6</p>&#13;
<p class="ListPlain">Node 2: 0.0 + 2.83 + 2.24 = 5.07</p>&#13;
<p class="ListPlain">Node 3: 0.0 + 3.0 + 4.0 = 7.0</p>&#13;
<p class="BodyContinued">This corresponds to the explorer updating their lists after finding three roads out of the initial city. From a helpful signpost, they know the distance to the villages and their locations. Each road presents a potential path with a different estimated cost.</p>&#13;
<p class="TX">Since the estimated total cost of node 2 looks the best, the search explores it next, as shown in <a href="#fig8-5">Figure 8-5(c)</a>. From there, it considers two neighbors, nodes 3 and 4. Node 3 already has a lower cost from the starting node (3.0 versus 2.83 + 2.24 = 5.07), so the search does not update its path or priority. The search has not seen node 4 before, so it provides an initial cost value of 2.83 + 3.5 = 6.33 and a total cost estimate of 2.83 + 3.5 + 2.24 = 8.57. This cost reflects the impact of both the path to node 2 and the extreme cost of traversing from node 2 to node 4.</p>&#13;
<p class="TX">Through the eyes of the explorer, these decisions look similar. They see a signpost indicating two new villages. Village 3 is an additional 2.24 miles away. Compared to the direct path from city 0 to village 3, the detour through village 2 to village 3 is much longer. They immediately realize there is no need to add an unnecessary stop and therefore refrain from updating the row for village 3. In contrast, while the path to village 4 from village 2 is exceptionally difficult, it offers the prospect of getting closer to their goal, so they update the row for village 4.</p>&#13;
<p class="TX">The search continues by taking the unvisited node with the best estimated total cost. Unlike greedy search, it does not jump to the node estimated to be closest to the goal, in this case node 4. Though this node has the best estimated cost to the goal (2.24), the cost of getting there using the current path is high (6.3 through node 2). Instead, the search explores node 1, as shown in <a href="#fig8-5">Figure 8-5(d)</a>, and finds a better path to node 4, updating the estimated total cost to 2.0 + 1.41 + 2.24 = 5.65. It also updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> array to indicate that the path to node 4 goes through node 1 instead of node 2.</p>&#13;
<p class="TX">This step mirrors the explorer thinking about the total cost of the route. The archologists who hired the explorer want a low-cost route to reach the site repeatedly. Knowing this, the explorer tries village 1 before crossing the mountain from village 2 to village 4.</p>&#13;
<p class="TX">The search continues to node 4 in <a href="#fig8-5">Figure 8-5(e)</a>, then node 6 in <a href="#fig8-5">Figure 8-5(f)</a>. At each stop, it considers the unvisited neighbors and checks whether it has found a better path. It stops after reaching node 6 because it knows it has found the best path to the goal, even without having visited nodes 3 and 5.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_124" aria-label="124"/>&#13;
<h4 class="H2" id="sec11"><span id="h-97"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Why A* Finds the Optimal Path</samp></h4>&#13;
<p class="TNI1">The skeptical reader might wonder how we can be sure A* search has found the best path, since it explores only a portion of the graph without visiting every node. However, as long as its heuristic is admissible, A* will always find the optimal path. To see why, let’s examine the state after A* search has reached the goal node through some path and consider an alternate path to the goal node through an unvisited node <i>v</i>. Because of our admissible heuristic and priority queue ordering, any path through node <i>v</i> must be longer than the one we have already found.</p>&#13;
<p class="TX">Since the search did not visit node <i>v</i> before the goal node, node <i>v</i>’s priority value (estimated total cost) must have been greater than the priority value of the goal node. At the point that the search visited the goal node, the goal node’s priority value equals the actual cost of the path found. The estimated cost to the goal is always 0 for the goal itself, so the goal’s priority value equals the cost to the node preceding it plus the corresponding edge weight. We are no longer relying on heuristics. We have an actual path cost.</p>&#13;
<p class="TX">In contrast, the priority value of the unvisited node <i>v</i> is a lower bound of the true distance due to use of an admissible heuristic. It can never be less than the true distance. Our heuristic is optimistic. Any path to the goal through node <i>v</i> must cost at least as much as node <i>v</i>’s priority value, which was greater than that of the goal node. Thus, the cost of a path to the goal through node <i>v</i> must be higher than the one already found.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h-98"/><samp class="SANS_Futura_Std_Bold_B_11">Applying A* to Puzzles</samp></h3>&#13;
<p class="TNI1">As long as we can generate a useful and admissible heuristic, we can apply heuristic-based searches to efficiently find solutions for the puzzle graphs from <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, such as the prisoners-and-guards puzzle. As a reminder, <a href="#fig8-6">Figure 8-6</a> shows the state graph for that puzzle (originally introduced in <a href="chapter6.xhtml#fig6-8">Figure 6-8</a>).</p>&#13;
<figure class="IMG"><img id="fig8-6" class="img100" src="../images/f08006.jpg" alt="A 16-node graph. Each node is labeled with a number and a three-element list describing the puzzle state." width="1679" height="590"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-6: The state graph for the prisoners-and-guards river-crossing puzzle</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_125" aria-label="125"/>We can use two basic facts about the physical properties of the boat to derive an admissible metric indicating the distance to the goal state:</p>&#13;
<ul class="BL">&#13;
<li class="BL">The boat can carry at most two people. If there are <i>k</i> people on the left shore, we need to least <i>ceil</i>(<i>k</i> / 2) trips to get them all onto the right shore.</li>&#13;
<li class="BL">If the boat is on the right shore, it must return to the left shore before picking up more people.</li>&#13;
</ul>&#13;
<p class="BodyContinued">Using those conditions, we can define a function to generate the heuristic from the <samp class="SANS_TheSansMonoCd_W5Regular_11">PGState</samp> stored in each node:</p>&#13;
<pre><code>def pg_generate_heuristic(g: Graph) -&gt; list: &#13;
    heuristic = [0.0] * g.num_nodes&#13;
    for node in g.nodes:&#13;
        state: PGState = node.label&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> num_left: int = state.guards_left + state.prisoners_left&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> min_trips_l_to_r: int = math.ceil(num_left / 2.0)&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> min_trips_r_to_l: int = max(0, min_trips_l_to_r - 1)&#13;
        if not state.boat_side == "L" and min_trips_l_to_r &gt; 0:&#13;
            min_trips_r_to_l += 1&#13;
        heuristic[node.index] = min_trips_l_to_r + min_trips_r_to_l&#13;
&#13;
    return heuristic&#13;
</code></pre>&#13;
<p class="TX">The code loops over the graph’s nodes with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, checking the puzzle state of each node to determine the number of people on the left shore <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. It then computes the minimum number of trips the boat needs to make from left to right by considering how many people still need to be moved over and noting that at most two people can come over each time <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. It also computes the minimum number of trips the boat needs to make from right to left by noting that, while there are more passengers to transport, the boat needs to return to the left shore to pick them up <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. The heuristic is the sum of these two sets of trips.</p>&#13;
<p class="TX"><a href="#tab8-1">Table 8-1</a> compares the values of this heuristic function for each state with the true distance to the goal node, which we calculate by counting the steps from each state to the goal in <a href="#fig8-6">Figure 8-6</a>. As you can see, the heuristic is admissible and never overestimates the true distance.</p>&#13;
<table class="Basic-Table1">&#13;
<caption>&#13;
<p class="TT1" id="tab8-1"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp> <samp class="SANS_Futura_Std_Book_11">Values from the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">pg_generate_heuristic()</samp> <samp class="SANS_Futura_Std_Book_11">Function vs. the True Distance to the Goal Node</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="Basic-Table">&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">State</samp></p>&#13;
</th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">3</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">3</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">L</samp></p>&#13;
</th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">3</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">2</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">R</samp></p>&#13;
</th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">3</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">1</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">R</samp></p>&#13;
</th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">2</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">2</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">R</samp></p>&#13;
</th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">3</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">2</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">L</samp></p>&#13;
</th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">3</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">0</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">R</samp></p>&#13;
</th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">3</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">1</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">L</samp></p>&#13;
</th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">1</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">1</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">R</samp></p>&#13;
</th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">2</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">2</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">L</samp></p>&#13;
</th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">0</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">2</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">R</samp></p>&#13;
</th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">0</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">3</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">L</samp></p>&#13;
</th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">0</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">1</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">R</samp></p>&#13;
</th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">1</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">1</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">L</samp></p>&#13;
</th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">0</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">2</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">L</samp></p>&#13;
</th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">0</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">0</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">R</samp></p>&#13;
</th>&#13;
<th class="Basic-Table TCH" scope="col">&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">0</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">1</samp></p>&#13;
<p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">L</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="Basic-Table">&#13;
<td class="Basic-Table TBF">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">Heuristic distance</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">5</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">6</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">4</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">4</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">5</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">4</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">3</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">2</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">3</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">2</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">3</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">2</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">1</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">1</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">0</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBF">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">1</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="Basic-Table">&#13;
<td class="Basic-Table TBL">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">True distance</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">11</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">12</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">10</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">10</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">9</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">8</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">7</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">6</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">5</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">4</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">3</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">2</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">1</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">1</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">0</samp></p>&#13;
</td>&#13;
<td class="Basic-Table TBL">&#13;
<p class="TT"><samp class="SANS_Futura_Std_Book_11">1</samp></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_126" aria-label="126"/>Given this heuristic function, we can run A* search on the river- crossing puzzle:</p>&#13;
<pre><code>g: Graph = create_prisoners_and_guards()&#13;
h: list = pg_generate_heuristic(g)&#13;
last: list = astar_search(g, h, 0, 14)&#13;
</code></pre>&#13;
<p class="TX">The prisoners-and-guards problem provides a demonstrative example of applying A* search to puzzles because we can enumerate the states and compare the heuristic values to the true best path. However, the structure of the graph, with a single long sequence of states without branches, means that A* search does not significantly outperform breadth-first search on this puzzle. In contrast, A* search could provide significant advantages on puzzles with much larger state spaces, since the power of A* search is its ability to focus on exploring only promising paths toward the goal.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H1" id="sec13"><span id="h-99"/><samp class="SANS_Futura_Std_Bold_B_11">Searching Unknown Graphs</samp></h3>&#13;
<p class="TNI1">While the algorithms introduced in this chapter so far have treated both the graph and heuristic values as known items passed to the search, these approaches work equally well on problems for which the algorithm needs to dynamically construct an unknown graph. Consider the puzzle-building examples from <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. There, we used breadth-first search to quite literally explore the state space, building up a graph as we encountered new nodes and edges. We can do the same thing with heuristically guided searches.</p>&#13;
<p class="TX">Instead of passing a list of heuristic values to each node, we could pass a function that dynamically evaluates the heuristic based on the information in the node. For example, if a node has auxiliary data <i>x</i> and <i>y</i>, indicating its spatial position, we could define the heuristic function to be the Euclidean distance from that node to the known goal position. In the case of a real-world explorer, this might correlate to their using a GPS to estimate the distance to the objective as they trek through the jungle.</p>&#13;
<p class="TX">We can visualize this dynamic construction and evaluation using the “clouded out” mechanism from video games. For example, <a href="#fig8-7">Figure 8-7</a> shows a grid as a 5×5 maze. Explored areas like the long dead end at the bottom of the graph are shown as boxes, while unexplored areas are grayed out. Anything could be in the gray zone: a direct path to the goal, numerous dead ends, or a giant monster. We won’t know until we explore it.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_127" aria-label="127"/>&#13;
<figure class="IMG"><img id="fig8-7" class="img30" src="../images/f08007.jpg" alt="The figure shows a grid as a 5 × 5 maze. Eleven of the cells are shown and the rest are grayed out." width="421" height="421"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-7: A maze with the unseen areas grayed out</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this section, we modify the code from <a href="#list8-1">Listing 8-1</a> to conduct dynamic exploration by constructing the graph as new nodes are discovered. The auxiliary data structures such as <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> and distance must also be dynamically extended to account for new states.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2"><span id="sec14"/><span id="h-100"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1">For our example code, we generalize the algorithm by using a <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> class. This class provides basic information about the puzzle, including the following:</p>&#13;
<ul class="BL">&#13;
<li class="BL">The starting state’s index</li>&#13;
<li class="BL">A given state’s neighbors</li>&#13;
<li class="BL">The cost of a transition between any two neighboring states</li>&#13;
<li class="BL">The heuristic value at a state</li>&#13;
<li class="BL">Whether the current state is the goal</li>&#13;
</ul>&#13;
<p class="TX">Given this interface, we do not need to know anything about the state space ahead of time. Just like a real-life explorer consulting GPS and road signs, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> interface throughout the algorithm to examine the local state of the world.</p>&#13;
<p class="TX">Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> class does not need to enumerate the state space. It also does not need to construct and store the full graph. We can use functions like the ones in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span> to dynamically determine a state’s neighbors given information about the state. This dynamic evaluation allows us to explore massive state spaces without a huge memory overhead.</p>&#13;
<p class="TX">We can define a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> class for the distance-based example search in this chapter as follows:</p>&#13;
<pre><code>class World:&#13;
    def __init__(self, g: Graph, start_ind: int, goal_ind: int):&#13;
        self.g = g&#13;
        self.start_ind = start_ind&#13;
        self.goal_ind = goal_ind&#13;
&#13;
    def get_num_states(self) -&gt; int:&#13;
        return self.g.num_nodes<span role="doc-pagebreak" epub:type="pagebreak" id="pg_128" aria-label="128"/>&#13;
&#13;
    def is_goal(self, state: int) -&gt; bool:&#13;
        return state == self.goal_ind&#13;
&#13;
    def get_start_index(self) -&gt; int:&#13;
        return self.start_ind&#13;
&#13;
    def get_neighbors(self, state: int) -&gt; set:&#13;
        return self.g.nodes[state].get_neighbors()&#13;
&#13;
    def get_cost(self, from_state: int, to_state: int) -&gt; float:&#13;
        if not self.g.is_edge(from_state, to_state):&#13;
            return math.inf&#13;
        return self.g.get_edge(from_state, to_state).weight&#13;
&#13;
    def get_heuristic(self, state: int):&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> pos1 = self.g.nodes[state].label&#13;
        pos2 = self.g.nodes[self.goal_ind].label&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> return math.sqrt((pos1[0]-pos2[0])**2 + (pos1[1]-pos2[1])**2)&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> class stores the underlying graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>), the starting index (<samp class="SANS_TheSansMonoCd_W5Regular_11">start_ind</samp>), and the goal index (<samp class="SANS_TheSansMonoCd_W5Regular_11">goal_ind</samp>). In this example, they are all provided by the user. The class then uses basic getter functions to provide the information needed. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">get_start_index()</samp> returns the index of the starting state, while <samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp> lists the neighboring states. The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_cost()</samp> function uses the actual edge cost between two nodes, or infinity if there is no such edge.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_heuristic()</samp> function assumes that the node’s coordinates are stored in its label as an (<i>x</i>, <i>y</i>) tuple or list <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> and uses the Euclidean distance to the goal as the heuristic <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> (which requires the code to include <samp class="SANS_TheSansMonoCd_W5Regular_11">import math</samp>). When creating the graph, we will also need to set the labels of the nodes to contain these coordinates.</p>&#13;
<p class="TX">Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> class, we create a modified version of A* search that dynamically allocates and fills the data structures. For simplicity’s sake, we use dictionaries to map each state’s index (or string) directly to the corresponding information, as shown in <a href="#list8-2">Listing 8-2</a>.</p>&#13;
<span id="list8-2"/>&#13;
<pre><code>def astar_dynamic(w: World): &#13;
    visited: dict = {}&#13;
    last: dict = {}&#13;
    cost: dict = {}&#13;
    pq: PriorityQueue = PriorityQueue(min_heap=True)&#13;
    visited_goal: bool = False&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> start: int = w.get_start_index()&#13;
    visited[start] = False&#13;
    last[start] = -1&#13;
    pq.enqueue(start, w.get_heuristic(start))&#13;
    cost[start] = 0.0&#13;
&#13;
    while not pq.is_empty() and not visited_goal:&#13;
        index: int = pq.dequeue()<span role="doc-pagebreak" epub:type="pagebreak" id="pg_129" aria-label="129"/>&#13;
        visited[index] = True&#13;
        visited_goal = w.is_goal(index)&#13;
&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> for other in w.get_neighbors(index):&#13;
            c: float = w.get_cost(index, other)&#13;
            h: float = w.get_heuristic(other)&#13;
&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if other not in visited:&#13;
                visited[other] = False&#13;
                cost[other] = cost[index] + c&#13;
                last[other] = index&#13;
                pq.enqueue(other, cost[other] + h)&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> elif cost[other] &gt; cost[index] + c:&#13;
                cost[other] = cost[index] + c&#13;
                last[other] = index&#13;
                pq.update_priority(other, cost[other] + h)&#13;
&#13;
    return last&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: An A* search for an unknown graph</samp></p>&#13;
<p class="TX">The code in <a href="#list8-2">Listing 8-2</a> defines a modified version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">astar_search()</samp> function defined in <a href="#list8-1">Listing 8-1</a>, <samp class="SANS_TheSansMonoCd_W5Regular_11">astar_dynamic()</samp>. This function creates empty helper data structures and inserts the starting state into each one <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. The use of dictionaries means we do not need to know anything about the number of total states or their underlying indices. At this point, the data structure has information only about that single state because the code has not explored any others. It gets the index of the starting state from the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_start_index()</samp> function and its estimated cost (priority) via the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_heuristic()</samp> function.</p>&#13;
<p class="TX">The <a href="#list8-2">Listing 8-2</a> algorithm uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to explore states on the priority queue until it has either run out of states to explore or found the goal. During each iteration, the algorithm dequeues the most promising state (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>), marks it visited, and checks whether it is the goal by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">is_goal()</samp> function. In the real world, this might consist of entering a new city and looking around for familiar landmarks.</p>&#13;
<p class="TX">For each state it explores, the code checks all its neighbors using the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp> function to return the state’s local neighborhood <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. The code then computes the cost from the current node to that neighbor (<samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>), using the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_cost()</samp> function to return the edge weight. Similarly, it dynamically computes the heuristic value of that neighbor (<samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>) using the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_heuristic()</samp> function.</p>&#13;
<p class="TX">Once it has the distance to the neighbor and that neighbor’s heuristic value, the code checks whether it has encountered the neighboring state before. It checks whether the state has been seen by testing whether it has an entry with any value in the <samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp> dictionary <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. If the neighboring state is not in the dictionary, it has never been seen and is added to each data structure. The neighboring state’s cost is the sum of the cost to get to the current state (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[index]</samp>) plus the cost of the next state transition (<samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>). The neighboring state’s priority is this best cost to that state (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[other]</samp>) plus the heuristic estimate at that state (<samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_130" aria-label="130"/>If the neighbor has been seen before <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>, the code checks whether the new path is better by comparing the neighbor’s cost (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[other]</samp>) with the cost through the new path (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost[index]</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>). If the code finds a better path, it updates the path to the state (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>), the cost to reach the state (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>), and the state’s priority. Again, the code updates the priority in the queue directly.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2"><span id="sec15"/><span id="h-101"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1">Let’s apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">astar_dynamic()</samp> function to the graph from <a href="#fig8-1">Figure 8-1</a>. Of course, the algorithm does not know the graph ahead of time. It does not even know how many nodes the graph has. All the code sees is what the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> class provides.</p>&#13;
<p class="TX">We can extend our graph from the greedy and A* examples shown in <a href="#fig8-3">Figures 8-3</a> and <a href="#fig8-5">8-5</a> by adding the node’s spatial position in its label, as in the following code:</p>&#13;
<pre><code>g.nodes[1].label = [0, 2]&#13;
</code></pre>&#13;
<p class="TX">Admittedly, while this manual assignment approach works for the purpose of setting up this demonstrative example, it leads to a long problem and tedious setup for a large number of points. We discuss programmatic approaches to reading in graph data in <span class="Xref"><a href="appendix_A.xhtml">Appendix A</a></span>.</p>&#13;
<p class="TX"><a href="#fig8-8">Figure 8-8</a> shows the search. In <a href="#fig8-8">Figure 8-8(a)</a>, the algorithm knows the starting state with index 0 and the existence of a goal state. However, it knows nothing about the rest of the graph, including the edges out of node 0. The goal node doesn’t even have a number yet because the search has not seen it.</p>&#13;
<p class="TX">When the search visits node 0 in <a href="#fig8-8">Figure 8-8(b)</a>, it discovers three edges to three neighbors. Each of these edges has a weight provided by the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">get_cost()</samp> function and a heuristic value provided by the class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">get_heuristic()</samp> function. While this is not much information, it is enough for us to build up a picture of the neighborhood around the starting state. The search augments its auxiliary data structures (<samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>) to account for this by adding new entries for the corresponding nodes. It does not explicitly create a graph or store the edges.</p>&#13;
<p class="TX">This search follows the same sequence as the A* search example in <a href="#fig8-5">Figure 8-5</a>. The main difference in <a href="#fig8-8">Figure 8-8</a> lies in what the search knows about the graph at each step. It is only guaranteed to have seen all the node’s edges once it visits that node. For example, while the algorithm knows about both nodes 1 and 4 for several iterations, it does not learn about the edge between them until <a href="#fig8-8">Figure 8-8(d)</a>, when it has visited node 1.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_131" aria-label="131"/>&#13;
<figure class="IMG"><img id="fig8-8" class="img80" src="../images/f08008.jpg" alt="Each subfigure shows a partial graph, along with the sorted priority queue, the last array, and the cost array. (B) shows five nodes, where node 0 is shaded and circled, attached by edges to nodes 1, 2, and 3, and node G is not attached to any edges." width="1660" height="2368"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-8: The steps of an A* search algorithm on an unknown graph</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_132" aria-label="132"/>As in the previous A* search example, the code continues until it visits the goal node. At this point the <samp class="SANS_TheSansMonoCd_W5Regular_11">World</samp> class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">is_goal()</samp> function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, and we know that we have found the shortest path. However, as shown by <a href="#fig8-8">Figure 8-8(f)</a>, this does not mean the search has explored the entire graph. Not only did it skip visiting nodes 3 and 5, but it also never learned about the edge between them. There could be an entire world branching out beyond those nodes.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h3 class="H1" id="sec16"><span id="h-102"/><samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp></h3>&#13;
<p class="TNI1">Greedy best-first search and A* search provide mechanisms for incorporating heuristic estimates into our search algorithms, helping us find the best paths between two nodes. Greedy best-first search is simple and needs to track very little information but may produce nonoptimal paths. The combination of an admissible (optimistic) heuristic and good bookkeeping on the cost so far allows A* search to efficiently choose which nodes to explore while guaranteeing it finds the lowest-cost path.</p>&#13;
<p class="TX">The main advantage of these algorithms, particularly A*, is that the use of heuristic information focuses the search. Just as GPS coordinates can help us determine which of two possible roads will bring us to our destination more quickly, heuristics allow us to prioritize which nodes to explore next. As a result, A* search is a practical algorithm that has become a staple of artificial intelligence and video game path planning.</p>&#13;
<p class="TX">In the next part of the book, we step away from search algorithms and examine tasks related to the connectivity of graphs. We review how to sort nodes in a directed graph, consider how to test the connectivity of graphs, and examine random behavior on graphs. Many of these algorithms use searches as a core component.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>