<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_75"/><strong><span class="big">8</span></strong><br/><strong>CROSS-SITE REQUEST FORGERY ATTACKS</strong></h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="image" width="190" height="190"/></div>&#13;
<p class="noindent">In the previous chapter, you saw how attackers use cross-site scripting attacks to inject JavaScript into a user’s web browser through page elements like comment sections, search results, and URLs. Now you’ll look at how attackers use malicious links to hack your users.</p>&#13;
<p class="indent">No website is an island. Because your website has a public URL, other sites will frequently link to it, which you should generally encourage as a site owner. More inbound links to your site means more traffic and better search engine rankings.</p>&#13;
<p class="indent">However, not everybody linking to your site has good intentions. An attacker can trick a user into clicking a malicious link that triggers undesirable or unexpected side effects. This is called <em>cross-site request forgery (CSRF or XSRF)</em>. Security researchers sometimes pronounce CSRF as “sea-surf.”</p>&#13;
<p class="indent">CSRF is a remarkably common vulnerability that most major websites have exhibited at one time or another. Attackers have used CSRF to steal <span epub:type="pagebreak" id="page_76"/>Gmail contact lists, trigger one-click purchases on Amazon, and change router configuration. This chapter examines how CSRF attacks typically work and shows some coding practices that protect against them.</p>&#13;
<h3 class="h3" id="ch00lev1sec99"><strong>Anatomy of a CSRF Attack</strong></h3>&#13;
<p class="noindent">Attackers usually launch CSRF attacks by exploiting websites that implement <code>GET</code> requests that change the state of a web server. A <code>GET</code> request is triggered when a victim clicks a link, allowing the attacker to craft misleading links into the target site that perform unexpected actions. <code>GET</code> requests are the only type of HTTP request that contain the entirety of the request’s contents in a URL, so they’re uniquely vulnerable to CSRF attacks.</p>&#13;
<p class="indent">In an early iteration of Twitter, you could create tweets via <code>GET</code> requests rather than the <code>POST</code> requests the site currently uses. This oversight made Twitter vulnerable to CSRF attacks: it made it possible to create URL links that, when clicked, would post on a user’s timeline. <a href="ch08.xhtml#ch8list1">Listing 8-1</a> shows one of these URL links.</p>&#13;
<pre>https://twitter.com/share/update?status=in%20ur%20twitter%20CSRF-ing%20ur%20tweets</pre>&#13;
<p class="caption"><a id="ch8list1"/><em>Listing 8-1: A link that, at one point, would have tweeted the text</em> in ur twitter CSRF-ing ur tweets <em>to a victim’s timeline when clicked</em></p>&#13;
<p class="indent">One canny hacker used this loophole to create a viral <em>worm</em> on Twitter. Because they could use a single <code>GET</code> request to write a tweet, they constructed a malicious link that, when clicked, would post a tweet containing an obscene message <em>and</em> the same malicious link. When readers of the tweet clicked the link that the first victim tweeted, they too were tricked into tweeting the same thing.</p>&#13;
<p class="indent">The hacker tricked a handful of victims into clicking the malicious link, and those victims tweeted unexpected posts on the timelines. As more and more users read the original tweets and clicked the embedded link out of curiosity, they too tweeted the same thing. Soon, tens of thousands of Twitter users were being tricked into expressing their desire to molest goats (the content of the initial tweet). The first Twitter worm was born, and the Twitter development team scrambled to close the security hole before things got out of hand.</p>&#13;
<h3 class="h3" id="ch00lev1sec100"><strong>Mitigation 1: Follow REST Principles</strong></h3>&#13;
<p class="noindent">To protect your users against CSRF attacks, make sure that your <code>GET</code> requests don’t change the state of the server. Your website should use <code>GET</code> requests only to fetch web pages or other resources. You should perform actions that change server state—for example, logging the user in or out, resetting passwords, writing posts, or closing an account—only through <code>PUT</code>, <code>POST</code>, or <code>DELETE</code> requests. This design philosophy, called <em>Representational State Transfer (REST)</em>, comes with a host of other benefits besides CSRF protection.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_77"/>REST states that you should map website operations to the appropriate HTTP method according to their intention. You should fetch data or pages with <code>GET</code> requests, create new objects on the server (such as comments, uploads, or messages) with <code>PUT</code> requests, modify objects on the server with <code>POST</code> requests, and delete objects with <code>DELETE</code> requests.</p>&#13;
<p class="indent">Not all actions have an obvious corresponding HTTP method. For instance, when a user logs in, it’s a philosophical discussion as to whether the user is creating a new session or modifying their status. In terms of protecting against CSRF attacks, though, the key thing is to avoid assigning actions that change the server state to <code>GET</code> requests.</p>&#13;
<p class="indent">Protecting your <code>GET</code> requests doesn’t mean that there aren’t vulnerabilities in other types of requests, as you’ll see with our second mitigation.</p>&#13;
<h3 class="h3" id="ch00lev1sec101"><strong>Mitigation 2: Implement Anti-CSRF Cookies</strong></h3>&#13;
<p class="noindent">Defusing your <code>GET</code> requests shuts the door on most CSRF attacks, but you still need to protect against requests using the other HTTP verbs. Attacks using those verbs are much less common than <code>GET</code>-based CSRF attacks, and require much more work, but an attacker might try them if they think the payoff is sufficient.</p>&#13;
<p class="indent">For instance, they can trick a user into initiating a <code>POST</code> request to your site by having the victim submit a malicious form or script hosted on a third-party site under the attacker’s control. If your site performs sensitive actions in response to <code>POST</code> requests, you need to use anti-CSRF cookies to ensure that these requests are initiated only from within your site. Sensitive actions should be triggered only from your own login forms and JavaScript, rather than malicious pages that may trick the user into performing unexpected actions.</p>&#13;
<p class="indent">An <em>anti-CSRF cookie</em> is a randomized string token that the web server writes out to a named cookie parameter. Recall that cookies are small pieces of text passed back and forth between the browser and web server in HTTP headers. If the web server returns an HTTP response containing a header value like <code>Set-Cookie: _xsrf=5978e29d4ef434a1</code>, the browser will send back the same information in the next HTTP request in a header with form <code>Cookie: _xsrf=5978e29d4ef434a1</code>.</p>&#13;
<p class="indent">Secure websites use anti-CSRF cookies to verify that <code>POST</code> requests originate from pages hosted on the same web domain. HTML pages on the site add this same string token as an <code>&lt;input type="hidden" name="_xsrf" value="5978e29d4ef434a1"&gt;</code> element in any HTML form used to generate <code>POST</code> requests. When a user submits the form to the server, and the <code>_xsrf</code> value in the returned cookie doesn’t match the <code>_xsrf</code> value in the request body, the server rejects the request entirely. This way, the server validates and ensures that the request originated from within the site rather than from a malicious third-party site; the browser will send the required cookie <em>only</em> when the web page is loaded from the same domain.</p>&#13;
<p class="indent">Most modern web servers support anti-CSRF cookies. Make sure to consult the security documentation of your chosen web server to understand <span epub:type="pagebreak" id="page_78"/>how they implement these cookies, since the syntax varies slightly among web servers. <a href="ch08.xhtml#ch8list2">Listing 8-2</a> shows a template file for the Tornado web server that includes anti-CSRF protection.</p>&#13;
<pre>&lt;form action="/new_message" method="post"&gt;<br/><span class="ent">❶</span> {% module xsrf_form_html() %}<br/>   &lt;input type="text" name="message"/&gt;<br/>   &lt;input type="submit" value="Post"/&gt;<br/>&lt;/form&gt;</pre>&#13;
<p class="caption"><a id="ch8list2"/><em>Listing 8-2: A template file for the Tornado web server in Python that includes anti-CSRF protection</em></p>&#13;
<p class="indent">In this example, the <code>xsrf_form_html()</code> function <span class="ent">❶</span> generates a randomized token and writes it out in the HTML form as an input element like so: <code>&lt;input type="hidden" name="_xsrf" value="5978e29d4ef434a1"&gt;</code>. The Tornado web server then writes out this same token in the HTTP response headers as <code>Set-Cookie: _xsrf=5978e29d4ef434a1</code>. When the user submits the form, the web server validates that the token from the form and the token in the return <code>Cookie</code> header match. The browser security model will return cookies according to the <em>same-origin policy</em>, so the cookie values can only have been set by the web server. Hence the server can be sure that the <code>POST</code> request originated from the host website.</p>&#13;
<p class="indent">You should use anti-CSRF cookies to validate HTTP requests made from JavaScript, too, which allows you to also protect <code>PUT</code> and <code>DELETE</code> requests. The JavaScript needs to query out the anti-CSRF token from the HTML, and pass it back to the server in the HTTP request.</p>&#13;
<p class="indent">After you’ve implemented anti-CSRF cookies, your website should be much safer. Now you need to close one final loophole, to make sure attackers can’t steal your anti-CSRF tokens and embed them in malicious code.</p>&#13;
<h3 class="h3" id="ch00lev1sec102"><strong>Mitigation 3: Use the SameSite Cookie Attribute</strong></h3>&#13;
<p class="noindent">The final protection against CSRF attacks you must implement is to specify a <code>SameSite</code> attribute when you set cookies. By default, when a browser generates a request to your website, it will attach to the request the last known cookies that the site set, regardless of the source of the request. This means that malicious cross-site requests will arrive at your web server with any security cookies you previously set. This doesn’t defeat anti-CSRF measures in and of itself, but if an attacker steals the security token from your HTML forms, and installs it in their own malicious forms, they can still launch a CSRF attack.</p>&#13;
<p class="indent">Specifying a <code>SameSite</code> attribute when you set a cookie tells the browser to strip cookies on a request to your site when the request is generated from an external domain—like a malicious website set up by an attacker. Setting a cookie with the <code>SameSite=Strict</code> syntax in <a href="ch08.xhtml#ch8list3">Listing 8-3</a> ensures that the browser will send the cookie only with requests initiated from within your own site.</p>&#13;
<pre><span epub:type="pagebreak" id="page_79"/>Set-Cookie: _xsrf=5978e29d4ef434a1; SameSite=Strict;</pre>&#13;
<p class="caption"><a id="ch8list3"/><em>Listing 8-3: Setting the <span class="codeitalic">SameSite</span> attribute to our anti-CSRF cookie ensures that the cookie attaches to only requests from our site.</em></p>&#13;
<p class="indent">It’s a good idea to set a <code>SameSite</code> attribute on all your cookies, not just those used for CSRF protection. There’s a caveat to this, however: if you use cookies for session management, setting the <code>SameSite</code> attribute to your session cookie strips the cookie of any requests to your site generated from other websites. This means that any inbound links to your site will force the user to log in again.</p>&#13;
<p class="indent">This behavior can be a little annoying for users who already have a session open on your site. Imagine if you had to log back into Facebook every time somebody shared a video. Frustrating, right? To prevent this behavior, <a href="ch08.xhtml#ch8list4">Listing 8-4</a> shows a more useful value of the <code>SameSite</code> attribute, <code>Lax</code>, that allows only <code>GET</code> requests from other sites to send cookies.</p>&#13;
<pre>Set-Cookie: session_id=82938d911e13f3; SameSite=Lax;</pre>&#13;
<p class="caption"><a id="ch8list4"/><em>Listing 8-4: Setting the <span class="codeitalic">SameSite</span> attribute on an HTTP cookie allows cookies on <span class="codeitalic">GET</span> requests.</em></p>&#13;
<p class="indent">This allows seamless linking into your site, but strips the ability of an attacker to forge malicious actions such as <code>POST</code> requests. Provided your <code>GET</code> requests are side-effect free, this setting is no less safe.</p>&#13;
<h3 class="h3" id="ch00lev1sec103"><strong>Bonus Mitigation: Require Reauthentication for Sensitive Actions</strong></h3>&#13;
<p class="noindent">You might notice that some websites force you to reconfirm your login details when you perform sensitive actions, such as when you change your password or initiate a payment. This is known as <em>reauthentication</em>, and it’s a common way to secure sites against CSRF attacks, because it gives the user a clear indication that you’re about to do something significant and potentially dangerous.</p>&#13;
<p class="indent">Reauthentication also has the positive side effect of protecting your users if they accidentally leave themselves logged in on shared or stolen devices. If your website handles financial transactions or confidential data, you should strongly consider forcing your users to reenter their credentials when they perform sensitive actions.</p>&#13;
<h3 class="h3" id="ch00lev1sec104"><strong>Summary</strong></h3>&#13;
<p class="noindent">Attackers can use web requests from other sites to trick your users into performing undesired actions. The solution to such cross-site request forgery attacks is threefold.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_80"/>First, make sure your <code>GET</code> requests are side-effect free, so the server state is not changed when a user clicks malicious links. Second, use anti-CSRF cookies to protect other types of requests. Third, set these cookies with a <code>SameSite</code> attribute to strip cookies from requests generated by other sites.</p>&#13;
<p class="indent">For very sensitive actions on your site, it’s a good idea to require the user to reauthenticate themselves when they request to perform these actions. This adds an additional layer of protection against CSRF attacks, and protects your users if they accidentally leave themselves logged in on shared or stolen devices.</p>&#13;
<p class="indent">In the next chapter, you’ll look at how hackers try to exploit vulnerabilities during the authentication process.</p>&#13;
</div>



  </body></html>