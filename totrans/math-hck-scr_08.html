<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2-h" id="ch08"><span epub:type="pagebreak" id="page_151"/><span class="color2"><strong>8</strong></span></h2>&#13;
<h2 class="h2-hd"><strong>Three Helpings of Pi</strong></h2>&#13;
<div class="imagec"><img src="../images/common.jpg" alt="Image" width="167" height="189"/></div>&#13;
<p class="noindent">The number <em>π</em> (pi) represents the ratio of a circle’s circumference (the distance all the way around the circle’s “rim”) to its diameter (the straight line distance from one side of the circle through its center to the other side). Remarkably, the value of this ratio is the same no matter what size the circle is. Other properties of a circle, like its area, depend on its size, but not <em>π</em>; as the size of the circle increases, the ratio of the increasing circumference to the increasing diameter remains constant.</p>&#13;
<p class="indent">You can think of measurements of circumference and diameter as being given in a common length unit, like centimeters or inches. In the ratio, the units of these measurements cancel out, leaving <em>π</em> as a pure number, dimensionless. It’s often approximated as 3.14, but the digits beyond the decimal point actually continue on forever, without repeating. Over the years, mathematicians have devised lots of different ways to calculate <em>π</em>, with varying degrees of accuracy. In this chapter, we’ll consider a few such techniques, using algebra, geometry, and even number theory.</p>&#13;
<h3 class="h3" id="ch08lev1"><span epub:type="pagebreak" id="page_152"/>How Archimedes Calculated Pi</h3>&#13;
<p class="noindent">Let’s first explore an approach to calculating <em>π</em> used by the ancient Greek mathematician Archimedes. Start by drawing a circle, then draw an <em>inscribed</em> polygon, a shape that fits completely inside the circle with its corners just touching the circle’s rim. Next, draw a <em>circumscribed</em> polygon, a shape that completely surrounds the circle such that the midpoint of each side touches the rim of the circle. The two polygons should have the same number of sides, and they should be <em>regular</em> polygons, meaning all their sides are of equal length. <a href="ch08.xhtml#ch8fig1">Figure 8-1</a> shows what this drawing might look like.</p>&#13;
<p class="indent">Notice that the perimeter of the inscribed (purple) hexagon is smaller than the circumference of the circle, and the perimeter of the circumscribed (black) hexagon is larger than the circumference of the circle. This means we can use the perimeters of these two hexagons to find lower and upper bounds for the value of <em>π</em>.</p>&#13;
<p class="indent">The figure doesn’t specify length units, so let’s say the circle has a radius of <em>r</em> = 1. A circle with a radius of 1 is called a <em>unit circle</em>. This unit circle has a circumference of <em>C</em> = 2<em>πr</em> = 2<em>π</em>. The inscribed hexagon is made up of six equilateral triangles with side length 1, so by summing the lengths of the outer edges of the triangles we can determine that the size of the perimeter of the inscribed hexagon is 6. This in turn tells us that 2<em>π</em> &gt; 6, so <em>π</em> &gt; 3.</p>&#13;
<div class="image"><img id="ch8fig1" src="../images/pg172_Image_208.jpg" alt="Image" width="247" height="284"/></div>&#13;
<p class="figcap"><em>Figure 8-1: Inscribed and circumscribed hexagons</em></p>&#13;
<p class="indent">With a little bit of trigonometry, we can calculate that the circumscribed hexagon has sides of length (2<img class="inline" src="../images/pg172_Image_209.jpg" alt="Image" width="29" height="21"/>) / 3, so the size of its perimeter is (6 ⋅ 2<img class="inline" src="../images/pg172_Image_209.jpg" alt="Image" width="29" height="21"/>) / 3. This equals 4<img class="inline" src="../images/pg172_Image_209.jpg" alt="Image" width="29" height="21"/>, and if 2<em>π</em> &lt; 4<img class="inline" src="../images/pg172_Image_209.jpg" alt="Image" width="29" height="21"/>, then <em>π</em> &lt; 2<img class="inline" src="../images/pg172_Image_209.jpg" alt="Image" width="29" height="21"/>, or approximately 3.4642.</p>&#13;
<p class="indent">We now know that <em>π</em> is between 3 and 3.4642. To get a little more precision, let’s try doubling the number of sides of the inscribed and circumscribed polygons. As the number of sides increases, the inner and outer polygons nestle closer to the circle. <a href="ch08.xhtml#ch8fig2">Figure 8-2</a> shows what happens when we go from 6 sides to 12, for example.</p>&#13;
<p class="indent">As the polygons get closer and closer to the circle, their perimeters <em>converge</em> on the value of 2<em>π</em>. Archimedes went from 6- to 12- to 24- to 48- to 96-sided polygons and reached an approximation for <em>π</em> that was the best known for centuries: 223 / 71 &lt; <em>π</em> &lt; 22 / 7.</p>&#13;
<div class="image"><img id="ch8fig2" src="../images/pg172_Image_210.jpg" alt="Image" width="283" height="283"/></div>&#13;
<p class="figcap"><em>Figure 8-2: Inscribed and circumscribed 12-sided polygons</em></p>&#13;
<p class="indent">Archimedes arrived at his approximation by developing a recurrence rule for tracking how the perimeters change when you double the number of sides of the two polygons. The recurrence takes <em>a</em><sub><em>n</em></sub> and <em>b</em><sub><em>n</em></sub>, the old upper and lower bounds of <em>π</em>, and calculates the new upper and lower bounds after the doubling, <em>a</em><sub><em>n</em> + 1</sub> and <em>b</em><sub><em>n</em> + 1</sub>, as follows:</p>&#13;
<div class="imagec"><img src="../images/pg172_Image_211.jpg" alt="Image" width="202" height="114"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_153"/>For example, to go from our initial hexagons, where <em>a</em><sub>1</sub> = 2<img class="inline" src="../images/pg172_Image_209.jpg" alt="Image" width="29" height="21"/> and <em>b</em><sub>1</sub> = 3, to the 12-sided polygons, we calculate</p>&#13;
<div class="imagec"><img src="../images/pg173_Image_212.jpg" alt="Image" width="429" height="68"/></div>&#13;
<p class="noindent">and:</p>&#13;
<div class="imagec"><img src="../images/pg173_Image_213.jpg" alt="Image" width="494" height="83"/></div>&#13;
<p class="noindent">This tells us that <em>π</em> must be between 3.10583 and 3.21539.</p>&#13;
<p class="indent">The calculation for <em>a</em><sub><em>n</em> + 1</sub> is called the <em>harmonic mean</em> of <em>a</em><sub><em>n</em></sub> and <em>b</em><sub><em>n</em></sub>. The calculation for <em>b</em><sub><em>n</em> + 1</sub> is the <em>geometric mean</em> of <em>a</em><sub><em>n</em> + 1</sub> and <em>b</em><sub><em>n</em></sub>. You can find more details about what these terms mean and how Archimedes used trigonometry to derive his recurrence at <em><a href="https://mathworld.wolfram.com/ArchimedesRecurrenceFormula.html">https://mathworld.wolfram.com/ArchimedesRecurrenceFormula.html</a></em>.</p>&#13;
<h4 class="h4" id="ch08lev2">Project 30: Archimedes’s Recurrence</h4>&#13;
<p class="noindent">In this project, we’ll program Archimedes’s recurrence in Scratch in order to calculate an approximation of <em>π</em>. We’ll start with hexagons, which, as we’ve established, give an upper bound <em>a</em><sub>1</sub> of 2<img class="inline" src="../images/pg172_Image_209.jpg" alt="Image" width="29" height="21"/> and a lower bound <em>b</em><sub>1</sub> of 3. Then, we’ll have the number of sides double from there. <a href="ch08.xhtml#ch8fig3">Figure 8-3</a> shows the code.</p>&#13;
<div class="image"><img id="ch8fig3" src="../images/pg173_Image_214.jpg" alt="Image" width="613" height="794"/></div>&#13;
<p class="figcap"><em>Figure 8-3: Calculating <em>π</em> starting from inscribed and circumscribed hexagons</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_154"/>After setting the starting values for the upper and lower bounds <span class="ent">❶</span>, we use a loop to calculate new values until the results are equal <span class="ent">➋</span>, meaning we’ve reached the highest level of accuracy that Scratch can support. We store the upper bounds in list <span class="literal">A</span> and the lower bounds in list <span class="literal">B</span>. In the loop, notice how we calculate the new value of <span class="literal">a</span> first so we can use it in our calculation of <span class="literal">b</span>.</p>&#13;
<h5 class="h5" id="ch08lev3">The Results</h5>&#13;
<p class="noindent"><a href="ch08.xhtml#ch8fig4">Figure 8-4</a> shows the contents of the <span class="literal">A</span> and <span class="literal">B</span> lists after running the program.</p>&#13;
<div class="image"><img id="ch8fig4" src="../images/pg174_Image_215.jpg" alt="Image" width="677" height="673"/></div>&#13;
<p class="figcap"><em>Figure 8-4: Starting with hexagons and converging to π</em></p>&#13;
<p class="indent">It takes just 27 cycles of the loop for us to hit the accuracy limits of Scratch’s floating-point representation. At this point, the values of the bounds converge on 3.141592653589792. You can check that the first several digits are right if you remember the mnemonic “How I need a shake, chocolate of course, after the heavy lectures involving quantum mechanics.” Count the letters in each word to get the first 15 digits of <em>π</em>: “How I need” is 3, 1, 4, and so on.</p>&#13;
<h5 class="h5" id="ch08lev4">Hacking the Code</h5>&#13;
<p class="noindent">The side-doubling recurrence works even if we don’t start with hexagons. Suppose we approximate the circumference of a circle with inscribed and circumscribed squares, as in <a href="ch08.xhtml#ch8fig5">Figure 8-5</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_155"/><img id="ch8fig5" src="../images/pg175_Image_216.jpg" alt="Image" width="284" height="284"/></div>&#13;
<p class="figcap"><em>Figure 8-5: Using squares to approximate circumference</em></p>&#13;
<p class="indent">If the circle still has a radius of 1, the outer square has a perimeter of 8. By the Pythagorean theorem, the inner square has sides of length <img class="inline" src="../images/pg175_Image_217.jpg" alt="Image" width="29" height="23"/>. Since the circle has a circumference of 2<em>π</em>, the first estimate is therefore 2<img class="inline" src="../images/pg175_Image_217.jpg" alt="Image" width="29" height="23"/> &lt; <em>π</em> &lt; 4. To run the recurrence from there, just replace the two blocks setting the initial values of <span class="literal">a</span> and <span class="literal">b</span> (see <a href="ch08.xhtml#ch8fig3">Figure 8-3</a> <span class="ent">❶</span> on <a href="ch08.xhtml#page_153">page 153</a>) with the blocks in <a href="ch08.xhtml#ch8fig6">Figure 8-6</a>.</p>&#13;
<div class="image"><img id="ch8fig6" src="../images/pg175_Image_218.jpg" alt="Image" width="482" height="151"/></div>&#13;
<p class="figcap"><em>Figure 8-6: New initial values for the recurrence</em></p>&#13;
<p class="indent"><a href="ch08.xhtml#ch8fig7">Figure 8-7</a> shows the result of running the program with these new starting values.</p>&#13;
<div class="image"><img id="ch8fig7" src="../images/pg175_Image_219.jpg" alt="Image" width="689" height="643"/></div>&#13;
<p class="figcap"><em>Figure 8-7: Starting with squares and converging to π</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_156"/>Even though the recurrence starts with wider bounds, it quickly converges, once again taking 27 cycles to hit Scratch’s accuracy limit.</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenge</p>&#13;
<p class="indentib"><span class="blue"><strong>8.1</strong></span><span class="space"/>Figure out the initial values for the recurrence if you start with inscribed and circumscribed triangles. Since the first doubling of sides goes from triangles to hexagons, the output from the second line on should be the same as in <a href="ch08.xhtml#ch8fig4">Figure 8-4</a>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch08lev5">Estimating Pi from the Area of a Circle</h3>&#13;
<p class="noindent">Another way to calculate <em>π</em> is to use <em>A</em> = <em>πr</em><sup>2</sup>, the formula for the area of a circle. Imagine you’ve drawn a circle with a radius of <em>r</em> on top of a grid, with its center at point (0, 0). Any point (<em>x</em>, <em>y</em>) inside the circle will satisfy the inequality <em>x</em><sup>2</sup> + <em>y</em><sup>2</sup> &lt; <em>r</em><sup>2</sup>. Say we focus only on points whose coordinates are integers. These are known as <em>lattice points</em>. We can think of each lattice point as the lower-left corner of a <em>unit square</em>, a square with a side length <em>s</em> = 1 and area <em>s</em><sup>2</sup> = 1. Counting the number of lattice points inside the circle (the ones that satisfy the <em>x</em><sup>2</sup> + <em>y</em><sup>2</sup> &lt; <em>r</em><sup>2</sup> inequality) gives us an approximation of the area of the circle. <a href="ch08.xhtml#ch8fig8">Figure 8-8</a> shows an example of how this works, for a circle with a radius of 4.</p>&#13;
<div class="image"><img id="ch8fig8" src="../images/pg176_Image_220.jpg" alt="Image" width="453" height="442"/></div>&#13;
<p class="figcap"><em>Figure 8-8: Lattice points in a circle with a radius of 4</em></p>&#13;
<p class="indent">The lattice points inside the circle are shown as purple dots. There are 45 in all. Each lattice point marks the lower-left corner of a yellow unit square. A few of these squares extend beyond the circle, but this is offset by the parts of the circle that the squares don’t cover. On balance, we can say that the circle has an approximate area of 45, the same as the area covered by the yellow squares. We know the area of a circle is <em>πr</em><sup>2</sup>, so dividing 45 by <em>r</em><sup>2</sup> gives us an estimated value for <em>π</em>: 45 / 16 = 2.8125.</p>&#13;
<p class="indent">If we also count the four lattice points that fall directly on the perimeter of the circle—points (4, 0), (0, 4), (–4, 0), and (–4, 0)—we can get a better approximation: 49 / 16 = 3.0625. We could get even closer by using a bigger circle. This is because the area of the circle grows in proportion to the square of the radius, but the error comes only from the squares around the circumference, the number of which grows only in proportion to the first power of the radius. So the bigger the <span epub:type="pagebreak" id="page_157"/>circle is, the less the error is relative to the overall area. In our next project, we’ll see how much we can improve our estimate by increasing the size of the radius, with Scratch handling the calculations for us.</p>&#13;
<h4 class="h4" id="ch08lev6">Project 31: Using the Lattice Point Tally</h4>&#13;
<p class="noindent"><a href="ch08.xhtml#ch8fig9">Figure 8-9</a> shows some Scratch code that prompts for a radius and counts lattice points in the resulting circle to approximate <em>π</em>. The output keeps track of both the number of lattice points that satisfy the condition <em>x</em><sup>2</sup> + <em>y</em><sup>2</sup> &lt; <em>r</em><sup>2</sup> and the resulting estimated value of <em>π</em>.</p>&#13;
<div class="image"><img id="ch8fig9" src="../images/pg177_Image_221.jpg" alt="Image" width="843" height="1085"/></div>&#13;
<p class="figcap"><em>Figure 8-9: Counting lattice points to determine π</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_158"/>We first ask for a value for the circle’s radius. Then, we use two nested loops <span class="ent">❶</span> to step through the rows and columns of lattice points in a square circumscribed around the circle. We start in the top-right corner of the square, where <span class="literal">x</span> and <span class="literal">y</span> both equal the radius <em>r</em>, and work toward the bottom-left corner, where they equal –<em>r</em>. For each pair of coordinates, we check if the point is in the circle <span class="ent">➋</span> and increment the lattice count if it is. At the end, we divide the lattice count by the square of the radius to get the approximation of <em>π</em>.</p>&#13;
<h5 class="h5" id="ch08lev7">The Results</h5>&#13;
<p class="noindent"><a href="ch08.xhtml#ch8fig10">Figure 8-10</a> shows the result of running the program for a circle with a radius of 1,000.</p>&#13;
<div class="image"><img id="ch8fig10" src="../images/pg178_Image_222.jpg" alt="Image" width="577" height="206"/></div>&#13;
<p class="figcap"><em>Figure 8-10: Counting lattice points in a circle with</em> r <em>= 1,000</em></p>&#13;
<p class="indent">This approximation of <em>π</em> is accurate up to the first four decimal places. Much better!</p>&#13;
<h5 class="h5" id="ch08lev8">Hacking the Code</h5>&#13;
<p class="noindent">For a circle with a radius of <em>r</em>, the program in <a href="ch08.xhtml#ch8fig9">Figure 8-9</a> has to check (2<em>r</em>)<sup>2</sup> lattice points. When <em>r</em> = 1,000, that’s 4 million points to check, which takes a little while. The delay gets worse as the circle gets bigger. If <em>r</em> = 10,000, for example, there will be 400 million points to check, and you’ll be waiting a very long time for your results.</p>&#13;
<p class="indent">But why check <em>all</em> the points? We can sample a smaller number of randomly selected lattice points and use those to make a guess about the overall area of the circle. <a href="ch08.xhtml#ch8fig11">Figure 8-11</a> shows how.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_159"/><img id="ch8fig11" src="../images/pg179_Image_223.jpg" alt="Image" width="783" height="833"/></div>&#13;
<p class="figcap"><em>Figure 8-11: Sampling random lattice points to determine π</em></p>&#13;
<p class="indent">The variable <span class="literal">tries</span> controls the <span class="literal">repeat</span> loop <span class="ent">❶</span> and determines how many random points to check. I recommend setting it to about 10 times the radius of the circle. We can confine ourselves to looking only at points in the first quadrant of the grid, where the coordinates are positive integers, by picking random <span class="literal">x</span> and <span class="literal">y</span> values between <span class="literal">0</span> and <span class="literal">radius</span> <span class="ent">➋</span>. If the point falls within the circle, we update the lattice count as before. With enough tries, we should see the following equivalence:</p>&#13;
<div class="imagec"><img src="../images/pg179_Image_224.jpg" alt="Image" width="149" height="58"/></div>&#13;
<p class="indent">The left side of this equivalence is the ratio of “hits” (lattice points in the circle) to the total number of points sampled. The right side is the ratio of one-fourth of the circle’s area (the part of the circle in the first quadrant of the grid) to the square of its radius. Think of <em>r</em><sup>2</sup> here as the area of the first-quadrant square containing all the points we can possibly sample. Substituting <em>A</em> for <em>πr</em><sup>2</sup> and solving for <em>π</em>, we get:</p>&#13;
<div class="imagec"><img src="../images/pg179_Image_225.jpg" alt="Image" width="137" height="56"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_160"/>We use this equation at the end of the program to estimate <em>π</em>. <a href="ch08.xhtml#ch8fig12">Figure 8-12</a> shows an example result, with a radius of 10,000 and 100,000 randomly sampled points.</p>&#13;
<div class="image"><img id="ch8fig12" src="../images/pg180_Image_226.jpg" alt="Image" width="553" height="212"/></div>&#13;
<p class="figcap"><em>Figure 8-12: Estimating π through random trials</em></p>&#13;
<p class="indent">Your output from this program will probably be different every time you run it, since the random number generator determines the choice of points to test. Still, the result we got here is pretty close, and it’s calculated much more quickly than it would have been if the program had checked every single lattice point in the circle.</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenge</p>&#13;
<p class="indentib"><span class="blue"><strong>8.2</strong></span><span class="space"/>There’s a subtle difference between these two versions of the <span class="literal">pick random</span> block:</p>&#13;
<div class="imagec"><img src="../images/pg180_Image_227.jpg" alt="Image" width="561" height="52"/></div>&#13;
<p class="noindent-s">Embed each block in a little bit of code that reports the result to see how they behave. The version with <span class="literal">1</span> returns integer values, so asking for values between 0 and 1 gives 0 about half the time and 1 about half the time. The version with <span class="literal">1.0</span> returns values between 0 and 1, which aren’t necessarily integers. If we don’t have integer (<em>x, y</em>) coordinates, then we don’t have true lattice points, but does that matter? See if the code in <a href="ch08.xhtml#ch8fig11">Figure 8-11</a> still works if the randomly chosen points don’t have integer coordinates.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch08lev9">Approximating Pi with Relative Primes</h3>&#13;
<p class="noindent">The number <em>π</em> shows up in many places in mathematics that seem to be far removed from circles and geometry. One interesting formula involving <em>π</em> relates back to the idea of common divisors from <a href="ch02.xhtml#ch02">Chapters 2</a> and <a href="ch03.xhtml#ch03">3</a>. Remember that a <em>common divisor</em> of two integers is a number that’s a divisor of each one. If the only common divisor that two integers have is 1, then the two integers are said to be <em>relatively prime</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_161"/>Here’s a geometric way to interpret relative primes. Suppose you’re standing at the origin of a coordinate plane, at the point (0, 0), looking out at the lattice points. You can see most of them, but some are blocked because there’s another lattice point in the way. For example, <a href="ch08.xhtml#ch8fig13">Figure 8-13</a> marks the <em>visible lattice points</em> in the first quadrant as purple dots. The straight black lines show that the point (1, 1) blocks the points (2, 2), (3, 3), and so on; the point (2, 1) blocks (4, 2) and (6, 3); and the point (3, 2) blocks (6, 4).</p>&#13;
<div class="image"><img id="ch8fig13" src="../images/pg181_Image_228.jpg" alt="Image" width="594" height="593"/></div>&#13;
<p class="figcap"><em>Figure 8-13: Visible and hidden lattice points</em></p>&#13;
<p class="indent">The coordinates of the visible points, such as (1, 1), (7, 2), and (3, 8), are relatively prime. The coordinates of blocked points, such as (6, 8) and (2, 4), are not. The 8×8 square shown in <a href="ch08.xhtml#ch8fig13">Figure 8-13</a> has 44 visible lattice points in it out of 64 points total, so the proportion that are visible is 44 / 64 ≈ 0.6875. This tells us the proportion of pairs of numbers between 1 and 8 that are relatively prime.</p>&#13;
<p class="indent">Now suppose we expand the size of the square. What happens to the number of visible lattice points and to the number of relatively prime pairs? Both numbers grow, of course, but in a very specific way. As the size of the square grows, the proportion of the square’s lattice points that are visible approaches a limiting value of about 0.608. The amazing thing is that this number has a value related to <em>π</em>. It’s 6/<em>π</em><sup>2</sup>. The reason for this is a little too advanced for this book (if you’re interested, it has to do with the Riemann zeta function), but we can still explore how the ratio behaves and use it to estimate the value of <em>π</em>.</p>&#13;
<h4 class="h4" id="ch08lev10">Project 32: Using Only Visible Lattice Points</h4>&#13;
<p class="noindent">Let’s write a program that counts the number of visible lattice points within a first-quadrant square of a given size and uses that count to calculate an approximation <span epub:type="pagebreak" id="page_162"/>of <em>π</em>. (We’re using a square here rather than a circle because it’s easier to generate the points in a square with nested loops.) Since each visible point’s coordinates will be relatively prime, we can use the custom <span class="literal">gcd</span> (greatest common divisor) block we created for <a href="ch02.xhtml#ch02lev14">Project 9</a> back in <a href="ch02.xhtml#ch02">Chapter 2</a> to help (see <a href="ch02.xhtml#ch2fig17">Figure 2-17</a> on <a href="ch02.xhtml#page_38">page 38</a> for the block definition). If the GCD of a set of coordinates is 1, we’ve found a visible lattice point. <a href="ch08.xhtml#ch8fig14">Figure 8-14</a> shows the code.</p>&#13;
<div class="image"><img id="ch8fig14" src="../images/pg182_Image_229.jpg" alt="Image" width="665" height="944"/></div>&#13;
<p class="figcap"><em>Figure 8-14: Approximating π by counting visible lattice points</em></p>&#13;
<p class="indent">We prompt for a quadrant size, then test all lattice points within the square with lower-left corner (<span class="literal">1</span>, <span class="literal">1</span>) and upper-right corner (<span class="literal">size</span>, <span class="literal">size</span>) using nested loops <span class="ent">❶</span>. We start at (1,1) so we’re always calculating GCDs of pairs of positive integers. For every visible lattice point whose coordinates yield a GCD of <span class="literal">1</span>, we increment the <span class="literal">count</span> variable.</p>&#13;
<p class="indent">After the loops are completed, we use the value of <span class="literal">count</span> to approximate <em>π</em>. We already know the following:</p>&#13;
<div class="imagec"><img src="../images/pg182_Image_230.jpg" alt="Image" width="155" height="60"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_163"/>Solving for <em>π</em>, we get:</p>&#13;
<div class="imagec"><img src="../images/pg183_Image_231.jpg" alt="Image" width="186" height="83"/></div>&#13;
<p class="noindent">We make this calculation at the end of the program <span class="ent">➋</span>.</p>&#13;
<h5 class="h5" id="ch08lev11">The Results</h5>&#13;
<p class="noindent">It’s fun to run this program for a fairly large square, say <span class="literal">size = 1000</span>, and watch Scratch Cat take a few seconds to tally the points as they’re counted. <a href="ch08.xhtml#ch8fig15">Figure 8-15</a> shows the results. As before, the larger the sample size, the more accurate the approximation is likely to be.</p>&#13;
<div class="image"><img id="ch8fig15" src="../images/pg183_Image_232.jpg" alt="Image" width="448" height="219"/></div>&#13;
<p class="figcap"><em>Figure 8-15: Visible lattice points in a square of size 1,000</em></p>&#13;
<p class="indent">Once again, the value of <em>π</em> is accurate for at least the first few decimal places.</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib"><span class="blue"><strong>8.3</strong></span><span class="space"/>The series behind the visible lattice point enumeration is:</p>&#13;
<p class="center"><em>π</em><sup>2</sup>/6 = 1 + 1/4 + 1/9 + 1/16 + . . . + 1/<em>n</em><sup>2</sup> + . . .</p>&#13;
<p class="noindent-s">Use Scratch to check this out by working out the first several partial sums:</p>&#13;
<p class="center">1, 1 + 1/4, 1 + 1/4 + 1/9, . . .</p>&#13;
<p class="indentib"><span class="blue"><strong>8.4</strong></span><span class="space"/>A formula for <em>π</em> involving an infinite series is <em>π</em>/4 = 1 – 1/3 + 1/5 – 1/7 + . . . . This is sometimes called the <em>Gregory series</em>. Program Scratch to use this formula to get the first few digits of <em>π</em>.</p>&#13;
<p class="indentib"><span class="blue"><strong>8.5</strong></span><span class="space"/>The series in Challenge 8.3 consists of all positive terms, while the Gregory series has terms that alternate between positive and negative. Compare how many terms of each series it takes to get a value of <em>π</em> that’s accurate to three decimal places. In general, alternating series converge much more slowly than series of positive terms.</p>&#13;
<p class="indentib"><span epub:type="pagebreak" id="page_164"/><span class="blue"><strong>8.6</strong></span><span class="space"/>In <a href="ch08.xhtml#ch08lev6">Project 31</a>, we used two versions of the area calculation to approximate <em>π</em>: one using every point in the square and one sampling points at random. Try applying a similar random approach to <a href="ch08.xhtml#ch08lev10">Project 32</a>. Examine a random sampling of lattice points, count how many have relatively prime coordinates, and use that count to approximate <em>π</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch08lev12">Conclusion</h3>&#13;
<p class="noindent">The number <em>π</em> comes up in lots of places in math, which leads to many different techniques for calculating its approximate value. Because of the limits of the IEEE 754 floating-point representation, Scratch can’t express <em>π</em> exactly. But then again, neither can we, since the digits of <em>π</em> go on forever! With Scratch Cat’s help, though, we can easily approximate its value in various ways, with up to 15 or 16 digits of accuracy.</p>&#13;
</div>
</div>
</body></html>