<html><head></head><body>
<h2 class="h" id="ch03"><span epub:type="pagebreak" id="page_61" class="calibre1"/><strong class="calibre2"><span class="big">3</span><br class="calibre3"/>MODULES AND PACKAGES</strong></h2>
<div class="bq">
<p class="center"><em class="calibre11">Information about the package is as important as the package itself.</em></p>
<p class="center1"><em class="calibre11">—</em>Frederick W. Smith, founder of FedEx</p>
</div>
<div class="image"><img alt="Image" src="../images/common.jpg" class="calibre6"/></div>
<p class="noindent">In the previous chapter, I mentioned that Julia programs are organized around collections of functions. The functions are the verbs of your program, meaning they describe what it does. You could spend your whole Julia programming life working in the REPL or in Pluto while saving programs in files using nothing more than function, variable, and data type definitions.</p>
<p class="indent">But when it comes time to develop projects that build on your previous work systematically, or to allow other people to use your code in their projects, you will want to take advantage of the structures Julia provides to organize and share your programs. Even if you never reuse or distribute your own code, you will use code from the Julia standard library, from other official Julia packages, and perhaps from other researchers. In any case, familiarity with Julia’s module and package system is essential.<span epub:type="pagebreak" id="page_62"/></p>
<h3 class="h2" id="ch03lev1"><strong class="calibre2">Modules</strong></h3>
<p class="noindent">Julia programmers make liberal use of modules both in the REPL and in program files, and borrowing existing facilities for plotting, solving equations, serving websites, and countless other activities is routine. <em class="calibre11">Creating</em> modules, however, is of little use in the REPL. The modules you create will live in files, ready to be used as needed.</p>
<h4 class="h3" id="ch03lev1sec1"><strong class="calibre2"><em class="calibre4">Understanding Namespaces</em></strong></h4>
<p class="noindent">A <em class="calibre11">namespace</em> is a grouping for names that distinguishes them from identical names existing in other groups. We need namespaces because functions and variables may be defined in different places but happen to have identical names, and we need a way to make it clear which object we are referring to.</p>
<p class="indent">When we define an object in the REPL we can refer to it later with its name. For example, after an assignment such as <code>a = 1</code>, the variable <code>a</code> will return <code>1</code>. We say that <code>a</code> is defined in the <em class="calibre11">global namespace</em>. The terminology varies: sometimes it’s <em class="calibre11">top-level namespace</em> and sometimes <em class="calibre11">main namespace</em>. In any case, the <em class="calibre11">current namespace</em> is the one in which we’re working.</p>
<p class="indent">When we need to refer to objects defined elsewhere, we have two options. We can call them by their unadorned names, as if they had been defined in the current namespace, or we can refer to them with a name such as <code>SomeModule.a</code>. In the latter case, we say that <code>a</code> is in the <code>SomeModule</code> namespace, and we have used a <em class="calibre11">qualified name</em> for it.</p>
<p class="indent">The two names <code>SomeModule.a</code> and <code>a</code> can refer to different objects—perhaps even to different types of objects. The identifier <code>a</code> might be a variable that we’ve defined in the REPL, and <code>SomeModule.a</code> might be a function defined in the <code>SomeModule</code> module. In the next section, we’ll learn how objects from other modules sometimes wind up in our current namespace and when we need to use qualified names to refer to them.</p>
<h4 class="h3" id="ch03lev1sec2"><strong class="calibre2"><em class="calibre4">Using Installed Modules</em></strong></h4>
<p class="noindent">A Julia installation comes with many modules ready for use. The resources in two particular modules, <code>Base</code> and <code>Core</code>, are always automatically available, which is why we can invoke the functions that we used in the previous chapter, such as <code>abs()</code>, without loading anything explicitly. Most of these essential functions are in the <code>Base</code> module. <code>Base</code> also supplies such basics as the <code>+</code> operator, which is also a function under the hood. The <code>Core</code> module exists at an even deeper level and contains such foundation stones as the <code>Int64</code> data type. Although you can’t do much without <code>Base</code>, you can arrange for it to not be loaded. The small <code>Core</code> module is necessary for Julia to work, however, so it’s not optional.</p>
<p class="indent">The <em class="calibre11">standard library</em> is a collection of modules that’s always installed with Julia but that you need to load explicitly to be able to use. The modules in the standard library provide functionality that is commonly needed across a variety of computations, but that is less fundamental than, for example, the <span epub:type="pagebreak" id="page_63"/>arithmetic operators. You will never need everything in the standard library in any particular program, but a typical program will make use of several of its modules.</p>
<p class="indent">You can load the resources in a module with either the <code>using</code> or <code>import</code> statements.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">Most modules have uppercase initials and use “camel case” for their names, such as</em> <span class="codeitalic1">LinearAlgebra</span> <em class="calibre11">from the standard library. Although you’re free to ignore such naming conventions (including the use of ! explained in <a href="ch02.xhtml#ch02lev1sec17" class="calibre10">“Functions That Mutate Their Arguments</a>” on <a href="ch02.xhtml#ch02lev1sec17" class="calibre10">page 56</a>) in your own projects, following them will make your code easier to read for other Julia programmers.</em></p>
</div>
<p class="indent">The <code>using</code> statement provides access to everything in the module. It brings all the names that the module creator has marked for export into the current namespace. So, for example, after executing <code>using Plots</code>, we can use the <code>plot()</code> function directly, as in <code>plot(x -&gt; x^2)</code>.</p>
<p class="indent">We can use any name that we know of, however, even if it’s not exported. Julia has no secrets. Prefix the unexported name with the name of the module and a dot. For example, <code>Plots.surface(x, y, f)</code> will work regardless of whether <code>surface</code> is exported. In this case, we are invoking <code>surface</code> in the <code>Plots</code> namespace.</p>
<p class="indent">The other way to use resources from other modules involves the <code>import</code> statement. The only difference between <code>import</code> and <code>using</code> has to do with how we use names. If we execute <code>import Plots</code>, <code>Plots.surface(x, y, f)</code> will work, but just using <code>surface(x, y, f)</code> will not. The <code>import</code> statement provides access to everything in the module, just as <code>using</code> does, but <em class="calibre11">not in the current namespace</em>. You must use the module’s namespace.</p>
<p class="indent">You can use either statement with a list of modules separated by commas: <code>using <em class="calibre11">Module1, Module2, Module3</em></code>.</p>
<p class="indent">To show the difference between the <code>using</code> and <code>import</code> statements, we’ll use two modules from the standard library: the <code>LinearAlgebra</code> module, which contains functions for solving sets of linear equations, inverting matrices, and other linear algebra operations, and <code>Random</code>, which provides random number functions.</p>
<p class="indent"><a href="ch03.xhtml#ch3lis1" class="calibre10">Listing 3-1</a> uses some functions from the standard library.</p>
<pre class="calibre13">   using LinearAlgebra
   import Random

<span class="ent">➊</span> function randexp()
       17
   end

   a = [1 1]
   b = [0 1]

<span class="ent">➋</span> dot(a, b) |&gt; println

<span class="ent">➌</span> Random.randexp() |&gt; println

<span class="ent">➍</span> randexp() |&gt; println</pre>
<p class="list" id="ch3lis1"><span epub:type="pagebreak" id="page_64"/><em class="calibre11">Listing 3-1: Two ways to import a module</em></p>
<p class="indent">The first two lines make the resources from the two standard library modules available in the rest of the program. The difference between the <code>using</code> and <code>import</code> statements is in how we refer to those resources.</p>
<p class="indent">The <code>using LinearAlgebra</code> statement allows us to use all of the <em class="calibre11">exported names</em> from this module directly. The exported names are those that appear in an <code>export</code> statement in the module. We can use the <code>dot()</code> function <span class="ent">➋</span>, which computes the dot product of two vectors, directly, because it’s exported by <code>LinearAlgebra</code>, and the <code>using LinearAlgebra</code> statement pulled it into the current namespace. (The dot product of [<em class="calibre11">a</em>, <em class="calibre11">b</em>] and [<em class="calibre11">c</em>, <em class="calibre11">d</em>] is <em class="calibre11">ac</em>+<em class="calibre11">bd</em>.) We can refer to the function using <code>LinearAlgebra.dot()</code> as well; the two names refer to the same object.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">Sometimes</em> <span class="codeitalic1">import</span> <em class="calibre11">and</em> <span class="codeitalic1">using</span> <em class="calibre11">statements incur significant delays. Julia is precompiling some functions in the module to make their use more efficient.</em></p>
</div>
<p class="indent">The other way to use resources from other modules involves the <code>import</code> statement, as we used in the second line: <code>import Random</code>. The only difference between <code>import</code> and <code>using</code> has to do with the use of names. Since we <em class="calibre11">imported</em> <code>Random</code>, to use its functions we must prefix them with the name of the module <span class="ent">➌</span>.</p>
<p class="indent">If we pull in a module with <code>using</code> and already have some of its names defined in our program, Julia will print a warning. The next section describes other ways to handle this problem.</p>
<p class="indent">We use the <code>import</code> statement when we have names that happen to be the same within more than one module or that are identical in an imported module and in our program. The use of module namespaces will remove the ambiguity. For example, our program has our own <code>randexp()</code> function, which is different from the one supplied by the <code>Random</code> module. It returns <code>17</code>, which I chose at random when I wrote the function, hence the name.</p>
<p class="indent">After the definition of <code>randexp()</code> <span class="ent">➊</span>, we define two vectors, <code>a</code> and <code>b</code>. We calculate their dot product using the <code>dot()</code> function, which is exported by <code>LinearAlgebra</code>, and pipe its output to <code>println()</code> so we can see it.</p>
<p class="indent">The next line calls the <code>randexp()</code> function from <code>Random</code> and prints the result. This function returns a number randomly selected from the exponential distribution.</p>
<p class="indent">Finally we call <code>randexp()</code> <span class="ent">➍</span> from the program’s global namespace and print the result: <code>17</code>.</p>
<p class="indent">Here is the output from one run of the program:</p>
<pre class="calibre13">1
0.11747991328811039
17</pre>
<p class="indent">When you run it, the second number will be different because it’s randomly generated (see “Random Numbers in Julia” on <a href="ch10.xhtml#ch10lev2" class="calibre10">page 307</a>).<span epub:type="pagebreak" id="page_65"/></p>
<h4 class="h3" id="ch03lev1sec3"><strong class="calibre2"><em class="calibre4">Selective Importing and Renaming</em></strong></h4>
<p class="noindent">So far we’ve seen two Julia statements, each of which allows a program to refer to objects defined elsewhere. Both statements give access to everything in the target module, but differ in how we refer to the module’s objects.</p>
<p class="indent">We can supplement either command with specifications that provide more control.</p>
<p class="indent">The <code>as</code> keyword lets us pick a name to use for the module within our program. If we change the second line in <a href="ch03.xhtml#ch3lis1" class="calibre10">Listing 3-1</a> to <code>import Random as Rnd</code>, we need to change the line that uses it to <code>Rnd.randexp() |&gt; println</code>.</p>
<p class="indent">We can append a colon to the module name to limit the import to only specified objects. Optionally, we can use the <code>as</code> keyword to rename those objects to names of our choosing. These methods can serve to avoid conflicts with existing names. Here is <a href="ch03.xhtml#ch3lis1" class="calibre10">Listing 3-1</a> with some modifications:</p>
<pre class="calibre13">   using LinearAlgebra
<span class="ent">➊</span> import Random: randexp as rrexp

   function randexp()
       17
   end

   a = [1 1]
   b = [0 1]

   dot(a, b) |&gt; println

<span class="ent">➋</span> rrexp() |&gt; println

   randexp() |&gt; println</pre>
<p class="indent">This program has the same results as the previous version, but the <code>import</code> statement <span class="ent">➊</span> imports only the <code>randexp()</code> function from <code>Random</code> and renames it as <code>rrexp()</code>. When we call it <span class="ent">➋</span>, we have to use its alias because its original name, <code>randexp()</code>, is unknown in its current environment.</p>
<h4 class="h3" id="ch03lev1sec4"><strong class="calibre2"><em class="calibre4">Creating Modules</em></strong></h4>
<p class="noindent">In Julia, there is no relationship between modules and files or between filenames and module names. A file can contain any number of modules, and a module may be split among many files.</p>
<p class="indent">We define a module in a program file using the <code>module</code> keyword. This begins a structure that resembles a block and is terminated with the <code>end</code> keyword, but is different from the blocks described in <a href="ch02.xhtml" class="calibre10">Chapter 2</a>. Because it’s common for entire files to comprise the contents of a module, the conventional style does not indent module bodies. Such a practice would lead to uselessly indenting most of the file. Another distinction concerns scope: variables defined within a module, but outside any of the blocks that define <span epub:type="pagebreak" id="page_66"/>local scopes, are global to the module. Each module has its own global scope, so a file with more than one module has more than one such scope.</p>
<p class="indent">As an example, let’s begin with a simple case: <a href="ch03.xhtml#ch3lis2" class="calibre10">Listing 3-2</a> is a small program containing two modules, with everything contained within a single file.</p>
<pre class="calibre13">   module M1
   export plusone
   plusone(x) = x + 1
   end

   module M2
   export minusone
   minusone(x) = x - 1
   end

<span class="ent">➊</span> using .M1, .M2

   println(plusone(99))
   println(minusone(101))</pre>
<p class="list" id="ch3lis2"><em class="calibre11">Listing 3-2: A program containing two modules</em></p>
<p class="indent">This program defines two modules, <code>M1</code> and <code>M2</code>. Each module defines one function, which it lists in an <code>export</code> statement. Usually <code>export</code> lines go near the top of the module, but they can appear anywhere. Running the program prints <code>100</code> twice.</p>
<p class="indent">The <code>using</code> statement <span class="ent">➊</span> brings the exported names of the two modules into the global namespace of the file. The dots in front of the module names mean that we are referring to modules defined <em class="calibre11">within the current module</em>. But it doesn’t appear as if we’re in a “current module”: the statement is simply at the top level of the file.</p>
<p class="indent">We’re always in a module in Julia. The top-level module is automatically called <code>Main</code> if we don’t name it ourselves, so <code>M1</code> and <code>M2</code> are modules within the <code>Main</code> module.</p>
<p class="indent">If we had used <code>import</code> rather than <code>using</code>, we would have been obliged to mention the module namespaces when invoking their functions. Although we need to use the dot when importing to indicate <em class="calibre11">where</em> the module is, its names are still given in the <code>module</code> statements. For example, the <code>plusone()</code> function is <code>M1.plusone()</code>.</p>
<p class="indent">Dots in module import statements have a significance similar to their use in directory names in Unix-like operating systems. Single dots refer to the current “directory,” or module, and a double dot goes up one level to the enclosing module.</p>
<p class="indent"><a href="ch03.xhtml#ch3lis3" class="calibre10">Listing 3-3</a> shows an example.<span epub:type="pagebreak" id="page_67"/></p>
<pre class="calibre13">   module M1
   export plusone
   plusone(x) = x + 1

<span class="ent">➊</span> module M2
   export minusone
   minusone(x) = x - 1
<span class="ent">➋</span> using ..M1
   println(plusone(200))
   end

   end

<span class="ent">➌</span> using .M1, .M1.M2

   println(plusone(99))
   println(minusone(101))</pre>
<p class="list" id="ch3lis3"><em class="calibre11">Listing 3-3: Relative module imports</em></p>
<p class="indent">We’ve moved the definition of module <code>M2</code> inside <code>M1</code> <span class="ent">➊</span>. Within <code>M2</code> we import <code>M1</code> <span class="ent">➋</span>, which is now a <em class="calibre11">sibling module</em>: the double dot tells Julia to go up one level before looking for <code>M1</code>. After this <code>using</code> statement, <code>plusone()</code> is available within <code>M2</code>, so we can call it directly within the <code>println()</code> statement.</p>
<p class="indent">Back in the top level, which is the <code>Main</code> module, we again want to import every exported name from <code>M1</code> and <code>M2</code> into the global namespace, but now we need to specify that <code>M2</code> is within <code>M1</code> <span class="ent">➌</span>.</p>
<p class="indent">This program prints <code>201</code> followed by the same output as the previous example in <a href="ch03.xhtml#ch3lis2" class="calibre10">Listing 3-2</a>.</p>
<p class="indent">If we simply want to insert the contents of a file into the current file, we use the <code>include()</code> statement with a string argument giving the file’s pathname. This is equivalent to pasting the file’s contents at the location of the <code>include()</code> statement. It doesn’t use any of the module namespacing machinery, pulling objects in the included file into the module’s namespace. Using file inclusion, we can split large modules among different files, helping to keep our code organized.</p>
<h4 class="h3" id="ch03lev1sec5"><strong class="calibre2"><em class="calibre4">Documenting Functions with Docstrings</em></strong></h4>
<p class="noindent">The previous chapter described how to use the REPL’s help system to get information about functions. We can document our own functions so that the help system can provide nicely formatted information about them.</p>
<p class="indent">Place a string literal immediately before the beginning of any function definition to document it, creating what’s called a <em class="calibre11">docstring</em>. The help system, as well as any other Julia documentation system, will associate this string with the function, and format and display it when the user asks for help. Here is a somewhat silly example, where I added some help text to <a href="ch03.xhtml#ch3lis3" class="calibre10">Listing 3-3</a> to document the <code>plusone()</code> function:<span epub:type="pagebreak" id="page_68"/></p>
<pre class="calibre13">module M1
export plusone
"""
    plusone(x)

Add _one_ to the **number** `x`.

# Example

For example, `plusone(1)` returns 2.
"""
plusone(x) = x + 1

module M2
<span class="codeitalic">--snip--</span></pre>
<p class="indent">In this example I use the triple-quoted string syntax explained on <a href="ch02.xhtml#page_45" class="calibre10">page 45</a> to conveniently embed newlines and other characters without needing to escape them. Most help strings are written this way.</p>
<div class="box">
<p class="boxtitle-d"><strong class="calibre2">MARKDOWN IN DOCSTRINGS</strong></p>
<p class="noindent">The documentation system understands a version of Markdown syntax and will format the output appropriately. Markdown is a simplified system of text markup where you can specify italics, boldface, and code using underscore, double underscore, and backtick delimiters, with asterisks accepted as alternatives to underscores. A blank line starts a new paragraph, and indenting text by four spaces sets it as code. Lines beginning with hash marks are not comments, as in Julia code, but become headings: <code># Heading</code>, <code>##</code> <code>Subheading</code>, and so on.</p>
</div>
<p class="indent">The example demonstrates some of the documentation conventions the Julia community uses. Begin the help text with the function signature, followed by an imperative statement of what the function does. After that can come more explanation and examples.</p>
<p class="indent"><a href="ch03.xhtml#ch3fig1" class="calibre10">Figure 3-1</a> is a screenshot of a REPL session where I included the <em class="calibre11">modutst.jl</em> file.</p>
<div class="image1"><img alt="Image" id="ch3fig1" src="../images/ch03fig01.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 3-1: Using the documentation system</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_69"/>In the REPL, the <code>println()</code> statements are run and produce the output shown previously. I pressed <code>?</code> to enter help mode and typed the name of the function. After showing the results of a fuzzy search on the name, the REPL renders the docstring of the most likely choice. The terminal REPL renders code using a contrasting color and italics with an underline. Other environments may use different typography.</p>
<p class="indent">For more details about Markdown formatting, see “Further Reading” on <a href="ch03.xhtml#fur3" class="calibre10">page 81</a>.</p>
<p class="indent">We’ve learned how to reference modules defined in the current file using dots and extend the current file using <code>include()</code>. Before that, we were loading external modules with the same <code>using</code> and <code>import</code> statements, but with no dots in front of the module names. Somehow in those cases, Julia knew where to find the files containing the module definitions, and that is the subject of the next section.</p>
<h3 class="h2" id="ch03lev2"><strong class="calibre2">The Package System</strong></h3>
<p class="noindent">The most convenient way to interact with Julia’s package system is with the REPL’s package mode. Press <code>]</code> to enter and <small class="calibre5">BACKSPACE</small> to exit this mode.</p>
<p class="indent">Enter the package mode and have another look at the prompt. It looks something like <code>(@v1.8) pkg&gt;</code>, where <code>v1.8</code> shows the currently installed Julia version. The part within the parentheses informs us of our current <em class="calibre11">environment</em>. We are always in some environment in the REPL. The environment is the project to which the package mode applies its commands.</p>
<p class="indent">When we start the REPL we’re in the default project. Everything we do in the package manager applies to that environment, unless we change it with the <code>activate</code> command.</p>
<p class="indent">Enter <span class="codestrong1">activate.</span> to change the environment to the current directory, or <span class="codestrong1">activate</span> <span class="codestrongitalic">path</span> to change it to a specified path. A simple <span class="codestrong1">activate</span> changes to the default environment for the version of Julia in use.</p>
<h4 class="h3" id="ch03lev1sec6"><strong class="calibre2"><em class="calibre4">How to Add and Remove Packages</em></strong></h4>
<p class="noindent">The most important package command is <code>add</code>. To use it, enter <span class="codestrong1">add</span> <span class="codestrongitalic">packageName</span> from within the REPL’s package mode.</p>
<p class="indent">The <code>add</code> command does two things: it downloads and precompiles the latest compatible version of the requested package, if it’s not already installed, and it records the package as a dependency of the current environment. The second step ensures that the set of package versions used in the project can always be reproduced, either by its author on a different computer or by a colleague.</p>
<p class="indent">We will have to <code>add</code> any packages that are not in the standard library. This includes the vast majority of packages in the Julia ecosystem, such as <code>Plots</code>, for making scientific graphics, or <code>BenchmarkTools</code>, for timing and profiling programs.</p>
<p class="indent">If any package previously installed with <code>add</code> is no longer needed, we can remove it with the <code>rm</code> <span class="codeitalic1">PackageName</span> command, also from within package mode.</p>
<p class="indent"><span epub:type="pagebreak" id="page_70"/>The <code>rm</code> package mode command deletes a package from the list of direct dependencies of your project, but it does not immediately erase any files from the disk. An automatic garbage collection process runs periodically, reclaiming disk space by purging packages that no other installed package depends on and that haven’t been used for over 30 days. To reclaim disk space right away, call the garbage collector manually. Detailed instructions are in the package system manual (see “Further Reading” on <a href="ch03.xhtml#fur3" class="calibre10">page 81</a>).</p>
<h4 class="h3" id="ch03lev1sec7"><strong class="calibre2"><em class="calibre4">The Load Path</em></strong></h4>
<p class="noindent">The current environment influences where <code>using</code> and <code>import</code> look for packages and defines the default location for package commands. When executing statements like <code>using Plots</code> or <code>import Random</code> that mention package names without dots, Julia looks for the packages in a series of places derived from a vector of strings named <code>LOAD_PATH</code>.</p>
<p class="indent">We can ask the REPL to show us the default initial value of <code>LOAD_PATH</code>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">LOAD_PATH</span>
3-element Vector{String}:
 "@"
 "@v#.#"
 "@stdlib"</pre>
<p class="indent">The contents of <code>LOAD_PATH</code> are clearly not filepaths. They’re a notation that the package manager translates into the appropriate paths for the system and installation. To see the results of the translation and the current values of the paths, we can call the <code>load_path()</code> function from <code>Base</code>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">Base.load_path()</span>
2-element Vector{String}:
 "/home/lee/.julia/environments/v1.8/Project.toml"
 "/home/lee/Downloads/julia/julia-1.8.1/share/julia/stdlib/v1.8"</pre>
<p class="indent">We’ve already mentioned that <code>Base</code> contains the functions we almost always need, but they’re not all exported. Ones that are used infrequently, such as <code>load_path()</code>, need to be accessed in the <code>Base</code> namespace.</p>
<p class="indent">My current load path contains two items. The first is a directory that Julia set up when I installed it. It corresponds to my default environment. When I execute a command like <code>add Plots</code> in the REPL, if I haven’t switched environments with the <code>activate</code> command, the package manager adds the current version of the <code>Plots</code> package as a <em class="calibre11">dependency</em> in the default <em class="calibre11">project</em>. It records the fact that this project depends on a particular version of <code>Plots</code> being available, and <code>using Plots</code> will import the functions from that version. This path is the translation of the second element in <code>LOAD_PATH</code>, <code>"@v#.#"</code>. The notation simply means “the default environment”; notice how its structure resembles the prompt in package mode.</p>
<p class="indent">The package manager records these direct dependencies, the ones specified with <code>add</code> commands, in the <em class="calibre11">Project.toml</em> file. This file contains lines such as:<span epub:type="pagebreak" id="page_71"/></p>
<pre class="calibre13">Plots = "91a5bcdd-55d7-5caf-9e0b-520d859cae80"</pre>
<p class="indent">This line shows that the particular version of the <code>Plots</code> package, made specific with a unique identifier called a <em class="calibre11">UUID</em>, is a dependency of the project that contains this file—in this case, the default project associated with my installation of v1.8 of Julia.</p>
<p class="indent">The second path returned by <code>Base.load_path()</code> comes from the last element of <code>LOAD_PATH</code>, which refers to the standard library. As mentioned previously, the standard library consists of modules that are part of the Julia installation, so they don’t need to be installed with <code>add</code>. I left my installation in the download folder where my web browser put it, so that’s where its standard library lives.</p>
<p class="indent">The <code>LOAD_PATH</code> has three elements, but we see only two in its current translation by <code>Base.load_path()</code>. The first element, which is simply <code>@</code>, refers to the <em class="calibre11">current environment</em>. Julia searches for packages in the order in which they appear in <code>LOAD_PATH</code>, so it searches the current environment first. To change the current environment, execute <span class="codestrong1">activate</span> <span class="codestrongitalic">path</span>.</p>
<p class="indent">The current environment has two purposes: it comes first in the load path, so imports of packages will load the versions, if any, that have been added as dependencies in the environment, and the package system <code>add</code> command inserts a dependency there.</p>
<p class="indent">An environment is really nothing more than a place in the filesystem with a <em class="calibre11">Project.toml</em> file and a <em class="calibre11">Manifest.toml</em> file. The latter is a list of the entire <em class="calibre11">dependency graph</em> of the environment: all the packages that need to be loaded to satisfy the dependencies of the ones explicitly <code>add</code>ed, with their UUIDs, the list of dependencies of each of those dependencies, and so on. If we use the <code>activate</code> command on a path where there is no existing environment and execute one or more <code>add</code> commands, Julia will create these two files there and fill them with the specified package information.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">If we can’t use the filenames</em> Project.toml <em class="calibre11">or</em> Manifest.toml <em class="calibre11">because they conflict with another tool, we can use</em> JuliaProject.toml <em class="calibre11">and</em> JuliaManifest.toml <em class="calibre11">instead. If Julia sees either of those files, it will use it and ignore the one without the</em> Julia <em class="calibre11">prefix.</em></p>
</div>
<p class="indent">Environments contain no Julia code, only a list of dependencies. They may document a set of consistent modules that work for a particular purpose. For example, after using Pluto, we’ll discover that Julia has created an environment alongside the normal default environment whose <em class="calibre11">Project.toml</em> and <em class="calibre11">Manifest.toml</em> files contain a list of the modules that Pluto needs to work properly.</p>
<h4 class="h3" id="ch03lev1sec8"><strong class="calibre2"><em class="calibre4">The Nature of a Package</em></strong></h4>
<p class="noindent">I’ve mentioned <em class="calibre11">package</em> many times, and have used the term more or less interchangeably with <em class="calibre11">module</em>, a tradition well established in the Julia documentation. Now let’s make the relationship between these concepts precise and explore how packages are related to environments.</p>
<p class="indent"><span epub:type="pagebreak" id="page_72"/>A package is a Julia module associated with a <em class="calibre11">Project.toml</em> file containing a few critical pieces of information. The file containing the module and the <em class="calibre11">Project.toml</em> file must be laid out in the filesystem as shown in <a href="ch03.xhtml#ch3fig2" class="calibre10">Figure 3-2</a>.</p>
<div class="image1"><img alt="Image" id="ch3fig2" src="../images/ch03fig02.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 3-2: The filesystem layout of a package</em></p>
<p class="indent">Alongside the <em class="calibre11">Project.toml</em> file is a <em class="calibre11">src</em> directory, inside which must be the Julia program file, named after the package. Inside this file is the definition of a module also named after the package, which in this case is <code>module</code>
<code>SomePackage</code>. The structure shown in <a href="ch03.xhtml#ch3fig2" class="calibre10">Figure 3-2</a> is usually placed inside a directory also named after the module, <em class="calibre11">SomePackage</em> in this case, but that is not strictly required.</p>
<p class="indent">For this arrangement to qualify as a package, the <em class="calibre11">Project.toml</em> file must provide the name of the package, its UUID, its authors, and its version number, in the format shown in <a href="ch03.xhtml#ch3lis4" class="calibre10">Listing 3-4</a>.</p>
<pre class="calibre13">name = "SomePackage"
uuid = "842ca1f4-56d0-4d49-a6c9-7b9c77404c7a"
authors = ["Ada Lovelace &lt;ada.l@example.com&gt;"]
version = "0.1.0"</pre>
<p class="list" id="ch3lis4"><em class="calibre11">Listing 3-4: A package’s</em> Project.toml <em class="calibre11">file</em></p>
<p class="indent">The <code>name</code> must match the name of the module defined in <em class="calibre11">src/Some Package.jl</em>. If we have these two files, one within a <em class="calibre11">src</em> directory, we have a package. We can think of a package as an environment with a module inside and with these four pieces of information in <em class="calibre11">Project.toml</em>. In practice, as soon as we add dependencies to our package with the <code>add</code> command executed within the package’s environment, we will also have a <em class="calibre11">Manifest.toml</em> file alongside the <em class="calibre11">Project.toml</em> file that contains the complete dependency graph.</p>
<p class="indent">We can do all of our Julia development within <em class="calibre11">.jl</em> files, possibly using <code>include()</code> to split the code among several files, and share our work by emailing those files to colleagues. Many Julia programmers do no more than this and don’t bother creating packages.</p>
<h4 class="h3" id="ch03lev1sec9"><strong class="calibre2"><em class="calibre4">The Benefits of Packages</em></strong></h4>
<p class="noindent">After the exploratory REPL phase of your program development is over, and it’s time to save your code in the filesystem so you can use it later, possibly as a resource in other programs, I would like to encourage you to take advantage of Julia’s package system.</p>
<p class="indent"><span epub:type="pagebreak" id="page_73"/>It’s sophisticated, easy to use, and will save you from dependency conflicts down the road. Most programs use modules from the standard library and other packages, and all are developed with a particular version of Julia itself. As all these components evolve, the possibility of conflict arises and, with time, becomes inevitable in large programs that use many external resources. The package system records the exact versions of all the resources your program uses, so you or anyone else can reproduce that environment in the future, and the program will always work.</p>
<p class="indent">In the absence of dependency management, a statement like <code>using Plots</code> in your program imports whatever version of <code>Plots</code> is used by the environment in which a future user, including yourself, happens to run it. You may have used a feature that is later removed from the package, or a future version may introduce a bug that breaks your program. Without package management, your program is loading unknown code because you’re not being specific about what you mean by <code>Plots</code>.</p>
<p class="indent">Packages often depend on other packages. A future user of your program, encountering a conflict with <code>Plots</code>, may try to resolve it by using a different version. But that version will depend on different versions of other packages, and some of those will have their own dependencies. Trying to sort out the dependency graph of packages manually to find a workable set quickly becomes a maddening task. It’s such a common headache in languages without good package management that there’s a name for it: <em class="calibre11">dependency hell</em>. Julia’s package system manages the dependency graph automatically. You can have various versions of Julia and of any number of packages installed on your machine at the same time with no issues. If you keep your programs in packages, you can upgrade the versions of modules that it imports without changing your actual code, and if the new versions create problems, you can downgrade as needed.</p>
<p class="indent">If you decide to share your programs through the official community channels, you must use packages. The official repository, from which you get resources when you use the <code>add</code> command, is based on packages and the Git version control system, which I’ll treat in “Julia and Git” on <a href="ch03.xhtml#ch03lev1sec11" class="calibre10">page 77</a>.</p>
<h4 class="h3" id="ch03lev1sec10"><strong class="calibre2"><em class="calibre4">How to Create Packages</em></strong></h4>
<p class="noindent">It’s easy to create packages. First, we navigate to the directory in the filesystem where we want the package to be and start the Julia REPL. We can use any directory, and we can always move it later.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">We don’t have to start a new REPL session just to change locations in the filesystem. To continue in an existing REPL session, we can move around the filesystem while staying in the REPL using two Julia function versions of the familiar Unix commands</em> <span class="codeitalic1">pwd</span> <em class="calibre11">and</em> <span class="codeitalic1">cd</span><em class="calibre11">. The REPL maintains a notion of the current directory, which is where we gave the</em> <span class="codeitalic1">julia</span> <em class="calibre11">command that started the REPL, and it stays there unless we change it. The</em> <span class="codeitalic1">pwd()</span> <em class="calibre11">function in the REPL returns a string with the full pathname of the current directory. To change it, enter</em> <span class="codestrongitalic">cd(</span><span class="codestrong1">new_directory</span><span class="codestrongitalic">)</span><em class="calibre11">, substituting the name of the desired destination. (The name is a string, as returned by</em> <span class="codeitalic1">pwd()</span><em class="calibre11">, so must be enclosed within quotes.)</em></p>
</div>
<p class="indent"><span epub:type="pagebreak" id="page_74"/>Within the REPL, press <code>]</code> to enter package mode, and execute <span class="codestrong1">generate</span> <span class="codestrong1">Floof</span>. That’s all we need to do to create a new package named <code>Floof</code>.</p>
<p class="indent">Back in the system shell, or using the REPL’s shell mode, we’ll find the new directory named <em class="calibre11">Floof</em>, and within it, the minimal package files shown in <a href="ch03.xhtml#ch3fig2" class="calibre10">Figure 3-2</a>. Floof’s <em class="calibre11">Project.toml</em> file will contain lines similar to <a href="ch03.xhtml#ch3lis4" class="calibre10">Listing 3-4</a>, but with the name <em class="calibre11">Floof</em> and a new, unique UUID. The <code>authors</code> field is populated from our Git configuration, so it’ll be empty if we haven’t installed Git (see “Julia and Git” on <a href="ch03.xhtml#ch03lev1sec11" class="calibre10">page 77</a>). The <code>generate</code> statement gives our new package a version number of <code>0.1.0</code>, which we can change.</p>
<p class="indent">Descending into the <em class="calibre11">src</em> directory, the <em class="calibre11">Floof.jl</em> file has the following contents:</p>
<pre class="calibre13">module Floof

greet() = print("Hello World!")

end # module</pre>
<p class="indent">This defines a tiny module, called <code>Floof</code>, with one function, <code>greet()</code>, that greets the world. Julia sets up a minimal package with everything in place so we can begin development of our module. We’ll make one change to this file for now: add the statement <code>export greet</code> after the first line.</p>
<p class="indent">Let’s experiment with this new mini-package. First, we’ll exercise it without using the package system:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">include("/tmp/Floof/src/Floof.jl")</span>
<span class="ent">➊</span> Main.Floof

   julia&gt; <span class="codestrong">Floof.greet()</span>
   Hello World!
   julia&gt; <span class="codestrong">using Floof</span>
<span class="ent">➋</span> ERROR: ArgumentError: Package Floof not found in current path

   julia&gt; <span class="codestrong">using .Floof</span>

<span class="ent">➌</span> julia&gt; <span class="codestrong">greet()</span>
   Hello World!</pre>
<p class="indent">We put the <code>Floof</code> package in the <em class="calibre11">/tmp</em> directory. The first action in the REPL is to <code>include</code> the program file directly. This is equivalent to pasting it directly into the REPL. The feedback <span class="ent">➊</span> from the <code>include()</code> statement confirms that <code>Floof</code> is loaded into <code>Main</code>, which is always the name for the top-level module.</p>
<p class="indent">Now we can use anything in the <code>Floof</code> module by mentioning its namespace. It has only one ingredient, the <code>greet()</code> function, which does what’s expected when we call it.</p>
<p class="indent">We would prefer to call this function without having to type the module name, so we need to import its name into the current namespace. We tried <span epub:type="pagebreak" id="page_75"/>to do this with the <code>using</code> statement, but Julia won’t let us <span class="ent">➋</span>. After remembering that we need to prefix local modules with a dot, everything works as expected <span class="ent">➌</span>. (I’ve omitted the stacktrace from the error message to save space, as I will do routinely.)</p>
<p class="indent">Importing a name, whether with <code>using</code> or <code>import</code>, without a dot prefix tells Julia to import a package rather than a local module. This wakes up the package system, which consults the <code>LOAD_PATH</code> to search for the package. Although <code>Floof</code> is indeed a package, it’s not on the <code>LOAD_PATH</code>, which by default includes the activated environment, the default environment, and the standard library, in that order. Since we haven’t activated an environment, and the <code>Floof</code> package is in neither the standard library nor the default environment, Julia can’t find it.</p>
<p class="indent">If we’re determined to import <code>greet()</code> into the global namespace, we can activate the environment that contains the <code>Floof</code> module. But first, we should quit and restart the REPL. Otherwise, this new attempt to import will generate an error complaining about a conflict with an existing name. After starting a fresh REPL, we can do this:</p>
<pre class="calibre13">(@v1.8) pkg&gt; <span class="codestrong">activate /tmp/Floof</span>
  Activating environment at `/tmp/Floof/Project.toml`

julia&gt; <span class="codestrong">using Floof</span>

julia&gt; <span class="codestrong">greet()</span>
Hello World!
(Floof) pkg&gt; <span class="codestrong">add Random</span></pre>
<p class="indent">After activating the <code>Floof</code> environment using its pathname, we exit package mode. Back in the REPL’s normal mode, after importing <code>Floof</code>’s names into the global namespace with <code>using</code>, a simple <code>greet()</code> invokes the function. This works only because we edited <em class="calibre11">Floof.jl</em> to <code>export greet</code>. Then we re-enter package mode—observe the prompt, which now indicates the <code>Floof</code> environment. The <code>add Random</code> command adds this package, which contains utilities related to random number generation, to the dependency list for <code>Floof</code>.</p>
<p class="indent">We can add paths manually to <code>LOAD_PATH</code>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">push!(LOAD_PATH, "/tmp/Floof/")</span>
4-element Vector{String}:
 "@"
 "@v#.#"
 "@stdlib"
 "/tmp/Floof/"

julia&gt; <span class="codestrong">using Floof</span>

julia&gt; <span class="codestrong">greet()</span>
Hello World!</pre>
<p class="indent"><span epub:type="pagebreak" id="page_76"/>We do this, again, in a fresh REPL. The package system found <code>Floof</code> in the last entry in <code><em class="calibre11">LOAD_PATH</em></code>; it will find it regardless of the current environment.</p>
<p class="indent"><code>Floof</code>’s <em class="calibre11">Project.toml</em> file now contains two additional lines. Here are its contents after executing <code>add Random</code>:</p>
<pre class="calibre13">name = "Floof"
uuid = "fdb9266c-3340-4b10-958f-2cb27e4e2988"
authors = ["Lee &lt;lee@example.com&gt;"]
version = "0.1.0"

[deps]
Random = "9a3f8284-a2c9-5f02-9a11-845980a1fd5c"</pre>
<p class="indent">The lines after the <code>[deps]</code> label will record every dependency that we manually add with an <code>add</code> statement.</p>
<p class="indent">A new <em class="calibre11">Manifest.toml</em> file has appeared alongside the <em class="calibre11">Project.toml</em> file with these contents:</p>
<pre class="calibre13"># This file is machine-generated - editing it directly is not advised

[[Random]]
deps = ["Serialization"]
uuid = "9a3f8284-a2c9-5f02-9a11-845980a1fd5c"

[[Serialization]]
uuid = "9e88b42a-f829-5b0c-bbe9-9e923198166b"</pre>
<p class="indent">Manifest files are for recording the dependency graph of a package or environment. For each dependency added manually, the system looks up its dependencies, and the dependencies of all of those dependencies, and so on, until it finds every dependency. Each of these dependencies is another package; all of them together, with all of their dependency relationships, is the dependency graph. As you can imagine, Manifest files can get rather large, but this one is not because <code>Random</code> apparently has only one dependency, a package called <code>Serialization</code>, and <code>Serialization</code> has no dependencies of its own.</p>
<p class="indent">Now that we have our very own package, we should be able to add it as a dependency to other packages and environments, just as we did with other packages like <code>Random</code> and <code>Plots</code>:</p>
<pre class="calibre13">(Floof) pkg&gt; <span class="codestrong">activate</span>
  Activating environment at `~/.julia/environments/v1.8/Project.toml`

(@v1.8) pkg&gt; <span class="codestrong">add /tmp/Floof</span>
ERROR: Did not find a git repository at `/tmp/Floof`</pre>
<p class="indent">First we use the <code>activate</code> statement with no argument to go back to the default environment. We try to add <code>Floof</code> to that environment, but the <span epub:type="pagebreak" id="page_77"/>package manager has a complaint about not finding something called a <em class="calibre11">git repository</em>.</p>
<h4 class="h3" id="ch03lev1sec11"><strong class="calibre2"><em class="calibre4">Julia and Git</em></strong></h4>
<p class="noindent">Git is a <em class="calibre11">version control system</em>: a program that helps you keep track of your work as it changes over time. Git, in addition, focuses on collaboration, although it’s immensely useful to the solo creator as well.</p>
<p class="indent">Git is independent of Julia, but since its creation in 2005 by Linus Torvalds, the creator of Linux, its superiority over all other version control systems has led to a near monopoly in the free software community. Julia is part of this community, and Git is an intimate component of the development of the language and its packages.</p>
<p class="indent">If you don’t already have Git installed and would prefer to continue your study of Julia without pausing to install Git and learning how to use it, skip this section for now. You can always return later. See “Further Reading” on <a href="ch03.xhtml#fur3" class="calibre10">page 81</a> for a link to an excellent learning resource. There are also many articles and several books about Git.</p>
<p class="indent">I recommend installing Git and using it in your projects before your personal library of code becomes substantial. The small investment in time and effort to become familiar with a few basic operations has a huge payback. You’ll be able to travel back in time to past states of your programs, keep a log of changes, create alternative versions of your programs where you try out ideas, and merge the ideas into the main line of development when they’re ready.</p>
<p class="indent">If you’re already using one of the older version control systems, you can continue to do so. However, if you reach the stage where you would like to contribute your Julia programs to the community, you will have to use Git. As we’re about to see, Git is also required for adding your own packages as dependencies in your own projects and environments on your personal machine, which is something you may want to do even if you don’t share your programs.</p>
<p class="indent">As shown in “How to Create Packages” on <a href="ch03.xhtml#ch03lev1sec10" class="calibre10">page 73</a>, Julia complained when we tried to <code>add</code> my <code>Floof</code> package. The package system won’t let us add a package until we put it in a Git repository. Dependency management, which is the reason for the package system, tracks not simply packages, but versions of packages. Julia’s package system works with Git to track these versions. The rest of this section assumes Git is installed.</p>
<p class="indent">To allow the package system to deal with <code>Floof</code>, we have to put it in a Git repository and make an initial commit. In the <em class="calibre11">/tmp/Floof</em> directory, we execute <span class="codestrong1">git init</span> in the system shell to create the repository, then <span class="codestrong1">git add.</span> and <span class="codestrong1">git commit -m "Begin repo"</span> to begin tracking the contents.</p>
<p class="indent">Back in the Julia REPL, we try again:<span epub:type="pagebreak" id="page_78"/></p>
<pre class="calibre13">(@v1.8) pkg&gt; <span class="codestrong">add /tmp/Floof</span>
    Updating git-repo `/tmp/Floof`
   Resolving package versions...
    Updating `~/.julia/environments/v1.8/Project.toml`
  [fdb9266c] + Floof v0.1.0 `/tmp/Floof#master`
    Updating `~/.julia/environments/v1.8/Manifest.toml`
  [fdb9266c] + Floof v0.1.0 `/tmp/Floof#master`

(@v1.8) pkg&gt; <span class="codestrong">status</span>
      Status `~/.julia/environments/v1.8/Project.toml`
  [336ed68f] CSV v0.8.4
  [31c24e10] Distributions v0.24.15
  [fdb9266c] Floof v0.1.0 `/tmp/Floof#master`
  [23fbe1c1] Latexify v0.14.12
  [91a5bcdd] Plots v1.10.6
  [c3e4b0f8] Pluto v0.15.1</pre>
<p class="indent">It works this time: the package manager responds that it’s added <code>Floof</code> to the <em class="calibre11">Project.toml</em> and <em class="calibre11">Manifest.toml</em> files. The string in square brackets is the initial part of the UUID that the package manager has assigned to this version of <code>Floof</code>. The <code>#master</code> string refers to the branch name in Git.</p>
<p class="indent">The <code>status</code> package command returns a list of all the dependencies added to the current environment (not the entire dependency graph), and we see that <code>Floof</code> is among them.</p>
<p class="indent">If we want to remove a dependency—say, <code>Floof</code>—we enter <span class="codestrong1">rm Floof</span> in package mode: note that when removing packages, we use just the package name, not the whole path on the filesystem. This does nothing to our files; it simply removes <code>Floof</code> from the <em class="calibre11">Project.toml</em> file. However, it may not remove it from <em class="calibre11">Manifest.toml</em> because it may be listed there as a dependency of some other package.</p>
<p class="indent">If you’ve made your program into a Julia package and are tracking it with Git, you’ll be prepared to request that it be included in the official repository if the day comes when you feel it will be of use to a wider audience. If you complete this step, any Julia user anywhere in the world can simply tell their package REPL to <code>add</code> <code><em class="calibre11">YourPackage</em></code>, and they’ll be able to use and build on your work. Sharing and collaboration are embedded in Julia’s DNA. <a href="ch09.xhtml" class="calibre10">Chapters 9</a> and <a href="ch12.xhtml" class="calibre10">12</a> demonstrate several interesting examples of how packages can be combined to create new capabilities.</p>
<h4 class="h3" id="ch03lev1sec12"><strong class="calibre2"><em class="calibre4">The Relationship Between Package Versions and Git Commits</em></strong></h4>
<p class="noindent">We’ve seen how to request <code>status</code> at the package prompt to see a list of dependencies and abbreviations of their UUIDs, and how to see the complete UUID in the <em class="calibre11">Manifest.toml</em> file. We may be aware that Git identifies commits with a unique hash, but if we examine the hash of our project with <code>git log</code>, we won’t see anything that looks like Julia’s UUID.</p>
<p class="indent">Here is the relevant section of the default environment’s <em class="calibre11">Manifest.toml</em>, which is in <em class="calibre11">.julia/environments/v1.8/Manifest.toml</em> within the user’s home directory:<span epub:type="pagebreak" id="page_79"/></p>
<pre class="calibre13">[[Floof]]
deps = ["Random"]
git-tree-sha1 = "478b184e365f8d114ab757e18c6ab060fc590920"
repo-rev = "master"
repo-url = "/tmp/Floof"
uuid = "fdb9266c-3340-4b10-958f-2cb27e4e2988"
version = "0.1.0"</pre>
<p class="indent"><code>Random</code> is listed as a dependency because we had <code>add</code>ed it to the project earlier. In the last two lines, we see the full UUID and the initial version assigned by the package system. Before that, we have the path and the branch name from Git. Above that, we see something called the <code>git-tree-sha1</code>, which is a Git hash, but it’s not the commit hash that we see by default when we enter <span class="codestrong1">git log</span>. Within <code>Floof</code>’s directory, if we enter this command with an option, we can see more:</p>
<pre class="calibre13">bash&gt; <span class="codestrong">git log --pretty=raw</span>

commit 460ef22bb5c86863d07493e36be791977acd62e7
tree 478b184e365f8d114ab757e18c6ab060fc590920
author Lee &lt;lee@example.com&gt; 1630788711 -0600
committer Lee &lt;lee@example.com&gt; 1630788711 -0600

    make a repo</pre>
<p class="indent">The hash recorded in <em class="calibre11">Manifest.toml</em> is the <em class="calibre11">tree hash</em>. Most Git users are unaware of this hash because it’s rarely needed for anything. The tree hash encodes the actual contents of all the tracked files in the commit. Julia’s package manager uses this rather than the commit hash because it’s more reliable. Git provides powerful commands, such as <code>rebase</code>, that let users rewrite the commit history. If a conflict arises and something breaks, ideally we would like to identify the actual file contents of the programs involved. In practice, to identify a commit from the information recorded in <em class="calibre11">Manifest.toml</em>, we need to ask Git for the raw commit log and search for the tree hash.</p>
<h4 class="h3" id="ch03lev1sec13"><strong class="calibre2"><em class="calibre4">Version Updating and Pinning</em></strong></h4>
<p class="noindent">Another crucial package system command is <code>update</code> <code><em class="calibre11">PackageName</em></code>. Execute this operation to get the latest version of <code><em class="calibre11">PackageName</em></code> installed in the environment. Julia will check the registry for a new version, and download and precompile it if there is one. If <code><em class="calibre11">PackageName</em></code> has any dependencies, Julia will check their versions against the ones already installed, and download and precompile anything that’s changed. It will continue through the entire dependency graph, leaving us with a consistent environment, with no further action on our part.</p>
<p class="indent">If <code><em class="calibre11">PackageName</em></code> is our own project that we’re developing locally, the <code>update</code> command will cause the package manager to check its Git repository. If the tree hash at the <code>HEAD</code> of the tracked branch, as recorded in Git’s log, has changed, Julia will install the new version into the environment and precompile it. The <em class="calibre11">Manifest.toml</em> file will contain the new tree hash. If we’ve <span epub:type="pagebreak" id="page_80"/>edited the source file but not yet made a new Git commit, the package manager won’t do anything. Even if we change the version number recorded in <code><em class="calibre11">PackageName</em></code>’s <em class="calibre11">Project.toml</em> file, that will not cause Julia to take any action. The package manager cares only about the tree hash. This means, for example, if we soft-reset to an earlier commit, then <code>update</code> in Julia, the package manager will revert to the version that our <code>HEAD</code> now points to, pulling the files from the Git repository and <em class="calibre11">not</em> from our working tree.</p>
<p class="indent">It’s possible for an <code>update</code> to lead to a conflict, where the current versions of two packages cannot work together. Use the <code>pin</code> command in the package manager to force it to hold particular packages at certain versions. Sometimes that’s the only way around a conflict until the bugs are fixed.</p>
<p class="indent">The three versions of <code>pin</code> are <code>pin</code> <code><em class="calibre11">PackageName</em></code>, which holds <code><em class="calibre11">PackageName</em></code> at its current version; <code>pin</code> <code><em class="calibre11">PackageName</em>@2.4.2</code>, which, in this example, holds <code><em class="calibre11">PackageName</em></code> at version 2.4.2; and <code>pin</code> <code><em class="calibre11">PackageName=UUID</em></code>, which holds the package using its UUID rather than the version number to identify the version.</p>
<h4 class="h3" id="ch03lev1sec14"><strong class="calibre2"><em class="calibre4">How to Find Public Packages</em></strong></h4>
<p class="noindent">How can we discover if there is a Julia package that might help us write our program? The most productive approach is probably a general web search for projects or problems similar to ours, using Julia—this will quickly surface the most popular relevant packages. Of course, talking to people working in the same area is invaluable, if such a community is available. Asking on the Julia Discourse forum will almost certainly yield helpful replies, unless our project is quite niche or esoteric.</p>
<p class="indent">Since practically all development of public Julia packages takes place on GitHub, this is the place to search directly for solutions, especially if the previously mentioned approaches did not lead to anything appropriate, or if specific criteria are important to our project, such as recency of development.</p>
<p class="indent">There are several sites that seem to offer a way to search through packages, but provide nothing beyond what GitHub offers directly, aside from incorrect and outdated information and an even worse interface. The best strategy for searching on GitHub is to use a language qualifier. For example, in the project search box we would enter <code>phylogenetics language:Julia</code> to look for projects that mention phylogenetics in their title or keywords, and that are written in Julia (and possibly other languages). This is effective because Julia packages are written in Julia, and it’s necessary because Julia packages often do not have a “Julia" keyword, so using that as a bare search term misses many projects.</p>
<p class="indent">Crucially, we can then sort the resulting list based on several criteria, including recency of last update and the number of “stars” the project has. The latter, despite its unpleasant associations with internet popularity and gamification, is actually a useful proxy to uncover packages that are widely used and therefore more likely to be valuable and to have a community around them.</p>
<p class="indent">The individual project pages in GitHub will contain a rendering of their README files, which range from a few cryptic phrases to a full introduction <span epub:type="pagebreak" id="page_81"/>and tutorial with screenshots and animations. The README sometimes contains a link to further documentation; if it doesn’t, one can click one of the project’s documentation badges, but there is no guarantee that will lead to any actual documentation. Lack of documentation is not a good sign, but there may be linguistic or other reasons for the lapse. We can always look at the source code, all of which will be a click away on GitHub. Julia code is unusually easy to read, and obviously is the final source of truth about the operation of any package.</p>
<p class="indent">After we discover a package that we want to try, it’s time to return to the REPL and <code>add</code> it to our project. We can add packages in the official registry, listed in the GitHub project <code>JuliaRegistries/General</code>, simply by using its name. In the probably unusual circumstance where we want to add a public project that is not in the general registry, we can add it using its URL. In package mode, we enter</p>
<pre class="calibre13"><span class="codestrong">add https://github.com/developer/projectname</span></pre>
<p class="noindent">for example, to add the project <code>projectname</code> by developer <code>developer</code>. This will only work if we are pointing at a proper Julia project with a <em class="calibre11">Project.toml</em> or <em class="calibre11">JuliaProject.toml</em> file. After adding the project, it will appear in our <em class="calibre11">Manifest.toml</em> file with the extra field <code>repo-url</code>.</p>
<h3 class="h2" id="ch03lev3"><strong class="calibre2">Conclusion</strong></h3>
<p class="noindent">This chapter describes some essential ingredients for using Julia effectively and making it possible for others to incorporate our programs into their work. Programming is rarely done in isolation. There is no need to reinvent the wheel if a solution to a part of your problem is as close as an <code>import</code> away. In later chapters, we’ll expand on these ideas and look at even more powerful ways to combine the resources of several packages. But first, in the next chapter we’ll explore an essential package that nearly all scientific Julia programmers use as we delve into the plotting system.</p>
<div class="box">
<p class="boxtitle-d" id="fur3"><strong class="calibre2">FURTHER READING</strong></p>
<ul class="calibre12">
<li class="noindent1">More details on what you can do with docstrings, mostly of interest to package developers, are available at <a href="https://docs.julialang.org/en/v1/manual/documentation/" class="calibre10"><em class="calibre11">https://docs.julialang.org/en/v1/manual/documentation/</em></a>.</li>
<li class="noindent1">When making those docstrings, you may need to know more about Markdown syntax:
 <a href="https://www.markdownguide.org/basic-syntax" class="calibre10"><em class="calibre11">https://www.markdownguide.org/basic-syntax</em></a>.</li>
<li class="noindent1">The <em class="calibre11">.toml</em> file extension stands for “Tom’s Obvious, Minimal Language” designed by Tom Preston-Werner: <a href="https://github.com/toml-lang/toml" class="calibre10"><em class="calibre11">https://github.com/toml-lang/toml</em></a>.</li>
<li class="noindent1">A good resource for getting started with Git is <a href="https://git-scm.com" class="calibre10"><em class="calibre11">https://git-scm.com</em></a>.</li>
<li class="noindent1"><span epub:type="pagebreak" id="page_82"/>For detailed information about the package system, including instructions on how to submit your creations to the official repository, or <em class="calibre11">registry</em>, go to <a href="https://pkgdocs.julialang.org/" class="calibre10"><em class="calibre11">https://pkgdocs.julialang.org/</em></a>.</li>
<li class="noindent1">A package system summary, and my first adventure in contributing to a public package, are available at <a href="https://lwn.net/Articles/871490/" class="calibre10"><em class="calibre11">https://lwn.net/Articles/871490/</em></a>.</li>
<li class="noindent1">For workflow tips, visit <a href="https://docs.julialang.org/en/v1/manual/workflow-tips/" class="calibre10"><em class="calibre11">https://docs.julialang.org/en/v1/manual/workflow-tips/</em></a>.</li>
</ul>
</div>
</body></html>