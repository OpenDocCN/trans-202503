- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ANTI-DEBUGGING</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Anti-debugging* is a series of anti-reversing techniques used by malware (and
    even some legitimate programs) to hamper or prevent debugging. For example, the
    malware might try to interfere with the debugger process if it detects that it’s
    attached to a debugger, or it might try to prevent debugging altogether by using
    so-called anti-attach mechanisms or crashing the debugger program. In this chapter,
    we’ll explore some of these techniques in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Using Windows API Functions to Access
    the PEB</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you learned in [Chapter 1](chapter1.xhtml), the Process Environment Block
    (PEB) is a structure that contains pointers to information in memory about the
    currently running process. The PEB includes several pointers that are relevant
    to anti-debugging, as listed in [Table 10-1](chapter10.xhtml#tab10-1).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 10-1:</samp> <samp class="SANS_Futura_Std_Book_11">PEB
    Members Relating to Anti-debugging</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">PEB offset</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">PEB
    member</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x002</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">BeingDebugged</samp>
    | <samp class="SANS_Futura_Std_Book_11">Indicates whether the program is currently
    being debugged</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x018</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessHeap</samp>
    | <samp class="SANS_Futura_Std_Book_11">Contains pointers to the heap’s</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp> <samp class="SANS_Futura_Std_Book_11">and</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceFlags</samp> <samp class="SANS_Futura_Std_Book_11">members</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0x068</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">NtGlobalFlag</samp>
    | <samp class="SANS_Futura_Std_Book_11">Contains information related to the creation
    of memory heaps</samp> |'
  prefs: []
  type: TYPE_TB
- en: Windows exposes a wealth of data about its internal workings to programs via
    its APIs. Some Windows API functions have the sole purpose of telling the calling
    program whether a debugger is attached, and malware can easily exploit this fact
    by having them query the PEB to determine whether it’s being debugged. Not only
    that, but malware can also abuse some API functions to trick Windows into exposing
    an attached debugger. In this section, we’ll look at some common ways in which
    malware can leverage the Windows API and NT API to try to identify a malware analyst
    debugging its code. Later in the chapter, you’ll see how malware can also query
    the PEB directly, which is why it’s important to have at least a basic understanding
    of the PEB’s relevant members.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">IsDebuggerPresent
    and CheckRemoteDebuggerPresent</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of the best-known and simplest Windows functions for detecting debuggers
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">IsDebuggerPresent</samp>. This
    function returns a nonzero value if the current process is being debugged; otherwise,
    it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CheckRemoteDebuggerPresent</samp>
    function returns the same information, but with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. The following example
    shows how malware might use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Two parameters are being pushed to the stack here: a handle to the target process
    (in this case, the malware’s own process, <samp class="SANS_TheSansMonoCd_W5Regular_11">hProcess</samp>)
    followed by a pointer to a variable that will receive the information returned
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">DebuggerPresent</samp>). Once the
    malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CheckRemoteDebuggerPresent</samp>,
    the return value (<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>) is stored in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DebuggerPresent</samp> variable. As you’ll
    see later in the chapter, these are some of the easiest debugger detection techniques
    to circumvent.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">NtQueryInformationProcess</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To detect a debugger, <samp class="SANS_TheSansMonoCd_W5Regular_11">CheckRemoteDebuggerPresent</samp>
    calls the system function <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryInformationProcess</samp>,
    a lower-level Windows NT function that can return a lot of different information
    about the system. <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryInformationProcess</samp>
    can also be called directly. It takes several parameters, including <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessHandle</samp>
    (a handle to the target process) and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessInformationClass</samp>
    value (the type of information that should be returned). In the case of debugger
    detection, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessInformationClass</samp>
    value would be <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp>, or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ProcessDebugPort</samp>. A nonzero value
    indicates that the process is currently running under a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the malware author can specify <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessInformationClass
    ProcessDebugFlags</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">1F</samp>).
    If the process is being debugged, the debug flags will be set, tipping off the
    malware. Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessDebugObjectHandle</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">1E</samp>) information class can
    also reveal a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">NtQuerySystemInformation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemInformation</samp>
    is a Windows NT function that can be used to, you guessed it, query system information.
    This function can return many different types of information, and an especially
    crucial structure for our purposes is <samp class="SANS_TheSansMonoCd_W5Regular_11">SYSTEM_KERNEL_DEBUGGER_INFORMATION</samp>.
    This structure contains two important values for debugger detection: <samp class="SANS_TheSansMonoCd_W5Regular_11">KdDebuggerEnabled</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">KdDebuggerNotPresent</samp>,
    both of which can be used to detect a kernel debugger attached to the calling
    process. *Kernel debuggers* are specialized tools for debugging low-level software
    and sometimes for malware analysis. If <samp class="SANS_TheSansMonoCd_W5Regular_11">KdDebuggerEnabled</samp>
    returns nonzero or <samp class="SANS_TheSansMonoCd_W5Regular_11">KdDebuggerNotPresent</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, it might indicate
    to the malware that a kernel debugger is present.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">OutputDebugString</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    function simply displays a string in the debugger. If a process is attached to
    a debugger, the string will be displayed; if not, <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    will return with an error. Malware can abuse this function by manually setting
    an error code using <samp class="SANS_TheSansMonoCd_W5Regular_11">SetLastError</samp>
    (this error can be any arbitrary value), calling <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    with a random string value, and then calling <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLastError</samp>
    to check whether the error state has changed, as demonstrated in the following
    pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This malware sample sets an error code of <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">SetLastError</samp>, then
    invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    with the random string value <samp class="SANS_TheSansMonoCd_W5Regular_11">testing123</samp>.
    Next, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLastError</samp>
    to get the last error code and compares that value to the error code from the
    previous <samp class="SANS_TheSansMonoCd_W5Regular_11">SetLastError</samp> call.
    If the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    succeeded with no error, the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLastError</samp>
    code should still be <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>, meaning
    that a debugger is present. This is an old technique, but malware occasionally
    still attempts to use it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">CloseHandle and NtClose</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a malware sample is being debugged and the malware attempts to call the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CloseHandle</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtClose</samp>
    function with an invalid handle, it will raise an <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_INVALID_HANDLE</samp>
    exception. Once this exception is triggered, it will be passed to the debugger’s
    exception handler, tipping off the malware that it is being debugged. The following
    simple code demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code calls <samp class="SANS_TheSansMonoCd_W5Regular_11">NtClose</samp>
    with an invalid handle as a parameter. Once executed, this will raise an exception
    and tip off the malware that it is being debugged.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">NtQueryObject</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a debugger to work properly, it must create a special kernel object called
    a *debug object*. Malware can call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryObject</samp>
    to get a list of all debug objects, whose presence would indicate either that
    the malware is currently being debugged or that the host has used a debugger in
    the past.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter for this function, <samp class="SANS_TheSansMonoCd_W5Regular_11">Handle</samp>,
    is the handle to the object being queried for information. The second parameter,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryObject</samp>, accepts an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInformationClass</samp> value
    that will tell the function what type of data needs to be returned. The third
    parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInformation</samp>,
    accepts a pointer to where the returned data will be stored.
  prefs: []
  type: TYPE_NORMAL
- en: If you spot malware calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryObject</samp>,
    providing an <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInformationClass</samp>
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectAllTypesInformation</samp>),
    and then inspecting the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectInformation</samp>
    buffer for strings such as <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugObject</samp>,
    you can be relatively certain the malware is attempting to identify a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Heap Flags</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The PEB contains pointers to the process’s memory heap structure, known as the
    *process heap*, at location 0x18 (0x30 for 64-bit processes). The process heap
    contains various members that are pointers to additional data; two of these members
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceFlags</samp>,
    which point to a block of data that provides information to the Windows kernel
    about the process heap memory. In Windows 7 and above, if a process is being debugged,
    the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp> member
    will be <samp class="SANS_TheSansMonoCd_W5Regular_11">0x40000062</samp>, and the
    value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceFlags</samp> member
    will be <samp class="SANS_TheSansMonoCd_W5Regular_11">0x40000060</samp>. To detect
    a debugger, malware may attempt to read these values in its heap structure by
    calling the function <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlQueryProcessHeapInformation</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlQueryProcessDebugInformation</samp>,
    or it may manually read the PEB as we’ll discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t a common anti-debugging technique, so I won’t go into further detail
    here, but it’s important to be aware that it exists. If you spot malware calling
    one or both of these functions, inspect the code that follows. If the malware
    is querying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ForceFlags</samp> member, there’s
    a good chance it’s trying to detect your debugger.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Directly Accessing the PEB</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rather than relying on the Windows functions described in the previous section,
    malware might directly access and read the PEB, as shown in the following assembly
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, in order to obtain the address of the PEB to read it, the malware moves
    the address at <samp class="SANS_TheSansMonoCd_W5Regular_11">fs:0x30</samp> into
    <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>. (As you might recall
    from [Chapter 1](chapter1.xhtml), <samp class="SANS_TheSansMonoCd_W5Regular_11">fs:0x30</samp>
    is the address for the beginning of the PEB.) Next, the malware compares the value
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to the value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">eax+0x2</samp>, which is the <samp class="SANS_TheSansMonoCd_W5Regular_11">BeingDebugged</samp>
    field in the PEB structure. If this value is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    it’s likely that a debugger is attached to the process, and the malware might
    respond accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Another example of manual PEB reading involves the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtGlobalFlag</samp>,
    which is located at byte 0x68 in the PEB and contains information related to the
    creation of memory heaps. When a process is started under a debugger, the value
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">NtGlobalFlag</samp> will be <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x70</samp>, so malware can read that
    value in its PEB for a quick debugger check.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that malware can query any member of the PEB structure in this
    manner. Accessing the PEB directly, rather than invoking common Windows functions
    in order to do so, can be an effective way for malware to detect a debugger without
    raising alarms.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Timing Checks</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Chapter 7](chapter7.xhtml) described timing checks specifically in the context
    of detecting sandboxes and VM environments, but these checks can also be used
    to detect debuggers. Three of the common timing-based methods for debugger detection
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> instruction, and system time
    checks.'
  prefs: []
  type: TYPE_NORMAL
- en: As you might remember from [Chapter 5](chapter5.xhtml), <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp>
    returns the number of milliseconds that have elapsed since system boot-up. Malware
    can call <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> at
    various points in its code to see how much time has elapsed since its last call
    to this function. When malware is being debugged, the program will naturally execute
    more slowly, especially if the malware analyst is setting breakpoints throughout
    the debugging process. If the analyst happens to place a breakpoint on a function
    or is single-stepping through code, the difference between the first call of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetTickCount</samp> and the last will
    be much greater than it would be otherwise. Malware can exploit this fact to detect
    a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Malware can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    instruction in a similar manner. By placing <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp>
    instructions throughout its code, malware can determine whether it’s being debugged
    based on CPU timing (see the x64dbg screenshot in [Figure 10-1](chapter10.xhtml#fig10-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig10-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: Malware using
    rdtsc as an anti-debugging technique</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, malware can simply query the system time by calling functions such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">GetLocalTime</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetSystemTime</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQuerySystemTime</samp> at
    various points in its code to detect a debugger in use.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other methods of using timing checks to catch a debugger in its
    tracks; these are only some of the most common. The takeaway here is that if you
    spot malware that is occasionally calling timing functions or using instructions
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">rdtsc</samp> throughout
    its code, it could be using anti-debugging techniques. The best way to address
    this is to simply avoid using a debugger. However, this isn’t always practical.
    You may have to identify where these functions and instructions are being executed
    in the malware and patch them out, or you may modify their return values to trick
    the malware into believing it’s not being debugged.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">System Artifacts</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Malware may be able to detect a debugger via system artifacts such as desktop
    windows, registry keys, and loaded modules. We’ll cover each briefly in this section,
    but you might also find it helpful to refer back to [Part II](part2.xhtml), which
    covered how malware might search for these types of artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hunting for Debugger
    Windows</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Chapter 5](chapter5.xhtml) discussed how malware can detect analyst tools
    using functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FindWindow</samp>,
    which locates a desktop window, and <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp>,
    which enumerates open desktop windows. Malware can also use these functions to
    look specifically for debugger windows. For example, it might call <samp class="SANS_TheSansMonoCd_W5Regular_11">FindWindow</samp>
    to enumerate open windows with debugger product names such as x64dbg, OllyDbg,
    or Immunity debugger. [Figure 10-2](chapter10.xhtml#fig10-2) shows the ransomware
    variant Satan hunting for any open OllyDbg windows.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig10-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-2: The malware Satan
    looking for OllyDbg-related windows</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Enumerating Loaded
    Modules</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you attach malware to a debugger, the debugger may load modules into the
    malware’s address space; for example, the WinDbg debugger may load the *dbghelp.dll*
    library. Malware can locate a suspect module by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetModuleHandle</samp>
    function and passing the module’s name (such as *dbghelp.dll*) as a parameter.
    Alternatively, it can enumerate all loaded modules by using <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp> and then
    search for a specific module name.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Searching for Debugger
    Processes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Malware can also enumerate the running processes on the host to search for debugger
    processes. To do so, it might call <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>, then look specifically
    for common debugger process names, such as *ollydbg.exe*, *x64dbg.exe*, or *ida64.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Checking Parent Processes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To detect a debugger, malware can check to see what its parent process is. If
    the malware is running inside a debugger, its parent process will be the debugger
    process. If the malware detects it is running as a child process of a debugger
    process (such as *x64dbg.exe*), the malware will identify that it is being debugged.
  prefs: []
  type: TYPE_NORMAL
- en: Malware can detect its parent process in a few ways. One approach is to obtain
    its own process ID (<samp class="SANS_TheSansMonoCd_W5Regular_11">GetCurrentProcessId</samp>),
    take a snapshot of all running processes (<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp>),
    and use <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Proces32Next</samp> to search for
    its own process name. Once it finds its process, the process snapshot structure
    contains an entry (<samp class="SANS_TheSansMonoCd_W5Regular_11">th32ParentProcessID</samp>)
    representing its parent process ID.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, malware could spawn a child process using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>,
    making the malware’s original process the parent process of this new child. The
    child process could then invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugActiveProcess</samp>
    with its parent process as a parameter. If the parent process (the original malware
    process) is already being debugged, this function will throw an exception such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PORT_ALREADY_SET</samp>,
    cluing in the malware that there’s a debugger attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Breakpoint Detection and Traps</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When investigating malware in a debugger, a malware analyst commonly creates
    breakpoints on specific instructions, function calls, or specific memory segments.
    As you might remember from [Chapter 3](chapter3.xhtml), the act of creating software
    breakpoints in the malware’s code modifies the running malware sample. This means
    that the malware can detect these breakpoints in some interesting ways. This section
    will discuss some of the breakpoint detection, circumvention, and exploitation
    methods malware might employ.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Detecting Debuggers
    with Breakpoints</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a debugger hits a breakpoint instruction such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    3</samp> (one of the most common) in a program, it breaks at that point in the
    program’s code. This occurs because the breakpoint instruction causes an interrupt
    exception in the program, which ultimately transfers control to the debugger.
    When a program is not being debugged, however, breakpoint instructions cause an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_BREAKPOINT</samp> and
    the control flow is passed to the program’s default exception handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a great way for malware to test whether it’s being debugged. If malware
    executes the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp>
    and it’s not being debugged, an <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_BREAKPOINT</samp>
    will be raised and the exception handler will be invoked. Of course, the opposite
    is also true. If this <samp class="SANS_TheSansMonoCd_W5Regular_11">EXCEPTION_BREAKPOINT</samp>
    doesn’t invoke the exception handler, the malware can infer that it’s being debugged.
    Take a look at the following simplified pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This pseudocode features a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">try...
    catch</samp> statement. The malware attempts to execute the <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    3</samp> instruction ❶, and if this statement successfully returns without invoking
    an exception handler, the malware assumes it’s running in a debugger. If this
    instruction raises an exception ❷, however, the malware can safely assume it’s
    not attached to a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Detecting and Circumventing
    Software Breakpoints</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Malware can also directly detect the use of breakpoints by implementing breakpoint-scanning
    techniques. In the following assembly code example, the malware scans its code
    for the breakpoint instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    3</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">0xCC</samp> in hex):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This malware sample is trying to determine whether a malware analyst has set
    a software breakpoint on the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    function. First, the malware moves the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp> register. Then,
    it compares the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0xCC</samp>
    (the <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp> debugger breakpoint
    instruction) to the first byte in <samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp>,
    which is the beginning of the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>
    function and where the breakpoint will reside. Once the malware identifies a software
    breakpoint, it may attempt to overwrite or clear the breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: You can overcome some breakpoint detection techniques by using uncommon breakpoint
    instructions. Many debuggers have this option. In x64dbg, simply navigate to **Options****Settings****Engine**
    and set your preferred breakpoint instruction under Default Breakpoint Type, as
    shown in [Figure 10-3](chapter10.xhtml#fig10-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig10-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-3: Setting the default
    breakpoint type in x64dbg</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Some variations of malware look for these alternative breakpoint instructions
    as well, so a better option is to use hardware breakpoints to circumvent software
    breakpoint detection techniques. Hardware breakpoints can also be circumvented
    by malware, however, as the next section will discuss.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Detecting and Circumventing
    Hardware and Memory Breakpoints</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Like software breakpoints, hardware breakpoints can be used by analysts to
    intercept function calls, break on interesting behavior, and generally control
    the malware’s execution. Because hardware breakpoints are implemented in CPU registers
    (DR0–DR3) rather than as instructions, malware can scan these registers for them.
    If any of these registers contain data (specifically, a memory address), the malware
    might assume there’s a hardware breakpoint in place and take evasive actions,
    such as clearing these registers, effectively removing the breakpoints. One way
    to find hardware breakpoints is by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetThreadContext</samp>
    function (or <samp class="SANS_TheSansMonoCd_W5Regular_11">Wow64GetThreadContext</samp>
    for 64-bit programs) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this sample pseudocode (adapted from [*https://<wbr>www<wbr>.codeproject<wbr>.com<wbr>/Articles<wbr>/30815<wbr>/An<wbr>-Anti<wbr>-Reverse<wbr>-Engineering<wbr>-Guide*](https://www.codeproject.com/Articles/30815/An-Anti-Reverse-Engineering-Guide)),
    the malware defines a new <samp class="SANS_TheSansMonoCd_W5Regular_11">CONTEXT</samp>
    structure (<samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>), which
    is a Windows structure used to store CPU state and related data for the process.
    This structure must be in place to store the debug register (DR0–DR3) data that
    the malware will check for shortly. Next, the malware specifies that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CONTEXT_DEBUG_REGISTERS</samp> should
    be the data that <samp class="SANS_TheSansMonoCd_W5Regular_11">GetThreadContext</samp>
    returns. The malware then gets a handle to its current thread (<samp class="SANS_TheSansMonoCd_W5Regular_11">HANDLE</samp>)
    and calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetThreadContext</samp>,
    which will store the current thread’s <samp class="SANS_TheSansMonoCd_W5Regular_11">CONTEXT_DEBUG_REGISTERS</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> structure.
    Finally, the malware sample inspects the debug registers for data. If these registers
    are nonzero, the check returns true, informing the malware that a hardware breakpoint
    has been set by the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The malware can then completely remove any hardware breakpoints it detects
    by using <samp class="SANS_TheSansMonoCd_W5Regular_11">SetThreadContext</samp>
    (or <samp class="SANS_TheSansMonoCd_W5Regular_11">Wow64SetThreadContext</samp>
    for 64-bit malware). Adding this line to the preceding code example will effectively
    clear the debug registers, subsequently removing the malware analyst’s hardware
    breakpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finally, malware can detect memory breakpoints with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>
    function. Setting a memory breakpoint alters the memory page, so if the malware
    invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>
    on a suspect memory page, and if it returns an unexpected value such as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PAGE_NOACCESS</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp>,
    it might infer that a hardware breakpoint has been set on this memory page. Another
    option to achieve the same effect is for the malware to execute <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualQuery</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualQueryEx</samp>, or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtQueryVirtualMemory</samp>. We’ll discuss
    memory breakpoints more in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: If you suspect that a malware sample is using any of the techniques described
    in this section, it’s helpful to hook (place a breakpoint on) these functions.
    Once a breakpoint is hit, you can simply modify the return value or <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>
    out the call to the function altogether. The debugger plug-in ScyllaHide, described
    on [page 181](chapter10.xhtml#pg_181), can also be useful here.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Using Memory
    Page Guards for Breakpoint Detection</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Memory page guards* are a special flag implemented in Windows for memory access.
    When allocating new memory pages, a program can add the <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp>
    flag as a sort of alarm system for memory access. When this area of memory is
    accessed by the program (or by a different program), it raises a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_GUARD_PAGE_VIOLATION</samp>
    exception. If the program is running under a debugger, <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp>
    often behaves a bit differently (because the debugger is handling the exception)
    and won’t raise the normal exception.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Malware can take advantage of this by implementing page guards on certain memory
    pages. If these pages are accessed from outside a debugger (meaning that the malware
    isn’t being debugged), the malware will raise the exception as normal. If no exception
    is raised, depending on the debugger being used and its configuration, this could
    alert the malware that it’s being debugged. To set page guards in memory, malware
    can call <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp> with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">0x100</samp>)
    value set. The following code shows a malware sample calling <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    with this parameter set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">flNewProtect</samp> value
    set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0x104</samp>, which is a
    combination of <samp class="SANS_TheSansMonoCd_W5Regular_11">0x100</samp> (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp>) and <samp class="SANS_TheSansMonoCd_W5Regular_11">0x4</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">READ/WRITE</samp>) protection.
    Memory allocation and <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>
    are covered in more detail in [Part IV](part4.xhtml), particularly [Chapter 17](chapter17.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Using Breakpoint Traps</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Malware can insert breakpoint instructions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    3</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int 2d</samp> throughout
    its code in order to force the debugger to break often, causing a lot of trouble
    for the malware analysts debugging it. A constantly breaking debugger makes debugging
    a headache. Breakpoint instructions intentionally placed in malware are sometimes
    called *traps*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-4](chapter10.xhtml#fig10-4) shows a sample of the Dridex malware
    in x64dbg using the <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp>
    trap technique.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig10-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-4: A Dridex malware
    sample using a breakpoint anti-debug trap</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The Dridex code shown here executes two <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    3</samp> instructions, increments <samp class="SANS_TheSansMonoCd_W5Regular_11">eax</samp>,
    executes two more <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp> instructions,
    and then continues to loop. This function repeats 13,512 times (<samp class="SANS_TheSansMonoCd_W5Regular_11">cmp
    eax, 13512</samp>), which can cause major frustration for the malware analyst
    debugging the sample.
  prefs: []
  type: TYPE_NORMAL
- en: It’s often difficult to circumvent this trap technique in malware. The best
    approach is to identify the problematic instructions and patch them out. As in
    the case of this Dridex sample, the malware may create a loop (using <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">jnz</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">jz</samp>,
    and so on) of these breakpoint instructions, in which case you’d need to patch
    out or modify the loop instruction to bypass this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Unhandled Exceptions</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Malware can set a top-level exception handler (called an *unhandled exception
    filter*) to test for a debugger. This supersedes any other handlers, such as the
    default SEH, by first invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">SetUnhandledExceptionFilter</samp>,
    which allows the calling program to become the top-level exception handler, then
    invoking <samp class="SANS_TheSansMonoCd_W5Regular_11">UnhandledExceptionFilter</samp>,
    which forces the exception handler to execute. When a malware program isn’t being
    debugged, the exception will be passed to the new handler. If it *is* being debugged,
    then the new handler won’t be called and the exception will be passed to the debugger,
    indicating to the malware that it’s running inside a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: To deal with this technique, you can intercept calls to both <samp class="SANS_TheSansMonoCd_W5Regular_11">SetUnhandledExceptionFilter</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">UnhandledExceptionFilter</samp>
    (via breakpoints or hooks) and modify the function calls or patch them out of
    the code completely. [Chapter 11](chapter11.xhtml) discusses exception handling
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Checksums, Section Hashing, and Self-Healing</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Malware can take a checksum (or hash) of its code to determine whether a breakpoint
    has been placed or an analyst has otherwise modified the code in the debugger.
    Using any hashing algorithm (MD5, for example), the malware author can create
    a hash of its code line by line or hash an entire section of code (typically called
    *section hashing*), then compare this with a baseline sum. If there’s a discrepancy,
    the malware may assume that a breakpoint has been set or its code has been otherwise
    modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Malware can also implement so-called *self-healing* techniques, in which it
    stores clean copies of its code and, if it detects code tampering, restores the
    original version. The following pseudocode demonstrates how this might look in
    practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There’s not much an analyst can do to circumvent this technique. The most effective
    method is to identify where the malware is obtaining a checksum of a certain segment
    of code and then patch this functionality out of its code. Hardware breakpoints
    can also be used in the event that the malware is using this approach to look
    for software breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Exploiting, Crashing, and Interfering
    with the Debugger</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes the most effective anti-debugging method is to directly interfere
    with the debugger by causing it to crash or behave unpredictably. Just like any
    software, debuggers can have bugs in their code that allow the malware to interfere
    with analysis, crash the debugger, or possibly even crash the operating system
    itself. A popular example is a bug in version 1.1 of OllyDbg whereby malware could
    call the <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    function and pass <samp class="SANS_TheSansMonoCd_W5Regular_11">%s</samp> as a
    parameter; OllyDbg would be unable to handle this value, causing the running malware
    sample to crash and preventing further debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps slightly less offensive is the <samp class="SANS_TheSansMonoCd_W5Regular_11">BlockInput</samp>
    function, which malware can abuse to interfere with analysis tools. <samp class="SANS_TheSansMonoCd_W5Regular_11">BlockInput</samp>
    takes only one parameter: <samp class="SANS_TheSansMonoCd_W5Regular_11">fBlockIt</samp>.
    If this parameter is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    mouse and keyboard events to all applications will be blocked, which can seriously
    interfere with the debugging process. If malware detects that it is being manually
    inspected or running under a debugger, it may simply call <samp class="SANS_TheSansMonoCd_W5Regular_11">BlockInput</samp>
    as a self-defense mechanism. Luckily, you can easily get around this technique
    by using CTRL-ALT-DELETE, which will escape the <samp class="SANS_TheSansMonoCd_W5Regular_11">BlockInput</samp>
    routine. You can also modify the function call in a debugger, setting the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fBlockIt</samp> parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, malware can use <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationThread</samp>
    to hide code execution from the debugger or to crash the debugger altogether.
    By passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreadInformationClass</samp>
    value <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreadHideFromDebugger</samp>
    (in hex, 0x11) to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationThread</samp>
    function, the malware can covertly execute code, causing the malware analyst to
    lose control of the running sample. Additionally, if the malware executes a breakpoint
    instruction (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp>)
    in the covertly executed code, the malware process will hang indefinitely in the
    debugger. I’ll discuss this technique in the context of covert code execution
    in [Chapter 11](chapter11.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: These are only a few examples of known debugger exploitation techniques, and
    there are certainly more that are unknown. Malware analysts should be wary of
    these techniques and expect new ones to pop up when analyzing advanced evasive
    malware. Remember to always conduct analysis and debugging in a safe testing environment.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Debug Blocking and Anti-attach
    Techniques</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of detecting a debugger or actively interfering with it, malware may
    simply try to prevent it from functioning altogether. This series of techniques
    is often called *debug blocking* or *anti-attach*.
  prefs: []
  type: TYPE_NORMAL
- en: To attach to a running malware sample, normally the debugger calls the Windows
    function <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugActiveProcess</samp>.
    In the event that the process is already being debugged, this function will fail.
    Malware can take advantage of this by simply acting as its own debugger. It can
    spawn a child process and set the parent process as the debugger. When attempting
    to attach a debugger to this child process, a malware analyst will be met with
    a frustrating <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PORT_ALREADY_SET</samp>
    exception, meaning that the process is already being debugged.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this technique, you can attach a debugger to the parent process
    and set a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">WaitForDebugEvent</samp>.
    When the breakpoint is hit, you can force the process (which is acting as the
    debugger) to unattach from its child process by invoking the <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugActiveProcessStop</samp>
    function.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For more information on this technique, check out the research paper “The
    Art of Unpacking” by Mark Vincent Yason. The paper is old but still very relevant.
    Read it at* [https://<wbr>www<wbr>.blackhat<wbr>.com<wbr>/presentations<wbr>/bh<wbr>-usa<wbr>-07<wbr>/Yason<wbr>/Whitepaper<wbr>/bh<wbr>-usa<wbr>-07<wbr>-yason<wbr>-WP<wbr>.pdf](https://www.blackhat.com/presentations/bh-usa-07/Yason/Whitepaper/bh-usa-07-yason-WP.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: Malware can also modify common debugger functions to prevent debugging; the
    malware family GuLoader does exactly this. When attaching to a process, the debugger
    will invoke the functions <samp class="SANS_TheSansMonoCd_W5Regular_11">DbgBreakPoint</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DbgUiRemoteBreakin</samp>, which
    essentially allow the debugger to use breakpoints within the program being debugged.
    GuLoader modifies <samp class="SANS_TheSansMonoCd_W5Regular_11">DbgBreakPoint</samp>
    by removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">int 3</samp> opcode
    and replacing it with <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>
    instructions, effectively impairing the function. Likewise, GuLoader modifies
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">DbgUiRemoteBreakin</samp> function
    with an invalid call instruction, which will ultimately cause an exception, possibly
    resulting in a crash of the malware being debugged. *CrowdStrike* wrote an exceptional
    article on GuLoader; for more information on these techniques, read the paper
    at [*https://<wbr>www<wbr>.crowdstrike<wbr>.com<wbr>/blog<wbr>/guloader<wbr>-malware<wbr>-analysis<wbr>/*](https://www.crowdstrike.com/blog/guloader-malware-analysis/).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Other Anti-debugging Techniques</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many more methods malware can use to discover or interfere with a
    debugger in use. And, of course, researchers and malware authors constantly identify
    new, creative ways to detect and circumvent debuggers. I’ve tried to cover as
    many commonly used or particularly interesting techniques as possible in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Some methods I chose not to describe here because they’re uncommon or difficult
    to implement. For example, some malware families (rootkits, for instance) can
    directly inspect their <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp>
    blocks for signs of an attached debugger, but this is quite rare. Other techniques
    are subject to error. For example, malware can check its debug privileges by attempting
    to call <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp> with
    the target of a system process, such as *csrss.exe*. If the malware can get a
    handle to this process, it may infer that it’s being debugged, but it’s not always
    accurate. Another example is the use of the *trap flag*, a special flag in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EFLAGS</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">RFLAGS</samp>
    registers that can give away the presence of a debugger. Both methods can produce
    false positives, are more difficult to implement, and thus are not as widely used.
  prefs: []
  type: TYPE_NORMAL
- en: To end this chapter, we’ll take a look at how to counter anti-debugging techniques
    that you encounter when reverse engineering.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Countering Anti-debugging Techniques</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to effectively bypass anti-debugging techniques, first you need to
    have an idea of what exactly you’re up against. You could identify the techniques
    a malware sample is employing simply by single-stepping through its code and manually
    searching for them, but of course, this isn’t very efficient. Typically, you’ll
    want to use a disassembler in combination with a debugger to better understand
    any anti-debugging methods you encounter.
  prefs: []
  type: TYPE_NORMAL
- en: Before digging into any malware, I always inspect the sample in a PE static
    analysis and triage tool such as PEStudio or PE-bear. These types of tools allow
    me to inspect imports and strings in the file that may help identify possible
    anti-debugging-related libraries and function calls. I also use tools like CAPA,
    which I described in [Chapter 3](chapter3.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Once I’ve identified anti-debugging techniques in the executable, I inspect
    the surrounding code with the help of a disassembler and decide how I’ll counter
    and bypass these techniques. This often involves setting breakpoints on suspect
    code and function calls in the debugger and modifying the code dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: There are some great tools that can help automate the process of bypassing anti-debugging
    techniques. *ScyllaHide* ([*https://<wbr>github<wbr>.com<wbr>/x64dbg<wbr>/ScyllaHide*](https://github.com/x64dbg/ScyllaHide)),
    a plug-in for x64dbg and other debuggers, is perhaps the most popular. It can
    hide a debugger from malware by dynamically modifying the malware’s code and hooking
    suspect functions to bypass many debugger detection and anti-debugger techniques
    (as shown in [Figure 10-5](chapter10.xhtml#fig10-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig10-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-5: The ScyllaHide
    menu in x64dbg</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To enable an *anti-anti-debugging* feature in ScyllaHide, simply check the box
    next to the feature, then select **Apply** and **OK**. Mousing over each option
    will pop up more information about it. I often enable the entire left column of
    options, and this rarely causes problems. That said, while most of these options
    can be enabled safely, some of them may break the malware sample, possibly causing
    it to crash or behave in unexpected ways. So, use this with care.
  prefs: []
  type: TYPE_NORMAL
- en: '*HyperHide* ([*https://<wbr>github<wbr>.com<wbr>/Air14<wbr>/HyperHide*](https://github.com/Air14/HyperHide))
    provides many of the same features as ScyllaHide, but it’s always a good idea
    to have multiple tools in your toolbox. [Figure 10-6](chapter10.xhtml#fig10-6)
    shows HyperHide’s anti-anti-debugging capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig10-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-6: The HyperHide
    menu in x64dbg</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Both tools feature very similar anti-anti-debugging options, but one may work
    better than the other in certain circumstances. Try them both out and see which
    you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter discussed many common anti-debugging methods that malware might
    use to detect and circumvent debugging tools. Many of these techniques are widely
    used in all sorts of malware, from commodity infostealers to advanced bespoke
    and targeted threats, so it’s important to understand the concepts described here.
    In the next chapter, you’ll learn how malware can covertly execute code to evade
    dynamic analysis tools like debuggers and use misdirection techniques to disrupt
    the analysis process.
  prefs: []
  type: TYPE_NORMAL
