<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch15">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_345" aria-label="345"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch15">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">15</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">EXTENDED HEAPS</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="INTRO">In this chapter, we’ll explore some new data structures that allow extra operations on heaps. For example, we’ll be able to change or alter the value of a key by increasing or decreasing it, or produce a new heap out of two or more other heaps by melding or merging. These new structures are based on several concepts we’ve looked at in previous chapters, such as common heaps, linked (and doubly linked) lists, forests, and more.</p>&#13;
<p class="TX">First, we’ll consider <i>skew heaps</i>, which are heaps implemented as binary trees, and <i>binomial heaps</i>, which are a new heap implementation based on a forest that allows you to merge heaps quickly. We’ll also study an enhanced version of heaps called <i>lazy binomial heaps</i> that provide better amortized performance, and finish by looking at <i>Fibonacci heaps</i>, which allow you to change (increase or decrease) a key in (amortized) constant time, and <span role="doc-pagebreak" epub:type="pagebreak" id="pg_346" aria-label="346"/><i>pairing heaps</i>, which present an easier alternative with surprisingly similar performance.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-75"/><span class="SANS_Futura_Std_Bold_B_11">Meldable and Addressable Priority Queues</span></h3>&#13;
<p class="TNI1">First review the priority queue abstract data type (ADT) you implemented with binary heaps. This ADT requires three operations: <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> adds a new value to the queue, <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span> gets the highest priority from the queue, and <span class="SANS_TheSansMonoCd_W5Regular_11">top()</span> shows the priority of the current top element of the queue. With the binary heap implementation that represents the heap as an array, the two first operations run in <i>O</i>(log <i>n</i>) time, and the third runs in <i>O</i>(1). The extra <span class="SANS_TheSansMonoCd_W5Regular_11">change()</span> operation alters the priority of an element in the queue, and that also is <i>O</i>(log <i>n</i>).</p>&#13;
<p class="TX">If those three (or four) operations were all that were needed, you’d have a good enough implementation. Working with arrays and no pointers is usually quite fast, providing performance that is tough to beat. However, if you need specific enhanced times (for example, adding new values in constant time) or extra operations (like being able to merge two queues into one), you’ll need other solutions. Each structure considered in this chapter allows us to meld (or merge) two separate priority queues into one. This is called a <i>meldable priority queue (MPQ)</i>.</p>&#13;
<p class="TX">Several algorithms need to be able to meld priority queues, so allowing that operation enhances their performance. Imagine you’re implementing a priority queue for the printers in your system. If one printer goes down, you want to be able to reassign all of its printing jobs to another. A meldable heap would provide the fastest performance for such a reassignment.</p>&#13;
<p class="TX">You also might want to include a second operation: changing a key value. This change is a specific one where the old key is replaced with a new one that should go higher in the heap—for instance, a lower value in a min heap for several graph algorithms. In fact, when working with min heaps, the operation is usually called <span class="SANS_TheSansMonoCd_W5Regular_11">decreaseKey()</span>. Since you’re working with both max and min heaps, you’ll use the name <span class="SANS_TheSansMonoCd_W5Regular_11">changeKey()</span> but will check to make sure the new value should be nearer the top of the heap.</p>&#13;
<p class="TX">For this, you need a reference to a value that you insert, and you’ll use the <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> operation for that purpose. A heap that provides such an operation is called an <i>addressable heap</i>. The main focus of this chapter is on meldable heaps, but all of the structures here will be addressable, so we’ll consider both new operations together.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>We considered max heaps with their highest value at the top in <a href="chapter14.xhtml">Chapter 14</a>. Since extended heaps are often used with the lowest value at the top, we’ll use the function</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">goesHigher(a,b)</span> <i>to determine whether a value</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">a</span> <i>should be higher than a value</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">b</span><i>. For max heaps, you have</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">a &gt; b</span> <i>(so the greater value goes to the top), and for min heaps, you have</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">a &lt; b</span><i>. Simply changing a single line in the definition of this new function provides max heaps or min heaps as needed. All the examples in this chapter use max heaps.</i></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_347" aria-label="347"/><a href="chapter15.xhtml#tab15-1">Table 15-1</a> shows the operations in terms of a meldable priority queue  ADT, starting with creating the priority queue, modifying the addition operation, and including merging and changing.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab15-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 15-1:</span></span> <span class="SANS_Futura_Std_Book_11">Operations on Meldable Priority Queues</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Signature</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">MPQ</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create a new MPQ.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">MPQ</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Determine whether the MPQ is empty.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">MPQ × key</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">MPQ × node</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a new key, add it to an MPQ and provide a reference to the new node.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Top</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">MPQ</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">key</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given an MPQ, produce its top value.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">MPQ</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">MPQ × key</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given an MPQ, extract its top value and update the MPQ correspondingly.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Change</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">MPQ × node × key</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">MPQ</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given an MPQ, one of its nodes, and a new key value, change the node’s key to the new value and update the MPQ.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Merge</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">MPQ1 × MPQ2</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">MPQ</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given two distinct MPQs, merge them into a single MPQ.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Let’s now move on to a different variety of heap.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-76"/><span class="SANS_Futura_Std_Bold_B_11">Skew Heaps</span></h3>&#13;
<p class="TNI1">In <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>, we represented binary heaps with an array, which has the advantage of maximum simplicity. However, with that representation, the best performance you can achieve when merging two heaps of sizes <i>m</i> and <i>n</i> is O(<i>m</i> + <i>n</i>) by using Floyd’s algorithm. (As an alternative, think of choosing a heap and adding all the other heaps’ values to it, which would not be optimal; see question 15.1.) <i>Skew heaps</i>, which are based on representing a heap as a self-adjusting binary tree, provide better (although amortized) performance. In later sections, we’ll look at even speedier data structures, but those will include an added degree of complexity.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Skew heaps are related to a data structure (which we don’t discuss in this book) called a leftist heap. Skew heaps, however, require less space, are competitive as to running time, and are easier to implement.</i></p>&#13;
<p class="TX">Skew heaps have one characteristic in common with the binary heaps considered previously: the heap property must be satisfied, so a root must be greater than its children—in other words, a skew heap is a <i>heap-ordered binary tree</i>. (Remember, we are working with max heaps; for min heaps, a root would be smaller than its children.) However, one important difference is that skew heaps have no structural constraints, so the tree can have any shape, and its height may be not logarithmic. <a href="chapter15.xhtml#fig15-1">Figure 15-1</a> illustrates this fact. It shows a valid heap, but its shape is different from what we saw in <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_348" aria-label="348"/>&#13;
<figure class="IMG"><img class="img5" id="fig15-1" src="../images/Figure15-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-1: A skew heap isn’t complete as common heaps are.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Apart from the heap property and no structural constraints, a third particular detail is that all adding and removing operations need to use the <i>skew-merging</i> operation to assure good amortized performance.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-126"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Representing a Skew Heap</span></h4>&#13;
<p class="TNI1">Since a skew heap is a binary tree at its core, you can represent it using the same kind of code for binary search trees and others:</p>&#13;
<pre id="pre-287"><code>const goesHigher = (a, b) =&gt; a &gt; b;&#13;
&#13;
const newSkewHeap = () =&gt; null;&#13;
&#13;
const newNode = (key, left = null, right = null) =&gt; ({key, left, right});&#13;
&#13;
const isEmpty = (heap) =&gt; heap === null;&#13;
&#13;
const top = (heap) =&gt; (isEmpty(heap) ? undefined : heap.key);</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">goesHigher()</span> function determines whether to have a max heap (as shown here) or a min heap (by changing the comparison to <span class="SANS_TheSansMonoCd_W5Regular_11">a &lt; b</span>). The following three functions are copies of the binary search tree code, and the final <span class="SANS_TheSansMonoCd_W5Regular_11">top()</span> is simple, given that the heap’s top will be the tree’s root.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-127"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Merging Two Skew Heaps</span></h4>&#13;
<p class="TNI1">The logic for merging two skew heaps together is as follows:</p>&#13;
<p class="ListNumberF">	1.	If you merge two empty heaps, the result is an empty heap.</p>&#13;
<p class="ListNumber">	2.	If one heap is empty and the other isn’t, the result is the nonempty heap.</p>&#13;
<p class="ListNumberL">	3.	If both heaps are nonempty, the heap with the greater root becomes the merged heap, but it swaps its children and then merges its left subtree with the heap that has the smaller root.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_349" aria-label="349"/>The first two cases are pretty clear, so let’s consider the third, more interesting one. If you start with the two skew heaps shown in <a href="chapter15.xhtml#fig15-2">Figure 15-2</a>, what’s the result of merging them?</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-2" src="../images/Figure15-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-2: Two skew heaps to be merged</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The root of the merged heap should be 60, because it’s the greater root. (Again, keep in mind that you’re working with max heaps.) The left subtree of the corresponding tree would switch sides with the right subtree, and the (now) left subtree would be merged with the heap with root 56. Recursively, you’d compare 56 and 34, so the new root would be 56, and so on. Can you follow all the steps to the result shown in <a href="chapter15.xhtml#fig15-3">Figure 15-3</a>? For instance, it’s easy to see that the old left child of the 60 key now is its right child; the 56 key also swapped its subtrees.</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-3" src="../images/Figure15-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-3: The result of merging the two skew heaps</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Switching subtrees is what provides good amortized performance; if you merge without swapping, the performance is worse. (See question 15.2 for two specific sequences of operations that produce badly shaped structures.) The logic is as follows:</p>&#13;
<pre id="pre-288"><code>const merge = (heap1, heap2) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(heap2)) {&#13;
   return heap1;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else if (isEmpty(heap1)) {&#13;
   return heap2;&#13;
 } else if (goesHigher(heap1.key, heap2.key)) {&#13;
 <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> [heap1.left, heap1.right] = [merge(heap2, heap1.right), heap1.left];&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_350" aria-label="350"/>    return heap1;&#13;
 } else {&#13;
 <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> return merge(heap2, heap1);&#13;
 }&#13;
};</code></pre>&#13;
<p class="TX">If the second heap is empty, return the first one <span class="CodeAnnotation" aria-label="annotation1">❶</span>. (This also covers the case when both heaps are empty. Can you see why?) Otherwise, if the first heap is empty <span class="CodeAnnotation" aria-label="annotation2">❷</span>, return the second heap. If no heap is empty and the first heap has the highest key, produce a new heap as described earlier <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If the second heap has the highest key, just swap them around for the merge <span class="CodeAnnotation" aria-label="annotation4">❹</span>. (See question 15.3 for an alternative.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-128"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Adding a Key to a Skew Heap</span></h4>&#13;
<p class="TNI1">How do you add a new key to a heap, if all you know is how to merge? Simply build a new heap with a single value and merge it to the existing heap. You’ve already looked at how to merge heaps, so let’s skip to the actual code:</p>&#13;
<pre id="pre-289"><code>const add = (heap, keyToAdd) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const newHeap = newNode(keyToAdd);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> return [merge(heap, newHeap), newHeap];&#13;
};</code></pre>&#13;
<p class="TX">This just creates a single-node heap <span class="CodeAnnotation" aria-label="annotation1">❶</span> and merges it <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-129"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Removing the Top Key from a Skew Heap</span></h4>&#13;
<p class="TNI1">Removing the top key from a heap is straightforward. When you remove the root, you’re left with two subtrees, so all you need to do is merge them to form the new heap:</p>&#13;
<pre id="pre-290"><code>const remove = (heap) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(heap)) {&#13;
    throw new Error("Empty heap; cannot remove");&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const topKey = top(heap);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> return [merge(heap.left, heap.right), topKey];&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">If the heap is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, throw an error. Otherwise, get the top key <span class="CodeAnnotation" aria-label="annotation2">❷</span> and merge the left and right subtrees <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-130"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Considering Performance for Skew Heaps</span></h4>&#13;
<p class="TNI1">When first thinking about skew heaps and realizing how their structure could become quite awful (in the same way that binary trees can degenerate into linear shapes), it’s hard to believe that their performance can be good. However, the amortized time of additions, removals, and merging <span role="doc-pagebreak" epub:type="pagebreak" id="pg_351" aria-label="351"/>can be proven to be <i>O</i>(log <i>n</i>). <a href="chapter15.xhtml#tab15-2">Table 15-2</a> shows the results; asterisks denote amortized values.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab15-2"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 15-2:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Skew Heaps</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Performance</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)*</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Top</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)*</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Change</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)*</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Merge</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)*</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">changeKey()</span> method was added, which you can do by first removing the old key and then inserting the new one; both are <i>O</i>(log <i>n</i>) methods. (See question 15.4.)</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h1-77"/><span class="SANS_Futura_Std_Bold_B_11">Binomial Heaps</span></h3>&#13;
<p class="TNI1">Skew heaps have amortized logarithmic performance all around, but if you go beyond single trees, you can do better. <i>Binomial heaps</i> are based on a forest of heaps, and not only do they perform well, they also are the basis for some enhanced variations with even better performance.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-131"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Binomial Trees</span></h4>&#13;
<p class="TNI1">Start with a definition: a <i>binomial tree of order k</i>, or <i>BT(k)</i>, is a <i>k</i>-ary tree that is either empty or consists of a root whose children are binomial trees of order 0, 1, 2, . . . up to (<i>k</i> – 1). <a href="chapter15.xhtml#fig15-4">Figure 15-4</a> shows the first five binomial trees, from BT(0) to BT(4), each consisting of a root and one copy of each previous binomial tree.</p>&#13;
<figure class="IMG"><img class="img1" id="fig15-4" src="../images/Figure15-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-4: The first five binomial trees</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_352" aria-label="352"/>When looking at the trees, you may notice some mathematical properties that can be properly proven, but the most important ones are that BT(<i>k</i>) has exactly 2<i><sup>k</sup></i> nodes and its height is <i>k</i>. They share those two properties with full binary trees. (Actually, full binary trees of height <i>k</i> have 2<i><sup>k+</sup></i><sup>1</sup> – 1 nodes, but it’s close enough. Let it go!)</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The order of a binomial tree equals the degree of its root, so in this code, we’ll use degree instead of order, because that will help when we consider Fibonacci heaps, which don’t use the order concept but work with the root’s degree.</i></p>&#13;
<p class="TX">If you count how many nodes each level has, you’ll notice another property that explains the name of this heap: for the trees in <a href="chapter15.xhtml#fig15-4">Figure 15-4</a>, the results are 1; 1 and 1; 1, 2, and 1; 1, 3, 3, and 1; 1, 4, 6, 4, and 1; and so on. These are <i>binomial coefficients</i>, as in Pascal’s triangle where each value is the sum of the two above it, as shown in <a href="chapter15.xhtml#fig15-5">Figure 15-5</a>. Another property of the triangle is that the sum of the numbers in a row is a power of 2, which also matches the size property for a BT(<i>k</i>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-5" src="../images/Figure15-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-5: Pascal’s triangle provides the number of values at each level of binomial heaps.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You can look at these trees another way. Notice that each tree is actually built out of two trees of the previous order; modifying <a href="chapter15.xhtml#fig15-4">Figure 15-4</a> a bit makes this clearer, as shown in <a href="chapter15.xhtml#fig15-6">Figure 15-6</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig15-6" src="../images/Figure15-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-6: Each binomial tree actually consists of two smaller previous ones.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="chapter15.xhtml#fig15-6">Figure 15-6</a> shows the first four binomial trees. Each one (except the first) is built out of two copies of the previous tree, joined at a new root. If these trees also satisfy the heap order property (all nodes are greater than or equal to their children), they’re called <i>heap-ordered binomial trees</i>. With such trees, you can easily represent a heap whose size is a power of 2, but how do you represent other sizes of heaps?</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_353" aria-label="353"/>&#13;
<h4 class="H2" id="sec10"><span id="h2-132"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Defining Binomial Heaps</span></h4>&#13;
<p class="TNI1">A <i>binomial heap</i> is a forest of heap-ordered binomial trees. (Some textbooks specify that those trees must be ordered by ascending size, but we won’t apply that extra rule.) How will this allow us to represent any size of heaps? Binary numbers provide an easy answer.</p>&#13;
<p class="TX">The number 22 in binary is 10110, which means that 22 = 16 + 4 + 2; thus, you can represent any integer number as a sum of powers of 2. In the same way, you represent a heap of any size with a set of binomial trees whose sizes add up to whatever size you need. (You won’t have two binomial trees of the same order. Can you see why?) Keep in mind another property: the representation of a number <i>n</i> in the binary system requires log <i>n</i> bits, rounded up (we’ll use this later).</p>&#13;
<p class="TX">For simplicity, we represent the forest with an array of trees (you could also work with a list of linked trees, but that added complexity isn’t needed). Since binomial trees are multiway trees, you also need a way to represent them, so we’ll use a binary tree representation. Nodes have a <span class="SANS_TheSansMonoCd_W5Regular_11">down</span> pointer (instead of <span class="SANS_TheSansMonoCd_W5Regular_11">left</span>) to their first child and a <span class="SANS_TheSansMonoCd_W5Regular_11">right</span> pointer to their next sibling. Nodes also include an <span class="SANS_TheSansMonoCd_W5Regular_11">up</span> link to their parents, in case you want to implement the <span class="SANS_TheSansMonoCd_W5Regular_11">changeKey()</span> operation. Finally, each node also has its <span class="SANS_TheSansMonoCd_W5Regular_11">degree</span>.</p>&#13;
<p class="TX">This representation is necessary because these algorithms require two operations: splitting a tree into several smaller ones and fusing two trees together, and those operations are fast and easy to implement with the links. For example, fusing two BT(2)s to build a BT(3) requires changing only two pointers (we’ll look at that in the next section).</p>&#13;
<p class="TX">Start with a few basic functions and then add the rest:</p>&#13;
<pre id="pre-291"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const newBinomialHeap = () =&gt; [];&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const newNode = (key) =&gt; ({&#13;
  key,&#13;
  right: null,&#13;
  down: null,&#13;
  up: null,&#13;
  degree: 0&#13;
});&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> const isEmpty = (heap) =&gt; heap.length === 0;</code></pre>&#13;
<p class="TX">A binomial heap, then, is an array <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and each of its elements is a binomial tree. The nodes have the five attributes described earlier <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Checking whether the heap is empty just requires testing the length of the array of trees <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You might have wondered about using functions for binomial trees. However, since you aren’t actually going to use the trees for searching, you’ll use plain records in the code, with</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">key</span> <i>and</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">degree</span> <i>attributes, as well as with</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">up</span><i>,</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">down</span><i>, and</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">right</span> <i>pointers. Remember that the order of a binomial tree equals the degree of its root; that’s why you have</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">degree</span> <i>instead of</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">order</span><i>. Having the degree for all roots will help with Fibonacci heaps.</i></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_354" aria-label="354"/>First, write the <span class="SANS_TheSansMonoCd_W5Regular_11">top()</span> procedure, using an auxiliary <span class="SANS_TheSansMonoCd_W5Regular_11">_findTop()</span> function to go through all the roots:</p>&#13;
<pre id="pre-292"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const _findTop = (trees) =&gt; {&#13;
  let top;&#13;
  trees.forEach((v, i) =&gt; {&#13;
    if (top === undefined || goesHigher(v.key, trees[top].key)) {&#13;
      top = i;&#13;
    }&#13;
  });&#13;
  return top;&#13;
};&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const top = (heap) =&gt; (isEmpty(heap) ? undefined : heap[_findTop(heap)].key);</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">_findTop()</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span> finds which tree has the greatest root; it just goes through the <span class="SANS_TheSansMonoCd_W5Regular_11">trees</span> array looking for the greatest key. With this method, <span class="SANS_TheSansMonoCd_W5Regular_11">top()</span> is simply a matter of checking whether the heap is empty. If so, return <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span>; otherwise, use <span class="SANS_TheSansMonoCd_W5Regular_11">_findTop()</span> to get the top value of the heap <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-133"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Adding a Value to a Binomial Heap</span></h4>&#13;
<p class="TNI1">When adding a value to a heap, start by creating a binomial tree of order 0 with just the key and add it to the heap; however, this may cause a problem if another binomial tree of the same order already exists. (Remember, trees of repeated orders aren’t allowed.) You can solve it with merging.</p>&#13;
<p class="TX">Assume you have two binomial trees of the same order, as shown in <a href="chapter15.xhtml#fig15-7">Figure 15-7</a>, and want to merge them into one. In general, one of the trees should become a subtree of the other.</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-7" src="../images/Figure15-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-7: Merging two binomial heaps where one becomes a subtree of the other</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This example, however, needs further consideration because you’re not dealing with just any trees; you’re dealing with trees that satisfy the heap condition. So, what do you do in this case? Assume the two trees are as shown in <a href="chapter15.xhtml#fig15-8">Figure 15-8</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_355" aria-label="355"/>&#13;
<figure class="IMG"><img class="img5" id="fig15-8" src="../images/Figure15-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-8: Two binomial heaps to be merged</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The idea is simple. The greater root becomes the new root, and the smaller root becomes its child, as shown in <a href="chapter15.xhtml#fig15-9">Figure 15-9</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-9" src="../images/Figure15-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-9: A way to merge the two trees from <a href="chapter15.xhtml#fig15-8">Figure 15-8</a></span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">But <a href="chapter15.xhtml#fig15-9">Figure 15-9</a> doesn’t show how to actually do it. With the binary representation discussed earlier, both original trees would look like the ones shown in <a href="chapter15.xhtml#fig15-10">Figure 15-10</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-10" src="../images/Figure15-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-10: The actual binary tree representation for the two binomial heaps</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Correspondingly, the result also follows the same scheme of “down to child, right to sibling,” as shown in <a href="chapter15.xhtml#fig15-11">Figure 15-11</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-11" src="../images/Figure15-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-11: The merged binomial trees in binary tree representation</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_356" aria-label="356"/>In this way, you can always merge two BT(<i>k</i>)s into a single BT(<i>k</i> + 1), and thanks to the binary representation, that procedure requires you to change only two links. The code for this is as follows, where <span class="SANS_TheSansMonoCd_W5Regular_11">low</span> is the tree with the smaller root and <span class="SANS_TheSansMonoCd_W5Regular_11">high</span> is the one with the greater root:</p>&#13;
<pre id="pre-293"><code>const _mergeA2B = (low, high) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> low.right = high.down;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> low.up = high;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> high.down = low;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> high.degree++;&#13;
  return high;&#13;
};</code></pre>&#13;
<p class="TX">It’s pretty straightforward. The lower tree will have the higher tree’s children as siblings <span class="CodeAnnotation" aria-label="annotation1">❶</span> and that node as the parent <span class="CodeAnnotation" aria-label="annotation2">❷</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>, making the new root’s degree go up by one <span class="CodeAnnotation" aria-label="annotation4">❹</span>. (You’ll use this operation repeatedly in this chapter.)</p>&#13;
<p class="TX">Now you have the means to merge two trees, but there could be an extra complication. In the example, what would happen if the original heap already had another BT(3)? In that case, you’d keep merging the original BT(3) with the new one to get a BT(4). And, of course, that might lead to a repeated BT(4), and so on. (You’ll look at the complete algorithm in the next section.)</p>&#13;
<p class="TX">Assume for a moment that you already have a method to add a new tree into a heap by merging; then the <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> method is short:</p>&#13;
<pre id="pre-294"><code>const add = (heap, keyToAdd) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const newHeap = newNode(keyToAdd);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> return [merge(heap, [newHeap]), newHeap];&#13;
};</code></pre>&#13;
<p class="TX">You just have to create a new basic BT(0) with the key to be added <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which is an array with a single object in it, and merge it with the heap <span class="CodeAnnotation" aria-label="annotation2">❷</span>. It’s basically the same technique used with skew heaps. The difference is how you go about merging the heaps.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-134"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Merging Two Binomial Heaps</span></h4>&#13;
<p class="TNI1">Consider the problem of merging two heaps in terms of summing binary numbers. If you’re familiar with the 2048 game where you try to merge boxes together to reach 2048, you’ll understand the examples fairly quickly.</p>&#13;
<p class="TX">Start with an easy case. Say you have a binomial heap with 22 elements (22 = 2 + 4 + 16) and want to merge it with another binomial heap of a single element, as when adding a new value, as shown in <a href="chapter15.xhtml#fig15-12">Figure 15-12</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_357" aria-label="357"/>&#13;
<figure class="IMG"><img class="img5" id="fig15-12" src="../images/Figure15-12.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-12: Merging two heaps has a lot to do with binary numbers.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Start at (a)—the heap consists of three binomial trees of sizes 2, 4, and 16 (corresponding to the binary representation of 22)—and represent it with an array, using the trees’ order as an index. The tree with 2 elements is at position 1; the one with 4 is at position 2, and the one with 16 is at position 4, while other positions remain empty (black). Match the tree to be added with the corresponding place in the current heap, and it’s empty, so just move it into place (this is the equivalent of doing 1 + 0 = 1), and you get (b). No more trees remain to be merged, so you’re done.</p>&#13;
<p class="TX">Now consider the harder case of merging two separate heaps with the resulting heap of size 23 (23 = 1 + 2 + 4 + 16) and another heap of size 5 (5 = 1 + 4), as shown in <a href="chapter15.xhtml#fig15-13">Figure 15-13</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-13" src="../images/Figure15-13.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-13: Working through the merging, step by step</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Start at (a), matching 1 and 1: remove the 1 from the top heap and merge it with the 1 at the bottom heap, which becomes a 2. Then you arrive at (b) and match 2 and 2. Again, remove the 2 from the top heap and merge it with the 2 at the bottom, which becomes a 4. In (c), the situation repeats: you again remove from the top and merge at the bottom. (The bottom values are no longer in ascending order—you have an 8 first and a 4 second—but that won’t impact the final result.) At (d), you have an easy case because there is no 8 at the top, so just put the 8 there and remove it from the bottom. At (e), you now have a 4, and it has no match, so place it at the top and remove it from the bottom, getting to (f), where you are finished, since there are no more values to merge.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_358" aria-label="358"/>You have now solved the problem: merging goes on until no trees of duplicate order remain. Implementing the method isn’t complex:</p>&#13;
<pre id="pre-295"><code>const merge = (heap1, heap2) =&gt; {&#13;
  const merged = [];&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> heap1.forEach((v) =&gt; {&#13;
    merged[v.degree] = v;&#13;
  });&#13;
&#13;
  let j = 0;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> while (j &lt; heap2.length) {&#13;
    const i = heap2[j].degree;&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (!(i in merged) || merged[i] === null) {&#13;
      merged[i] = heap2[j];&#13;
      j++;&#13;
    } else {&#13;
      if (goesHigher(heap2[j].key, merged[i].key)) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> heap2[j] = _mergeA2B(merged[i], heap2[j]);&#13;
      } else {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> heap2[j] = _mergeA2B(heap2[j], merged[i]);&#13;
      }&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> merged[i] = null;&#13;
    }&#13;
  }&#13;
&#13;
 <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> return merged.filter(Boolean);&#13;
};</code></pre>&#13;
<p class="TX">First, you place all the binomial trees of the heap in the <span class="SANS_TheSansMonoCd_W5Regular_11">merged</span> array <span class="CodeAnnotation" aria-label="annotation1">❶</span>, setting each tree in its place according to its order. Then, start processing all the trees in the second list <span class="CodeAnnotation" aria-label="annotation2">❷</span>, “adding” them as described. If you don’t have a match in <span class="SANS_TheSansMonoCd_W5Regular_11">merged</span>, just put the new tree in there <span class="CodeAnnotation" aria-label="annotation3">❸</span> and advance to the following tree to merge. Otherwise, when there’s a match, merge both trees. You have one case if the second tree has the greater root <span class="CodeAnnotation" aria-label="annotation4">❹</span> and a different case if the merged tree has it <span class="CodeAnnotation" aria-label="annotation5">❺</span>. In both cases, place the resulting tree in the second array, emptying the place in <span class="SANS_TheSansMonoCd_W5Regular_11">merged</span> <span class="CodeAnnotation" aria-label="annotation6">❻</span>. At the end, after going through all the trees in the second array <span class="CodeAnnotation" aria-label="annotation7">❼</span>, filter out the <span class="SANS_TheSansMonoCd_W5Regular_11">merged</span> array to remove empty trees.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-135"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Removing a Value from a Binomial Heap</span></h4>&#13;
<p class="TNI1">The method to remove the top value from a heap is based on breaking a binomial tree apart by removing its root and then melding the separated trees with the original heap. Assume the heap consists of two binomial trees (sizes 2 and 8) and remove the top value (60), as shown in <a href="chapter15.xhtml#fig15-14">Figure 15-14</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_359" aria-label="359"/>&#13;
<figure class="IMG"><img class="img5" id="fig15-14" src="../images/Figure15-14.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-14: A heap with two binomial trees</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">After removing the top value, separate its subtrees (of sizes 4, 2, and 1), leaving four binomial trees, as shown in <a href="chapter15.xhtml#fig15-15">Figure 15-15</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-15" src="../images/Figure15-15.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-15: After you remove the 60 value, the tree becomes several heaps.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Next, use the same method as before to merge these four trees with an initially empty set of trees. The first step melds together the two 2-sized trees, as shown in <a href="chapter15.xhtml#fig15-16">Figure 15-16</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-16" src="../images/Figure15-16.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-16: The first step of the merge</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Then, as you have two 4-sized (order 2) trees, do another merge, as shown in <a href="chapter15.xhtml#fig15-17">Figure 15-17</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-17" src="../images/Figure15-17.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-17: The second merge finishes the job.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_360" aria-label="360"/>And you’re done! The new binomial heap has one fewer element, and you managed that easily by splitting the tree into subtrees and using the merging code you had already written. The <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span> method is as follows:</p>&#13;
<pre id="pre-296"><code>const remove = (heap) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(heap)) {&#13;
    throw new Error("Empty heap");&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const top = _findTop(heap);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const heapTop = heap[top].key;&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> const newTrees = [];&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> let bt = heap[top].down;&#13;
  while (bt) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> newTrees.push(bt);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> const nextBt = bt.right;&#13;
    bt.right = null;&#13;
    bt.up = null;&#13;
    bt = nextBt;&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> heap.splice(top, 1);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> return [merge(heap, newTrees), heapTop];&#13;
};</code></pre>&#13;
<p class="TX">First, check whether the heap is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then find which tree has the greatest root <span class="CodeAnnotation" aria-label="annotation2">❷</span> and get its value <span class="CodeAnnotation" aria-label="annotation3">❸</span> to return it at the end. Create a <span class="SANS_TheSansMonoCd_W5Regular_11">newTrees</span> array <span class="CodeAnnotation" aria-label="annotation4">❹</span> and set up a loop <span class="CodeAnnotation" aria-label="annotation5">❺</span> to push the tree <span class="CodeAnnotation" aria-label="annotation6">❻</span> and its siblings <span class="CodeAnnotation" aria-label="annotation7">❼</span> there. After splitting the original tree, remove it from the heap <span class="CodeAnnotation" aria-label="annotation8">❽</span> and use the <span class="SANS_TheSansMonoCd_W5Regular_11">merge()</span> function <span class="CodeAnnotation" aria-label="annotation9">❾</span> to merge the new trees into the rest of the original heap.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-136"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Changing a Value in a Binomial Heap</span></h4>&#13;
<p class="TNI1">Some graph-oriented algorithms often need to change a value already in a heap. In such cases, the heap typically includes full records instead of just a priority and keeps an external reference to the heap node that includes the record. (We’ll look at such graph algorithms in <span class="Xref"><a href="chapter17.xhtml">Chapter 17</a></span>.) We won’t go into all of that here, but the logic remains the same.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The most common case is working with min heaps and decreasing a priority with a</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">decreaseKey()</span> <i>method. If you want to work with a min heap, all you need to do is change the direction of the comparison in the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">goesHigher()</span> <i>function described earlier in this chapter.</i></p>&#13;
<p class="TX">We’ve already discussed how to change a value in binary heaps: after effecting the change, it’s simply a matter of bubbling it up or sinking it down, depending on the relationship with other values. In this chapter, we’ll consider only the logic to bubble up a key, moving toward the top of the heap, since that’s the case actually needed in practice. In <a href="chapter15.xhtml#fig15-18">Figure 15-18</a>, say you want to change the 4 key to 50.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_361" aria-label="361"/>&#13;
<figure class="IMG"><img class="img7" id="fig15-18" src="../images/Figure15-18.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-18: A key-changing example, step by step</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Change the key and compare it to the parent, unless you already are at the root, which means you’re finished. If you’re not at the root, if the changed key is smaller, you’re done; otherwise, you have to swap nodes and keep bubbling up. Starting at (a), change the 4 key to a 50 in (b). Now compare 50 with 22 and exchange the nodes (actually, it’s the pointers that are exchanged) getting to (c). A new comparison, 50 and 40, requires yet another exchange as in (d), but now 50 is smaller than its parent (60), so you’re done.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The need for a value to bubble up is the only reason we include an</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">up</span> <i>pointer in the tree’s nodes. If you don’t plan to provide the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">changeKey()</span> <i>method, you can remove all instances of</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">up</span> <i>in the code.</i></p>&#13;
<p class="TX">Here’s the implementation for this method:</p>&#13;
<pre id="pre-297"><code>const changeKey = (heap, node, newKey) =&gt; {&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(heap)) {&#13;
    throw new Error("Heap is empty!");&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span>} else if (!goesHigher(newKey, node.key)) {&#13;
    throw new Error("New value should go higher than old value");&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> node.key = newKey;  &#13;
    _bubbleUp(heap, node);&#13;
    return heap;&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">First check whether the operation is possible: the heap shouldn’t be empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and the new key should go higher in the heap <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If everything’s okay, change the node’s key to the new value and call <span class="SANS_TheSansMonoCd_W5Regular_11">_bubbleUp()</span> to make it climb up the heap <span class="CodeAnnotation" aria-label="annotation3">❸</span> if that’s needed.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_362" aria-label="362"/>The code for bubbling up is as follows, and it has the longest line of code in this entire book:</p>&#13;
<pre id="pre-298"><code>const _bubbleUp = (heap, node) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (node.up &amp;&amp; goesHigher(node.key, node.up.key)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const parent = node.up;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> [&#13;
      node.up,&#13;
      node.down,&#13;
      node.right,&#13;
      node.degree,&#13;
      parent.up,&#13;
      parent.down,&#13;
      parent.right,&#13;
      parent.degree&#13;
    ] = [&#13;
      parent.up,&#13;
      parent,&#13;
      parent.right,&#13;
      parent.degree,&#13;
      node,&#13;
      node.down,&#13;
      node.right,&#13;
      node.degree&#13;
    ];&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if (node.up) {&#13;
      _bubbleUp(heap, node);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span>} else {&#13;
      const i = heap.findIndex((v) =&gt; v === parent);&#13;
      heap[i] = node;&#13;
    }&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">First see whether any bubbling up is needed. If the node doesn’t have a parent, or if it has one but the parent’s key is higher than the node’s key, nothing’s required <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If you need to swap the node up, get a pointer to its parent <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and make all the pointer (and degree) changes we saw previously (it’s quite a long line <span class="CodeAnnotation" aria-label="annotation3">❸</span> but straightforward in concept). Finally, if the node again has a parent, use recursion to check whether it still has to bubble up more <span class="CodeAnnotation" aria-label="annotation4">❹</span>. If the node doesn’t have a parent <span class="CodeAnnotation" aria-label="annotation5">❺</span> (meaning it got to the top of its heap), you need to fix the reference in the array of heaps, so instead of pointing to the old node’s parent, now it points to the new top. (Couldn’t we just have exchanged keys between the node and its parent, as with binary heaps? The answer is important; see question 15.7 for more on this.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h2-137"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Considering Performance for Binomial Heaps</span></h4>&#13;
<p class="TNI1"><a href="chapter15.xhtml#tab15-3">Table 15-3</a> summarizes the binomial heaps’ performance; results with an asterisk are amortized.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab15-3"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_363" aria-label="363"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 15-3:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Binomial Heaps</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Performance</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)*</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Top</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">) as seen;</span> <span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1) with a fix</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Change</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Merge</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Given that a binomial heap may consist of up to log <i>n</i> heaps, getting the top is <i>O</i>(log <i>n</i>). If you only did additions but no removals, the amortized order of adding a new value would be <i>O</i>(1)—see question 15.5 for more on this—but we can prove that sequences of operations worsen this result to <i>O</i>(log <i>n</i>). Getting the top value, as implemented previously, means looking through log <i>n</i> heaps, but that can be enhanced to <i>O</i>(1); see question 15.6. As for the other results, removing the top value means separating a heap into, at most, log <i>n</i> subtrees, doing an <i>O</i>(log <i>n</i>) procedure, followed by merging, which is another <i>O</i>(log <i>n</i>) procedure, so that’s the total order for the operation.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h3 class="H1" id="sec16"><span id="h1-78"/><span class="SANS_Futura_Std_Bold_B_11">Lazy Binomial Heaps</span></h3>&#13;
<p class="TNI1">Binomial heaps have a potential performance problem when adding values, when you go from <i>O</i>(1) to <i>O</i>(log <i>n</i>), which means you can think in amortized terms to find a solution that enhances this procedure at the possible risk of (not too often) costlier fixes. <i>Lazy binomial heaps</i> do exactly that.</p>&#13;
<p class="TX">With lazy binomial heaps, when you do additions, you don’t care about merging. You just let the heap have more and more trees, so <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> is a trivial operation, running in <i>O</i>(1). Take care, however, to keep track of the greatest value, so <span class="SANS_TheSansMonoCd_W5Regular_11">top()</span> is also <i>O</i>(1). You can fix the structure when you try to <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span> a value, except then you process the heap to bring it back into binomial heap shape.</p>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h2-138"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Defining Lazy Binomial Heaps</span></h4>&#13;
<p class="TNI1">Lazy binomial heaps are binomial heaps after all, although you add an extra <span class="SANS_TheSansMonoCd_W5Regular_11">top</span> property to keep track of the top value in the heap. The class definition then is quite short, as most of the methods are shared with binomial heaps:</p>&#13;
<pre id="pre-299"><code>const goesHigher = (a, b) =&gt; a &gt; b;&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const newLazyBinomialHeap = () =&gt; ({&#13;
<b>  top: undefined,</b>&#13;
<b>  trees: []</b>&#13;
});&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_364" aria-label="364"/>const newNode = (key) =&gt; ({&#13;
  key,&#13;
  right: null,&#13;
  down: null,&#13;
  up: null,&#13;
  degree: 0&#13;
});&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const isEmpty = (heap) =&gt; <b>heap.trees.length</b> === 0;&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> const top = (heap) =&gt; (isEmpty(heap) ? undefined : heap.top);</code></pre>&#13;
<p class="TX">So far, there are only two differences. A heap is now a record with two fields: <span class="SANS_TheSansMonoCd_W5Regular_11">top</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which will have the top value of the heap, and the <span class="SANS_TheSansMonoCd_W5Regular_11">trees</span> array, which are the individual heaps. An empty heap has no trees <span class="CodeAnnotation" aria-label="annotation2">❷</span>, so use that for detection. You need to update <span class="SANS_TheSansMonoCd_W5Regular_11">top</span> when adding to or removing from the heap. The <span class="SANS_TheSansMonoCd_W5Regular_11">top()</span> method <span class="CodeAnnotation" aria-label="annotation3">❸</span> is quite short: if the heap is empty, return undefined; otherwise, return the value of <span class="SANS_TheSansMonoCd_W5Regular_11">heap.top</span>. With this implementation, you don’t need to go through the whole <span class="SANS_TheSansMonoCd_W5Regular_11">trees</span> array to find the top, which provides enhanced performance, although later <span class="SANS_TheSansMonoCd_W5Regular_11">heap.top</span> will need some extra maintenance work.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2" id="sec18"><span id="h2-139"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Adding a Value to a Lazy Binomial Heap</span></h4>&#13;
<p class="TNI1">The first important difference with lazy binomial heaps is that you won’t do any merging when adding a new key. How is this possible? First, if you want to know the top of the heap, you can do that without any structure. The <span class="SANS_TheSansMonoCd_W5Regular_11">heap.top</span> attribute described earlier can be updated easily. As long as you keep adding, the heap just grows a tree at a time, and you’ll always know the top of the heap. For example, assume that a binomial heap had the structure shown in <a href="chapter15.xhtml#fig15-19">Figure 15-19</a> at a certain moment; the triangle points to the maximum of the heap at that time.</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-19" src="../images/Figure15-19.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-19: Tracking the top value just needs a simple property.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you add three new values, the process is quite fast, as the only thing you do is add new trees. The diagram in <a href="chapter15.xhtml#fig15-20">Figure 15-20</a> with several binomial trees of the same order, which wouldn’t be allowed in binomial heaps, shows this. Again, after each addition, update the maximum. In this <span role="doc-pagebreak" epub:type="pagebreak" id="pg_365" aria-label="365"/>example, one of the newly added keys was greater than the previous maximum, so you now have a different top of the heap.</p>&#13;
<figure class="IMG"><img class="img7" id="fig15-20" src="../images/Figure15-20.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-20: After you add values, the property needs adjustment.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">But removing the heap’s top is a different scenario, because then finding the new <span class="SANS_TheSansMonoCd_W5Regular_11">_heapTop</span> is too slow: <i>O</i>(<i>n</i>). You can restructure the heap by merging trees together only when removing a key. Some math (which we’ll skip) shows that the amortized performance remains quite good.</p>&#13;
<p class="TX">The code for adding a value is similar to what you saw before, but instead of merging a new tree, you just add it with no further process:</p>&#13;
<pre id="pre-300"><code>const add = (heap, keyToAdd) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const newHeap = newNode(keyToAdd);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> heap.trees.push(newHeap);&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (heap.top === undefined || goesHigher(keyToAdd, heap.top)) {&#13;
    heap.top = keyToAdd;&#13;
  }&#13;
&#13;
  return [heap, newHeap];&#13;
};</code></pre>&#13;
<p class="TX">First, create a new binomial tree with the new key <span class="CodeAnnotation" aria-label="annotation1">❶</span> and push it to the end of the current <span class="SANS_TheSansMonoCd_W5Regular_11">trees</span> array <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The only extra step is possibly updating the heap’s top. If the array of trees is empty or if the current top is not greater than the newly added value <span class="CodeAnnotation" aria-label="annotation3">❸</span>, reset <span class="SANS_TheSansMonoCd_W5Regular_11">heap.top</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2" id="sec19"><span id="h2-140"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Removing a Value from a Lazy Binomial Heap</span></h4>&#13;
<p class="TNI1">As mentioned previously, the idea with lazy binomial heaps is to delay merging trees as long as possible (thus, the term <i>lazy</i>). When you remove a key, first merge together all the current binomial trees to get a binomial heap and then proceed with the removal.</p>&#13;
<p class="TX">You do this because although the number of trees in the heap grows slowly when adding values and eventually becomes high, it drops sharply after merging, and the balance between many fast operations and an eventual slow one ends with a nice amortized cost.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_366" aria-label="366"/>The code is as follows; notice it has a few changes and additions in comparison to the original binomial heaps:</p>&#13;
<pre id="pre-301"><code>const remove = (heap) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(heap)) {&#13;
    throw new Error("Empty heap");&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const heapTop = heap.top;&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const top = _findTop(heap.trees);&#13;
  let bt = heap.trees[top].down;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> while (bt) {&#13;
    heap.trees.push(bt);&#13;
    const nextBt = bt.right;&#13;
    bt.right = null;&#13;
    bt.up = null;&#13;
    bt = nextBt;&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> heap.trees.splice(top, 1);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> const newHeap = merge(newLazyBinomialHeap(), {&#13;
    top: undefined,&#13;
    trees: heap.trees&#13;
  });&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> newHeap.top =&#13;
    newHeap.trees.length === 0&#13;
      ? undefined&#13;
      : newHeap.trees[_findTop(newHeap.trees)].key;&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> return [newHeap, heapTop];&#13;
};</code></pre>&#13;
<p class="TX">First check whether the heap is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span> and save the current top of the heap <span class="CodeAnnotation" aria-label="annotation2">❷</span> to return its value later <span class="CodeAnnotation" aria-label="annotation8">❽</span>. Then find which tree had the top <span class="CodeAnnotation" aria-label="annotation3">❸</span> and do a loop to split its subtrees <span class="CodeAnnotation" aria-label="annotation4">❹</span>, which you then add to the list of trees. Then remove the split tree <span class="CodeAnnotation" aria-label="annotation5">❺</span>, merge all trees together <span class="CodeAnnotation" aria-label="annotation6">❻</span>, and update <span class="SANS_TheSansMonoCd_W5Regular_11">heap.top</span> <span class="CodeAnnotation" aria-label="annotation7">❼</span> to find the new current top. It’s not very different from binomial heaps. The way you merge all trees together is pretty neat: by merging an empty heap with the list of trees, you trigger all the necessary merges that will reduce the number of trees. Can you see how it works?</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2" id="sec20"><span id="h2-141"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Changing a Value in a Lazy Binomial Heap</span></h4>&#13;
<p class="TNI1">There is one final method: how to change any key. Here’s the code:</p>&#13;
<pre id="pre-302"><code>const changeKey = (heap, node, newKey) =&gt; {&#13;
  if (isEmpty(heap)) {&#13;
    throw new Error("Heap is empty!");&#13;
  } else if (!goesHigher(newKey, node.key)) {&#13;
    throw new Error("New value should go higher than old value");&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_367" aria-label="367"/>  } else {&#13;
    node.key = newKey;&#13;
    _bubbleUp(heap, node);&#13;
&#13;
    <b>heap.top =</b>&#13;
<b>      heap.trees.length === 0</b>&#13;
<b>        ? undefined</b>&#13;
<b>        : heap.trees[_findTop(heap.trees)].key;</b>&#13;
&#13;
    return heap;&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">This code is the same as for binomial heaps, with the addition of the single line to update <span class="SANS_TheSansMonoCd_W5Regular_11">heap.top</span>; you did a similar calculation in <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span>. The code for <span class="SANS_TheSansMonoCd_W5Regular_11">_bubbleUp()</span> is unchanged, so it’s not repeated here.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2" id="sec21"><span id="h2-142"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Considering Performance for Lazy Binomial Heaps</span></h4>&#13;
<p class="TNI1">The performance of lazy binomial heaps is similar to that of binomial heaps, but postponing merges has a positive effect in amortized terms. In particular, adding a value is logically faster, since you don’t do practically anything, as <a href="chapter15.xhtml#tab15-4">Table 15-4</a> shows. Remember, asterisks denote amortized results.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab15-4"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 15-4:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Lazy Binomial Heaps</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Performance</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Top</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)*</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Change</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)*</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Merge</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)*</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">You now have very good performance (in particular, adding a new value is faster), but you’ll want a better result when changing a value. Let’s look at another variant of binomial heaps that allows this enhancement.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h3 class="H1" id="sec22"><span id="h1-79"/><span class="SANS_Futura_Std_Bold_B_11">Fibonacci Heaps</span></h3>&#13;
<p class="TNI1">Some graph algorithms use min heaps and frequently call the <span class="SANS_TheSansMonoCd_W5Regular_11">decreaseKey()</span> operation, which we renamed to <span class="SANS_TheSansMonoCd_W5Regular_11">changeKey()</span> to allow for max heaps and min heaps. In that situation, being able to decrease keys in a quicker fashion than the <i>O</i>(log <i>n</i>) performance for lazy binomial heaps becomes important. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_368" aria-label="368"/>Enter <i>Fibonacci heaps</i>, which are quite similar to lazy binomial heaps but allow a faster algorithm to change a key.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Michael Fredman and Robert Tarjan described Fibonacci heaps in their paper “Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms” (network refers to graphs in this title), but Tarjan later suggested an alternative simpler structure called pairing heaps, which we’ll study later.</i></p>&#13;
<p class="TX">What’s the idea behind Fibonacci heaps? The <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span> methods work the same way as with lazy binomial heaps, but the difference appears when changing a key. If a key is changed and has to bubble up (in a max heap, this would happen if the new value was greater than before; in a min heap, if smaller), you obviously might need to bubble it up even to the root of its tree—that’s <i>O</i>(log <i>n</i>).</p>&#13;
<p class="TX">Instead of doing any bubbling, just separate that node with its subtree and add it as a new tree to the heap—that’s <i>O</i>(1). However, since this process alters the expected shape of the binomial trees and doing it too often could lead to badly structured heaps, there’s a compromise. You won’t allow non-root nodes to lose more than one child in the described fashion. Should a node lose a second node (and you’ll know it because every time a node loses a child, the node will be marked), you’ll also separate it, which itself may lead to further separations. And, as with lazy binomial heaps, you’ll patch things up when a removal is done; you will see all of this later, but first consider how to represent the new heaps.</p>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h4 class="H2" id="sec23"><span id="h2-143"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Representing a Fibonacci Heap</span></h4>&#13;
<p class="TNI1">The structure used earlier—an array of trees where each tree is represented with <span class="SANS_TheSansMonoCd_W5Regular_11">up</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">right</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">down</span> links plus a <span class="SANS_TheSansMonoCd_W5Regular_11">degree</span> field with the number of children—works, but that’s not efficient enough for the operation needed here. When changing a key and it bubbles up, the idea is to remove the corresponding node and its subtree, but can you quickly unlink it from its siblings? If you keep the siblings in a singly linked list, that procedure requires traversing a list with a size of up to <i>O</i>(log <i>n</i>), which will spoil the <i>O</i>(1) goal. So, in the same way as shown in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, use a doubly linked list here. But there’s more! When merging trees, you want to merge two lists of siblings, so make the lists circular, and that will complete the solution.</p>&#13;
<p class="TX"><a href="chapter15.xhtml#fig15-21">Figure 15-21</a> shows a small BT(3) and how it would look with all the added links in a Fibonacci heap.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_369" aria-label="369"/>&#13;
<figure class="IMG"><img class="img7" id="fig15-21" src="../images/Figure15-21.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-21: A binomial tree represented in Fibonacci heap style</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Showing all the up and down and left and right links makes for a cluttered diagram, so from now on, we’ll remove any unnecessary links. For instance, the up links to parents will be removed, as you can deduce those from the diagrams. We’ll also omit arrowheads and circular links for single node lists for clarity, but we’ll point out when we make those alterations.</p>&#13;
<p class="TX">To sum up the changes, we add a <span class="SANS_TheSansMonoCd_W5Regular_11">left</span> link to the nodes (so we can build the circular doubly linked list) and a <span class="SANS_TheSansMonoCd_W5Regular_11">marked</span> boolean field, which we’ll use to mark a node that has lost a child:</p>&#13;
<pre id="pre-303"><code>const goesHigher = (a, b) =&gt; a &gt; b;&#13;
&#13;
const newFibonacciHeap = () =&gt; ({&#13;
  top: undefined,&#13;
  trees: []&#13;
});&#13;
&#13;
const newNode = (key) =&gt; ({&#13;
  key,&#13;
  degree: 0,&#13;
<b>  marked: false,</b>&#13;
  <b>left: null</b>,&#13;
  right: null,&#13;
  down: null,&#13;
  up: null&#13;
});&#13;
&#13;
const isEmpty = (heap) =&gt; heap.trees.length === 0;&#13;
&#13;
const top = (heap) =&gt; (isEmpty(heap) ? undefined : heap.top);</code></pre>&#13;
<p class="TX">The single change is the addition of the <b>marked</b> and <b>left</b> fields; the rest is the same as it was for lazy binomial heaps.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_370" aria-label="370"/>&#13;
<h4 class="H2" id="sec24"><span id="h2-144"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Merging Two Fibonacci Trees</span></h4>&#13;
<p class="TNI1">When we first looked at how to merge binomial trees, the procedure was relatively simple. Now that siblings are in a circular doubly linked list, however, you’ll need to make some changes. Say you want to merge the trees shown in <a href="chapter15.xhtml#fig15-22">Figure 15-22</a> (remember, details for subtrees that won’t be affected by the changes, as well as arrowheads and up links, are hidden).</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-22" src="../images/Figure15-22.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-22: Two Fibonacci trees to be merged</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">After merging the trees together, you get the result shown in <a href="chapter15.xhtml#fig15-23">Figure 15-23</a>. Pay particular attention to the changed links; arrowheads are included only for those.</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-23" src="../images/Figure15-23.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-23: The result of merging the trees; only a few pointers needed to change.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Here’s the new merging code:</p>&#13;
<pre id="pre-304"><code>mergeA2B(low, high) {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (high.down) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> low.right = high.down;&#13;
    low.left = high.down.left;&#13;
    high.down.left.right = low;&#13;
    high.down.left = low;&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> high.down = low;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> low.up = high;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> high.degree++;&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> return high;&#13;
}</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_371" aria-label="371"/>If the tree with the higher key has no children, the logic is simple, because you just need to set the lower tree as its child <span class="CodeAnnotation" aria-label="annotation3">❸</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. However, if it does have children <span class="CodeAnnotation" aria-label="annotation1">❶</span>, you need to add the lower tree’s root as a new sibling to the higher tree’s root’s children <span class="CodeAnnotation" aria-label="annotation2">❷</span>. (Notice the four link changes.) After that, make the higher root point to the lower root <span class="CodeAnnotation" aria-label="annotation3">❸</span> and vice versa <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Then increment the higher root’s degree by 1 <span class="CodeAnnotation" aria-label="annotation5">❺</span> since it gained a new child and return the merged tree <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h4 class="H2" id="sec25"><span id="h2-145"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Adding a Value to a Fibonacci Heap</span></h4>&#13;
<p class="TNI1">Adding a new value to the Fibonacci heap isn’t very different from lazy binomial heaps. The only change is you need to set up the circular list of siblings (initially with just the node itself) for future merging operations. The following code highlights the needed changes:</p>&#13;
<pre id="pre-305"><code>const add = (heap, keyToAdd) =&gt; {&#13;
  const newHeap = newNode(keyToAdd);&#13;
  &#13;
<b>  newHeap.left = newHeap;</b>&#13;
<b>  newHeap.right = newHeap;</b>&#13;
&#13;
  heap.trees.push(newHeap);&#13;
&#13;
  if (heap.top === undefined || goesHigher(keyToAdd, heap.top)) {&#13;
    heap.top = keyToAdd;&#13;
  }&#13;
&#13;
  return [heap, newHeap];&#13;
};</code></pre>&#13;
<p class="TX">Initialize the left and right pointers of the new node appropriately, so they form a single-node circular list. (Yes, you could write the two lines as a single assignment; see question 15.9.) The new tree will have <span class="SANS_TheSansMonoCd_W5Regular_11">marked</span> set to <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>, because the node hasn’t yet lost any children. To check this, see the <span class="SANS_TheSansMonoCd_W5Regular_11">newNode()</span> code, in the section “<span class="Xref">Representing a Fibonacci Heap</span>” on page <span class="Xref">368</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h4 class="H2" id="sec26"><span id="h2-146"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Removing a Value from a Fibonacci Heap</span></h4>&#13;
<p class="TNI1">The logic for removing a value is essentially the same as for other binomial heaps, with minor changes. Removing the top of the heap also works the same as with lazy binomial trees, except beware of infinite loops when traversing the circular list of siblings, for example. The new lines are highlighted:</p>&#13;
<pre id="pre-306"><code>const remove = (heap) =&gt; {&#13;
  if (isEmpty(heap)) {&#13;
    throw new Error("Empty heap");&#13;
  }&#13;
&#13;
  const heapTop = heap.top;&#13;
&#13;
  const top = _findTop(heap.trees);&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_372" aria-label="372"/>  let bt = heap.trees[top].down;&#13;
&#13;
<b>  if (bt &amp;&amp; bt.left) {</b>&#13;
<b>   </b><span class="Code_CodeAnnotation" aria-label="annotation1">❶</span><b> bt.left.right = null;</b>&#13;
<b>  }</b>&#13;
&#13;
  while (bt) {&#13;
    heap.trees.push(bt);&#13;
    const nextBt = bt.right;&#13;
<b>  </b><span class="Code_CodeAnnotation" aria-label="annotation2">❷</span><b> bt.right = bt;</b>&#13;
<b>    bt.left = bt;</b>&#13;
    bt.up = null;&#13;
    bt = nextBt;&#13;
  }&#13;
&#13;
  heap.trees.splice(top, 1);&#13;
  const newHeap = merge(newFibonacciHeap(), {&#13;
    top: undefined,&#13;
    trees: heap.trees&#13;
  });&#13;
&#13;
  newHeap.top =&#13;
    newHeap.trees.length === 0&#13;
      ? undefined&#13;
      : newHeap.trees[_findTop(newHeap.trees)].key;&#13;
&#13;
  return [newHeap, heapTop];&#13;
};</code></pre>&#13;
<p class="TX">To avoid infinite loops, set the rightmost link of the list to <span class="SANS_TheSansMonoCd_W5Regular_11">null</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span> to ensure that the following loop will stop. (Here, <span class="SANS_TheSansMonoCd_W5Regular_11">bt</span> points to an element in the circular list. Traverse this list to the right, so <span class="SANS_TheSansMonoCd_W5Regular_11">bt.left</span> points to what should be the last element to visit. If you clear the right link of <span class="SANS_TheSansMonoCd_W5Regular_11">bt.left</span>, this ensures that the loop will stop.) The other difference is when you extract a sibling, the root must be a circular link by itself <span class="CodeAnnotation" aria-label="annotation2">❷</span>, so you have to fix its <span class="SANS_TheSansMonoCd_W5Regular_11">left</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">right</span> links.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h4 class="H2" id="sec27"><span id="h2-147"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Changing a Value in a Fibonacci Heap</span></h4>&#13;
<p class="TNI1">How a key change is handled is what sets Fibonacci heaps apart from the other types of heaps. Instead of bubbling up, you directly separate that key from the heap. The code is similar to what you saw before, but it has one significant change (in bold):</p>&#13;
<pre id="pre-307"><code>const changeKey = (heap, node, newKey) =&gt; {&#13;
  if (isEmpty(heap)) {&#13;
    throw new Error("Heap is empty!");&#13;
  } else if (!goesHigher(newKey, node.key)) {&#13;
    throw new Error("New value should go higher than old value");&#13;
  } else {&#13;
    node.key = newKey;&#13;
<b>    _separate(heap, node);</b>&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_373" aria-label="373"/>When you actually change the node’s key, you <i>separate</i> it from the heap instead of bubbling up. To illustrate, consider the heap shown in <a href="chapter15.xhtml#fig15-24">Figure 15-24</a> from earlier in the chapter.</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-24" src="../images/Figure15-24.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-24: The previous Fibonacci heap</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Suppose the 9 key is changing to 99, as shown in <a href="chapter15.xhtml#fig15-25">Figure 15-25</a>. Since it would be bubbling up, just remove it from the heap and mark its parent (80).</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-25" src="../images/Figure15-25.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-25: The Fibonacci heap after changing a key from 9 to 99</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The only thing you had to do is unlink the 9 (now 99) from its siblings. If you now want to change the 60 to 66, you also need to change 80’s down pointer. You can make it point to 60’s right sibling, as shown in <a href="chapter15.xhtml#fig15-26">Figure 15-26</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-26" src="../images/Figure15-26.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-26: Another change in the tree, and 60 becomes 66.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_374" aria-label="374"/>Now you need to do an extra step. After this separation, if 80 isn’t the root, since it was already marked (meaning it had already lost one child), you’d also have to separate it, applying exactly the same logic as earlier. The code looks like this:</p>&#13;
<pre id="pre-308"><code>const _separate = (heap, node) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> node._marked = false;&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const parent = node.up;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (parent) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if (node.right === node) {&#13;
      parent.down = null;&#13;
    } else {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> if (parent.down === node) {&#13;
        parent.down = node.right;&#13;
      }&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> node.left.right = node.right;&#13;
      node.right.left = node.left;&#13;
    }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> parent.degree--;&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> node.up = null;&#13;
    node.left = node;&#13;
    node.right = node;&#13;
    heap.trees.push(node);&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> if (parent._marked) {&#13;
      _separate(heap, parent);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation10">❿</span>} else {  &#13;
      parent._marked = true;&#13;
    }&#13;
  }&#13;
&#13;
  if (goesHigher(node.key, heap.top)) {&#13;
    heap.top = node.key;&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">Start by unmarking the node to be separated <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This is the <i>only</i> way a node can become unmarked again. You then get the parent of the node <span class="CodeAnnotation" aria-label="annotation2">❷</span>, but if it has none (meaning the node is a root), don’t do anything. Otherwise, if the node has a parent <span class="CodeAnnotation" aria-label="annotation3">❸</span>, start unlinking. If the changing node has no siblings <span class="CodeAnnotation" aria-label="annotation4">❹</span>, just set the parent’s down link to null, and you’re done. But if instead the parent is pointing down directly to the node you are changing <span class="CodeAnnotation" aria-label="annotation5">❺</span>, you must change the link to a sibling, so you don’t break the structure when removing the changing node. Now that you are sure the parent is pointing to a different sibling, you can easily unlink the node from the doubly linked list <span class="CodeAnnotation" aria-label="annotation6">❻</span>. Then you need to reduce the parent’s degree by one <span class="CodeAnnotation" aria-label="annotation7">❼</span>, since it will be losing a child, and push the separated subtree after fixing its links <span class="CodeAnnotation" aria-label="annotation8">❽</span>. The last check is if you are removing a child from a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_375" aria-label="375"/>node that was marked (meaning it had already lost another child), recursively separate it <span class="CodeAnnotation" aria-label="annotation9">❾</span>; otherwise, just mark it <span class="CodeAnnotation" aria-label="annotation10">❿</span>, and you’re finished.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h4 class="H2" id="sec28"><span id="h2-148"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Considering Performance for Fibonacci Heaps</span></h4>&#13;
<p class="TNI1">Binomial heaps are formed of binomial trees, and each tree has a number of nodes that is a power of 2. Before any changes (which start pruning the trees), a Fibonacci heap has same-sized trees, but how low can they go? <a href="chapter15.xhtml#fig15-27">Figure 15-27</a> shows a Fibonacci heap with as many nodes removed as possible; the white nodes were removed, and black nodes are left.</p>&#13;
<figure class="IMG"><img class="img1" id="fig15-27" src="../images/Figure15-27.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-27: Fibonacci trees with a minimum number of nodes</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">How do you remove as many nodes as possible from a tree without causing any cascading? Or, how do you build the next tree, out of the previous ones, all pruned as much as possible? The worst you can do is promote the largest subtree of every node. In that case, the individual trees would at least have 1, 1, 2, 3, 5, 8, . . . nodes. Recognize the sequence? The trees in this scheme would have at least as many nodes as a Fibonacci number (instead of a power of 2). This also helps because Fibonacci numbers are exponential in nature, implying that the algorithms’ performance will still be logarithmic.</p>&#13;
<p class="TX"><a href="chapter15.xhtml#tab15-5">Table 15-5</a> summarizes the performance of Fibonacci heaps; the values with an asterisk are amortized.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab15-5"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_376" aria-label="376"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 15-5:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Fibonacci Heaps</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Performance</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Top</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)*</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Change</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)*</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Merge</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">You can’t do better than <i>O</i>(1) for insertions, but removals possibly could be better than <i>O</i>(log <i>n</i>). However, in that case, you could sort a set of <i>n</i> values in <i>O</i>(<i>n</i>) time by inserting all of them into the heap and then removing them in order, but you already know you can’t have a sorting algorithm that depends on key-to-key comparisons run with a faster time than <i>O</i>(<i>n</i> log <i>n</i>), so you can’t do removals with better speed.</p>&#13;
<p class="TX">What you can do is use a simpler structure, with less complex algorithms. The last type of extended heap we’ll consider in this chapter, the pairing heap, does exactly that.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h3 class="H1" id="sec29"><span id="h1-80"/><span class="SANS_Futura_Std_Bold_B_11">Pairing Heaps</span></h3>&#13;
<p class="TNI1">A <i>pairing heap</i> is a multiary data structure that satisfies the heap property. It basically consists of a root that has the top value of the heap and an ordered set of heaps, so you could call it an orchard in terms of the definitions from <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>. In more formal terms, you could say that a pairing heap is either an empty structure or a root element plus a (possibly empty) list of pairing heaps. Each individual heap is represented in the “left child, right sibling” style; <a href="chapter15.xhtml#fig15-28">Figure 15-28</a> shows an example of a pairing heap.</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-28" src="../images/Figure15-28.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-28: A sample pairing heap</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The root is 60 and has three subheaps with keys 22, 56, and 12. The subheaps have 3, 5, and 2 elements, respectively.</p>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_377" aria-label="377"/>&#13;
<h4 class="H2" id="sec30"><span id="h2-149"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Defining a Pairing Heap</span></h4>&#13;
<p class="TNI1">We won’t consider the <span class="SANS_TheSansMonoCd_W5Regular_11">changeKey()</span> operation (but see question 15.4), so the representation is a tad simpler. Here’s the basic starting code for a pairing heap:</p>&#13;
<pre id="pre-309"><code>const goesHigher = (a, b) =&gt; a &gt; b;&#13;
&#13;
const newPairingHeap = () =&gt; null;&#13;
&#13;
const newNode = (key, down = null, right = null) =&gt; ({key, down, right});&#13;
&#13;
const isEmpty = (heap) =&gt; heap === null || heap.key === undefined;&#13;
&#13;
const top = (heap) =&gt; (isEmpty(heap) ? undefined : heap.key);</code></pre>&#13;
<p class="TX">It’s the same code as for skew heaps, except the left pointer is named <span class="SANS_TheSansMonoCd_W5Regular_11">down</span> and a small change was made in <span class="SANS_TheSansMonoCd_W5Regular_11">isEmpty()</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h4 class="H2" id="sec31"><span id="h2-150"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Melding Two Pairing Heaps</span></h4>&#13;
<p class="TNI1">How do we meld two heaps? If one of the two heaps is empty, just return the other one. Otherwise, if neither heap is empty, the heap with the greatest key will have the other heap added (melded) to its list of subtrees. For instance, see what happens if you want meld the first two subheaps in <a href="chapter15.xhtml#fig15-29">Figure 15-29</a> (this is an important example, and you’ll return to it later).</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-29" src="../images/Figure15-29.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-29: Two pairing heaps to be merged</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The new root should be 56, so the first heap (the one with root 22) becomes a child of the second heap, producing the configuration shown in <a href="chapter15.xhtml#fig15-30">Figure 15-30</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-30" src="../images/Figure15-30.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-30: The result of merging</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_378" aria-label="378"/>You can implement this easily:</p>&#13;
<pre id="pre-310"><code>const merge = (heap1, heap2) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(heap2)) {&#13;
   return heap1;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else if (isEmpty(heap1)) {&#13;
   return heap2;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else if (goesHigher(heap1.key, heap2.key)) {&#13;
   [heap2.right, heap1.down] = [heap1.down, heap2];&#13;
   return heap1;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span>} else {&#13;
   [heap1.right, heap2.down] = [heap2.down, heap1];&#13;
   return heap2;&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">If one heap is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, the result of the merge is just the other tree. Otherwise, if the first heap has the highest key <span class="CodeAnnotation" aria-label="annotation3">❸</span>, make the second heap its child. The last case is the same <span class="CodeAnnotation" aria-label="annotation4">❹</span> but in reverse, making the first heap a child of the second.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
&#13;
<h4 class="H2" id="sec32"><span id="h2-151"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Adding a Value to a Pairing Heap</span></h4>&#13;
<p class="TNI1">Adding a new value to the heap is done with the same method as for skew heaps. Create a new heap with only the new value in it and merge it with the current heap. You’ve already seen how merging works. The code is almost a one-liner:</p>&#13;
<pre id="pre-311"><code>const add = (heap, keyToAdd) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const newHeap = newNode(keyToAdd);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> return [merge(heap, newHeap), newHeap];&#13;
};</code></pre>&#13;
<p class="TX">It creates a new heap <span class="CodeAnnotation" aria-label="annotation1">❶</span> with a single value in it and merges it with the current heap <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h4 class="H2" id="sec33"><span id="h2-152"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Removing the Top Value from a Pairing Heap</span></h4>&#13;
<p class="TNI1">Removing the top value from the heap is harder than adding a new value, and it requires a lot of melding. Basically, you want to remove the heap’s root and produce a list of subheaps, which you’ll meld in pairs from left to right and then meld the resulting list of heaps from right to left.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The name pairing heaps comes from the procedure described previously where many heaps are always merged in pairs, two by two.</i></p>&#13;
<p class="TX">First, take a look at how to meld several heaps together. <a href="chapter15.xhtml#fig15-31">Figure 15-31</a> shows an example for seven heaps A through G.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_379" aria-label="379"/>&#13;
<figure class="IMG"><img class="img7" id="fig15-31" src="../images/Figure15-31.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-31: Melding seven heaps together, always working two at a time</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">First merge A and B, and combine that with the result of merging C through G. The second merge starts by merging C and D, and then it merges E through G. The third merge merges E and F first and then waits for the merge of only G (which is trivially just G), so you can complete merging E through G, and then C through G, and finally A through G.</p>&#13;
<p class="TX">Implementing this seesaw from left to right and then from right to left is actually easy. It’s based on a recursive idea: given a list of heaps, merge the initial two heaps on the list to produce a first heap, apply recursion to meld all the others into a second heap, and finish by merging both results together:</p>&#13;
<pre id="pre-312"><code>const _mergeByPairs = (heaps) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (heaps.length === 0) {&#13;
   return newPairingHeap();&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else if (heaps.length === 1) {&#13;
   return heaps[0];&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else {&#13;
   return merge(merge(heaps[0], heaps[1]), _mergeByPairs(heaps.slice(2)));&#13;
 }&#13;
};</code></pre>&#13;
<p class="TX">This code shows two simple, one-liner cases. If you have no heaps to merge <span class="CodeAnnotation" aria-label="annotation1">❶</span>, a null heap is returned, and if there is only one heap to merge <span class="CodeAnnotation" aria-label="annotation2">❷</span>, the result is that heap itself. If you have several heaps <span class="CodeAnnotation" aria-label="annotation3">❸</span>, merge the two first heaps, then recursively merge all the other heaps, and finish by merging both heaps together.</p>&#13;
<p class="TX">This is actually an implementation of the left-to-right then right-to-left process described previously, so now redo the case with the seven heaps <span role="doc-pagebreak" epub:type="pagebreak" id="pg_380" aria-label="380"/>A through G you looked at earlier. Writing <span class="SANS_TheSansMonoCd_W5Regular_11">mbp()</span> for <span class="SANS_TheSansMonoCd_W5Regular_11">mergeByPairs()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">m()</span> for <span class="SANS_TheSansMonoCd_W5Regular_11">merge(),</span> it would be:</p>&#13;
<pre id="pre-313"><code>mbp([A,B,C,D,E,F,G]) =&#13;
m(AB, mbp([C,D,E,F,G]) =&#13;
m(AB, m(CD, mbp([E,F,G]))) =&#13;
m(AB, m(CD, m(EF, mbp([G])))) =&#13;
m(AB, m(CD, m(EF, G))) =&#13;
m(AB, m(CD, EFG)) =&#13;
m(AB, CDEFG) =&#13;
<b>ABCDEFG</b></code></pre>&#13;
<p class="TX">Given this auxiliary method, you can now write the <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span> code:</p>&#13;
<pre id="pre-314"><code>const remove = (heap) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(heap)) {&#13;
    throw new Error("Empty heap; cannot remove");&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const top = heap.key;&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const children = [];&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> let child = heap.down;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> while (!isEmpty(child)) {&#13;
      const next = child.right;&#13;
      child.right = null;&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> children.push(child);&#13;
      child = next;&#13;
    }&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> return [_mergeByPairs(children), top];&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">If the heap is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, throw an error, because you cannot proceed with the removal. Otherwise, get the top value <span class="CodeAnnotation" aria-label="annotation2">❷</span>, so you can return it later <span class="CodeAnnotation" aria-label="annotation7">❼</span>, and proceed to separate the subheaps. Initialize an array for the children <span class="CodeAnnotation" aria-label="annotation3">❸</span> and set up a child variable <span class="CodeAnnotation" aria-label="annotation4">❹</span> to loop through all the root’s children <span class="CodeAnnotation" aria-label="annotation5">❺</span>. Then push each of the subheaps <span class="CodeAnnotation" aria-label="annotation6">❻</span>, after remembering to unlink each from its siblings. After pushing all children into the array, merge them by pairs as described previously and return the removed top <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="TX">For example, assume you start again with the original pairing heap (see <a href="chapter15.xhtml#fig15-32">Figure 15-32</a>) and want to remove its root.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_381" aria-label="381"/>&#13;
<figure class="IMG"><img class="img5" id="fig15-32" src="../images/Figure15-32.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-32: The original pairing heap revisited</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Removing the root leaves three heaps. Start by melding the first two, those with roots 22 and 56 (you saw this in the previous section), resulting in <a href="chapter15.xhtml#fig15-33">Figure 15-33</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-33" src="../images/Figure15-33.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-33: The pairing heap after removing its root</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The final step is melding those heaps, resulting in the situation shown in <a href="chapter15.xhtml#fig15-34">Figure 15-34</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig15-34" src="../images/Figure15-34.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-34: The separate heaps melded again into a single heap</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Let’s now consider another procedure: changing a key’s value.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_382" aria-label="382"/>&#13;
<h4 class="H2" id="sec34"><span id="h2-153"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Changing a Value in a Pairing Heap</span></h4>&#13;
<p class="TNI1">The procedure to change a key is based on what you’ve already seen. First, change the key in place, but if it needs bubbling up (as with binomial heaps), separate it from the heap (as with Fibonacci heaps). Then merge the separated heap back into the original heap. You’re reusing concepts and algorithms.</p>&#13;
<p class="TX">For example, start with the heap shown in <a href="chapter15.xhtml#fig15-35">Figure 15-35</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig15-35" src="../images/Figure15-35.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-35: A pairing heap just before changing a key</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you want to change the 40 key, for example, and changed it to any value between 40 and 56, you’d just change the key and be done with it. However, if you change it to anything greater than its parent key (56), you have to split the heap and remerge it. This means if you want to change it to 78, after changing the key and splitting the heap away, you are left with the pair of heaps shown in <a href="chapter15.xhtml#fig15-36">Figure 15-36</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig15-36" src="../images/Figure15-36.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-36: Changing the 40 to a 78 splits the heap in two.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Applying the merging function we’ve looked at previously, <a href="chapter15.xhtml#fig15-37">Figure 15-37</a> shows the final result.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_383" aria-label="383"/>&#13;
<figure class="IMG"><img class="img7" id="fig15-37" src="../images/Figure15-37.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-37: Merging results in a single heap again</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you had changed the 40 to 58 instead of 78, the result would be different (see <a href="chapter15.xhtml#fig15-38">Figure 15-38</a>). Can you see why?</p>&#13;
<figure class="IMG"><img class="img7" id="fig15-38" src="../images/Figure15-38.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 15-38: An alternative result if you had changed the 40 to 58</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Here’s how to code the process:</p>&#13;
<pre id="pre-315"><code>const changeKey = (heap, node, newKey) =&gt; {&#13;
  if (isEmpty(heap)) {&#13;
    throw new Error("Heap is empty!");&#13;
  } else if (!goesHigher(newKey, node.key)) {&#13;
    throw new Error("New value should go higher than old value");&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> node.key = newKey;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const parent = node.up;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (parent &amp;&amp; goesHigher(newKey, parent.key)) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if (parent.down === node) {&#13;
        parent.down = node.right;&#13;
      } else {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> let child = parent.down;&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> while (child.right !== node) {&#13;
        <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> child = child.right;&#13;
        }&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_384" aria-label="384"/>      <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> child.right = node.right;&#13;
      }&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> node.right = null;&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation10">❿</span> heap = merge(heap, node);&#13;
    }&#13;
&#13;
    return heap;&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">The first two <span class="SANS_TheSansMonoCd_W5Regular_11">if()</span> statements are the same ones you’ve seen before to check whether the change is possible. Then, actually change the node’s key <span class="CodeAnnotation" aria-label="annotation1">❶</span> and get a pointer to its parent <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If there’s a parent and the new node’s key should go higher <span class="CodeAnnotation" aria-label="annotation3">❸</span>, then you need to act; otherwise, nothing else is needed. If the node was the first child of its parent <span class="CodeAnnotation" aria-label="annotation4">❹</span>, separate the node from the heap by changing the link down from its parent to point to the node’s first sibling. Otherwise, if the node isn’t the first child, loop through the siblings list <span class="CodeAnnotation" aria-label="annotation5">❺</span> <span class="CodeAnnotation" aria-label="annotation6">❻</span> <span class="CodeAnnotation" aria-label="annotation7">❼</span> until you find the node’s previous sibling. Then unlink the node from the list <span class="CodeAnnotation" aria-label="annotation8">❽</span> <span class="CodeAnnotation" aria-label="annotation9">❾</span> and finish by merging the separated heap back into the original <span class="CodeAnnotation" aria-label="annotation10">❿</span>. (Similar procedures were discussed in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
&#13;
<h4 class="H2" id="sec35"><span id="h2-154"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Considering Performance for Pairing Heaps</span></h4>&#13;
<p class="TNI1">The performance of pairing heaps is similar to that of Fibonacci heaps, as shown in <a href="chapter15.xhtml#tab15-6">Table 15-6</a>; values with an asterisk are amortized.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab15-6"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 15-6:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Pairing Heaps</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Performance</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Top</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Top</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)*</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Change</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)?</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Merge</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Why does changing a value have a question mark in the table? There’s still no consensus as to the precise amortized order of this operation. An initial estimate suggested it would be <i>O</i>(1), but then it was proven to be at least <span class="greek"><span xml:lang="el" lang="el">Ω</span></span>(log log <i>n</i>). Further work produced an <i>O</i>(log <i>n</i>) estimate, but no definite proof has yet appeared. In any case, this looks worse than Fibonacci heaps, but in practice, the performance of pairing heaps is reported to be excellent, despite the purported theoretical deficiency, which is most likely a result of the simpler implementation.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_385" aria-label="385"/>&#13;
<h3 class="H1" id="sec36"><span id="h1-81"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>&#13;
<p class="TNI1">In the previous chapter, we studied binary heaps that were represented with an array, and in this chapter, we completed our overview of heaps, exploring several extended versions that are implemented with binary trees, multiway trees, or forests and that allow operations such as merging two heaps and changing a key in a more performant way. These changes not only maintained the functionality of the previous heaps, but they also added enhanced performance and new features, allowing us to use these structures for other types of problems that common heaps wouldn’t handle as well. This chapter presents the best example of the possibilities of modified (or hybrid, if you will) structures that add speed and functionality—but at the obvious cost, clearly, of some more complex algorithms!</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec37">&#13;
&#13;
<h3 class="H1" id="sec37"><span id="h1-82"/><span class="SANS_Futura_Std_Bold_B_11">Questions</span></h3>&#13;
<p class="ListHead"><b>15.1  Intuitive but Worse</b></p>&#13;
<p class="ListPlainFirst">Suppose you have two common heaps of sizes <i>m</i> and <i>n</i> and you implement melding by applying the following intuitive method: successively choose all the elements from one heap and insert them into the other. What would be the order of this method?</p>&#13;
<p class="ListHead"><b>15.2  Sequential Cases</b></p>&#13;
<p class="ListPlainFirst">What’s the shape of a skew heap if you insert keys in ascending order? What about in descending order?</p>&#13;
<p class="ListHead"><b>15.3  No Recursion Needed</b></p>&#13;
<p class="ListPlainFirst">When merging two skew heaps and the second had the greater key, no recursion was actually needed; could you do the merge directly?</p>&#13;
<p class="ListHead"><b>15.4  Change Needed</b></p>&#13;
<p class="ListPlainFirst">How would you implement the <span class="SANS_TheSansMonoCd_W5Regular_11">changeKey()</span> function for skew heaps? Would you need to make some structure changes, and if so, what would they be?</p>&#13;
<p class="ListHead"><b>15.5  Just Adding</b></p>&#13;
<p class="ListPlainFirst">Assume you have a binomial heap with only a BT(3) in it, so it has eight values. Add a new value to that node eight times and count how many merges are needed. What can you conclude about the amortized cost of the operation?</p>&#13;
<p class="ListHead"><b>15.6  Faster Binomial Top</b></p>&#13;
<p class="ListPlainFirst">You can accelerate reaching the top of a binomial heap with means used for other heaps; can you figure out how to do so?</p>&#13;
<p class="ListHead"><b>15.7  Easier Bubbling Up?</b></p>&#13;
<p class="ListPlainFirst">Why can’t you implement the <span class="SANS_TheSansMonoCd_W5Regular_11">_bubbleUp()</span> method for binomial trees in the following way, similar to what you wrote for binary heaps? (The reason is easy to miss.)</p>&#13;
<pre class="pre" id="pre-316"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_386" aria-label="386"/>const _bubbleUp = (heap, node, newKey) =&gt; {&#13;
  node.key = newKey;&#13;
  const parent = node.up;&#13;
  if (parent &amp;&amp; goesHigher(newKey, parent.key)) {&#13;
    node.key = parent.key;&#13;
    _bubbleUp(parent, newKey);&#13;
  }&#13;
};</code></pre>&#13;
<p class="ListHead"><b>15.8  Searching a Heap</b></p>&#13;
<p class="ListPlainFirst">Even if it makes little sense, can you implement a <span class="SANS_TheSansMonoCd_W5Regular_11">find()</span> function for heaps? Be careful with Fibonacci heaps, so you don’t create an infinite loop because of the circular lists.</p>&#13;
<p class="ListHead"><b>15.9  Two in One</b></p>&#13;
<p class="ListPlainFirst">In a Fibonacci heap, you can make the <span class="SANS_TheSansMonoCd_W5Regular_11">add()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">remove()</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">mergeA2B()</span> methods a few lines shorter by joining assignments with the same right value; can you see how?</p>&#13;
</section>&#13;
</section>&#13;
</body></html>