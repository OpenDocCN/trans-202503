- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_11">导言</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/Drop-image.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Drop-image.jpg)'
- en: Nearly all programming jobs today require at least a cursory understanding of
    full-stack development, but if you’re a beginner, you might struggle to find the
    right entry point to this overwhelming topic. You might not even know what the
    term means.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的编程职位如今都要求至少对全栈开发有一个粗略的了解，但如果你是初学者，你可能会很难找到切入这个庞大话题的正确入口。你甚至可能不知道这个术语的含义。
- en: Simply put, *full-stack web development* typically refers to the creation of
    complete web applications using JavaScript and the many frameworks built for it.
    It requires a mastery of the traditional disciplines of frontend and backend development,
    as well as the ability to write middleware and various kinds of application programming
    interfaces (APIs).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，*全栈Web开发*通常指的是使用JavaScript及其构建的各种框架来创建完整的Web应用。这要求精通前端和后端开发的传统学科，并且能够编写中间件和各种类型的应用程序接口（API）。
- en: Lastly, a well-rounded full-stack developer can handle databases and has professional
    skills, such as the ability to craft automated tests and deploy their code by
    themselves. To do all of this, they must understand HTML, CSS, and JavaScript,
    as well as the language’s typed counterpart, TypeScript. For a crash course on
    some of this terminology, see “The Parts of a Full-Stack Application” on page
    xxiv.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一名全面的全栈开发人员能够处理数据库，并具备专业技能，比如能够编写自动化测试并自行部署代码。要做到这一点，他们必须理解HTML、CSS和JavaScript，以及该语言的类型化对应物TypeScript。有关这些术语的速成课程，请参见第xxiv页的《全栈应用的组成部分》。
- en: If this sounds like a lot, you’ve come to the right place. This book will introduce
    you to each component of a modern application and teach you how to use some of
    the most widely used technologies to build them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来很多，你来对地方了。本书将向你介绍现代应用的各个组成部分，并教你如何使用一些最广泛使用的技术来构建它们。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Who Should Read This Book?</samp>
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">谁应该阅读这本书？</samp>
- en: There are two primary audiences for the book. The first includes professional
    frontend or backend engineers who want to advance their careers by mastering full-stack
    development. The second includes inexperienced, beginning developers interested
    in learning about web development.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的主要读者有两类。一类是希望通过掌握全栈开发来提升职业生涯的前端或后端工程师；另一类是对Web开发感兴趣的初学者。
- en: While the book introduces many technologies from scratch, it assumes some prior
    familiarity with HTML, CSS, and JavaScript, as well as the client/server architecture
    of most web applications. For a refresher, see *The Coding Workbook* by Sam Taylor
    (No Starch Press, 2020), which teaches you how to build a website with HTML and
    CSS, and *The Book of CSS3*, 2nd edition, by Peter Gasston (No Starch Press, 2014)
    to sharpen your CSS skills. To familiarize yourself with JavaScript, I recommend
    *JavaScript Crash Course* by Nick Morgan (No Starch Press, 2024), which is a fast-paced
    JavaScript tutorial for beginners, and *Eloquent JavaScript*, 3rd edition, by
    Marijn Haverbeke (No Starch Press, 2018), for a deep dive into JavaScript.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书从零开始介绍了许多技术，但它假设读者对HTML、CSS和JavaScript有一定的基础了解，并且了解大多数Web应用的客户端/服务器架构。作为复习，可以参考Sam
    Taylor的*《编码工作手册》*（No Starch Press, 2020），该书教你如何使用HTML和CSS构建网站；以及Peter Gasston的*《CSS3书籍》*第二版（No
    Starch Press, 2014），来提升你的CSS技能。为了熟悉JavaScript，我推荐Nick Morgan的*《JavaScript速成课程》*（No
    Starch Press, 2024），这是一本为初学者设计的快速JavaScript教程；以及Marijn Haverbeke的*《Eloquent JavaScript》第三版*（No
    Starch Press, 2018），深入探讨JavaScript。
- en: <samp class="SANS_Futura_Std_Bold_B_11">What’s in This Book?</samp>
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">本书内容</samp>
- en: The book is split into two parts. [Part I](part1.xhtml), comprising [Chapters
    1](chapter1.xhtml) through [10](chapter10.xhtml), introduces you to the components
    of a modern technology stack. Each chapter focuses on one technology and highlights
    the topics you need to know as a full-stack developer. The exercises will encourage
    you to begin writing application code from page 1.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书分为两部分。[第一部分](part1.xhtml)，包括[第1章](chapter1.xhtml)到[第10章](chapter10.xhtml)，将向你介绍现代技术栈的各个组成部分。每一章重点介绍一种技术，并强调作为全栈开发人员需要掌握的知识点。练习将鼓励你从第1页开始编写应用代码。
- en: '**[Chapter 1](chapter1.xhtml): Node.js  **Introduces you to Node.js and its
    ecosystem, which let you run JavaScript code outside a browser. Then you’ll use
    Node.js and the Express.js framework to create your own simple web server with
    JavaScript.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第1章](chapter1.xhtml): Node.js**  介绍了Node.js及其生态系统，使你能够在浏览器外运行JavaScript代码。然后，你将使用Node.js和Express.js框架创建一个简单的JavaScript网页服务器。'
- en: '**[Chapter 2](chapter2.xhtml): Modern JavaScript  **Focuses on contemporary
    JavaScript syntax useful for full-stack developers, including how to use modules
    to write maintainable code packages. We look at the different ways to define variables
    and constants, the arrow function, and techniques for asynchronous code. You’ll
    use these to rewrite your JavaScript server.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第2章](chapter2.xhtml): 现代JavaScript**  聚焦于现代JavaScript语法，适用于全栈开发人员，包含如何使用模块编写可维护的代码包。我们将探讨定义变量和常量的不同方式、箭头函数以及异步代码的技巧。你将使用这些知识重写你的JavaScript服务器。'
- en: '**[Chapter 3](chapter3.xhtml): TypeScript  **Introduces TypeScript, a superset
    of JavaScript, and highlights how modern full-stack development benefits from
    it. We discuss the shortcomings and pitfalls of JavaScript and how to effectively
    leverage TypeScript’s type system through inference. You’ll conclude the chapter
    by refactoring your JavaScript server with type annotations, custom types, and
    interfaces.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第3章](chapter3.xhtml): TypeScript**  介绍了TypeScript，这是一种JavaScript的超集，并强调了现代全栈开发如何从中受益。我们讨论了JavaScript的不足和陷阱，以及如何通过类型推断有效利用TypeScript的类型系统。最后，你将通过类型注解、自定义类型和接口重构你的JavaScript服务器。'
- en: '**[Chapter 4](chapter4.xhtml): React  **Discusses React, one of the most common
    libraries for creating user interface components. You’ll see how its components
    simplify full-stack development and learn how to use its JSX elements, the virtual
    DOM, and hooks. You’ll then use React to add a reactive user interface to your
    Express.js server.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第4章](chapter4.xhtml): React**  讨论了React，这是最常用的用户界面组件库之一。你将看到它的组件如何简化全栈开发，并学习如何使用其JSX元素、虚拟DOM和Hooks。然后，你将使用React为你的Express.js服务器添加一个响应式用户界面。'
- en: '**[Chapter 5](chapter5.xhtml): Next.js  **Focuses on Next.js, the leading web
    application framework built on top of React. You’ll create pages and custom API
    routes with Next.js’s file-based routing before learning different ways to render
    a page within the framework. Finally, you’ll migrate the Express.js server to
    Next.js as an exercise.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第5章](chapter5.xhtml): Next.js**  重点介绍了Next.js，这是一个基于React构建的领先Web应用框架。你将使用Next.js的基于文件的路由创建页面和自定义API路由，之后学习在框架内渲染页面的不同方式。最后，你将进行一个练习，将Express.js服务器迁移到Next.js。'
- en: '**[Chapter 6](chapter6.xhtml): REST and GraphQL APIs  **Teaches you all about
    APIs, what they are, and how to use them for full-stack web development. We explore
    two kinds of APIs: REST and GraphQL. You’ll conclude the chapter by adding an
    Apollo GraphQL server to your Next.js full-stack application.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第6章](chapter6.xhtml): REST和GraphQL APIs**  教你关于API的所有知识，API是什么，以及如何在全栈Web开发中使用它们。我们探索了两种类型的API：REST和GraphQL。最后，你将通过向你的Next.js全栈应用添加Apollo
    GraphQL服务器来完成本章内容。'
- en: '**[Chapter 7](chapter7.xhtml): MongoDB and Mongoose  **Discusses the differences
    between traditional relational databases and non-relational databases such as
    MongoDB. You’ll add the Mongoose object data modeling tool to your technology
    stack to simplify working with a database. You’ll then connect the GraphQL API
    to your own MongoDB database.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第7章](chapter7.xhtml): MongoDB和Mongoose**  讨论了传统关系型数据库和非关系型数据库（如MongoDB）之间的区别。你将把Mongoose对象数据建模工具添加到你的技术栈中，以简化数据库操作。接着，你将把GraphQL
    API连接到你自己的MongoDB数据库。'
- en: '**[Chapter 8](chapter8.xhtml): Testing with the Jest Framework  **Explains
    the importance of automated tests and test-driven development to full-stack development.
    We explore different types of tests, common test patterns, and the concepts of
    test doubles, stubs, fakes, and mocks. Lastly, you’ll add a few basic snapshot
    tests to your Next.js application with the Jest framework.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第8章](chapter8.xhtml): 使用Jest框架进行测试**  解释了自动化测试和测试驱动开发对全栈开发的重要性。我们探索了不同类型的测试、常见的测试模式以及测试双胞胎、存根、假对象和模拟的概念。最后，你将使用Jest框架向你的Next.js应用添加一些基本的快照测试。'
- en: '**[Chapter 9](chapter9.xhtml): Authorization with OAuth  **Discusses authentication
    and authorization and how full-stack developers can use the OAuth protocol to
    handle those tasks by integrating with a third-party service. We walk through
    this authorization flow and its components. You’ll run through a complete OAuth
    interaction on the command line to explore each step in depth.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第9章](chapter9.xhtml)：OAuth授权**  讨论身份验证和授权，以及全栈开发人员如何通过集成第三方服务使用OAuth协议来处理这些任务。我们将详细讲解此授权流程及其组件。你将通过命令行运行一次完整的OAuth交互，深入探讨每个步骤。'
- en: '**[Chapter 10](chapter10.xhtml): Containerization with Docker  **Introduces
    you to using Docker to deploy your application. We cover the concept of a microservice
    architecture, then cover all relevant components of the Docker ecosystem: the
    host, the Docker daemon, Dockerfiles, images, containers, volumes, and Docker
    Compose. You’ll conclude by splitting your application into self-contained microservices.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第10章](chapter10.xhtml)：使用Docker进行容器化**  介绍了如何使用Docker部署应用程序。我们首先讲解微服务架构的概念，然后介绍Docker生态系统的所有相关组件：主机、Docker守护进程、Dockerfile、镜像、容器、卷和Docker
    Compose。最后，你将通过将应用程序拆分为自包含的微服务来完成这部分内容。'
- en: In [Part II](part2.xhtml), you’ll use your newfound knowledge to build a web
    application that applies the concepts, tools, and frameworks introduced in [Part
    I](part1.xhtml). The Food Finder application is a location search service that
    lets users log in with their GitHub account and maintain a wish list of places
    to visit.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二部分](part2.xhtml)中，你将运用新学到的知识构建一个Web应用程序，应用[第一部分](part1.xhtml)中介绍的概念、工具和框架。Food
    Finder应用是一个位置搜索服务，允许用户通过GitHub帐户登录并维护一个想要访问的地点愿望清单。
- en: '**[Chapter 11](chapter11.xhtml): Setting Up the Docker Environment  **Create
    the foundation of your Food Finder application by using your knowledge of Docker
    and containerization to set up your development environment. You’ll use Docker
    Compose to decouple the application development from your local system and then
    add a MongoDB server as its own service.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第11章](chapter11.xhtml)：设置Docker环境**  通过运用你对Docker和容器化的知识，创建你的Food Finder应用的基础。你将使用Docker
    Compose将应用开发与本地系统解耦，然后添加一个作为独立服务的MongoDB服务器。'
- en: '**[Chapter 12](chapter12.xhtml): Building the Middleware  **Create the first
    part of the Food Finder application’s middleware. Here you’ll connect Mongoose
    to the MongoDB service and create its schema, model, services, and custom types.
    With these pieces in place, you’ll be able to create, read, update, and delete
    data from your database.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第12章](chapter12.xhtml)：构建中间件**  创建Food Finder应用的第一个中间件部分。在这里，你将连接Mongoose到MongoDB服务，并创建其架构、模型、服务和自定义类型。有了这些组件，你将能够从数据库中创建、读取、更新和删除数据。'
- en: '**[Chapter 13](chapter13.xhtml): Building the GraphQL API  **Use your knowledge
    of GraphQL to add an Apollo GraphQL server to your Food Finder application, then
    implement a public GraphQL API. You’ll be able to use the Apollo sandbox to read
    and update data with GraphQL on your MongoDB server.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第13章](chapter13.xhtml)：构建GraphQL API**  运用你对GraphQL的知识，在Food Finder应用中添加一个Apollo
    GraphQL服务器，然后实现一个公共的GraphQL API。你将能够使用Apollo沙盒来读取和更新MongoDB服务器上的数据。'
- en: '**[Chapter 14](chapter14.xhtml): Building the Frontend  **Use React components
    and the Next.js framework to build the frontend for the Food Finder application.
    At this point, you’ll have implemented a complete modern full-stack application
    that reads data from the database through your custom middleware and renders the
    data to your application’s frontend.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第14章](chapter14.xhtml)：构建前端**  使用React组件和Next.js框架构建Food Finder应用的前端。在这一阶段，你将实现一个完整的现代全栈应用程序，通过自定义中间件从数据库读取数据并将数据呈现到应用的前端。'
- en: '**[Chapter 15](chapter15.xhtml): Adding OAuth  **Add an OAuth flow to your
    app so that visitors can log in to maintain a personal wish list of locations.
    You’ll use the *next-auth* package from Auth.js to add login options using GitHub.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第15章](chapter15.xhtml)：添加OAuth**  向你的应用程序添加OAuth流程，让访客能够登录并维护个人地点愿望清单。你将使用*next-auth*包从Auth.js中添加通过GitHub的登录选项。'
- en: '**[Chapter 16](chapter16.xhtml): Running Automated Tests in Docker  **Set up
    automated snapshot tests with Jest and configure a new service to run the tests
    automatically.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第16章](chapter16.xhtml)：在Docker中运行自动化测试**  使用Jest设置自动化快照测试，并配置一个新的服务来自动运行这些测试。'
- en: Then, in the appendices, you’ll get detailed information on the TypeScript Compiler
    options and the most common Jest matchers. Also, you’ll use your newfound knowledge
    to explore and understand Next.js’s modern app directory approach.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在附录中，你将获得关于 TypeScript 编译器选项和最常见 Jest 匹配器的详细信息。此外，你还将运用你新获得的知识，探索并理解 Next.js
    的现代应用程序目录方法。
- en: '**[Appendix A](appendix-A.xhtml): TypeScript Compiler Options  **Shows the
    most common TypeScript Compiler (TSC) options so that you can customize your own
    TypeScript projects to your liking.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**[附录 A](appendix-A.xhtml)：TypeScript 编译器选项**展示了最常见的 TypeScript 编译器（TSC）选项，以便你可以根据个人喜好自定义自己的
    TypeScript 项目。'
- en: '**[Appendix B](appendix-B.xhtml): The Next.js app Directory  **Explores a new
    routing pattern using the *app* directory that Next.js introduced in version 13\.
    You can then choose to work with either the traditional pages approach covered
    in [Chapter 5](chapter5.xhtml) or the modern *app* directory in your own upcoming
    projects.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**[附录 B](appendix-B.xhtml)：Next.js 应用程序目录**探索了 Next.js 在版本 13 中引入的使用*app*目录的新路由模式。你可以选择继续使用传统的页面方法（详见[第
    5 章](chapter5.xhtml)），或者在即将到来的项目中使用现代的*app*目录。'
- en: '**[Appendix C](appendix-C.xhtml): Common Matchers  **Shows the most common
    matchers for testing your applications with Jest and the Jest DOM.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**[附录 C](appendix-C.xhtml)：常见的匹配器**展示了用于使用 Jest 和 Jest DOM 测试应用程序的最常见匹配器。'
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parts of a Full-Stack Application</samp>
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">全栈应用程序的各个部分</samp>
- en: Throughout this book, we’ll discuss various portions of an application. This
    section gives you a crash course on what we mean when we use the terms *frontend*,
    *middleware*, and *backend*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将讨论应用程序的各个部分。本节为你提供一个速成课程，讲解当我们使用术语*前端*、*中间件*和*后端*时的含义。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Frontend</samp>
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">前端</samp>
- en: The frontend is the user-facing part of a website or web application. It runs
    on the client, typically a web browser. You can think of it as the “front office”
    of the web application. For example, on [*https://<wbr>www<wbr>.google<wbr>.com*](https://www.google.com),
    the frontend is a page with a simple search bar, though of course, frontend development
    can be much more complex than this; take a look at Google’s search results page
    or the interface of the last website you visited.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前端是网站或 Web 应用程序的面向用户部分。它运行在客户端，通常是一个 Web 浏览器。你可以将其视为 Web 应用程序的“前台”。例如，在 [*https://<wbr>www<wbr>.google<wbr>.com*](https://www.google.com)上，前端是一个带有简单搜索栏的页面，当然，前端开发可能比这更复杂；看看谷歌的搜索结果页面或你最近访问的最后一个网站的界面。
- en: Frontend developers focus on user engagement, experiences, and interfaces. They
    rely on HTML for creating the elements of the website’s interface, CSS for styling,
    JavaScript for user interactions, and frameworks such as Next.js to pull everything
    together.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前端开发者专注于用户参与、体验和界面。他们依赖 HTML 来创建网站界面的元素，CSS 用于样式，JavaScript 用于用户交互，以及 Next.js
    等框架来将所有内容结合在一起。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Middleware</samp>
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">中间件</samp>
- en: The middleware connects an application’s frontend and backend and performs all
    of its chores, such as integrating with third-party services and transferring
    and updating data. You can think of it as the employees on the company floor.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件连接应用程序的前端和后端，并执行所有任务，例如与第三方服务的集成、数据的传输和更新。你可以将其看作是公司楼层上的员工。
- en: As full-stack developers, we often write middleware for *routing* our applications,
    which means serving the correct data for a particular URL, handling database connections,
    and performing authorization. For example, on [*https://<wbr>www<wbr>.google<wbr>.com*](https://www.google.com),
    the middleware asks the server for the landing page’s HTML. Then a different part
    of the middleware checks whether the user is logged in, and if so, which personal
    data it should show. Meanwhile, a third part of the middleware consolidates the
    information from each of these data streams and then answers the server’s requests
    with the correct HTML.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为全栈开发者，我们经常为*路由*应用程序编写中间件，这意味着为特定 URL 提供正确的数据，处理数据库连接并执行授权。例如，在 [*https://<wbr>www<wbr>.google<wbr>.com*](https://www.google.com)上，中间件会向服务器请求登录页面的
    HTML。然后，另一部分中间件会检查用户是否已登录，如果已登录，应该显示哪些个人数据。与此同时，第三部分中间件会整合这些数据流中的信息，然后以正确的 HTML
    响应服务器的请求。
- en: 'One essential part of a full-stack application’s middleware is its *API layer*,
    which exposes the application’s APIs. Generally, an API is code written to connect
    two machines. Often, an API lets the frontend code (or a third party) access the
    application’s backend. JavaScript-driven development relies on two primary architectural
    frameworks for creating APIs: REST and GraphQL, both of which are covered in [Chapter
    6](chapter6.xhtml).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个全栈应用程序的中间件的一个重要部分是它的 *API 层*，该层公开了应用程序的 API。通常，API 是用来连接两台机器的代码。通常，API 让前端代码（或第三方）访问应用程序的后端。由
    JavaScript 驱动的开发依赖于两种主要的架构框架来创建 API：REST 和 GraphQL，二者在[第 6 章](chapter6.xhtml)中有详细介绍。
- en: You could write the middleware by using any programming language. Most full-stack
    developers use modern JavaScript or TypeScript, but they could instead use PHP,
    Ruby, or Go.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何编程语言来编写中间件。大多数全栈开发者使用现代 JavaScript 或 TypeScript，但他们也可以选择使用 PHP、Ruby 或
    Go。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Backend</samp>
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">后端</samp>
- en: The backend is the invisible part of a web application. In a JavaScript-driven
    application, the backend runs on a server, typically Express.js, though others
    might use Apache or NGINX. You can think of it as the “back office” of the web
    application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 后端是 Web 应用程序中看不见的部分。在一个由 JavaScript 驱动的应用程序中，后端运行在服务器上，通常是 Express.js，尽管其他人可能使用
    Apache 或 NGINX。你可以把它看作是 Web 应用程序的“后台”部分。
- en: More concretely, the backend handles any operations involving the application’s
    data. It performs create, read, update, and delete (CRUD) operations on the values
    stored in the database and returns the datasets requested by the user through
    the middleware’s API layer. For [*https://<wbr>www<wbr>.google<wbr>.com*](https://www.google.com),
    the backend is the code that searches the database for the keywords you entered
    in the frontend, which the backend received through the middleware. The middleware
    would combine these search results with other relevant pieces of information.
    Then the user would see the search results page rendered by the frontend.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，后端处理涉及应用程序数据的任何操作。它对存储在数据库中的值执行创建、读取、更新和删除（CRUD）操作，并通过中间件的 API 层返回用户请求的数据集。对于[*https://<wbr>www<wbr>.google<wbr>.com*](https://www.google.com)，后端是用来搜索数据库中你在前端输入的关键词的代码，这些关键词通过中间件传递给后端。中间件将这些搜索结果与其他相关信息结合起来。然后，用户将在前端呈现的搜索结果页面中看到这些内容。
- en: Backend development can be done in any programming language. Full-stack developers
    usually employ modern JavaScript or TypeScript. Other options include PHP, Ruby,
    Elixir, Python, Java, and frameworks like Symfony, Ruby on Rails, Phoenix, and
    Django.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 后端开发可以使用任何编程语言进行。全栈开发者通常使用现代 JavaScript 或 TypeScript。其他选择包括 PHP、Ruby、Elixir、Python、Java
    以及像 Symfony、Ruby on Rails、Phoenix 和 Django 这样的框架。
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Brief History of JavaScript and Full-Stack
    Development</samp>
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">JavaScript 和全栈开发的简史</samp>
- en: All developers should understand the context of the tools they’re using. Before
    we begin developing, let’s start with a bit of history.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有开发者都应该理解他们所使用工具的背景。在我们开始开发之前，让我们先了解一点历史。
- en: The full-stack developer position evolved alongside JavaScript, which began
    as nothing more than a scripting language that ran in users’ browsers. Developers
    used it to add elements to their websites, such as accordions, pop-up menus, and
    overlays, that reacted immediately to a user’s behavior, without requiring requests
    to the application’s server.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 全栈开发者职位是与 JavaScript 一同发展的，JavaScript 最初只不过是一个在用户浏览器中运行的脚本语言。开发者使用它来为网站添加元素，如手风琴、弹出菜单和覆盖层，这些元素会根据用户的行为立即响应，而无需向应用程序的服务器发出请求。
- en: Until the late 2000s, most JavaScript libraries were designed to provide consistent
    interfaces to handle vendor-specific quirks. Often, the JavaScript engines were
    slow, especially when interacting with, updating, or modifying the HTML. Hence,
    JavaScript was considered a quirky scripting language for the frontend and was
    frowned upon by backend developers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 2000 年代末，大多数 JavaScript 库的设计都是为了提供一致的接口，以处理供应商特定的特殊情况。通常，JavaScript 引擎的速度较慢，特别是在与
    HTML 交互、更新或修改时。因此，JavaScript 曾被视为一个有些怪异的前端脚本语言，并且不被后端开发者所看好。
- en: Several projects attempted to popularize the use of JavaScript in the backend,
    but until the release of Node.js in 2009, these didn’t gain any traction. Node.js,
    covered in [Chapter 1](chapter1.xhtml), is a JavaScript tool for developing backends.
    Shortly thereafter, the Node.js package manager npm built the missing ecosystem
    for full-stack JavaScript development.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 几个项目曾试图普及JavaScript在后端的应用，但直到2009年Node.js发布之前，这些尝试都没有取得显著进展。Node.js（在[第1章](chapter1.xhtml)中讨论）是一个用于开发后端的JavaScript工具。随后，Node.js的包管理器npm构建了全栈JavaScript开发所需的生态系统。
- en: This ecosystem includes a host of JavaScript libraries for working with databases,
    building user interfaces, and writing server-side code (many of which we’ll explore
    in this book). These new tools allowed developers to use JavaScript reliably on
    both the client and the server. Of particular importance, Google released the
    Angular framework in 2010, and Meta (known as Facebook at the time) released React
    in 2013\. The commitment of these internet giants to building JavaScript tools
    turned full-stack web development into a sought-after role.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生态系统包括了一系列用于处理数据库、构建用户界面和编写服务器端代码的JavaScript库（我们将在本书中探讨其中的许多）。这些新工具使得开发人员可以在客户端和服务器端可靠地使用JavaScript。特别重要的是，谷歌于2010年发布了Angular框架，Meta（当时被称为Facebook）于2013年发布了React。互联网巨头们致力于构建JavaScript工具，使得全栈Web开发成为一个备受追捧的职位。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setting Up</samp>
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">设置</samp>
- en: Throughout this book, you’ll write code and run command line tools. You can
    use any development environment you’d like, but here are some guidelines.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，您将编写代码并运行命令行工具。您可以使用任何开发环境，但以下是一些指导建议。
- en: The most common code editor these days is Visual Studio Code, which you can
    download from [*https://<wbr>code<wbr>.visualstudio<wbr>.com*](https://code.visualstudio.com).
    It is Microsoft’s open source editor and is free for Windows, macOS, and Linux.
    In addition, you can extend and configure it through a plethora of third-party
    plug-ins and adjust its appearance to your liking. However, if you’re used to
    a different editor, such as Vim or Emacs, you can keep using it. The book doesn’t
    require a particular tool.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最常见的代码编辑器是Visual Studio Code，您可以从[*https://<wbr>code<wbr>.visualstudio<wbr>.com*](https://code.visualstudio.com)下载。它是微软的开源编辑器，适用于Windows、macOS和Linux，且免费。此外，您可以通过大量第三方插件扩展和配置它，并根据个人喜好调整外观。不过，如果您习惯使用其他编辑器，比如Vim或Emacs，您也可以继续使用。本书并不要求使用特定的工具。
- en: 'Depending on your operating system, your default command line program will
    be either the *Command Prompt* (on Windows) or the *Terminal* (on macOS and Linux).
    These programs use slightly different syntax for tasks like creating, changing,
    and listing the contents of a directory. This book shows the Linux and macOS versions
    of these commands. If you’re using Windows, you’ll have to adapt the commands
    for your operating system. For example, instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp>,
    Windows uses <samp class="SANS_TheSansMonoCd_W5Regular_11">dir</samp> to list
    files and folders in the current directory. Microsoft’s official command line
    reference lists all available commands here: [*https://<wbr>learn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/windows<wbr>-server<wbr>/administration<wbr>/windows<wbr>-commands<wbr>/windows<wbr>-commands#command<wbr>-line<wbr>-reference<wbr>-a<wbr>-z*](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands#command-line-reference-a-z).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的操作系统，默认的命令行程序可能是*命令提示符*（Windows）或*终端*（macOS和Linux）。这些程序在执行诸如创建、修改和列出目录内容等任务时，使用略有不同的语法。本书展示的是Linux和macOS版本的命令。如果您使用的是Windows，您需要根据操作系统调整命令。例如，Windows使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">dir</samp>来列出当前目录中的文件和文件夹，而不是Linux中的<code>ls</code>。微软的官方命令行参考文档列出了所有可用的命令，您可以在这里查看：[
    *https://<wbr>learn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/windows<wbr>-server<wbr>/administration<wbr>/windows<wbr>-commands<wbr>/windows<wbr>-commands#command<wbr>-line<wbr>-reference<wbr>-a<wbr>-z*](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands#command-line-reference-a-z)。
- en: The most notable difference between operating systems relevant to this book
    is the escape character used for line breaks in multiline cURL commands. This
    escape character is <samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp> on
    macOS and <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp> on Windows. We’ll
    point out these differences in [Chapter 6](chapter6.xhtml), when we first use
    cURL.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中与操作系统相关的最显著区别是多行cURL命令中用于换行的转义字符。这个转义字符在macOS中是<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>，而在Windows中是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">^</samp>。我们将在[第六章](chapter6.xhtml)中指出这些区别，当我们首次使用cURL时。
- en: You can download the code listings for the first part of the book and the complete
    source code for the Food Finder application from [*https://<wbr>www<wbr>.usemodernfullstack<wbr>.dev<wbr>/downloads*](https://www.usemodernfullstack.dev/downloads).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[*https://<wbr>www<wbr>.usemodernfullstack<wbr>.dev<wbr>/downloads*](https://www.usemodernfullstack.dev/downloads)下载本书第一部分的代码清单以及Food
    Finder应用程序的完整源代码。
