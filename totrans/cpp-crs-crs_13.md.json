["```\nstruct SpeedUpdate {\n  double velocity_mps;\n};\n\nstruct CarDetected {\n  double distance_m;\n  double velocity_mps;\n};\n\nstruct BrakeCommand {\n  double time_to_collision_s;\n};\n```", "```\nstruct ServiceBus {\n  void publish(const BrakeCommand&);\n  --snip--\n};\n```", "```\ntemplate <typename T>\nstruct AutoBrake {\n  AutoBrake(const T& publish);\n  void observe(const SpeedUpdate&);\n  void observe(const CarDetected&);\nprivate:\n  const T& publish;\n  --snip--\n};\n```", "```\n--snip--\nint main() {\n  ServiceBus bus;\n  AutoBrake auto_brake{ [&bus➊] (const auto& cmd) {\n                          bus.publish(cmd); ➋\n                      }\n  };\n  while (true) {  // Service bus's event loop\n    auto_brake.observe(SpeedUpdate{ 10L }); ➌\n auto_brake.observe(CarDetected{ 250L, 25L }); ➍\n  }\n}\n```", "```\nstruct SpeedUpdate {\n  double velocity_mps;\n};\n\nstruct CarDetected {\n  double distance_m;\n  double velocity_mps;\n};\n\nstruct BrakeCommand {\n  double time_to_collision_s;\n};\n\ntemplate <typename T>\nstruct AutoBrake {\n  AutoBrake(const T& publish➊) : publish{ publish } { }\n  void observe(const SpeedUpdate& cd) { } ➋\n  void observe(const CarDetected& cd) { } ➌\n  void set_collision_threshold_s(double x) { ➍\n    collision_threshold_s = x;\n  }\n  double get_collision_threshold_s() const { ➎\n    return collision_threshold_s;\n  }\n  double get_speed_mps() const { ➏\n    return speed_mps;\n  }\nprivate:\n  double collision_threshold_s;\n  double speed_mps;\n  const T& publish;\n};\n```", "```\n#include <stdexcept>\nconstexpr void assert_that(bool statement, const char* message) {\n  if (!statement➊) throw std::runtime_error{ message }; ➋\n}\n\nint main() {\n  assert_that(1 + 2 > 2, \"Something is profoundly wrong with the universe.\"); ➌\n  assert_that(24 == 42, \"This assertion will generate an exception.\"); ➍\n}\n--------------------------------------------------------------------------\nterminate called after throwing an instance of 'std::runtime_error'\n  what():  This assertion will generate an exception. ➍\n```", "```\nvoid initial_speed_is_zero() {\n  AutoBrake auto_brake{ [](const BrakeCommand&) {} }; ➊\n  assert_that(auto_brake.get_speed_mps() == 0L, \"speed not equal 0\"); ➋\n}\n```", "```\n#include <exception>\n--snip--\nvoid run_test(void(*unit_test)(), const char* name) {\n  try {\n    unit_test(); ➊\n    printf(\"[+] Test %s successful.\\n\", name); ➋\n  } catch (const std::exception& e) {\n    printf(\"[-] Test failure in %s. %s.\\n\", name, e.what()); ➌\n  }\n}\n```", "```\n#include <stdexcept>\n\nstruct SpeedUpdate {\n  double velocity_mps;\n};\n\nstruct CarDetected {\n double distance_m;\n  double velocity_mps;\n};\n\nstruct BrakeCommand {\n  double time_to_collision_s;\n};\n\ntemplate <typename T>\nstruct AutoBrake {\n  --snip--\n};\n\nconstexpr void assert_that(bool statement, const char* message) {\n  if (!statement) throw std::runtime_error{ message };\n}\n\nvoid initial_speed_is_zero() {\n  AutoBrake auto_brake{ [](const BrakeCommand&) {} };\n  assert_that(auto_brake.get_speed_mps() == 0L, \"speed not equal 0\");\n}\n\nvoid run_test(void(*unit_test)(), const char* name) {\n  try {\n    unit_test();\n    printf(\"[+] Test %s successful.\\n\", name);\n  } catch (const std::exception& e) {\n    printf(\"[-] Test failure in %s. %s.\\n\", name, e.what());\n  }\n}\n\nint main() {\n  run_test(initial_speed_is_zero, \"initial speed is 0\"); ➊\n}\n--------------------------------------------------------------------------\n[-] Test failure in initial speed is 0\\. speed not equal 0\\. ➊\n```", "```\ntemplate <typename T>\nstruct AutoBrake {\n AutoBrake(const T& publish) : speed_mps{}➊, publish{ publish } { }\n  --snip--\n};\n```", "```\n[+] Test initial speed is 0 successful.\n```", "```\nvoid initial_sensitivity_is_five() {\n  AutoBrake auto_brake{ [](const BrakeCommand&) {} };\n  assert_that(auto_brake.get_collision_threshold_s() == 5L,\n              \"sensitivity is not 5\");\n}\n```", "```\n--snip--\nint main() {\n  run_test(initial_speed_is_zero, \"initial speed is 0\");\n  run_test(initial_sensitivity_is_five, \"initial sensitivity is 5\");\n}\n--------------------------------------------------------------------------\n[+] Test initial speed is 0 successful.\n[-] Test failure in initial sensitivity is 5\\. sensitivity is not 5.\n```", "```\ntemplate <typename T>\nstruct AutoBrake {\n  AutoBrake(const T& publish)\n    : collision_threshold_s{ 5 }, ➊\n      speed_mps{},\n      publish{ publish } { }\n  --snip--\n};\n```", "```\n[+] Test initial speed is 0 successful.\n[+] Test initial sensitivity is 5 successful.\n```", "```\nvoid sensitivity_greater_than_1() {\n  AutoBrake auto_brake{ [](const BrakeCommand&) {} };\n  try {\n    auto_brake.set_collision_threshold_s(0.5L); ➊\n  } catch (const std::exception&) {\n    return; ➋\n  }\n  assert_that(false, \"no exception thrown\"); ➌\n}\n```", "```\n--snip--\nint main() {\n  run_test(initial_speed_is_zero, \"initial speed is 0\");\n  run_test(initial_sensitivity_is_five, \"initial sensitivity is 5\");\n  run_test(sensitivity_greater_than_1, \"sensitivity greater than 1\"); ➊\n}\n--------------------------------------------------------------------------\n[+] Test initial speed is 0 successful.\n[+] Test initial sensitivity is 5 successful.\n[-] Test failure in sensitivity greater than 1\\. no exception thrown. ➊\n```", "```\n#include <exception>\n--snip--\ntemplate <typename T>\nstruct AutoBrake {\n  --snip--\n  void set_collision_threshold_s(double x) {\n    if (x < 1) throw std::exception{ \"Collision less than 1.\" };\n    collision_threshold_s = x;\n  }\n}\n```", "```\n[+] Test initial speed is 0 successful.\n[+] Test initial sensitivity is 5 successful.\n[+] Test sensitivity greater than 1 successful.\n```", "```\nvoid speed_is_saved() {\n  AutoBrake auto_brake{ [](const BrakeCommand&) {} }; ➊\n  auto_brake.observe(SpeedUpdate{ 100L }); ➋\n  assert_that(100L == auto_brake.get_speed_mps(), \"speed not saved to 100\"); ➌\n  auto_brake.observe(SpeedUpdate{ 50L });\n  assert_that(50L == auto_brake.get_speed_mps(), \"speed not saved to 50\");\n  auto_brake.observe(SpeedUpdate{ 0L });\n  assert_that(0L == auto_brake.get_speed_mps(), \"speed not saved to 0\");\n}\n```", "```\n--snip--\nint main() {\n  run_test(initial_speed_is_zero, \"initial speed is 0\");\n  run_test(initial_sensitivity_is_five, \"initial sensitivity is 5\");\n  run_test(sensitivity_greater_than_1, \"sensitivity greater than 1\");\n  run_test(speed_is_saved, \"speed is saved\"); ➊\n}\n--------------------------------------------------------------------------\n[+] Test initial speed is 0 successful.\n[+] Test initial sensitivity is 5 successful.\n[+] Test sensitivity greater than 1 successful.\n[-] Test failure in speed is saved. speed not saved to 100\\. ➊\n```", "```\ntemplate <typename T>\nstruct AutoBrake {\n  --snip--\n  void observe(const SpeedUpdate& x) {\n    speed_mps = x.velocity_mps; ➊\n  }\n};\n```", "```\n[+] Test initial speed is 0 successful.\n[+] Test initial sensitivity is 5 successful.\n[+] Test sensitivity greater than 1 successful.\n[+] Test speed is saved successful.\n```", "```\nvoid alert_when_imminent() {\n  int brake_commands_published{}; ➊\n  AutoBrake auto_brake{\n    [&brake_commands_published➋](const BrakeCommand&) {\n      brake_commands_published++; ➌\n  } };\n  auto_brake.set_collision_threshold_s(10L); ➍\n  auto_brake.observe(SpeedUpdate{ 100L }); ➎\n  auto_brake.observe(CarDetected{ 100L, 0L }); ➏\n  assert_that(brake_commands_published == 1, \"brake commands published not\none\"); ➐\n}\n```", "```\n[+] Test initial speed is 0 successful.\n[+] Test initial sensitivity is 5 successful.\n[+] Test sensitivity greater than 1 successful.\n[+] Test speed is saved successful.\n[-] Test failure in alert when imminent. brake commands published not one.\n```", "```\ntemplate <typename T>\nstruct AutoBrake {\n  --snip--\n  void observe(const CarDetected& cd) {\n    const auto relative_velocity_mps = speed_mps - cd.velocity_mps; ➊\n    const auto time_to_collision_s = cd.distance_m / relative_velocity_mps; ➋\n    if (time_to_collision_s > 0 &&  ➌\n        time_to_collision_s <= collision_threshold_s ➍) {\n publish(BrakeCommand{ time_to_collision_s }); ➎\n    }\n  }\n};\n```", "```\n[+] Test initial speed is 0 successful.\n[+] Test initial sensitivity is 5 successful.\n[+] Test sensitivity greater than 1 successful.\n[+] Test speed is saved successful.\n[+] Test alert when imminent successful.\n```", "```\nvoid no_alert_when_not_imminent() {\n  int brake_commands_published{};\n  AutoBrake auto_brake{\n    [&brake_commands_published](const BrakeCommand&) {\n      brake_commands_published++;\n  } };\n  auto_brake.set_collision_threshold_s(2L);\n  auto_brake.observe(SpeedUpdate{ 100L });\n  auto_brake.observe(CarDetected{ 1000L, 50L });\n  assert_that(brake_commands_published == 0 ➊, \"brake command published\");\n}\n```", "```\n[+] Test initial speed is 0 successful.\n[+] Test initial sensitivity is 5 successful.\n[+] Test sensitivity greater than 1 successful.\n[+] Test speed is saved successful.\n[+] Test alert when imminent successful.\n[+] Test no alert when not imminent successful. ➊\n```", "```\n#include <functional>\n\nusing SpeedUpdateCallback = std::function<void(const SpeedUpdate&)>;\nusing CarDetectedCallback = std::function<void(const CarDetected&)>;\n\nstruct IServiceBus {\n  virtual ~IServiceBus() = default;\n  virtual void publish(const BrakeCommand&) = 0;\n  virtual void subscribe(SpeedUpdateCallback) = 0;\n  virtual void subscribe(CarDetectedCallback) = 0;\n};\n```", "```\nstruct MockServiceBus : IServiceBus {\n  void publish(const BrakeCommand& cmd) override {\n    commands_published++; ➊\n    last_command = cmd; ➋\n  }\n  void subscribe(SpeedUpdateCallback callback) override {\n    speed_update_callback = callback; ➌\n  }\n  void subscribe(CarDetectedCallback callback) override {\n    car_detected_callback = callback; ➍\n  }\n  BrakeCommand last_command{};\n  int commands_published{};\n  SpeedUpdateCallback speed_update_callback{};\n  CarDetectedCallback car_detected_callback{};\n};\n```", "```\n#include <exception>\n--snip--\nstruct AutoBrake { ➊\n AutoBrake(IServiceBus& bus) ➋\n    : collision_threshold_s{ 5 },\n      speed_mps{} {\n  }\n  void set_collision_threshold_s(double x) {\n    if (x < 1) throw std::exception{ \"Collision less than 1.\" };\n    collision_threshold_s = x;\n  }\n  double get_collision_threshold_s() const {\n    return collision_threshold_s;\n  }\n  double get_speed_mps() const {\n    return speed_mps;\n  }\nprivate:\n  double collision_threshold_s;\n  double speed_mps;\n};\n```", "```\nvoid initial_speed_is_zero() {\n  MockServiceBus bus{}; ➊\n  AutoBrake auto_brake{ bus }; ➋\n  assert_that(auto_brake.get_speed_mps() == 0L, \"speed not equal 0\");\n}\n\nvoid initial_sensitivity_is_five() {\n  MockServiceBus bus{}; ➊\n  AutoBrake auto_brake{ bus }; ➋\n  assert_that(auto_brake.get_collision_threshold_s() == 5,\n              \"sensitivity is not 5\");\n}\n\nvoid sensitivity_greater_than_1() {\n  MockServiceBus bus{}; ➊\n  AutoBrake auto_brake{ bus }; ➋\n try {\n    auto_brake.set_collision_threshold_s(0.5L);\n  } catch (const std::exception&) {\n    return;\n  }\n  assert_that(false, \"no exception thrown\");\n}\n```", "```\n[+] Test initial speed is 0 successful.\n[+] Test initial sensitivity is 5 successful.\n[+] Test sensitivity greater than 1 successful.\n```", "```\nvoid speed_is_saved() {\n  MockServiceBus bus{};\n  AutoBrake auto_brake{ bus };\n\n  bus.speed_update_callback(SpeedUpdate{ 100L }); ➊\n  assert_that(100L == auto_brake.get_speed_mps(), \"speed not saved to 100\"); ➋\n  bus.speed_update_callback(SpeedUpdate{ 50L });\n  assert_that(50L == auto_brake.get_speed_mps(), \"speed not saved to 50\");\n  bus.speed_update_callback(SpeedUpdate{ 0L });\n  assert_that(0L == auto_brake.get_speed_mps(), \"speed not saved to 0\");\n}\n```", "```\n[+] Test initial speed is 0 successful.\n[+] Test initial sensitivity is 5 successful.\n[+] Test sensitivity greater than 1 successful.\n[-] Test failure in speed is saved. bad function call.\n```", "```\nstruct AutoBrake {\n  AutoBrake(IServiceBus& bus)\n    : collision_threshold_s{ 5 },\n    speed_mps{} {\n    bus.subscribe([this](const SpeedUpdate& update) {\n      speed_mps = update.velocity_mps;\n    });\n  }\n  --snip--\n}\n```", "```\n[+] Test initial speed is 0 successful.\n[+] Test initial sensitivity is 5 successful.\n[+] Test sensitivity greater than 1 successful.\n[+] Test speed is saved successful.\n```", "```\nvoid no_alert_when_not_imminent() {\n  MockServiceBus bus{};\n  AutoBrake auto_brake{ bus };\n  auto_brake.set_collision_threshold_s(2L);\n  bus.speed_update_callback(SpeedUpdate{ 100L }); ➊\n  bus.car_detected_callback(CarDetected{ 1000L, 50L }); ➋\n  assert_that(bus.commands_published == 0, \"brake commands were published\");\n}\n```", "```\n[+] Test initial speed is 0 successful.\n[+] Test initial sensitivity is 5 successful.\n[+] Test sensitivity greater than 1 successful.\n[+] Test speed is saved successful.\n[-] Test failure in no alert when not imminent. bad function call.\n```", "```\nstruct AutoBrake {\n  AutoBrake(IServiceBus& bus)\n    : collision_threshold_s{ 5 },\n    speed_mps{} {\n    bus.subscribe([this](const SpeedUpdate& update) {\n      speed_mps = update.velocity_mps;\n    });\n    bus.subscribe([this➊, &bus➋](const CarDetected& cd) {\n      const auto relative_velocity_mps = speed_mps - cd.velocity_mps;\n      const auto time_to_collision_s = cd.distance_m / relative_velocity_mps;\n      if (time_to_collision_s > 0 &&\n          time_to_collision_s <= collision_threshold_s) {\n        bus.publish(BrakeCommand{ time_to_collision_s }); ➌\n      }\n    });\n  }\n  --snip--\n}\n```", "```\n[+] Test initial speed is 0 successful.\n[+] Test initial sensitivity is 5 successful.\n[+] Test sensitivity greater than 1 successful.\n[+] Test speed is saved successful.\n[+] Test no alert when not imminent successful.\n```", "```\nvoid alert_when_imminent() {\n  MockServiceBus bus{};\n  AutoBrake auto_brake{ bus };\n  auto_brake.set_collision_threshold_s(10L);\n  bus.speed_update_callback(SpeedUpdate{ 100L });\n  bus.car_detected_callback(CarDetected{ 100L, 0L });\n  assert_that(bus.commands_published == 1, \"1 brake command was not published\");\n  assert_that(bus.last_command.time_to_collision_s == 1L,\n              \"time to collision not computed correctly.\"); ➊\n}\n```", "```\n[+] Test initial speed is 0 successful.\n[+] Test initial sensitivity is 5 successful.\n[+] Test sensitivity greater than 1 successful.\n[+] Test speed is saved successful.\n[+] Test no alert when not imminent successful.\n[+] Test alert when imminent successful.\n```", "```\n#include <stdexcept>\n#include <cstdio>\n\nvoid assert_that(bool statement, const char* message) {\n  if (!statement) throw std::runtime_error{ message };\n}\n\nvoid run_test(void(*unit_test)(), const char* name) {\n  try {\n    unit_test();\n    printf(\"[+] Test %s successful.\\n\", name);\n    return;\n  } catch (const std::exception& e) {\n    printf(\"[-] Test failure in %s. %s.\\n\", name, e.what());\n  }\n}\n```", "```\n#define CATCH_CONFIG_MAIN\n#include \"catch.hpp\"\n```", "```\n#define CATCH_CONFIG_MAIN\n#include \"catch.hpp\"\n\nTEST_CASE(\"AutoBrake\") { ➊\n  // Unit test here\n}\n--------------------------------------------------------------------------\n==========================================================================\ntest cases: 1 | 1 passed ➊\nassertions: - none - ➋\n```", "```\nREQUIRE(assertion-expression);\n```", "```\n#define CATCH_CONFIG_MAIN\n#include \"catch.hpp\"\n#include <functional>\n\nstruct IServiceBus {\n  --snip--\n};\n\nstruct MockServiceBus : IServiceBus {\n  --snip--\n};\n\nstruct AutoBrake {\n  --snip--\n};\nTEST_CASE➊(\"initial car speed is zero\"➋) {\n  MockServiceBus bus{};\n  AutoBrake auto_brake{ bus };\n  REQUIRE(auto_brake.get_speed_mps() == 0); ➌\n}\n```", "```\nstruct AutoBrake {\n  AutoBrake(IServiceBus& bus)\n    : collision_threshold_s{ 5 }/*,\n    speed_mps{} */{ ➊\n  --snip--\n};\n```", "```\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ncatch_example.exe is a Catch v2.0.1 host application.\nRun with -? for options\n\n------------------------------------------------------------------------------\ninitial car speed is zero\n------------------------------------------------------------------------------\nc:\\users\\jalospinoso\\catch-test\\main.cpp(82)\n..............................................................................\n\nc:\\users\\jalospinoso\\catch-test\\main.cpp(85):➊ FAILED:\n  REQUIRE( auto_brake.get_speed_mps()L == 0 ) ➋\nwith expansion:\n  -92559631349317830736831783200707727132248687965119994463780864.0 ➌\n  ==\n  0\n\n==============================================================================\ntest cases: 1 | 1 failed\nassertions: 1 | 1 failed\n```", "```\n  try {\n    auto_brake.set_collision_threshold_s(0.5L);\n  } catch (const std::exception&) {\n    return;\n  }\n  assert_that(false, \"no exception thrown\");\n```", "```\nREQUIRE_THROWS(expression-to-evaluate);\n```", "```\nTEST_CASE(\"AutoBrake\") {\n  MockServiceBus bus{};\n  AutoBrake auto_brake{ bus };\n  REQUIRE(auto_brake.get_collision_threshold_s() == Approx(5L));\n}\n```", "```\nif (something-bad) FAIL(\"Something bad happened.\")\n```", "```\n  MockServiceBus bus{};\n  AutoBrake auto_brake{ bus };\n```", "```\nTEST_CASE(\"MyTestGroup\") {\n  // Setup code goes here ➊\n  SECTION(\"MyTestA\") { ➋\n    // Code for Test A\n  }\n  SECTION(\"MyTestB\") { ➌\n    // Code for Test B\n  }\n}\n```", "```\n#define CATCH_CONFIG_MAIN\n#include \"catch.hpp\"\n#include <functional>\n#include <stdexcept>\n\nstruct IServiceBus {\n  --snip--\n};\n\nstruct MockServiceBus : IServiceBus {\n  --snip--\n};\n\nstruct AutoBrake {\n  --snip--\n};\n\nTEST_CASE(\"AutoBrake\"➊) {\n  MockServiceBus bus{}; ➋\n  AutoBrake auto_brake{ bus }; ➌\n\n  SECTION➍(\"initializes speed to zero\"➎) {\n    REQUIRE(auto_brake.get_speed_mps() == Approx(0));\n  }\n\n  SECTION(\"initializes sensitivity to five\") {\n    REQUIRE(auto_brake.get_collision_threshold_s() == Approx(5));\n  }\n\n  SECTION(\"throws when sensitivity less than one\") {\n    REQUIRE_THROWS(auto_brake.set_collision_threshold_s(0.5L));\n  }\n\n  SECTION(\"saves speed after update\") {\n    bus.speed_update_callback(SpeedUpdate{ 100L });\n    REQUIRE(100L == auto_brake.get_speed_mps());\n    bus.speed_update_callback(SpeedUpdate{ 50L });\n    REQUIRE(50L == auto_brake.get_speed_mps());\n    bus.speed_update_callback(SpeedUpdate{ 0L });\n    REQUIRE(0L == auto_brake.get_speed_mps());\n  }\n\n  SECTION(\"no alert when not imminent\") {\n    auto_brake.set_collision_threshold_s(2L);\n    bus.speed_update_callback(SpeedUpdate{ 100L });\n    bus.car_detected_callback(CarDetected{ 1000L, 50L });\n    REQUIRE(bus.commands_published == 0);\n  }\n\n  SECTION(\"alert when imminent\") {\n    auto_brake.set_collision_threshold_s(10L);\n bus.speed_update_callback(SpeedUpdate{ 100L });\n    bus.car_detected_callback(CarDetected{ 100L, 0L });\n    REQUIRE(bus.commands_published == 1);\n    REQUIRE(bus.last_command.time_to_collision_s == Approx(1));\n  }\n}\n------------------------------------------------------------------------------\n==============================================================================\nAll tests passed (9 assertions in 1 test case)\n```", "```\n#include \"gtest/gtest.h\" ➊\n\nTEST➋(AutoBrake➌, UnitTestName➍) {\n  // Unit test here ➎\n}\n--------------------------------------------------------------------------\nRunning main() from gtest_main.cc ➏\n[==========] Running 1 test from 1 test case.\n[----------] Global test environment set-up.\n[----------] 1 test from AutoBrake\n[ RUN      ] AutoBrake.UnitTestName\n[       OK ] AutoBrake.UnitTestName (0 ms)\n[----------] 1 test from AutoBrake (0 ms total)\n\n[----------] Global test environment tear-down\n[==========] 1 test from 1 test case ran. (1 ms total)\n[  PASSED  ] 1 test. ➐\n```", "```\n#include \"gtest/gtest.h\"\n#include <functional>\n\nstruct IServiceBus {\n  --snip--\n};\n\nstruct MockServiceBus : IServiceBus {\n  --snip--\n};\n\nstruct AutoBrake {\n  AutoBrake(IServiceBus& bus)\n    : collision_threshold_s{ 5 }/*,\n    speed_mps{} */ {\n  --snip--\n};\nTEST➊(AutoBrakeTest➋, InitialCarSpeedIsZero➌) {\n  MockServiceBus bus{};\n  AutoBrake auto_brake{ bus };\n  ASSERT_FLOAT_EQ➍(0➎, auto_brake.get_speed_mps()➏);\n}\n--------------------------------------------------------------------------\nRunning main() from gtest_main.cc\n[==========] Running 1 test from 1 test case.\n[----------] Global test environment set-up.\n[----------] 1 test from AutoBrakeTest\n[ RUN      ] AutoBrakeTest.InitialCarSpeedIsZero\nC:\\Users\\josh\\AutoBrake\\gtest.cpp(80): error: Expected equality of these values:\n 0 ➎\n auto_brake.get_speed_mps()➏\n Which is: -inf\n[  FAILED  ] AutoBrakeTest➋.InitialCarSpeedIsZero➌ (5 ms)\n[----------] 1 test from AutoBrakeTest (5 ms total)\n\n[----------] Global test environment tear-down\n[==========] 1 test from 1 test case ran. (7 ms total)\n[  PASSED  ] 0 tests.\n[  FAILED  ] 1 test, listed below:\n[  FAILED  ] AutoBrakeTest.InitialCarSpeedIsZero\n\n 1 FAILED TEST\n```", "```\n#include \"gtest/gtest.h\"\n\nstruct MyTestFixture➊ : ::testing::Test➋ { };\n\nTEST_F(MyTestFixture➌, MyTestA➍) {\n  // Test A here\n}\n\nTEST_F(MyTestFixture, MyTestB➎) {\n  // Test B here\n}\n--------------------------------------------------------------------------\nRunning main() from gtest_main.cc\n[==========] Running 2 tests from 1 test case.\n[----------] Global test environment set-up.\n[----------] 2 tests from MyTestFixture\n[ RUN      ] MyTestFixture.MyTestA\n[       OK ] MyTestFixture.MyTestA (0 ms)\n[ RUN      ] MyTestFixture.MyTestB\n[       OK ] MyTestFixture.MyTestB (0 ms)\n[----------] 2 tests from MyTestFixture (1 ms total)\n\n[----------] Global test environment tear-down\n[==========] 2 tests from 1 test case ran. (3 ms total)\n[  PASSED  ] 2 tests.\n```", "```\n#include \"gtest/gtest.h\"\n#include <functional>\n\nstruct IServiceBus {\n  --snip--\n};\n\nstruct MockServiceBus : IServiceBus {\n  --snip--\n};\n\nstruct AutoBrake {\n  --snip--\n};\n\nstruct AutoBrakeTest : ::testing::Test { ➊\n  MockServiceBus bus{};\n  AutoBrake auto_brake { bus };\n};\n\nTEST_F➋(AutoBrakeTest➌, InitialCarSpeedIsZero➍) {\n  ASSERT_DOUBLE_EQ(0, auto_brake.get_speed_mps()); ➎\n}\n\nTEST_F(AutoBrakeTest, InitialSensitivityIsFive) {\n  ASSERT_DOUBLE_EQ(5, auto_brake.get_collision_threshold_s());\n}\n\nTEST_F(AutoBrakeTest, SensitivityGreaterThanOne) {\n  ASSERT_ANY_THROW(auto_brake.set_collision_threshold_s(0.5L)); ➏\n}\n TEST_F(AutoBrakeTest, SpeedIsSaved) {\n  bus.speed_update_callback(SpeedUpdate{ 100L });\n  ASSERT_EQ(100, auto_brake.get_speed_mps());\n  bus.speed_update_callback(SpeedUpdate{ 50L });\n  ASSERT_EQ(50, auto_brake.get_speed_mps());\n  bus.speed_update_callback(SpeedUpdate{ 0L });\n  ASSERT_DOUBLE_EQ(0, auto_brake.get_speed_mps());\n}\n\nTEST_F(AutoBrakeTest, NoAlertWhenNotImminent) {\n  auto_brake.set_collision_threshold_s(2L);\n  bus.speed_update_callback(SpeedUpdate{ 100L });\n  bus.car_detected_callback(CarDetected{ 1000L, 50L });\n  ASSERT_EQ(0, bus.commands_published);\n}\n\nTEST_F(AutoBrakeTest, AlertWhenImminent) {\n  auto_brake.set_collision_threshold_s(10L);\n  bus.speed_update_callback(SpeedUpdate{ 100L });\n  bus.car_detected_callback(CarDetected{ 100L, 0L });\n  ASSERT_EQ(1, bus.commands_published);\n  ASSERT_DOUBLE_EQ(1L, bus.last_command.time_to_collision_s);\n}\n--------------------------------------------------------------------------\nRunning main() from gtest_main.cc\n[==========] Running 6 tests from 1 test case.\n[----------] Global test environment set-up.\n[----------] 6 tests from AutoBrakeTest\n[ RUN      ] AutoBrakeTest.InitialCarSpeedIsZero\n[       OK ] AutoBrakeTest.InitialCarSpeedIsZero (0 ms)\n[ RUN      ] AutoBrakeTest.InitialSensitivityIsFive\n[       OK ] AutoBrakeTest.InitialSensitivityIsFive (0 ms)\n[ RUN      ] AutoBrakeTest.SensitivityGreaterThanOne\n[       OK ] AutoBrakeTest.SensitivityGreaterThanOne (1 ms)\n[ RUN      ] AutoBrakeTest.SpeedIsSaved\n[       OK ] AutoBrakeTest.SpeedIsSaved (0 ms)\n[ RUN      ] AutoBrakeTest.NoAlertWhenNotImminent\n[       OK ] AutoBrakeTest.NoAlertWhenNotImminent (1 ms)\n[ RUN      ] AutoBrakeTest.AlertWhenImminent\n[       OK ] AutoBrakeTest.AlertWhenImminent (0 ms)\n[----------] 6 tests from AutoBrakeTest (3 ms total)\n\n[----------] Global test environment tear-down\n[==========] 6 tests from 1 test case ran. (4 ms total)\n[  PASSED  ] 6 tests.\n```", "```\n#define BOOST_TEST_MODULE test_module_name\n#include <boost/test/included/unit_test.hpp>\n```", "```\n#include <boost/test/unit_test.hpp>\n```", "```\n#define BOOST_TEST_MODULE AutoBrake\n#include <boost/test/unit_test.hpp>\n```", "```\n#define BOOST_TEST_DYN_LINK\n#include <boost/test/unit_test.hpp>\n```", "```\n#define BOOST_TEST_MODULE AutoBrake\n#define BOOST_TEST_DYN_LINK\n#include <boost/test/unit_test.hpp>\n```", "```\n#define BOOST_TEST_MODULE TestModuleName ➊\n#include <boost/test/unit_test.hpp> ➋\n\nBOOST_AUTO_TEST_CASE➌(TestA➍) {\n  // Unit Test A here ➎\n}\n--------------------------------------------------------------------------\nRunning 1 test case...\n\n*** No errors detected\n```", "```\nBOOST_TEST(assertion-expression)\n```", "```\nBOOST_REQUIRE_THROW(expression, desired-exception-type);\n```", "```\n#define BOOST_TEST_MODULE AutoBrakeTest ➊\n#include <boost/test/unit_test.hpp>\n#include <functional>\n\nstruct IServiceBus {\n  --snip--\n};\n\nstruct MockServiceBus : IServiceBus {\n  --snip--\n};\n\nstruct AutoBrake {\n  AutoBrake(IServiceBus& bus)\n    : collision_threshold_s{ 5 }/*,\n      speed_mps{} */➋ {\n  --snip--\n};\n\nBOOST_AUTO_TEST_CASE(InitialCarSpeedIsZero➌) {\n  MockServiceBus bus{};\n  AutoBrake auto_brake{ bus };\n  BOOST_TEST(0 == auto_brake.get_speed_mps()); ➍\n}\n--------------------------------------------------------------------------\nRunning 1 test case...\nC:/Users/josh/projects/cpp-book/manuscript/part_2/10-testing/samples/boost/\nminimal.cpp(80): error: in \"InitialCarSpeedIsZero\": check 0 == auto_brake.\nget_speed_mps() has failed [0 != -9.2559631349317831e+61] ➎\n*** 1 failure is detected in the test module \"AutoBrakeTest\"\n```", "```\n#define BOOST_TEST_MODULE TestModuleName\n#include <boost/test/unit_test.hpp>\n\nstruct MyTestFixture { }; ➊\n\nBOOST_FIXTURE_TEST_CASE➋(MyTestA➌, MyTestFixture) {\n  // Test A here\n}\n\nBOOST_FIXTURE_TEST_CASE(MyTestB➍, MyTestFixture) {\n  // Test B here\n}\n--------------------------------------------------------------------------\nRunning 2 test cases...\n\n*** No errors detected\n```", "```\n#define BOOST_TEST_MODULE AutoBrakeTest\n#include <boost/test/unit_test.hpp>\n#include <functional>\n\nstruct IServiceBus {\n  --snip--\n};\n\nstruct MockServiceBus : IServiceBus {\n  --snip--\n};\n\nstruct AutoBrakeTest { ➊\n  MockServiceBus bus{};\n  AutoBrake auto_brake{ bus };\n};\n\nBOOST_FIXTURE_TEST_CASE➋(InitialCarSpeedIsZero, AutoBrakeTest) {\n  BOOST_TEST(0 == auto_brake.get_speed_mps());\n}\nBOOST_FIXTURE_TEST_CASE(InitialSensitivityIsFive, AutoBrakeTest) {\n  BOOST_TEST(5 == auto_brake.get_collision_threshold_s());\n}\n\nBOOST_FIXTURE_TEST_CASE(SensitivityGreaterThanOne, AutoBrakeTest) {\n  BOOST_REQUIRE_THROW(auto_brake.set_collision_threshold_s(0.5L),\n                      std::exception);\n}\n\nBOOST_FIXTURE_TEST_CASE(SpeedIsSaved, AutoBrakeTest) {\n  bus.speed_update_callback(SpeedUpdate{ 100L });\n  BOOST_TEST(100 == auto_brake.get_speed_mps());\n  bus.speed_update_callback(SpeedUpdate{ 50L });\n  BOOST_TEST(50 == auto_brake.get_speed_mps());\n  bus.speed_update_callback(SpeedUpdate{ 0L });\n  BOOST_TEST(0 == auto_brake.get_speed_mps());\n}\n\nBOOST_FIXTURE_TEST_CASE(NoAlertWhenNotImminent, AutoBrakeTest) {\n  auto_brake.set_collision_threshold_s(2L);\n  bus.speed_update_callback(SpeedUpdate{ 100L });\n  bus.car_detected_callback(CarDetected{ 1000L, 50L });\n  BOOST_TEST(0 == bus.commands_published);\n}\n\nBOOST_FIXTURE_TEST_CASE(AlertWhenImminent, AutoBrakeTest) {\n  auto_brake.set_collision_threshold_s(10L);\n  bus.speed_update_callback(SpeedUpdate{ 100L });\n  bus.car_detected_callback(CarDetected{ 100L, 0L });\n  BOOST_TEST(1 == bus.commands_published);\n  BOOST_TEST(1L == bus.last_command.time_to_collision_s);\n}\n--------------------------------------------------------------------------\nRunning 6 test cases...\n\n*** No errors detected\n```", "```\nstruct MockServiceBus : IServiceBus {\n  void publish(const BrakeCommand& cmd) override {\n    commands_published++;\n    last_command = cmd;\n  };\n  void subscribe(SpeedUpdateCallback callback) override {\n    speed_update_callback = callback;\n  };\n  void subscribe(CarDetectedCallback callback) override {\n    car_detected_callback = callback;\n  };\n  BrakeCommand last_command{};\n  int commands_published{};\n  SpeedUpdateCallback speed_update_callback{};\n  CarDetectedCallback car_detected_callback{};\n};\n```", "```\n#include \"gmock/gmock.h\"\n\nint main(int argc, char** argv) {\n  ::testing::GTEST_FLAG(throw_on_failure) = true; ➊\n  ::testing::InitGoogleMock(&argc, argv); ➋\n  // Unit test as usual, Google Mock is initialized\n}\n```", "```\nstruct MockServiceBus : IServiceBus { ➊\n  MOCK_METHOD1➋(publish➌, void(const BrakeCommand& cmd)➍);\n  MOCK_METHOD1(subscribe, void(SpeedUpdateCallback callback));\n  MOCK_METHOD1(subscribe, void(CarDetectedCallback callback));\n};\n```", "```\nEXPECT_CALL(mock_object, method(matchers))\n```", "```\nMockServiceBus naggy_mock➊;\n::testing::NiceMock<MockServiceBus> nice_mock➋;\n::testing::StrictMock<MockServiceBus> strict_mock➌;\n```", "```\n--snip--\nusing ::testing::_; ➊\n\nTEST(AutoBrakeTest, PublishIsCalled) {\n  MockServiceBus bus;\n  EXPECT_CALL(bus, publish(_➋));\n  --snip--\n}\n```", "```\n--snip--\nusing ::testing::A; ➊\n\nTEST(AutoBrakeTest, PublishIsCalled) {\n  MockServiceBus bus;\n  EXPECT_CALL(bus, publish(A<BrakeCommand>()➋));\n  --snip--\n}\n```", "```\n--snip--\nusing ::testing::Field; ➊\nusing ::testing::DoubleEq; ➋\n\nTEST(AutoBrakeTest, PublishIsCalled) {\n  MockServiceBus bus;\n  EXPECT_CALL(bus, publish(Field(&BrakeCommand::time_to_collision_s➌,\n                                 DoubleEq(1L)➍)));\n  --snip--\n}\n```", "```\nASSERT_GT(power_level, 9000);\n```", "```\nASSERT_THAT(power_level, Gt(9000));\n```", "```\n--snip--\nusing ::testing::Field;\nusing ::testing::DoubleEq;\n\nTEST(AutoBrakeTest, PublishIsCalled) {\n  MockServiceBus bus;\n  EXPECT_CALL(bus, publish(Field(&BrakeCommand::time_to_collision_s,\n                                 DoubleEq(1L)))).Times(1)➊;\n  --snip--\n}\n```", "```\nEXPECT_CALL(jenny_mock, get_your_number()) ➊\n  .WillOnce(Return(8675309)) ➋\n  .WillRepeatedly(Return(911))➌;\n```", "```\nCarDetectedCallback callback; ➊\nEXPECT_CALL(bus, subscribe(A<CarDetectedCallback>()))\n    .Times(1)\n    .WillOnce(Invoke([&callback➋](const auto& callback_in➌) {\n      callback = callback_in; ➍\n    }));\n```", "```\n#include \"gtest/gtest.h\"\n#include \"gmock/gmock.h\"\n#include <functional>\n\nusing ::testing::_;\nusing ::testing::A;\nusing ::testing::Field;\nusing ::testing::DoubleEq;\nusing ::testing::NiceMock;\nusing ::testing::StrictMock;\nusing ::testing::Invoke;\n\nstruct NiceAutoBrakeTest : ::testing::Test { ➊\n  NiceMock<MockServiceBus> bus;\n  AutoBrake auto_brake{ bus };\n};\n\nstruct StrictAutoBrakeTest : ::testing::Test { ➋\n  StrictAutoBrakeTest() {\n    EXPECT_CALL(bus, subscribe(A<CarDetectedCallback>())) ➌\n      .Times(1)\n      .WillOnce(Invoke([this](const auto& x) {\n        car_detected_callback = x;\n      }));\n    EXPECT_CALL(bus, subscribe(A<SpeedUpdateCallback>())) ➍\n      .Times(1)\n      .WillOnce(Invoke([this](const auto& x) {\n        speed_update_callback = x;\n      }));;\n  }\n  CarDetectedCallback car_detected_callback;\n  SpeedUpdateCallback speed_update_callback;\n  StrictMock<MockServiceBus> bus;\n};\n\nTEST_F(NiceAutoBrakeTest, InitialCarSpeedIsZero) {\n  ASSERT_DOUBLE_EQ(0, auto_brake.get_speed_mps());\n}\n\nTEST_F(NiceAutoBrakeTest, InitialSensitivityIsFive) {\n  ASSERT_DOUBLE_EQ(5, auto_brake.get_collision_threshold_s());\n}\n\nTEST_F(NiceAutoBrakeTest, SensitivityGreaterThanOne) {\n  ASSERT_ANY_THROW(auto_brake.set_collision_threshold_s(0.5L));\n}\n\nTEST_F(StrictAutoBrakeTest, NoAlertWhenNotImminent) {\n  AutoBrake auto_brake{ bus };\n\n  auto_brake.set_collision_threshold_s(2L);\n  speed_update_callback(SpeedUpdate{ 100L });\n  car_detected_callback(CarDetected{ 1000L, 50L });\n}\n\nTEST_F(StrictAutoBrakeTest, AlertWhenImminent) {\n  EXPECT_CALL(bus, publish(\n                       Field(&BrakeCommand::time_to_collision_s, DoubleEq{ 1L\n}))\n                   ).Times(1);\n  AutoBrake auto_brake{ bus };\n  auto_brake.set_collision_threshold_s(10L);\n  speed_update_callback(SpeedUpdate{ 100L });\n  car_detected_callback(CarDetected{ 100L, 0L });\n}\n```", "```\nMockRepository mocks;\nmocks.autoExpect = false;\n```", "```\nauto* bus = mocks.Mock<IServiceBus>();\n```", "```\nmocks.ExpectCall(bus, IServiceBus::subscribe_to_speed)\n```", "```\nmocks.ExpectCall➊(bus, IServiceBus::publish)\n  .Match➋([](const BrakeCommand& cmd) {\n    return cmd.time_to_collision_s == Approx(1); ➌\n  });\n```", "```\nstruct IServiceBus {\n  virtual ~IServiceBus() = default;\n  virtual void publish(const BrakeCommand&) = 0;\n  virtual void subscribe_to_speed(SpeedUpdateCallback) = 0;\n  virtual void subscribe_to_car_detected(CarDetectedCallback) = 0;\n};\n```", "```\n#include \"hippomocks.h\"\n--snip--\nTEST_CASE(\"AutoBrake\") {\n  MockRepository mocks; ➊\n  mocks.autoExpect = false;\n  CarDetectedCallback car_detected_callback;\n  SpeedUpdateCallback speed_update_callback;\n  auto* bus = mocks.Mock<IServiceBus>();\n  mocks.ExpectCall(bus, IServiceBus::subscribe_to_speed) ➋\n    .Do([&](const auto& x) {\n      speed_update_callback = x;\n    });\n  mocks.ExpectCall(bus, IServiceBus::subscribe_to_car_detected) ➌\n    .Do([&](const auto& x) {\n    car_detected_callback = x;\n  });\n  AutoBrake auto_brake{ *bus };\n\n  SECTION(\"initializes speed to zero\") {\n    REQUIRE(auto_brake.get_speed_mps() == Approx(0));\n  }\n\n  SECTION(\"initializes sensitivity to five\") {\n    REQUIRE(auto_brake.get_collision_threshold_s() == Approx(5));\n  }\n\n  SECTION(\"throws when sensitivity less than one\") {\n    REQUIRE_THROWS(auto_brake.set_collision_threshold_s(0.5L));\n  }\n\n  SECTION(\"saves speed after update\") {\n    speed_update_callback(SpeedUpdate{ 100L }); ➍\n    REQUIRE(100L == auto_brake.get_speed_mps());\n    speed_update_callback(SpeedUpdate{ 50L });\n    REQUIRE(50L == auto_brake.get_speed_mps());\n    speed_update_callback(SpeedUpdate{ 0L });\n    REQUIRE(0L == auto_brake.get_speed_mps());\n  }\n\n  SECTION(\"no alert when not imminent\") {\n    auto_brake.set_collision_threshold_s(2L);\n    speed_update_callback(SpeedUpdate{ 100L }); ➎\n    car_detected_callback(CarDetected{ 1000L, 50L });\n  }\n\n  SECTION(\"alert when imminent\") {\n    mocks.ExpectCall(bus, IServiceBus::publish) ➏\n      .Match([](const auto& cmd) {\n        return cmd.time_to_collision_s == Approx(1);\n      });\n\n    auto_brake.set_collision_threshold_s(10L);\n    speed_update_callback(SpeedUpdate{ 100L });\n car_detected_callback(CarDetected{ 100L, 0L });\n  }\n}\n```", "```\nstruct SpeedLimitDetected {\n  unsigned short speed_mps;\n}\n```", "```\n#include <functional>\n--snip--\nusing SpeedUpdateCallback = std::function<void(const SpeedUpdate&)>;\nusing CarDetectedCallback = std::function<void(const CarDetected&)>;\nusing SpeedLimitCallback = std::function<void(const SpeedLimitDetected&)>;\n\nstruct IServiceBus {\n  virtual ~IServiceBus() = default;\n  virtual void publish(const BrakeCommand&) = 0;\n  virtual void subscribe(SpeedUpdateCallback) = 0;\n  virtual void subscribe(CarDetectedCallback) = 0;\n  virtual void subscribe(SpeedLimitCallback) = 0;\n};\n```"]