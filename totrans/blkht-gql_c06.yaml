- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Information Disclosure
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 信息泄露
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Information disclosure vulnerabilities* arise when software systems, such
    as APIs, reveal sensitive information to unauthorized users. Much like REST-based
    applications, GraphQL is not immune to this type of issue. In this chapter, we’ll
    use its built-in features to gain additional insight into applications and the
    data they protect.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*信息泄露漏洞* 出现的原因是软件系统（如 API）将敏感信息泄露给未经授权的用户。与基于 REST 的应用程序类似，GraphQL 也无法避免这种问题。在本章中，我们将利用其内置功能深入了解应用程序及其保护的数据。'
- en: Sensitive data exposure is one of the most impactful attacks against APIs. Devastating
    vulnerabilities can leak all kinds of information to potential attackers, including
    business information, intellectual property, the PII of customers, and more. Even
    unintentionally disclosing technical information, such as the application source
    code, operating system version, and filesystem paths, can be just as serious.
    These disclosures may reveal additional attack vectors for us to exploit.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 敏感数据泄露是对 API 的最具破坏性的攻击之一。严重的漏洞可能泄露各种信息给潜在攻击者，包括商业信息、知识产权、客户的个人身份信息（PII）等。即使是无意间泄露的技术信息，如应用程序源代码、操作系统版本和文件系统路径，也可能同样严重。这些泄露可能揭示出其他可供我们利用的攻击向量。
- en: We’ll explore how we can abuse field suggestions to extract and map the GraphQL
    schema regardless of whether introspection is enabled. You’ll also learn to discover
    local users, operating systems, filesystem structures, and application details
    by probing GraphQL error messages, debug logs, and application stack traces.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何利用字段建议来提取和映射 GraphQL 模式，无论内省是否启用。你还将学习如何通过探测 GraphQL 错误消息、调试日志和应用程序堆栈跟踪来发现本地用户、操作系统、文件系统结构和应用程序详细信息。
- en: As you search for useful information, remember that vulnerabilities can often
    be chained together. A low-severity vulnerability used with another, higher-severity
    vulnerability might completely compromise an application. Collect as much information
    as you can about your target, and make sure to keep track of it; you never know
    when it will come in handy.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找有用信息时，请记住，漏洞往往是可以串联起来利用的。一个低危漏洞与另一个高危漏洞结合使用，可能会完全危害应用程序。尽可能多地收集目标的信息，并确保将其记录下来；你永远不知道什么时候它会派上用场。
- en: Identifying Information Disclosure Vectors in GraphQL
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别 GraphQL 中的信息泄露向量
- en: Many architectural-, technical-, and process-level mistakes could introduce
    information disclosure vulnerabilities. Common failures include incorrect or missing
    data-classification processes, an absence of data encryption in sensitive networks
    and applications, and a lack of access-management controls on critical functions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 许多架构、技术和流程级别的错误可能导致信息泄露漏洞。常见的失败包括不正确或缺失的数据分类过程、敏感网络和应用程序中缺乏数据加密、以及关键功能缺乏访问管理控制。
- en: Other large contributors to information disclosure attacks are software systems
    that store and provide API consumers with more data than necessary. Often, when
    you’re inspecting the responses of frontend applications backed by APIs, you’ll
    notice that they return more information than the frontend actually uses. Usually,
    this is a sign that the application may contain additional information disclosure
    vulnerabilities. It also indicates that the application was shipped without sufficient
    security review.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个信息泄露攻击的重要原因是软件系统存储并向 API 消费者提供超过必要数据的情况。通常，当你检查由 API 支持的前端应用程序的响应时，你会发现它们返回了前端实际上并未使用的更多信息。这通常表明应用程序可能存在额外的信息泄露漏洞，也表明该应用程序在发布时缺乏充分的安全审查。
- en: In GraphQL, one of the most efficient ways to extract sensitive information
    from an application is to explore its schema, which provides context about the
    application’s data structure and business logic. The best way to do so is to use
    the GraphQL introspection feature. Most GraphQL implementations are shipped with
    introspection enabled by default.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphQL 中，从应用程序中提取敏感信息的最有效方法之一是探索其模式，模式提供了关于应用程序数据结构和业务逻辑的上下文。实现这一点的最佳方法是使用
    GraphQL 内省功能。大多数 GraphQL 实现默认启用了内省功能。
- en: However, during your hacking adventures, you may come across GraphQL implementations
    with introspection disabled. To overcome this, you can run field-stuffing attacks
    and use automated tools designed to abuse the widely adopted field suggestion
    feature. You can also gain user and operating-level information by actively probing
    GraphQL’s debug, error, and stack trace logs. We’ll explore all of this in this
    chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在你的黑客冒险过程中，你可能会遇到禁用 introspection 的 GraphQL 实现。为了克服这一点，你可以进行字段填充攻击，并使用专门设计的自动化工具来滥用广泛采用的字段建议功能。你还可以通过主动探测
    GraphQL 的调试、错误和堆栈跟踪日志来获得用户和操作级别的信息。我们将在本章中探讨这一切。
- en: Automating Schema Extraction with InQL
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 InQL 自动化模式提取
- en: In previous chapters, we used introspection queries to manually uncover information
    such as the API’s available queries and mutations. To make our lives even easier,
    tools such as InQL (installed in Chapter 2) allow you to automatically extract
    the schema.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们使用 introspection 查询手动揭示 API 的可用查询和突变等信息。为了让我们的工作更加轻松，像 InQL（在第 2 章中安装）这样的工具可以帮助你自动提取模式。
- en: InQL uses a single introspection query very similar to the one used in Chapter
    4. From the results, it generates a schema document in several formats, including
    HTML, JSON, and tab-separated values (TSV). You can use these documents alongside
    tools like GraphQL Voyager to further analyze the schema.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: InQL 使用一个非常类似于第 4 章中使用的 introspection 查询。从结果中，它生成一个模式文档，格式包括 HTML、JSON 和制表符分隔值（TSV）。你可以将这些文档与
    GraphQL Voyager 等工具一起使用，进一步分析模式。
- en: 'Extract and analyze DVGA’s schema by executing the following command. The `-t`
    (target) flag points to DVGA’s network address. We generate a report using the
    TSV format (`--generate-tsv`):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令提取并分析 DVGA 的模式。`-t`（目标）标志指向 DVGA 的网络地址。我们使用 TSV 格式（`--generate-tsv`）生成报告：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'InQL will use the name of the target domain to automatically create a directory.
    If you list its contents, you should see multiple schema files:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: InQL 将使用目标域的名称自动创建一个目录。如果你列出其内容，你应该能看到多个模式文件：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These TSV files are tab separated, making it easy to see which queries are
    available in DVGA. Using `awk`, we can parse only the query names:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 TSV 文件是以制表符分隔的，便于查看 DVGA 中可用的查询。使用 `awk`，我们可以解析出查询名称：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To see which arguments the various queries support, you can issue the following
    `awk` command to parse the tab-delimiter output:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看各种查询支持哪些参数，你可以执行以下 `awk` 命令来解析制表符分隔的输出：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To view mutations or subscription-related queries, simply use the same `awk`
    command against the *endpoint_mutation.tsv* and *endpoint_subscription.tsv* files*.*
    Searching InQL’s generated documents for queries, mutations, or subscriptions,
    along with their arguments, types, and other schema-related information, is useful
    if you want to automate certain tasks from the command line, such as fuzzing,
    brute-forcing, or searching for sensitive information.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看突变或订阅相关的查询，只需使用相同的 `awk` 命令处理 *endpoint_mutation.tsv* 和 *endpoint_subscription.tsv*
    文件。搜索 InQL 生成的文档中的查询、突变或订阅，以及它们的参数、类型和其他模式相关信息，对于你想要从命令行自动化某些任务（如模糊测试、暴力破解或查找敏感信息）非常有用。
- en: Overcoming Disabled Introspection
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克服禁用的 introspection
- en: Even if a GraphQL implementation uses introspection by default, developers might
    disable it to avoid exposing information about their schema to clients. This makes
    it harder to understand how to interact with the API, but, as you will soon see,
    not completely impossible. We can use a variety of techniques and specially crafted
    queries to peek into the key elements of an application’s schema, even when introspection
    is turned off.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个 GraphQL 实现默认启用 introspection，开发者也可能会禁用它，以避免向客户端暴露关于其模式的信息。这会使得理解如何与 API
    交互变得更加困难，但正如你将很快看到的，完全不是不可能。我们可以使用多种技术和特制的查询，即使在禁用 introspection 的情况下，也能窥探应用程序模式的关键元素。
- en: Detecting Disabled Introspection
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测禁用的 introspection
- en: In Chapter 4, we discussed using the `__schema` meta-field to detect introspection.
    If introspection is disabled, such a query should return an error. Every GraphQL
    implementation will handle this error response differently. For example, some
    implementations could return a *400 Bad Request* HTTP response code without any
    informative error message, while other implementations may choose to return a
    *200 OK* status code with a message like `Introspection is Disabled`. Usually,
    GraphQL servers tend to return a *200 OK* response with an error message in the
    `errors` response key.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章中，我们讨论了如何使用 `__schema` 元数据字段来检测 introspection。如果禁用了 introspection，类似的查询应该返回一个错误。每个
    GraphQL 实现会以不同的方式处理这个错误响应。例如，一些实现可能会返回 *400 错误请求* HTTP 响应代码而没有任何详细的错误信息，而其他实现可能会选择返回
    *200 成功* 状态码，并附带如 `Introspection is Disabled` 的消息。通常，GraphQL 服务器倾向于返回 *200 成功*
    响应，并在 `errors` 响应键中附带错误信息。
- en: '[Listing 6-1](#listing6-1) is an error message you might encounter when sending
    an introspection query to Apollo Server, a popular GraphQL server implementation.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-1](#listing6-1) 是你在向 Apollo Server 发送 introspection 查询时可能遇到的错误信息，Apollo
    Server 是一个流行的 GraphQL 服务器实现。'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 6-1: The `introspection` `is` `not` `allowed` message from the Apollo
    GraphQL server'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-1：来自 Apollo GraphQL 服务器的 `introspection` `is` `not` `allowed` 消息
- en: In the following two sections, we test disclosure techniques that allow us to
    bypass improperly disabled introspection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分，我们将测试一些揭露技术，帮助我们绕过错误禁用的 introspection。
- en: Exploiting Non-production Environments
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用非生产环境
- en: In some applications, the development and staging environments won’t have the
    same level of security as the production environment. Even if introspection is
    disabled in the production environment, you might find it enabled in other environments,
    where it can assist engineers with building, updating, testing, and maintaining
    their APIs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些应用程序中，开发环境和暂存环境的安全级别可能低于生产环境。即使在生产环境中禁用了 introspection，你也可能发现它在其他环境中是启用的，这有助于工程师构建、更新、测试和维护他们的
    API。
- en: Typically, non-production environments are hosted on subdomains such as *staging*
    or *dev*. It will be worth checking if those environments are accessible to us,
    and if any GraphQL services may have introspection enabled. You can find a list
    of potential GraphQL staging and development locations at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/resources/non-production-graphql-urls.txt](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/resources/non-production-graphql-urls.txt).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，非生产环境托管在像 *staging* 或 *dev* 这样的子域名上。检查这些环境是否对我们开放，并查看是否有任何 GraphQL 服务可能启用了
    introspection，是值得的。你可以在 [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/resources/non-production-graphql-urls.txt](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/resources/non-production-graphql-urls.txt)
    找到潜在的 GraphQL 暂存和开发位置列表。
- en: If we’re able to successfully run introspection queries against staging and
    development environments, we can take the information learned there and apply
    it to the production environment. Often the schemas will be similar.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够成功地在暂存和开发环境中运行 introspection 查询，我们可以将所学到的信息应用到生产环境中。通常，模式会是相似的。
- en: Exploiting the __type Meta-field
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用 __type 元数据字段
- en: When GraphQL implementations want to block introspection queries from executing,
    they often filter out any requests that contain the keyword `__schema`. However,
    while most introspection queries leverage the `__schema` meta-field, clients could
    also use several other introspection meta-fields. For instance, `__type` represents
    all types in the system and could be used to extract type details from a GraphQL
    schema.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当 GraphQL 实现想要阻止 introspection 查询执行时，通常会过滤掉包含 `__schema` 关键字的请求。然而，尽管大多数 introspection
    查询利用了 `__schema` 元数据字段，客户端也可以使用其他几个 introspection 元数据字段。例如，`__type` 代表系统中的所有类型，可以用来从
    GraphQL 模式中提取类型详情。
- en: In May 2022, we discovered a vulnerability in AppSync, an Amazon Web Services
    (AWS) service that provides a GraphQL interface for developers. To protect AppSync
    from malicious clients, AWS uses a WAF under the hood. We identified a way to
    bypass the WAF and perform an introspection query. The WAF contains rules tailored
    to GraphQL applications, one of which blocks attempts to introspect the GraphQL
    API via the `__schema` meta-field but doesn’t take into consideration other introspection
    meta-fields.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在2022年5月，我们发现了一个漏洞，涉及Amazon Web Services（AWS）提供的GraphQL接口服务AppSync。为了保护AppSync免受恶意客户端的攻击，AWS在后台使用了WAF。我们找到了一种绕过WAF并执行反射查询的方法。WAF包含专门针对GraphQL应用程序的规则，其中之一会阻止通过`__schema`元字段对GraphQL
    API进行反射查询，但没有考虑其他反射元字段。
- en: 'The rule itself is defined in JSON in the following way:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则本身以JSON格式定义如下：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using a string search (`SearchString`), the WAF rule looks for the `__schema`
    keyword in any incoming HTTP requests and blocks them from going through to the
    application. Because the rule uses `CONTAINS` as the positional constraint (`PositionalConstraint`)
    and matches on the HTTP `Body` field (`FieldToMatch`), any mentions of `__schema`
    in the body’s payload will result in a deny action.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串搜索（`SearchString`），WAF规则会在任何传入的HTTP请求中查找`__schema`关键字，并阻止它们通过应用程序。因为规则使用`CONTAINS`作为位置约束（`PositionalConstraint`）并匹配HTTP的`Body`字段（`FieldToMatch`），所以在请求体中任何提到`__schema`的内容都会导致拒绝操作。
- en: This example illustrates that if a `__schema` introspection canary query is
    rejected, we can use another canary query to evaluate whether introspection has
    truly been disabled. The `__type` introspection canary query in [Listing 6-2](#listing6-2)
    will return a predetermined response if introspection is not properly disabled.
    This query requests the `name` field of the root query operation from the schema.
    Try sending it to your local DVGA instance.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了，如果`__schema`反射检测查询被拒绝，我们可以使用另一个检测查询来评估反射是否真的被禁用。如果反射没有正确禁用，[列表6-2](#listing6-2)中的`__type`反射检测查询将返回预定响应。这个查询请求模式中的根查询操作的`name`字段。尝试将它发送到你的本地DVGA实例。
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 6-2: A `__type` introspection canary query'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-2：一个`__type`反射检测查询
- en: Because we know that the name of the query operation will always be `Query`,
    the response should look exactly as shown in [Listing 6-3](#listing6-3).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们知道查询操作的名称总是`Query`，所以响应应该与[列表6-3](#listing6-3)中显示的完全相同。
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 6-3: A predetermined response for the `__type` introspection canary
    query'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-3：`__type`反射检测查询的预定响应
- en: As hackers, if we notice that introspection is not properly disabled, we could
    extend the `__type` introspection canary query to stuff a list of potential custom
    object type names and extract valuable schema information. We’ll discuss this
    stuffing technique in “Type Stuffing in the `__type` Meta-field” on page 150.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为黑客，如果我们发现反射没有被正确禁用，我们可以扩展`__type`反射检测查询，填充潜在的自定义对象类型名称列表，并提取有价值的模式信息。我们将在第150页的“`__type`元字段中的类型填充”中讨论这种填充技术。
- en: Using Field Suggestions
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字段建议
- en: A popular feature adopted by many GraphQL implementations, field suggestions
    activate when clients send a request that contains a typo. Unlike most REST APIs,
    which return status codes of *400 Bad Request* if an HTTP query is malformed,
    GraphQL responds in a much more friendly manner, by suggesting possible corrections.
    This feature is not part of the GraphQL specification but is commonly seen in
    the majority of the GraphQL server implementations available today.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 许多GraphQL实现采用了一个流行的功能，字段建议，它会在客户端发送包含拼写错误的请求时激活。与大多数REST API不同，当HTTP查询格式错误时，GraphQL不会返回*400错误请求*的状态码，而是通过建议可能的修正来以更友好的方式响应。这一功能并不是GraphQL规范的一部分，但在当前大多数GraphQL服务器实现中普遍存在。
- en: In our experience, implementations typically return three to five suggestions.
    However, not every part of a GraphQL request will return a field suggestion. For
    instance, if you make a typo in the root query operation, GraphQL implementations
    won’t attempt to autocorrect it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验，GraphQL实现通常会返回三到五个建议。然而，并不是GraphQL请求的每个部分都会返回字段建议。例如，如果你在根查询操作中犯了拼写错误，GraphQL实现不会尝试自动修正它。
- en: 'Let’s take a look at what a field suggestion response looks like. Say we send
    a query to DVGA that attempts to request the `pastes` field `title` but misspells
    it as `titlr`. In the error message, GraphQL lets the client know that the field
    cannot be queried and suggests a field that exists in the schema:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下字段建议响应是什么样的。假设我们向 DVGA 发送一个查询，尝试请求字段 `pastes` 的 `title`，但拼写错误为 `titlr`。在错误消息中，GraphQL
    会通知客户端该字段无法查询，并建议一个架构中存在的字段：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The error message `Cannot query field` . . . `Did you mean` . . . `?` is common.
    If a GraphQL server implementation supports field suggestions, you should see
    a similar message.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息 `无法查询字段` . . . `你是想说` . . . `吗？` 是常见的。如果一个 GraphQL 服务器实现支持字段建议，你应该会看到类似的消息。
- en: 'While field suggestions are available in most popular GraphQL implementations
    today, not all of them offer the option to disable this feature. The following
    is an example of how field suggestions can be disabled in Graphene, the Python-based
    GraphQL implementation that DVGA is based on:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数流行的 GraphQL 实现今天都提供字段建议，但并非所有实现都提供禁用此功能的选项。以下是如何在 Graphene 中禁用字段建议的示例，Graphene
    是基于 Python 的 GraphQL 实现，DVGA 就是基于此实现的：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, `MAX_LENGTH` is the number of suggestions to return to the
    client when a typo is made in a query. Setting `MAX_LENGTH` to `0` means that
    no suggestions will be returned, effectively disabling the feature altogether.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`MAX_LENGTH` 是查询中出现拼写错误时返回给客户端的建议数量。将 `MAX_LENGTH` 设置为 `0` 意味着不会返回任何建议，实际上是完全禁用该功能。
- en: Understanding the Edit-Distance Algorithm
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解编辑距离算法
- en: To determine whether a typo is similar to a valid object, field, or argument
    in the schema, GraphQL implementations rely on the simple *edit-distance algorithm*.
    Understanding edit distance can help us optimize a brute-forcing script for discovering
    names from field suggestions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了判断拼写错误是否与架构中的有效对象、字段或参数相似，GraphQL 实现依赖于简单的 *编辑距离算法*。理解编辑距离可以帮助我们优化暴力破解脚本，从字段建议中发现名称。
- en: This matching algorithm compares any two strings and returns their similarity
    based on the number of character operations required to match them. Adding, replacing,
    or removing a character from one of the strings counts as an operation. For example,
    to match the incorrect field name `titlr` with the correct name `title`, we need
    to replace the `r` character with an `e`, resulting in an edit distance of `1`.
    [Table 6-1](#table6-1) shows additional string comparisons and their corresponding
    edit distances.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该匹配算法比较任意两个字符串，并根据将它们匹配所需的字符操作数量返回它们的相似度。向字符串中添加、替换或删除一个字符都算作一次操作。例如，要将错误的字段名
    `titlr` 与正确的字段名 `title` 匹配，我们需要将 `r` 替换为 `e`，因此编辑距离为 `1`。[表 6-1](#table6-1) 显示了更多的字符串比较及其相应的编辑距离。
- en: 'Table 6-1: The Edit Distances Between Two Strings'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1：两个字符串之间的编辑距离
- en: '| **String** | **Typo** | **Operations** | **Edit distance** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **字符串** | **拼写错误** | **操作** | **编辑距离** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `title` | `titl` | Add `e` | 1 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `title` | `titl` | 添加 `e` | 1 |'
- en: '| `content` | `rntent` | Replace `r` with `c`, add `o` | 2 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `content` | `rntent` | 将 `r` 替换为 `c`，添加 `o` | 2 |'
- en: GraphQL implementations use a variable edit-distance threshold, calculated using
    the formula shown in [Listing 6-4](#listing6-4), to decide whether to show field
    suggestions. This example is taken directly from the source code of the GraphQL
    reference implementation GraphQL.js.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 实现使用可变的编辑距离阈值，该阈值通过 [列表 6-4](#listing6-4) 中所示的公式计算，以决定是否显示字段建议。这个例子直接取自
    GraphQL 参考实现 GraphQL.js 的源代码。
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 6-4: The edit-distance threshold snippet from GraphQL.js'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-4：来自 GraphQL.js 的编辑距离阈值代码片段
- en: This code takes the length of a string, multiplies it by 0.4, rounds that number
    down using the `Math.floor` function, and adds 1\. For example, a seven-character
    string like `content` must have an edit distance threshold of `3` or less in order
    to trigger relevant field suggestions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码获取字符串的长度，将其乘以 0.4，然后使用 `Math.floor` 函数向下取整，并加上 1。例如，像 `content` 这样的七个字符的字符串，必须具有
    `3` 或更少的编辑距离阈值，才能触发相关的字段建议。
- en: Optimizing Field Suggestion Use
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化字段建议的使用
- en: 'You’ll find it useful to know that a single typo can return multiple field
    names. GraphQL will return all fields that could possibly match the typo provided.
    For example, the following query requests the misspelled `owne` field (owner)
    from the `pastes` top-level field:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 单个拼写错误可能返回多个字段名。GraphQL 会返回所有可能匹配提供的拼写错误的字段。例如，以下查询请求从顶级字段 `pastes` 中请求拼错的 `owne`
    字段（即 `owner`）：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This single `owne` typo is within the edit-distance thresholds for both the
    `owner` and `ownerId` fields. When this happens, the GraphQL implementation doesn’t
    know which field the client wanted to request, so it returns both:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单独的 `owne` 拼写错误在 `owner` 和 `ownerId` 字段的编辑距离阈值内。当这种情况发生时，GraphQL 实现不知道客户端想请求哪个字段，因此会同时返回两者：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another useful fact is that there is no limit to the number of typos a client
    can send in a single request. For each typo, the GraphQL server will attempt to
    suggest an autocorrection. For example, in the following request, we send a query
    with multiple fields, all of which have typos:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的事实是，客户端在单个请求中发送的拼写错误数量没有限制。对于每个拼写错误，GraphQL 服务器将尝试提供一个自动更正建议。例如，在以下请求中，我们发送了一个带有多个字段的查询，所有这些字段都有拼写错误：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'GraphQL servers analyze each typo and return a list of all possible field suggestions
    within the edit-distance threshold. This GraphQL response behavior allows for
    bulk information gathering:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 服务器会分析每个拼写错误，并返回在编辑距离阈值内的所有可能的字段建议列表。这种 GraphQL 响应行为允许进行大量信息收集：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Query batching, discussed in Chapter 5, could allow you to further optimize
    such an attack by batching many requests in a single HTTP request.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 章讨论的查询批处理可以通过在单个 HTTP 请求中批量处理多个请求来进一步优化此类攻击。
- en: Considering Security Developments
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑安全发展
- en: At the time of this writing, ongoing security developments might impact the
    use of field suggestions in the future. On November 5, 2019, a GitHub issue was
    raised regarding the use of field suggestions in the GraphQL reference implementation
    GraphQL.js.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，正在进行的安全开发可能会影响将来对字段建议的使用。2019 年 11 月 5 日，关于在 GraphQL 参考实现 GraphQL.js
    中使用字段建议的 GitHub 问题已经提出。
- en: The issue stated that attackers could probe a server for schema details by sending
    invalid GraphQL documents. It referenced a file, *didYouMean.ts*, used by several
    validation rules. This file can give developers helpful suggestions when developing
    an API but can also be used to leak information.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题指出，攻击者可以通过发送无效的 GraphQL 文档来探测服务器的模式详细信息。它引用了一个名为 *didYouMean.ts* 的文件，该文件在几个验证规则中使用。这个文件可以在开发
    API 时为开发人员提供有用的建议，但也可以用来泄漏信息。
- en: 'In response to the issue, GraphQL co-creator Lee Byron commented the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于该问题的回应，GraphQL 共同创始人李·拜伦评论如下：
- en: I would expect that a schema with introspection disabled would also disable
    didYouMean. I can’t think of a reason why you would want to disable introspection
    but enable didYouMean or vice versa.
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我预期，一个禁用内省的模式也会禁用 didYouMean。我想不出你为什么会想要禁用内省，但启用 didYouMean，反之亦然。
- en: Following the thread of comments supporting Byron’s opinion on the matter, a
    pull request was made on January 28, 2022, to disable field suggestions whenever
    introspection is disabled. If merged, this pull request would make it difficult
    to abuse field suggestions when introspection is disabled.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持拜伦观点的评论线索之后，于 2022 年 1 月 28 日提出了一个拉取请求，以在禁用内省时禁用字段建议。如果合并，这个拉取请求将使得在禁用内省时滥用字段建议变得困难。
- en: While this change is a positive development for the security of GraphQL, we
    hackers should consider a few takeaways. First, it took more than two years after
    the issue was first raised for the community to develop a potential solution.
    In open source and community-driven technology like GraphQL, significant security
    concerns don’t necessarily get patched quickly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这一变更对于 GraphQL 的安全性是一个积极的发展，但我们黑客应该考虑几个要点。首先，在问题首次提出后，社区花了两年多的时间才开发出潜在的解决方案。在像
    GraphQL 这样的开源和社区驱动技术中，重要的安全问题不一定会很快得到修补。
- en: Second, while addressed within the GraphQL reference implementation, this patch
    will most likely take time to gain widespread adoption across all server implementations
    and production deployments where GraphQL is used.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在 GraphQL 参考实现中解决了这个问题，但这个补丁可能需要一段时间才能在所有使用 GraphQL 的服务器实现和生产部署中广泛采用。
- en: Now, what if both introspection and field suggestions are disabled? How can
    we continue exploring our target’s schema? In the next section, we’ll dive into
    another technique we can use to potentially discover the sensitive information
    behind a seemingly innocent-looking GraphQL query.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果 introspection 和字段建议都被禁用呢？我们该如何继续探索目标的模式？在接下来的章节中，我们将深入探讨另一种可能用于发现看似无害的
    GraphQL 查询背后敏感信息的技术。
- en: Using Field Stuffing
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字段填充
- en: '*Field stuffing* is a GraphQL information disclosure technique in which a list
    of fields is inserted into a GraphQL query. We can use field stuffing to potentially
    discover sensitive information like passwords, keys, and PII by guessing and passing
    these potential field names into a query request that we know works.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*字段填充* 是一种 GraphQL 信息泄露技术，其中将一系列字段插入到 GraphQL 查询中。我们可以通过字段填充，尝试猜测并将这些潜在的字段名传入一个我们知道有效的查询请求，从而可能发现诸如密码、密钥和个人身份信息等敏感数据。'
- en: For example, say we’ve captured the following query by using Burp Suite to intercept
    traffic while observing how normal user operations work on our target. This is
    a good initial step for finding information disclosure vulnerabilities. (Chapter
    2 explains how to intercept traffic with Burp Suite.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们通过使用 Burp Suite 拦截流量并观察正常用户操作的方式，捕获了以下查询。这是发现信息泄露漏洞的一个良好初步步骤。（第 2 章解释了如何使用
    Burp Suite 拦截流量。）
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A query like this probably returns something innocent, like the `name` of the
    currently logged-in user account. And because introspection is disabled, we can’t
    be sure what other juicy fields are available to us in this `user` object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个查询可能返回一些看似无害的内容，比如当前登录用户账户的 `name`。而且由于 introspection 被禁用，我们无法确定在这个 `user`
    对象中是否有其他有价值的字段可供我们使用。
- en: Field stuffing may allow us to bypass this. Essentially, this technique takes
    advantage of the possibility that an object’s fields in the GraphQL schema closely
    map to resources like database columns. [Table 6-2](#table6-2) shows an example
    MySQL database schema that may represent our user table.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 字段填充可能使我们绕过这一点。从本质上讲，这种技术利用了一个可能性，即 GraphQL 模式中的对象字段与数据库列等资源紧密映射。[表 6-2](#table6-2)
    显示了一个可能代表我们用户表的 MySQL 数据库模式示例。
- en: 'Table 6-2: A Sample User Table MySQL Database Schema'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-2：示例用户表 MySQL 数据库模式
- en: '| **MySQL schema** | **GraphQL type and field** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **MySQL 模式** | **GraphQL 类型和字段** |'
- en: '| --- | --- |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `id BIGINT(20)` | `User.id` (`Int`) |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `id BIGINT(20)` | `User.id`（`Int`） |'
- en: '| `name VARCHAR(50)` | `User.name` (`String`) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `name VARCHAR(50)` | `User.name`（`String`） |'
- en: '| `mobile VARCHAR(50)` | `User.mobile` (`String`) |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `mobile VARCHAR(50)` | `User.mobile`（`String`） |'
- en: '| `email VARCHAR(50)` | `User.email` (`String`) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `email VARCHAR(50)` | `User.email`（`String`） |'
- en: '| `password_hash VARCHAR(32)` | `User.password_hash` (`String`) |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `password_hash VARCHAR(32)` | `User.password_hash`（`String`） |'
- en: '| `registered_at DATETIME` | `User.registered_at` (custom `DATETIME` scalar
    type or `String`) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `registered_at DATETIME` | `User.registered_at`（自定义 `DATETIME` 标量类型或 `String`）
    |'
- en: '| `last_login DATETIME` | `User.last_login` (custom `DATETIME` scalar type
    or `String`) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `last_login DATETIME` | `User.last_login`（自定义 `DATETIME` 标量类型或 `String`）
    |'
- en: '| `intro TEXT` | `User.intro` (`String`) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `intro TEXT` | `User.intro`（`String`） |'
- en: '| `profile TEXT` | `User.profile` (`String`) |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `profile TEXT` | `User.profile`（`String`） |'
- en: '| `api_key VARCHAR(50)` | `User.api_key` (`String`) |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `api_key VARCHAR(50)` | `User.api_key`（`String`） |'
- en: To represent integers and strings, MySQL uses types such as `BIGINT` and `VARCHAR`,
    while GraphQL uses scalar types such as `Int` and `String`. MySQL also has built-in
    types for things like date and time, using the `DATETIME` data type. In GraphQL,
    we may need to use a custom scalar type, such as `DATETIME`, or a `String` scalar
    type. The serializing to an actual date-time representation would be done by the
    application’s logic.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示整数和字符串，MySQL 使用诸如 `BIGINT` 和 `VARCHAR` 等数据类型，而 GraphQL 使用诸如 `Int` 和 `String`
    的标量类型。MySQL 还内置了日期和时间等类型，使用 `DATETIME` 数据类型。在 GraphQL 中，我们可能需要使用自定义标量类型，例如 `DATETIME`
    或 `String`。实际的日期时间表示将由应用程序的逻辑来序列化。
- en: 'As attackers, we obviously won’t know what the database schema is up front,
    but we can make an educated guess about what these additional database columns
    might be and begin stuffing their possible field names into a query. Here is a
    list of potential field names added to our `user` query:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作为攻击者，我们显然无法事先了解数据库的模式，但我们可以通过推测这些额外的数据库列可能是什么，并开始将它们的字段名尝试插入查询中。以下是添加到我们`user`查询中的潜在字段名列表：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Pay attention to the formatting of the field names you attempt. Fields and arguments
    in SDL files are often styled in *snake_case*, in which each space is replaced
    with an underscore (`_`) symbol, and the first letter of each word is lowercase.
    For example, an API key field is likely to be defined as `api_key`. However, when
    querying a GraphQL API as a client, these fields and arguments may be shown in
    *camelCase*, in which a name formed by multiple words is joined together as a
    single word without punctuation, and the first letter of this word is lowercase
    (also called *lowerCamelCase*). This is because some GraphQL implementations automatically
    convert the style of fields and arguments. However, naming conventions can be
    changed, as they are completely up to the application maintainer. More information
    on naming conventions can be found at [https://graphql-rules.com/rules/naming](https://graphql-rules.com/rules/naming).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你尝试的字段名称的格式。SDL 文件中的字段和参数通常采用 *snake_case* 风格，即每个空格都被下划线（`_`）符号替换，并且每个单词的首字母小写。例如，API
    密钥字段很可能会被定义为 `api_key`。然而，当以客户端身份查询 GraphQL API 时，这些字段和参数可能以 *camelCase* 显示，即多个单词组成的名称被连接为一个单词且不带标点符号，第一个字母小写（也称为
    *lowerCamelCase*）。这是因为某些 GraphQL 实现会自动转换字段和参数的风格。不过，命名约定是可以更改的，完全取决于应用程序维护者。更多命名约定的信息可以在
    [https://graphql-rules.com/rules/naming](https://graphql-rules.com/rules/naming)
    中找到。
- en: Stuffing a single query with hundreds of potential field names is much like
    playing a game of darts with a blindfold on and hoping something hits the bull’s-eye.
    If we’re lucky, one or more of our query fields will resolve and return data (or
    potentially even suggest a few alternative field names that fall within the edit-distance
    threshold).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个查询填充上数百个潜在的字段名称，就像戴着眼罩玩飞镖游戏，并希望能击中靶心。如果我们幸运的话，我们的某些查询字段可能会得到解析并返回数据（或者甚至可能建议一些在编辑距离阈值内的备用字段名称）。
- en: Type Stuffing in the __type Meta-field
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 `__type` 元字段中进行类型填充
- en: 'Earlier in this chapter, we mentioned that certain applications might fail
    to reject queries that use the `__type` meta-field when attempting to disable
    introspection. If so, we can use a technique similar to field stuffing to gain
    insight into the application’s schema: namely, stuffing potential type names into
    the `__type` field’s `name` argument.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早些时候，我们提到某些应用程序可能无法拒绝使用 `__type` 元字段的查询，当试图禁用 introspection 时。如果是这样，我们可以使用类似字段填充的技术来深入了解应用程序的
    schema：即将潜在的类型名称填充到 `__type` 字段的 `name` 参数中。
- en: 'Let’s take advantage of DVGA’s poor introspection-disabling method to get a
    list of fields from its schema by sending the following `__type` introspection
    query for `PasteObject`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用 DVGA 禁用 introspection 的方法较差的漏洞，通过发送以下针对 `PasteObject` 的 `__type` introspection
    查询，从其 schema 中获取字段列表：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The response for this query should provide us with a list of all field names
    in the `PasteObject` type:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询的响应应该会提供我们 `PasteObject` 类型中所有字段名称的列表：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Just as we used field stuffing earlier to identify field names, we can try different
    type names until we land on one that exists. In terms of naming conventions, type
    names in GraphQL are usually written in *UpperCamelCase* (for example, `PrivatePasteProperties`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前使用字段填充来识别字段名称一样，我们可以尝试不同的类型名称，直到找到一个有效的类型名。在命名约定方面，GraphQL 中的类型名称通常使用
    *UpperCamelCase*（例如 `PrivatePasteProperties`）。
- en: We now have the theoretical knowledge needed to manually test and analyze GraphQL
    applications for a few information disclosure weaknesses. Next, we’ll investigate
    applying our new understanding of GraphQL to leverage automated tools that’ll
    make our attacks more efficient.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在具备了手动测试和分析 GraphQL 应用程序的理论知识，以发现一些信息泄露的弱点。接下来，我们将研究如何运用我们对 GraphQL 的新理解，利用自动化工具使我们的攻击更加高效。
- en: Automating Field Suggestion and Stuffing Using Clairvoyance
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Clairvoyance 自动化字段建议和填充
- en: Clairvoyance can take advantage of the field suggestion and stuffing features
    to uncover valid field information from a target. In this section, we’ll use Clairvoyance
    to execute brute-force requests. Our goal is to stitch together multiple suggestions
    and uncover as much schema information as possible without relying on introspection.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Clairvoyance 可以利用字段建议和填充功能，从目标中揭示有效的字段信息。在本节中，我们将使用 Clairvoyance 执行暴力请求。我们的目标是拼接多个建议，尽可能多地揭示
    schema 信息，而不依赖 introspection。
- en: Clairvoyance takes a wordlist as input and stuffs its contents into multiple
    GraphQL queries to identify any valid operations, fields, arguments, input types,
    and other key schema elements. Behind the scenes, it uses regular expressions
    to match valid fields in error messages, relying on field suggestions. Once it
    finishes parsing the entire wordlist, it outputs a schema. We can use this output
    schema to probe for sensitive information disclosure opportunities.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Clairvoyance将词汇表作为输入，并将其内容填充到多个GraphQL查询中，以识别任何有效的操作、字段、参数、输入类型和其他关键的模式元素。在后台，它使用正则表达式通过错误信息匹配有效字段，并依赖字段建议。一旦完成解析整个词汇表，它将输出一个模式。我们可以利用这个输出的模式来探测敏感信息泄露的机会。
- en: Field stuffing with tools like Clairvoyance works most efficiently when the
    wordlist being used matches the elements of the GraphQL schema we’re targeting.
    Many wordlists are available online, but most are designed for guessing passwords,
    directories, or usernames. Because we’re trying to guess the names of fields,
    operations, and arguments, we’ll probably have the most success using lists of
    generic English dictionary words.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像Clairvoyance这样的工具进行字段填充时，最有效的方式是词汇表与我们目标的GraphQL模式元素相匹配。虽然有很多在线词汇表，但大多数是为猜测密码、目录或用户名设计的。因为我们要猜测字段、操作和参数的名称，所以我们可能最成功的方式是使用普通的英文词典词汇列表。
- en: 'One suitable wordlist is the *high-frequency-vocabulary* wordlist created by
    Derek Chuank. This list of 30,000 common English words is a great one to start
    with. To get this wordlist, run these commands:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合适的词汇表是Derek Chuank创建的*high-frequency-vocabulary*词汇表。这个包含30,000个常见英语单词的列表是一个很好的起点。要获取这个词汇表，可以运行以下命令：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we have a wordlist we can play with, let’s put Clairvoyance into action
    and attack the DVGA instance. Remember that it should be in Expert (hardened)
    mode to disable introspection.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以使用的词汇表，接下来让我们启动Clairvoyance并攻击DVGA实例。记住，它应该处于专家（加固）模式，以禁用自省。
- en: 'Enter the directory in which you installed Clairvoyance, and then execute it
    against DVGA with a wordlist using the `-w` (words) argument. The `-o` argument
    tells Clairvoyance where it should output the schema it generates during runtime:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 进入你安装Clairvoyance的目录，然后使用`-w`（词汇）参数对DVGA执行词汇表攻击。`-o`参数告诉Clairvoyance在运行时应该将生成的模式输出到哪里：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Depending on the size of the wordlist, Clairvoyance may take a few minutes to
    finish executing. Upon completion, you should see a new file in the *clairvoyance*
    directory called *clairvoyance-dvga-schema.json*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 根据词汇表的大小，Clairvoyance可能需要几分钟才能完成执行。执行完成后，你应该会在*clairvoyance*目录下看到一个名为*clairvoyance-dvga-schema.json*的新文件。
- en: Let’s test the efficiency of our wordlist by comparing the schema Clairvoyance
    gave us with the schema generated from an introspection query. To best represent
    these differences, we can leverage GraphQL Voyager, located at [http://lab.blackhatgraphql.com:9000](http://lab.blackhatgraphql.com:9000)
    or [https://ivangoncharov.github.io/graphql-voyager](https://ivangoncharov.github.io/graphql-voyager),
    and upload both schemas. [Figure 6-1](#figure6-1) shows the DVGA’s schema, and
    [Figure 6-2](#figure6-2) shows the reconstruction of the schema by Clairvoyance.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将Clairvoyance给我们的模式与从自省查询生成的模式进行比较，来测试我们的词汇表的效率。为了最好地表示这些差异，我们可以利用GraphQL
    Voyager，访问[http://lab.blackhatgraphql.com:9000](http://lab.blackhatgraphql.com:9000)或[https://ivangoncharov.github.io/graphql-voyager](https://ivangoncharov.github.io/graphql-voyager)，并上传两个模式。[图6-1](#figure6-1)展示了DVGA的模式，[图6-2](#figure6-2)展示了Clairvoyance重建的模式。
- en: As you can see, Clairvoyance was able to recover almost every field and operation
    of the DVGA schema! For an application that doesn’t have introspection enabled,
    this isn’t half bad.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Clairvoyance成功恢复了几乎所有DVGA模式的字段和操作！对于一个没有启用自省的应用来说，这已经相当不错了。
- en: Another good option is to generate our own wordlists. As mentioned, tools like
    Clairvoyance are only as strong as the wordlists we provide them. We can add to
    our list by making informed guesses, or by extracting keywords from HTTP traffic,
    static files, and other resources collected during the information-gathering phase.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不错的选择是生成我们自己的词汇表。如前所述，像Clairvoyance这样的工具只会根据我们提供的词汇表的强度来发挥作用。我们可以通过做出有根据的猜测，或者从HTTP流量、静态文件和在信息收集阶段收集的其他资源中提取关键词，来扩充我们的词汇表。
- en: '![](image_fi/502840c06/F06001.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c06/F06001.png)'
- en: 'Figure 6-1: The original DVGA schema'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1：原始DVGA模式
- en: '![](image_fi/502840c06/F06002.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c06/F06002.png)'
- en: 'Figure 6-2: The DVGA schema reconstructed by Clairvoyance'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2：Clairvoyance重建的DVGA模式
- en: 'Tools like the Custom Word List Generator (CeWL), which comes preinstalled
    in Kali, can extract keywords from the application’s frontend HTML. Try using
    the following one-liner to profile and extract information from the DVGA interface:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 CeWL（自定义单词列表生成器）等工具，Kali 系统中预装的 CeWL 工具可以从应用程序的前端 HTML 提取关键字。尝试使用以下命令提取并分析
    DVGA 界面中的信息：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This command will return a list of words that you can use in a manual field-stuffing
    attack. Alternatively, merge it with your list of 30,000 words and use it with
    Clairvoyance. You can merge two text files by using a simple Bash command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将返回一个可以用于手动字段填充攻击的单词列表。或者，将它与您的 30,000 个单词列表合并并使用 Clairvoyance。您可以使用一个简单的
    Bash 命令合并两个文本文件：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Abusing Error Messages
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滥用错误消息
- en: '*Information exposure through error messages* is a security weakness in which
    an application or system reveals sensitive information to end users in error messages.
    These messages can expose data such as secret keys, user credentials, user information,
    database details, application environment variables, and file or operating system
    details if an application doesn’t properly handle them.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过错误消息泄露信息* 是一种安全漏洞，其中应用程序或系统在错误消息中向最终用户泄露敏感信息。如果应用程序没有正确处理错误消息，这些信息可能会暴露诸如密钥、用户凭据、用户信息、数据库详情、应用程序环境变量以及文件或操作系统详情等数据。'
- en: As we discovered through our exploration of field suggestions, GraphQL error
    messaging can be verbose. By default, GraphQL tends to overshare with clients
    to improve the overall developer experience. By learning about GraphQL error messages,
    we can take advantage of the information that they reveal to conduct our attacks.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们通过探索字段建议所发现的，GraphQL 错误消息可能会非常冗长。默认情况下，GraphQL 倾向于向客户端分享更多信息，以改善整体开发者体验。通过了解
    GraphQL 错误消息，我们可以利用它们揭示的信息来进行攻击。
- en: 'We’ve already mentioned that GraphQL error messages differ from REST error
    messages, which use standard HTTP status codes. According to the spec, GraphQL
    error responses do not require HTTP status codes and typically contain only three
    unique fields: `Message`, `Location`, and `Path`. To see this in action, try sending
    the following mutation to create a new paste in DVGA. This request is missing
    the required `title` argument:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过，GraphQL 错误消息与 REST 错误消息不同，后者使用标准的 HTTP 状态码。根据规范，GraphQL 错误响应不需要 HTTP
    状态码，通常只包含三个独特的字段：`Message`、`Location` 和 `Path`。要查看这个效果，可以尝试发送以下变更请求，在 DVGA 中创建一个新的粘贴。此请求缺少必需的
    `title` 参数：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we send this incorrect mutation request to DVGA, it will return a standard
    error JSON object that we can analyze. This error response should contain an array
    of all the errors identified in the query:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向 DVGA 发送这个错误的变更请求，它将返回一个标准的错误 JSON 对象，我们可以分析它。这个错误响应应该包含一个数组，列出查询中识别到的所有错误：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The error response format may include special keys such as `message`, `location`,
    and `path`. These keys provide a description of the error to the client, as well
    as where the error occurred in the query:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 错误响应格式可能包括诸如 `message`、`location` 和 `path` 等特殊键。这些键提供了错误的描述以及错误发生的位置：
- en: '`message` The `message` field is required in every GraphQL error and contains
    a high-level description of the error. In this case, the `message` field is letting
    us know that our mutation operation is missing one required positional argument,
    `title`. Most information disclosure weaknesses occur in the `message` field,
    so be sure to keep an eye out for it.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`message` `message` 字段在每个 GraphQL 错误中都是必需的，并包含错误的高层次描述。在这个例子中，`message` 字段告诉我们我们的变更操作缺少一个必需的位置参数
    `title`。大多数信息泄露漏洞发生在 `message` 字段中，所以一定要特别留意它。'
- en: '`location` When it comes to long and complex GraphQL documents (such as large
    fuzzing documents), the error responses returned may be difficult to parse. This
    is where the `location` field comes in handy. If an error can be associated with
    a particular place in the GraphQL document, this field will contain that location’s
    line and column. In our example, the error is in line 2 and column 3, which points
    to the `createPaste` mutation. Note that indented spaces are counted in these
    location columns.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`location` 对于长而复杂的 GraphQL 文档（如大型模糊测试文档），返回的错误响应可能很难解析。这时，`location` 字段非常有用。如果错误可以与
    GraphQL 文档中的某个特定位置关联，则该字段将包含该位置的行和列。在我们的例子中，错误发生在第 2 行，第 3 列，指向 `createPaste`
    变更。请注意，缩进空格也会计入这些位置列。'
- en: '`path` The `path` field references a particular field and is used to determine
    whether a `null` result is intentional or caused by a runtime error. In this example,
    we can see that the path error occurred because we were unable to return the `id`
    response after our attempt at creating a new paste. Path errors may also occur
    when a field returns a value as a union or interface, but the value couldn’t be
    resolved to a member of that union or interface. However, most implementations,
    including DVGA, won’t return path errors caused by validation errors.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`path` `path` 字段引用特定的字段，用于判断 `null` 结果是故意的还是由运行时错误引起的。在这个例子中，我们看到路径错误发生是因为我们在尝试创建新粘贴时无法返回
    `id` 响应。路径错误也可能发生在字段返回一个联合类型或接口类型的值，但该值无法解析为该联合类型或接口类型的成员。然而，大多数实现，包括 DVGA，都不会返回由验证错误引起的路径错误。'
- en: '`extensions` The `extensions` field is used in several GraphQL services to
    extend the `message`, `location`, and `path` fields we just mentioned. Extensions
    are reserved for implementations and plug-ins and commonly include information
    like error codes, timestamps, stack traces, and rate-limit information.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`extensions` `extensions` 字段用于多个 GraphQL 服务中，以扩展我们刚才提到的 `message`、`location`
    和 `path` 字段。扩展字段保留给实现和插件，通常包括错误代码、时间戳、堆栈跟踪和速率限制信息等内容。'
- en: Exploring Excessive Error Messaging
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索过多的错误信息
- en: 'Now that you understand some of the standard elements of the GraphQL error
    array, you can begin to probe them for sensitive information. The following error
    is raised in DVGA when a client attempts to send a `createUser` mutation request
    with a username that already exists in the database:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 GraphQL 错误数组的一些标准元素，你可以开始探查它们是否包含敏感信息。以下错误是在 DVGA 中，当客户端尝试使用已经存在于数据库中的用户名发送
    `createUser` 变更请求时引发的：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, the response error is clearly oversharing information. The `message`
    field comes directly from a SQLite3 database and provides us with the entire SQL
    statement used to insert a new user record into the `users` table. We also see
    a unique `username` database column and a `password` column that clearly isn’t
    being encrypted on insertion.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，响应错误明显是信息泄露。`message` 字段直接来自 SQLite3 数据库，提供了用于向 `users` 表中插入新用户记录的完整 SQL
    语句。我们还看到一个唯一的 `username` 数据库列和一个 `password` 列，后者显然在插入时并没有加密。
- en: This single error message could enable malicious actors to fingerprint the SQL
    database and potentially enumerate all the valid user accounts stored in it. It
    also exposes the application to SQL injection attacks, as it provides an attacker
    with insight into how the SQL query gets structured.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这条单一的错误信息可能使恶意攻击者能够指纹识别 SQL 数据库，并可能枚举出所有有效的用户帐户。它还将应用程序暴露于 SQL 注入攻击，因为它向攻击者提供了有关
    SQL 查询结构的洞察。
- en: When testing for information disclosure issues through error messages, you might
    want to fuzz the API in different ways until a combination of actions, or malformed
    inputs, makes the server throw unexpected errors. Not all GraphQL servers are
    alike, and it’s important to try various test cases until something sticks.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过错误信息测试信息泄露问题时，你可能想通过不同的方式模糊测试 API，直到某个操作组合或格式不正确的输入导致服务器抛出意外错误。并非所有的 GraphQL
    服务器都相同，因此尝试各种测试用例，直到某些东西起作用是非常重要的。
- en: For example, if you send malformed queries, specify special characters where
    they aren’t meant to exist in a query, or even send queries over HTTP methods
    that are unusual for GraphQL (such as PUT), you could cause unexpected server-processing
    errors. When this happens, you want to look out for any nonstandard outputs in
    the `errors` or `extensions` GraphQL response JSON keys to identify additional
    details that the server may include in the response.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你发送格式不正确的查询，指定查询中不该出现的特殊字符，甚至通过对 GraphQL 来说不常用的 HTTP 方法（如 PUT）发送查询，都可能导致意外的服务器处理错误。当这种情况发生时，你需要留意
    `errors` 或 `extensions` GraphQL 响应 JSON 键中是否有任何非标准输出，以识别服务器可能在响应中包含的额外细节。
- en: Enabling Debugging
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用调试
- en: Developers use debugging information when troubleshooting issues with GraphQL
    applications. When debug mode is enabled, a GraphQL server will respond to client
    requests with verbose messages related to a backend server error that wouldn’t
    normally be shown. For instance, instead of returning standard errors, a client
    may receive a stack trace with detailed error messages. These debug messages may
    include valuable information that we can use in further attacks against our target.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员在排查 GraphQL 应用程序问题时会使用调试信息。当启用调试模式时，GraphQL 服务器会以详细的消息响应客户端请求，这些消息与通常不会显示的后端服务器错误相关。例如，客户端可能会收到一个堆栈跟踪，而不是返回标准错误信息。这些调试消息可能包含有价值的信息，攻击者可以利用这些信息对目标进行进一步攻击。
- en: Most GraphQL implementations that support debugging can enable debug mode by
    using environment variables. Many also support *tracing*, a useful tool that tracks
    the amount of time it takes for GraphQL to complete a query and adds that data
    to the `extensions` key in the response along with other metadata about the request.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数支持调试的 GraphQL 实现可以通过使用环境变量来启用调试模式。许多实现还支持*追踪*，这是一种有用的工具，用于跟踪 GraphQL 完成查询所需的时间，并将这些数据与关于请求的其他元数据一起添加到响应中的
    `extensions` 键中。
- en: 'Some implementations have debug mode enabled by default and may even allow
    clients to potentially enable it through cookies and URL parameters. For example,
    according to Magento’s GraphQL implementation documentation, a client can start
    debugging by adding the `?XDEBUG_SESSION_START=PHPSTORM` parameter to the endpoint
    URL. Another common parameter used to enable debug mode is the `debug` query parameter
    with a value of `1` (for true), for example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一些实现默认启用调试模式，甚至可能允许客户端通过 cookies 和 URL 参数来启用调试模式。例如，根据 Magento 的 GraphQL 实现文档，客户端可以通过将`?XDEBUG_SESSION_START=PHPSTORM`参数添加到端点
    URL 来启动调试。另一个常用的启用调试模式的参数是 `debug` 查询参数，值为 `1`（表示启用），例如：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Developers will most likely use debug mode in their staging or development environments.
    You can use the list of nonproduction GraphQL URLs ([https://github.com/dolevf/Black-Hat-GraphQL/blob/master/resources/non-production-graphql-urls.txt](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/resources/non-production-graphql-urls.txt))
    to test for verbose debug error messages across multiple GraphQL subdomains and
    endpoints.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员最有可能在其预发布或开发环境中使用调试模式。你可以使用非生产 GraphQL URL 的列表（[https://github.com/dolevf/Black-Hat-GraphQL/blob/master/resources/non-production-graphql-urls.txt](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/resources/non-production-graphql-urls.txt)）来测试多个
    GraphQL 子域和端点上的详细调试错误信息。
- en: Many developers may also write debug messages to a browser’s console by using
    the `console.log` function in JavaScript. In the browser’s developer tools, use
    the Console tab to inspect console messages for possible debug logs that may be
    attributed to GraphQL functionality.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员可能还会通过在 JavaScript 中使用`console.log`函数将调试信息写入浏览器的控制台。在浏览器的开发者工具中，可以使用“控制台”标签页检查可能与
    GraphQL 功能相关的调试日志。
- en: Inferring Information from Stack Traces
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从堆栈跟踪中推断信息
- en: '*Stack traces* (also known as *stack backtraces* and *stack tracebacks*) are
    function calls that an application executes when an exception error occurs. This
    breadcrumb trail is extremely useful for developers trying to identify failure
    conditions in their source code. But if these stack traces are made available
    to hackers, we could use the sensitive information about the system and source
    code to extract data and tailor future attacks.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆栈跟踪*（也称为*堆栈回溯*或*堆栈追溯*）是应用程序在发生异常错误时执行的函数调用。当发生错误时，这个“面包屑”轨迹对开发人员非常有用，可以帮助他们在源代码中识别故障条件。但是，如果这些堆栈跟踪暴露给黑客，攻击者可能会利用有关系统和源代码的敏感信息来提取数据并定制未来的攻击。'
- en: As mentioned earlier, various GraphQL endpoints on the same server could have
    different configuration settings. For example, DVGA’s */graphql* endpoint does
    not throw stack traces to client requests that raise an error. However, the */graphiql*
    endpoint, which provides access to graphical query tools, is configured to return
    stack traces when an error is raised.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，同一服务器上的不同 GraphQL 端点可能具有不同的配置设置。例如，DVGA 的 */graphql* 端点不会对引发错误的客户端请求抛出堆栈跟踪。然而，提供图形查询工具访问的
    */graphiql* 端点在发生错误时会配置为返回堆栈跟踪。
- en: If you think about it, having different settings for each endpoint makes sense.
    The assumption is that developers use graphical interfaces for debugging and testing,
    so they might require verbose error messages to identify bugs, something that
    isn’t necessary in production endpoints such as */graphql*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细想想，为每个端点设置不同的配置是合理的。假设开发人员使用图形界面进行调试和测试，因此他们可能需要详细的错误信息来识别bug，而这种信息在像*/graphql*这样的生产端点中并不必要。
- en: Let’s practice taking advantage of this configuration. Using the browser, navigate
    to DVGA at ***http://localhost:5013*** and toggle on the Beginner mode via the
    cubes menu icon. Next, to gain access to DVGA’s */graphiql* endpoint as a client,
    we’ll need to modify the `env` cookie from its default value of `graphiql:disable`
    to `graphiql:enable` by using the browser’s developer tools. You can access these
    by pressing CTRL-SHIFT-I or by right-clicking anywhere in the browser window and
    selecting **Inspect**. [Figure 6-3](#figure6-3) shows the Inspect window in Firefox.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们练习利用这个配置。通过浏览器，导航到DVGA的***http://localhost:5013***，然后通过立方体菜单图标切换到初学者模式。接下来，为了作为客户端访问DVGA的*/graphiql*端点，我们需要使用浏览器的开发者工具，将`env`
    cookie从默认值`graphiql:disable`修改为`graphiql:enable`。你可以通过按CTRL-SHIFT-I或右键点击浏览器窗口中的任意位置并选择**Inspect**来访问这些工具。[图6-3](#figure6-3)显示了Firefox中的检查窗口。
- en: You can modify the `env` cookie directly from the browser by clicking the **Storage**
    tab, then **Cookies**, and selecting ***http://locahost:5013*** from the drop-down
    menu. You will need to double-click the value field.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击浏览器中的**Storage**标签，然后选择**Cookies**，并从下拉菜单中选择***http://localhost:5013***，直接修改`env`
    cookie。你需要双击值字段。
- en: '![](image_fi/502840c06/f06003.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c06/f06003.png)'
- en: 'Figure 6-3: The Firefox Inspect window showing DVGA cookies'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3：Firefox检查窗口显示DVGA的cookies
- en: 'After modifying the `env` cookie, you should be able to send queries from the
    GraphiQL Explorer panel with typos in them. For example, try requesting the nonexistent
    `pastes` field `titled`, as shown here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`env` cookie后，你应该能够从GraphiQL Explorer面板发送包含拼写错误的查询。例如，尝试请求不存在的`pastes`字段`title`，如图所示：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The response should include a stack trace:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 响应应包括堆栈追踪：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The stack trace returns a wealth of information that we can use to uncover vulnerabilities,
    such as dependencies, software versions, software frameworks, and source code
    snippets. This stack trace also provides us with information such as user account,
    filesystem, and operating system details.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈追踪返回了大量信息，我们可以利用这些信息揭示漏洞，如依赖项、软件版本、软件框架以及源代码片段。这个堆栈追踪还提供了诸如用户账户、文件系统和操作系统细节等信息。
- en: In DVGA, stack tracing is enabled only on the */graphiql* endpoint that GraphiQL
    Explorer uses to send queries to. This is to show you that GraphQL endpoints could
    have different configurations, so you want to test both if there is more than
    one.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在DVGA中，堆栈追踪仅在*/graphiql*端点启用，该端点由GraphiQL Explorer用于发送查询。这是为了向你展示，GraphQL端点可能有不同的配置，所以如果有多个端点，你需要测试每一个。
- en: Leaking Data by Using GET-Based Queries
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基于GET的查询泄露数据
- en: As we mentioned in Chapter 1, some GraphQL implementations allow clients to
    execute queries using the GET method, while others allow only POST requests. Mutation
    operations in particular should be sent using only POST methods. However, some
    implementations, like Scala-based Sangria, may allow GET requests for mutation
    operations as well.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一章中提到的，一些GraphQL实现允许客户端使用GET方法执行查询，而其他的只允许POST请求。特别是突变操作应仅使用POST方法发送。然而，一些实现，如基于Scala的Sangria，可能也允许对突变操作使用GET请求。
- en: 'Because GET requests transmit data as query parameters in the URL, they risk
    exposing sensitive information. For example, the following URL sends a GET request
    to DVGA. We pass a phone number in the `variables` GET parameter:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GET请求将数据作为查询参数传输在URL中，因此它们有泄露敏感信息的风险。例如，以下URL向DVGA发送GET请求。我们将电话号码作为`variables`
    GET参数传递：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The same query can also be sent in the following manner, by omitting the `variables`
    parameter and inserting the phone number directly into the query:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的查询也可以通过以下方式发送，通过省略`variables`参数并直接将电话号码插入到查询中：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In real applications, phone numbers are considered PII. These URLs will show
    up in the web server access logs of GraphQL servers (such as Apache or Nginx).
    Any sensitive information they contain may be logged in various locations, such
    as in referrer headers and any forward or reverse proxies between the requesting
    client and the server.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，电话号码被视为个人身份信息（PII）。这些 URL 会出现在 GraphQL 服务器的 web 服务器访问日志中（如 Apache 或 Nginx）。它们包含的任何敏感信息可能会在不同位置记录，比如引荐头和请求客户端与服务器之间的任何正向或反向代理。
- en: While this condition doesn’t directly give us information we don’t already have,
    it’s important to highlight such cases to clients in your penetration tests as
    something to be wary of.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个条件并不会直接给我们提供我们尚未掌握的信息，但在渗透测试中向客户强调此类情况是非常重要的，作为需要警惕的事项。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored how to extract valuable information from our targets
    by using a variety of tools and techniques. When introspection is enabled, you
    can use InQL to automatically extract the schema from GraphQL targets. When introspection
    is disabled, you can exploit a built-in GraphQL feature known as field suggestions
    and “stuff” fields by using a tool called Clairvoyance.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何通过使用各种工具和技术从目标中提取有价值的信息。当自省功能开启时，你可以使用 InQL 自动从 GraphQL 目标中提取架构。当自省功能禁用时，你可以利用
    GraphQL 的一个内置特性，称为字段建议，并通过使用名为 Clairvoyance 的工具“填充”字段。
- en: You learned how to identify and bypass poor attempts at disabling introspection
    by using unblocked introspection meta-field queries. You also learned to uncover
    system details by using verbose GraphQL error and debug messages.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你学会了如何通过使用未被禁用的自省元字段查询来识别并绕过无效的禁用自省尝试。你还学会了如何通过使用详细的 GraphQL 错误和调试信息来揭示系统细节。
- en: With all these GraphQL information disclosure tools and techniques, you should
    feel confident about your ability to extract application secrets, user details,
    PII, and system information that will propel your future GraphQL attacks.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所有这些 GraphQL 信息泄露工具和技术，你应该对提取应用程序秘密、用户详情、个人身份信息（PII）和系统信息充满信心，这些信息将推动你未来的
    GraphQL 攻击。
