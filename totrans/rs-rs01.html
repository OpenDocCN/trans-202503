<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="1" id="Page_1"/>1</span><br/>
<span class="ChapterTitle">Foundations</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="206" height="206"/>
</figure>
<p class="ChapterIntro">As you dive into the more advanced corners of Rust, it’s important that you ensure you have a solid understanding of the fundamentals. In Rust, as in any programming language, the precise meaning of various keywords and concepts becomes important as you begin to use the language in more sophisticated ways. In this chapter, we’ll walk through many of Rust’s primitives and try to define more clearly what they mean, how they work, and why they are exactly the way that they are. Specifically, we’ll look at how variables and values differ, how they are represented in memory, and the different memory regions a program has. We’ll then discuss some of the subtleties of ownership, borrowing, and lifetimes that you’ll need to have a handle on before you continue with the book.</p>
<p>You can read this chapter from top to bottom if you wish, or you can use it as a reference to brush up on the concepts that you feel less sure about. I recommend that you move on only when you feel completely <span epub:type="pagebreak" title="2" id="Page_2"/>comfortable with the content of this chapter, as misconceptions about how these primitives work will quickly get in the way of understanding the more advanced topics, or lead to you using them incorrectly.</p>
<h2 id="h1-123456c01-0001">Talking About Memory</h2>
<p class="BodyFirst">Not all memory is created equal. In most programming environments, your programs have access to a stack, a heap, registers, text segments, memory-mapped registers, memory-mapped files, and perhaps nonvolatile RAM. Which one you choose to use in a particular situation has implications for what you can store there, how long it remains accessible, and what mechanisms you use to access it. The exact details of these memory regions vary between platforms and are beyond the scope of this book, but some are so important to how you reason about Rust code that they are worth covering here.</p>
<h3 id="h2-123456c01-0001">Memory Terminology</h3>
<p class="BodyFirst">Before we dive into regions of memory, you first need to know about the difference between values, variables, and pointers. A <em>value</em> in Rust is the combination of a type and an element of that type’s domain of values. A value can be turned into a sequence of bytes using its type’s <em>representation</em>, but on its own you can think of a value more like what you, the programmer, meant. For example, the number <code>6</code> in the type <code>u8</code> is an instance of the mathematical integer 6, and its in-memory representation is the byte <code>0x06</code>. Similarly, the <code>str</code> <code>"Hello world"</code> is a value in the domain of all strings whose representation is its UTF-8 encoding. A value’s meaning is independent of the location where those bytes are stored.</p>
<p>A value is stored in a <em>place</em>, which is the Rust terminology for “a location that can hold a value.” This place can be on the stack, on the heap, or in a number of other locations. The most common place to store a value is a <em>variable</em>, which is a named value slot on the stack.</p>
<p>A <em>pointer</em> is a value that holds the address of a region of memory, so the pointer points to a place. A pointer can be dereferenced to access the value stored in the memory location it points to. We can store the same pointer in more than one variable and therefore have multiple variables that indirectly refer to the same location in memory and thus the same underlying value.</p>
<p>Consider the code in <a href="#listing1-1" id="listinganchor1-1">Listing 1-1</a>, which illustrates these three elements.</p>
<pre><code>let x = 42;
let y = 43;
let var1 = &amp;x;
let mut var2 = &amp;x;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> var2 = &amp;y;</code></pre>
<p class="CodeListingCaption"><a id="listing1-1">Listing 1-1</a>: Values, variables, and pointers</p>
<p><span epub:type="pagebreak" title="3" id="Page_3"/>Here, there are four distinct values: <code>42</code> (an <code>i32</code>), <code>43</code> (an <code>i32</code>), the address of <code>x</code> (a pointer), and the address of <code>y</code> (a pointer). There are also four variables: <code>x</code>, <code>y</code>, <code>var1</code>, and <code>var2</code>. The latter two variables both hold values of the pointer type, because references are pointers. While <code>var1</code> and <code>var2</code> store the same value initially, they store separate, independent copies of that value; when we change the value stored in <code>var2</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, the value in <code>var1</code> does not change. In particular, the <code>=</code> operator stores the value of the right-hand side expression in the place named by the left-hand side.</p>
<p>An interesting example of where the distinction between variables, values, and pointers becomes important is in a statement such as:</p>
<pre><code>let string = "Hello world";</code></pre>
<p>Even though we assign a string value to the variable <code>string</code>, the <em>actual</em> value of the variable is a pointer to the first character in the string value <code>"Hello world"</code>, and not the string value itself. At this point you might say, “But hang on, where is the string value stored, then? Where does the pointer point?” If so, you have a keen eye—we’ll get to that in a second.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Technically, the value of <code>string</code> also includes the string’s length. We’ll talk about that in Chapter 2 when we discuss wide pointer types.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-123456c01-0002">Variables in Depth</h3>
<p class="BodyFirst">The definition of a variable I gave earlier is broad and unlikely to be all that useful in and of itself. As you encounter more complex code, you’ll need a more accurate mental model to help you reason through what the programs are really doing. There are many such models that we can make use of. Describing them all in detail would take up several chapters and is beyond the scope of this book, but broadly speaking, they can be divided into two categories: high-level models and low-level models. High-level models are useful when thinking about code at the level of lifetimes and borrows, while low-level models are good for when you are reasoning about unsafe code and raw pointers. The models for variables described in the following two sections will suffice for most of the material in this book.</p>
<h4 id="h3-123456c01-0001">High-Level Model</h4>
<p class="BodyFirst">In the high-level model, we don’t think of variables as places that hold bytes. Instead, we think of them just as names given to values as they are instantiated, moved, and used throughout a program. When you assign a value to a variable, that value is from then on named by that variable. When a variable is later accessed, you can imagine drawing a line from the previous access of that variable to the new access, which establishes a dependency relationship between the two accesses. If the value in a variable is moved, no lines can be drawn from it anymore.</p>
<p>In this model, a variable exists only so long as it holds a legal value; you cannot draw lines from a variable whose value is uninitialized or has been <span epub:type="pagebreak" title="4" id="Page_4"/>moved, so effectively it isn’t there. Using this model, your entire program consists of many of these dependency lines, often called <em>flows</em>, each one tracing the lifetime of a particular instance of a value. Flows can fork and merge when there are branches, with each split tracing a distinct lifetime for that value. The compiler can check that at any given point in your program, all flows that can exist in parallel with each other are compatible. For example, there cannot be two parallel flows with mutable access to a value. Nor can there be a flow that borrows a value while there is no flow that owns the value. <a href="#listing1-2" id="listinganchor1-2">Listing 1-2</a> shows examples of both of these cases.</p>
<pre><code>let mut x;
<span class="LiteralGray">// this access would be illegal, nowhere to draw the flow from:</span>
<span class="LiteralGray">// assert_eq!(x, 42);</span>
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> x = 42;
<span class="LiteralGray">// this is okay, can draw a flow from the value assigned above:</span>
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> let y = &amp;x;
<span class="LiteralGray">// this establishes a second, mutable flow from x:</span>
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> x = 43;
<span class="LiteralGray">// this continues the flow from y, which in turn draws from x.</span>
<span class="LiteralGray">// but that flow conflicts with the assignment to x!</span>
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> assert_eq!(*y, 42);</code></pre>
<p class="CodeListingCaption"><a id="listing1-2">Listing 1-2</a>: Illegal flows that the borrow checker will catch</p>
<p>First, we cannot use <code>x</code> before it is initialized, because we have nowhere to draw the flow from. Only when we assign a value to <code>x</code> can we draw flows from it. This code has two flows: one exclusive (<code>&amp;mut</code>) flow from <span class="CodeAnnotation" aria-label="annotation1">1</span> to <span class="CodeAnnotation" aria-label="annotation3">3</span>, and one shared (<code>&amp;</code>) flow from <span class="CodeAnnotation" aria-label="annotation1">1</span> through <span class="CodeAnnotation" aria-label="annotation2">2</span> to <span class="CodeAnnotation" aria-label="annotation4">4</span>. The borrow checker inspects every vertex of every flow and checks that no other incompatible flows exist concurrently. In this case, when the borrow checker inspects the exclusive flow at <span class="CodeAnnotation" aria-label="annotation3">3</span>, it sees the shared flow that terminates at <span class="CodeAnnotation" aria-label="annotation4">4</span>. Since you cannot have an exclusive and a shared use of a value at the same time, the borrow checker (correctly) rejects the code. Notice that if <span class="CodeAnnotation" aria-label="annotation4">4</span> was not there, this code would compile fine! The shared flow would terminate at <span class="CodeAnnotation" aria-label="annotation2">2</span>, and when the exclusive flow is checked at <span class="CodeAnnotation" aria-label="annotation3">3</span>, no conflicting flows would exist.</p>
<p>If a new variable is declared with the same name as a previous one, they are still considered distinct variables. This is called <em>shadowing</em>—the later variable “shadows” the former by the same name. The two variables coexist, though subsequent code no longer has a way to name the earlier one. This model matches roughly how the compiler, and the borrow checker in particular, reasons about your program, and is actually used internally in the compiler to produce efficient code. </p>
<h4 id="h3-123456c01-0002">Low-Level Model</h4>
<p class="BodyFirst">Variables name memory locations that may or may not hold legal values. You can think of a variable as a “value slot.” When you assign to it, the slot is filled, and its old value (if it had one) is dropped and replaced. When you access it, the compiler checks that the slot isn’t empty, as that would mean the variable is uninitialized or its value has been moved. A pointer to a variable refers to the variable’s backing memory and can be dereferenced to <span epub:type="pagebreak" title="5" id="Page_5"/>get at its value. For example, in the statement <code>let x: usize</code>, the variable <code>x</code> is a name for a region of memory on the stack that has room for a value the size of a <code>usize</code>, though it does not have a well-defined value (its slot is empty). If you assign a value to that variable, such as with <code>x = 6</code>, that region of memory will then hold the bits representing the value <code>6</code>. <code>&amp;x</code> does not change when you assign to <code>x</code>. If you declare multiple variables with the same name, they still end up with different chunks of memory backing them. This model matches the memory model used by C and C++, and many other low-level languages, and is useful for when you need to reason explicitly about memory.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	In this example, we ignore CPU registers and treat them as an optimization. In reality, the compiler may use a register to back a variable instead of a region of memory if no memory address is needed for that variable.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>You may find that one of these matches your previous model better than the other, but I urge you to try to wrap your head around both of them. They are both equally valid, and both are simplifications, like any useful mental model has to be. If you are able to consider a piece of code from both of these perspectives, you will find it much easier to work through complicated code segments and understand why they do or do not compile and work as you expect.</p>
<h3 id="h2-123456c01-0003">Memory Regions</h3>
<p class="BodyFirst">Now that you have a grip on how we refer to memory, we need to talk about what memory actually is. There are many different regions of memory, and perhaps surprisingly, not all of them are stored in the DRAM of your computer. Which part of memory you use has a significant impact on how you write your code. The three most important regions for the purposes of writing Rust code are the stack, the heap, and static memory.</p>
<h4 id="h3-123456c01-0003">The Stack</h4>
<p class="BodyFirst">The <em>stack</em> is a segment of memory that your program uses as scratch space for function calls. Each time a function is called, a contiguous chunk of memory called a <em>frame</em> is allocated at the top of the stack.  Near the bottom of the stack is the frame for the <code>main</code> function, and as functions call other functions, additional frames are pushed onto the stack. A function’s frame contains all the variables within that function, along with any arguments the function takes. When the function returns, its stack frame is reclaimed.</p>
<p>The bytes that make up the values of the function’s local variables are not immediately wiped, but it’s not safe to access them as they may have been overwritten by a subsequent function call whose frame overlaps with the reclaimed one. And even if they haven’t been overwritten, they may contain values that are illegal to use, such as ones that were moved when the function returned.</p>
<p>Stack frames, and crucially the fact that they eventually disappear, are very closely tied to the notion of lifetimes in Rust. Any variable stored in a frame on the stack cannot be accessed after that frame goes away, so any <span epub:type="pagebreak" title="6" id="Page_6"/>reference to it must have a lifetime that is at most as long as the lifetime of the frame.</p>
<h4 id="h3-123456c01-0004">The Heap</h4>
<p class="BodyFirst">The <em>heap</em> is a pool of memory that isn’t tied to the current call stack of the program. Values in heap memory live until they are explicitly deallocated. This is useful when you want a value to live beyond the lifetime of the current function’s frame. If that value is the function’s return value, the calling function can leave some space on its stack for the called function to write that value into before it returns. But if you want to, say, send that value to a different thread with which the current thread may share no stack frames at all, you can store it on the heap.</p>
<p>The heap allows you to explicitly allocate contiguous segments of memory. When you do so, you get a pointer to the start of that segment of memory. That memory segment is reserved for you until you later deallocate it; this process is often referred to as <em>freeing</em>, after the name of the corresponding function in the C standard library. Since allocations from the heap do not go away when a function returns, you can allocate memory for a value in one place, pass the pointer to it to another thread, and have that thread safely continue to operate on that value. Or, phrased differently, when you heap-allocate memory, the resulting pointer has an unconstrained lifetime—its lifetime is however long your program keeps it alive.</p>
<p>The primary mechanism for interacting with the heap in Rust is the <code>Box</code> type. When you write <code>Box::new(value)</code>, the value is placed on the heap, and what you are given back (the <code>Box&lt;T&gt;</code>) is a pointer to that value on the heap. When the <code>Box</code> is eventually dropped, that memory is freed.</p>
<p>If you forget to deallocate heap memory, it will stick around forever, and your application will eventually eat up all the memory on your machine. This is called <em>leaking memory</em> and is usually something you want to avoid. However, there are some cases where you explicitly want to leak memory. For example, say you have a read-only configuration that the entire program should be able to access. You can allocate that on the heap and explicitly leak it with <code>Box::leak</code> to get a <code>'static</code> reference to it.</p>
<h4 id="h3-123456c01-0005">Static Memory</h4>
<p class="BodyFirst"><em>Static memory </em>is really a catch-all term for several closely related regions located in the file your program is compiled into. These regions are automatically loaded into your program’s memory when that program is executed. Values in static memory live for the entire execution of your program. Your program’s static memory contains the program’s binary code, which is usually mapped as read-only. As your program executes, it walks through the binary code in the text segment instruction by instruction and jumps around whenever a function is called. Static memory also holds the memory for variables you declare with the <code>static</code> keyword, as well as certain constant values in your code, like strings.</p>
<p>The special lifetime <code>'static</code>, which gets its name from the static memory region, marks a reference as being valid for “as long as static memory is <span epub:type="pagebreak" title="7" id="Page_7"/>around,” which is until the program shuts down. Since a static variable’s memory is allocated when the program starts, a reference to a variable in static memory is, by definition, <code>'static</code>, as it is not deallocated until the program shuts down. The inverse is not true—there can be <code>'static</code> references that do not point to static memory—but the name is still appropriate: once you create a reference with a static lifetime, whatever it points to might as well be in static memory as far as the rest of the program is concerned, as it can be used for however long your program wishes.</p>
<p>You will encounter the <code>'static</code> lifetime much more often than you will encounter truly static memory (through the <code>static</code> keyword, for example) when working with Rust. This is because <code>'static</code> often shows up in trait bounds on type parameters. A bound like <code>T: 'static</code> indicates that the type parameter <code>T</code> is able to live for however long we keep it around for, up to and including the remaining execution of the program. Essentially, this bound requires that <code>T</code> is owned and self-sufficient, either in that it does not borrow other (non-static) values or that anything it does borrow is also <code>'static</code> and thus will stick around until the end of the program. A good example of <code>'static</code> as a bound is the <code>std::thread::spawn</code> function that creates a new thread, which requires that the closure you pass it is <code>'static</code>. Since the new thread may outlive the current thread, the new thread cannot refer to anything stored on the old thread’s stack. The new thread can refer only to values that will live for its entire lifetime, which may be for the remaining duration of the program.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	You may wonder how <var>const</var> differs from <var>static</var>. The <var>const</var> keyword declares the following item as <em>constant</em>. Constant items can be completely computed at compile time, and any code that refers to them is replaced with the constant’s computed value during compilation. A constant has no memory or other storage associated with it (it is not a place). You can think of constant as a convenient name for a particular value.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-123456c01-0002">Ownership</h2>
<p class="BodyFirst">Rust’s memory model centers on the idea that all values have a single <em>owner</em>—that is, exactly one location (usually a scope) is responsible for ultimately deallocating each value. This is enforced through the borrow checker. If the value is moved, such as by assigning it to a new variable, pushing it to a vector, or placing it on the heap, the ownership of the value moves from the old location to the new one. At that point, you can no longer access the value through variables that flow from the original owner, even though the bits that make up the value are technically still there. Instead, you must access the moved value through variables that refer to its new location.</p>
<p>Some types are rebels and do not follow this rule. If a value’s type implements the special <code>Copy</code> trait, the value is not considered to have moved even if it is reassigned to a new memory location. Instead, the value is <em>copied</em>, and both the old and new locations remain accessible. Essentially, another <span epub:type="pagebreak" title="8" id="Page_8"/>identical instance of that same value is constructed at the destination of the move. Most primitive types in Rust, such as the integer and floating-point types, are <code>Copy</code>. To be <code>Copy</code>, it must be possible to duplicate the type’s values simply by copying their bits. This eliminates all types that <em>contain</em> non-<code>Copy</code> types as well as any type that owns a resource it must deallocate when the value is dropped.</p>
<p>To see why, consider what would happen if a type like <code>Box</code> were <code>Copy</code>. If we executed <code>box2 = box1</code>, then <code>box1</code> and <code>box2</code> would both believe that they owned the heap memory allocated for the box, and they would both attempt to free it when they went out of scope. Freeing the memory twice could have catastrophic consequences.</p>
<p>When a value’s owner no longer has use for it, it is the owner’s responsibility to do any necessary cleanup for that value by <em>dropping</em> it. In Rust, dropping happens automatically when the variable that holds the value is no longer in scope. Types usually recursively drop values they contain, so dropping a variable of a complex type may result in many values being dropped. Because of Rust’s discrete ownership requirement, we cannot accidentally drop the same value multiple times. A variable that holds a reference to another value does not own that other value, so the value isn’t dropped when the variable drops.</p>
<p>The code in <a href="#listing1-3" id="listinganchor1-3">Listing 1-3</a> gives a quick summary of the rules around ownership, move and copy semantics, and dropping.</p>
<pre><code>let x1 = 42;
let y1 = Box::new(84);
{ <span class="LiteralGray">// starts a new scope</span>
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> let z = (x1, y1);
  <span class="LiteralGray">// z goes out of scope, and is dropped;</span>
  <span class="LiteralGray">// it in turn drops the values from x1 and y1</span>
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> }
<span class="LiteralGray">// x1's value is Copy, so it was not moved into z</span>
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> let x2 = x1;
<span class="LiteralGray">// y1's value is not Copy, so it was moved into z</span>
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> <span class="LiteralGray">// let y2 = y1;</span></code></pre>
<p class="CodeListingCaption"><a id="listing1-3">Listing 1-3</a>: Moving and copying semantics</p>
<p>We start out with two values, the number <code>42</code> and a <code>Box</code> (a heap-allocated value) containing the number <code>84</code>. The former is <code>Copy</code>, whereas the latter is not. When we place <code>x1</code> and <code>y1</code> into the tuple <code>z</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, <code>x1</code> is <em>copied</em> into <code>z</code>, whereas <code>y1</code> is <em>moved</em> into <code>z</code>. At this point, <code>x1</code> continues to be accessible and can be used again <span class="CodeAnnotation" aria-label="annotation3">3</span>. On the other hand, <code>y1</code> is rendered inaccessible once its value has been moved <span class="CodeAnnotation" aria-label="annotation4">4</span>, and any attempt to access it would incur a compiler error. When <code>z</code> goes out of scope <span class="CodeAnnotation" aria-label="annotation2">2</span>, the tuple value it contains is dropped, and this in turn drops the value copied from <code>x1</code> and the one moved from <code>y1</code>. When the <code>Box</code> from <code>y1</code> is dropped, it also deallocates the heap memory used to store <code>y1</code>’s value.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" title="9" id="Page_9"/>Drop Order</h2>
<p class="BoxBodyFirst">Rust automatically drops values when they go out of scope, such as <code>x1</code> and <code>y1</code> in the inner scope in <a href="#listing1-3">Listing 1-3</a>. The rules for the order in which to drop are fairly simple: variables (including function arguments) are dropped in reverse order, and nested values are dropped in source-code order.</p>
<p>This might sound weird at first—why the discrepancy? If we look at it closely, though, it makes a lot of sense. Say you write a function that declares a string and then inserts a reference to that string into a new hash table. When the function returns, the hash table must be dropped first; if the string were dropped first, the hash table would then hold an invalid reference! In general, later variables may contain references to earlier values, whereas the inverse cannot happen due to Rust’s lifetime rules. And for that reason, Rust drops variables in reverse order.</p>
<p>Now, we could have the same behavior for nested values, like the values in a tuple, array, or struct, but that would likely surprise users. If you constructed an array that contained two values, it’d seem odd if the last element of the array were dropped first. The same applies to tuples and structs, where the most intuitive behavior is for the first tuple element or field to be dropped first, then the second, and so on. Unlike for variables, there is no need to reverse the drop order in this case, since Rust doesn’t (currently) allow self-references in a single value. So, Rust goes with the intuitive option.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-123456c01-0003">Borrowing and Lifetimes</h2>
<p class="BodyFirst">Rust allows the owner of a value to lend out that value to others, without giving up ownership, through references. <em>References</em> are pointers that come with an additional contract for how they can be used, such as whether the reference provides exclusive access to the referenced value, or whether the referenced value may also have other references point to it.</p>
<h3 id="h2-123456c01-0004">Shared References</h3>
<p class="BodyFirst">A shared reference, <code>&amp;T</code>, is, as the name implies, a pointer that may be shared. Any number of other references may exist to the same value, and each shared reference is <code>Copy</code>, so you can trivially make more of them. Values behind shared references are not mutable; you cannot modify or reassign the value a shared reference points to, nor can you cast a shared reference to a mutable one.</p>
<p>The Rust compiler is allowed to assume that the value a shared reference points to <em>will not change</em> while that reference lives. For example, if the Rust compiler sees that the value behind a shared reference is read multiple times in a function, it is within its rights to read it only once and reuse that value. More concretely, the assertion in <a href="#listing1-4" id="listinganchor1-4">Listing 1-4</a> should never fail.</p>
<pre><code><span epub:type="pagebreak" title="10" id="Page_10"/>fn cache(input: &amp;i32, sum: &amp;mut i32) {
  *sum = *input + *input;
  assert_eq!(*sum, 2 * *input);
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-4">Listing 1-4</a>: Rust assumes that shared references are immutable.</p>
<p>Whether or not the compiler chooses to apply a given optimization is more or less irrelevant. The compiler heuristics change over time, so you generally want to code against what the compiler is allowed to do rather than what it actually does in a particular case at a particular moment in time.</p>
<h3 id="h2-123456c01-0005">Mutable References</h3>
<p class="BodyFirst">The alternative to a shared reference is a mutable reference: <code>&amp;mut T</code>. With mutable references, the Rust compiler is again allowed to make full use of the contract that the reference comes with: the compiler assumes that there are no other threads accessing the target value, whether through a shared reference or a mutable one. In other words, it assumes that the mutable reference is <em>exclusive</em>. This enables some interesting optimizations that are not readily available in other languages. Take, for example, the code in <a href="#listing1-5" id="listinganchor1-5">Listing 1-5</a>.</p>
<pre><code>fn noalias(input: &amp;i32, output: &amp;mut i32) {
  if *input == 1 {
   <span class="CodeAnnotationCode" aria-label="annotation1">1</span> *output = 2;
  }
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> if *input != 1 {
     *output = 3;
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-5">Listing 1-5</a>: Rust assumes that mutable references are exclusive.</p>
<p>In Rust, the compiler can assume that <code>input</code> and <code>output</code> do not point to the same memory. Therefore, the reassignment of <code>output</code> at <span class="CodeAnnotation" aria-label="annotation1">1</span> cannot affect the check at <span class="CodeAnnotation" aria-label="annotation2">2</span>, and the entire function can be compiled as a single <code>if-else</code> block. If the compiler could not rely on the exclusive mutability contract, that optimization would be invalid, since an <code>input</code> of <code>1</code> could then result in an <code>output</code> of <code>3</code> in a case like <code>noalias(&amp;x, &amp;mut x)</code>.</p>
<p>A mutable reference lets you mutate only the memory location that the reference points to. Whether you can mutate values that lie beyond the immediate reference depends on the methods provided by the type that lies between. This may be easier to understand with an example, so consider <a href="#listing1-6" id="listinganchor1-6">Listing 1-6</a>.</p>
<pre><code>let x = 42;
let mut y = &amp;x; <span class="LiteralGray">// y is of type &amp;i32</span>
let z = &amp;mut y; <span class="LiteralGray">// z is of type &amp;mut &amp;i32</span></code></pre>
<p class="CodeListingCaption"><a id="listing1-6">Listing 1-6</a>: Mutability applies only to the immediately referenced memory.</p>
<p><span epub:type="pagebreak" title="11" id="Page_11"/>In this example, you are able to change the value of the pointer <code>y</code> to a different value (that is, a different pointer) by making it reference a different variable, but you cannot change the value that is pointed to (that is, the value of <code>x</code>). Similarly, you can change the pointer value of <code>y</code> through <code>z</code>, but you cannot change <code>z</code> itself to hold a different reference.</p>
<p>The primary difference between owning a value and having a mutable reference to it is that the owner is responsible for dropping the value when it is no longer necessary. Apart from that, you can do anything through a mutable reference that you can if you own the value, with one caveat: if you move the value behind the mutable reference, then you must leave another value in its place. If you did not, the owner would still think it needed to drop the value, but there would be no value for it to drop!</p>
<p><a href="#listing1-7" id="listinganchor1-7">Listing 1-7</a> gives an example of the ways in which you can move the value behind a mutable reference.</p>
<pre><code>fn replace_with_84(s: &amp;mut Box&lt;i32&gt;) {
  <span class="LiteralGray">// this is not okay, as *s would be empty:</span>
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> <span class="LiteralGray">// let was = *s;</span>
  <span class="LiteralGray">// but this is:</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> let was = std::mem::take(s);
  <span class="LiteralGray">// so is this:</span>
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> *s = was;
  <span class="LiteralGray">// we can exchange values behind &amp;mut:</span>
  let mut r = Box::new(84);
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> std::mem::swap(s, &amp;mut r);
  assert_ne!(*r, 84);
}
let mut s = Box::new(42);
replace_with_84(&amp;mut s);
<span class="CodeAnnotationHang" aria-label="annotation5">5</span></code></pre>
<p class="CodeListingCaption"><a id="listing1-7">Listing 1-7</a>: Access through a mutable reference must leave a value behind.</p>
<p>I’ve added commented-out lines that represent illegal operations. You cannot simply move the value out <span class="CodeAnnotation" aria-label="annotation1">1</span> since the caller would still think they owned that value and would free it again at <span class="CodeAnnotation" aria-label="annotation5">5</span>, leading to a double free. If you just want to leave some valid value behind, <code>std::mem::take</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> is a good candidate. It is equivalent to <code>std::mem::replace(&amp;mut value, Default::default())</code>; it moves <code>value</code> out from behind the mutable reference but leaves a new, default value for the type in its place. The default is a separate, owned value, so it is safe for the caller to drop it when the scope ends at <span class="CodeAnnotation" aria-label="annotation5">5</span>.</p>
<p>Alternatively, if you don’t need the old value behind the reference, you can overwrite it with a value that you already own <span class="CodeAnnotation" aria-label="annotation3">3</span>, leaving it to the caller to drop the value later. When you do this, the value that used to be behind the mutable reference is dropped immediately.</p>
<p>Finally, if you have two mutable references, you can swap their values without owning either of them <span class="CodeAnnotation" aria-label="annotation4">4</span>, since both references will end up with a legal owned value for their owners to eventually free.</p>
<h3 id="h2-123456c01-0006"><span epub:type="pagebreak" title="12" id="Page_12"/>Interior Mutability</h3>
<p class="BodyFirst">Some types provide <em>interior mutability</em>, meaning they allow you to mutate a value through a shared reference. These types usually rely on additional mechanisms (like atomic CPU instructions) or invariants to provide safe mutability without relying on the semantics of exclusive references. These normally fall into two categories: those that let you get a mutable reference through a shared reference, and those that let you replace a value given only a shared reference.</p>
<p>The first category consists of types like <code>Mutex</code> and <code>RefCell</code>, which contain safety mechanisms to ensure that, for any value they give a mutable reference to, only one mutable reference (and no shared references) can exist at a time. Under the hood, these types (and those like them) all rely on a type called <code>UnsafeCell</code>, whose name should immediately make you hesitate to use it. We will cover <code>UnsafeCell</code> in more detail in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>, but for now you should know that it is the <em>only</em> correct way to mutate through a shared reference.</p>
<p>Other categories of types that provide interior mutability are those that do not give out a mutable reference to the inner value but instead just give you methods for manipulating that value in place. The atomic integer types in <code>std::sync::atomic</code> and the <code>std::cell::Cell</code> type fall into this category. You cannot get a reference directly to the <code>usize</code> or <code>i32</code> behind such a type, but you can read and replace its value at a given point in time.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The <var>Cell</var> type in the standard library is an interesting example of safe interior mutability through invariants. It is not shareable across threads and never gives out a reference to the value contained in the <var>Cell</var>. Instead, the methods all either replace the value entirely or return a copy of the contained value. Since no references can exist to the inner value, it is always okay to move it. And since <var>Cell</var> isn’t shareable across threads, the inner value will never be concurrently mutated even though mutation happens through a shared reference.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-123456c01-0007">Lifetimes</h3>
<p class="BodyFirst">If you’re reading this book, you’re probably already familiar with the concept of lifetimes, likely through repeated notices from the compiler about lifetime rules violations. That level of understanding will serve you well for the majority of Rust code you will write, but as we dive deeper into the more complex parts of Rust, you will need a more rigorous mental model to work with.</p>
<p>Newer Rust developers are often taught to think of lifetimes as corresponding to scopes: a lifetime begins when you take a reference to some variable and ends when that variable is moved or goes out of scope. That’s often correct, and usually useful, but the reality is a little more complex. A <em>lifetime</em> is really a name for a region of code that some reference must be valid for. While a lifetime will frequently coincide with a scope, it does not have to, as we will see later in this section.</p>
<h4 id="h3-123456c01-0006"><span epub:type="pagebreak" title="13" id="Page_13"/>Lifetimes and the Borrow Checker</h4>
<p class="BodyFirst">At the heart of Rust lifetimes is the <em>borrow checker</em>. Whenever a reference with some lifetime <code>'a</code> is used, the borrow checker checks that <code>'a</code> is still <em>alive</em>. It does this by tracing the path back to where <code>'a</code> starts—where the reference was taken—from the point of use and checking that there are no conflicting uses along that path. This ensures that the reference still points to a value that it is safe to access. This is similar to the high-level “data flow” mental model we discussed earlier in the chapter; the compiler checks that the flow of the reference we are accessing does not conflict with any other parallel flows.</p>
<p><a href="#listing1-8" id="listinganchor1-8">Listing 1-8</a> shows a simple code example with lifetime annotations for the reference to <code>x</code>.</p>
<pre><code>let mut x = Box::new(42);
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> let r = &amp;x;           <span class="LiteralGray">// 'a</span>
if rand() &gt; 0.5 {
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> *x = 84;
} else {
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> println!("{}", r);  <span class="LiteralGray">// 'a</span>
}
<span class="CodeAnnotationHang" aria-label="annotation4">4</span></code></pre>
<p class="CodeListingCaption"><a id="listing1-8">Listing 1-8</a>: Lifetimes do not need to be contiguous.</p>
<p>The lifetime starts at <span class="CodeAnnotation" aria-label="annotation1">1</span> when we take a reference to <code>x</code>. In the first branch <span class="CodeAnnotation" aria-label="annotation2">2</span>, we then immediately try to modify <code>x</code> by changing its value to <code>84</code>, which requires a <code>&amp;mut x</code>. The borrow checker takes out a mutable reference to <code>x</code> and immediately checks its use. It finds no conflicting uses between when the reference was taken and when it was used, so it accepts the code. This may come as a surprise if you are used to thinking about lifetimes as scopes, since <code>r</code> is still in scope at <span class="CodeAnnotation" aria-label="annotation2">2</span> (it goes out of scope at <span class="CodeAnnotation" aria-label="annotation4">4</span>). But the borrow checker is smart enough to realize that <code>r</code> is never used later if this branch is taken, and therefore it is fine for <code>x</code> to be mutably accessed here. Or, phrased differently, the lifetime created at <span class="CodeAnnotation" aria-label="annotation1">1</span> does not extend into this branch: there is no flow from <code>r</code> beyond <span class="CodeAnnotation" aria-label="annotation2">2</span>, and therefore there are no conflicting flows. The borrow checker then finds the use of <code>r</code> in the print statement at <span class="CodeAnnotation" aria-label="annotation3">3</span>. It walks the path back to <span class="CodeAnnotation" aria-label="annotation1">1</span> and finds no conflicting uses (<span class="CodeAnnotation" aria-label="annotation2">2</span> is not on that path), so it accepts this use as well.</p>
<p>If we were to add another use of <code>r</code> at <span class="CodeAnnotation" aria-label="annotation4">4</span> in <a href="#listing1-8">Listing 1-8</a>, the code would no longer compile. The lifetime <code>'a</code> would then last from <span class="CodeAnnotation" aria-label="annotation1">1</span> all the way until <span class="CodeAnnotation" aria-label="annotation4">4</span> (the last use of <code>r</code>), and when the borrow checker checked our new use of <code>r</code>, it would discover a conflicting use at <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
<p>Lifetimes can get quite convoluted. In <a href="#listing1-9" id="listinganchor1-9">Listing 1-9</a> you can see an example of a lifetime that has <em>holes</em>, where it’s intermittently invalid between where it starts and where it ultimately ends.</p>
<pre><code><span epub:type="pagebreak" title="14" id="Page_14"/>let mut x = Box::new(42);
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> let mut z = &amp;x;          <span class="LiteralGray">// 'a</span>
for i in 0..100 {
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> println!("{}", z);     <span class="LiteralGray">// 'a</span>
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> x = Box::new(i);
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> z = &amp;x;                <span class="LiteralGray">// 'a</span>
}
println!("{}", z);       <span class="LiteralGray">// 'a</span></code></pre>
<p class="CodeListingCaption"><a id="listing1-9">Listing 1-9</a>: Lifetimes can have holes.</p>
<p>The lifetime starts at <span class="CodeAnnotation" aria-label="annotation1">1</span> when we take a reference to <code>x</code>. We then move out of <code>x</code> at <span class="CodeAnnotation" aria-label="annotation3">3</span>, which ends the lifetime <code>'a</code> because it is no longer valid. The borrow checker accepts this move by considering <code>'a</code> ended at <span class="CodeAnnotation" aria-label="annotation2">2</span>, which leaves no conflicting flows from <code>x</code> at <span class="CodeAnnotation" aria-label="annotation3">3</span>. Then, we restart the lifetime by updating the reference in <code>z</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>. Regardless of whether the code now loops back around to <span class="CodeAnnotation" aria-label="annotation2">2</span> or continues to the final print statement, both of those uses now have a valid value to flow from, and there are no conflicting flows, so the borrow checker accepts the code!</p>
<p>Again, this aligns perfectly with the data-flow model of memory we discussed earlier. When <code>x</code> is moved, <code>z</code> stops existing. When we reassign <code>z</code> later, we are creating an entirely new variable that exists only from that point forward. It just so happens that that new variable is also named <code>z</code>. With that model in mind, this example is not weird.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The borrow checker is, and has to be, conservative. If it’s unsure whether a borrow is valid, it rejects it, as the consequences of allowing an invalid borrow could be disastrous. The borrow checker keeps getting smarter, but there are times when it needs help to understand why a borrow is legal. This is part of why we have unsafe Rust.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-123456c01-0007">Generic Lifetimes</h4>
<p class="BodyFirst">Occasionally you need to store references within your own types. Those references need to have a lifetime so that the borrow checker can check their validity when they are used in the various methods on that type. This is especially true if you want a method on your type to return a reference that outlives the reference to <code>self</code>.</p>
<p>Rust lets you make a type definition generic over one or more lifetimes, just as it allows you to make it generic over types. <em>The Rust Programming Language </em>by Steve Klabnik and Carol Nichols (No Starch Press, 2018) covers this topic in some detail, so I won’t reiterate the basics here. But as you write more complex types of this nature, there are two subtleties around the interaction between such types and lifetimes that you should be aware of.</p>
<p>First, if your type also implements <code>Drop</code>, then dropping your type counts as a use of any lifetime or type your type is generic over. Essentially, when an instance of your type is dropped, the borrow checker will check that it’s still legal to use any of your type’s generic lifetimes before dropping it. This is necessary in case your drop code <em>does</em> use any of those references. If your type does not implement <code>Drop</code>, dropping the type does <em>not</em> count as a use, <span epub:type="pagebreak" title="15" id="Page_15"/>and users are free to ignore any references stored in your type as long as they do not use it anymore, like we saw in <a href="#listing1-7">Listing 1-7</a>. We’ll talk more about these rules around dropping in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>.</p>
<p>Second, while a type can be generic over multiple lifetimes, making it so often only serves to unnecessarily complicate your type signature. Usually, a type being generic over a single lifetime is fine, and the compiler will use the shorter of the lifetimes for any references inserted into your type as that one lifetime. You should only really use multiple generic lifetime parameters if you have a type that contains multiple references, and its methods return references that should be tied to the lifetime of only <em>one</em> of those references. </p>
<p>Consider the type in <a href="#listing1-10" id="listinganchor1-10">Listing 1-10</a>, which gives you an iterator over parts of a string separated by a particular other string.</p>
<pre><code>struct StrSplit&lt;'s, 'p&gt; {
  delimiter: &amp;'p str,
  document: &amp;'s str,
}
impl&lt;'s, 'p&gt; Iterator for StrSplit&lt;'s, 'p&gt; {
  type Item = &amp;'s str;
  fn next(&amp;self) -&gt; Option&lt;Self::Item&gt; {
    todo!()
  }
}
fn str_before(s: &amp;str, c: char) -&gt; Option&lt;&amp;str&gt; {
  StrSplit { document: s, delimiter: &amp;c.to_string() }.next()
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-10">Listing 1-10</a>: A type that needs to be generic over multiple lifetimes</p>
<p>When you construct this type, you have to give the <code>delimiter</code> and <code>document</code> to search, both of which are references to string values. When you ask for the next string, you get a reference into the document. Consider what would happen if you used a single lifetime in this type. The values yielded by the iterator would be tied to the lifetime of the <code>document</code> <em>and</em> the <code>delimiter</code>. This would make <code>str_before</code> impossible to write: the return type would have a lifetime associated with a variable local to the function—the <code>String</code> produced by <code>to_string</code>—and the borrow checker would reject the code.</p>
<h4 id="h3-123456c01-0008">Lifetime Variance</h4>
<p class="BodyFirst">Variance is a concept that programmers are often exposed to but rarely know the name of because it’s mostly invisible. At a glance, variance describes what types are subtypes of other types and when a subtype can be used in place of a supertype (and vice versa). Broadly speaking, a type <code>A</code> is a subtype of another type <code>B</code> if <code>A</code> is at least as useful as <code>B</code>. Variance is the reason why, in Java, you can pass a <code>Turtle</code> to a function that accepts an <code>Animal</code> if <code>Turtle</code> is a subtype of <code>Animal</code>, or why, in Rust, you can pass a <code>&amp;'static str</code> to a function that accepts a <code>&amp;'a str</code>. </p>
<p>While variance usually hides out of sight, it comes up often enough that we need to have a working knowledge of it. <code>Turtle</code> is a subtype of <code>Animal</code> <span epub:type="pagebreak" title="16" id="Page_16"/>because a <code>Turtle</code> is more “useful” than some unspecified <code>Animal</code>—a <code>Turtle</code> can do anything an <code>Animal</code> can do, and likely more. Similarly, <code>'static</code> is a subtype of <code>'a</code> because a <code>'static</code> lives at least as long as any <code>'a</code> and so is more useful. Or, more generally, if <code>'b: 'a</code> (<code>'b</code> outlives <code>'a</code>), then <code>'b</code> is a subtype of <code>'a</code>. This is obviously not the formal definition, but it gets close enough to be of practical use.</p>
<p>All types have a variance, which defines what other similar types can be used in that type’s place. There are three kinds of variance: covariant, invariant, and contravariant. A type is <em>covariant</em> if you can just use a subtype in place of the type. For example, if a variable is of type <code>&amp;'a T</code>, you can provide a value of type <code>&amp;'static T</code> to it, because <code>&amp;'a T</code> is covariant in <code>'a</code>. <code>&amp;'a T</code> is also covariant in <code>T</code>, so you can pass a <code>&amp;Vec&lt;&amp;'static str&gt;</code> to a function that takes <code>&amp;Vec&lt;&amp;'a str&gt;</code>.</p>
<p>Some types are <em>invariant</em>, which means that you must provide exactly the given type. <code>&amp;mut T</code> is an example of this—if a function takes a <code>&amp;mut Vec&lt;&amp;'a str&gt;</code>, you cannot pass it a <code>&amp;mut Vec&lt;&amp;'static str&gt;</code>. That is, <code>&amp;mut T</code> is invariant in <code>T</code>. If you could, the function could put a short-lived string inside the <code>Vec</code>, which the caller would then continue using, thinking that it were a <code>Vec&lt;&amp;'static str&gt;</code> and thus that the contained string were <code>'static</code>! Any type that provides mutability is generally invariant for the same reason—for example, <code>Cell&lt;T&gt;</code> is invariant in <code>T</code>.</p>
<p>The last category, <em>contravariance</em>, comes up for function arguments. Function types are more useful if they’re okay with their arguments being <em>less</em> useful. This is clearer if you contrast the variance of the argument types on their own with their variance when used as function arguments:</p>
<pre><code>let x: &amp;'static str; <span class="LiteralGray">// more useful, lives longer</span>
let x: &amp;'a      str; <span class="LiteralGray">// less useful, lives shorter</span>

fn take_func1(&amp;'static str) <span class="LiteralGray">// stricter, so less useful</span>
fn take_func2(&amp;'a str)      <span class="LiteralGray">// less strict, more useful</span></code></pre>
<p>This flipped relationship indicates that <code>Fn(T)</code> is contravariant in <code>T</code>.</p>
<p>So why do you need to learn about variance when it comes to lifetimes? Variance becomes relevant when you consider how generic lifetime parameters interact with the borrow checker. Consider a type like the one shown in <a href="#listing1-11" id="listinganchor1-11">Listing 1-11</a>, which uses multiple lifetimes in a single field.</p>
<pre><code>struct MutStr&lt;'a, 'b&gt; {
  s: &amp;'a mut &amp;'b str
}
let mut s = "hello";
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> *MutStr { s: &amp;mut s }.s = "world";
println!("{}", s);</code></pre>
<p class="CodeListingCaption"><a id="listing1-11">Listing 1-11</a>: A type that needs to be generic over multiple lifetimes</p>
<p>At first glance, using two lifetimes here seems unnecessary—we have no methods that need to differentiate between a borrow of different parts of the structure, as we did with <code>StrSplit</code> in <a href="#listing1-10">Listing 1-10</a>. But if you replace the <span epub:type="pagebreak" title="17" id="Page_17"/>two lifetimes here with a single <code>'a</code>, the code no longer compiles! And it’s all because of variance.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The syntax at 1 may seem alien. It’s equivalent to defining a variable <code>x</code> holding a <code>MutStr</code> and then writing <code>*x.s = "world"</code>, except that there’s no variable and so the <code>MutStr</code> is dropped immediately.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>At <span class="CodeAnnotation" aria-label="annotation1">1</span>, the compiler must determine what lifetime the lifetime parameter(s) should be set to. If there are two lifetimes, <code>'a</code> is set to the to-be-determined lifetime of the borrow of <code>s</code>, and <code>'b</code> is set to <code>'static</code> since that’s the lifetime of the provided string <code>"hello"</code>. If there is just one lifetime <code>'a</code>, the compiler infers that that lifetime must be <code>'static</code>. </p>
<p>When we later attempt to access the string reference <code>s</code> through a shared reference to print it, the compiler tries to shorten the mutable borrow of <code>s</code> used by <code>MutStr</code> to allow the shared borrow of <code>s</code>.</p>
<p>In the two-lifetime case, <code>'a</code> simply ends just before the <code>println</code>, and <code>'b</code> stays the same. In the single-lifetime case, on the other hand, we run into issues. The compiler wants to shorten the borrow of <code>s</code>, but to do so, it would also have to shorten the borrow of the <code>str</code>. While <code>&amp;'static str</code> can in general be shortened to any <code>&amp;'a str</code> (<code>&amp;'a T</code> is covariant in <code>'a</code>), here it’s behind a <code>&amp;mut T</code>, which is invariant in <code>T</code>. Invariance requires that the relevant type is never replaced with a sub- or supertype, so the compiler’s attempt to shorten the borrow fails, and it reports that <code>s</code> is still mutably borrowed. Ouch!</p>
<p>Because of the reduced flexibility imposed by invariance, you want to ensure that your types remain covariant (or contravariant where appropriate) over as many of their generic parameters as possible. If that requires introducing additional lifetime arguments, you need to carefully weigh the cognitive cost of adding another parameter against the ergonomic cost of invariance.</p>
<h2 id="h1-123456c01-0004">Summary</h2>
<p class="BodyFirst">The aim of this chapter has been to establish a solid, shared foundation that we can build on in the chapters to come. By now, I hope you feel that you have a firm grasp on Rust’s memory and ownership model, and that those errors you may have gotten from the borrow checker seem less mysterious. You might have known bits and pieces of what we covered here already, but hopefully the chapter has given you a more holistic image of how it all fits together. In the next chapter, we will do something similar for types. We’ll go over how types are represented in memory, see how generics and traits produce running code, and take a look at some of the special type and trait constructs Rust offers for more advanced use cases.</p>
</section>
</div></body></html>