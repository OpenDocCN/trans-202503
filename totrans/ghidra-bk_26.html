<html><head></head><body><div id="sbo-rt-content"><span epub:type="pagebreak" id="page_469"/>
<h2 class="h2" id="ch21"><strong><span class="big">21</span><br/>OBFUSCATED CODE ANALYSIS</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindent"><span class="big1">Even under ideal circumstances, comprehending a disassembly listing is a difficult task. High-quality disassemblies are essential for anyone trying to understand the inner workings of a binary, which is precisely why we have spent the last 20 chapters discussing Ghidra and its associated</span> capabilities. It can be argued that Ghidra is so effective at what it does that it has lowered the barrier for entry into the binary analysis field. While certainly not attributable to Ghidra alone, recent advances in binary reverse engineering are not lost on anyone who does not want their software to be analyzed. Thus, over the last several years, an arms race of sorts has been taking place between programmers who wish to keep their code secret and reverse engineers</p>
<p class="indent">In this chapter, we examine Ghidra’s role in this arms race and discuss some of the measures that have been taken to protect code, along with approaches to defeating those measures. We wrap up the chapter by introducing Ghidra’s <span class="literal">Emulator</span> class and provide examples of how emulation scripts can give us an edge in this arms race.</p>
<span epub:type="pagebreak" id="page_470"/>
<h3 class="h3" id="ch21lev386"><strong>Anti–Reverse Engineering</strong></h3>
<p class="noindent"><em>Anti–reverse engineering</em> is an umbrella topic that covers all techniques that software developers might employ to make reverse engineering their products more challenging. Many tools and techniques exist to assist developers with this goal, with more appearing every day. The RE/anti-RE ecosystem is similar to the escalating dynamic that plays out between malware authors and antivirus vendors.</p>
<p class="indent">As a reverse engineer, you are likely to encounter techniques ranging from trivial to nearly impossible to defeat. The approaches that you will be required to use will also vary depending on the nature of the anti-reversing techniques you encounter, and may require some level of comfort with both static and dynamic analysis techniques. In the sections that follow, we discuss some of the more common anti-reversing techniques, why they are employed, and approaches for defeating them.</p>
<h4 class="h4" id="ch21lev387"><strong><em>Obfuscation</em></strong></h4>
<p class="noindent">Various dictionary definitions will inform you that <em>obfuscation</em> is the act of making something obscure, perplexing, confusing, or bewildering in order to prevent others from understanding the obfuscated item. In the context of this book and the use of Ghidra, the items being obfuscated are binary executable files (as opposed to source files or silicon chips, for example).</p>
<p class="indent">Obfuscation, by itself, is too broad to be considered an anti–reverse engineering technique. It also fails to cover all known anti–reverse engineering techniques. Specific, individual techniques can often be described as obfuscating or non-obfuscating techniques and, where applicable, we point these out in the sections that follow. It is important to note that there is no one correct way to categorize techniques, as the general categories often overlap in their descriptions. In addition, new anti–reverse engineering techniques are under continuous development, and it is not possible to provide a single all-inclusive list.</p>
<p class="indent">Because Ghidra is primarily a static analysis tool, we find it more useful to divide our discussion of techniques into two, broad categories: <em>anti–static analysis</em> and <em>anti–dynamic analysis</em>. Both categories may contain obfuscating techniques, but the former is more likely to confound static tools, while the latter generally targets debuggers and other runtime analysis tools.</p>
<h4 class="h4" id="ch21lev388"><strong><em>Anti–Static Analysis Techniques</em></strong></h4>
<p class="noindent"><em>Anti–static analysis techniques</em> aim to prevent an analyst from understanding the nature of a program without actually running the program. These are precisely the types of techniques that target disassemblers such as Ghidra and are thus of greatest concern whenever you are using Ghidra to reverse engineer binaries. Several types of anti–static analysis techniques are discussed here.</p>
<span epub:type="pagebreak" id="page_471"/>
<h5 class="h5" id="ch21lev389"><strong>Disassembly Desynchronization</strong></h5>
<p class="noindent">One of the older techniques designed to frustrate the disassembly process involves the creative use of instructions and data to prevent the disassembler from finding the correct starting address for one or more instructions. Forcing the disassembler to lose track of itself usually results in a failed or, at a minimum, incorrect disassembly listing. <a href="ch21.xhtml#exa21_1">Listing 21-1</a> shows Ghidra’s efforts to disassemble a portion of the Shiva anti–reverse engineering tool.<sup><a id="ch21fn1a" href="footnotes.xhtml#ch21fn1">1</a></sup></p>
<p class="programs">  0a04b0d1 e8 01 00 00 00 CALL<span class="ent">➊</span> FUN_0a04b0d7<br/>
  0a04b0d6 c7             ??     C7h<span class="ent">➋</span><br/>
       ************************************************************<br/>
       *                         FUNCTION                         *<br/>
       ************************************************************<br/>
       undefined FUN_0a04b0d7()<br/>
          undefined AL:1 &lt;RETURN&gt;<br/>
       FUN_0a04b0d7                           XREF[1]: FUN_0a04b0c4:0a04b0d1(c)<br/>
  0a04b0d7 58             POP<span class="ent">➌</span>  EAX<br/>
  0a04b0d8 8d 40 0a       LEA<span class="ent">➍</span>  EAX,[EAX + 0xa]<br/>
          LAB_0a04b0db+1                      XREF[0,1]: 0a04b0db(j)<br/>
<span class="ent">➎</span> 0a04b0db eb ff          JMP   LAB_0a04b0db+1<br/>
  0a04b0dd e0             ??<span class="ent">➏</span>   E0h</p>
<p class="ex-caption" id="exa21_1"><em>Listing 21-1: Sample of initial Shiva disassembly</em></p>
<p class="indent">This example executes a <span class="literal">CALL</span> <span class="ent">➊</span> that is immediately followed by a <span class="literal">POP</span> <span class="ent">➌</span>. This sequence is not uncommon in self-modifying code and is used by the code to discover where it is running memory. The return address <span class="ent">➋</span> for the call instruction is <span class="literal">0a04b0d6</span> and sits on the top of the stack as execution arrives at the <span class="literal">POP</span> instruction. The <span class="literal">POP</span> instruction removes the return address from the stack and loads it into <span class="literal">EAX</span>, while the <span class="literal">LEA</span> that follows <span class="ent">➍</span> immediately adds <span class="literal">0xa</span> (10) to <span class="literal">EAX</span> so that <span class="literal">EAX</span> now holds <span class="literal">0a04b0e0</span> (keep this value handy, as we’ll use it in a few moments).</p>
<p class="indent">The called function is unlikely to ever return to the original call point, as the original return address is no longer on top of the stack (it would need to be replaced in order to <span class="literal">RET</span> to the original return location), and Ghidra cannot form an instruction at the return address <span class="ent">➋</span> because <span class="literal">C7h</span> is not a valid start byte for an instruction.</p>
<p class="indent">So far, the code may be a little unusual or difficult to follow, but Ghidra is presenting a correct disassembly. This all changes when the <span class="literal">JMP</span> <span class="ent">➎</span> instruction is reached. This jump instruction is 2 bytes long, its address is <span class="literal">0a04b0db</span>, and the jump target is <span class="literal">LAB_0a04b0db+1</span>. The <span class="literal">+1</span> suffix in the label is new to us. The address component of the label is the same as the address of the jump itself. The <span class="literal">+1</span> is telling you that the jump target is 1 byte past <span class="literal">LAB_0a04b0db</span>. In other words, the jump lands right in the middle of the 2-byte jump instruction. While the processor doesn’t care about this unusual situation (it will happily fetch whatever the instruction pointer points to), Ghidra <span epub:type="pagebreak" id="page_472"/>just can’t make it work. Ghidra has no means to concurrently display the byte at <span class="literal">0a04b0db</span> (<span class="literal">ff</span>) as both the second byte of the jump and the first byte of another instruction. As a result, Ghidra is suddenly unable to continue with the disassembly, as indicated by the undefined data value at <span class="literal">0a04b0dd</span> <span class="ent">➏</span>. (This behavior is not restricted to Ghidra: virtually all disassemblers, whether they utilize a recursive descent algorithm or a linear sweep algorithm, fall victim to this technique.)</p>
<p class="indent">Ghidra makes note of any problems it encounters during disassembly by creating <em>error bookmarks</em> in the disassembly. <a href="ch21.xhtml#fig21_1">Figure 21-1</a> shows two such bookmarks (X icon to the left of the offending addresses) in the left margin of the Listing window. Hovering over an error bookmark displays an associated detail message. In addition, you can open a listing of all bookmarks in the current binary by using Window ▸ Bookmarks.</p>
<p class="indent">Ghidra’s message for the first error is “Unable to resolve constructor at 0a04b0d6 (flow from 0a04b0d1),” which means roughly “I think an instruction is supposed to exist at 0a04b0d6, but I couldn’t create one.” Ghidra’s message for the second error is “Failed to disassemble at 0a04b0dc due to conflicting instruction at 0a04b0db (flow from 0a04b0db),” which means roughly “I cannot disassemble an instruction within an existing instruction.”</p>
<div class="image"><img src="Images/fig21-1.jpg" alt="image" width="507" height="292"/></div>
<p class="figcap" id="fig21_1"><em>Figure 21-1: Ghidra error bookmarks</em></p>
<p class="indent">As a Ghidra user, you have no solution for the first error. A byte sequence is either a valid instruction or it isn’t. With a bit of effort on your part, you can deal with the second error. The proper way to deal with this situation is to undefine the instruction that contains the bytes that are the target of the call and then define an instruction at the call target address in an attempt to resynchronize the disassembly. You will lose the original instruction, but you can leave yourself a comment to remind you of what the original instruction was. The following portion of the previous listing contains the overlapping instruction error:</p>
<p class="programs">          LAB_0a04b0db+1                       XREF[0,1]:   0a04b0db(j)<br/>
<span class="ent">➊</span> 0a04b0db eb ff    JMP    LAB_0a04b0db+1<br/>
  0a04b0dd e0        ??     E0h</p>
<span epub:type="pagebreak" id="page_473"/>
<p class="indent">Right-clicking the <span class="literal">JMP</span> instruction <span class="ent">➊</span> and selecting Clear Code Bytes (hotkey C) from the context menu yields the following listing of undefined bytes:</p>
<p class="programs">  0a04b0db eb        ??     EBh<br/>
<span class="ent">➊</span> 0a04b0dc ff       ??     FFh<br/>
  0a04b0dd e0        ??     E0h</p>
<p class="indent">The byte that is the target <span class="ent">➊</span> of the <span class="literal">JMP</span> is now accessible for reformatting. Raw bytes are changed to code by right-clicking the start byte of an instruction and selecting Disassemble (hotkey D). The listing is now updated to the following:</p>
<p class="programs"><span class="ent">➊</span> 0a04b0dc ff e0    JMP    EAX<br/>
  0a04b0de 90        ??     90h<br/>
  0a04b0df c7        ??     C7h</p>
<p class="indent">The target of the jump instruction turns out to be yet another jump instruction <span class="ent">➊</span>. In this case, however, the jump is impossible for a disassembler (and potentially confusing to the human analyst) to follow, as the target of the jump is contained in a register (<span class="literal">EAX</span>) and computed at runtime. This is an example of another type of anti–static analysis technique, discussed in the following section, “Dynamically Computed Target Addresses.” We previously determined that <span class="literal">EAX</span> contains the value <span class="literal">0a04b0e0</span> by the time we reach this jump, and this is the address at which we must resume the disassembly process. Lather, rinse, repeat.</p>
<p class="indent">Referring back to <a href="ch21.xhtml#exa21_1">Listing 21-1</a>, as an alternative to manually moving to address <span class="literal">0a04b0e0</span> to resume the disassembly, you can set the value of <span class="literal">EAX</span> to the known value by right-clicking the address <span class="ent">➌</span> and selecting Set Register Values. Ghidra will then add a special markup called a <em>register transition</em> around the instruction to indicate the <em>assumed</em> value of the <span class="literal">JMP</span> target, <span class="literal">EAX</span>. Subsequent clearing (hotkey C) and disassembling (hotkey D) from this location will restart the recursive descent disassembly process from the <span class="literal">JMP</span> to the target, <span class="literal">0a04b0e0</span>, and beyond (including creating the XREFs between those code blocks).</p>
<p class="indent">An advantage of this approach is that the code is annotated to show the target of the <span class="literal">JMP</span>, allowing other analysts to easily follow the effective control flow through this section. (This is even clearer when combined with an override to the fallthrough for the <span class="literal">LEA</span> instruction at <span class="literal">0a04b0d8</span> in <a href="ch21.xhtml#exa21_1">Listing 21-1</a>). This alternative approach results in the following listing:</p>
<p class="programs">0a04b0d7 58        POP    EAX<br/>
0a04b0d8 8d 40 0a  LEA    EAX,[EAX + 0xa]<br/>
                      -- Fallthrough Override: 0a04b0dc<br/>
0a04b0db eb        ??     EBh<br/>
            assume EAX = 0xa04b0e0<br/>
        LAB_0a04b0dc                         XREF[1]:     0a04b0d8  <br/>
0a04b0dc ff e0     JMP    EAX=&gt;LAB_0a04b0e0<br/>
            assume EAX = &lt;UNKNOWN&gt;<br/>
0a04b0de 90        ??     90h<br/>
0a04b0df c7        ??     C7h<br/>
<span epub:type="pagebreak" id="page_474"/>
        LAB_0a04b0e0                         XREF[1]:     0a04b0dc(j)  <br/>
0a04b0e0 58        POP    EAX 0a04b0e0 POP EAX</p>
<p class="indent">Another example of desynchronization taken from a different binary demonstrates how processor flags may be utilized to turn conditional jumps into absolute jumps. The following disassembly demonstrates the use of the x86 <span class="literal">Z</span> flag for just such a purpose:</p>
<p class="programs">  00401000  XOR<span class="ent">➊</span>  EAX,EAX<br/>
  00401002  JZ<span class="ent">➋</span>   LAB_00401009+1<br/>
  00401004  MOV    EBX,dword ptr [EAX]<br/>
  00401006  MOV    dword ptr [param_1 + -0x4],EBX<br/>
       <span class="ent">➌</span> LAB_00401009+1                       XREF[0,1]: 00401002(j)<br/>
<span class="ent">➍</span> 00401009  CALL   SUB_adfeffc6<br/>
  0040100e  FICOM  word ptr [EAX + 0x59]</p>
<p class="indent">Here, the <span class="literal">XOR</span> instruction <span class="ent">➊</span> is used to zero the <span class="literal">EAX</span> register and set the x86 <span class="literal">Z</span> flag. The programmer, knowing that the <span class="literal">Z</span> flag is set, utilizes a jump-on-zero (<span class="literal">JZ</span>) instruction <span class="ent">➋</span>, which will always be taken, to attain the effect of an unconditional jump. As a result, the instructions between the jump <span class="ent">➋</span> and the jump target <span class="ent">➌</span> will never be executed and serve only to confuse any analyst who fails to realize this fact. This example also obscures the actual jump target by jumping into the middle of the <span class="literal">CALL</span> instruction at <span class="literal">00401009</span> <span class="ent">➍</span>. Properly disassembled, the code should read as follows:</p>
<p class="programs">  00401000  XOR    EAX,EAX<br/>
  00401002  JZ     LAB_0040100a<br/>
  00401004  MOV    EBX,dword ptr [EAX]<br/>
  00401006  MOV    dword ptr [param_1 + -0x4],EBX<br/>
<span class="ent">➊</span> 00401009  ??    E8h<br/>
          LAB_0040100a                         XREF[1]: 00401002(j)<br/>
<span class="ent">➋</span> 0040100a  MOV    EAX,0xdeadbeef<br/>
  0040100f  PUSH   EAX<br/>
  00401010  POP    param_1</p>
<p class="indent">The actual target of the jump <span class="ent">➋</span> has been revealed, as has the extra byte <span class="ent">➊</span> that caused the desynchronization in the first place. It is certainly possible to use far more roundabout ways of setting and testing flags prior to executing a conditional jump. The level of difficulty for analyzing such code increases with the number of operations that may affect the processor flag bits prior to testing their value.</p>
<h5 class="h5" id="ch21lev390"><strong>Dynamically Computed Target Addresses</strong></h5>
<p class="noindent">The phrase <em>dynamically computed</em> simply means that an address to which execution will flow is computed at runtime. In this section, we discuss several ways in which such an address can be derived. The intent of such techniques is to hide (obfuscate) the actual control flow path that a binary will follow from the prying eyes of the static analysis process.</p>
<p class="indent">One example of this technique was shown in the preceding section. The example used a call instruction to place a return address on the stack. <span epub:type="pagebreak" id="page_475"/>The return address was popped directly off the stack into a register, and a constant value was added to the register to derive the final target address, which was ultimately reached by performing a jump to the location specified by the register contents.</p>
<p class="indent">An infinite number of similar code sequences can be developed for deriving a target address and transferring control to that address. The following code, also used in Shiva, demonstrates an alternate method for dynamically computing target addresses:</p>
<p class="programs">  0a04b3be  MOV    ECX,0x7f131760              ; ECX = 7F131760<br/>
  0a04b3c3  XOR    EDI,EDI                     ; EDI = 00000000<br/>
  0a04b3c5  MOV    DI,0x1156                   ; EDI = 00001156<br/>
  0a04b3c9  ADD    EDI,0x133ac000              ; EDI = 133AD156<br/>
  0a04b3cf  XOR    ECX,EDI                     ; ECX = 6C29C636<br/>
  0a04b3d1  SUB    ECX,0x622545ce              ; ECX = 0A048068<br/>
  0a04b3d7  MOV    EDI,ECX                     ; EDI = 0A048068<br/>
  0a04b3d9  POP    EAX<br/>
  0a04b3da  POP    ESI<br/>
  0a04b3db  POP    EBX<br/>
  0a04b3dc  POP    EDX<br/>
  0a04b3dd  POP    ECX<br/>
<span class="ent">➊</span> 0a04b3de  XCHG   dword ptr [ESP],EDI         ; TOS =   0A048068<br/>
  0a04b3e1  RET                                ; return to 0A048068</p>
<p class="indent">The comments to the right of the semicolons document the changes being made to various processor registers at each instruction. The process culminates in a derived value being moved into the top position of the stack (<span class="literal">TOS</span>) <span class="ent">➊</span>, which causes the return instruction to transfer control to the computed location (<span class="literal">0A048068</span> in this case). An analyst must essentially run the code by hand to determine the actual control flow path taken in the program.</p>
<h5 class="h5" id="ch21lev391"><strong>Obfuscated Control Flow</strong></h5>
<p class="noindent">Much more complex methods to hide control flow have been developed and utilized in recent years. In the most complex cases, a program will use multiple threads or child processes to compute control flow information and receive that information via some form of interprocess communication (for child processes) or synchronization primitives (for multiple threads).</p>
<p class="indent">In such cases, static analysis can become extremely difficult, as it becomes necessary to understand not only the behavior of multiple executable entities but also the exact manner by which those entities exchange information. For example, one thread may wait on a shared semaphore object, while a second thread computes values or modifies code that the first thread will make use of after the second thread signals its completion via the semaphore.<sup><a id="ch21fn2a" href="footnotes.xhtml#ch21fn2">2</a></sup></p>
<span epub:type="pagebreak" id="page_476"/>
<p class="indent">Another technique, frequently used within Windows malware, involves configuring an exception handler,<sup><a id="ch21fn3a" href="footnotes.xhtml#ch21fn3">3</a></sup> intentionally triggering an exception, and then manipulating the state of the process’s registers while handling the exception. The following example is used by the tElock anti–reverse engineering tool to obscure the program’s actual control flow:</p>
<p class="programs"><span class="ent">➊</span> 0041d07a  CALL   LAB_0041d07f<br/>
          LAB_0041d07f                         XREF[1]: 0041d07a(j)<br/>
<span class="ent">➋</span> 0041d07f  POP    EBP<br/>
<span class="ent">➌</span> 0041d080  LEA    EAX,[EBP + 0x46]<br/>
<span class="ent">➍</span> 0041d083  PUSH   EAX<br/>
  0041d084  XOR    EAX,EAX<br/>
<span class="ent">➎</span> 0041d086  PUSH   dword ptr FS:[EAX]<br/>
<span class="ent">➏</span> 0041d089  MOV    dword ptr FS:[EAX],ESP<br/>
<span class="ent">➐</span> 0041d08c  INT    3<br/>
  0041d08d  NOP<br/>
  0041d08e  MOV    EAX,EAX<br/>
  0041d090  STC<br/>
  0041d091  NOP<br/>
  0041d092  LEA    EAX,[EBX*0x2 + 0x1234]<br/>
  0041d099  CLC<br/>
  0041d09a  NOP<br/>
  0041d09b  SHR    EBX,0x5<br/>
  0041d09e  CLD<br/>
  0041d09f  NOP<br/>
  0041d0a0  ROL    EAX,0x7<br/>
  0041d0a3  NOP<br/>
  0041d0a4  NOP<br/>
<span class="ent">➑</span> 0041d0a5  XOR    EBX,EBX<br/>
<span class="ent">➒</span> 0041d0a7  DIV    EBX<br/>
  0041d0a9  POP    dword ptr FS:[0x0]</p>
<p class="indent">The sequence begins by using a <span class="literal">CALL</span> <span class="ent">➊</span> to the next instruction <span class="ent">➋</span>; the <span class="literal">CALL</span> instruction pushes <span class="literal">0041d07f</span> onto the stack as a return address, which is promptly popped off the stack into the <span class="literal">EBP</span> register <span class="ent">➋</span>. Next, the <span class="literal">EAX</span> register <span class="ent">➌</span> is set to the sum of <span class="literal">EBP</span> and <span class="literal">46h</span>, or <span class="literal">0041d0c5</span>, and this address is pushed onto the stack <span class="ent">➍</span> as the address of an exception handler function. The remainder of the exception handler setup takes place at <span class="ent">➎</span> and <span class="ent">➏</span>, which complete the process of linking the new exception handler into the existing chain of exception handlers referenced by <span class="literal">FS:[0]</span>.<sup><a id="ch21fn4a" href="footnotes.xhtml#ch21fn4">4</a></sup></p>
<p class="indent">The next step is to intentionally generate an exception <span class="ent">➐</span>, in this case an <span class="literal">INT 3</span>, which is a software trap (interrupt) to the debugger. (In x86 programs, the <span class="literal">INT 3</span> instruction is used by debuggers to implement a software breakpoint.) Normally at this point, an attached debugger would gain control, as debuggers are given the first opportunity to handle the exception. <span epub:type="pagebreak" id="page_477"/>In this case, the program fully expects to handle the exception, so any attached debugger must be instructed to pass the exception along to the program. Not allowing the program to handle the exception may cause the program to operate incorrectly or crash. Without understanding how the <span class="literal">INT 3</span> exception is handled, it is impossible to know what may happen next in this program. If we assume that execution simply resumes following the <span class="literal">INT 3</span>, then it appears that a divide-by-zero exception will eventually be triggered by instructions <span class="ent">➑</span> and <span class="ent">➒</span>.</p>
<p class="indent">The decompiled version of the exception handler associated with the preceding code begins at address <span class="literal">0041d0c5</span>. The first portion of this function is shown here:</p>
<p class="programs">int FUN_0041d0c5(EXCEPTION_RECORD *param_1,void *frame,<span class="ent">➊</span>CONTEXT *ctx) {<br/>
  DWORD code;<br/>
<br/>
<span class="ent">➋</span> ctx-&gt;Eip = ctx-&gt;Eip + 1;<br/>
<span class="ent">➌</span> code = param_1-&gt;ExceptionCode;<br/>
<span class="ent">➍</span> if (code == EXCEPTION_INT_DIVIDE_BY_ZERO) {<br/>
    ctx-&gt;Eip = ctx-&gt;Eip + 1;<br/>
  <span class="ent">➎</span> ctx-&gt;Dr0 = 0;<br/>
    ctx-&gt;Dr1 = 0;<br/>
    ctx-&gt;Dr2 = 0;<br/>
    ctx-&gt;Dr3 = 0;<br/>
    ctx-&gt;Dr6 = ctx-&gt;Dr6 &amp; 0xffff0ff0;<br/>
    ctx-&gt;Dr7 = ctx-&gt;Dr7 &amp; 0xdc00;<br/>
  }</p>
<p class="indent">The third argument to the exception handler function <span class="ent">➊</span> is a pointer to a Windows <span class="literal">CONTEXT</span> structure (defined in the Windows API header file <em>winnt.h</em>). The <span class="literal">CONTEXT</span> structure is initialized with the contents of all processor registers as they existed at the time of the exception. An exception handler has the opportunity to inspect and, if desired, modify the contents of the <span class="literal">CONTEXT</span> structure. If the exception handler feels that it has corrected the problem that led to the exception, it can notify the operating system that the offending thread should be allowed to continue. At this point, the operating system reloads the processor registers for the thread from the <span class="literal">CONTEXT</span> structure that was provided to the exception handler, and execution of the thread resumes as if nothing had ever happened.</p>
<p class="indent">In the preceding example, the exception handler begins by accessing the thread’s <span class="literal">CONTEXT</span> in order to increment the instruction pointer <span class="ent">➋</span>, to allow execution to resume at the instruction following the one that generated the exception. Next, the exception’s type code (a field within the provided <span class="literal">EXCEPTION_RECORD</span>) is retrieved <span class="ent">➌</span> in order to determine the nature of the exception. This portion of the exception handler handles the divide-by-zero error <span class="ent">➍</span>, generated in the previous example, by zeroing <span class="ent">➎</span> all of the x86 hardware debugging registers and disabling hardware breakpoints.<sup><a id="ch21fn5a" href="footnotes.xhtml#ch21fn5">5</a></sup> <span epub:type="pagebreak" id="page_478"/>Without examining the remainder of the tElock code, it is not immediately apparent why the debug registers are being cleared. In this case, tElock is clearing values from a previous operation in which it used the debug registers to set four breakpoints in addition to the <span class="literal">INT 3</span> seen previously. In addition to obfuscating the true flow of the program, clearing or modifying the x86 debug registers can wreak havoc for software debuggers such as OllyDbg or GDB. Such anti-debugging techniques are discussed in “<a href="ch21.xhtml#ch21lev394">Anti–Dynamic Analysis Techniques</a>” on <a href="ch21.xhtml#page_487">page 487</a>.</p>
<h5 class="h5" id="ch21lev392"><strong>Opcode Obfuscation</strong></h5>
<p class="noindent">While the techniques described to this point may provide—in fact, are intended to provide—a hindrance to understanding a program’s control flow, none prevent you from observing the correct disassembled form of a program you are analyzing. Desynchronization had the greatest impact on the disassembly, but it was easily defeated by reformatting the disassembly to reflect the correct instruction flow.</p>
<p class="indent">A more effective technique for preventing correct disassembly is to encode or encrypt the actual instructions when the executable file is being created. The obfuscated instructions must be deobfuscated back to their original form before they are fetched for execution by the processor. Therefore, at least some portion of the program must remain unencrypted in order to serve as the startup routine, which, in the case of an obfuscated program, is usually responsible for deobfuscating some or all of the remainder of the program. A very generic overview of the obfuscation process is shown in <a href="ch21.xhtml#fig21_2">Figure 21-2</a>.</p>
<div class="image"><img src="Images/fig21-2.jpg" alt="image" width="843" height="226"/></div>
<p class="figcap" id="fig21_2"><em>Figure 21-2: Generic obfuscation process</em></p>
<p class="indent">As shown, the input to the process is a program to be obfuscated. In many cases, the input program is written using standard programming languages and build tools (editors, compiler, and the like) with little thought required about the obfuscation to come. The resulting executable file is fed into an obfuscation utility that transforms the binary into a functionally <span epub:type="pagebreak" id="page_479"/>equivalent, yet obfuscated, binary. As depicted, the obfuscation utility is responsible for obfuscating the original program’s code and data sections and adding additional code (a deobfuscation stub) that performs the task of deobfuscating the code and data before the original functionality can be accessed at runtime. The obfuscation utility also modifies the program headers to redirect the program entry point to the deobfuscation stub, ensuring that execution begins with the deobfuscation process. Following deobfuscation, execution typically transfers to the entry point of the original program, which begins execution as if it had never been obfuscated at all.</p>
<p class="indent">This oversimplified process varies widely based on the obfuscation utility that is used to create the obfuscated binary. An ever-increasing number of utilities are available to handle the obfuscation process. Such utilities offer features ranging from compression to anti-disassembly and anti-debugging techniques. Examples include programs such as UPX (compressor, also works with ELF; <em><a href="https://upx.github.io/">https://upx.github.io/</a></em>), ASPack (compressor; <em><a href="http://www.aspack.com/">http://www.aspack.com/</a></em>), ASProtect (anti–reverse engineering by the makers of ASPack), and tElock (compression and anti–reverse engineering; <em><a href="http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/Telock.shtml">http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/Telock.shtml</a></em>.) for Windows PE files. The capabilities of obfuscation utilities have advanced to the point that some anti–reverse engineering tools such as VMProtect integrate with the entire build process, allowing programmers to integrate anti–reverse engineering features at every stage of development, from source code through post-processing the compiled binary file (<em><a href="https://vmpsoft.com/">https://vmpsoft.com/</a></em>).</p>
<div class="box5">
<p class="boxtitle-c"><strong>SANDBOX ENVIRONMENTS</strong></p>
<p class="noindent">The purpose of a <em>sandbox environment</em> for reverse engineering is to allow you to execute programs in a manner that allows observation of the program’s behavior without allowing that behavior to adversely impact critical components of your reverse engineering platform or anything it is connected to. Sandbox environments are commonly constructed using platform virtualization software, but they may be constructed on dedicated systems that are capable of being restored to a known-good state following the execution of any malware.</p>
<p class="indent">Sandbox systems are typically heavily instrumented in order to observe and collect information on the behavior of programs run within the sandbox. Collected data may include information on the filesystem activity of a program, the registry activity of a (Windows) program, and information about any networking activity generated by the program. One example of a complete sandbox environment is Cuckoo (<em><a href="https://cuckoosandbox.org/">https://cuckoosandbox.org/</a></em>), a popular open source sandbox specifically oriented toward malware analysis.</p>
</div>
<span epub:type="pagebreak" id="page_480"/>
<p class="indent">As with any offensive technology, defensive measures have been developed to counter many anti–reverse engineering tools. In most cases, the goal of such tools is to recover the original, unprotected executable file (or a reasonable facsimile), which can then be analyzed using more traditional tools such as disassemblers and debuggers.</p>
<p class="indent">One such tool designed to deobfuscate Windows executables is called QuickUnpack (<em><a href="http://qunpack.ahteam.org/?p=458">http://qunpack.ahteam.org/?p=458</a></em>; site is in Russian). QuickUnpack, like many other automated unpackers, operates by functioning as a debugger and allowing an obfuscated binary to execute through its deobfuscation phase and then capturing the process image from memory. Beware that this type of tool actually runs potentially malicious programs in the hope of intercepting the execution of those programs after they have unpacked or deobfuscated themselves but before they have a chance to do anything malicious. Thus, you should always execute such programs in a sandbox-type environment.</p>
<p class="indent">Using a purely static analysis environment to analyze obfuscated code is a challenging task. Without being able to execute the deobfuscation stub, the obfuscated portions of the binary must be unpacked or decrypted before disassembly can begin. The Ghidra Address Type overview bar, at right in <a href="ch21.xhtml#fig21_3">Figure 21-3</a>, shows the layout of an executable that has been packed using the UPX packer. Ghidra color-codes content in the overview bar to give you an indication of the associated content in the binary. The general categories for the overview bar include the following:</p>
<ul>
<li><p class="noindent">Function</p></li>
<li><p class="noindent">Uninitialized</p></li>
<li><p class="noindent">External Reference</p></li>
<li><p class="noindent">Instruction</p></li>
<li><p class="noindent">Data</p></li>
<li><p class="noindent">Undefined</p></li>
</ul>
<p class="indent">Focusing on the overview bar in the figure, we can see Ghidra’s preliminary assessment of various parts of the binary. Hovering over any of the sections in the overview bar will provide additional information about the corresponding region of the binary. The unusual appearance of this particular navigation bar is a tip-off that this binary has been obfuscated in some manner. Let’s take a closer look at some of the sections in the overview bar.</p>
<p class="indent">Ghidra has identified a data section <span class="ent">➊</span> at the start of the file. Examining this content reveals the headers for the file along with informative content that is indicative of the type of obfuscation used on this file:</p>
<p class="programs">  This file is packed with the UPX executable packer http://upx.tsx.org<br/>
  UPX 1.07 Copyright (C) 1996-2001 the UPX Team. All Rights Reserved.</p>
<span epub:type="pagebreak" id="page_481"/>
<div class="image"><img src="Images/fig21-3.jpg" alt="image" width="632" height="883"/></div>
<p class="figcap" id="fig21_3"><em>Figure 21-3: Ghidra Listing window and Address Type overview bar for a binary packed using UPX</em></p>
<p class="indent">This section is followed by a block of undefined content <span class="ent">➋</span> similar to the following, which appears in the Listing window:</p>
<p class="programs">004008a3 72        ??     72h    r<br/>
004008a4 85        ??     85h<br/>
004008a5 6c        ??     6Ch    l</p>
<span epub:type="pagebreak" id="page_482"/>
<p class="indent">The largest section <span class="ent">➌</span> contains uninitialized data, which appears as follows in the Listing window:</p>
<p class="programs">004034e3  ??       ??<br/>
004034e4  ??       ??</p>
<p class="indent">A little farther in the file, Ghidra has identified another block of undefined content <span class="ent">➍</span>. At the end of this data is a region that Ghidra has identified as a function <span class="ent">➎</span>. This function is easily recognizable as the UPX decompression stub, which Ghidra has identified as the entry point for the binary, as shown in the Listing window on the left in <a href="ch21.xhtml#fig21_3">Figure 21-3</a>. The undefined content segments we observed <span class="ent">➋➍</span> are the result of the UPX compression process. The job of the decompression stub is to unpack that data into the uninitialized region <span class="ent">➌</span> before finally transferring control to the unpacked code.</p>
<p class="indent">The information presented by the Address Type overview bar can be correlated with the properties of each segment within the binary to determine whether the information presented in each display is consistent. The memory map for this binary is shown in <a href="ch21.xhtml#fig21_4">Figure 21-4</a>.</p>
<div class="image"><img src="Images/fig21-4.jpg" alt="image" width="844" height="182"/></div>
<p class="figcap" id="fig21_4"><em>Figure 21-4: Memory map of a UPX packed binary</em></p>
<p class="indent">In this particular binary, the entire range of addresses contained in segment <span class="literal">UPX0</span> <span class="ent">➊</span> and segment <span class="literal">UPX1</span> <span class="ent">➋</span> (<span class="literal">00401000</span>–<span class="literal">00408fff</span>) is marked as executable (the X flag is set). Given this fact, we should expect to see the entire Address Type overview bar colorized to represent functions. The fact that we do not, coupled with the fact that the entire range of <span class="literal">UPX0</span> is uninitialized and writable, should be considered highly suspicious and provides valuable clues about the binary and how we might proceed with analysis.</p>
<p class="indent">Techniques for using Ghidra to perform the decompression operation in a static context (without actually executing the binary) on files such as this one are discussed in “<a href="ch21.xhtml#ch21lev399">Static Deobfuscation of Binaries Using Ghidra</a>” on <a href="ch21.xhtml#page_491">page 491</a>.</p>
<h4 class="h4" id="ch21lev393"><strong><em>Imported Function Obfuscation</em></strong></h4>
<p class="noindent">Anti–static analysis techniques may also hide which shared libraries and library functions a binary uses in order to avoid leaking information about <span epub:type="pagebreak" id="page_483"/>potential actions that the binary may perform. In most cases, it is possible to render tools such as <span class="literal">dumpbin</span>, <span class="literal">ldd</span>, and <span class="literal">objdump</span> ineffective for the purposes of listing library dependencies.</p>
<p class="indent">The effect of such obfuscations on Ghidra is most obvious in the Symbol Tree. The entire Symbol Tree for our earlier tElock example is shown in <a href="ch21.xhtml#fig21_5">Figure 21-5</a>.</p>
<div class="image"><img src="Images/fig21-5.jpg" alt="image" width="308" height="434"/></div>
<p class="figcap" id="fig21_5"><em>Figure 21-5: Symbol Tree for obfuscated binary</em></p>
<p class="indent">Only two imported functions are referenced: <span class="literal">GetModulehandleA</span> (from <em>kernel32.dll</em>) and <span class="literal">MessageBoxA</span> (from <em>user32.dll</em>). Virtually nothing about the behavior of the program can be inferred from this short list. Here again the techniques are varied but essentially boil down to the fact that the program itself must load any additional libraries that it depends on, and once the libraries are loaded, the program must locate any required functions within those libraries. In most cases, these tasks are performed by the deobfuscation stub prior to transferring control to the deobfuscated program. The end goal is for the program’s import table to have been properly initialized, just as if the process had been performed by the operating system’s own loader.</p>
<p class="indent">For Windows binaries, a simple approach is to use the <span class="literal">LoadLibrary</span> function to load required libraries by name and then use the <span class="literal">GetProcAddress</span> function to perform function address lookups within each library. To use these functions, a program must either be explicitly linked to them or have an alternate means of looking them up. The Symbol Tree for the tElock example does not include either of these functions, while the Symbol Tree for the UPX example, shown in <a href="ch21.xhtml#fig21_6">Figure 21-6</a>, includes both.</p>
<span epub:type="pagebreak" id="page_484"/>
<div class="image"><img src="Images/fig21-6.jpg" alt="image" width="343" height="552"/></div>
<p class="figcap" id="fig21_6"><em>Figure 21-6: Symbol Tree for UPX example</em></p>
<p class="indent">The actual UPX code responsible for rebuilding the import table is shown in <a href="ch21.xhtml#exa21_2">Listing 21-2</a>.</p>
<p class="programs">        LAB_0040886c                         XREF[1]: 0040888e(j)<br/>
0040886c  MOV    EAX,dword ptr [EDI]<br/>
0040886e  OR     EAX,EAX<br/>
00408870  JZ     LAB_004088ae<br/>
00408872  MOV    EBX,dword ptr [EDI + 0x4]<br/>
00408875  LEA    EAX,[EAX + ESI*0x1 + 0x8000]<br/>
0040887c  ADD    EBX,ESI<br/>
0040887e  PUSH   EAX<br/>
0040887f  ADD    EDI,0x8<br/>
00408882  CALL<span class="ent">➊</span> dword ptr [ESI + 0x808c]=&gt;KERNEL32.DLL::LoadLibraryA<br/>
00408888  XCHG   EAX,EBP<br/>
        LAB_00408889                         XREF[1]: 004088a6(j)<br/>
00408889  MOV    AL,byte ptr [EDI]<br/>
0040888b  INC    EDI<br/>
0040888c  OR     AL,AL<br/>
0040888e  JZ     LAB_0040886c<br/>
00408890  MOV    ECX,EDI<br/>
00408892  PUSH   EDI<br/>
00408893  DEC    EAX<br/>
00408894  SCASB.REPNE ES:EDI<br/>
00408896  PUSH    EBP<br/>
00408897  CALL<span class="ent">➋</span> dword ptr [ESI + 0x8090]=&gt;KERNEL32.DLL::GetProcAddress<br/>
0040889d  OR     EAX,EAX<br/>
<span epub:type="pagebreak" id="page_485"/>
0040889f  JZ     LAB_004088a8<br/>
004088a1  MOV<span class="ent">➌</span>  dword ptr [EBX],EAX ; save to import table<br/>
004088a3  ADD    EBX,0x4<br/>
004088a6  JMP    LAB_00408889</p>
<p class="ex-caption" id="exa21_2"><em>Listing 21-2: Import table reconstruction in UPX</em></p>
<p class="indent">This example contains an outer loop responsible for calling <span class="literal">LoadLibrary</span> <span class="ent">➊</span> and an inner loop responsible for calling <span class="literal">GetProcAddress</span> <span class="ent">➋</span>. Following each successful call to <span class="literal">GetProcAddress</span>, the newly retrieved function address is stored into the reconstructed import table <span class="ent">➌</span>.</p>
<p class="indent">These loops are executed as the last portion of the UPX deobfuscation stub, because each function takes string pointer parameters that point to either a library name or a function name, and the associated strings are held within the compressed data region to avoid detection by the <span class="literal">strings</span> utility. As a result, library loading in UPX cannot take place until the required strings have been decompressed.</p>
<p class="indent">Returning to the tElock example, a different problem presents itself. With only two imported functions, neither of which is <span class="literal">LoadLibrary</span> or <span class="literal">GetProcAddress</span>, how can the tElock utility perform the function-resolution tasks that were performed by UPX? All Windows processes depend on <em>kernel32.dll</em>, which means that it is present in memory for all processes. If a program can locate <em>kernel32.dll</em>, a relatively straightforward process may be followed to locate any function within the DLL, including <span class="literal">LoadLibrary</span> and <span class="literal">GetProcAddress</span>. As shown previously, with these two functions in hand, it is possible to load any additional libraries required by the process and locate all required functions within those libraries.</p>
<p class="indent">In his paper “Understanding Windows Shellcode,” Skape discusses techniques for doing exactly this.<sup><a id="ch21fn6a" href="footnotes.xhtml#ch21fn6">6</a></sup> While tElock does not use the exact techniques detailed by Skape, there are many parallels, and the net effect is to obscure the details of the loading and linking process. Without carefully tracing the program’s instructions, it is extremely easy to overlook the loading of a library or the lookup of a function address. The following small code fragment illustrates the manner in which tElock attempts to locate the address of <span class="literal">LoadLibrary</span>:</p>
<p class="programs">0041d1e4  CMP    dword ptr [EAX],0x64616f4c<br/>
0041d1ea  JNZ    LAB_0041d226<br/>
0041d1ec  CMP    dword ptr [EAX + 0x4],0x7262694c<br/>
0041d1f3  JNZ    LAB_0041d226<br/>
0041d1f5  CMP    dword ptr [EAX + 0x8],0x41797261<br/>
0041d1fc  JNZ    LAB_0041d226</p>
<p class="indent">It is immediately obvious that several comparisons are taking place in rapid succession. What may not be immediately clear is the purpose of these comparisons. Reformatting the operands (right-click and then choose <strong>Convert</strong> ▸ <strong>Char Sequence</strong>) used in each comparison sheds a little light on the code, as seen in the following listing.</p>
<span epub:type="pagebreak" id="page_486"/>
<p class="programs">0041d1e4  CMP    dword ptr [EAX],"Load"<br/>
0041d1ea  JNZ    LAB_0041d226<br/>
0041d1ec  CMP    dword ptr [EAX + 0x4],"Libr"<br/>
0041d1f3  JNZ    LAB_0041d226<br/>
0041d1f5  CMP    dword ptr [EAX + 0x8],"aryA"<br/>
0041d1fc  JNZ    LAB_0041d226</p>
<p class="indent">Each hexadecimal constant is actually a sequence of four ASCII characters, which Ghidra is capable of displaying as quoted ASCII and, together, spell <span class="literal">LoadLibraryA</span>.<sup><a id="ch21fn7a" href="footnotes.xhtml#ch21fn7">7</a></sup> If the three comparisons succeed, tElock has located the export table entry for <span class="literal">LoadLibraryA</span> and in a few short operations will obtain the address of this function for loading additional libraries. tElock’s approach to function lookup is somewhat resistant to string analysis because the 4-byte constants embedded directly in the program’s instructions do not look like standard, null-terminated strings and thus do not get included in the list of strings generated by Ghidra unless you change the defaults (for example, unchecking the Require Null Termination option during your string search).</p>
<p class="indent">Manually reconstructing a program’s import table through careful analysis of the program’s code is made easier in the case of UPX and tElock because, ultimately, both contain ASCII character data that you can use to determine exactly which libraries and which functions are being referenced. Skape’s paper details a function-resolution process in which no strings at all appear within the code. The basic idea discussed in the paper is to precompute a unique hash value for the name of each function that you need to resolve.<sup><a id="ch21fn8a" href="footnotes.xhtml#ch21fn8">8</a></sup> To resolve each function, you can search through a library’s exported names table. Each name in the table is hashed, and you can compare the resulting hash against the precomputed hash value for the desired function. If the hashes match, you have located the desired function, and can easily locate its address in the library’s export address table.</p>
<p class="indent">To statically analyze binaries obfuscated in this manner, you need to understand the hashing algorithm used for each function name and apply that algorithm to all the names exported by the library the program is searching. With a complete table of hashes in hand, you can do a simple lookup of each hash you encounter in the program to determine which function the hash references. A portion of such a table, generated for <em>kernel32.dll</em>, might look like this:</p>
<p class="programs"><span class="ent">➊</span> GetProcAddress : 8A0FB5E2<br/>
  GetProcessAffinityMask : B9756EFE<br/>
  GetProcessHandleCount : B50EB87C<br/>
  GetProcessHeap : C246DA44<br/>
<span epub:type="pagebreak" id="page_487"/>
  GetProcessHeaps : A18AAB23<br/>
  GetProcessId : BE05ED07</p>
<p class="indent">Note that the hash values are specific to the hash function being used within a particular binary and are likely to vary from one binary to another. Using this particular table, if the hash value <span class="literal">8A0FB5E2</span> <span class="ent">➊</span> were encountered within a program, you could quickly determine that the program was attempting to look up the address of the <span class="literal">GetProcAddress</span> function.</p>
<p class="indent">Skape’s use of hash values to resolve function names was originally developed and documented for use in exploit payloads for Windows vulnerabilities; however, they have been adopted for use in obfuscated programs as well.</p>
<h4 class="h4" id="ch21lev394"><strong><em>Anti–Dynamic Analysis Techniques</em></strong></h4>
<p class="noindent">None of the anti–static analysis techniques covered in the past few sections have any effect whatsoever on whether a program will actually execute. In fact, while anti–static analysis techniques may make it difficult for you to comprehend the true behavior of a program using static analysis techniques alone, they can’t prevent the program from executing, or they would render a program useless from the start and therefore eliminate the need to analyze the program at all.</p>
<p class="indent">Given that a program must run in order to do any useful work, dynamic analysis aims to observe the behavior of a program in motion (while it is running) rather than observe the program at rest (using static analysis while the program is not running). In this section, we briefly summarize some of the more common anti–dynamic analysis techniques. For the most part, these techniques have little effect on static analysis tools; however, where there is overlap, we point this out.</p>
<h5 class="h5" id="ch21lev395"><strong>Detecting Virtualization</strong></h5>
<p class="noindent">Sandbox environments commonly use virtualization software, such as VMware, to provide an execution environment for malicious software (or any other software of interest). The advantage of such environments is that they typically offer checkpoint and rollback capabilities that facilitate rapid restoration of the sandbox to a known-clean state. The primary disadvantage is that malware may be able to detect the sandbox. Under the assumption that virtualization equates to observation, many programs that want to remain undetected simply shut after once they determine that they are running within a virtual machine. Given the widespread use of virtualization for production purposes, this assumption is less valid today than it has been historically.</p>
<p class="indent">The following list describes a few of the techniques that have been used by programs running in virtualized environments to determine that they are running within a virtual machine rather than on native hardware:</p>
<p class="listhead"><strong>Detection of virtualization-specific software</strong></p>
<p class="listbody">Users often install helper applications within virtual machines to facilitate communications between a virtual machine and its host operating system or simply to improve performance within the virtual machine. <span epub:type="pagebreak" id="page_488"/>The VMware Tools collection is one example of this kind of software. The presence of such software is easily detected by programs running within the virtual machine. For example, when VMware Tools is installed into a Microsoft Windows virtual machine, it creates Windows registry keys that can be read by any program. Malware detecting these keys may elect to shut down before exhibiting any noteworthy behaviors. On the other hand, virtualization is so widely used today that a VMware image found without VMware Tools installed might be considered equally suspicious in the eyes of a piece of malware.</p>
<p class="listhead"><strong>Detection of virtualization-specific hardware</strong></p>
<p class="listbody">Virtual machines use virtual hardware abstraction layers to provide the interface between the virtual machine and the host computer’s native hardware. Characteristics of the virtual hardware are often easily detectable by software running within the virtual machine. For example, VMware has been assigned its own organizationally unique identifiers (OUIs) for its virtualized network adapters.<sup><a id="ch21fn9a" href="footnotes.xhtml#ch21fn9">9</a></sup> Observing a VMware-specific OUI is a good indication that a program is running within a virtual machine. Software that shuts down for this reason may be coaxed into executing by modifying the MAC address assigned to any virtual network adapters associated with the virtual machine.</p>
<p class="listhead"><strong>Detection of processor-specific behavioral changes</strong></p>
<p class="listbody">Perfect virtualization is difficult to achieve. Ideally, a program should not be able to detect any difference between a virtualized environment and native hardware. However, this is seldom the case. Joanna Rutkowska developed her Red Pill VMware-detection technique after observing behavioral differences between the operation of the x86 <span class="literal">sidt</span> instruction on native hardware and the same instruction executed within a virtual machine environment.<sup><a id="ch21fn10a" href="footnotes.xhtml#ch21fn10">10</a></sup></p>
<h5 class="h5" id="ch21lev396"><strong>Detecting Instrumentation</strong></h5>
<p class="noindent">Following creation of your sandbox environment and prior to executing any program you want to observe, you need to ensure that instrumentation is in place to properly collect and record information about the behavior of the program you are analyzing. A wide variety of tools exist for performing such monitoring tasks. Two widely used examples are <em>Process Monitor</em> from the Sysinternals group at Microsoft and <em>Wireshark</em>.<sup><a id="ch21fn11a" href="footnotes.xhtml#ch21fn11">11</a></sup> Process Monitor is a utility capable of monitoring certain activities associated with any running Windows process, including accesses to the Windows registry and filesystem <span epub:type="pagebreak" id="page_489"/>activity. Wireshark is a network packet capture and analysis tool often used to analyze network traffic generated by malicious software.</p>
<p class="indent">Malware authors with a sufficient level of paranoia may program their software to search for running instances of such monitoring programs. Techniques that have been employed range from scanning the active process list for process names associated with such monitoring software to scanning the title bar text for all active Windows applications to search for known strings. Deeper searches can be performed, with some software going so far as to search for specific characteristics associated with Windows GUI components used within certain instrumentation software.</p>
<h5 class="h5" id="ch21lev397"><strong>Detecting Debuggers</strong></h5>
<p class="noindent">Moving beyond simple observation of a program, a debugger allows an analyst to take complete control of the execution of a program that requires analysis. Debuggers are commonly used to run an obfuscated program just long enough to complete any decompression or decryption tasks, and then the debuggers’ memory-access features are used to extract the deobfuscated process image from memory. In most cases, standard static analysis tools and techniques can be used to complete the analysis of the extracted process image.</p>
<p class="indent">The authors of obfuscation utilities are well aware of such debugger-assisted deobfuscation techniques and so have developed measures to attempt to defeat the use of debuggers for execution of their obfuscated programs. Programs that detect the presence of a debugger often choose to terminate rather than proceed with any operations that might allow an analyst to determine the behavior of the program.</p>
<p class="indent">Techniques for detecting the presence of debuggers range from simple queries to the operating system via well-known API functions such as the Windows <span class="literal">IsDebuggerPresent</span> function, to lower-level checks for memory or processor artifacts resulting from the use of a debugger. An example of the latter includes detecting that a processor’s trace (single step) flag is set.</p>
<p class="indent">As long as you know what to look for, there is nothing terribly tricky about trying to detect a debugger, and attempts to do so are easily observed during static analysis (unless anti–static analysis techniques are employed simultaneously). For more information on debugger detection, please consult the article “Anti Debugging Detection Techniques with Examples,” which provides a comprehensive overview of Windows anti-debugging techniques.<sup><a id="ch21fn12a" href="footnotes.xhtml#ch21fn12">12</a></sup></p>
<h5 class="h5" id="ch21lev398"><strong>Preventing Debugging</strong></h5>
<p class="noindent">Even an undetectable debugger can be thwarted using additional techniques that attempt to confound the debugger by introducing spurious breakpoints, clearing hardware breakpoints, hindering disassembly to make selection of appropriate breakpoint addresses difficult, or preventing the debugger from attaching to a process in the first place. Many of the <span epub:type="pagebreak" id="page_490"/>techniques discussed in the previously referenced anti-debugging article are geared toward preventing debuggers from operating correctly.</p>
<p class="indent">Intentionally generating exceptions is one way a program may attempt to hinder debugging. In most cases, an attached debugger will catch the exception, and the user of the debugger must analyze why the exception occurred and whether to pass the exception along to the program being debugged. In the case of a software breakpoint such as the x86 <span class="literal">INT 3</span>, it may be difficult to distinguish a software interrupt generated by the underlying program from one that results from an actual debugger breakpoint. This confusion is exactly the effect that is desired by the creator of the obfuscated program. In such cases, it’s possible, though harder, to understand the true program flow by using careful analysis of the disassembly listing.</p>
<p class="indent">Encoding portions of a program has the dual effect of hindering static analysis because disassembly is not possible and hindering debugging because placing breakpoints is difficult. Even if the start of each instruction is known, software breakpoints cannot be placed until the instructions have actually been decoded, as altering the instructions by inserting a software breakpoint is likely to result in a failed decryption of the obfuscated code and then a crash of the program when execution reaches the intended breakpoint.</p>
<p class="indent">The Shiva ELF obfuscation tool for Linux uses a technique called <em>mutual ptrace</em> as a means of preventing the use of a debugger in analyzing Shiva’s behavior.</p>
<div class="box5">
<p class="boxtitle-c"><strong>PROCESS TRACING</strong></p>
<p class="noindent">The <em>ptrace</em>, or process tracing, API available on many Unix-like systems provides a mechanism for one process to monitor and control the execution of another process. The GNU debugger (<span class="literal">gdb</span>) is one of the more well-known applications that uses the ptrace API. Using the ptrace API, a ptrace parent process may attach to and control the execution of a ptrace child process. To begin controlling a process, a parent process must first <em>attach</em> to the child process that it seeks to control. Once the parent process is attached, the child process is stopped anytime it receives a signal, and the parent is notified of this fact via the POSIX <span class="literal">wait</span> function, at which point the parent may choose to alter or inspect the state of the child process before instructing the child process to continue execution. Once a parent process has attached to a child process, no other process may attach to the same child process until the tracing parent chooses to detach from the child process.</p>
</div>
<p class="indent">Shiva takes advantage of the fact that only one other process may be attached to a process at any given time. Early in its execution, the Shiva process forks to create a copy of itself. The original Shiva process immediately performs a ptrace attach operation on the newly forked child. The newly <span epub:type="pagebreak" id="page_491"/>forked child process, in turn, immediately attaches to its parent process. If either attach operation fails, Shiva terminates under the assumption that a debugger is being used to monitor the Shiva process. If both operations succeed, no other debugger can attach to the running Shiva pair, and Shiva can continue to run without fear of being observed. While operating in this manner, either Shiva process may alter the state of the other, making it difficult to determine, using static analysis techniques, what the exact control flow path is through the Shiva binary.</p>
<h3 class="h3" id="ch21lev399"><strong>Static Deobfuscation of Binaries Using Ghidra</strong></h3>
<p class="noindent">At this point, you may be wondering how, given all of the anti–reverse engineering techniques available, it is possible to analyze software that a programmer is intent on keeping secret. Given that these techniques target both static analysis tools and dynamic analysis tools, what is the best approach to take in revealing a program’s hidden behavior? Unfortunately, no single solution fits all cases equally well.</p>
<p class="indent">In most cases, the solution depends on your skill set and the tools available to you. If your analysis tool of choice is a debugger, you will need to develop strategies for circumventing debugger detection and prevention protections. If your preferred analysis tool is a disassembler, you will need to develop strategies for obtaining an accurate disassembly and, in cases in which self-modifying code is encountered, for mimicking the behavior of that code in order to properly update your disassembly listings.</p>
<p class="indent">In this section, we discuss two techniques for dealing with self-modifying code in a static analysis environment (that is, without executing the code). Static analysis may be your only option when you are unwilling (because of hostile code) or unable (because of lack of hardware) to analyze a program while controlling it with a debugger. If these concepts make you feel like you are going down a rabbit hole, don’t be discouraged. Ghidra has secret (or not-so-secret) weapons that we can leverage in the static deobfuscation arms race.</p>
<h4 class="h4" id="ch21lev400"><strong><em>Script-Oriented Deobfuscation</em></strong></h4>
<p class="noindent">Because Ghidra can be used to disassemble binaries for an ever-increasing set of processors, it is not uncommon to analyze a binary developed for an entirely different platform than the one on which you are running Ghidra. For example, you may be asked to analyze a Linux x86 binary even though you happen to be running Ghidra on macOS, or you may be asked to analyze a MIPS or ARM binary even though you are running Ghidra on an x86 platform.</p>
<p class="indent">In such cases, you may not have access to appropriate tools, such as debuggers, for dynamically analyzing the binary. When such a binary has been obfuscated by encoding portions of the program, you may have no other option than to create a Ghidra script that will mimic the deobfuscating stage of the program in order to properly decode the program and disassemble the decoded instructions and data.</p>
<span epub:type="pagebreak" id="page_492"/>
<p class="indent">This may seem like a daunting task; however, in many cases, the decoding stages of an obfuscated program use only a small subset of a processor’s instruction set, so familiarizing yourself with the necessary operations may not require understanding the entire instruction set for the target processor.</p>
<p class="indent"><a href="ch14.xhtml#ch14">Chapter 14</a> presented an algorithm for developing scripts that emulate the behavior of portions of a program. In the following example, we will utilize those steps to develop a simple Ghidra script to decode a program that has been encrypted with the Burneye ELF encryption tool. In our sample program, execution begins with the instructions in <a href="ch21.xhtml#exa21_3">Listing 21-3</a>.</p>
<p class="programs"><span class="ent">➊</span> 05371035  PUSH   dword ptr [DAT_05371008]<br/>
<span class="ent">➋</span> 0537103b  PUSHFD<br/>
<span class="ent">➌</span> 0537103c  PUSHAD<br/>
<span class="ent">➍</span> 0537103d  MOV    ECX,dword ptr [DAT_05371000]<br/>
  05371043  JMP    LAB_05371082<br/>
  ...<br/>
          LAB_05371082                         XREF[1]:     05371043(j)<br/>
<span class="ent">➎</span> 05371082  CALL   FUN_05371048<br/>
  05371087  SHL    byte ptr [EBX + -0x2b],1<br/>
  0537108a  PUSHFD<br/>
  0537108b  XCHG   byte ptr [EDX + -0x11],AL<br/>
  0537108e  POP    SS<br/>
  0537108f  XCHG   EAX,ESP<br/>
  05371090  CWDE<br/>
  05371091  AAD    0x8e<br/>
  05371093  PUSH   ECX<br/>
<span class="ent">➏</span> 05371094  OUT    DX,EAX<br/>
  05371095  ADD    byte ptr [EDX + 0xa81bee60],BH<br/>
  0537109b  PUSH   SS<br/>
  0537109c  RCR    dword ptr [ESI + 0xc],CL<br/>
  0537109f  PUSH   CS<br/>
  053710a0  SUB    AL,0x70<br/>
  053710a2  CMP    CH,byte ptr [EAX + 0x6e]<br/>
  053710a5  CMP    dword ptr [DAT_cbd35372],0x9c38a8bc<br/>
  053710af  AND    AL,0xf4<br/>
  053710b1  SBB    EBP,ESP<br/>
  053710b4  POP    DS<br/>
<span class="ent">➐</span> 053710b5  ??    C6h</p>
<p class="ex-caption" id="exa21_3"><em>Listing 21-3: Burneye startup sequence and obfuscated code</em></p>
<p class="indent">The program begins by pushing the contents of memory location <span class="literal">05371008h</span> onto the stack <span class="ent">➊</span> before pushing the processor flags <span class="ent">➋</span> and all processor registers <span class="ent">➌</span>. The purpose of these instructions is not immediately clear, so we simply file this information away for later. Next, the <span class="literal">ECX</span> register is loaded with the contents of memory location <span class="literal">05371000h</span> <span class="ent">➍</span>. According to the algorithm presented in <a href="ch14.xhtml#ch14">Chapter 14</a>, we need to declare a variable named <span class="literal">ECX</span> at this point and initialize it from memory by using Ghidra’s <span class="literal">getInt</span> function, as shown here:</p>
<p class="programs">int ECX = getInt(toAddr(0x5371000));    // from instruction 0537103d</p>
<span epub:type="pagebreak" id="page_493"/>
<p class="indent">Following an absolute jump, the program calls function <span class="literal">FUN_05371048</span> <span class="ent">➎</span>, which pushes address <span class="literal">05371087h</span> (the return address) onto the stack. The disassembled instructions that follow the <span class="literal">CALL</span> instruction begin to make less and less sense. The <span class="literal">OUT</span> instruction <span class="ent">➏</span> is not generally encountered in user-space code, and Ghidra is unable to disassemble an instruction at address <span class="literal">053710B5h</span> <span class="ent">➐</span>. These are both indications that something is not quite right with this binary (that and the fact that the Symbol Tree lists only two functions: <span class="literal">entry</span> and <span class="literal">FUN_05371048</span>).</p>
<p class="indent">At this point, analysis needs to continue with the call to function <span class="literal">FUN_05371048</span>, which is shown in <a href="ch21.xhtml#exa21_4">Listing 21-4</a>.</p>
<p class="programs">  FUN_05371048                                 XREF[1]:     entry:05371082(c)<br/>
<span class="ent">➊</span> 05371048  POP    ESI<br/>
<span class="ent">➋</span> 05371049  MOV    EDI,ESI<br/>
<span class="ent">➌</span> 0537104b  MOV    EBX,dword ptr [DAT_05371004] = C09657B0h<br/>
  05371051  OR     EBX,EBX<br/>
<span class="ent">➍</span> 05371053  JZ     LAB_0537107f<br/>
<span class="ent">➎</span> 05371059  XOR    EDX,EDX<br/>
        <span class="ent">➏</span> LAB_0537105b                         XREF[1]:  0537107d(j)<br/>
  0537105b  MOV    EAX,0x8<br/>
        <span class="ent">➐</span> LAB_05371060                         XREF[1]:  05371073(j)<br/>
  05371060  SHRD   EDX,EBX,0x1<br/>
  05371064  SHR    EBX,1<br/>
  05371066  JNC    LAB_05371072<br/>
  0537106c  XOR    EBX,0xc0000057<br/>
          LAB_05371072                         XREF[1]:  05371066(j)<br/>
  05371072  DEC    EAX<br/>
  05371073  JNZ    LAB_05371060<br/>
  05371075  SHR    EDX,0x18<br/>
  05371078  LODSB  ESI<br/>
  05371079  XOR    AL,DL<br/>
  0537107b  STOSB  ES:EDI<br/>
  0537107c  DEC    ECX<br/>
  0537107d  JNZ    LAB_0537105b<br/>
          LAB_0537107f                         XREF[1]:  05371053(j)<br/>
  0537107f  POPAD<br/>
  05371080  POPFD<br/>
  05371081  RET</p>
<p class="ex-caption" id="exa21_4"><em>Listing 21-4: Main Burneye decoding function</em></p>
<p class="indent">This is not a typical function: it begins by immediately popping the return address off the stack into the <span class="literal">ESI</span> register <span class="ent">➊</span>. Recalling that the saved return address was <span class="literal">05371087h</span>, and taking into account the initialization of <span class="literal">EDI</span> <span class="ent">➋</span>, <span class="literal">EBX</span> <span class="ent">➌</span>, and <span class="literal">EDX</span> <span class="ent">➎</span>, our script grows to the following:</p>
<p class="programs">int ECX = getInt(toAddr(0x5371000));   // from instruction 0537103D<br/>
int ESI = 0x05371087;                  // from instruction 05371048<br/>
int EDI = ESI;                         // from instruction 05371049<br/>
int EBX = getInt(toAddr(0x5371004));   // from instruction 0537104B<br/>
int EDX = 0;                           // from instruction 05371059</p>
<span epub:type="pagebreak" id="page_494"/>
<p class="indent">Following these initializations, the function performs a test on the value contained in the <span class="literal">EBX</span> register <span class="ent">➍</span> before entering an outer loop <span class="ent">➏</span> and an inner loop <span class="ent">➐</span>. The remaining logic of the function is captured in the following completed script. Within the script, comments are used to relate script actions to the corresponding actions in the preceding disassembly listing.</p>
<p class="programs">public void run() throws Exception {<br/>
   int ECX = getInt(toAddr(0x5371000));   // from instruction 0537103D<br/>
   int ESI = 0x05371087;                  // from instruction 05371048<br/>
   int EDI = ESI;                         // from instruction 05371049<br/>
   int EBX = getInt(toAddr(0x5371004));   // from instruction 0537104B<br/>
<br/>
   if (EBX != 0) {                        // from instructions 05371051 <br/>
                                          //   and 05371053<br/>
      int EDX = 0;                        // from instruction 05371059<br/>
      do {<br/>
         int EAX = 8;                     // from instruction 0537105B<br/>
         do {<br/>
                                          // mimic x86 shrd instruction<br/>
                                          //   using several operations<br/>
            EDX = EDX &gt;&gt;&gt; 1;              // unsigned shift right one bit<br/>
            int CF = EBX &amp; 1;             // remember the low bit of EBX<br/>
            if (CF == 1) {                // CF represents the x86 carry flag<br/>
               EDX = EDX | 0x80000000;    // shift in low bit of EBX if it's 1<br/>
            }<br/>
            EBX = EBX &gt;&gt;&gt; 1;              // unsigned shift right one bit<br/>
            if (CF == 1) {                // from instruction 05371066<br/>
               EBX = EBX ^ 0xC0000057;    // from instruction 0537106C<br/>
            }<br/>
            EAX--;                        // from instruction 05371072<br/>
         } while (EAX != 0);              // from instruction 05371073<br/>
         EDX = EDX &gt;&gt;&gt; 24;                // unsigned shift right 24 bits<br/>
      <span class="ent">➊</span> EAX = getByte(toAddr(ESI));      // from instruction 05371078<br/>
         ESI++;<br/>
         EAX = EAX ^ EDX;                 // from instruction 05371079<br/>
         clearListing(toAddr(EDI));       // clear byte so we can change it<br/>
      <span class="ent">➋</span> setByte(toAddr(EDI), (byte)EAX); // from instruction 0537107B<br/>
         EDI++;<br/>
         ECX--;                           // from instruction 0537107C<br/>
      } while (ECX != 0);                 // from instruction 0537107D<br/>
   }<br/>
}</p>
<p class="indent">Whenever you are trying to emulate an instruction, you should pay particular attention to data sizes and register aliasing. In this example, we need to select an appropriate data size and variable to properly implement the x86 <span class="literal">LODSB</span> (load string byte) and <span class="literal">STOSB</span> (store string byte) instructions. These instructions write to (<span class="literal">LODSB</span>) and read from (<span class="literal">STOSB</span>) the low-order 8 bits of the <span class="literal">EAX</span> register,<sup><a id="ch21fn13a" href="footnotes.xhtml#ch21fn13">13</a></sup> leaving the upper 24 bits unchanged. In Java, there <span epub:type="pagebreak" id="page_495"/>is no way to partition a variable into bit-sized portions other than using various bitwise operations to mask off and recombine portions of the variable. Specifically, in the case of the <span class="literal">LODSB</span> instruction <span class="ent">➊</span>, a more faithful emulation would read as follows:</p>
<p class="programs">EAX = (EAX &amp; 0xFFFFFF00) | (getByte(toAddr(ESI)) &amp; 0xFF);</p>
<p class="indent">This example first clears the low 8 bits of the <span class="literal">EAX</span> variable and then merges in the new value for the low 8 bits using an <span class="literal">OR</span> operation. In the Burneye decoding example, the entire <span class="literal">EAX</span> register is set to 8 at the beginning of each outer loop, which has the effect of zeroing the upper 24 bits of <span class="literal">EAX</span>. As a result, we have elected to simplify our implementation of <span class="literal">LODSB</span> <span class="ent">➊</span> by ignoring the effect of the assignment on the upper 24 bits of <span class="literal">EAX</span>. No thought need be given to our implementation of <span class="literal">STOSB</span> <span class="ent">➋</span>, as the <span class="literal">setByte</span> function requires us to cast the second argument to a <span class="literal">byte</span>.</p>
<p class="indent">Following execution of the Burneye decoding script, our disassembly would reflect all of the changes that would normally not be observable until the obfuscated program was executed on a Linux system. If the deobfuscation process was carried out properly, we are very likely to see many more legible strings within Ghidra’s Search ▸ “For Strings... option” . To observe this fact, you may need to select the Refresh icon in the String Search window.</p>
<p class="indent">Remaining tasks include (1) determining where the decoding function will return to, given that it popped its return address in the very first instruction of the function, and (2) coaxing Ghidra to properly display the decoded byte values as instructions or data as appropriate. The Burneye decoding function ends with the following three instructions:</p>
<p class="programs">0537107f  POPAD<br/>
05371080  POPFD<br/>
05371081  RET</p>
<p class="indent">Recall that the function began by popping its own return address, which means that the remaining stack values were set up by the caller. The <span class="literal">POPAD</span> and <span class="literal">POPFD</span> instructions used here are the counterparts to the <span class="literal">PUSHAD</span> and <span class="literal">PUSHFD</span> instructions used at the beginning of Burneye’s start routine, as shown here:</p>
<p class="programs">       entry<br/>
<span class="ent">➊</span> 05371035  PUSH   dword ptr [DAT_05371008]<br/>
  0537103b  PUSHFD<br/>
  0537103c  PUSHAD</p>
<p class="indent">The net result is that the only value that remains on the stack is the one that was pushed at the first line of <span class="literal">entry</span> <span class="ent">➊</span>. It is to this location that the Burneye decoding routine returns, and it is at this location that further analysis of the Burneye protected binary would need to continue.</p>
<p class="indent">The preceding example may make it seem like writing a script to decode or unpack an obfuscated binary is a relatively easy thing to do. This is true <span epub:type="pagebreak" id="page_496"/>in the case of Burneye, which does not use a terribly sophisticated initial obfuscation algorithm. The deobfuscation stub of more sophisticated utilities such as ASPack and tElock would require somewhat more effort to implement using Ghidra.</p>
<p class="indent">Advantages to script-based deobfuscation include that the binary being analyzed need never be executed and that it is possible to create a functional script without ever developing a complete understanding of the exact algorithm used to deobfuscate the binary. This latter statement may seem counterintuitive, as it would seem that you would need to have a complete understanding of the deobfuscation before you could emulate the algorithm using a script. Using the development process described here and in <a href="ch14.xhtml#ch14">Chapter 14</a>, however, all you really need is a complete understanding of each processor instruction involved in the deobfuscation process. By faithfully implementing each processor action using Ghidra and properly sequencing each action according to the disassembly listing, you will have a script that mimics the program’s actions even if you do not fully comprehend the higher-level algorithm that those actions, as a whole, implement.</p>
<p class="indent">Disadvantages of using a script-based approach include that the scripts are rather fragile. If a deobfuscation algorithm changes as a result of an upgrade to a deobfuscation tool or through the use of alternate command line settings supplied to the obfuscation tool, a script that had been effective against that tool will likely need to be modified accordingly. For example, it is possible to develop generic unpacking scripts for use with binaries packed using UPX, but such scripts require constant tuning as UPX evolves.</p>
<p class="indent">Finally, scripted deobfuscation suffers from the lack of a one-size-fits-all solution to deobfuscation. There is no mega-script capable of deobfuscating all binaries. In a sense, scripted deobfuscation suffers from many of the same shortcomings as signature-based intrusion detection and antivirus systems. A new script must be developed for each new type of packer, and subtle changes in existing packers are likely to break existing scripts. Let’s shift focus and look at a more generic approach to deobfuscation.</p>
<h4 class="h4" id="ch21lev401"><strong><em>Emulation-Oriented Deobfuscation</em></strong></h4>
<p class="noindent">A recurring theme encountered when creating scripts to perform deobfuscation tasks is the need to emulate a processor’s instruction set in order to behave identically to the program being deobfuscated. Instruction emulators allow us to shift some or all of the work performed by these scripts over to the emulator and drastically reduce the amount of time required for Ghidra to deobfuscate. Emulators can fill the void between scripts and debuggers and can be more flexible than debuggers. An emulator can, for example, emulate a MIPS binary on an x86 platform or emulate instructions from a Linux ELF binary on a Windows platform.</p>
<p class="indent">Emulators vary in capabilities. At a minimum, an emulator requires a stream of instruction bytes and sufficient memory to dedicate to stack operations and processor registers. More sophisticated emulators may provide access to emulated hardware devices and operating system services.</p>
<span epub:type="pagebreak" id="page_497"/>
<h5 class="h5" id="ch21lev402"><strong>Ghidra’s Emulator Class</strong></h5>
<p class="noindent">Fortunately, Ghidra provides a rich <span class="literal">Emulator</span> class as well as an <span class="literal">EmulatorHelper</span>, which provides a higher-level abstraction of common emulator functionality and facilitates the quick-and-easy creation of emulation scripts. In <a href="ch18.xhtml#ch18">Chapter 18</a>, we introduced p-code as an intermediate representation of the underlying assembly and described how this allows the decompiler to work against a variety of target architectures. Similarly, p-code supports emulator functionality as well, and Ghidra’s <span class="literal">ghidra.pcode.emulate.Emulate</span> class provides the ability to emulate a single p-code instruction.</p>
<p class="indent">We can use Ghidra’s emulator-related classes to build emulators that allow us to emulate a wide variety of processors. As with other Ghidra packages and classes, this functionality is documented in the Javadoc supplied with Ghidra and can be pulled up as a reference by clicking the red plus tool in the Script Manager window. If you are interested in writing emulators, we encourage you to check out the Javadoc associated with the emulator methods used in the following example.</p>
<div class="box5">
<p class="boxtitle-c"><strong>CRACKME, CRACK YOURSELF</strong></p>
<p class="noindent">A <em>crackme</em> is a puzzle built by reverse engineers, for reverse engineers. The name derives from cracking a piece of software to bypass copy or usage restrictions—one of the more nefarious uses of reverse engineering skills. Crackmes provide a legal means to practice these skills as well as provide both the author of the crackme and the person analyzing the crackme a chance to show off their talent.</p>
<p class="indent">A common style of crackme receives a user input, transforms that input in some way, and then compares the result of the transformation to a precomputed output. When you attempt to solve a crackme, you are generally given only a compiled executable that contains both the code that performs the transformation and the final output for an unknown input. The crackme is solved when you derive the input that was used to generate the output contained in the binary, which typically requires understanding the transformation so well that you can derive the inverse transformation function.</p>
</div>
<h5 class="h5" id="ch21lev403"><strong>Example: SimpleEmulator</strong></h5>
<p class="noindent">Assume that we have a binary associated with the following crackme challenge, including some encoded content at the start of the file that eventually serves as the body of a function. In this example, we build an emulator script to automate the process of decoding the information needed to solve the crackme:</p>
<p class="programs"><span class="ent">➊</span> unsigned char check_access[] = {<br/>
      0xf0, 0xed, 0x2c, 0x40, 0x2c, 0xd8, 0x59, 0x26, 0xd8,<br/>
      0x59, 0xc1, 0xaa, 0x31, 0x65, 0xaa, 0x13, 0x65, 0xf8, 0x66<br/>
  };<br/>
<span epub:type="pagebreak" id="page_498"/>
  unsigned char key = 0xa5;<br/>
  void unpack() {<br/>
      for (int ii = 0; ii &lt; sizeof(check_access); ii++) {<br/>
        <span class="ent">➋</span> check_access[ii] ^= key;<br/>
      }<br/>
  }<br/>
  void do_challenge() {<br/>
      int guess;<br/>
      int access_allowed;<br/>
      int (*check_access_func)(int);<br/>
    <span class="ent">➌</span> unpack();<br/>
      printf("Enter the correct integer: ");<br/>
      scanf("%d", &amp;guess);<br/>
      check_access_func = (int (*)(int))check_access;<br/>
      access_allowed = check_access_func(guess)<span class="ent">➋</span>;<br/>
      if (access_allowed) {<br/>
          printf("Access granted!\n");<br/>
      } else {<br/>
          printf("Access denied!\n");<br/>
      }<br/>
  }<br/>
  int main() {<br/>
      do_challenge();<br/>
      return 0;<br/>
  }</p>
<p class="indent">Even with the source code available, this crackme would require some effort to solve because of the encoded content <span class="ent">➊</span>. Ghidra’s decompiler is frequently an awesome partner for solving crackme challenges, but this one has interesting characteristics that complicate the process. Ghidra sees only the encoded function body, but we need to know the function’s actual purpose before we can solve the challenge. At runtime, the <span class="literal">unpack</span> <span class="ent">➌</span> function call results in the decoding of the <span class="literal">check_access</span> <span class="ent">➋</span> function before <span class="literal">check_access</span> is called <span class="ent">➍</span>. The answer to this crackme is obfuscated, and we can build an emulator script in Ghidra to help us attack this challenge. Unlike the previous example, this emulator will not just solve the problem for this specific case, but will be capable of emulating somewhat arbitrary code.</p>
<h4 class="h4" id="ch21lev404"><strong><em>Step 1: Define the Problem</em></strong></h4>
<p class="noindent">Our task is to design and develop a simple emulator that will allow us to choose a region of a disassembly and will emulate the instructions in that region. The emulator needs to be added to Ghidra and be available as a script. For example, if we select the <span class="literal">unpack</span> function for the crackme challenge and run the script, our emulator should use the key to unpack the <span class="literal">check_access</span> array and let us know the solution to the crackme challenge. The script will write the unpacked code bytes into the program’s memory in Ghidra.</p>
<h4 class="h4" id="ch21lev405"><strong><em>Step 2: Create the Eclipse Script Project</em></strong></h4>
<p class="noindent">We can create a project called <em>SimpleEmulator</em> using GhidraDev ▸ New ▸ Ghidra Script Project. This gives us a <em>SimpleEmulator</em> folder in Eclipse with a folder <span epub:type="pagebreak" id="page_499"/>called <em>Home scripts</em> (refer to <a href="ch15.xhtml#fig15_16">Figure 15-16</a> on <a href="ch15.xhtml#page_325">page 325</a>) waiting for our new script. We still need to create the actual script and enter the associated metadata to ensure that our script is documented and can be catalogued. The metadata collected in the script creation dialog is included in the file and, as <a href="ch21.xhtml#fig21_7">Figure 21-7</a> shows, we have only one thing to do: <span class="literal">Add script code here</span>.</p>
<div class="image"><img src="Images/fig21-7.jpg" alt="image" width="694" height="460"/></div>
<p class="figcap" id="fig21_7"><em>Figure 21-7: Script template for</em> SimpleEmulator</p>
<h4 class="h4" id="ch21lev406"><strong><em>Step 3: Build the Emulator</em></strong></h4>
<p class="noindent">We know that Eclipse will recommend imports if we need them as we develop our code, so we can jump right into the coding tasks we need to perform and add the recommended <span class="literal">import</span> statements when Eclipse detects that we need them. For functionality, we will rely on the following instance variable declarations throughout our <span class="literal">SimpleEmulator</span> class:</p>
<p class="programs">private EmulatorHelper emuHelper;   // EmulatorHelper member variable object<br/>
private Address executionAddress;   // Initially the start of the selection<br/>
private Address endAddress;         // End of the selected region</p>
<p class="indent">Comments associated with each declaration describe the purpose of each variable. The <span class="literal">executionAddress</span> will initially be set to the start of the selected range, but will also be used to advance through the selection.</p>
<h5 class="h5" id="ch21lev407"><strong>Step 3-1: Set Up the Emulator</strong></h5>
<p class="noindent">The first thing we will do in our script’s <span class="literal">run</span> method is instantiate our emulator helper object and activate the tracking of any memory written in the emulator so that we can write updated values back into the current <span epub:type="pagebreak" id="page_500"/>program. The instantiation acts as a lock, similar to the lock that the CodeBrowser places on an open binary:</p>
<p class="programs">emuHelper = new EmulatorHelper(currentProgram);<br/>
emuHelper.enableMemoryWriteTracking(true);</p>
<h5 class="h5" id="ch21lev408"><strong>Step 3-2: Select the Address Range to Be Emulated</strong></h5>
<p class="noindent">Since we want the user to choose the section of code to be emulated, we need to ensure they have selected something in the Listing window. Otherwise, we will generate an error message.</p>
<p class="programs">if (currentSelection != null) {<br/>
    executionAddress = currentSelection.getMinAddress();<br/>
    endAddress = currentSelection.getMaxAddress().next();<br/>
} else {<br/>
    println("Nothing selected");<br/>
    return;<br/>
}</p>
<h5 class="h5" id="ch21lev409"><strong>Step 3-3: Get Ready to Emulate</strong></h5>
<p class="noindent">Within the selection, we want to ensure we are looking at an instruction in order to establish the initial processor context, initialize the stack pointer, and set up a breakpoint at the end of the selected region. The <span class="literal">continuing</span> flag indicates whether we are just starting the emulation or continuing the emulation, and determines which version of <span class="literal">emuHelper.run</span> is called in step 3-4:</p>
<p class="programs">Instruction executionInstr = getInstructionAt(executionAddress);<br/>
if (executionInstr == null) {<br/>
    printerr("Instruction not found at: " + executionAddress);<br/>
    return;<br/>
}<br/>
long stackOffset = (executionInstr.getAddress().getAddressSpace().<br/>
                    getMaxAddress().getOffset() &gt;&gt;&gt; 1) - 0x7fff;<br/>
emuHelper.writeRegister(emuHelper.getStackPointerRegister(), stackOffset);<br/>
// Setup breakpoint at the end address<br/>
emuHelper.setBreakpoint(endAddress);<br/>
// Set continuing to false as we are just starting the emulation<br/>
boolean continuing = false;;</p>
<h5 class="h5" id="ch21lev410"><strong>Step 3-4: Perform Emulation</strong></h5>
<p class="noindent">In this section, you should recognize the use of some Ghidra API functions introduced in <a href="ch14.xhtml#ch14">Chapter 14</a> (such as <span class="literal">monitor.isCancelled</span>). We need a loop to drive the emulation until a termination condition that we define is reached:</p>
<p class="programs"><span class="ent">➊</span> while (!monitor.isCancelled() &amp;&amp;<br/>
         !emuHelper.getExecutionAddress().equals(endAddress)) {<br/>
      if (continuing) {<br/>
<span epub:type="pagebreak" id="page_501"/>
          emuHelper.run(monitor);<br/>
      } else {<br/>
          emuHelper.run(executionAddress, executionInstr, monitor);<br/>
      }<br/>
    <span class="ent">➋</span> executionAddress = emuHelper.getExecutionAddress();<br/>
<br/>
      // determine why the emulator stopped, and handle each possible reason<br/>
    <span class="ent">➌</span> if (emuHelper.getEmulateExecutionState() ==<br/>
          EmulateExecutionState.BREAKPOINT) {<br/>
          continuing = true;<br/>
      } else if (monitor.isCancelled()) {<br/>
          println("Emulation cancelled at 0x" + executionAddress);<br/>
          continuing = false;<br/>
      } else {<br/>
          println("Emulation Error at 0x" + executionAddress +<br/>
                  ": " + emuHelper.getLastError());<br/>
          continuing = false;<br/>
      }<br/>
    <span class="ent">➍</span> writeBackMemory();<br/>
      if (!continuing) {<br/>
          break;<br/>
      }<br/>
  }</p>
<p class="indent">For this example, emulation continues as long as the monitor hasn’t detected a user cancellation, we haven’t reached the end of the selected range of instructions, or an error condition hasn’t been triggered <span class="ent">➊</span>. When the emulator stops, we need to update the current execution address <span class="ent">➋</span> and then handle the stop condition appropriately <span class="ent">➌</span>. The final step is to call the <span class="literal">writeBackMemory()</span>method <span class="ent">➍</span>.</p>
<h5 class="h5" id="ch21lev411"><strong>Step 3-5: Write Memory Back to the Program</strong></h5>
<p class="noindent">The implementation of <span class="literal">writeBackMemory()</span> <span class="ent">➍</span> is shown here. This emulator is going to be tested on an unpack routine, which ultimately changes the bytes in memory. The memory changes that the emulator has made exist only in its working memory. The content needs to be written back to the binary in order to allow the listing and other user interfaces to accurately reflect the changes that result from executing the instructions in the unpack routine. Ghidra provides functionality within its <span class="literal">emulatorHelper</span> to facilitate this process.</p>
<p class="programs">private void writeBackMemory() {<br/>
    AddressSetView memWrites = emuHelper.getTrackedMemoryWriteSet();<br/>
    AddressIterator aIter = memWrites.getAddresses(true);<br/>
    Memory mem = currentProgram.getMemory();<br/>
    while (aIter.hasNext()) {<br/>
        Address a = aIter.next();<br/>
        MemoryBlock mb = getMemoryBlock(a);<br/>
        if (mb == null) {<br/>
            continue;<br/>
        }<br/>
<span epub:type="pagebreak" id="page_502"/>
        if (!mb.isInitialized()) {<br/>
            // initialize memory<br/>
            try {<br/>
                mem.convertToInitialized(mb, (byte)0x00);<br/>
            } catch (Exception e) {<br/>
                println(e.toString());<br/>
            }<br/>
        }<br/>
        try {<br/>
            mem.setByte(a, emuHelper.readMemoryByte(a));<br/>
        } catch (Exception e) {<br/>
            println(e.toString());<br/>
        }<br/>
    }<br/>
}</p>
<h5 class="h5" id="ch21lev412"><strong>Step 3-6: Clean Up Resources</strong></h5>
<p class="noindent">In this step, we need to clean up resources and release the lock that we have on the current program. Both can be accomplished in one easy statement:</p>
<p class="programs">emuHelper.dispose();</p>
<p class="indent">Since this emulator is only for demonstration purposes, we took some liberties in what was included in the script. To conserve space, we minimized the comments, functionality, error checking, and error handling that we would normally include in a production script. All that remains is to confirm that our emulator script is able to accomplish our goal.</p>
<h4 class="h4" id="ch21lev413"><strong><em>Step 4: Add the Script to Our Ghidra Installation</em></strong></h4>
<p class="noindent">Adding a script to our Ghidra installation just requires dropping it somewhere that Ghidra will find it. If you set up the script project as a linked project, Ghidra knows where to find it already. If you did not link your script project (or if you created your emulator script in another editor), you need to save it in one of Ghidra’s script directories, as discussed in <a href="ch14.xhtml#ch14">Chapter 14</a>.</p>
<h4 class="h4" id="ch21lev414"><strong><em>Step 5: Test the Script Within Ghidra</em></strong></h4>
<p class="noindent">To test the script, we will load the binary associated with the crackme challenge source code. When we load the binary and navigate to the <span class="literal">unpack</span> function, we note that it contains references to the <span class="literal">check_access</span> label:</p>
<p class="programs">0010077d 48 8d 05 8c 08 20 00  LEA    RAX,[check_access]</p>
<p class="indent">The code in the Decompiler window contains the following, which does not get us any closer to solving our crackme:</p>
<p class="programs">check_access[(int)local_c] = check_access[(int)local_c] ^ key;</p>
<span epub:type="pagebreak" id="page_503"/>
<p class="indent">Double-clicking <span class="literal">check_access</span> within the Listing window leads us to address <span class="literal">00301010</span>, which does not look like instructions within a function.</p>
<p class="programs">00301010 f0 ed 2c 40 2c d8 59  undefined1[19]<br/>
         26 d8 59 c1 aa 31 65<br/>
         aa 13 65 f8 66</p>
<p class="indent">If we chose to disassemble this content, we would receive a bad data error in Ghidra. The Decompiler window also provides no help for this location. So let’s use our script to see if we can emulate the <span class="literal">unpack</span> function. We select the instructions that make up the <span class="literal">unpack</span> function and open the Script Manager and run our script. We see no observable change in the <span class="literal">unpack</span> function or in the Decompiler window. But if we navigate to <span class="literal">check_access</span> (<span class="literal">00301010</span>), the content has changed!</p>
<p class="programs">00301010 55 48 89 e5 89 7d     undefined1[19]<br/>
         fc 83 7d fc 64 0f<br/>
         94 c0 0f b6 c0 5d c3</p>
<p class="indent">We can clear these code bytes (hotkey C) and then disassemble (hotkey D) and obtain the following results:</p>
<p class="programs">     check_access<br/>
00301010 55                    PUSH   RBP<br/>
00301011 48 89 e5              MOV    RBP,RSP<br/>
00301014 89 7d fc              MOV    dword ptr [RBP + -0x4],EDI<br/>
00301017 83 7d fc 64           CMP    dword ptr [RBP + -0x4],100<br/>
0030101b 0f 94 c0              SETZ   AL<br/>
0030101e 0f b6 c0              MOVZX  EAX,AL<br/>
00301021 5d                    POP    RBP<br/>
00301022 c3                    RET</p>
<p class="indent">Here is the corresponding code in the Decompiler window:</p>
<p class="programs">ulong UndefinedFunction_00301010(int param_1)<br/>
{<br/>
  return (ulong)(param_1 == 100);<br/>
}</p>
<p class="indent">This was just a proof-of-concept script to demonstrate the use of emulators to aid in code deobfuscation, but it does show how a relatively general-purpose emulator can be built within Ghidra by using its emulator support classes. There are other situations where developing and using emulators are an appropriate course of action. An immediate advantage of emulation over debugging is that potentially malicious code is never actually executed by an emulator, whereas debugger-assisted deobfuscation must allow at least some portion of the malicious program to execute in order to obtain the deobfuscated version of the program.</p>
<span epub:type="pagebreak" id="page_504"/>
<h3 class="h3" id="ch21lev415"><strong>Summary</strong></h3>
<p class="noindent">Obfuscated programs are the rule rather than the exception when it comes to malware these days. Any attempts to study the internal operations of a malware sample are almost certain to require some type of deobfuscation. Whether you take a debugger-assisted, dynamic approach to deobfuscation or you prefer not to run potentially malicious code and instead choose to use scripts or emulation to deobfuscate your binaries, the ultimate goal is to produce a deobfuscated binary that can be fully disassembled and properly analyzed.</p>
<p class="indent">In most cases, this final analysis will be performed using a tool such as Ghidra. Given this ultimate goal (of using Ghidra for analysis), it makes sense to attempt to use Ghidra from start to finish. The techniques presented in this chapter are intended to demonstrate that Ghidra is capable of far more than simply generating disassembly listings, and we build on this in the next chapter as we look at how we can use Ghidra to patch our disassembly listings.</p>
</div>



  </body></html>