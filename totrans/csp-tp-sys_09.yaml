- en: <samp class="SANS_Dogma_OT_Bold_B_11">AFTERWORD</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*There are two ways of constructing a software design: One way is to make it
    so simple that there are obviously no deficiencies, and the other way is to make
    it so complicated that there are no obvious deficiencies. The first method is
    far more difficult.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Tony (C.A.R.) Hoare, 1980 Turing Award Lecture
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: Computer programming is a subtle art. A successful programmer needs more than
    knowledge of a programming language’s syntax. Getting the most out of any programming
    language requires a deep understanding of its *mechanics* (how the syntax elements
    fit together) and its *semantics* (how those elements define and control the resulting
    program’s behavior).
  prefs: []
  type: TYPE_NORMAL
- en: 'Semantics can be low level, such as the effects of copy-by-value behavior on
    equality comparisons between objects, or more conceptual, such as the application
    of different kinds of polymorphism. Semantics also plays a part in application
    design: carefully designed objects can express different concepts in a system,
    giving the code structure and meaning.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding the mechanics and semantics of C# allows us to write code that
    makes better use of the language constructs. This comes with several potential
    benefits: more efficient use of memory and processor resources; simpler, easier-to-understand
    code (by other programmers as well as ourselves); and an enhanced capability to
    add new features and diagnose errors.'
  prefs: []
  type: TYPE_NORMAL
- en: When designing a system, whatever its size and purpose, it’s easy to focus on
    the big architectural components that form the application’s overall shape. Even
    when a design is emergent—that is, it takes shape organically as we start creating
    features—the fine-grained values are easily forgotten or dismissed as the small,
    passive bits of data passed between the more interesting system interfaces. In
    this book, we’ve explored the relationship between those values and other application
    elements because recognizing value types as the *currency* of information in a
    system gives us opportunities not only to better express the overall design, but
    also to clarify the purpose of the code that uses them. Rich custom value types
    help us establish a ubiquitous language in an application that plays an important
    part in conveying a design and its overall purpose. They also enable the compiler
    to catch more errors before run time.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing every feature of a complex language like C# in a book like this is
    not practical, partly because C# is an evolving language. Its features expand
    constantly to meet the needs of programmers in all domains. This is a Good Thing™
    because the software development landscape is also continually evolving, but C#
    programming practitioners are responsible for keeping up with that progress. In
    this book, I’ve presented numerous techniques and features to help you better
    understand C# as it is today, and I hope I’ve also inspired you to explore the
    characteristics, performance, and semantics of features that the C# language designers
    add in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the intricacies of C# semantics for value and value-like types
    can be challenging, but your effort will be rewarded with richer, clearer designs
    that are easier to maintain and extend. I hope this book has given you a deeper
    appreciation for and knowledge of the diverse facilities that C# provides for
    creating these types, and, most importantly, I hope it has made you a better programmer.
  prefs: []
  type: TYPE_NORMAL
