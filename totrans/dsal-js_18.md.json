["```\nconst goesHigher = (a, b) => a > b;\n\nconst newSkewHeap = () => null;\n\nconst newNode = (key, left = null, right = null) => ({key, left, right});\n\nconst isEmpty = (heap) => heap === null;\n\nconst top = (heap) => (isEmpty(heap) ? undefined : heap.key);\n```", "```\nconst merge = (heap1, heap2) => {\n❶ if (isEmpty(heap2)) {\n   return heap1;\n❷} else if (isEmpty(heap1)) {\n   return heap2;\n } else if (goesHigher(heap1.key, heap2.key)) {\n ❸ [heap1.left, heap1.right] = [merge(heap2, heap1.right), heap1.left];\n return heap1;\n } else {\n ❹ return merge(heap2, heap1);\n }\n};\n```", "```\nconst add = (heap, keyToAdd) => {\n❶ const newHeap = newNode(keyToAdd);\n❷ return [merge(heap, newHeap), newHeap];\n};\n```", "```\nconst remove = (heap) => {\n❶ if (isEmpty(heap)) {\n    throw new Error(\"Empty heap; cannot remove\");\n  } else {\n  ❷ const topKey = top(heap);\n  ❸ return [merge(heap.left, heap.right), topKey];\n  }\n};\n```", "```\n❶ const newBinomialHeap = () => [];\n\n❷ const newNode = (key) => ({\n  key,\n  right: null,\n  down: null,\n  up: null,\n  degree: 0\n});\n\n❸ const isEmpty = (heap) => heap.length === 0;\n```", "```\n❶ const _findTop = (trees) => {\n  let top;\n  trees.forEach((v, i) => {\n    if (top === undefined || goesHigher(v.key, trees[top].key)) {\n      top = i;\n    }\n  });\n  return top;\n};\n\n❷ const top = (heap) => (isEmpty(heap) ? undefined : heap[_findTop(heap)].key);\n```", "```\nconst _mergeA2B = (low, high) => {\n❶ low.right = high.down;\n❷ low.up = high;\n❸ high.down = low;\n❹ high.degree++;\n  return high;\n};\n```", "```\nconst add = (heap, keyToAdd) => {\n❶ const newHeap = newNode(keyToAdd);\n❷ return [merge(heap, [newHeap]), newHeap];\n};\n```", "```\nconst merge = (heap1, heap2) => {\n  const merged = [];\n❶ heap1.forEach((v) => {\n    merged[v.degree] = v;\n  });\n\n  let j = 0;\n❷ while (j < heap2.length) {\n    const i = heap2[j].degree;\n\n  ❸ if (!(i in merged) || merged[i] === null) {\n      merged[i] = heap2[j];\n      j++;\n    } else {\n      if (goesHigher(heap2[j].key, merged[i].key)) {\n      ❹ heap2[j] = _mergeA2B(merged[i], heap2[j]);\n      } else {\n      ❺ heap2[j] = _mergeA2B(heap2[j], merged[i]);\n      }\n    ❻ merged[i] = null;\n    }\n  }\n\n ❼ return merged.filter(Boolean);\n};\n```", "```\nconst remove = (heap) => {\n❶ if (isEmpty(heap)) {\n    throw new Error(\"Empty heap\");\n  }\n\n❷ const top = _findTop(heap);\n❸ const heapTop = heap[top].key;\n\n❹ const newTrees = [];\n❺ let bt = heap[top].down;\n  while (bt) {\n  ❻ newTrees.push(bt);\n  ❼ const nextBt = bt.right;\n    bt.right = null;\n    bt.up = null;\n    bt = nextBt;\n  }\n\n❽ heap.splice(top, 1);\n❾ return [merge(heap, newTrees), heapTop];\n};\n```", "```\nconst changeKey = (heap, node, newKey) => {\n❶ if (isEmpty(heap)) {\n    throw new Error(\"Heap is empty!\");\n❷} else if (!goesHigher(newKey, node.key)) {\n    throw new Error(\"New value should go higher than old value\");\n  } else {\n  ❸ node.key = newKey;  \n    _bubbleUp(heap, node);\n    return heap;\n  }\n};\n```", "```\nconst _bubbleUp = (heap, node) => {\n❶ if (node.up && goesHigher(node.key, node.up.key)) {\n  ❷ const parent = node.up;\n  ❸ [\n      node.up,\n      node.down,\n      node.right,\n      node.degree,\n      parent.up,\n      parent.down,\n      parent.right,\n      parent.degree\n    ] = [\n      parent.up,\n      parent,\n      parent.right,\n      parent.degree,\n      node,\n      node.down,\n      node.right,\n      node.degree\n    ];\n\n  ❹ if (node.up) {\n      _bubbleUp(heap, node);\n  ❺} else {\n      const i = heap.findIndex((v) => v === parent);\n      heap[i] = node;\n    }\n  }\n};\n```", "```\nconst goesHigher = (a, b) => a > b;\n\n❶ const newLazyBinomialHeap = () => ({\n **top: undefined,**\n **trees: []**\n});\n\nconst newNode = (key) => ({\n  key,\n  right: null,\n  down: null,\n  up: null,\n  degree: 0\n});\n\n❷ const isEmpty = (heap) => **heap.trees.length** === 0;\n\n❸ const top = (heap) => (isEmpty(heap) ? undefined : heap.top);\n```", "```\nconst add = (heap, keyToAdd) => {\n❶ const newHeap = newNode(keyToAdd);\n❷ heap.trees.push(newHeap);\n\n❸ if (heap.top === undefined || goesHigher(keyToAdd, heap.top)) {\n    heap.top = keyToAdd;\n  }\n\n  return [heap, newHeap];\n};\n```", "```\nconst remove = (heap) => {\n❶ if (isEmpty(heap)) {\n    throw new Error(\"Empty heap\");\n  }\n\n❷ const heapTop = heap.top;\n\n❸ const top = _findTop(heap.trees);\n  let bt = heap.trees[top].down;\n❹ while (bt) {\n    heap.trees.push(bt);\n    const nextBt = bt.right;\n    bt.right = null;\n    bt.up = null;\n    bt = nextBt;\n  }\n\n❺ heap.trees.splice(top, 1);\n❻ const newHeap = merge(newLazyBinomialHeap(), {\n    top: undefined,\n    trees: heap.trees\n  });\n\n❼ newHeap.top =\n    newHeap.trees.length === 0\n      ? undefined\n      : newHeap.trees[_findTop(newHeap.trees)].key;\n\n❽ return [newHeap, heapTop];\n};\n```", "```\nconst changeKey = (heap, node, newKey) => {\n  if (isEmpty(heap)) {\n    throw new Error(\"Heap is empty!\");\n  } else if (!goesHigher(newKey, node.key)) {\n    throw new Error(\"New value should go higher than old value\");\n } else {\n    node.key = newKey;\n    _bubbleUp(heap, node);\n\n    **heap.top =**\n **heap.trees.length === 0**\n **? undefined**\n **: heap.trees[_findTop(heap.trees)].key;**\n\n    return heap;\n  }\n};\n```", "```\nconst goesHigher = (a, b) => a > b;\n\nconst newFibonacciHeap = () => ({\n  top: undefined,\n  trees: []\n});\n\nconst newNode = (key) => ({\n  key,\n  degree: 0,\n **marked: false,**\n  **left: null**,\n  right: null,\n  down: null,\n  up: null\n});\n\nconst isEmpty = (heap) => heap.trees.length === 0;\n\nconst top = (heap) => (isEmpty(heap) ? undefined : heap.top);\n```", "```\nmergeA2B(low, high) {\n❶ if (high.down) {\n  ❷ low.right = high.down;\n    low.left = high.down.left;\n    high.down.left.right = low;\n    high.down.left = low;\n  }\n\n❸ high.down = low;\n❹ low.up = high;\n❺ high.degree++;\n\n❻ return high;\n}\n```", "```\nconst add = (heap, keyToAdd) => {\n  const newHeap = newNode(keyToAdd);\n\n **newHeap.left = newHeap;**\n **newHeap.right = newHeap;**\n\n  heap.trees.push(newHeap);\n\n  if (heap.top === undefined || goesHigher(keyToAdd, heap.top)) {\n    heap.top = keyToAdd;\n  }\n\n  return [heap, newHeap];\n};\n```", "```\nconst remove = (heap) => {\n  if (isEmpty(heap)) {\n    throw new Error(\"Empty heap\");\n  }\n\n  const heapTop = heap.top;\n\n  const top = _findTop(heap.trees);\n\n let bt = heap.trees[top].down;\n\n **if (bt && bt.left) {**\n❶ **bt.left.right = null;**\n **}**\n\n  while (bt) {\n    heap.trees.push(bt);\n    const nextBt = bt.right;\n❷ **bt.right = bt;**\n **bt.left = bt;**\n    bt.up = null;\n    bt = nextBt;\n  }\n\n  heap.trees.splice(top, 1);\n  const newHeap = merge(newFibonacciHeap(), {\n    top: undefined,\n    trees: heap.trees\n  });\n\n  newHeap.top =\n    newHeap.trees.length === 0\n      ? undefined\n      : newHeap.trees[_findTop(newHeap.trees)].key;\n\n  return [newHeap, heapTop];\n};\n```", "```\nconst changeKey = (heap, node, newKey) => {\n  if (isEmpty(heap)) {\n    throw new Error(\"Heap is empty!\");\n  } else if (!goesHigher(newKey, node.key)) {\n    throw new Error(\"New value should go higher than old value\");\n  } else {\n    node.key = newKey;\n **_separate(heap, node);**\n  }\n};\n```", "```\nconst _separate = (heap, node) => {\n❶ node._marked = false;\n\n❷ const parent = node.up;\n❸ if (parent) {\n  ❹ if (node.right === node) {\n      parent.down = null;\n    } else {\n    ❺ if (parent.down === node) {\n        parent.down = node.right;\n      }\n    ❻ node.left.right = node.right;\n      node.right.left = node.left;\n    }\n  ❼ parent.degree--;\n\n  ❽ node.up = null;\n    node.left = node;\n    node.right = node;\n    heap.trees.push(node);\n\n  ❾ if (parent._marked) {\n      _separate(heap, parent);\n  ❿} else {  \n      parent._marked = true;\n    }\n  }\n\n  if (goesHigher(node.key, heap.top)) {\n    heap.top = node.key;\n  }\n};\n```", "```\nconst goesHigher = (a, b) => a > b;\n\nconst newPairingHeap = () => null;\n\nconst newNode = (key, down = null, right = null) => ({key, down, right});\n\nconst isEmpty = (heap) => heap === null || heap.key === undefined;\n\nconst top = (heap) => (isEmpty(heap) ? undefined : heap.key);\n```", "```\nconst merge = (heap1, heap2) => {\n❶ if (isEmpty(heap2)) {\n   return heap1;\n❷} else if (isEmpty(heap1)) {\n   return heap2;\n❸} else if (goesHigher(heap1.key, heap2.key)) {\n   [heap2.right, heap1.down] = [heap1.down, heap2];\n   return heap1;\n❹} else {\n   [heap1.right, heap2.down] = [heap2.down, heap1];\n   return heap2;\n  }\n};\n```", "```\nconst add = (heap, keyToAdd) => {\n❶ const newHeap = newNode(keyToAdd);\n❷ return [merge(heap, newHeap), newHeap];\n};\n```", "```\nconst _mergeByPairs = (heaps) => {\n❶ if (heaps.length === 0) {\n   return newPairingHeap();\n❷} else if (heaps.length === 1) {\n   return heaps[0];\n❸} else {\n   return merge(merge(heaps[0], heaps[1]), _mergeByPairs(heaps.slice(2)));\n }\n};\n```", "```\nmbp([A,B,C,D,E,F,G]) =\nm(AB, mbp([C,D,E,F,G]) =\nm(AB, m(CD, mbp([E,F,G]))) =\nm(AB, m(CD, m(EF, mbp([G])))) =\nm(AB, m(CD, m(EF, G))) =\nm(AB, m(CD, EFG)) =\nm(AB, CDEFG) =\n**ABCDEFG**\n```", "```\nconst remove = (heap) => {\n❶ if (isEmpty(heap)) {\n    throw new Error(\"Empty heap; cannot remove\");\n  } else {\n  ❷ const top = heap.key;\n\n  ❸ const children = [];\n  ❹ let child = heap.down;\n  ❺ while (!isEmpty(child)) {\n      const next = child.right;\n      child.right = null;\n    ❻ children.push(child);\n      child = next;\n    }\n\n  ❼ return [_mergeByPairs(children), top];\n  }\n};\n```", "```\nconst changeKey = (heap, node, newKey) => {\n  if (isEmpty(heap)) {\n    throw new Error(\"Heap is empty!\");\n  } else if (!goesHigher(newKey, node.key)) {\n    throw new Error(\"New value should go higher than old value\");\n  } else {\n  ❶ node.key = newKey;\n  ❷ const parent = node.up;\n  ❸ if (parent && goesHigher(newKey, parent.key)) {\n    ❹ if (parent.down === node) {\n        parent.down = node.right;\n      } else {\n      ❺ let child = parent.down;\n      ❻ while (child.right !== node) {\n        ❼ child = child.right;\n        }\n ❽ child.right = node.right;\n      }\n    ❾ node.right = null;\n    ❿ heap = merge(heap, node);\n    }\n\n    return heap;\n  }\n};\n```", "```\nconst _bubbleUp = (heap, node, newKey) => {\n  node.key = newKey;\n  const parent = node.up;\n  if (parent && goesHigher(newKey, parent.key)) {\n    node.key = parent.key;\n    _bubbleUp(parent, newKey);\n  }\n};\n```"]