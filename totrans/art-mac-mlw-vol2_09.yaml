- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 7 NETWORK MONITORING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, I’ll describe various approaches for monitoring network activity
    on macOS systems. I’ll start simple, by showing you how to regularly schedule
    network snapshots to obtain a near-continuous view of a host’s network activity.
    Next, you’ll dive deep into Apple’s *NetworkExtension* framework and APIs, which
    provide a means of customizing the operating system’s core networking features
    and building comprehensive network monitoring tools. As an example, I’ll discuss
    leveraging this powerful framework to build host-based DNS monitors and firewalls
    capable of filtering and blocking selected activity.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](chapter4.xhtml), we generated a snapshot of a device’s network
    state at given moments. While this simple approach can efficiently detect a variety
    of malicious behaviors, it has several limitations. Most notably, if malware isn’t
    accessing the network at the exact time at which the snapshot is taken, it will
    remain undetected. For example, the malware leveraged in the 3CX supply chain
    attack beaconed only every hour or two.^([1](#chapter7-1)) Unless the network
    snapshot was serendipitously scheduled, it would miss the malware’s network activity.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this shortcoming, we can continuously monitor the network for signs
    of infections. The collected network data could help us build baselines of normal
    traffic over time and provide a corpus for input to a larger distributed threat
    hunting system. While these approaches can be more complex to implement than simple
    snapshot tools, the insight they provide into the network activity on a host makes
    them an invaluable component of any comprehensive malware detection tool.
  prefs: []
  type: TYPE_NORMAL
- en: This book won’t cover using the framework for full packet captures, as capturing
    and processing this data would require significant resources, so it’s almost always
    best to perform these captures directly on the network, rather than on the host.
    Moreover, full packet captures are generally overkill for detecting malware. Often,
    simply identifying some unauthorized network activity, such as a listening socket
    or a connection to an unrecognized API endpoint, is sufficient to cast suspicion
    on a process (especially those that are unrecognized) and reveal an infection.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To use the* NetworkExtension *framework tools, we must add the proper entitlements,
    and we must build the code with provisioning profiles that authorize these entitlements
    at runtime. I won’t cover this process here, as the focus is on core concepts
    of working with the framework. Turn to [Part III](part3.xhtml) to learn how to
    obtain the necessary entitlements and create provisioning profiles.*'
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining Regular Snapshots
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One simple way to continuously monitor network activity is to repeatedly take
    snapshots of the current network state. For example, in [Chapter 4](chapter4.xhtml),
    we used Apple’s nettop utility to display network information. When you run this
    tool, it appears to update the information whenever new connections appear. However,
    consulting the utility’s man page reveals that, behind the scenes, nettop does
    nothing more than obtain network snapshots at regular intervals. By default, it
    takes a snapshot every second, though you can change this interval with the -s
    command line option. Is this a true network monitor? No, but its approach is straightforward
    and, assuming the snapshots happen often, likely comprehensive enough to detect
    suspicious network activity.
  prefs: []
  type: TYPE_NORMAL
- en: To mimic nettop, we can capture a snapshot of the network activity using the
    *NetworkStatistics* framework, invoking its NStatManagerQueryAllSourcesDescriptions
    API, as discussed in [Chapter 4](chapter4.xhtml). Then we can simply reinvoke
    the API at regular intervals. The code in [Listing 7-1](chapter7.xhtml#Lis7-1)
    does exactly this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-1: Regularly capturing the network state'
  prefs: []
  type: TYPE_NORMAL
- en: The code first creates a dispatch queue ❶ and a dispatch source ❷. Then it sets
    the start time and refresh rate for the dispatch source via the dispatch_source_set_timer
    API ❸. For illustrative purposes, we specify a refresh rate of 10 seconds. The
    API call requires this rate in nanoseconds, so we multiply it by NSEC_PER_SEC,
    a system constant representing the number of nanoseconds in one second. Next,
    we create an event handler ❹ that will reinvoke the NStatManagerQueryAllSourcesDescriptions
    API each time the dispatch source is refreshed. Finally, we invoke the dispatch_resume
    function ❺ to set the snapshot-based monitor in motion. Now, onto a continual
    monitor.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Monitoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Monitoring DNS traffic is an effective way to detect many types of malware.
    The idea is simple: regardless of how malware infects a victim’s machine, any
    connection it makes to a domain, such as its command-and-control server, will
    generate a DNS request and response. If we monitor DNS traffic directly on the
    host, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identify new processes using the network** Anytime this activity occurs,
    you should closely examine the new process. Users frequently install new software
    that accesses the network for legitimate reasons, but if the item isn’t notarized
    or persists, for example, it could be malicious.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Extract the domain that the process is attempting to resolve** If the domain
    looks suspicious (perhaps because it’s hosted by an internet service provider
    commonly leveraged by malicious actors), it could reveal the presence of malware.
    Also, saving these DNS requests provides a historical record of system activity
    that you can query whenever the security community discovers new malware to see,
    albeit retroactively, whether you’ve been infected.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Detect malware abusing DNS as an exfiltration channel** As firewalls typically
    allow DNS traffic, malware can exfiltrate data through valid DNS requests.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Monitoring just DNS traffic is a more efficient approach than monitoring all
    network activity, yet it still provides a way to uncover most malware. For example,
    take a look at a malicious updater component I discovered in early 2023.^([2](#chapter7-2))
    Dubbed iWebUpdater, this binary persistently installs itself to *~/Library/Services/iWebUpdate*.
    It then beacons to the domain *iwebservicescloud.com* to send information about
    the infected host and to download and install additional binaries. Within the
    malicious *iWebUpdate* binary, you can find this hardcoded domain at the address
    0x10000f7c2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In its disassembly, you can see the malware references this address when it
    builds a URL whose parameters contain information about the infected host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Then the malicious updater attempts to connect to the URL by leveraging the
    curl API. Using the popular network monitoring tool Wireshark, we can observe
    the DNS request and resulting response ([Figure 7-1](chapter7.xhtml#fig7-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: A network capture of iWebUpdater resolving the IP address of its
    update server'
  prefs: []
  type: TYPE_NORMAL
- en: Even though antivirus engines initially didn’t flag the binary as malicious,
    the *iwebservicescloud.com* domain has a long history of resolving to IP addresses
    associated with malicious actors. If we could tie the DNS data back to the iWebUpdate
    binary (which I’ll show how to do shortly), we could see that it originates from
    a persistently installed launch agent that isn’t signed. Shady!
  prefs: []
  type: TYPE_NORMAL
- en: For another example of the power of DNS monitoring, let’s consider the 3CX supply
    chain attack more closely. Supply chain attacks are notoriously difficult to detect,
    and in this case, Apple inadvertently notarized the subverted 3CX installer. Although
    traditional antivirus software didn’t initially flag the application as malicious,
    security tools leveraging DNS monitoring capabilities quickly noticed that something
    was amiss and began alerting users, who flocked to the 3CX forums, posting messages
    such as “I had an alert come through . . . telling me that the 3CX Desktop App
    has been attempting to communicate with a ‘highly suspicious’ domain, likely to
    be actor controlled.”^([3](#chapter7-3))
  prefs: []
  type: TYPE_NORMAL
- en: Could other heuristics have detected the attack? Possibly, but even Apple’s
    notarization system failed to notice it. Luckily, a DNS monitor provided a way
    to detect that the subverted application was communicating with a new and unusual
    domain, and mitigations soon limited what could have been a massively impactful
    and widespread cybersecurity event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there are downsides to DNS monitoring. Most notably, it won’t help
    you detect malware that doesn’t resolve domains, such as simple backdoors that
    merely open listening sockets for remote connections, or those that directly connect
    to an IP address. Though such malware is rare, you’ll encounter it occasionally.
    For example, Dummy, the simple Mac malware mentioned previously, creates a reverse
    shell to a hardcoded IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Connecting directly to an IP address doesn’t generate any DNS traffic, so a
    DNS monitor wouldn’t detect Dummy. In this case, you’d need a more comprehensive
    *filter data provider* that is capable of monitoring all traffic. Later in this
    chapter, I will show you how to build such a tool using the same framework and
    many of the same APIs used to build a simpler DNS monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Using the NetworkExtension Framework
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Monitoring network traffic on macOS used to require writing a network kernel
    extension. Apple has since deprecated this approach, along with all third-party
    kernel extensions, and introduced *system extensions* to replace it. System extensions
    run more safely in user mode and provide a modern mechanism to extend or enhance
    macOS functionality.^([4](#chapter7-4))
  prefs: []
  type: TYPE_NORMAL
- en: To extend core networking features, Apple also introduced the user-mode *NetworkExtension*
    framework.^([5](#chapter7-5)) By building system extensions that leverage this
    framework, you can achieve the same capabilities as the now-deprecated network
    kernel extensions, but from user mode.
  prefs: []
  type: TYPE_NORMAL
- en: System extensions are powerful, so Apple requires that you fulfill several prerequisites
    before you can deploy your extension:^([6](#chapter7-6))
  prefs: []
  type: TYPE_NORMAL
- en: You must package the extension in an application bundle’s *Contents/Library/SystemExtensions/*
    directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application containing the extension must be given the *com.apple .developer.system-extension.install*
    entitlement, and you must build it with a provisioning profile that provides the
    means to authorize the entitlement at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application containing the extension must be signed with an Apple developer
    ID, as well as notarized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application containing the extension must be installed in an appropriate
    *Applications* directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In unmanaged environments, macOS requires explicit user approval to load any
    system extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ll explain how to fulfill these requirements in [Chapter 13](chapter13.xhtml).
    As I noted in the book’s introduction, you can turn off System Integrity Protection
    (SIP) and Apple Mobile File Integrity (AMFI) to sidestep some of them. However,
    disabling these protections significantly reduces the overall security of the
    system, so I recommend doing so only within a virtual machine or on a system dedicated
    to development or testing.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I will briefly cover how to programmatically install and load a system
    extension, then use the *NetworkExtension* framework to monitor DNS traffic. Here,
    relevant code snippets are provided, and you can find this code in its entirety
    in Objective-See’s open source *DNSMonitor* project, covered in detail in [Chapter
    13](chapter13.xhtml).^([7](#chapter7-7))
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Several APIs mentioned in this section have recently been deprecated by Apple,
    for example, in macOS 15\. However, at the time of this publication, they retain
    their functionality. If you’re developing for older versions of macOS, you’ll
    still want to use these APIs for compatibility. Additionally, some deprecated
    functions, such as those from Apple’s* libresolv *library, lack direct replacements,
    so it makes sense to continue using them where necessary.*'
  prefs: []
  type: TYPE_NORMAL
- en: Activating a System Extension
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Apple requires you to place any system extension in an application bundle, so
    the code to install, or *activate*, a system extension must also live in the application.
    [Listing 7-2](chapter7.xhtml#Lis7-2) shows how to programmatically activate such
    an extension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-2: Installing a system extension'
  prefs: []
  type: TYPE_NORMAL
- en: 'The application that contains an extension should first invoke the OSSystemExtensionRequest
    class’s activationRequestForExtension:queue: method ❶, which creates a request
    to activate a system extension.^([8](#chapter7-8)) The method takes the extension’s
    bundle ID and a dispatch queue, which it will use to call delegate methods. We
    must set a delegate ❷ before we can submit the request to the system extension
    manager to trigger the activation ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s talk about the delegate in a bit more detail. The OSSystemExtensionRequest
    object requires a *delegate object*, which should conform to the OSSystemExtensionRequestDelegate
    protocol and implement various delegate methods to handle callbacks that occur
    during the activation process, as well as success and failure cases. The operating
    system will automatically invoke these delegate methods during the process of
    activating the extension. Here is a brief overview of these required delegate
    methods, based on Apple’s documentation:^([9](#chapter7-9))
  prefs: []
  type: TYPE_NORMAL
- en: '**requestNeedsUserApproval**: Invoked when the system has determined that it
    needs user approval before activating the extension'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**request:actionForReplacingExtension:withExtension:** Invoked when another
    version of the extension is already installed on the system'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**request:didFailWithError:** Invoked when the activation request has failed'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**request:didFinishWithResult:** Invoked when the activation request has completed'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s important that your application implement these required delegate methods.
    Otherwise, it will crash when the system attempts to invoke them during the activation
    of your extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that implementing the methods doesn’t involve much. For example,
    the requestNeedsUserApproval: method can simply return, as can the request:didFailWithError:
    method (although you’ll likely want to use it to log error messages). The request:actionForReplacingExtension:withExtension:
    method can return a value of OSSystemExtensionReplacementActionReplace to tell
    the operating system to replace any old instances of the extension.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the user has approved the extension, the system will invoke the request:didFinishWithResult:
    delegate method. If the result passed into this method is OSSystemExtensionRequestCompleted,
    the extension has successfully activated. At this point, you can proceed to enable
    network monitoring.'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the Monitoring
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Assuming the system extension activated successfully, you can now instruct the
    system to begin routing all DNS traffic through the extension. A singleton NEDNSProxyManager
    object can enable this monitoring, as shown in [Listing 7-3](chapter7.xhtml#Lis7-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-3: Enabling DNS monitoring via an NEDNSProxyManager object'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must load the current DNS proxy configuration by calling the NEDNSProxyManager
    class’s shared manager loadFromPreferencesWithCompletionHandler: method ❶. As
    its only argument, this method takes a block to invoke once the preferences have
    been loaded.'
  prefs: []
  type: TYPE_NORMAL
- en: After invoking the callback, we can configure the preferences to enable the
    DNS monitor. First, we set a description ❷ that will appear in the operating system’s
    System Settings application, which can display all active extensions. Then we
    allocate and initialize an NEDNSProxyProviderProtocol object with the bundle ID
    of our extension ❸. Following this, we specify that we’re toggling the DNS monitor
    on by setting the NEDNSProxyManager object’s shared manager enabled instance variable
    to YES ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we invoke the shared manager’s saveToPreferencesWithCompletionHandler
    method to save the updated configuration information ❺. Once we make this call,
    the system extension should be fully activated, and the operating system will
    begin proxying DNS traffic through it.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Extension
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we make a request to activate a system extension and toggle on a network
    extension, the system will copy the extension from the application’s bundle into
    a secure, root-owned directory, */Library/SystemExtension*. After verifying the
    extension, the system will load and execute it as a stand-alone process running
    with root privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve activated the extension from within the application, let’s explore
    the code found in the extension itself. [Listing 7-4](chapter7.xhtml#Lis7-4) begins
    the extension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-4: The network extension’s initialization logic'
  prefs: []
  type: TYPE_NORMAL
- en: In the extension’s main function, we invoke the NEProvider startSystemExtensionMode
    method to “start the Network Extension machinery.”^([10](#chapter7-10)) I also
    recommend making a call to dispatch_main; otherwise, the main function will return,
    and your extension will exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind the scenes, the startSystemExtensionMode method will cause the *NetworkExtension*
    framework to instantiate the class specified under the NEProviderClasses key of
    the NetworkExtension dictionary in the extension’s *Info.plist* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You must create this class, naming it whatever you’d like. Here, we’ve chosen
    the name DNSProxyProvider, and as we’re interested in proxying DNS traffic, we
    used the key value com.apple.networkextension.dns-proxy. This class must inherit
    from the NEProviderClass class or one of its subclasses, such as NEDNSProxyProvider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, the class must implement relevant delegate methods that the *NetworkExtension*
    framework will call to, for example, handle DNS network events. These delegate
    methods include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The start and stop methods provide you with an opportunity to perform any necessary
    initialization or cleanup. You can learn more about them in the *NEDNSProxyProvider.h*
    file or in Apple’s developer documentation for the NEDNSProxyProvider class.^([11](#chapter7-11))
  prefs: []
  type: TYPE_NORMAL
- en: 'The *NetworkExtension* framework will automatically invoke the handleNewFlow:
    delegate method to deliver the network data, so this method should contain the
    DNS monitor’s core logic. The method gets invoked with a *flow*, which represents
    a unit of network data transferred between a source and destination.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The NEAppProxyFlow objects encapsulate flows passed to handleNewFlow: to provide
    an interface for the network data. Because DNS traffic generally travels over
    UDP, this example focuses solely on UDP flows, whose type is NEAppProxyUDPFlow,
    a subclass of NEAppProxyFlow. In [Chapter 13](chapter13.xhtml), I’ll go through
    the steps of proxying UDP traffic in detail, but for now, we’ll just consider
    the process of interacting with DNS packets.'
  prefs: []
  type: TYPE_NORMAL
- en: Parsing DNS Requests
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can read from an NEAppProxyUDPFlow flow object to obtain a list of datagrams
    for a specific DNS request (or *question*, in DNS parlance). Each datagram is
    stored in an NSData object; [Listing 7-5](chapter7.xhtml#Lis7-5) parses and prints
    these out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-5: Reading and then parsing DNS datagrams'
  prefs: []
  type: TYPE_NORMAL
- en: We parse the packet via the dns_parse_packet function ❶, found in Apple’s *libresolv*
    library. We then print out the packet via a call to the dns_print_reply function
    ❷. Finally, we free it via the dns_free_reply function ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you’ll likely want your program to examine the DNS request rather
    than just print it out. You can inspect the parsed DNS record returned by the
    dns_parse_packet function, which has the type dns_reply_t. For example, [Listing
    7-6](chapter7.xhtml#Lis7-6) shows how to access the request’s fully qualified
    domain name (FQDN).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-6: Extracting members of interest from a parsed DNS request'
  prefs: []
  type: TYPE_NORMAL
- en: We make use of the qdcount and question members of the DNS packet to iterate
    over every question ❶. For each question, we extract its name (the domain to resolve)
    ❷, its class, and its type; convert them into strings (via Apple’s dns_class_string);
    and save them into a dictionary object. Finally, we save the dictionary of extracted
    details for each question to an array ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you perform a query via nslookup, for example, to *objective-see.org*,
    the DNS monitor code will capture the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll handle DNS responses (called *answers*).
  prefs: []
  type: TYPE_NORMAL
- en: Parsing DNS Responses
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A DNS monitor that leverages the NEDNSProxyProvider class is essentially a proxy,
    proxying both local requests and remote responses. This means that we must read
    the DNS request of the local flow, and then open a remote and send the request
    to its destination. To access any response, we read data from the remote endpoint
    using the nw_connection_receive API. [Listing 7-7](chapter7.xhtml#Lis7-7) invokes
    this API on the remote endpoint, then invokes the dns_parse_packet within its
    callback block to parse the response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-7: Receiving and parsing DNS responses'
  prefs: []
  type: TYPE_NORMAL
- en: Although we could just print out the response using the dns_print_reply function,
    let’s instead extract the answers. You’ll notice that this code, shown in [Listing
    7-8](chapter7.xhtml#Lis7-8), is similar to the snippet that extracted the questions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-8: Extracting members of interest from a parsed DNS response'
  prefs: []
  type: TYPE_NORMAL
- en: Here, however, we access the ancount ❶ and answer members ❷ and then must add
    additional logic to extract the response’s contents. For example, we examine its
    type ❸ and, if it’s an IPv4 address (ns_t_a) ❹, convert it via the inet_ntoa function
    ❺.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run Objective-See’s DNSMonitor, which contains this code and has received
    the appropriate entitlement and notarization, we can see that it will capture
    the answer to our previous *objective-see.org* lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The packet type is a reply containing the original question and the answers.
    We also learn that the domain *objective-see.org* maps to multiple IP addresses.
    When run against actual malware, this information can be incred- ibly useful.
    Take the aforementioned iWebUpdater as an example. When it connects to *iwebservicescloud.com*,
    it generates a DNS request and reply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The DNS monitoring code is able to detect both the resolution request and reply.
    Passing either of these into an external threat intelligence platform such as
    VirusTotal should reveal that the domain has a history of resolving to IP addresses
    associated with malicious activity (including the specific IP address it resolved
    to here).
  prefs: []
  type: TYPE_NORMAL
- en: The astute reader may have noticed that the output also identified iWebUpdater
    as the process responsible for making this request. Let’s see how to do this now.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the Responsible Process
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Identifying the process responsible for a DNS request is essential to detecting
    malware, yet DNS monitors that aren’t host-based can’t provide this information.
    For example, requests from trusted system processes are likely safe, while requests
    from, say, a persistent, unnotarized process such as iWebUpdate should be closely
    scrutinized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I’ll show you how to obtain the ID of the responsible process using information
    provided by the *NetworkExtension* framework. The flow object passed into the
    extension via the handleNewFlow: delegate method contains an instance variable
    named metaData whose type is NEFlowMetaData. Consulting the *NEFlowMetaData.h*
    file (found in *NetworkExtension.framework/Versions/A/Headers/*) reveals that
    it contains a property named sourceAppAuditToken with the responsible process’s
    audit token.'
  prefs: []
  type: TYPE_NORMAL
- en: From this audit token, we can extract the responsible process’s ID and securely
    obtain its path using SecCode* APIs. [Listing 7-9](chapter7.xhtml#Lis7-9) implements
    this technique.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-9: Obtaining the responsible process’s ID and path from a network
    flow'
  prefs: []
  type: TYPE_NORMAL
- en: First, we initialize a pointer to an audit token. As noted, the sourceAppAuditToken
    contains this token in the form of an NSData object. To get a pointer to the audit
    token’s actual bytes, we use the bytes property of the NSData class ❶. With this
    pointer, we can extract the associated process ID via the audit_token_to_pid function
    ❷. Next, we obtain a code reference from the audit token ❸ and then invoke the
    SecCodeCopyPath function to obtain the process’s path ❹.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that the SecCodeCopyGuestWithAttributes API can fail, for
    example, if the process has self-deleted. This case is both very unusual and likely
    indicative of a malicious process. Regardless, you’ll have to defer to other,
    less certain methods of obtaining the process’s path, such as examining the process’s
    arguments, which can be surreptitiously modified.
  prefs: []
  type: TYPE_NORMAL
- en: From the flow, we can also extract the responsible process’s code signing identifier,
    which can help classify the process as either benign or something to investigate
    further. This identifier is in the flow’s sourceAppSigningIdentifier attribute.
    [Listing 7-10](chapter7.xhtml#Lis7-10) extracts it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-10: Extracting code signing information from a network flow'
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted earlier in this chapter, the DNS monitoring process I’ve described
    thus far would fail to detect malware such as Dummy, which connects directly to
    an IP address. To detect such threats, let’s expand our monitoring capabilities
    to examine all network traffic.  ### Filter Data Providers'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most powerful network monitoring capabilities afforded by macOS are
    *filter data providers*. Implemented within a system extension and built atop
    the *NetworkExtension* framework, these network extensions can observe and filter
    all network traffic. You could use them to actively block malicious network traffic
    or else to passively observe all network flows, then identify potentially suspicious
    processes to investigate further.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, when Apple introduced filter data providers along with the other
    network extensions, it initially decided to exempt traffic generated by various
    system components from filtering, even though this traffic had previously been
    routed through the now-deprecated network kernel extensions. This meant that security
    tools such as network monitors and firewalls that had previously observed all
    network traffic now remained blind to some of it. Unsurprisingly, abusing the
    exempted system components was easy and provided a stealthy way to bypass any
    third-party security tool built atop Apple’s network extensions. After I demonstrated
    this bypass, the media jumped on the story,^([12](#chapter7-12)) and public outcry
    encouraged Apple to reevaluate its approach. Ultimately, wiser minds in Cupertino
    prevailed; today, all network traffic on macOS is routed through any installed
    filter data provider.^([13](#chapter7-13))
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*As with the DNS monitor, the filter data provider network extension we’ll
    implement here must meet the prerequisites discussed in “Using the NetworkExtension
    Framework” on [page 159](chapter7.xhtml#pg_159).*'
  prefs: []
  type: TYPE_NORMAL
- en: The code in this section largely comes from Objective-See’s popular open source
    firewall, LuLu, written by yours truly. You can find LuLu’s complete code in its
    GitHub repository, [*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/LuLu*](https://github.com/objective-see/LuLu).
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Filtering
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start by programmatically activating a network extension that implements
    a filter data provider. This process deviates slightly from the activation of
    a network extension that implements DNS monitoring; instead of using an NEDNSProxyManager
    object, we’ll leverage an NEFilterManager object.
  prefs: []
  type: TYPE_NORMAL
- en: In the main application, use the process covered in “Activating a System Extension”
    on [page 160](chapter7.xhtml#pg_160) to activate the extension, then enable filtering
    as shown in [Listing 7-11](chapter7.xhtml#Lis7-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-11: Enabling filtering with an NEFilterManager object'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we access the NEFilterManager shared manager object and invoke its loadFromPreferencesWithCompletionHandler:
    method ❶. Once this completes, we initialize an NEFilterProviderConfiguration
    object ❷. We then set two configuration options ❸. As we’re not interested in
    filtering packets, we set this option to NO. On the other hand, we want to filter
    socket activity, so we set this to YES. The code then saves this configuration
    and sets the NEFilterManager shared manager object to enabled ❹. Finally, to trigger
    the network extension activation with this configuration, the code invokes the
    shared manager’s saveToPreferencesWithCompletionHandler: method ❺. Once this process
    completes, the filter data provider should be running.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Extension
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with the DNS monitor, the filter data provider is a separate binary that
    you must package in a bundle’s *Contents/Library/SystemExtensions/* directory.
    Once loaded, it should invoke NEProvider’s startSystemExtensionMode: method. In
    the extension’s *Info.plist* file, we add a dictionary referenced by the key NEProviderClasses
    containing a single key-value pair ([Listing 7-12](chapter7.xhtml#Lis7-12)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-12: The extension’s Info.plist file, which specifies the extension’s
    NEProviderClasses class'
  prefs: []
  type: TYPE_NORMAL
- en: We set the key to com.apple.networkextension.filter-data and the value to the
    name of our class in the extension that inherits from NEFilterDataProvider. In
    this example, we’ve named the class FilterDataProvider, which we declare as such
    ([Listing 7-13](chapter7.xhtml#Lis7-13)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-13: An interface definition for the FilterDataProvider class'
  prefs: []
  type: TYPE_NORMAL
- en: Once the filter data provider extension is up and running, the *NetworkExtension*
    framework will automatically invoke this class’s startFilterWithCompletionHandler
    method, where you’ll specify what traffic you’d like to filter. The code in [Listing
    7-14](chapter7.xhtml#Lis7-14) filters all protocols but only for outgoing traffic,
    which is more helpful than incoming traffic for detecting unauthorized or new
    programs that could be malware.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-14: Setting filter rules to specify which traffic should be routed
    through the extension'
  prefs: []
  type: TYPE_NORMAL
- en: First, the code creates an NENetworkRule object, setting the protocol filter
    option to any and the direction filter option to outbound ❶. Then it uses this
    NENetworkRule object to create an NEFilterRule object. It also specifies an action
    of NEFilterActionFilterData to tell the *NetworkExtension* framework that we want
    to filter data ❷. Next, it creates an NEFilterSettings object with the filter
    rule we just created that matches all outbound traffic. Specifying NEFilterActionAllow
    for the default action means any traffic that doesn’t match this filter rule will
    be allowed ❸. Finally, it applies the settings to begin the filtration ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, anytime a program on the system initiates a new outbound network connection,
    the system automatically invokes the handleNewFlow: delegate method in our filter
    class. Though it shares the same name, this delegate method differs from the one
    we used for DNS monitoring in a few ways. It takes a single argument (an NEFilterFlow
    object that contains information about the flow) and, upon returning, must instruct
    the system on how to handle the flow. It does so via an NEFilterNewFlowVerdict
    object, which can specify verdicts such as allow (allowVerdict), drop (dropVerdict),
    or pause (pauseVerdict). Because we’re focusing on tying a flow to its responsible
    process, we’ll always allow the flow ([Listing 7-15](chapter7.xhtml#Lis7-15)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-15: Returning a verdict from the handleNewFlow: method'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were building a firewall, we would instead consult the firewall’s rules
    or alert the user before allowing or blocking each flow.  #### Querying the Flow'
  prefs: []
  type: TYPE_NORMAL
- en: 'By querying the flow, we can extract information such as its remote end-point
    and the process responsible for generating it. First, let’s just print out the
    flow object. For example, here is a flow generated by curl when attempting to
    connect to *objective-see.org*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Besides information about the responsible process, such as its app ID, we can
    see details about the destination, including both an endpoint and a hostname.
    The flow object also contains information about the type of flow, including its
    protocol and socket family.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s extract more granular information. Recall that when configuring the
    filter, we told the system we were interested only in filtering sockets. As such,
    the flow passed into the handleNewFlow: method will be an NEFilterSocketFlow object,
    which is a subclass of the NEFilterFlow class. These objects have an instance
    variable called remoteEndpoint containing an object of type NWEndpoint, which
    itself contains information about the flow’s destination. You can extract the
    IP address of the remote endpoint via the NEFilterSocketFlow object’s hostname
    instance variable and retrieve its port from the port variable, both of which
    are stored as strings ([Listing 7-16](chapter7.xhtml#Lis7-16)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-16: Extracting the remote endpoint’s address and port'
  prefs: []
  type: TYPE_NORMAL
- en: These NEFilterSocketFlow objects also contain low-level information about the
    flow, including the socket family, type, and protocol. [Table 7-1](chapter7.xhtml#tab7-1)
    summarizes these, but you can learn more about them in Apple’s *NEFilterFlow.h*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7-1: Low-Level Flow Information in NEFilterSocketFlow Objects'
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable name | Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| socketType | int | Socket type, such as SOCK_STREAM |'
  prefs: []
  type: TYPE_TB
- en: '| socketFamily | int | Socket family, such as AF_INET |'
  prefs: []
  type: TYPE_TB
- en: '| socketProtocol | int | Socket protocol, such as IPPROTO_TCP |'
  prefs: []
  type: TYPE_TB
- en: From the remoteEndpoint and the socket instance variables, you can extract information
    to be fed into network-based heuristics. For example, you might craft a heuristic
    that flags any network traffic bound to nonstandard ports.
  prefs: []
  type: TYPE_NORMAL
- en: To identify the responsible process, NEFilterFlow objects have the sourceAppIdentifier
    and sourceAppAuditToken properties. We’ll focus on the latter, as it can provide
    us with both a process ID and process path. [Listing 7-17](chapter7.xhtml#Lis7-17)
    performs this extraction by following the same approach we took in the DNS monitor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-17: Identifying the responsible process from a flow'
  prefs: []
  type: TYPE_NORMAL
- en: We extract the audit token from the flow and then call the audit_token_to_pid
    function to obtain the responsible process’s ID. We also use the audit token to
    obtain a code reference, then call SecCodeCopyPath to retrieve the process’s path.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Monitor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we compile this code as part of a project that implements a complete, properly
    entitled network extension, we can globally observe all outbound network flows
    in real time and then extract information about each flow’s remote endpoint and
    responsible process. Yes, this means now we can easily detect basic malware such
    as Dummy, but let’s test the tool against a relevant specimen of macOS malware,
    SentinelSneak.
  prefs: []
  type: TYPE_NORMAL
- en: 'Detected at the end of 2022, this malicious Python package targeted developers
    with the goal of exfiltrating sensitive data.^([14](#chapter7-14)) It used a hardcoded
    IP address for its command-and-control server. From its unobfuscated Python code,
    we can see that curl uploaded information from an infected system to an exfiltration
    server found at 54.254.189.27:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This means the DNS monitor we wrote earlier in this chapter wouldn’t detect
    its unauthorized network access. But the filter data provider should capture and
    display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it was able to capture the flow, extract the remote endpoint
    (54.254.189.27:443), and correctly identify the responsible process as curl.
  prefs: []
  type: TYPE_NORMAL
- en: 'This responsible process makes detection more complex, as curl is a legitimate
    macOS platform binary and not an untrusted component of the malware. What might
    we do? Well, using methods covered in [Chapter 1](chapter1.xhtml), we could extract
    the arguments with which the malware has executed curl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: These arguments should raise some red flags, because although legitimate software
    often uses curl to download files, it’s rarely used to upload them, especially
    to a hardcoded IP address. Moreover, the -k argument tells curl to run in insecure
    mode, meaning the server’s SSL certificate won’t be verified. Again, this is a
    red flag, as legitimate software leveraging curl wouldn’t normally run in this
    insecure mode.
  prefs: []
  type: TYPE_NORMAL
- en: You could also determine that the process’s parent is a Python script and collect
    the script for manual analysis, which would quickly reveal its malicious nature.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter focused on the concepts necessary for building real-time, host-based
    network monitoring tools by leveraging Apple’s powerful *NetworkExtension* framework.
    Because the vast majority of Mac malware incorporates networking capabilities,
    the techniques described in this chapter are essential for any malware detection
    system. Unauthorized network activity serves as a critical indicator for many
    security tools and heuristic-based detection approaches, providing an invaluable
    way to detect both known and unknown threats targeting macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[  1](#chapter7_1).  “Smooth Operator,” GCHQ, June 29, 2023, [*https://<wbr>www<wbr>.ncsc<wbr>.gov<wbr>.uk<wbr>/static<wbr>-assets<wbr>/documents<wbr>/malware<wbr>-analysis<wbr>-reports<wbr>/smooth<wbr>-operator<wbr>/NCSC<wbr>_MAR<wbr>-Smooth<wbr>-Operator<wbr>.pdf*](https://www.ncsc.gov.uk/static-assets/documents/malware-analysis-reports/smooth-operator/NCSC_MAR-Smooth-Operator.pdf).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  2](#chapter7_2).  Patrick Wardle, “Where There Is Love, There Is . . . Malware?”
    Objective-See, February 24, 2023, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x72<wbr>.html*](https://objective-see.org/blog/blog_0x72.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  3](#chapter7_3).  “Crowdstrike Endpoint Security Detection re 3CX Desktop
    App,” 3CX forums, March 29, 2023, [*https://<wbr>www<wbr>.3cx<wbr>.com<wbr>/community<wbr>/threads<wbr>/crowdstrike<wbr>-endpoint<wbr>-security<wbr>-detection<wbr>-re<wbr>-3cx<wbr>-desktop<wbr>-app<wbr>.119934<wbr>/*](https://www.3cx.com/community/threads/crowdstrike-endpoint-security-detection-re-3cx-desktop-app.119934/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  4](#chapter7_4).  For details on system extensions, see Will Yu, “Mac System
    Extensions for Threat Detection: Part 3,” *Elastic*, February 19, 2020, [*https://<wbr>www<wbr>.elastic<wbr>.co<wbr>/blog<wbr>/mac<wbr>-system<wbr>-extensions<wbr>-for<wbr>-threat<wbr>-detection<wbr>-part<wbr>-3*](https://www.elastic.co/blog/mac-system-extensions-for-threat-detection-part-3).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  5](#chapter7_5).  “Network Extension,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/networkextension<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/networkextension?language=objc).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  6](#chapter7_6).  “Installing System Extensions and Drivers,” Apple Developer
    Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/systemextensions<wbr>/installing<wbr>-system<wbr>-extensions<wbr>-and<wbr>-drivers<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/systemextensions/installing-system-extensions-and-drivers?language=objc).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  7](#chapter7_7).  See also [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/products<wbr>/utilities<wbr>.html#DNSMonitor*](https://objective-see.org/products/utilities.html#DNSMonitor).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  8](#chapter7_8).  “activationRequestForExtension:queue:,” Apple Developer
    Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/systemextensions<wbr>/ossystemextensionrequest<wbr>/activationrequest(forextensionwithidentifier:queue:)<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/systemextensions/ossystemextensionrequest/activationrequest(forextensionwithidentifier:queue:)?language=objc).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  9](#chapter7_9).  “OSSystemExtensionRequestDelegate,” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/systemextensions<wbr>/ossystemextensionrequestdelegate<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/systemextensions/ossystemextensionrequestdelegate?language=objc).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[10](#chapter7_10).  “startSystemExtensionMode,” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/networkextension<wbr>/neprovider<wbr>/3197862<wbr>-startsystemextensionmode<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/networkextension/neprovider/3197862-startsystemextensionmode?language=objc).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[11](#chapter7_11).  “NEDNSProxyProvider,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/networkextension<wbr>/nednsproxyprovider<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/networkextension/nednsproxyprovider?language=objc).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[12](#chapter7_12).  Dan Goodin, “Apple Lets Some Big Sur Network Traffic Bypass
    Firewalls,” Arstechnica, November 17, 2020, [*https://<wbr>arstechnica<wbr>.com<wbr>/gadgets<wbr>/2020<wbr>/11<wbr>/apple<wbr>-lets<wbr>-some<wbr>-big<wbr>-sur<wbr>-network<wbr>-traffic<wbr>-bypass<wbr>-firewalls<wbr>/*](https://arstechnica.com/gadgets/2020/11/apple-lets-some-big-sur-network-traffic-bypass-firewalls/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13](#chapter7_13).  Filipe Espósito, “macOS Big Sur 11.2 beta 2 Removes Filter
    That Lets Apple Apps Bypass Third-Party Firewalls,” 9to5Mac, January 13, 2021,
    [*https://<wbr>9to5mac<wbr>.com<wbr>/2021<wbr>/01<wbr>/13<wbr>/macos<wbr>-big<wbr>-sur<wbr>-11<wbr>-2<wbr>-beta<wbr>-2<wbr>-removes<wbr>-filter<wbr>-that<wbr>-lets<wbr>-apple<wbr>-apps<wbr>-bypass<wbr>-third<wbr>-party<wbr>-firewalls<wbr>/*](https://9to5mac.com/2021/01/13/macos-big-sur-11-2-beta-2-removes-filter-that-lets-apple-apps-bypass-third-party-firewalls/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[14](#chapter7_14).  Patrick Wardle, “The Mac Malware of 2022,” Objective-See,
    January 1, 2023, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x71<wbr>.html*](https://objective-see.org/blog/blog_0x71.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
