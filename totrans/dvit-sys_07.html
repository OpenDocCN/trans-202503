<html><head></head><body>
<h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_293"/><span class="big">7</span><br/>64-BIT X86 ASSEMBLY (X86-64)</h2>&#13;
<div class="imagec"><img alt="image" src="../images/common.jpg"/></div>&#13;
<p class="noindents">In this chapter, we cover the Intel Architecture 64-bit (x86-64) instruction set architecture. Recall that an instruction set architecture (or ISA; see <a href="ch05.xhtml#ch05">Chapter 5</a>) defines the set of instructions and binary encodings of a machine-level program. To run the examples in this chapter, you will need access to a machine with a 64-bit x86 processor. The term “x86” is often used synonymously with the IA-32 architecture. The 64-bit extension of this architecture is referred to as x86-64 (or x64) and is ubiquitous in modern computers. Both IA32 and x86-64 belong to the x86 architecture family.</p>&#13;
<p class="indent">To check to see if you have a 64-bit Intel processor on your Linux machine, run the <code>uname -p</code> command. If you have an x86-64 system, you should see output like the following:</p>&#13;
<pre>$ <span class="codestrong1">uname -p</span><br/>&#13;
x86_64</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_294"/>Since x86-64 is an extension of the smaller IA32 ISA, some readers may prefer a discussion of IA32. To read more about IA32, see <a href="ch08.xhtml#ch08">Chapter 8</a>.</p>&#13;
<div class="g-box">&#13;
<p class="box-title">X86 SYNTAX BRANCHES</p>&#13;
<p class="noindentt">x86 architectures typically follow one of two different syntax branches. Unix machines commonly use the AT&amp;T syntax, given that Unix was developed at AT&amp;T Bell Labs. The corresponding assembler is GNU Assembler (GAS). Since we use GCC for most examples in this book, we cover AT&amp;T syntax in this chapter. Windows machines commonly use Intel syntax, which is used by Microsoft’s Macro Assembler (MASM). The Netwide Assembler (NASM) is an example of a Linux assembler that uses Intel syntax. The argument regarding the superiority of one syntax over the other is one of the “holy wars” of the discipline. However, there is value in being familiar with both syntaxes, as a programmer may encounter either in various circumstances.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_51">7.1 Diving into Assembly: Basics</h3>&#13;
<p class="noindent">For a first look at x64 assembly, we modify the <code>adder</code> function from <a href="ch06.xhtml#ch06">Chapter 6</a> to simplify its behavior. The modified function (<code>adder2</code>) is shown here:</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
//adds two to an integer and returns the result<br/>&#13;
int adder2(int a) {<br/>&#13;
    return a + 2;<br/>&#13;
}<br/>&#13;
<br/>&#13;
int main(){<br/>&#13;
    int x = 40;<br/>&#13;
    x = adder2(x);<br/>&#13;
    printf("x is: %d\n", x);<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="indent">To compile this code, use the following command:</p>&#13;
<pre>$ <span class="codestrong1">gcc -o adder adder.c</span></pre>&#13;
<p class="indent">Next, let’s view the corresponding assembly of this code by using the <code>objdump</code> command:</p>&#13;
<pre>$ <span class="codestrong1">objdump -d adder &gt; output</span><br/>&#13;
$ <span class="codestrong1">less output</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_295"/>Search for the code snippet associated with <code>adder2</code> by typing <span class="codestrong">/adder2</span> while examining the file <code>output</code> using <span class="codestrong">less</span>. The section associated with <code>adder2</code> should look similar to the following:</p>&#13;
<pre>0000000000400526 &lt;adder2&gt;:<br/>&#13;
  400526:       55                      push   %rbp<br/>&#13;
  400527:       48 89 e5                mov    %rsp,%rbp<br/>&#13;
  40052a:       89 7d fc                mov    %edi,-0x4(%rbp)<br/>&#13;
  40052d:       8b 45 fc                mov    -0x4(%rbp),%eax<br/>&#13;
  400530:       83 c0 02                add    $0x2,%eax<br/>&#13;
  400533:       5d                      pop    %rbp<br/>&#13;
  400534:       c3                      retq</pre>&#13;
<p class="indent">Don’t worry if you don’t understand what’s going on just yet. We will cover assembly in greater detail in later sections. For now, let’s study the structure of these individual instructions.</p>&#13;
<p class="indent">Each line in the preceding example contains an instruction’s 64-bit address in program memory, the bytes corresponding to the instruction, and the plaintext representation of the instruction itself. For example, <code>55</code> is the machine code representation of the instruction <code>push %rbp</code>, and the instruction occurs at address <code>0x400526</code> in program memory. Note that <code>0x400526</code> is an abbreviation of the full 64-bit address associated with the <code>push %rbp</code> instruction; the leading zeros are ignored for readability.</p>&#13;
<p class="indent">It is important to note that a single line of C code often translates to multiple instructions in assembly. The operation <code>a + 2</code> is represented by the two instructions <code>mov -0x4(%rbp),%eax</code> and <code>add $0x2,%eax</code>.</p>&#13;
<p class="note"><strong><span class="black">Warning</span> YOUR ASSEMBLY MAY LOOK DIFFERENT!</strong></p>&#13;
<p class="note-w">If you are compiling your code along with us, you may notice that some of your assembly examples look different from what is shown in this book. The precise assembly instructions that are output by any compiler depend on that compiler’s version and the underlying operating system. Most of the assembly examples in this book were generated on systems running Ubuntu or Red Hat Enterprise Linux (RHEL).</p>&#13;
<p class="note-w">In the examples that follow, we do not use any optimization flags. For example, we compile any example file (<code>example.c</code>) using the command <code>gcc -o example example.c</code>. Consequently, there are many seemingly redundant instructions in the examples that follow. Remember that the compiler is not “smart”—it simply follows a series of rules to translate human-readable code into machine language. During this translation process, it is not uncommon for some redundancy to occur. Optimizing compilers remove many of these redundancies during optimization, which is covered in <a href="ch12.xhtml#ch12">Chapter 12</a>.</p>&#13;
<h4 class="h4" id="lev2_114"><span epub:type="pagebreak" id="page_296"/>7.1.1 Registers</h4>&#13;
<p class="noindent">Recall that a <em>register</em> is a word-sized storage unit located directly on the CPU. There may be separate registers for data, instructions, and addresses. For example, the Intel CPU has a total of 16 registers for storing 64-bit data: <code>%rax</code>, <code>%rbx</code>, <code>%rcx</code>, <code>%rdx</code>, <code>%rdi</code>, <code>%rsi</code>, <code>%rsp</code>, <code>%rbp</code>, and <code>%r8</code>–<code>%r15</code>. All the registers save for <code>%rsp</code> and <code>%rbp</code> hold general-purpose 64-bit data. While a program may interpret a register’s contents as, say, an integer or an address, the register itself makes no distinction. Programs can read from or write to all 16 registers.</p>&#13;
<p class="indent">The registers <code>%rsp</code> and <code>%rbp</code> are known as the <em>stack pointer</em> and the <em>frame pointer</em> (or <em>base pointer</em>), respectively. The compiler reserves these registers for operations that maintain the layout of the program stack. For example, register <code>%rsp</code> always points to the top of the stack. In earlier x86 systems (e.g., IA32), the frame pointer commonly tracked the base of the active stack frame and helped to reference parameters. However, the base pointer is less frequently used in x86-64 systems. Compilers typically store the first six parameters in registers <code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, and <code>%r9</code>, respectively. Register <code>%rax</code> stores the return value from a function.</p>&#13;
<p class="indent">The last register worth mentioning is <code>%rip</code> or the <em>instruction pointer</em>, sometimes called the <em>program counter</em> (PC). It points to the next instruction to be executed by the CPU. Unlike the 16 registers mentioned previously, programs cannot write directly to register <code>%rip</code>.</p>&#13;
<h4 class="h4" id="lev2_115">7.1.2 Advanced Register Notation</h4>&#13;
<p class="noindent">Since x86-64 is an extension of the 32-bit x86 architecture (which itself was an extension of an earlier 16-bit version), the ISA provides mechanisms to access the lower 32 bits, 16 bits, and lower bytes of each register. <a href="ch07.xhtml#ch7tab1">Table 7-1</a> lists each of the 16 registers and the ISA notations to access their component bytes.</p>&#13;
<p class="tabcap" id="ch7tab1"><strong>Table 7-1:</strong> x86-64 Registers and Mechanisms for Accessing Lower Bytes</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab-c"><strong>64-bit Register</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><strong>32-bit Register</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><strong>Lower 16 Bits</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><strong>Lower 8 Bits</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%rax</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%eax</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%ax</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%al</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%rbx</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%ebx</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%bx</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%bl</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%rcx</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%ecx</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%cx</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%cl</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%rdx</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%edx</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%dx</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%dl</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%rdi</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%edi</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%di</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%dil</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%rsi</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%esi</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%si</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%sil</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%rsp</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%esp</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%sp</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%spl</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%rbp</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%ebp</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%bp</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%bpl</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r8</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r8d</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r8w</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r8b</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r9</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r9d</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r9w</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r9b</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r10</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r10d</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r10w</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r10b</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r11</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r11d</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r11w</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r11b</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r12</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r12d</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r12w</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r12b</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r13</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r13d</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r13w</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r13b</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r14</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r14d</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r14w</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r14b</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r15</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r15d</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r15w</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><code>%r15b</code></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_297"/>The first eight registers (<code>%rax</code>, <code>%rbx</code>, <code>%rcx</code>, <code>%rdx</code>, <code>%rdi</code>, <code>%rsi</code>, <code>%rsp</code>, and <code>%rbp</code>) are 64-bit extensions of 32-bit registers in x86 and have a common mechanism for accessing their lower 32 bits, lower 16 bits, and least-significant byte. To access the lower 32 bits of the first eight registers, simply replace the <code>r</code> in the register name with <code>e</code>. Thus, the register corresponding to the lower 32 bits of register <code>%rax</code> is register <code>%eax</code>. To access the lower 16 bits of each of these eight registers, reference the last two letters of the register’s name. So, the mechanism to access the lower two bytes of register <code>%rax</code> is <code>%ax</code>.</p>&#13;
<div class="imagec" id="ch7fig1"><img alt="image" src="../images/07fig01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-1: The names that refer to subsets of register <code>%rax</code></em></p>&#13;
<p class="indent">The ISA provides a separate mechanism to access the eight-bit components within the lower 16 bits of the first four listed registers. <a href="ch07.xhtml#ch7fig1">Figure 7-1</a> depicts the access mechanisms for register <code>%rax</code>. The <em>higher</em> and <em>lower</em> bytes within the lower 16 bits of the first four listed registers can be accessed by taking the last two letters of the register name and replacing the last letter with either an <code>h</code> (for <em>higher</em>) or an <code>l</code> (for <em>lower</em>) depending on which byte is desired. For example, <code>%al</code> references the lower eight bits of register <code>%ax</code>, whereas <code>%ah</code> references the higher eight bits of register <code>%ax</code>. These eight-bit registers are commonly used for storing single-byte values for certain operations such as bitwise shifts (a 32-bit register cannot be shifted more than 32 places, and the number 32 requires only a single byte of storage).</p>&#13;
<p class="note"><strong><span class="black">Warning</span> WARNING: COMPILER MAY CHOOSE COMPONENT REGISTERS DEPENDING ON TYPE</strong></p>&#13;
<p class="note-w">When reading assembly code, keep in mind that the compiler typically uses the 64-bit registers when dealing with 64-bit values (e.g., pointers or <code>long</code> types), and the 32-bit component registers when dealing with 32-bit types (e.g., <code>int</code>). In x86-64, it is very common to see 32-bit component registers intermixed with the full 64-bit registers. For example, in the <code>adder2</code> function shown earlier, the compiler references component register <code>%eax</code> instead of <code>%rax</code> since <code>int</code> types typically take up 32 bits (four bytes) of space on 64-bit systems. If the <code>adder2</code> function had a <code>long</code> parameter instead of <code>int</code>, the compiler would store <code>a</code> in register <code>%rax</code> instead of register <code>%eax</code>.</p>&#13;
<p class="indent">The last eight registers (<code>%r8</code>–<code>%r15</code>) were not part of the IA32 ISA. However, they also have mechanisms to access their different byte components. To access the lower 32 bits, 16 bits, or byte of the last eight registers, append the letter <code>d</code>, <code>w</code>, or <code>b</code>, respectively, to the end of the register’s name. Thus, <code>%r9d</code> <span epub:type="pagebreak" id="page_298"/>accesses the lower 32 bits of register <code>%r9</code>, whereas <code>%r9w</code> accesses the lower 16 bits, and <code>%r9b</code> accesses the lowest byte of register <code>%r9</code>.</p>&#13;
<h4 class="h4" id="lev2_116">7.1.3 Instruction Structure</h4>&#13;
<p class="noindent">Each instruction consists of an operation code (or <em>opcode</em>) that specifies what it does, and one or more <em>operands</em> that tell the instruction how to do it. For example, the instruction <code>add $0x2,%eax</code> has the opcode <code>add</code> and the operands <code>$0x2</code> and <code>%eax</code>.</p>&#13;
<p class="indent">Each operand corresponds to a source or destination location for a specific operation. Two operand instructions typically follow the source, destination (<code>S</code>, <code>D</code>) format, where the first operand specifies a source register, and the second operand specifies the destination.</p>&#13;
<p class="indent">There are multiple types of operands:</p>&#13;
<ul>&#13;
<li class="noindent"><em>Constant</em> (<em>literal</em>) values are preceded by the <code>$</code> sign. For example, in the instruction <code>add $0x2,%eax</code>, <code>$0x2</code> is a literal value that corresponds to the hexadecimal value 0x2.</li>&#13;
<li class="noindent"><em>Register</em> forms refer to individual registers. Thus, the instruction <code>mov %rsp,%rbp</code> specifies that the value in the source register (<code>%rsp</code>) should be copied to the destination location (register <code>%rbp</code>).</li>&#13;
<li class="noindent"><em>Memory</em> forms correspond to some value inside main memory (RAM) and are commonly used for address lookups. Memory address forms can contain a combination of registers and constant values. For example, in the instruction <code>mov -0x4(%rbp),%eax</code>, the operand <code>-0x4(%rbp)</code> is an example of a memory form. It loosely translates to “add –0x4 to the value in register <code>%rbp</code> (i.e., subtract 0x4 from <code>%rbp</code>), and then perform a memory lookup.” If this sounds like a pointer dereference, that’s because it is!</li>&#13;
</ul>&#13;
<h4 class="h4" id="lev2_117">7.1.4 An Example with Operands</h4>&#13;
<p class="noindent">The best way to explain operands in detail is to present a quick example. Suppose that memory contains the following values:</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Address</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Value</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0x804</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0xCA</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0x808</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0xFD</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0x80c</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x12</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0x810</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x1E</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Let’s also assume that the following registers contain the values shown:</p>&#13;
<span epub:type="pagebreak" id="page_299"/>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Register</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Value</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>%rax</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x804</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>%rbx</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x10</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>%rcx</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>%rdx</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x1</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Then the operands in <a href="ch07.xhtml#ch7tab2">Table 7-2</a> evaluate to the values shown there. Each row of the table matches an operand with its form (e.g., constant, register, memory), how it is translated, and its value. Note that the notation M[x] in this context denotes the value at the memory location specified by address x.</p>&#13;
<p class="tabcap" id="ch7tab2"><strong>Table 7-2:</strong> Example Operands</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Operand</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Form</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Value</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>%rcx</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Register</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>%rcx</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>(%rax)</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">M[<code>%rax</code>] or M[0x804]</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0xCA</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>$0x808</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Constant</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x808</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x808</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>0x808</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">M[0x808]</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0xFD</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>0x8(%rax)</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">M[<code>%rax</code> + 8] or M[0x80c]</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x12</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>(%rax, %rcx)</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">M[<code>%rax</code> + <code>%rcx</code>] or M[0x808]</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0xFD</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>0x4(%rax, %rcx)</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">M[<code>%rax</code> + <code>%rcx</code> + 4] or M[0x80c]</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x12</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>0x800(,%rdx,4)</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">M[0x800 + <code>%rdx</code>×4] or M[0x804]</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0xCA</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>(%rax, %rdx, 8)</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Memory</p></td>&#13;
<td style="vertical-align: top"><p class="tab">M[<code>%rax</code> + <code>%rdx</code>×8] or M[0x80c]</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x12</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">In <a href="ch07.xhtml#ch7tab2">Table 7-2</a>, the notation <code>%rcx</code> indicates the value stored in register <code>%rcx</code>. In contrast, M[<code>%rax</code>] indicates that the value inside <code>%rax</code> should be treated as an address, and to dereference (look up) the value at that address. Therefore, the operand <code>(%rax)</code> corresponds to M[0x804], which corresponds to the value 0xCA.</p>&#13;
<p class="indent">A few important notes before continuing. Although <a href="ch07.xhtml#ch7tab2">Table 7-2</a> shows many valid operand forms, not all forms can be used interchangeably in all circumstances. Specifically:</p>&#13;
<ul>&#13;
<li class="noindent">Constant forms cannot serve as destination operands.</li>&#13;
<li class="noindent">Memory forms cannot serve as <em>both</em> the source and destination operand in a single instruction.</li>&#13;
<li class="noindent">In cases of scaling operations (refer back to the last two operands in <a href="ch07.xhtml#ch7tab2">Table 7-2</a>), the scaling factor is a third parameter in the parentheses. Scaling factors can be one of 1, 2, 4, or 8.</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch07.xhtml#ch7tab2">Table 7-2</a> is provided as a reference; however, understanding key operand forms will help improve the reader’s speed in parsing assembly language.</p>&#13;
<h4 class="h4" id="lev2_118"><span epub:type="pagebreak" id="page_300"/>7.1.5 Instruction Suffixes</h4>&#13;
<p class="noindent">In several cases in upcoming examples, common and arithmetic instructions have a suffix that indicates the <em>size</em> (associated with the <em>type</em>) of the data being operated on at the code level. The compiler automatically translates code to instructions with the appropriate suffix. <a href="ch07.xhtml#ch7tab3">Table 7-3</a> shows the common suffixes for x86-64 instructions.</p>&#13;
<p class="tabcap" id="ch7tab3"><strong>Table 7-3:</strong> Example Instruction Suffixes</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:60%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab-c"><strong>Suffix</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>C Type</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><strong>Size (Bytes)</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c">b</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>char</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c">w</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>short</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c">l</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>int</code> or <code>unsigned</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c">s</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>float</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c">q</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>long</code>, <code>unsigned long</code>, all pointers</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">8</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c">d</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>double</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">8</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Note that instructions involved with conditional execution have different suffixes based on the evaluated condition. We cover instructions associated with conditional execution in “Conditional Control and Loops” on <a href="ch07.xhtml#lev1_54">page 310</a>.</p>&#13;
<h3 class="h3" id="lev1_52">7.2 Common Instructions</h3>&#13;
<p class="noindent">In this section, we discuss several common assembly instructions. <a href="ch07.xhtml#ch7tab4">Table 7-4</a> lists the most foundational instructions in x86 (and thus x64) assembly.</p>&#13;
<p class="tabcap" id="ch7tab4"><strong>Table 7-4:</strong> Most Common Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>mov S,D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">S → D</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(copies value of S into D)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>add S,D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">S + D → D</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(adds S to D and stores result in D)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>sub S,D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D – S → D</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(subtracts S <em>from</em> D and stores result in D)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Therefore, the sequence of instructions</p>&#13;
<pre>mov    -0x4(%rbp),%eax<br/>&#13;
add    $0x2,%eax</pre>&#13;
<p class="noindent">translates to:</p>&#13;
<ul>&#13;
<li class="noindent">Copy the value at location <code>%rbp</code> + –0x4 in <em>memory</em> (or M[<code>%rbp</code>– 0x4]) to register <code>%eax</code>.</li>&#13;
<li class="noindent">Add the value 0x2 to register <code>%eax</code>, and store the result in register <code>%eax</code>.</li>&#13;
</ul>&#13;
<p class="indent">The three instructions shown in <a href="ch07.xhtml#ch7tab4">Table 7-4</a> also form the building blocks for instructions that maintain the organization of the program stack (i.e., <span epub:type="pagebreak" id="page_301"/>the <em>call stack</em>). Recall that registers <code>%rbp</code> and <code>%rsp</code> refer to the <em>frame</em> pointer and <em>stack</em> pointer, respectively, and are reserved by the compiler for call stack management. Recall from our earlier discussion on program memory in “Parts of Program Memory and Scope” on <a href="ch02.xhtml#lev1_9">page 64</a> that the call stack typically stores local variables and parameters and helps the program track its own execution (see <a href="ch07.xhtml#ch7fig2">Figure 7-2</a>). On x86-64 systems, the execution stack grows toward <em>lower</em> addresses. Like all stack data structures, operations occur at the “top” of the stack.</p>&#13;
<div class="imagec" id="ch7fig2"><img alt="image" src="../images/07fig02.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-2: The parts of a program’s address space</em></p>&#13;
<p class="indent">The x86-64 ISA provides two instructions (<a href="ch07.xhtml#ch7tab5">Table 7-5</a>) to simplify call stack management.</p>&#13;
<p class="tabcap" id="ch7tab5"><strong>Table 7-5:</strong> Stack Management Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>push S</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Pushes a copy of S onto the top of the stack. Equivalent to:</p>&#13;
<p class="tab"><code>sub $0x8,%rsp</code></p>&#13;
<p class="tab"><code>mov S,(%rsp)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>pop D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Pops the top element off the stack and places it in location D.</p>&#13;
<p class="tab">Equivalent to:</p>&#13;
<p class="tab"><code>mov (%rsp),D</code></p>&#13;
<p class="tab"><code>add $0x8,%rsp</code></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Notice that although the three instructions in <a href="ch07.xhtml#ch7tab4">Table 7-4</a> require two operands, the <code>push</code> and <code>pop</code> instructions in <a href="ch07.xhtml#ch7tab5">Table 7-5</a> require only one operand each.</p>&#13;
<h4 class="h4" id="lev2_119"><span epub:type="pagebreak" id="page_302"/>7.2.1 Putting It All Together: A More Concrete Example</h4>&#13;
<p class="noindent">Let’s take a closer look at the <code>adder2</code> function</p>&#13;
<pre>//adds two to an integer and returns the result<br/>&#13;
int adder2(int a) {<br/>&#13;
    return a + 2;<br/>&#13;
}</pre>&#13;
<p class="noindent">and its corresponding assembly code:</p>&#13;
<pre>0000000000400526 &lt;adder2&gt;:<br/>&#13;
  400526:       55                      push   %rbp<br/>&#13;
  400527:       48 89 e5                mov    %rsp,%rbp<br/>&#13;
  40052a:       89 7d fc                mov    %edi,-0x4(%rbp)<br/>&#13;
  40052d:       8b 45 fc                mov    -0x4(%rbp),%eax<br/>&#13;
  400530:       83 c0 02                add    $0x2,%eax<br/>&#13;
  400533:       5d                      pop    %rbp<br/>&#13;
  400534:       c3                      retq</pre>&#13;
<p class="indent">The assembly code consists of a <code>push</code> instruction, followed by three <code>mov</code> instructions, an <code>add</code> instruction, a <code>pop</code> instruction, and finally a <code>retq</code> instruction. To understand how the CPU executes this set of instructions, we need to revisit the structure of program memory (see “Parts of Program Memory and Scope” on <a href="ch02.xhtml#lev1_9">page 64</a>). Recall that every time a program executes, the operating system allocates the new program’s address space (also known as <em>virtual memory</em>). Virtual memory and the related concept of processes are covered in greater detail in <a href="ch13.xhtml#ch13">Chapter 13</a>; for now, it suffices to think of a process as the abstraction of a running program and virtual memory as the memory that is allocated to a single process. Every process has its own region of memory called the <em>call stack</em>. Keep in mind that the call stack is located in process/virtual memory, unlike registers (which are located on the CPU).</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch7fig3">Figure 7-3</a> depicts a sample state of the call stack and registers prior to the execution of the <code>adder2</code> function.</p>&#13;
<span epub:type="pagebreak" id="page_303"/>&#13;
<div class="imagec" id="ch7fig3"><img alt="image" src="../images/07fig03.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-3: Execution stack prior to execution</em></p>&#13;
<p class="indent">Notice that the stack grows toward <em>lower</em> addresses. Register <code>%eax</code> contains a junk value. The single parameter to the <code>adder2</code> function (<code>a</code>) is stored in register <code>%rdi</code> by convention. Since <code>a</code> is of type <code>int</code>, it is stored in component register <code>%edi</code>, which is shown in <a href="ch07.xhtml#ch7fig3">Figure 7-3</a>. Likewise, because the <code>adder2</code> function returns an <code>int</code>, component register <code>%eax</code> is used for the return value instead of <code>%rax</code>.</p>&#13;
<p class="indent">The addresses associated with the instructions in the code segment of program memory (0x400526–0x400534) have been shortened to 0x526–0x534 to improve figure readability. Likewise, the addresses associated with the call stack segment of program memory have been shortened to 0xd28–0xd1c from 0x7fffffffdd28–0x7fffffffdd1c. In truth, call stack addresses occur at much higher addresses in program memory than code segment addresses.</p>&#13;
<p class="indent">Pay close attention to the initial values of registers <code>%rsp</code> and <code>%rbp</code>: they are 0xd28 and 0xd40, respectively. The upper-left arrow in the following figures visually indicates the currently executing instruction. The <code>%rip</code> register (or instruction pointer) shows the next instruction to execute. Initially, <code>%rip</code> contains address 0x526, which corresponds to the first instruction in the <code>adder2</code> function.</p>&#13;
<span epub:type="pagebreak" id="page_304"/>&#13;
<div class="imagec"><img alt="image" src="../images/f0304-01.jpg"/></div>&#13;
<p class="indent">The first instruction (<code>push %rbp</code>) places a copy of the value in <code>%rbp</code> (or 0xd40) on top of the stack. After it executes, the <code>%rip</code> register advances to the address of the next instruction to execute (0x527). The <code>push</code> instruction decrements the stack pointer by 8 (“growing” the stack by 8 bytes), resulting in a new <code>%rsp</code> value of 0xd20. Recall that the <code>push %rbp</code> instruction is equivalent to:</p>&#13;
<pre>sub $8, %rsp<br/>&#13;
mov %rbp, (%rsp)</pre>&#13;
<p class="indent">In other words, subtract 8 from the stack pointer and place a copy of the contents of <code>%rbp</code> in the location pointed to by the dereferenced stack pointer, <code>(%rsp)</code>.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0304-02.jpg"/></div>&#13;
<p class="indent">Recall that the structure of the <code>mov</code> instruction is <code>mov S,D</code>, where S is the source location, and D is the destination. Thus, the next instruction (<code>mov</code> <span epub:type="pagebreak" id="page_305"/><code>%rsp,%rbp</code>) updates the value of <code>%rbp</code> to 0xd20. The register <code>%rip</code> advances to the address of the next instruction to execute, or 0x52a.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0305-01.jpg"/></div>&#13;
<p class="indent">Next, <code>mov %edi,-0x4(%rbp)</code> is executed. This is a bit more complicated than the last <code>mov</code> instruction. Let’s parse it piece by piece. First, recall that the first parameter to any function is stored in register <code>%rdi</code>. Since <code>a</code> is of type <code>int</code>, the compiler stores the first parameter in component register <code>%edi</code>. Next, the operand <code>-0x4(%rbp)</code> translates to M[<code>%rbp</code> – 0x4]. Since <code>%rbp</code> contains the value 0xd20, subtracting 4 from it yields 0xd1c. Therefore, the <code>mov</code> instruction copies the value of register <code>%edi</code> (or 0x28) to location 0xd1c on the stack. The instruction pointer advances to address 0x52d, the next address to be executed.</p>&#13;
<p class="indent">Note that storing the value 0x28 does not affect the stack pointer (<code>%rsp</code>). Therefore, as far as the program is concerned, the “top” of this stack is still address 0xd20.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0305-02.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_306"/>The next <code>mov</code> instruction (<code>mov -0x4(%rbp),%eax</code>) copies the value at stack location 0xd1c (i.e., M[<code>%rbp</code> – 0x4] or 0x28) and stores it in register <code>%eax</code>. Register <code>%rip</code> advances to the next instruction to be executed, or 0x530.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0306-01.jpg"/></div>&#13;
<p class="indent">Next, <code>add $0x2,%eax</code> is executed. Recall that the <code>add</code> instruction has the form <code>add S,D</code> and places the quantity S + D in the destination D. So, <code>add $0x2,</code> <code>%eax</code> adds the constant value 0x2 to the value stored in <code>%eax</code> (or 0x28), resulting in the value 0x2A being stored in register <code>%eax</code>. Register <code>%rip</code> advances to point to the next instruction to be executed, or 0x533.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0306-02.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_307"/>The next instruction that executes is <code>pop %rbp</code>. This instruction “pops” the value off the top of the call stack and places it in destination register <code>%rbp</code>. Recall that this instruction is equivalent to the following sequence of two instructions:</p>&#13;
<pre>mov (%rsp), %rbp<br/>&#13;
add $8, %rsp</pre>&#13;
<p class="indent">Recall that the top of the stack is 0xd20, since that is the value stored in <code>%rsp</code>. Therefore, as soon as this instruction executes, the value <code>(%rsp)</code> (i.e., M[0xd20]) is copied into register <code>%rbp</code>. Thus, <code>%rbp</code> now contains the value 0xd40. The stack pointer <em>increments</em> by 8, since the stack grows toward lower addresses (and consequently <em>shrinks</em> toward higher ones). The new value of <code>%rsp</code> is 0xd28, and <code>%rip</code> now points to the address of the last instruction to execute (i.e., 0x534).</p>&#13;
<p class="indent">The last instruction executed is <code>retq</code>. We will talk more about what happens with <code>retq</code> in future sections when we discuss function calls, but for now it suffices to know that it prepares the call stack for returning from a function. By convention, the register <code>%rax</code> always contains the return value (if one exists). In this case, because <code>adder2</code> is of type <code>int</code>, the return value is stored in component register <code>%eax</code>, and the function returns the value 0x2A, or 42.</p>&#13;
<p class="indent">Before we continue, note that the final values in registers <code>%rsp</code> and <code>%rbp</code> are 0xd28 and 0xd40, respectively, which are the <em>same values as when the function started executing</em>! This is normal and expected behavior with the call stack. The purpose of the call stack is to store the temporary variables and data of each function as it executes in the context of a program. When a function completes executing, the stack returns to the state it was in prior to the function call. As a result, it is common to see the following two instructions at the beginning of a function</p>&#13;
<pre>push %rbp<br/>&#13;
mov %rsp, %rbp</pre>&#13;
<p class="noindent">and the following two instructions at the end of a function:</p>&#13;
<pre>pop %rbp<br/>&#13;
retq</pre>&#13;
<h3 class="h3" id="lev1_53">7.3 Arithmetic Instructions</h3>&#13;
<p class="noindent">The x86 ISA implements several instructions that correspond to arithmetic operations performed by the ALU. <a href="ch07.xhtml#ch7tab6">Table 7-6</a> lists several arithmetic instructions that one may encounter when reading assembly.</p>&#13;
<p class="tabcap" id="ch7tab6"><span epub:type="pagebreak" id="page_308"/><strong>Table 7-6:</strong> Common Arithmetic Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>add S,D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">S + D → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>sub S,D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D – S → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>inc D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D + 1 → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>dec D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D – 1 → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>neg D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">–D → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>imul S,D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">S × D → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>idiv S</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>%rax</code> / S: quotient → <code>%rax</code>, remainder → <code>%rdx</code></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">The <code>add</code> and <code>sub</code> instructions correspond to addition and subtraction and take two operands each. The next three entries show the single-register instructions for the increment (<code>x++</code>), decrement (<code>x--</code>), and negation (<code>-x</code>) operations in C. The multiplication instruction operates on two operands and places the product in the destination. If the product requires more than 64 bits to represent, the value is truncated to 64 bits.</p>&#13;
<p class="indent">The division instruction works a little differently. Prior to the execution of the <code>idiv</code> instruction, it is assumed that register <code>%rax</code> contains the dividend. Calling <code>idiv</code> on operand S divides the contents of <code>%rax</code> by S and places the quotient in register <code>%rax</code> and the remainder in register <code>%rdx</code>.</p>&#13;
<h4 class="h4" id="lev2_120">7.3.1 Bit Shifting Instructions</h4>&#13;
<p class="noindent">Bit shifting instructions enable the compiler to perform bit shifting operations. Multiplication and division instructions typically take a long time to execute. Bit shifting offers the compiler a shortcut for multiplicands and divisors that are powers of 2. For example, to compute <code>77 * 4</code>, most compilers will translate this operation to <code>77 &lt;&lt; 2</code> to avoid the use of an <code>imul</code> instruction. Likewise, to compute <code>77 / 4</code>, a compiler typically translates this operation to <code>77 &gt;&gt; 2</code> to avoid using the <code>idiv</code> instruction.</p>&#13;
<p class="indent">Keep in mind that left and right bit shift translate to different instructions based on whether the goal is an arithmetic (signed) or logical (unsigned) shift.</p>&#13;
<p class="tabcap" id="ch7tab7"><strong>Table 7-7:</strong> Bit Shift Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Arithmetic or Logical?</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>sal v,D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D <code>≪</code> v → D</p></td>&#13;
<td style="vertical-align: top"><p class="tab">arithmetic</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>shl v,D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D <code>≪</code> v → D</p></td>&#13;
<td style="vertical-align: top"><p class="tab">logical</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>sar v,D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D <code>≫</code> v → D</p></td>&#13;
<td style="vertical-align: top"><p class="tab">arithmetic</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>shr v,D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">D <code>≫</code> v → D</p></td>&#13;
<td style="vertical-align: top"><p class="tab">logical</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_309"/>Each shift instruction takes two operands, one which is usually a register (denoted by D) and the other which is a shift value (<em>v</em>). On 64-bit systems, the shift value is encoded as a single byte (since it doesn’t make sense to shift past 63). The shift value <em>v</em> must either be a constant or stored in register <code>%cl</code>.</p>&#13;
<p class="note"><strong><span class="black">Note</span> DIFFERENT VERSIONS OF INSTRUCTIONS HELP DISTINGUISH TYPES AT AN ASSEMBLY LEVEL</strong></p>&#13;
<p class="note1">At the assembly level, there is no notion of types. However, recall that the compiler will use component registers based on types. Similarly, recall that shift right works differently depending on whether the value is signed or unsigned. At the assembly level, the compiler uses separate instructions to distinguish between logical and arithmetic shifts!</p>&#13;
<h4 class="h4" id="lev2_121">7.3.2 Bitwise Instructions</h4>&#13;
<p class="noindent">Bitwise instructions enable the compiler to perform bitwise operations on data. One way the compiler uses bitwise operations is for certain optimizations. For example, a compiler may choose to implement 77 mod 4 with the operation <code>77 &amp;</code> <code>3</code> in lieu of the more expensive <code>idiv</code> instruction.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch7tab8">Table 7-8</a> lists common bitwise instructions.</p>&#13;
<p class="tabcap" id="ch7tab8"><strong>Table 7-8:</strong> Bitwise Operations</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>and S,D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">S <code>&amp;</code> D → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>or S,D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">S <code>|</code> D → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>xor S,D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">S <code>^</code> D → D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>not D</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>~</code>D → D</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Remember that bitwise <code>not</code> is distinct from negation (<code>neg</code>). The <code>not</code> instruction flips the bits, but does not add 1. Be careful not to confuse these two instructions.</p>&#13;
<p class="note"><strong><span class="black">Warning</span> USE BITWISE OPERATIONS ONLY WHEN NEEDED IN YOUR C CODE!</strong></p>&#13;
<p class="note-w">After reading this section, it may be tempting to replace common arithmetic operations in your C code with bitwise shifts and other operations. This is <em>not</em> recommended. Most modern compilers are smart enough to replace simple arithmetic operations with bitwise operations when it makes sense, making it unnecessary for the programmer to do so. As a general rule, programmers should prioritize code readability whenever possible and avoid premature optimization.</p>&#13;
<h4 class="h4" id="lev2_122"><span epub:type="pagebreak" id="page_310"/>7.3.3 The Load Effective Address Instruction</h4>&#13;
<p class="right"><em>What’s lea got to do (got to do) with it?</em></p>&#13;
<p class="right"><em>What’s lea, but an effective address loading?</em></p>&#13;
<p class="right">—With apologies to Tina Turner</p>&#13;
<p class="indenta">We finally come to the <em>load effective address</em> or <code>lea</code> instruction, which is probably the arithmetic instruction that causes students the most consternation. It is traditionally used as a fast way to compute the address of a location in memory. The <code>lea</code> instruction operates on the same operand structure that we’ve seen thus far but does <em>not</em> include a memory lookup. Regardless of the type of data contained in the operand (whether it be a constant value or an address), <code>lea</code> simply performs arithmetic.</p>&#13;
<p class="indent">For example, suppose that register <code>%rax</code> contains the constant value 0x5, register <code>%rdx</code> contains the constant value 0x4, and register <code>%rcx</code> contains the value 0x808 (which happens to be an address). <a href="ch07.xhtml#ch7tab9">Table 7-9</a> depicts some example <code>lea</code> operations, their translations, and corresponding values.</p>&#13;
<p class="tabcap" id="ch7tab9"><strong>Table 7-9:</strong> Example lea Operations</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Value</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>lea 8(%rax), %rax</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">8 + <code>%rax</code> → <code>%rax</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">13 → <code>%rax</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>lea (%rax, %rdx), %rax</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>%rax</code> + <code>%rdx</code> → <code>%rax</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">9 → <code>%rax</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>lea (,%rax,4), %rax</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>%rax</code> × 4 → <code>%rax</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">20 → <code>%rax</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>lea -0x8(%rcx), %rax</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>%rcx</code> – 8 → <code>%rax</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x800 → <code>%rax</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>lea -0x4(%rcx, %rdx, 2), %rax</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>%rcx</code> + <code>%rdx</code> × 2 – 4 → <code>%rax</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">0x80c → <code>%rax</code></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">In all cases, the <code>lea</code> instruction performs arithmetic on the operand specified by the source S and places the result in the destination operand D. The <code>mov</code> instruction is identical to the <code>lea</code> instruction <em>except</em> that the <code>mov</code> instruction is <em>required</em> to treat the contents in the source operand as a memory location if it is in a memory form. In contrast, <code>lea</code> performs the same (sometimes complicated) operand arithmetic <em>without</em> the memory lookup, enabling the compiler to cleverly use <code>lea</code> as a substitution for some types of arithmetic.</p>&#13;
<h3 class="h3" id="lev1_54">7.4 Conditional Control and Loops</h3>&#13;
<p class="noindent">This section covers x86 assembly instructions for conditionals and loops (see “Conditionals and Loops” on <a href="ch01.xhtml#lev1_3">page 30</a>). Recall that conditional statements enable coders to modify program execution based on the result of a conditional expression. The compiler translates conditionals into assembly instructions that modify the instruction pointer (<code>%rip</code>) to point to an address that is not the next one in the program sequence.</p>&#13;
<h4 class="h4" id="lev2_123"><span epub:type="pagebreak" id="page_311"/>7.4.1 Preliminaries</h4>&#13;
<h5 class="h5" id="lev3_54">Conditional Comparison Instructions</h5>&#13;
<p class="noindent">Comparison instructions perform an arithmetic operation for the purpose of guiding the conditional execution of a program. <a href="ch07.xhtml#ch7tab10">Table 7-10</a> lists the basic instructions associated with conditional control.</p>&#13;
<p class="tabcap" id="ch7tab10"><strong>Table 7-10:</strong> Conditional Control Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>cmp R1, R2</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Compares R1 with R2 (i.e., evaluates R2 – R1)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>test R1, R2</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Computes R1 <code>&amp;</code> R2</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">The <code>cmp</code> instruction compares the values of two registers, R2 and R1. Specifically, it subtracts R1 from R2. The <code>test</code> instruction performs bitwise AND. It is common to see an instruction like:</p>&#13;
<pre>test %rax, %rax</pre>&#13;
<p class="indent">In this example, the bitwise AND of <code>%rax</code> with itself is zero only when <code>%rax</code> contains zero. In other words, this is a test for a zero value and is equivalent to:</p>&#13;
<pre>cmp $0, %rax</pre>&#13;
<p class="indent">Unlike the arithmetic instructions covered thus far, <code>cmp</code> and <code>test</code> do not modify the destination register. Instead, both instructions modify a series of single-bit values known as <em>condition code flags</em>. For example, <code>cmp</code> will modify condition code flags based on whether the value R2 – R1 results in a positive (greater), negative (less), or zero (equal) value. Recall that condition code values encode information about an operation in the ALU (see “The ALU” on <a href="ch05.xhtml#lev2_100">page 261</a>). The condition code flags are part of the <code>FLAGS</code> register on x86 systems.</p>&#13;
<p class="tabcap" id="ch7tab11"><strong>Table 7-11:</strong> Common Condition Code Flags</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Flag</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>ZF</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Is equal to zero (1: yes; 0: no)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>SF</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Is negative (1: yes; 0: no)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>OF</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Overflow has occurred (1: yes; 0: no)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>CF</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Arithmetic carry has occurred (1: yes; 0: no)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent"><a href="ch07.xhtml#ch7tab11">Table 7-11</a> depicts the common flags used for condition code operations. Revisiting the <code>cmp R1, R2</code> instruction:</p>&#13;
<ul>&#13;
<li class="noindent">The <code>ZF</code> flag is set to 1 if R1 and R2 are equal.</li>&#13;
<li class="noindent">The <code>SF</code> flag is set to 1 if R2 is <em>less</em> than R1 (R2 – R1 results in a negative value).</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_312"/>The <code>OF</code> flag is set to 1 if the operation R2 – R1 results in an integer overflow (useful for signed comparisons).</li>&#13;
<li class="noindent">The <code>CF</code> flag is set to 1 if the operation R2 – R1 results in a carry operation (useful for unsigned comparisons).</li>&#13;
</ul>&#13;
<p class="indent">The <code>SF</code> and <code>OF</code> flags are used for comparison operations on signed integers, whereas the <code>CF</code> flag is used for comparisons on unsigned integers. Although an in-depth discussion of condition code flags is beyond the scope of this book, the setting of these registers by <code>cmp</code> and <code>test</code> enables the next set of instructions we cover (the <em>jump</em> instructions) to operate correctly.</p>&#13;
<h5 class="h5" id="lev3_55">Jump Instructions</h5>&#13;
<p class="noindent">A jump instruction enables a program’s execution to “jump” to a new position in the code. In the assembly programs we have traced through thus far, <code>%rip</code> always points to the next instruction in program memory. The jump instructions enable <code>%rip</code> to be set to either a new instruction not yet seen (as in the case of an <code>if</code> statement) or to a previously executed instruction (as in the case of a loop).</p>&#13;
<p class="tabcap" id="ch7tab12"><strong>Table 7-12:</strong> Direct Jump Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>jmp L</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Jump to location specified by L</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>jmp *addr</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Jump to specified address</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="noindentt"><strong>Direct jump instructions.</strong>   <a href="ch07.xhtml#ch7tab12">Table 7-12</a> lists the set of direct jump instructions; <code>L</code> refers to a <em>symbolic label</em>, which serves as an identifier in the program’s object file. All labels consist of some letters and digits followed by a colon. Labels can be <em>local</em> or <em>global</em> to an object file’s scope. Function labels tend to be <em>global</em> and usually consist of the function name and a colon. For example, <code>main:</code> (or <code>&lt;main&gt;:</code>) is used to label a user-defined <code>main</code> function. In contrast, labels whose scope are <em>local</em> are preceded by a period. For example, <code>.L1:</code> is a local label one may encounter in the context of an <code>if</code> statement or loop.</p>&#13;
<p class="indent">All labels have an associated address. When the CPU executes a <code>jmp</code> instruction, it modifies <code>%rip</code> to reflect the program address specified by label <code>L</code>. A programmer writing assembly can also specify a particular address to jump to using the <code>jmp *</code> instruction. Sometimes, local labels are shown as an offset from the start of a function. Therefore, an instruction whose address is 28 bytes away from the start of <code>main</code> may be represented with the label <code>&lt;main+28&gt;</code>.</p>&#13;
<p class="indent">For example, the instruction <code>jmp 0x8048427 &lt;main+28&gt;</code> indicates a jump to address 0x8048427, which has the associated label <code>&lt;main+28&gt;</code>, representing that it is 28 bytes away from the starting address of the <code>main</code> function. Executing this instruction sets <code>%rip</code> to 0x8048427.</p>&#13;
<p class="noindentt"><span epub:type="pagebreak" id="page_313"/><strong>Conditional jump instructions.</strong>    The behavior of conditional jump instructions depends on the condition code registers set by the <code>cmp</code> instruction. <a href="ch07.xhtml#ch7tab13">Table 7-13</a> lists the set of common conditional jump instructions. Each instruction starts with the letter <code>j</code> denoting that it is a jump instruction. The suffix of each instruction indicates the <em>condition</em> for the jump. The jump instruction suffixes also determine whether to interpret numerical comparisons as signed or unsigned.</p>&#13;
<p class="tabcap" id="ch7tab13"><strong>Table 7-13:</strong> Conditional Jump Instructions; Synonyms Shown in Parentheses</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Signed Comparison</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Unsigned Comparison</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>je</code> (<code>jz</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">jump if equal (==) or jump if zero</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>jne</code> (<code>jnz</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">jump if not equal (!=)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>js</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">jump if negative</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>jns</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">jump if non-negative</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>jg</code> (<code>jnle</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>ja</code> (<code>jnbe</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">jump if greater (&gt;)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>jge</code> (<code>jnl</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>jae</code> (<code>jnb</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">jump if greater than or equal (&gt;=)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>jl</code> (<code>jnge</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>jb</code> (<code>jnae</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">jump if less (&lt;)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>jle</code> (<code>jng</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>jbe</code> (<code>jna</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">jump if less than or equal (&lt;=)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Instead of memorizing these different conditional jump instructions, it is more helpful to sound out the instruction suffixes. <a href="ch07.xhtml#ch7tab14">Table 7-14</a> lists the letters commonly found in jump instructions and their word correspondence.</p>&#13;
<p class="tabcap" id="ch7tab14"><strong>Table 7-14:</strong> Jump Instruction Suffixes</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Letter</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Word</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>j</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">jump</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>n</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">not</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>e</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">equal</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>s</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">signed</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>g</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">greater (signed interpretation)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>l</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">less (signed interpretation)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>a</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">above (unsigned interpretation)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>b</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">below (unsigned interpretation)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Sounding it out, we can see that <code>jg</code> corresponds to <em>jump greater</em> and that its signed synonym <code>jnl</code> stands for <em>jump not less</em>. Likewise, the unsigned version <code>ja</code> stands for <em>jump above</em>, whereas its synonym <code>jnbe</code> stands for <em>jump not below or equal</em>.</p>&#13;
<p class="indent">If you sound out the instructions, it helps to explain why certain synonyms correspond to particular instructions. The other thing to remember is that the terms <em>greater</em> and <em>less</em> instruct the CPU to interpret the numerical comparison as a signed value, whereas <em>above</em> and <em>below</em> indicate that the numerical comparison is unsigned.</p>&#13;
<h5 class="h5" id="lev3_56"><span epub:type="pagebreak" id="page_314"/>The goto statement</h5>&#13;
<p class="noindent">In the following subsections, we look at conditionals and loops in assembly and reverse engineer them back to C. When translating assembly code of conditionals and loops back into C, it is useful to understand the corresponding C language <code>goto</code> forms. The <code>goto</code> statement is a C primitive that forces program execution to switch to another line in the code. The assembly instruction associated with the <code>goto</code> statement is <code>jmp</code>.</p>&#13;
<p class="indent">The <code>goto</code> statement consists of the <code>goto</code> keyword followed by a <em>goto label</em>, a type of program label that indicates where execution should continue. So, <code>goto done</code> means that the program execution should jump to the line marked by label <code>done</code>. Other examples of program labels in C include the <code>switch</code> statement labels previously covered in “switch Statements” on <a href="ch02.xhtml#lev2_36">page 122</a>.</p>&#13;
<p class="indent">The following code listings depict a function <code>getSmallest</code> written in regular C code (first) and its associated <code>goto</code> form in C (second). The <code>getSmallest</code> function compares the values of two integers (<code>x</code> and <code>y</code>), and assigns the smaller value to the variable <code>smallest</code>.</p>&#13;
<p class="margnote">Regular C version</p>&#13;
<pre>int getSmallest(int x, int y) {<br/>&#13;
    int smallest;<br/>&#13;
    if ( x &gt; y ) { //if (conditional)<br/>&#13;
        smallest = y; //then statement<br/>&#13;
    }<br/>&#13;
    else {<br/>&#13;
        smallest = x; //else statement<br/>&#13;
    }<br/>&#13;
    return smallest;<br/>&#13;
}</pre>&#13;
<p class="margnote">goto version</p>&#13;
<pre>int getSmallest(int x, int y) {<br/>&#13;
    int smallest;<br/>&#13;
<br/>&#13;
    if (x &lt;= y ) { //if (!conditional)<br/>&#13;
        goto else_statement;<br/>&#13;
    }<br/>&#13;
    smallest = y; //then statement<br/>&#13;
    goto done;<br/>&#13;
<br/>&#13;
else_statement:<br/>&#13;
    smallest = x; //else statement<br/>&#13;
<br/>&#13;
done:<br/>&#13;
    return smallest;<br/>&#13;
}</pre>&#13;
<p class="indent">The <code>goto</code> form of this function may seem counterintuitive, but let’s discuss what exactly is going on. The conditional checks to see whether variable <code>x</code> is less than or equal to <code>y</code>.</p>&#13;
<ul>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_315"/>If <code>x</code> is less than or equal to <code>y</code>, the program transfers control to the label marked by <code>else_statement</code>, which contains the single statement <code>smallest = x</code>. Since the program executes linearly, the program continues on to execute the code under the label <code>done</code>, which returns the value of <code>smallest</code> (<code>x</code>).</li>&#13;
<li class="noindent">If <code>x</code> is greater than <code>y</code>, <code>smallest</code> is assigned the value <code>y</code>. The program then executes the statement <code>goto done</code>, which transfers control to the <code>done</code> label, which returns the value of <code>smallest</code> (<code>y</code>).</li>&#13;
</ul>&#13;
<p class="indent">While <code>goto</code> statements were commonly used in the early days of programming, the use of <code>goto</code> statements in modern code is considered bad practice, as it reduces the overall readability of code. In fact, computer scientist Edsger Dijkstra wrote a famous paper lambasting the use of <code>goto</code> statements called “Go To Statement Considered Harmful.”<sup><a href="ch07.xhtml#fn7_1" id="rfn7_1">1</a></sup></p>&#13;
<p class="indent">In general, well-designed C programs do not use <code>goto</code> statements, and programmers are discouraged from using them to avoid writing code that is difficult to read, debug, and maintain. However, the C <code>goto</code> statement is important to understand, as GCC typically changes C code with conditionals into a <code>goto</code> form prior to translating it to assembly, including code that contains <code>if</code> statements and loops.</p>&#13;
<h4 class="h4" id="lev2_124">7.4.2 if Statements in Assembly</h4>&#13;
<p class="noindent">Let’s take a look at the <code>getSmallest</code> function in assembly. For convenience, the function is reproduced here:</p>&#13;
<pre>int getSmallest(int x, int y) {<br/>&#13;
    int smallest;<br/>&#13;
    if ( x &gt; y ) {<br/>&#13;
        smallest = y;<br/>&#13;
    }<br/>&#13;
    else {<br/>&#13;
        smallest = x;<br/>&#13;
    }<br/>&#13;
    return smallest;<br/>&#13;
}</pre>&#13;
<p class="indent">The corresponding assembly code extracted from GDB looks similar to the following:</p>&#13;
<pre>(gdb) <span class="codestrong1">disas getSmallest</span><br/>&#13;
Dump of assembler code for function getSmallest:<br/>&#13;
   0x40059a &lt;+4&gt;:   mov    %edi,-0x14(%rbp)<br/>&#13;
   0x40059d &lt;+7&gt;:   mov    %esi,-0x18(%rbp)<br/>&#13;
   0x4005a0 &lt;+10&gt;:  mov    -0x14(%rbp),%eax<br/>&#13;
   0x4005a3 &lt;+13&gt;:  cmp    -0x18(%rbp),%eax<br/>&#13;
   0x4005a6 &lt;+16&gt;:  jle    0x4005b0 &lt;getSmallest+26&gt;<br/>&#13;
   0x4005a8 &lt;+18&gt;:  mov    -0x18(%rbp),%eax<br/>&#13;
   0x4005ae &lt;+24&gt;:  jmp    0x4005b9 &lt;getSmallest+35&gt;<br/>&#13;
<span epub:type="pagebreak" id="page_316"/>   0x4005b0 &lt;+26&gt;:  mov    -0x14(%rbp),%eax<br/>&#13;
   0x4005b9 &lt;+35&gt;:  pop    %rbp<br/>&#13;
   0x4005ba &lt;+36&gt;:  retq</pre>&#13;
<p class="indent">This is a different view of the assembly code than we have seen before. Here, we can see the <em>address</em> associated with each instruction, but not the <em>bytes</em>. Note that this assembly segment has been lightly edited for the sake of simplicity. The instructions that are normally part of function creation (i.e., <code>push %rbp</code>, <code>mov %rsp,%rbp</code>) are removed. By convention, GCC places the first and second parameters of a function in registers <code>%rdi</code> and <code>%rsi</code>, respectively. Since the parameters to <code>getSmallest</code> are of type <code>int</code>, the compiler places the parameters in the respective component registers <code>%edi</code> and <code>%esi</code> instead. For the sake of clarity, we refer to these parameters as <code>x</code> and <code>y</code>, respectively.</p>&#13;
<p class="indent">Let’s trace through the first few lines of the previous assembly code snippet. Note that we will not draw out the stack explicitly in this example. We leave this as an exercise for the reader and encourage you to practice your stack tracing skills by drawing it out yourself.</p>&#13;
<ul>&#13;
<li class="noindent">The first <code>mov</code> instruction copies the value located in register <code>%edi</code> (the first parameter, <code>x</code>) and places it at memory location <code>%rbp-0x14</code> on the call stack. The instruction pointer (<code>%rip</code>) is set to the address of the next instruction, or 0x40059d.</li>&#13;
<li class="noindent">The second <code>mov</code> instruction copies the value located in register <code>%esi</code> (the second parameter, <code>y</code>) and places it at memory location <code>%rbp-0x18</code> on the call stack. The instruction pointer (<code>%rip</code>) updates to point to the address of the next instruction, or 0x4005a0.</li>&#13;
<li class="noindent">The third <code>mov</code> instruction copies <code>x</code> to register <code>%eax</code>. Register <code>%rip</code> updates to point to the address of the next instruction in sequence.</li>&#13;
<li class="noindent">The <code>cmp</code> instruction compares the value at location <code>%rbp-0x18</code> (the second parameter, <code>y</code>) to <code>x</code> and sets appropriate condition code flag registers. Register <code>%rip</code> advances to the address of the next instruction, or 0x4005a6.</li>&#13;
<li class="noindent">The <code>jle</code> instruction at address 0x4005a6 indicates that if <code>x</code> is less than or equal to <code>y</code>, the next instruction that should execute should be at location <code>&lt;getSmallest+26&gt;</code> and that <code>%rip</code> should be set to address 0x4005b0. Otherwise, <code>%rip</code> is set to the next instruction in sequence, or 0x4005a8.</li>&#13;
</ul>&#13;
<p class="indent">The next instructions to execute depend on whether the program follows the branch (i.e., executes the jump) at address 0x4005a6. Let’s first suppose that the branch was <em>not</em> followed. In this case, <code>%rip</code> is set to 0x4005a8 (i.e., <code>&lt;getSmallest+18&gt;</code>) and the following sequence of instructions executes:</p>&#13;
<ul>&#13;
<li class="noindent">The <code>mov -0x18(%rbp), %eax</code> instruction at <code>&lt;getSmallest+18&gt;</code> copies <code>y</code> to register <code>%eax</code>. Register <code>%rip</code> advances to 0x4005ae.</li>&#13;
<li class="noindent">The <code>jmp</code> instruction at <code>&lt;getSmallest+24&gt;</code> sets register <code>%rip</code> to address 0x4005b9.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_317"/>The last instructions to execute are the <code>pop</code> <code>%rbp</code> instruction and the <code>retq</code> instruction, which cleans up the stack and returns from the function call. In this case, <code>y</code> is in the return register.</li>&#13;
</ul>&#13;
<p class="indent">Now, suppose that the branch was taken at <code>&lt;getSmallest+16&gt;</code>. In other words, the <code>jle</code> instruction sets register <code>%rip</code> to 0x4005b0 (i.e., <code>&lt;getSmallest+26&gt;</code>). Then, the next instructions to execute are:</p>&#13;
<ul>&#13;
<li class="noindent">The <code>mov -0x14(%rbp),%eax</code> instruction at address 0x4005b0 copies <code>x</code> to register <code>%eax</code>. Register <code>%rip</code> advances to 0x4005b9.</li>&#13;
<li class="noindent">The last instructions that execute are <code>pop %rbp</code> and <code>retq</code>, which cleans up the stack and returns the value in the return register. In this case, component register <code>%eax</code> contains <code>x</code>, and <code>getSmallest</code> returns <code>x</code>.</li>&#13;
</ul>&#13;
<p class="indent">We can then annotate the preceding assembly as follows:</p>&#13;
<pre>0x40059a &lt;+4&gt;:  mov %edi,-0x14(%rbp)          # copy x to %rbp-0x14<br/>&#13;
0x40059d &lt;+7&gt;:  mov %esi,-0x18(%rbp)          # copy y to %rbp-0x18<br/>&#13;
0x4005a0 &lt;+10&gt;: mov -0x14(%rbp),%eax          # copy x to %eax<br/>&#13;
0x4005a3 &lt;+13&gt;: cmp -0x18(%rbp),%eax          # compare x with y<br/>&#13;
0x4005a6 &lt;+16&gt;: jle 0x4005b0 &lt;getSmallest+26&gt; # if x&lt;=y goto &lt;getSmallest+26&gt;<br/>&#13;
0x4005a8 &lt;+18&gt;: mov -0x18(%rbp),%eax          # copy y to %eax<br/>&#13;
0x4005ae &lt;+24&gt;: jmp 0x4005b9 &lt;getSmallest+35&gt; # goto &lt;getSmallest+35&gt;<br/>&#13;
0x4005b0 &lt;+26&gt;: mov -0x14(%rbp),%eax          # copy x to %eax<br/>&#13;
0x4005b9 &lt;+35&gt;: pop %rbp                      # restore %rbp (clean up stack)<br/>&#13;
0x4005ba &lt;+36&gt;: retq                          # exit function (return %eax)</pre>&#13;
<p class="indent">Translating this back to C code yields:</p>&#13;
<p class="margnote">goto form</p>&#13;
<pre>int getSmallest(int x, int y) {<br/>&#13;
    int smallest;<br/>&#13;
    if (x &lt;= y) {<br/>&#13;
        goto assign_x;<br/>&#13;
    }<br/>&#13;
    smallest = y;<br/>&#13;
    goto done;<br/>&#13;
<br/>&#13;
assign_x:<br/>&#13;
    smallest = x;<br/>&#13;
<br/>&#13;
done:<br/>&#13;
    return smallest;<br/>&#13;
}</pre>&#13;
<p class="margnote">Translated C code</p>&#13;
<pre>int getSmallest(int x, int y) {<br/>&#13;
    int smallest;<br/>&#13;
    if (x &lt;= y) {<br/>&#13;
<span epub:type="pagebreak" id="page_318"/>&#13;
        smallest = x;<br/>&#13;
    }<br/>&#13;
    else {<br/>&#13;
        smallest = y;<br/>&#13;
    }<br/>&#13;
    return smallest;<br/>&#13;
}</pre>&#13;
<p class="indent">In these code listings, the variable <code>smallest</code> corresponds to register <code>%eax</code>. If <code>x</code> is less than or equal to <code>y</code>, the code executes the statement <code>smallest = x</code>, which is associated with the <code>goto</code> label <code>assign_x</code> in our <code>goto</code> form of this function. Otherwise, the statement <code>smallest = y</code> is executed. The <code>goto</code> label <code>done</code> is used to indicate that the value in <code>smallest</code> should be returned.</p>&#13;
<p class="indent">Notice that the preceding C translation of the assembly code is a bit different from the original <code>getSmallest</code> function. These differences don’t matter; close inspection of both functions reveals that the two programs are logically equivalent. However, the compiler first converts any <code>if</code> statement into an equivalent <code>goto</code> form, which results in the slightly different but equivalent version. The following code examples show the standard <code>if</code> statement format and its equivalent <code>goto</code> form:</p>&#13;
<p class="margnote">C if statement</p>&#13;
<pre>if (<span class="codeitalic1">&lt;condition&gt;</span>) {<br/>&#13;
    <span class="codeitalic1">&lt;then_statement&gt;</span>;<br/>&#13;
}<br/>&#13;
else {<br/>&#13;
    <span class="codeitalic1">&lt;else_statement&gt;</span>;<br/>&#13;
}</pre>&#13;
<p class="margnote">Compiler’s equivalent goto form</p>&#13;
<pre>    if (!<span class="codeitalic1">&lt;condition&gt;</span>) {<br/>&#13;
        goto else;<br/>&#13;
    }<br/>&#13;
    <span class="codeitalic1">&lt;then_statement&gt;</span>;<br/>&#13;
    goto done;<br/>&#13;
else:<br/>&#13;
    <span class="codeitalic1">&lt;else_statement&gt;</span>;<br/>&#13;
done:</pre>&#13;
<p class="indent">Compilers translating code into assembly designate a jump when a condition is true. Contrast this behavior with the structure of an <code>if</code> statement, where a “jump” (to the <code>else</code>) occurs when conditions are <em>not</em> true. The <code>goto</code> form captures this difference in logic.</p>&#13;
<p class="indent">Considering the original <code>goto</code> translation of the <code>getSmallest</code> function, we can see that:</p>&#13;
<ul>&#13;
<li class="noindent"><code>x &lt;= y</code> corresponds to <code>!<em>&lt;condition&gt;</em></code>.</li>&#13;
<li class="noindent"><code>smallest = x</code> is the <span class="literal"/> <span class="codeitalic">&lt;else_statement&gt;</span>.</li>&#13;
<li class="noindent">The line <code>smallest = y</code> is the <span class="literal"/> <span class="codeitalic">&lt;then_statement&gt;</span>.</li>&#13;
<li class="noindent">The last line in the function is <code>return smallest</code>.</li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_319"/>Rewriting the original version of the function with the preceding annotations yields:</p>&#13;
<pre>int getSmallest(int x, int y) {<br/>&#13;
    int smallest;<br/>&#13;
    if (x &gt; y) {     //!(x &lt;= y)<br/>&#13;
        smallest = y; //then_statement<br/>&#13;
    }<br/>&#13;
    else {<br/>&#13;
        smallest = x; //else_statement<br/>&#13;
    }<br/>&#13;
    return smallest;<br/>&#13;
}</pre>&#13;
<p class="indent">This version is identical to the original <code>getSmallest</code> function. Keep in mind that a function written in different ways at the C code level can translate to the same set of assembly instructions.</p>&#13;
<h5 class="h5" id="lev3_57">The cmov Instructions</h5>&#13;
<p class="noindent">The last set of conditional instructions we cover are <em>conditional move</em> (<code>cmov</code>) instructions. The <code>cmp</code>, <code>test</code>, and <code>jmp</code> instructions implement a <em>conditional transfer of control</em> in a program. In other words, the execution of the program branches in many directions. This can be very problematic for optimizing code because these branches are very expensive.</p>&#13;
<p class="indent">In contrast, the <code>cmov</code> instruction implements a <em>conditional transfer of data</em>. In other words, both the <span class="literal"/> <span class="codeitalic">&lt;then_statement&gt;</span> and <span class="literal"/> <span class="codeitalic">&lt;else_statement&gt;</span> of the conditional are executed, and the data is placed in the appropriate register based on the result of the condition.</p>&#13;
<p class="indent">The use of C’s <em>ternary expression</em> often results in the compiler generating a <code>cmov</code> instruction in place of jumps. For the standard if-then-else statement, the ternary expression has the form:</p>&#13;
<pre>result = (<span class="codeitalic1">&lt;condition&gt;</span>) ? <span class="codeitalic1">&lt;then_statement&gt;</span> : <span class="codeitalic1">&lt;else_statement&gt;</span>;</pre>&#13;
<p class="indent">Let’s use this format to rewrite the <code>getSmallest</code> function as a ternary expression. Keep in mind that this new version of the function behaves exactly as the original <code>getSmallest</code> function:</p>&#13;
<pre>int getSmallest_cmov(int x, int y) {<br/>&#13;
    return x &gt; y ? y : x;<br/>&#13;
}</pre>&#13;
<p class="indent">Although this may not seem like a big change, let’s look at the resulting assembly. Recall that the first and second parameters (<code>x</code> and <code>y</code>) are stored in registers <code>%edi</code> and <code>%esi</code>, respectively.</p>&#13;
<span epub:type="pagebreak" id="page_320"/>&#13;
<pre>0x4005d7 &lt;+0&gt;:   push   %rbp             #save %rbp<br/>&#13;
0x4005d8 &lt;+1&gt;:   mov    %rsp,%rbp        #update %rbp<br/>&#13;
0x4005db &lt;+4&gt;:   mov    %edi,-0x4(%rbp)  #copy x to %rbp-0x4<br/>&#13;
0x4005de &lt;+7&gt;:   mov    %esi,-0x8(%rbp)  #copy y to %rbp-0x8<br/>&#13;
0x4005e1 &lt;+10&gt;:  mov    -0x8(%rbp),%eax  #copy y to %eax<br/>&#13;
0x4005e4 &lt;+13&gt;:  cmp    %eax,-0x4(%rbp)  #compare x and y<br/>&#13;
0x4005e7 &lt;+16&gt;:  cmovle -0x4(%rbp),%eax  #if (x &lt;=y) copy x to %eax<br/>&#13;
0x4005eb &lt;+20&gt;:  pop    %rbp             #restore %rbp<br/>&#13;
0x4005ec &lt;+21&gt;:  retq                    #return %eax</pre>&#13;
<p class="indent">This assembly code has no jumps. After the comparison of <code>x</code> and <code>y</code>, <code>x</code> moves into the return register only if <code>x</code> is less than or equal to <code>y</code>. Like the jump instructions, the suffix of the <code>cmov</code> instructions indicates the condition on which the conditional move occurs. <a href="ch07.xhtml#ch7tab15">Table 7-15</a> lists the set of conditional move instructions.</p>&#13;
<p class="tabcap" id="ch7tab15"><strong>Table 7-15:</strong> The <code>cmov</code> Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Signed</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Unsigned</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>cmove</code> (<code>cmovz</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">move if equal (==)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>cmovne</code> (<code>cmovnz</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">move if not equal (!=)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>cmovs</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">move if negative</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>cmovns</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">move if non-negative</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>cmovg</code> (<code>cmovnle</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>cmova</code> (<code>cmovnbe</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">move if greater (&gt;)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>cmovge</code> (<code>cmovnl</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>cmovae</code> (<code>cmovnb</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">move if greater than or equal (&gt;=)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>cmovl</code> (<code>cmovnge</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>cmovb</code> (<code>cmovnae</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">move if less (&lt;)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>cmovle</code> (<code>cmovng</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>cmovbe</code> (<code>cmovna</code>)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">move if less than or equal (&lt;=)</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">In the case of the original <code>getSmallest</code> function, the compiler’s internal optimizer (see <a href="ch12.xhtml#ch12">Chapter 12</a>) will replace the jump instructions with a <code>cmov</code> instruction if level 1 optimizations are turned on (i.e., <code>-O1</code>):</p>&#13;
<pre>#compiled with: gcc -O1 -o getSmallest getSmallest.c<br/>&#13;
&lt;getSmallest&gt;:<br/>&#13;
   0x400546 &lt;+0&gt;: cmp    %esi,%edi      #compare x and y<br/>&#13;
   0x400548 &lt;+2&gt;: mov    %esi,%eax      #copy y to %eax<br/>&#13;
   0x40054a &lt;+4&gt;: cmovle %edi,%eax      #if (x&lt;=y) copy x to %eax<br/>&#13;
   0x40054d &lt;+7&gt;: retq                  #return %eax</pre>&#13;
<p class="indent">In general, the compiler is very cautious about optimizing jump instructions into <code>cmov</code> instructions, especially in cases where side effects and pointer values are involved. Here, we show two equivalent ways of writing a function, <code>incrementX</code>:</p>&#13;
<p class="margnote">C code</p>&#13;
<pre>int incrementX(int *x) {<br/>&#13;
    if (x != NULL) { //if x is not NULL<br/>&#13;
        return (*x)++; //increment x<br/>&#13;
    }<br/>&#13;
<span epub:type="pagebreak" id="page_321"/>    else { //if x is NULL<br/>&#13;
        return 1; //return 1<br/>&#13;
    }<br/>&#13;
}</pre>&#13;
<p class="margnote">C ternary form</p>&#13;
<pre>int incrementX2(int *x){<br/>&#13;
    return x ? (*x)++ : 1;<br/>&#13;
}</pre>&#13;
<p class="indent">Each function takes a pointer to an integer as input and checks whether it is <code>NULL</code>. If <code>x</code> is not <code>NULL</code>, the function increments and returns the dereferenced value of <code>x</code>. Otherwise, the function returns the value 1.</p>&#13;
<p class="indent">It is tempting to think that <code>incrementX2</code> uses a <code>cmov</code> instruction since it uses a ternary expression. However, both functions yield the exact same assembly code:</p>&#13;
<pre>0x4005ed &lt;+0&gt;:   push   %rbp<br/>&#13;
0x4005ee &lt;+1&gt;:   mov    %rsp,%rbp<br/>&#13;
0x4005f1 &lt;+4&gt;:   mov    %rdi,-0x8(%rbp)<br/>&#13;
0x4005f5 &lt;+8&gt;:   cmpq   $0x0,-0x8(%rbp)<br/>&#13;
0x4005fa &lt;+13&gt;:  je     0x40060d &lt;incrementX+32&gt;<br/>&#13;
0x4005fc &lt;+15&gt;:  mov    -0x8(%rbp),%rax<br/>&#13;
0x400600 &lt;+19&gt;:  mov    (%rax),%eax<br/>&#13;
0x400602 &lt;+21&gt;:  lea    0x1(%rax),%ecx<br/>&#13;
0x400605 &lt;+24&gt;:  mov    -0x8(%rbp),%rdx<br/>&#13;
0x400609 &lt;+28&gt;:  mov    %ecx,(%rdx)<br/>&#13;
0x40060b &lt;+30&gt;:  jmp    0x400612 &lt;incrementX+37&gt;<br/>&#13;
0x40060d &lt;+32&gt;:  mov    $0x1,%eax<br/>&#13;
0x400612 &lt;+37&gt;:  pop    %rbp<br/>&#13;
0x400613 &lt;+38&gt;:  retq</pre>&#13;
<p class="indent">Recall that the <code>cmov</code> instruction <em>executes both branches of the conditional</em>. In other words, <code>x</code> gets dereferenced no matter what. Consider the case where <code>x</code> is a null pointer. Recall that dereferencing a null pointer leads to a null pointer exception in the code, causing a segmentation fault. To prevent any chance of this happening, the compiler takes the safe road and uses jumps.</p>&#13;
<h4 class="h4" id="lev2_125">7.4.3 Loops in Assembly</h4>&#13;
<p class="noindent">Like <code>if</code> statements, loops in assembly are also implemented using jump instructions. However, loops enable instructions to be <em>revisited</em> based on the result of an evaluated condition.</p>&#13;
<p class="indent">The <code>sumUp</code> function shown in the following example sums up all the positive integers from 1 to a user-defined integer. This code is intentionally written suboptimally to illustrate a <code>while</code> loop in C.</p>&#13;
<pre>int sumUp(int n) {<br/>&#13;
    //initialize total and i<br/>&#13;
<span epub:type="pagebreak" id="page_322"/>    int total = 0;<br/>&#13;
    int i = 1;<br/>&#13;
<br/>&#13;
    while (i &lt;= n) {  //while i is less than or equal to n<br/>&#13;
        total += i;   //add i to total<br/>&#13;
        i++;          //increment i by 1<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</pre>&#13;
<p class="indent">Compiling this code and disassembling it using GDB yields the following assembly code:</p>&#13;
<pre>Dump of assembler code for function sumUp:<br/>&#13;
0x400526 &lt;+0&gt;:   push   %rbp<br/>&#13;
0x400527 &lt;+1&gt;:   mov    %rsp,%rbp<br/>&#13;
0x40052a &lt;+4&gt;:   mov    %edi,-0x14(%rbp)<br/>&#13;
0x40052d &lt;+7&gt;:   mov    $0x0,-0x8(%rbp)<br/>&#13;
0x400534 &lt;+14&gt;:  mov    $0x1,-0x4(%rbp)<br/>&#13;
0x40053b &lt;+21&gt;:  jmp    0x400547 &lt;sumUp+33&gt;<br/>&#13;
0x40053d &lt;+23&gt;:  mov    -0x4(%rbp),%eax<br/>&#13;
0x400540 &lt;+26&gt;:  add    %eax,-0x8(%rbp)<br/>&#13;
0x400543 &lt;+29&gt;:  add    $0x1,-0x4(%rbp)<br/>&#13;
0x400547 &lt;+33&gt;:  mov    -0x4(%rbp),%eax<br/>&#13;
0x40054a &lt;+36&gt;:  cmp    -0x14(%rbp),%eax<br/>&#13;
0x40054d &lt;+39&gt;:  jle    0x40053d &lt;sumUp+23&gt;<br/>&#13;
0x40054f &lt;+41&gt;:  mov    -0x8(%rbp),%eax<br/>&#13;
0x400552 &lt;+44&gt;:  pop    %rbp<br/>&#13;
0x400553 &lt;+45&gt;:  retq</pre>&#13;
<p class="indent">Again, we will not draw out the stack explicitly in this example. However, we encourage readers to draw the stack out themselves.</p>&#13;
<h5 class="h5" id="lev3_58">The First Five Instructions</h5>&#13;
<p class="noindent">The first five instructions of this function set the stack up for function execution and set up temporary values for function execution:</p>&#13;
<pre>0x400526 &lt;+0&gt;:  push %rbp              # save %rbp onto the stack<br/>&#13;
0x400527 &lt;+1&gt;:  mov  %rsp,%rbp         # update the value of %rbp (new frame)<br/>&#13;
0x40052a &lt;+4&gt;:  mov  %edi,-0x14(%rbp)  # copy n to %rbp-0x14<br/>&#13;
0x40052d &lt;+7&gt;:  mov  $0x0,-0x8(%rbp)   # copy 0 to %rbp-0x8 (total)<br/>&#13;
0x400534 &lt;+14&gt;: mov  $0x1,-0x4(%rbp)   # copy 1 to %rbp-0x4 (i)</pre>&#13;
<p class="indent">Recall that stack locations store <em>temporary variables</em> in a function. For simplicity we will refer to the location marked by <code>%rbp-0x8</code> as <code>total</code>, and <code>%rbp-0x4</code> as <code>i</code>. The input parameter to <code>sumUp</code> (<code>n</code>) is moved to stack location <code>%rbp-0x14</code>. Despite the placement of temporary variables on the stack, keep in mind that the stack pointer has not changed after the execution of the first instruction (i.e., <code>push %rbp</code>).</p>&#13;
<h5 class="h5" id="lev3_59"><span epub:type="pagebreak" id="page_323"/>The Heart of the Loop</h5>&#13;
<p class="noindent">The next seven instructions in the <code>sumUp</code> function represent the heart of the loop:</p>&#13;
<pre>0x40053b &lt;+21&gt;:  jmp    0x400547 &lt;sumUp+33&gt;  # goto &lt;sumUp+33&gt;<br/>&#13;
0x40053d &lt;+23&gt;:  mov    -0x4(%rbp),%eax      # copy i to %eax<br/>&#13;
0x400540 &lt;+26&gt;:  add    %eax,-0x8(%rbp)      # add i to total (total += i)<br/>&#13;
0x400543 &lt;+29&gt;:  add    $0x1,-0x4(%rbp)      # add 1 to i (i += 1)<br/>&#13;
0x400547 &lt;+33&gt;:  mov    -0x4(%rbp),%eax      # copy i to %eax<br/>&#13;
0x40054a &lt;+36&gt;:  cmp    -0x14(%rbp),%eax     # compare i to n<br/>&#13;
0x40054d &lt;+39&gt;:  jle    0x40053d &lt;sumUp+23&gt;  # if (i &lt;= n) goto &lt;sumUp+23&gt;</pre>&#13;
<ul>&#13;
<li class="noindent">The first instruction is a direct jump to <code>&lt;sumUp+33&gt;</code>, which sets the instruction pointer (<code>%rip</code>) to address 0x400547.</li>&#13;
<li class="noindent">The next instruction that executes is <code>mov -0x4(%rbp),%eax</code>, which places the value of <code>i</code> in register <code>%eax</code>. Register <code>%rip</code> is updated to 0x40054a.</li>&#13;
<li class="noindent">The <code>cmp</code> instruction at <code>&lt;sumUp+36&gt;</code> compares <code>i</code> to <code>n</code> and sets the appropriate condition code registers. Register <code>%rip</code> is set to 0x40054d.</li>&#13;
</ul>&#13;
<p class="indent">The <code>jle</code> instruction then executes. The instructions that execute next depend on whether or not the branch is taken.</p>&#13;
<p class="indent">Suppose that the branch <em>is</em> taken (i.e., <code>i &lt;= n</code> is true). Then the instruction pointer is set to 0x40053d and program execution jumps to <code>&lt;sumUp+23&gt;</code>. The following instructions then execute in sequence:</p>&#13;
<ul>&#13;
<li class="noindent">The <code>mov</code> instruction at <code>&lt;sumUp+23&gt;</code> copies <code>i</code> to register <code>%eax</code>.</li>&#13;
<li class="noindent">The <code>add %eax,-0x8(%rbp)</code> adds <code>i</code> to <code>total</code> (i.e., <code>total += i</code>).</li>&#13;
<li class="noindent">The <code>add</code> instruction at <code>&lt;sumUp+29&gt;</code> then adds 1 to <code>i</code> (i.e., <code>i += 1</code>).</li>&#13;
<li class="noindent">The <code>mov</code> instruction at <code>&lt;sumUp+33&gt;</code> copies the updated value of <code>i</code> to register <code>%eax</code>.</li>&#13;
<li class="noindent">The <code>cmp</code> instruction then compares <code>i</code> to <code>n</code> and sets the appropriate condition code registers.</li>&#13;
<li class="noindent">Next, <code>jle</code> executes. If <code>i</code> is less than or equal to <code>n</code>, program execution once again jumps to <code>&lt;sumUp+23&gt;</code> and the loop (defined between <code>&lt;sumUp+23&gt;</code> and <code>&lt;sumUp+39&gt;</code>) repeats.</li>&#13;
</ul>&#13;
<p class="indent">If the branch is <em>not</em> taken (i.e., <code>i</code> is <em>not</em> less than or equal to <code>n</code>), the following instructions execute:</p>&#13;
<pre>0x40054f &lt;+41&gt;:  mov    -0x8(%rbp),%eax     # copy total to %eax<br/>&#13;
0x400552 &lt;+44&gt;:  pop    %rbp                # restore rbp<br/>&#13;
0x400553 &lt;+45&gt;:  retq                       # return (total)</pre>&#13;
<p class="indent">These instructions copy <code>total</code> to register <code>%eax</code>, restore <code>%rbp</code> to its original value, and exit the function. Thus, the function returns <code>total</code> upon exit.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_324"/>The following code shows the assembly and then the C <code>goto</code> forms of the <code>sumUp</code> function:</p>&#13;
<p class="margnote">Assembly</p>&#13;
<pre>&lt;sumUp&gt;:<br/>&#13;
  &lt;+0&gt;:   push   %rbp<br/>&#13;
  &lt;+1&gt;:   mov    %rsp,%rbp<br/>&#13;
  &lt;+4&gt;:   mov    %edi,-0x14(%rbp)<br/>&#13;
  &lt;+7&gt;:   mov    $0x0,-0x8(%rbp)<br/>&#13;
  &lt;+14&gt;:  mov    $0x1,-0x4(%rbp)<br/>&#13;
  &lt;+21&gt;:  jmp    0x400547 &lt;sumUp+33&gt;<br/>&#13;
  &lt;+23&gt;:  mov    -0x4(%rbp),%eax<br/>&#13;
  &lt;+26&gt;:  add    %eax,-0x8(%rbp)<br/>&#13;
  &lt;+29&gt;:  add    $0x1,-0x4(%rbp)<br/>&#13;
  &lt;+33&gt;:  mov    -0x4(%rbp),%eax<br/>&#13;
  &lt;+36&gt;:  cmp    -0x14(%rbp),%eax<br/>&#13;
  &lt;+39&gt;:  jle    0x40053d &lt;sumUp+23&gt;<br/>&#13;
  &lt;+41&gt;:  mov    -0x8(%rbp),%eax<br/>&#13;
  &lt;+44&gt;:  pop    %rbp<br/>&#13;
  &lt;+45&gt;:  retq</pre>&#13;
<p class="margnote">Translated goto form</p>&#13;
<pre>int sumUp(int n) {<br/>&#13;
    int total = 0;<br/>&#13;
    int i = 1;<br/>&#13;
    goto start;<br/>&#13;
body:<br/>&#13;
    total += i;<br/>&#13;
    i += 1;<br/>&#13;
start:<br/>&#13;
    if (i &lt;= n) {<br/>&#13;
        goto body;<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</pre>&#13;
<p class="indent">The preceding code is also equivalent to the following C code without <code>goto</code> statements:</p>&#13;
<pre>int sumUp(int n) {<br/>&#13;
    int total = 0;<br/>&#13;
    int i = 1;<br/>&#13;
    while (i &lt;= n) {<br/>&#13;
        total += i;<br/>&#13;
        i += 1;<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</pre>&#13;
<h5 class="h5" id="lev3_60"><span epub:type="pagebreak" id="page_325"/>for Loops in Assembly</h5>&#13;
<p class="noindent">The primary loop in the <code>sumUp</code> function can also be written as a <code>for</code> loop:</p>&#13;
<pre>int sumUp2(int n) {<br/>&#13;
    int total = 0;             //initialize total to 0<br/>&#13;
    int i;<br/>&#13;
    for (i = 1; i &lt;= n; i++) { //initialize i to 1, increment by 1 while i&lt;=n<br/>&#13;
        total += i;            //updates total by i<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</pre>&#13;
<p class="indent">This version yields assembly code identical to our <code>while</code> loop example. We repeat the assembly code here and annotate each line with its English translation:</p>&#13;
<pre>Dump of assembler code for function sumUp2:<br/>&#13;
0x400554 &lt;+0&gt;:   push   %rbp                   #save %rbp<br/>&#13;
0x400555 &lt;+1&gt;:   mov    %rsp,%rbp              #update %rpb (new stack frame)<br/>&#13;
0x400558 &lt;+4&gt;:   mov    %edi,-0x14(%rbp)       #copy %edi to %rbp-0x14 (n)<br/>&#13;
0x40055b &lt;+7&gt;:   movl   $0x0,-0x8(%rbp)        #copy 0 to %rbp-0x8 (total)<br/>&#13;
0x400562 &lt;+14&gt;:  movl   $0x1,-0x4(%rbp)        #copy 1 to %rbp-0x4 (i)<br/>&#13;
0x400569 &lt;+21&gt;:  jmp    0x400575 &lt;sumUp2+33&gt;   #goto &lt;sumUp2+33&gt;<br/>&#13;
0x40056b &lt;+23&gt;:  mov    -0x4(%rbp),%eax        #copy i to %eax [loop]<br/>&#13;
0x40056e &lt;+26&gt;:  add    %eax,-0x8(%rbp)        #add i to total (total+=i)<br/>&#13;
0x400571 &lt;+29&gt;:  addl   $0x1,-0x4(%rbp)        #add 1 to i (i++)<br/>&#13;
0x400575 &lt;+33&gt;:  mov    -0x4(%rbp),%eax        #copy i to %eax [start]<br/>&#13;
0x400578 &lt;+36&gt;:  cmp    -0x14(%rbp),%eax       #compare i with n<br/>&#13;
0x40057b &lt;+39&gt;:  jle    0x40056b &lt;sumUp2+23&gt;   #if (i &lt;= n) goto loop<br/>&#13;
0x40057d &lt;+41&gt;:  mov    -0x8(%rbp),%eax        #copy total to %eax<br/>&#13;
0x400580 &lt;+44&gt;:  pop    %rbp                   #prepare to leave the function<br/>&#13;
0x400581 &lt;+45&gt;:  retq                          #return total</pre>&#13;
<p class="indent">To understand why the <code>for</code> loop version of this code results in identical assembly to the <code>while</code> loop version of the code, recall that the <code>for</code> loop has the following representation</p>&#13;
<pre>for (<span class="codeitalic1">&lt;initialization&gt;</span>; <span class="codeitalic1">&lt;boolean expression&gt;</span>; <span class="codeitalic1">&lt;step&gt;</span>){<br/>&#13;
    <span class="codeitalic1">&lt;body&gt;</span><br/>&#13;
}</pre>&#13;
<p class="noindent">and is equivalent to the following <code>while</code> loop representation:</p>&#13;
<pre><span class="codeitalic1">&lt;initialization&gt;</span><br/>&#13;
while (<span class="codeitalic1">&lt;boolean expression&gt;</span>) {<br/>&#13;
    <span class="codeitalic1">&lt;body&gt;</span><br/>&#13;
    <span class="codeitalic1">&lt;step&gt;</span><br/>&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_326"/>Since every <code>for</code> loop can be represented by a <code>while</code> loop (see “for Loops” on <a href="ch01.xhtml#lev3_5">page 35</a>), the following two C programs are equivalent representations for the previous assembly:</p>&#13;
<p class="margnote">For loop</p>&#13;
<pre>int sumUp2(int n) {<br/>&#13;
    int total = 0;<br/>&#13;
    int i = 1;<br/>&#13;
    for (i; i &lt;= n; i++) {<br/>&#13;
        total += i;<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</pre>&#13;
<p class="margnote">While loop</p>&#13;
<pre>int sumUp(int n){<br/>&#13;
    int total = 0;<br/>&#13;
    int i = 1;<br/>&#13;
    while (i &lt;= n) {<br/>&#13;
        total += i;<br/>&#13;
        i += 1;<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</pre>&#13;
<h3 class="h3" id="lev1_55">7.5 Functions in Assembly</h3>&#13;
<p class="noindent">In the previous section, we traced through simple functions in assembly. In this section, we discuss the interaction between multiple functions in assembly in the context of a larger program. We also introduce some new instructions involved with function management.</p>&#13;
<p class="indent">Let’s begin with a refresher on how the call stack is managed. Recall that <code>%rsp</code> is the <em>stack pointer</em> and always points to the top of the stack. The register <code>%rbp</code> represents the base pointer (also known as the <em>frame pointer</em>) and points to the base of the current stack frame. The <em>stack frame</em> (also known as the <em>activation frame</em> or the <em>activation record</em>) refers to the portion of the stack allocated to a single function call. The currently executing function is always at the top of the stack, and its stack frame is referred to as the <em>active frame</em>. The active frame is bounded by the stack pointer (at the top of stack) and the frame pointer (at the bottom of the frame). The activation record typically holds local variables for a function. <a href="ch07.xhtml#ch7fig4">Figure 7-4</a> shows the stack frames <span epub:type="pagebreak" id="page_327"/>for <code>main</code> and a function it calls named <code>fname</code>. We will refer to the <code>main</code> function as the <em>caller</em> function and <code>fname</code> as the <em>callee</em> function.</p>&#13;
<div class="imagec" id="ch7fig4"><img alt="image" src="../images/07fig04.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-4: Stack frame management</em></p>&#13;
<p class="indent">In <a href="ch07.xhtml#ch7fig4">Figure 7-4</a>, the current active frame belongs to the callee function (<code>fname</code>). The memory between the stack pointer and the frame pointer is used for local variables. The stack pointer moves as local values are pushed and popped from the stack. In contrast, the frame pointer remains relatively constant, pointing to the beginning (the bottom) of the current stack frame. As a result, compilers like GCC commonly reference values on the stack relative to the frame pointer. In <a href="ch07.xhtml#ch7fig4">Figure 7-4</a>, the active frame is bounded below by the base pointer of <code>fname</code>, which is stack address 0x418. The value stored at address 0x418 is the “saved” <code>%rbp</code> value (0x42c), which itself is an address that indicates the bottom of the activation frame for the <code>main</code> function. The top of the activation frame of <code>main</code> is bounded by the <em>return address</em>, which indicates where in the <code>main</code> function program execution resumes once the callee function <code>fname</code> finishes executing.</p>&#13;
<p class="note"><strong><span class="black">Warning</span> THE RETURN ADDRESS POINTS TO CODE SEGMENT MEMORY, NOT STACK MEMORY</strong></p>&#13;
<p class="note-w">Recall that the call stack region (stack memory) of a program is different from its code region (code segment memory). While <code>%rbp</code> and <code>%rsp</code> point to addresses in the stack memory, <code>%rip</code> points to an address in <em>code</em> segment memory. In other words, the return address is an address in code segment memory, not stack memory (see <a href="ch07.xhtml#ch7fig5">Figure 7-5</a>).</p>&#13;
<span epub:type="pagebreak" id="page_328"/>&#13;
<div class="imagec" id="ch7fig5"><img alt="image" src="../images/07fig05.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-5: The parts of a program’s address space</em></p>&#13;
<p class="noindent"><a href="ch07.xhtml#ch7tab16">Table 7-16</a> contains several additional instructions that the compiler uses for basic function management.</p>&#13;
<p class="tabcap" id="ch7tab16"><strong>Table 7-16:</strong> Common Function Management Instructions</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instruction</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Translation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>leaveq</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Prepares the stack for leaving a function. Equivalent to:</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>mov %rbp,%rsp</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>pop %rbp</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>callq addr &lt;fname&gt;</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Switches active frame to callee function. Equivalent to:</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>push %rip</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>mov addr, %rip</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>retq</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Restores active frame to caller function. Equivalent to:</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>pop %rip</code></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">For example, the <code>leaveq</code> instruction function is a shorthand that the compiler uses to restore the stack and frame pointers as it prepares to leave a function. When the callee function finishes execution, <code>leaveq</code> ensures that the frame pointer is <em>restored</em> to its previous value.</p>&#13;
<p class="indent">The <code>callq</code> and <code>retq</code> instructions play a prominent role in the process where one function calls another. Both instructions modify the instruction pointer (register <code>%rip</code>). When the caller function executes the <code>callq</code> instruction, the current value of <code>%rip</code> is saved on the stack to represent the return address, or the program address at which the caller resumes executing once the callee function finishes. The <code>callq</code> instruction also replaces the value of <code>%rip</code> with the address of the callee function.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_329"/>The <code>retq</code> instruction restores the value of <code>%rip</code> to the value saved on the stack, ensuring that the program resumes execution at the program address specified in the caller function. Any value returned by the callee is stored in <code>%rax</code> or one of its component registers (e.g., <code>%eax</code>). The <code>retq</code> instruction is usually the last instruction that executes in any function.</p>&#13;
<h4 class="h4" id="lev2_126">7.5.1 Function Parameters</h4>&#13;
<p class="noindent">Unlike IA32, function parameters are typically preloaded into registers prior to a function call. <a href="ch07.xhtml#ch7tab17">Table 7-17</a> lists the parameters to a function and the register (if any) that they are loaded into prior to a function call.</p>&#13;
<p class="tabcap" id="ch7tab17"><strong>Table 7-17:</strong> Locations of Function Parameters</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:70%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Parameter</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Location</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">Parameter 1</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>%rdi</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">Parameter 2</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>%rsi</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">Parameter 3</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>%rdx</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">Parameter 4</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>%rcx</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">Parameter 5</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>%r8</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">Parameter 6</p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>%r9</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">Parameter 7+</p></td>&#13;
<td style="vertical-align: top"><p class="tab">on call stack</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">The first six parameters to a function are loaded into registers <code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, and <code>%r9</code>, respectively. Any additional parameters are successively loaded into the call stack based on their size (4 byte offsets for 32-bit data, 8 byte offsets for 64-bit data).</p>&#13;
<h4 class="h4" id="lev2_127">7.5.2 Tracing Through an Example</h4>&#13;
<p class="noindent">Using our knowledge of function management, let’s trace through the code example first introduced at the beginning of this chapter. Note that the <code>void</code> keyword is added to the parameter list of each function definition to specify that the functions take no arguments. This change does not modify the output of the program; however, it does simplify the corresponding assembly.</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int assign(void) {<br/>&#13;
    int y = 40;<br/>&#13;
    return y;<br/>&#13;
}<br/>&#13;
<br/>&#13;
int adder(void) {<br/>&#13;
    int a;<br/>&#13;
    return a + 2;<br/>&#13;
}<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_330"/>int main(void) {<br/>&#13;
    int x;<br/>&#13;
    assign();<br/>&#13;
    x = adder();<br/>&#13;
    printf("x is: %d\n", x);<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="indent">We compile this code with the command <code>gcc -o prog prog.c</code> and use <code>objdump -d</code> to view the underlying assembly. The latter command outputs a pretty big file that contains a lot of information that we don’t need. Use <code>less</code> and the search functionality to extract the <code>adder</code>, <code>assign</code>, and <code>main</code> functions:</p>&#13;
<pre>0000000000400526 &lt;assign&gt;:<br/>&#13;
  400526:       55                      push   %rbp<br/>&#13;
  400527:       48 89 e5                mov    %rsp,%rbp<br/>&#13;
  40052a:       c7 45 fc 28 00 00 00    movl   $0x28,-0x4(%rbp)<br/>&#13;
  400531:       8b 45 fc                mov    -0x4(%rbp),%eax<br/>&#13;
  400534:       5d                      pop    %rbp<br/>&#13;
  400535:       c3                      retq<br/>&#13;
<br/>&#13;
0000000000400536 &lt;adder&gt;:<br/>&#13;
  400536:       55                      push   %rbp<br/>&#13;
  400537:       48 89 e5                mov    %rsp,%rbp<br/>&#13;
  40053a:       8b 45 fc                mov    -0x4(%rbp),%eax<br/>&#13;
  40053d:       83 c0 02                add    $0x2,%eax<br/>&#13;
  400540:       5d                      pop    %rbp<br/>&#13;
  400541:       c3                      retq<br/>&#13;
<br/>&#13;
0000000000400542 &lt;main&gt;:<br/>&#13;
  400542:       55                      push   %rbp<br/>&#13;
  400543:       48 89 e5                mov    %rsp,%rbp<br/>&#13;
  400546:       48 83 ec 10             sub    $0x10,%rsp<br/>&#13;
  40054a:       e8 e3 ff ff ff          callq  400526 &lt;assign&gt;<br/>&#13;
  40054f:       e8 d2 ff ff ff          callq  400536 &lt;adder&gt;<br/>&#13;
  400554:       89 45 fc                mov    %eax,-0x4(%rbp)<br/>&#13;
  400557:       8b 45 fc                mov    -0x4(%rbp),%eax<br/>&#13;
  40055a:       89 c6                   mov    %eax,%esi<br/>&#13;
  40055c:       bf 04 06 40 00          mov    $0x400604,%edi<br/>&#13;
  400561:       b8 00 00 00 00          mov    $0x0,%eax<br/>&#13;
  400566:       e8 95 fe ff ff          callq  400400 &lt;printf@plt&gt;<br/>&#13;
  40056b:       b8 00 00 00 00          mov    $0x0,%eax<br/>&#13;
  400570:       c9                      leaveq<br/>&#13;
  400571:       c3                      retq</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_331"/>Each function begins with a symbolic label that corresponds to its declared name in the program. For example, <code>&lt;main&gt;:</code> is the symbolic label for the <code>main</code> function. The address of a function label is also the address of the first instruction in that function. To save space in the figures that follow, we truncate addresses to the lower 12 bits. So, program address 0x400542 is shown as 0x542.</p>&#13;
<h4 class="h4" id="lev2_128">7.5.3 Tracing Through main</h4>&#13;
<p class="noindent"><a href="ch07.xhtml#ch7fig6">Figure 7-6</a> shows the execution stack immediately prior to the execution of <code>main</code>.</p>&#13;
<div class="imagec" id="ch7fig6"><img alt="image" src="../images/07fig06.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-6: The initial state of the CPU registers and call stack prior to executing the main function</em></p>&#13;
<p class="indent">Recall that the stack grows toward lower addresses. In this example, <code>%rbp</code> initially is stack address 0x830, and <code>%rsp</code> initially is stack address 0xd48. Both of these values are made up for this example.</p>&#13;
<p class="indent">Since the functions shown in the previous example utilize integer data, we highlight component registers <code>%eax</code> and <code>%edi</code>, which initially contain junk values. The upper-left arrow indicates the currently executing instruction. Initially, <code>%rip</code> contains address 0x542, which is the program memory address of the first line in the <code>main</code> function.</p>&#13;
<span epub:type="pagebreak" id="page_332"/>&#13;
<div class="imagec"><img alt="image" src="../images/f0332-01.jpg"/></div>&#13;
<p class="indent">The first instruction saves the current value of <code>%rbp</code> by pushing 0x830 onto the stack. Since the stack grows toward lower addresses, the stack pointer <code>%rsp</code> is updated to 0xd40, which is 8 bytes less than 0xd48. <code>%rip</code> advances to the next instruction in sequence.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0332-02.jpg"/></div>&#13;
<p class="indent">The next instruction (<code>mov %rsp,%rbp</code>) updates the value of <code>%rbp</code> to be the same as <code>%rsp</code>. The frame pointer (<code>%rbp</code>) now points to the start of the stack frame for the <code>main</code> function. <code>%rip</code> advances to the next instruction in sequence.</p>&#13;
<span epub:type="pagebreak" id="page_333"/>&#13;
<div class="imagec"><img alt="image" src="../images/f0333-01.jpg"/></div>&#13;
<p class="indent">The <code>sub</code> instruction subtracts 0x10 from the address of our stack pointer, which essentially causes the stack to “grow” by 16 bytes, which we represent by showing two 8-byte locations on the stack. Register <code>%rsp</code> therefore has the new value of 0xd30. <code>%rip</code> advances to the next instruction in sequence.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0333-02.jpg"/></div>&#13;
<p class="indent">The <code>callq &lt;assign&gt;</code> instruction pushes the value inside register <code>%rip</code> (which denotes the address of the <em>next</em> instruction to execute) onto the stack. Since the next instruction after <code>callq &lt;assign&gt;</code> has an address of 0x55f, that value is pushed onto the stack as the return address. Recall that the return address indicates the program address where execution should resume when program execution returns to <code>main</code>.</p>&#13;
<p class="indent">Next, the <code>callq</code> instruction moves the address of the <code>assign</code> function (0x526) into register <code>%rip</code>, signifying that program execution should continue into the callee function <code>assign</code> and not the next instruction in <code>main</code>.</p>&#13;
<span epub:type="pagebreak" id="page_334"/>&#13;
<div class="imagec"><img alt="image" src="../images/f0334-01.jpg"/></div>&#13;
<p class="indent">The first two instructions that execute in the <code>assign</code> function are the usual book-keeping that every function performs. The first instruction pushes the value stored in <code>%rbp</code> (memory address 0xd40) onto the stack. Recall that this address points to the beginning of the stack frame for <code>main</code>. <code>%rip</code> advances to the second instruction in <code>assign</code>.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0334-02.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_335"/>The next instruction (<code>mov %rsp,%rbp</code>) updates <code>%rbp</code> to point to the top of the stack, marking the beginning of the stack frame for <code>assign</code>. The instruction pointer (<code>%rip</code>) advances to the next instruction in the <code>assign</code> function.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0335-01.jpg"/></div>&#13;
<p class="indent">The <code>mov</code> instruction at address 0x52a moves the value <code>$0x28</code> (or 40) onto the stack at address <code>-0x4(%rbp)</code>, which is four bytes above the frame pointer. Recall that the frame pointer is commonly used to reference locations on the stack. However, keep in mind that this operation does not change the value of <code>%rsp</code>—the stack pointer still points to address 0xd20. Register <code>%rip</code> advances to the next instruction in the <code>assign</code> function.</p>&#13;
<span epub:type="pagebreak" id="page_336"/>&#13;
<div class="imagec"><img alt="image" src="../images/f0336-01.jpg"/></div>&#13;
<p class="indent">The <code>mov</code> instruction at address 0x531 places the value <code>$0x28</code> into register <code>%eax</code>, which holds the return value of the function. <code>%rip</code> advances to the <code>pop</code> instruction in the <code>assign</code> function.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0336-02.jpg"/></div>&#13;
<span epub:type="pagebreak" id="page_337"/>&#13;
<p class="indent">At this point, the <code>assign</code> function has almost completed execution. The next instruction that executes is <code>pop %rbp</code>, which restores <code>%rbp</code> to its previous value, or 0xd40. Since the <code>pop</code> instruction modifies the stack pointer, <code>%rsp</code> updates to 0xd28.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0337-01.jpg"/></div>&#13;
<p class="indent">The last instruction in <code>assign</code> is a <code>retq</code> instruction. When <code>retq</code> executes, the return address is popped off the stack into register <code>%rip</code>. In our example, <code>%rip</code> now advances to point to the <code>callq</code> instruction in <code>main</code> at address 0x55f.</p>&#13;
<p class="indent">Some important things to notice at this juncture:</p>&#13;
<ul>&#13;
<li class="noindent">The stack pointer and the frame pointer have been restored to their values prior to the call to <code>assign</code>, reflecting that the stack frame for <code>main</code> is once again the active frame.</li>&#13;
<li class="noindent">The old values on the stack from the prior active stack frame are <em>not</em> removed. They still exist on the call stack.</li>&#13;
</ul>&#13;
<span epub:type="pagebreak" id="page_338"/>&#13;
<div class="imagec"><img alt="image" src="../images/f0338-01.jpg"/></div>&#13;
<p class="indent">Back in <code>main</code>, the call to <code>adder</code> <em>overwrites</em> the old return address on the stack with a new return address (0x554). This return address points to the next instruction to be executed after <code>adder</code> returns, or <code>mov %eax,-0x4(%rbp)</code>. Register <code>%rip</code> updates to point to the first instruction to execute in <code>adder</code>, which is at address 0x536.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0338-02.jpg"/></div>&#13;
<p class="indent">The first instruction in the <code>adder</code> function saves the caller’s frame pointer (<code>%rbp</code> of <code>main</code>) on the stack.</p>&#13;
<span epub:type="pagebreak" id="page_339"/>&#13;
<div class="imagec"><img alt="image" src="../images/f0339-01.jpg"/></div>&#13;
<p class="indent">The next instruction updates <code>%rbp</code> with the current value of <code>%rsp</code>, or address 0xd20. Together, these last two instructions establish the beginning of the stack frame for <code>adder</code>.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0339-02.jpg"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_340"/>Pay close attention to the next instruction that executes. Recall that <code>$0x28</code> was placed on the stack during the call to <code>assign</code>. The instruction <code>mov $-0x4(%rbp),%eax</code> moves an <em>old</em> value that is on the stack into register <code>%eax</code>! This would not have occurred if the programmer had initialized variable <code>a</code> in the <code>adder</code> function.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0340-01.jpg"/></div>&#13;
<p class="indent">The <code>add</code> instruction at address 0x53d adds 2 to register <code>%eax</code>. Recall that when a 32-bit integer is being returned, x86-64 utilizes component register <code>%eax</code> instead of <code>%rax</code>. Together the last two instructions are equivalent to the following code in <code>adder</code>:</p>&#13;
<pre>int a;<br/>&#13;
return a + 2;</pre>&#13;
<span epub:type="pagebreak" id="page_341"/>&#13;
<div class="imagec"><img alt="image" src="../images/f0341-01.jpg"/></div>&#13;
<p class="indent">After <code>pop</code> executes, the frame pointer again points to the beginning of the stack frame for <code>main</code>, or address 0xd40. The stack pointer now contains the address 0xd28.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0341-02.jpg"/></div>&#13;
<span epub:type="pagebreak" id="page_342"/>&#13;
<p class="indent">The execution of <code>retq</code> pops the return address off the stack, restoring the instruction pointer back to 0x554, or the address of the next instruction to execute in <code>main</code>. The address contained in <code>%rsp</code> is now 0xd30.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0342-01.jpg"/></div>&#13;
<p class="indent">Back in <code>main</code>, the <code>mov %eax,-0x4(%rbp)</code> instruction places the value in <code>%eax</code> at a location four bytes above <code>%rbp</code>, or at address 0xd3c. The next instruction replaces it back into register <code>%eax</code>.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0342-02.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_343"/>Skipping ahead a little, the <code>mov</code> instruction at address 0x55a copies the value in <code>%eax</code> (or 0x2A) to register <code>%esi</code>, which is the 32-bit component register associated with <code>%rsi</code> and typically stores the second parameter to a function.</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0343-01.jpg"/></div>&#13;
<p class="indent">The next instruction (<code>mov $0x400604,%edi</code>) copies a constant value (an address in code segment memory) to register <code>%edi</code>. Recall that register <code>%edi</code> is the 32-bit component register of <code>%rdi</code>, which typically stores the first parameter to a function. The code segment memory address 0x400604 is the base address of the string <code>"x is %d\n"</code>.</p>&#13;
<span epub:type="pagebreak" id="page_344"/>&#13;
<div class="imagec"><img alt="image" src="../images/f0344-01.jpg"/></div>&#13;
<p class="indent">The next instruction resets register <code>%eax</code> with the value 0. The instruction pointer advances to the call to the <code>printf</code> function (which is denoted with the label <code>&lt;printf@plt&gt;</code>).</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0344-02.jpg"/></div>&#13;
<p class="indent">The next instruction calls the <code>printf</code> function. For the sake of brevity, we will not trace the <code>printf</code> function, which is part of <code>stdio.h</code>. However, we know from the manual page (<code>man -s3 printf</code>) that <code>printf</code> has the following format:</p>&#13;
<span epub:type="pagebreak" id="page_345"/>&#13;
<pre>int printf(const char * format, ...)</pre>&#13;
<p class="indent">In other words, the first argument is a pointer to a string specifying the format, and the second argument onward specify the values that are used in that format. The instructions specified by addresses 0x55a–0x566 correspond to the following line in the <code>main</code> function:</p>&#13;
<pre>printf("x is %d\n", x);</pre>&#13;
<p class="indent">When the <code>printf</code> function is called:</p>&#13;
<ul>&#13;
<li class="noindent">A return address specifying the instruction that executes after the call to <code>printf</code> is pushed onto the stack.</li>&#13;
<li class="noindent">The value of <code>%rbp</code> is pushed onto the stack, and <code>%rbp</code> is updated to point to the top of the stack, indicating the beginning of the stack frame for <code>printf</code>.</li>&#13;
</ul>&#13;
<p class="indent">At some point, <code>printf</code> references its arguments, which are the string <code>"x is</code> <code>%d\n"</code> and the value 0x2A. The first parameter is stored in component register <code>%edi</code>, and the second parameter is stored in component register <code>%esi</code>. The return address is located directly below <code>%rbp</code> at location <code>%rbp+8</code>.</p>&#13;
<p class="indent">For any function with <em>n</em> arguments, GCC places the first six arguments in registers, as shown in <a href="ch07.xhtml#ch7tab17">Table 7-17</a>, and the remaining arguments onto the stack <em>below</em> the return address.</p>&#13;
<p class="indent">After the call to <code>printf</code>, the value 0x2A is output to the user in integer format. Thus, the value 42 is printed to the screen!</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0345-01.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_346"/>After the call to <code>printf</code>, the last few instructions clean up the stack and prepare a clean exit from the <code>main</code> function. First, the <code>mov</code> instruction at address 0x56b ensures that 0 is in the return register (since the last thing <code>main</code> does is return 0).</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0346-01.jpg"/></div>&#13;
<p class="indent">The <code>leaveq</code> instruction prepares the stack for returning from the function call. Recall that <code>leaveq</code> is analogous to the following pair of instructions:</p>&#13;
<pre>mov %rbp, %rsp<br/>&#13;
pop %rbp</pre>&#13;
<p class="indent">In other words, the CPU overwrites the stack pointer with the frame pointer. In our example, the stack pointer is initially updated from 0xd30 to 0xd40. Next, the CPU executes <code>pop %rbp</code>, which takes the value located at 0xd40 (in our example, the address 0x830) and places it in <code>%rbp</code>. After <code>leaveq</code> executes, the stack and frame pointers revert to their original values prior to the execution of <code>main</code>.</p>&#13;
<p class="indent">The last instruction that executes is <code>retq</code>. With 0x0 in the return register <code>%eax</code>, the program returns zero, indicating correct termination.</p>&#13;
<p class="indent">If you have carefully read through this section, you should understand why our program prints out the value 42. In essence, the program inadvertently uses old values on the stack to cause it to behave in a way that we didn’t expect. This example was pretty harmless; however, we discuss in future sections how hackers have misused function calls to make programs misbehave in truly malicious ways.</p>&#13;
<h3 class="h3" id="lev1_56"><span epub:type="pagebreak" id="page_347"/>7.6 Recursion</h3>&#13;
<p class="noindent">Recursive functions are a special class of functions that call themselves (also known as <em>self-referential</em> functions) to compute a value. Like their nonrecursive counterparts, recursive functions create new stack frames for each function call. Unlike standard functions, recursive functions contain function calls to themselves.</p>&#13;
<p class="indent">Let’s revisit the problem of summing up the set of positive integers from 1 to <em>n</em>. In previous sections, we discussed the <code>sumUp</code> function to achieve this task. The following code listings show a related function called <code>sumDown</code>, which adds the numbers in reverse (<em>n</em> to 1), and its recursive equivalent <code>sumr</code>:</p>&#13;
<p class="margnote">Iterative</p>&#13;
<pre>int sumDown(int n) {<br/>&#13;
    int total = 0;<br/>&#13;
    int i = n;<br/>&#13;
    while (i &gt; 0) {<br/>&#13;
        total += i;<br/>&#13;
        i--;<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</pre>&#13;
<p class="margnote">Recursive</p>&#13;
<pre>int sumr(int n) {<br/>&#13;
    if (n &lt;= 0) {<br/>&#13;
        return 0;<br/>&#13;
    }<br/>&#13;
    return n + sumr(n-1);<br/>&#13;
}</pre>&#13;
<p class="indent">The base case in the recursive function <code>sumr</code> accounts for any values of <em>n</em> that are less than one. The recursive step calls <code>sumr</code> with the value <em>n –</em> 1 and adds the result to <em>n</em> prior to returning. Compiling <code>sumr</code> and disassembling it with GDB yields the following assembly code:</p>&#13;
<pre>Dump of assembler code for function sumr:<br/>&#13;
0x400551 &lt;+0&gt;: push  %rbp                # save %rbp<br/>&#13;
0x400552 &lt;+1&gt;: mov   %rsp,%rbp           # update %rbp (new stack frame)<br/>&#13;
0x400555 &lt;+4&gt;: sub   $0x10,%rsp          # expand stack frame by 16 bytes<br/>&#13;
0x400559 &lt;+8&gt;: mov   %edi,-0x4(%rbp)     # move first param (n) to %rbp-0x4<br/>&#13;
0x40055c &lt;+11&gt;: cmp   $0x0,-0x4(%rbp)    # compare n to 0<br/>&#13;
0x400560 &lt;+15&gt;: jg    0x400569 &lt;sumr+24&gt; # if (n &gt; 0) goto &lt;sumr+24&gt; [body]<br/>&#13;
0x400562 &lt;+17&gt;: mov   $0x0,%eax          # copy 0 to %eax<br/>&#13;
0x400567 &lt;+22&gt;: jmp   0x40057d &lt;sumr+44&gt; # goto &lt;sumr+44&gt; [done]<br/>&#13;
0x400569 &lt;+24&gt;: mov   -0x4(%rbp),%eax    # copy n to %eax (result = n)<br/>&#13;
0x40056c &lt;+27&gt;: sub   $0x1,%eax          # subtract 1 from %eax (result -= 1)<br/>&#13;
0x40056f &lt;+30&gt;: mov   %eax,%edi          # copy %eax to %edi<br/>&#13;
0x400571 &lt;+32&gt;: callq 0x400551 &lt;sumr&gt;    # call sumr(result)<br/>&#13;
0x400576 &lt;+37&gt;: mov   %eax,%edx          # copy returned value to %edx<br/>&#13;
<span epub:type="pagebreak" id="page_348"/>0x400578 &lt;+39&gt;: mov   -0x4(%rbp),%eax    # copy n to %eax<br/>&#13;
0x40057b &lt;+42&gt;: add   %edx,%eax          # add sumr(result) to n<br/>&#13;
0x40057d &lt;+44&gt;: leaveq                   # prepare to leave the function<br/>&#13;
0x40057e &lt;+45&gt;: retq                     # return result</pre>&#13;
<p class="indent">Each line in the preceding assembly code is annotated with its English translation. Here, we show the corresponding <code>goto</code> form (first) and C program without <code>goto</code> statements (second):</p>&#13;
<p class="margnote">C goto form</p>&#13;
<pre>int sumr(int n) {<br/>&#13;
    int result;<br/>&#13;
    if (n &gt; 0) {<br/>&#13;
        goto body;<br/>&#13;
    }<br/>&#13;
    result = 0;<br/>&#13;
    goto done;<br/>&#13;
body:<br/>&#13;
    result = n;<br/>&#13;
    result -= 1;<br/>&#13;
    result = sumr(result);<br/>&#13;
    result += n;<br/>&#13;
done:<br/>&#13;
    return result;<br/>&#13;
}</pre>&#13;
<p class="margnote">C version without goto</p>&#13;
<pre>int sumr(int n) {<br/>&#13;
    int result;<br/>&#13;
    if (n &lt;= 0) {<br/>&#13;
        return 0;<br/>&#13;
    }<br/>&#13;
    result = sumr(n-1);<br/>&#13;
    result += n;<br/>&#13;
    return result;<br/>&#13;
}</pre>&#13;
<p class="indent">Although this translation may not initially appear to be identical to the original <code>sumr</code> function, close inspection reveals that the two functions are indeed equivalent.</p>&#13;
<h4 class="h4" id="lev2_129">7.6.1 Animation: Observing How the Call Stack Changes</h4>&#13;
<p class="noindent">As an exercise, we encourage you to draw out the stack and see how the values change. We have provided an animation online that depicts how the stack is updated when we run this function with the value 3.<sup><a href="ch07.xhtml#fn7_2" id="rfn7_2">2</a></sup></p>&#13;
<h3 class="h3" id="lev1_57"><span epub:type="pagebreak" id="page_349"/>7.7 Arrays</h3>&#13;
<p class="noindent">Recall that arrays (see “Introduction to Arrays” on <a href="ch01.xhtml#lev2_9">page 44</a>) are ordered collections of data elements of the same type that are contiguously stored in memory. Statically allocated single-dimension arrays (see “Single-Dimensional Arrays” on <a href="ch02.xhtml#lev2_22">page 81</a>) have the form <span class="literal"/> <span class="codeitalic">&lt;type&gt;</span> <code>arr[N]</code>, where <span class="literal"/> <span class="codeitalic">&lt;type&gt;</span> is the data type, <code>arr</code> is the identifier associated with the array, and <code>N</code> is the number of data elements. Declaring an array statically as <span class="literal"/> <span class="codeitalic">&lt;type&gt;</span> <code>arr[N]</code> or dynamically as <code>arr = malloc(N * sizeof(</code> <span class="codeitalic">&lt;type&gt;</span><code>))</code> allocates <code>N</code> × <code>sizeof(</code> <span class="codeitalic">&lt;type&gt;</span><code>)</code> total bytes of memory.</p>&#13;
<p class="indent">To access the element at index <code>i</code> in array <code>arr</code>, use the syntax <code>arr[i]</code>. Compilers commonly convert array references into pointer arithmetic (see “Pointer Variables” on <a href="ch02.xhtml#lev2_17">page 67</a>) prior to translating to assembly. So, <code>arr+i</code> is equivalent to <code>&amp;arr[i]</code>, and <code>*(arr+i)</code> is equivalent to <code>arr[i]</code>. Since each data element in <code>arr</code> is of type <span class="literal"/> <span class="codeitalic">&lt;type&gt;</span>, <code>arr+i</code> implies that element <code>i</code> is stored at address <code>arr</code> + <code>sizeof(</code> <span class="codeitalic">&lt;type&gt;</span><code>)</code> × <code>i</code>.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch7tab18">Table 7-18</a> outlines some common array operations and their corresponding assembly instructions. In the examples that follow, suppose that we declare an <code>int</code> array of length 10 (<code>int arr[10]</code>). Assume that register <code>%rdx</code> stores the address of <code>arr</code>, register <code>%rcx</code> stores the <code>int</code> value <code>i</code>, and register <code>%rax</code> represents some variable <code>x</code> (also of type <code>int</code>). Recall that <code>int</code> variables take up four bytes of space, whereas <code>int *</code> variables take up eight bytes of space.</p>&#13;
<p class="tabcap" id="ch7tab18"><strong>Table 7-18:</strong> Common Array Operations and Their Corresponding Assembly Representations</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Type</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Assembly Representation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>x = arr</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>int *</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>mov %rdx,%rax</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>x = arr[0]</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>int</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>mov (%rdx),%eax</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>x = arr[i]</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>int</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>mov (%rdx,%rcx,4),%eax</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>x = &amp;arr[3]</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>int *</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>lea 0xc(%rdx),%rax</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>x = arr+3</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>int *</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>lea 0xc(%rdx),%rax</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>x = *(arr+5)</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>int</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>mov 0x14(%rdx),%eax</code></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Pay close attention to the <em>type</em> of each expression in <a href="ch07.xhtml#ch7tab18">Table 7-18</a>. In general, the compiler uses <code>mov</code> instructions to dereference pointers and the <code>lea</code> instruction to compute addresses.</p>&#13;
<p class="indent">Notice that to access element <code>arr[3]</code> (or <code>*(arr+3)</code> using pointer arithmetic), the compiler performs a memory lookup on address <code>arr+3*4</code> instead of <code>arr+3</code>. To understand why this is necessary, recall that any element at index <code>i</code> in an array is stored at address <code>arr + sizeof(</code> <span class="codeitalic">&lt;type&gt;</span><code>) * i</code>. The compiler must therefore multiply the index by the size of the data type (in this case four, since <code>sizeof(int)</code> = 4) to compute the correct offset. Recall also that memory is byte-addressable; offsetting by the correct number of bytes is the same as computing an address. Lastly, because <code>int</code> values require only four bytes of space, they are stored in component register <code>%eax</code> of register <code>%rax</code>.</p>&#13;
<p class="indent">As an example, consider a sample array (<code>array</code>) with 10 integer elements (<a href="ch07.xhtml#ch7fig7">Figure 7-7</a>).</p>&#13;
<span epub:type="pagebreak" id="page_350"/>&#13;
<div class="imagec" id="ch7fig7"><img alt="image" src="../images/07fig07.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-7: The layout of a 10-integer array in memory. Each <em>x</em><sub><em>i</em></sub>-labeled box represents four bytes.</em></p>&#13;
<p class="indent">Notice that since <code>array</code> is an array of integers, each element takes up exactly four bytes. Thus, an integer array with 10 elements consumes 40 bytes of contiguous memory.</p>&#13;
<p class="indent">To compute the address of element 3, the compiler multiplies the index 3 by the data size of the integer type (4) to yield an offset of 12 (or 0xc). Sure enough, element 3 in <a href="ch07.xhtml#ch7fig7">Figure 7-7</a> is located at byte offset <em>x</em><sub>12</sub>.</p>&#13;
<p class="indent">Let’s take a look at a simple C function called <code>sumArray</code> that sums up all the elements in an array:</p>&#13;
<pre>int sumArray(int *array, int length) {<br/>&#13;
    int i, total = 0;<br/>&#13;
    for (i = 0; i &lt; length; i++) {<br/>&#13;
        total += array[i];<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</pre>&#13;
<p class="indent">The <code>sumArray</code> function takes the address of an array and the array’s associated length and sums up all the elements in the array. Now take a look at the corresponding assembly for the <code>sumArray</code> function:</p>&#13;
<pre>0x400686 &lt;+0&gt;: push %rbp                    # save %rbp<br/>&#13;
0x400687 &lt;+1&gt;: mov  %rsp,%rbp               # update %rbp (new stack frame)<br/>&#13;
0x40068a &lt;+4&gt;: mov  %rdi,-0x18(%rbp)        # copy array to %rbp-0x18<br/>&#13;
0x40068e &lt;+8&gt;: mov  %esi,-0x1c(%rbp)        # copy length to %rbp-0x1c<br/>&#13;
0x400691 &lt;+11&gt;: movl $0x0,-0x4(%rbp)        # copy 0 to %rbp-0x4 (total)<br/>&#13;
0x400698 &lt;+18&gt;: movl $0x0,-0x8(%rbp)        # copy 0 to %rbp-0x8 (i)<br/>&#13;
0x40069f &lt;+25&gt;: jmp  0x4006be &lt;sumArray+56&gt; # goto &lt;sumArray+56&gt;<br/>&#13;
0x4006a1 &lt;+27&gt;: mov  -0x8(%rbp),%eax        # copy i to %eax<br/>&#13;
0x4006a4 &lt;+30&gt;: cltq                        # convert i to a 64-bit integer<br/>&#13;
0x4006a6 &lt;+32&gt;: lea  0x0(,%rax,4),%rdx      # copy i*4 to %rdx<br/>&#13;
0x4006ae &lt;+40&gt;: mov  -0x18(%rbp),%rax       # copy array to %rax<br/>&#13;
0x4006b2 &lt;+44&gt;: add  %rdx,%rax              # compute array+i*4, store in %rax<br/>&#13;
0x4006b5 &lt;+47&gt;: mov  (%rax),%eax            # copy array[i] to %eax<br/>&#13;
0x4006b7 &lt;+49&gt;: add  %eax,-0x4(%rbp)        # add %eax to total<br/>&#13;
0x4006ba &lt;+52&gt;: addl $0x1,-0x8(%rbp)        # add 1 to i (i+=1)<br/>&#13;
0x4006be &lt;+56&gt;: mov  -0x8(%rbp),%eax        # copy i to %eax<br/>&#13;
0x4006c1 &lt;+59&gt;: cmp  -0x1c(%rbp),%eax       # compare i to length<br/>&#13;
0x4006c4 &lt;+62&gt;: jl   0x4006a1 &lt;sumArray+27&gt; # if i&lt;length goto &lt;sumArray+27&gt;<br/>&#13;
0x4006c6 &lt;+64&gt;: mov  -0x4(%rbp),%eax        # copy total to %eax<br/>&#13;
<span epub:type="pagebreak" id="page_351"/>0x4006c9 &lt;+67&gt;: pop  %rbp                   # prepare to leave the function<br/>&#13;
0x4006ca &lt;+68&gt;: retq                        # return total</pre>&#13;
<p class="indent">When tracing this assembly code, consider whether the data being accessed represents an address or a value. For example, the instruction at <code>&lt;sumArray+11&gt;</code> results in <code>%rbp-0x4</code> containing a variable of type <code>int</code>, which is initially set to 0. In contrast, the argument stored at <code>%rbp-0x18</code> is the first argument to the function (<code>array</code>) which is of type <code>int *</code> and corresponds to the base address of the array. A different variable (which we call <code>i</code>) is stored at location <code>%rbp-0x8</code>. Lastly, note that size suffixes are included at the end of instructions like <code>add</code> and <code>mov</code> only when necessary. In cases where constant values are involved, the compiler needs to explicitly state how many bytes of the constant are being moved.</p>&#13;
<p class="indent">The astute reader will notice a previously unseen instruction at line <code>&lt;sumArray+30&gt;</code> called <code>cltq</code>. The <code>cltq</code> instruction stands for “convert long to quad” and converts the 32-bit <code>int</code> value stored in <code>%eax</code> to a 64-bit integer value that is stored in <code>%rax</code>. This operation is necessary because the instructions that follow perform pointer arithmetic. Recall that on 64-bit systems, pointers take up 8 bytes of space. The compiler’s use of <code>cltq</code> simplifies the process by ensuring that all data are stored in 64-bit registers instead of 32-bit components.</p>&#13;
<p class="indent">Let’s take a closer look at the five instructions between locations <code>&lt;sumArray+32&gt;</code> and <code>&lt;sumArray+49&gt;</code>:</p>&#13;
<pre>&lt;+32&gt;: lea 0x0(,%rax,4),%rdx       # copy i*4 to %rdx<br/>&#13;
&lt;+40&gt;: mov -0x18(%rbp),%rax        # copy array to %rax<br/>&#13;
&lt;+44&gt;: add %rdx,%rax               # add i*4 to array (i.e. array+i) to %rax<br/>&#13;
&lt;+47&gt;: mov (%rax),%eax             # dereference array+i*4, place in %eax<br/>&#13;
&lt;+49&gt;: add %eax,-0x4(%rbp)         # add %eax to total (i.e. total+=array[i])</pre>&#13;
<p class="indent">Recall that the compiler commonly uses <code>lea</code> to perform simple arithmetic on operands. The operand <code>0x0(,%rax,4)</code> translates to <code>%rax*4 + 0x0</code>. Since <code>%rax</code> holds the value of <code>i</code>, this operation copies the value <code>i*4</code> to <code>%rdx</code>. At this point, <code>%rdx</code> contains the number of bytes to calculate the correct offset of <code>array[i]</code> (recall that <code>sizeof(int)</code> = 4).</p>&#13;
<p class="indent">The next instruction (<code>mov -0x18(%rbp),%rax</code>) copies the first argument to the function (the base address of <code>array</code>) into register <code>%rax</code>. Adding <code>%rdx</code> to <code>%rax</code> in the next instruction causes <code>%rax</code> to contain <code>array+i*4</code>. Recall that the element at index <code>i</code> in <code>array</code> is stored at address <code>array + sizeof(</code> <span class="codeitalic">&lt;type&gt;</span><code>) * i</code>. Therefore, <code>%rax</code> now contains the assembly-level computation of the address <code>&amp;array[i]</code>.</p>&#13;
<p class="indent">The instruction at <code>&lt;sumArray+47&gt;</code> <em>dereferences</em> the value located at <code>%rax</code>, placing the value of <code>array[i]</code> into <code>%eax</code>. Notice the use of the component register <code>%eax</code>, since <code>array[i]</code> contains a 32-bit <code>int</code> value! In contrast, the variable <code>i</code> was changed to a quad-word on line <code>&lt;sumArray+30&gt;</code> since <code>i</code> was about to be used for <em>address computation</em>. Again, addresses are stored as 64-bit words.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_352"/>Lastly, <code>%eax</code> is added to the value in <code>%rbp-0x4</code>, or <code>total</code>. Therefore, the five instructions between locations <code>&lt;sumArray+22&gt;</code> and <code>&lt;sumArray+39&gt;</code> correspond to the line <code>total += array[i]</code> in the <code>sumArray</code> function.</p>&#13;
<h3 class="h3" id="lev1_58">7.8 Matrices</h3>&#13;
<p class="noindent">A matrix is a two-dimensional array. A matrix in C can be statically allocated as a two-dimensional array (<code>M[n][m]</code>), dynamically allocated with a single call to <code>malloc</code>, or dynamically allocated as an array of arrays. Let’s consider the array of arrays implementation. The first array contains <code>n</code> elements (<code>M[n]</code>), and each element <code>M[i]</code> in our matrix contains an array of <code>m</code> elements. The following code snippets each declare matrices of size 4 × 3:</p>&#13;
<pre>//statically allocated matrix (allocated on stack)<br/>&#13;
int M1[4][3];<br/>&#13;
<br/>&#13;
//dynamically allocated matrix (programmer friendly, allocated on heap)<br/>&#13;
int **M2, i;<br/>&#13;
M2 = malloc(4 * sizeof(int*));<br/>&#13;
for (i = 0; i &lt; 4; i++) {<br/>&#13;
    M2[i] = malloc(3 * sizeof(int));<br/>&#13;
}</pre>&#13;
<p class="indent">In the case of the dynamically allocated matrix, the main array contains a contiguous array of <code>int</code> pointers. Each integer pointer points to a different array in memory. <a href="ch07.xhtml#ch7fig8">Figure 7-8</a> illustrates how we would normally visualize each of these matrices.</p>&#13;
<div class="imagec" id="ch7fig8"><img alt="image" src="../images/07fig08.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-8: Illustration of a statically allocated (<code>M1</code>) and a dynamically allocated (<code>M2</code>) 3 × 4 matrix</em></p>&#13;
<p class="indent">For both of these matrix declarations, element (<em>i</em>,<em>j</em>) can be accessed using the double-indexing syntax <code>M[i][j]</code>, where <code>M</code> is either <code>M1</code> or <code>M2</code>. However, these matrices are organized differently in memory. Even though both store the elements in their primary array contiguously in memory, our statically allocated matrix also stores all the rows contiguously in memory, as shown in <a href="ch07.xhtml#ch7fig9">Figure 7-9</a>.</p>&#13;
<span epub:type="pagebreak" id="page_353"/>&#13;
<div class="imagec" id="ch7fig9"><img alt="image" src="../images/07fig09.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-9: Matrix <code>M1</code>’s memory layout in row-major order</em></p>&#13;
<p class="indent">This contiguous ordering is not guaranteed for <code>M2</code>. Recall (from “Two-Dimensional Array Memory Layout” on <a href="ch02.xhtml#lev3_13">page 86</a>) that to contiguously allocate an <em>n</em> × <em>m</em> matrix on the heap, we should use a single call to <code>malloc</code> that allocates <em>n</em> × <em>m</em> elements:</p>&#13;
<pre>//dynamic matrix (allocated on heap, memory efficient way)<br/>&#13;
#define ROWS 4<br/>&#13;
#define COLS 3<br/>&#13;
int *M3;<br/>&#13;
M3 = malloc(ROWS * COLS * sizeof(int));</pre>&#13;
<p class="indent">Recall that with the declaration of <code>M3</code>, element (<em>i</em>,<em>j</em>) <em>cannot</em> be accessed using the <code>M[i][j]</code> notation. Instead, we must index the element using the format <code>M3[i*COLS + j]</code>.</p>&#13;
<h4 class="h4" id="lev2_130">7.8.1 Contiguous Two-Dimensional Arrays</h4>&#13;
<p class="noindent">Consider a function <code>sumMat</code> that takes a pointer to a contiguously allocated (either statically allocated or memory-efficiently dynamically allocated) matrix as its first parameter, along with the numbers of rows and columns, and returns the sum of all the elements inside the matrix.</p>&#13;
<p class="indent">We use scaled indexing in the code snippet that follows because it applies to both statically and dynamically allocated contiguous matrices. Recall that the syntax <code>m[i][j]</code> does not work with the memory-efficient contiguous dynamic allocation previously discussed.</p>&#13;
<pre>int sumMat(int *m, int rows, int cols) {<br/>&#13;
    int i, j, total = 0;<br/>&#13;
    for (i = 0; i &lt; rows; i++){<br/>&#13;
        for (j = 0; j &lt; cols; j++){<br/>&#13;
            total += m[i*cols + j];<br/>&#13;
        }<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</pre>&#13;
<p class="indent">Here is the corresponding assembly. Each line is annotated with its English translation:</p>&#13;
<pre>Dump of assembler code for function sumMat:<br/>&#13;
0x400686 &lt;+0&gt;:   push %rbp                 # save rbp<br/>&#13;
0x400687 &lt;+1&gt;:   mov  %rsp,%rbp            # update rbp (new stack frame)<br/>&#13;
0x40068a &lt;+4&gt;:   mov  %rdi,-0x18(%rbp)     # copy m to %rbp-0x18<br/>&#13;
0x40068e &lt;+8&gt;:   mov  %esi,-0x1c(%rbp)     # copy rows to %rbp-0x1c<br/>&#13;
<span epub:type="pagebreak" id="page_354"/>0x400691 &lt;+11&gt;:  mov  %edx,-0x20(%rbp)     # copy cols parameter to %rbp-0x20<br/>&#13;
0x400694 &lt;+14&gt;:  movl $0x0,-0x4(%rbp)      # copy 0 to %rbp-0x4 (total)<br/>&#13;
0x40069b &lt;+21&gt;:  movl $0x0,-0xc(%rbp)      # copy 0 to %rbp-0xc (i)<br/>&#13;
0x4006a2 &lt;+28&gt;:  jmp  0x4006e1 &lt;sumMat+91&gt; # goto &lt;sumMat+91&gt;<br/>&#13;
0x4006a4 &lt;+30&gt;:  movl $0x0,-0x8(%rbp)      # copy 0 to %rbp-0x8 (j)<br/>&#13;
0x4006ab &lt;+37&gt;:  jmp  0x4006d5 &lt;sumMat+79&gt; # goto &lt;sumMat+79&gt;<br/>&#13;
0x4006ad &lt;+39&gt;:  mov  -0xc(%rbp),%eax      # copy i to %eax<br/>&#13;
0x4006b0 &lt;+42&gt;:  imul -0x20(%rbp),%eax     # mult i with cols, place in %eax<br/>&#13;
0x4006b4 &lt;+46&gt;:  mov  %eax,%edx            # copy i*cols to %edx<br/>&#13;
0x4006b6 &lt;+48&gt;:  mov  -0x8(%rbp),%eax      # copy j to %eax<br/>&#13;
0x4006b9 &lt;+51&gt;:  add  %edx,%eax            # add i*cols with j, place in %eax<br/>&#13;
0x4006bb &lt;+53&gt;:  cltq                      # convert %eax to a 64-bit int<br/>&#13;
0x4006bd &lt;+55&gt;:  lea  0x0(,%rax,4),%rdx    # mult (i*cols+j) by 4,put in %rdx<br/>&#13;
0x4006c5 &lt;+63&gt;:  mov  -0x18(%rbp),%rax     # copy m to %rax<br/>&#13;
0x4006c9 &lt;+67&gt;:  add  %rdx,%rax            # add m to (i*cols+j)*4,put in %rax<br/>&#13;
0x4006cc &lt;+70&gt;:  mov  (%rax),%eax          # copy m[i*cols+j] to %eax<br/>&#13;
0x4006ce &lt;+72&gt;:  add  %eax,-0x4(%rbp)      # add m[i*cols+j] to total<br/>&#13;
0x4006d1 &lt;+75&gt;:  addl $0x1,-0x8(%rbp)      # add 1 to j (j++)<br/>&#13;
0x4006d5 &lt;+79&gt;:  mov  -0x8(%rbp),%eax      # copy j to %eax<br/>&#13;
0x4006d8 &lt;+82&gt;:  cmp  -0x20(%rbp),%eax     # compare j with cols<br/>&#13;
0x4006db &lt;+85&gt;:  jl   0x4006ad &lt;sumMat+39&gt; # if (j &lt; cols) goto &lt;sumMat+39&gt;<br/>&#13;
0x4006dd &lt;+87&gt;:  addl $0x1,-0xc(%rbp)      # add 1 to i<br/>&#13;
0x4006e1 &lt;+91&gt;:  mov  -0xc(%rbp),%eax      # copy i to %eax<br/>&#13;
0x4006e4 &lt;+94&gt;:  cmp  -0x1c(%rbp),%eax     # compare i with rows<br/>&#13;
0x4006e7 &lt;+97&gt;:  jl   0x4006a4 &lt;sumMat+30&gt; # if (i &lt; rows) goto &lt;sumMat+30&gt;<br/>&#13;
0x4006e9 &lt;+99&gt;:  mov  -0x4(%rbp),%eax      # copy total to %eax<br/>&#13;
0x4006ec &lt;+102&gt;: pop  %rbp                 # clean up stack<br/>&#13;
0x4006ed &lt;+103&gt;: retq                      # return total</pre>&#13;
<p class="indent">The local variables <code>i</code>, <code>j</code>, and <code>total</code> are loaded at addresses <code>%rbp-0xc</code>, <code>%rbp-0x8</code>, and <code>%rbp-0x4</code> on the stack, respectively. The input parameters <code>m</code>, <code>row</code>, and <code>cols</code> are stored at locations <code>%rbp-0x8</code>, <code>%rbp-0x1c</code>, and <code>%rbp-0x20</code>, respectively. Using this knowledge, let’s zoom in on the component that just deals with the access of element (<em>i</em>,<em>j</em>) in our matrix:</p>&#13;
<pre>0x4006ad &lt;+39&gt;: mov  -0xc(%rbp),%eax    # copy i to %eax<br/>&#13;
0x4006b0 &lt;+42&gt;: imul -0x20(%rbp),%eax   # multiply i with cols, place in %eax<br/>&#13;
0x4006b4 &lt;+46&gt;: mov  %eax,%edx          # copy i*cols to %edx</pre>&#13;
<p class="indent">The first set of instructions calculates the value <code>i*cols</code> and places it in register <code>%edx</code>. Recall that for a matrix named <code>matrix</code>, <code>matrix + (i*cols)</code> is equivalent to <code>&amp;matrix[i]</code>.</p>&#13;
<pre>0x4006b6 &lt;+48&gt;: mov  -0x8(%rbp),%eax    # copy j to %eax<br/>&#13;
0x4006b9 &lt;+51&gt;: add  %edx,%eax          # add i*cols with j, place in %eax<br/>&#13;
0x4006bb &lt;+53&gt;: cltq                    # convert %eax to a 64-bit int<br/>&#13;
0x4006bd &lt;+55&gt;: lea  0x0(,%rax,4),%rdx  # multiply (i*cols+j) by 4,put in %rdx</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_355"/>The next set of instructions computes <code>(i*cols + j)*4</code>. The compiler multiplies the index <code>i*cols+j</code> by four since each element in the matrix is a four-byte integer, and this multiplication enables the compiler to compute the correct offset. The <code>cltq</code> instruction on line <code>&lt;sumMat+53&gt;</code> is needed to sign-extend the contents of <code>%eax</code> into a 64-bit integer, since that is about to be used for address calculation.</p>&#13;
<p class="indent">Next, the following set of instructions adds the calculated offset to the matrix pointer and dereferences it to yield the value of element (<em>i</em>,<em>j</em>):</p>&#13;
<pre>0x4006c5 &lt;+63&gt;: mov -0x18(%rbp),%rax   # copy m to %rax<br/>&#13;
0x4006c9 &lt;+67&gt;: add %rdx,%rax          # add m to (i*cols+j)*4, place in %rax<br/>&#13;
0x4006cc &lt;+70&gt;: mov (%rax),%eax        # copy m[i*cols+j] to %eax<br/>&#13;
0x4006ce &lt;+72&gt;: add %eax,-0x4(%rbp)    # add m[i*cols+j] to total</pre>&#13;
<p class="indent">The first instruction loads the address of matrix <code>m</code> into register <code>%rax</code>. The <code>add</code> instruction adds <code>(i*cols + j)*4</code> to the address of <code>m</code> to correctly calculate the offset of element (<em>i</em>,<em>j</em>). The third instruction dereferences the address in <code>%rax</code> and places the value in <code>%eax</code>. Notice the use of <code>%eax</code> as the destination component register; since our matrix contains integers, and an integer takes up four bytes of space, component register <code>%eax</code> is again used instead of <code>%rax</code>.</p>&#13;
<p class="indent">The last instruction adds the value in <code>%eax</code> to the accumulator <code>total</code>, which is located at stack address <code>%rbp-0x4</code>.</p>&#13;
<p class="indent">Let’s consider how element (1,2) is accessed in <a href="ch07.xhtml#ch7fig9">Figure 7-9</a>. For convenience, the figure is reproduced here in <a href="ch07.xhtml#ch7fig10">Figure 7-10</a>:</p>&#13;
<div class="imagec" id="ch7fig10"><img alt="image" src="../images/07fig10.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-10: Matrix <code>M1</code>’s memory layout in row-major order</em></p>&#13;
<p class="indent">Element (1,2) is located at address <code>M1 + 1*COLS + 2</code>. Since <code>COLS</code> = 3, element (1,2) corresponds to <code>M1+5</code>. To access the element at this location, the compiler must multiply 5 by the size of the <code>int</code> data type (four bytes), yielding the offset <code>M1+20</code>, which corresponds to byte <em>x</em><sub>20</sub> in the figure. Dereferencing this location yields element 5, which is indeed element (1,2) in the matrix.</p>&#13;
<h4 class="h4" id="lev2_131">7.8.2 Noncontiguous Matrix</h4>&#13;
<p class="noindent">The noncontiguous matrix implementation is a bit more complicated. <a href="ch07.xhtml#ch7fig11">Figure 7-11</a> visualizes how <code>M2</code> may be laid out in memory.</p>&#13;
<span epub:type="pagebreak" id="page_356"/>&#13;
<div class="imagec" id="ch7fig11"><img alt="image" src="../images/07fig11.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-11: Matrix <code>M2</code>’s noncontiguous layout in memory</em></p>&#13;
<p class="indent">Notice that the array of pointers is contiguous, and that each array pointed to by an element of <code>M2</code> (e.g., <code>M2[i]</code>) is contiguous. However, the individual arrays are not contiguous with one another. Since <code>M2</code> is an array of pointers, each element of <code>M2</code> takes eight bytes of space. In contrast, since <code>M2[i]</code> is an <code>int</code> array, each element of <code>M2[i]</code> is four bytes away.</p>&#13;
<p class="indent">The <code>sumMatrix</code> function in the following example takes an array of integer pointers (called <code>matrix</code>) as its first parameter, and a number of rows and columns as its second and third parameters:</p>&#13;
<pre>int sumMatrix(int **matrix, int rows, int cols) {<br/>&#13;
    int i, j, total=0;<br/>&#13;
<br/>&#13;
    for (i = 0; i &lt; rows; i++) {<br/>&#13;
        for (j = 0; j &lt; cols; j++) {<br/>&#13;
            total += matrix[i][j];<br/>&#13;
        }<br/>&#13;
    }<br/>&#13;
    return total;<br/>&#13;
}</pre>&#13;
<p class="indent">Even though this function looks nearly identical to the <code>sumMat</code> function shown earlier, the matrix accepted by this function consists of a contiguous array of <em>pointers</em>. Each pointer contains the address of a separate contiguous array, which corresponds to a separate row in the matrix.</p>&#13;
<p class="indent">The corresponding assembly for <code>sumMatrix</code> follow. Each line is annotated with its English translation.</p>&#13;
<pre>Dump of assembler code for function sumMatrix:<br/>&#13;
0x4006ee &lt;+0&gt;:   push   %rbp                    # save rbp<br/>&#13;
0x4006ef &lt;+1&gt;:   mov    %rsp,%rbp               # update rbp (new stack frame)<br/>&#13;
0x4006f2 &lt;+4&gt;:   mov    %rdi,-0x18(%rbp)        # copy matrix to %rbp-0x18<br/>&#13;
0x4006f6 &lt;+8&gt;:   mov    %esi,-0x1c(%rbp)        # copy rows to %rbp-0x1c<br/>&#13;
0x4006f9 &lt;+11&gt;:  mov    %edx,-0x20(%rbp)        # copy cols to %rbp-0x20<br/>&#13;
0x4006fc &lt;+14&gt;:  movl   $0x0,-0x4(%rbp)         # copy 0 to %rbp-0x4 (total)<br/>&#13;
0x400703 &lt;+21&gt;:  movl   $0x0,-0xc(%rbp)         # copy 0 to %rbp-0xc (i)<br/>&#13;
0x40070a &lt;+28&gt;:  jmp    0x40074e &lt;sumMatrix+96&gt; # goto &lt;sumMatrix+96&gt;<br/>&#13;
0x40070c &lt;+30&gt;:  movl   $0x0,-0x8(%rbp)         # copy 0 to %rbp-0x8 (j)<br/>&#13;
<span epub:type="pagebreak" id="page_357"/>0x400713 &lt;+37&gt;:  jmp    0x400742 &lt;sumMatrix+84&gt; # goto &lt;sumMatrix+84&gt;<br/>&#13;
0x400715 &lt;+39&gt;:  mov    -0xc(%rbp),%eax         # copy i to %eax<br/>&#13;
0x400718 &lt;+42&gt;:  cltq                           # convert i to 64-bit integer<br/>&#13;
0x40071a &lt;+44&gt;:  lea    0x0(,%rax,8),%rdx       # mult i by 8, place in %rdx<br/>&#13;
0x400722 &lt;+52&gt;:  mov    -0x18(%rbp),%rax        # copy matrix to %rax<br/>&#13;
0x400726 &lt;+56&gt;:  add    %rdx,%rax               # put i*8 + matrix in %rax<br/>&#13;
0x400729 &lt;+59&gt;:  mov    (%rax),%rax             # copy matrix[i] to %rax (ptr)<br/>&#13;
0x40072c &lt;+62&gt;:  mov    -0x8(%rbp),%edx         # copy j to %edx<br/>&#13;
0x40072f &lt;+65&gt;:  movslq %edx,%rdx               # convert j to 64-bit integer<br/>&#13;
0x400732 &lt;+68&gt;:  shl    $0x2,%rdx               # mult j by 4, place in %rdx<br/>&#13;
0x400736 &lt;+72&gt;:  add    %rdx,%rax               # put j*4 + matrix[i] in %rax<br/>&#13;
0x400739 &lt;+75&gt;:  mov    (%rax),%eax             # copy matrix[i][j] to %eax<br/>&#13;
0x40073b &lt;+77&gt;:  add    %eax,-0x4(%rbp)         # add matrix[i][j] to total<br/>&#13;
0x40073e &lt;+80&gt;:  addl   $0x1,-0x8(%rbp)         # add 1 to j (j++)<br/>&#13;
0x400742 &lt;+84&gt;:  mov    -0x8(%rbp),%eax         # copy j to %eax<br/>&#13;
0x400745 &lt;+87&gt;:  cmp    -0x20(%rbp),%eax        # compare j with cols<br/>&#13;
0x400748 &lt;+90&gt;:  jl     0x400715 &lt;sumMatrix+39&gt; # if j&lt;cols goto&lt;sumMatrix+39&gt;<br/>&#13;
0x40074a &lt;+92&gt;:  addl   $0x1,-0xc(%rbp)         # add 1 to i (i++)<br/>&#13;
0x40074e &lt;+96&gt;:  mov    -0xc(%rbp),%eax         # copy i to %eax<br/>&#13;
0x400751 &lt;+99&gt;:  cmp    -0x1c(%rbp),%eax        # compare i with rows<br/>&#13;
0x400754 &lt;+102&gt;: jl     0x40070c &lt;sumMatrix+30&gt; # if i&lt;rows goto&lt;sumMatrix+30&gt;<br/>&#13;
0x400756 &lt;+104&gt;: mov    -0x4(%rbp),%eax         # copy total to %eax<br/>&#13;
0x400759 &lt;+107&gt;: pop    %rbp                    # restore %rbp<br/>&#13;
0x40075a &lt;+108&gt;: retq                           # return total</pre>&#13;
<p class="indent">Once again, the variables <code>i</code>, <code>j</code>, and <code>total</code> are at stack addresses <code>%rbp-0xc</code>, <code>%rbp-0x8</code>, and <code>%rbp-0x4</code>, respectively. The input parameters <code>matrix</code>, <code>row</code>, and <code>cols</code> are located at stack addresses <code>%rbp-0x18</code>, <code>%rbp-0x1c</code>, and <code>%rbp-0x20</code>, respectively.</p>&#13;
<p class="indent">Let’s zoom in on the section that deals specifically with an access to element (<em>i</em>,<em>j</em>), or <code>matrix[i][j]</code>:</p>&#13;
<pre>0x400715 &lt;+39&gt;: mov  -0xc(%rbp),%eax       # copy i to %eax<br/>&#13;
0x400718 &lt;+42&gt;: cltq                       # convert i to 64-bit integer<br/>&#13;
0x40071a &lt;+44&gt;: lea  0x0(,%rax,8),%rdx     # multiply i by 8, place in %rdx<br/>&#13;
0x400722 &lt;+52&gt;: mov  -0x18(%rbp),%rax      # copy matrix to %rax<br/>&#13;
0x400726 &lt;+56&gt;: add  %rdx,%rax             # add i*8 to matrix, place in %rax<br/>&#13;
0x400729 &lt;+59&gt;: mov  (%rax),%rax           # copy matrix[i] to %rax (pointer)</pre>&#13;
<p class="indent">The five instructions in this example compute <code>matrix[i]</code>, or <code>*(matrix+i)</code>. Since <code>matrix[i]</code> contains a pointer, <code>i</code> is first converted to a 64-bit integer. Then, the compiler multiplies <code>i</code> by eight prior to adding it to <code>matrix</code> to calculate the correct address offset (recall that pointers are eight bytes in size). The instruction at <code>&lt;sumMatrix+59&gt;</code> then dereferences the calculated address to get the element <code>matrix[i]</code>.</p>&#13;
<p class="indent">Since <code>matrix</code> is an array of <code>int</code> pointers, the element located at <code>matrix[i]</code> is itself an <code>int</code> pointer. The <em>j</em>th element in <code>matrix[i]</code> is located at offset <em>j</em> × 4 in the <code>matrix[i]</code> array.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_358"/>The next set of instructions extract the <em>j</em>th element in array <code>matrix[i]</code>:</p>&#13;
<pre>0x40072c &lt;+62&gt;: mov    -0x8(%rbp),%edx    # copy j to %edx<br/>&#13;
0x40072f &lt;+65&gt;: movslq %edx,%rdx          # convert j to a 64-bit integer<br/>&#13;
0x400732 &lt;+68&gt;: shl    $0x2,%rdx          # multiply j by 4, place in %rdx<br/>&#13;
0x400736 &lt;+72&gt;: add    %rdx,%rax          # add j*4 to matrix[i], put in %rax<br/>&#13;
0x400739 &lt;+75&gt;: mov    (%rax),%eax        # copy matrix[i][j] to %eax<br/>&#13;
0x40073b &lt;+77&gt;: add    %eax,-0x4(%rbp)    # add matrix[i][j] to total</pre>&#13;
<p class="indent">The first instruction in this snippet loads variable <code>j</code> into register <code>%edx</code>. The <code>movslq</code> instruction at <code>&lt;sumMatrix+65&gt;</code> converts <code>%edx</code> into a 64-bit integer, storing the result in 64-bit register <code>%rdx</code>. The compiler then uses the left shift (<code>shl</code>) instruction to multiply <code>j</code> by four and stores the result in register <code>%rdx</code>. The compiler finally adds the resulting value to the address located in <code>matrix[i]</code> to get the address of element <code>matrix[i][j]</code>. The instructions at <code>&lt;sumMatrix+75&gt;</code> and <code>&lt;sumMatrix+77&gt;</code> obtain the value at <code>matrix[i][j]</code> and add the value to <code>total</code>.</p>&#13;
<p class="indent">Let’s revisit <a href="ch07.xhtml#ch7fig11">Figure 7-11</a> and consider an example access to M2[1][2]. For convenience, we reproduce the figure in <a href="ch07.xhtml#ch7fig12">Figure 7-12</a>:</p>&#13;
<div class="imagec" id="ch7fig12"><img alt="image" src="../images/07fig12.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-12: Matrix <code>M2</code>’s noncontiguous layout in memory</em></p>&#13;
<p class="indent">Note that <code>M2</code> starts at memory location <em>x</em><sub>0</sub>. The compiler first computes the address of <code>M2[1]</code> by multiplying 1 by 8 (<code>sizeof(int *)</code>) and adding it to the address of <code>M2</code> (<em>x</em><sub>0</sub>), yielding the new address <em>x</em><sub>8</sub>. A dereference of this address yields the address associated with <code>M2[1]</code>, or <em>x</em><sub>36</sub>. The compiler then multiplies index 2 by 4 (<code>sizeof(int)</code>), and adds the result (8) to <em>x</em><sub>36</sub>, yielding a final address of <em>x</em><sub>44</sub>. The address <em>x</em><sub>44</sub> is dereferenced, yielding the value 5. Sure enough, the element in <a href="ch07.xhtml#ch7fig11">Figure 7-11</a> that corresponds to <code>M2[1][2]</code> has the value 5.</p>&#13;
<h3 class="h3" id="lev1_59">7.9 structs in Assembly</h3>&#13;
<p class="noindent">A <code>struct</code> (see “C Structs” on <a href="ch02.xhtml#lev1_15">page 103</a>) is another way to create a collection of data types in C. Unlike arrays, structs enable different data types to be grouped together. C stores a <code>struct</code> like a single-dimension array, where the data elements (fields) are stored contiguously. Let’s revisit <code>struct studentT</code> <span epub:type="pagebreak" id="page_359"/>from <a href="ch01.xhtml#ch01">Chapter 1</a>:</p>&#13;
<pre>struct studentT {<br/>&#13;
    char name[64];<br/>&#13;
    int  age;<br/>&#13;
    int  grad_yr;<br/>&#13;
    float gpa;<br/>&#13;
};<br/>&#13;
<br/>&#13;
struct studentT student;</pre>&#13;
<p class="indent"><a href="ch07.xhtml#ch7fig13">Figure 7-13</a> shows how <code>student</code> is laid out in memory. Each <em>x</em><sub><em>i</em></sub> denotes the address of a particular field.</p>&#13;
<div class="imagec" id="ch7fig13"><img alt="image" src="../images/07fig13.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-13: The memory layout of <code>struct studentT</code></em></p>&#13;
<p class="indent">The fields are stored contiguously next to one another in memory in the order in which they are declared. In <a href="ch07.xhtml#ch7fig13">Figure 7-13</a>, the <code>age</code> field is allocated at the memory location directly after the <code>name</code> field (at byte offset <em>x</em><sub>64</sub>) and is followed by the <code>grad_yr</code> (byte offset <em>x</em>68) and <code>gpa</code> (byte offset <em>x</em><sub>72</sub>) fields. This organization enables memory-efficient access to the fields.</p>&#13;
<p class="indent">To understand how the compiler generates assembly code to work with a <code>struct</code>, consider the function <code>initStudent</code>:</p>&#13;
<pre>void initStudent(struct studentT *s, char *nm, int ag, int gr, float g) {<br/>&#13;
    strncpy(s-&gt;name, nm, 64);<br/>&#13;
    s-&gt;grad_yr = gr;<br/>&#13;
    s-&gt;age = ag;<br/>&#13;
    s-&gt;gpa = g;<br/>&#13;
}</pre>&#13;
<p class="indent">The <code>initStudent</code> function uses the base address of a <code>struct studentT</code> as its first parameter, and the desired values for each field as its remaining parameters. The following listing depicts this function in assembly:</p>&#13;
<pre>Dump of assembler code for function initStudent:<br/>&#13;
0x4006aa &lt;+0&gt;:  push  %rbp                   # save rbp<br/>&#13;
0x4006ab &lt;+1&gt;:  mov   %rsp,%rbp              # update rbp (new stack frame)<br/>&#13;
0x4006ae &lt;+4&gt;:  sub   $0x20,%rsp             # add 32 bytes to stack frame<br/>&#13;
0x4006b2 &lt;+8&gt;:  mov   %rdi,-0x8(%rbp)        # copy 1st param to %rbp-0x8 (s)<br/>&#13;
0x4006b6 &lt;+12&gt;: mov   %rsi,-0x10(%rbp)       # copy 2nd param to %rpb-0x10 (nm)<br/>&#13;
0x4006ba &lt;+16&gt;: mov   %edx,-0x14(%rbp)       # copy 3rd param to %rbp-0x14 (ag)<br/>&#13;
0x4006bd &lt;+19&gt;: mov   %ecx,-0x18(%rbp)       # copy 4th param to %rbp-0x18 (gr)<br/>&#13;
0x4006c0 &lt;+22&gt;: movss %xmm0,-0x1c(%rbp)      # copy 5th param to %rbp-0x1c (g)<br/>&#13;
0x4006c5 &lt;+27&gt;: mov   -0x8(%rbp),%rax        # copy s to %rax<br/>&#13;
0x4006c9 &lt;+31&gt;: mov   -0x10(%rbp),%rcx       # copy nm to %rcx<br/>&#13;
<span epub:type="pagebreak" id="page_360"/>0x4006cd &lt;+35&gt;: mov   $0x40,%edx             # copy 0x40 (or 64) to %edx<br/>&#13;
0x4006d2 &lt;+40&gt;: mov   %rcx,%rsi              # copy nm to %rsi<br/>&#13;
0x4006d5 &lt;+43&gt;: mov   %rax,%rdi              # copy s to %rdi<br/>&#13;
0x4006d8 &lt;+46&gt;: callq 0x400460 &lt;strncpy@plt&gt; # call strcnpy(s-&gt;name, nm, 64)<br/>&#13;
0x4006dd &lt;+51&gt;: mov   -0x8(%rbp),%rax        # copy s to %rax<br/>&#13;
0x4006e1 &lt;+55&gt;: mov   -0x18(%rbp),%edx       # copy gr to %edx<br/>&#13;
0x4006e4 &lt;+58&gt;: mov   %edx,0x44(%rax)        # copy gr to %rax+0x44 (s-&gt;grad_yr)<br/>&#13;
0x4006e7 &lt;+61&gt;: mov   -0x8(%rbp),%rax        # copy s to %rax<br/>&#13;
0x4006eb &lt;+65&gt;: mov   -0x14(%rbp),%edx       # copy ag to %edx<br/>&#13;
0x4006ee &lt;+68&gt;: mov   %edx,0x40(%rax)        # copy ag to %rax+0x40 (s-&gt;age)<br/>&#13;
0x4006f1 &lt;+71&gt;: mov   -0x8(%rbp),%rax        # copy s to %rax<br/>&#13;
0x4006f5 &lt;+75&gt;: movss -0x1c(%rbp),%xmm0      # copy g to %xmm0<br/>&#13;
0x4006fa &lt;+80&gt;: movss %xmm0,0x48(%rax)       # copy g to %rax+0x48<br/>&#13;
0x400700 &lt;+86&gt;: leaveq                       # prepare stack to exit function<br/>&#13;
0x400701 &lt;+87&gt;: retq                         # return (void func, %rax ignored)</pre>&#13;
<p class="indent">Being mindful of the byte offsets of each field is key to understanding this code. Here are a few things to keep in mind.</p>&#13;
<p class="indent">The <code>strncpy</code> call takes the base address of the <code>name</code> field of <code>s</code>, the address of array <code>nm</code>, and a length specifier as its three arguments. Recall that because <code>name</code> is the first field in the <code>struct studentT</code>, the address of <code>s</code> is synonymous with the address of <code>s-&gt;name</code>.</p>&#13;
<pre>0x4006b2 &lt;+8&gt;:  mov   %rdi,-0x8(%rbp)        # copy 1st param to %rbp-0x8 (s)<br/>&#13;
0x4006b6 &lt;+12&gt;: mov   %rsi,-0x10(%rbp)       # copy 2nd param to %rpb-0x10 (nm)<br/>&#13;
0x4006ba &lt;+16&gt;: mov   %edx,-0x14(%rbp)       # copy 3rd param to %rbp-0x14 (ag)<br/>&#13;
0x4006bd &lt;+19&gt;: mov   %ecx,-0x18(%rbp)       # copy 4th param to %rbp-0x18 (gr)<br/>&#13;
0x4006c0 &lt;+22&gt;: movss %xmm0,-0x1c(%rbp)      # copy 5th param to %rbp-0x1c (g)<br/>&#13;
0x4006c5 &lt;+27&gt;: mov   -0x8(%rbp),%rax        # copy s to %rax<br/>&#13;
0x4006c9 &lt;+31&gt;: mov   -0x10(%rbp),%rcx       # copy nm to %rcx<br/>&#13;
0x4006cd &lt;+35&gt;: mov   $0x40,%edx             # copy 0x40 (or 64) to %edx<br/>&#13;
0x4006d2 &lt;+40&gt;: mov   %rcx,%rsi              # copy nm to %rsi<br/>&#13;
0x4006d5 &lt;+43&gt;: mov   %rax,%rdi              # copy s to %rdi<br/>&#13;
0x4006d8 &lt;+46&gt;: callq 0x400460 &lt;strncpy@plt&gt; #call strcnpy(s-&gt;name, nm, 64)</pre>&#13;
<p class="indent">This code snippet contains the previously undiscussed register (<code>%xmm0</code>) and instruction (<code>movss</code>). The <code>%xmm0</code> register is an example of a register reserved for floating-point values. The <code>movss</code> instruction indicates that the data being moved onto the call stack is of type single-precision floating point.</p>&#13;
<p class="indent">The next part (instructions <code>&lt;initStudent+51&gt;</code> through <code>&lt;initStudent+58&gt;</code>) places the value of the <code>gr</code> parameter at an offset of 0x44 (or 68) from the start of <code>s</code>. Revisiting the memory layout in <a href="ch07.xhtml#ch7fig13">Figure 7-13</a> shows that this address corresponds to <code>s-&gt;grad_yr</code>:</p>&#13;
<pre>0x4006dd &lt;+51&gt;: mov   -0x8(%rbp),%rax        # copy s to %rax<br/>&#13;
0x4006e1 &lt;+55&gt;: mov   -0x18(%rbp),%edx       # copy gr to %edx<br/>&#13;
0x4006e4 &lt;+58&gt;: mov   %edx,0x44(%rax)        # copy gr to %rax+0x44 (s-&gt;grad_yr)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_361"/>The next section (instructions <code>&lt;initStudent+61&gt;</code> through <code>&lt;initStudent+68&gt;</code>) copies the <code>ag</code> parameter to the <code>s-&gt;age</code> field of the <code>struct</code>, which is located at an offset of 0x40 (or 64) bytes from the address of <code>s</code>:</p>&#13;
<pre>0x4006e7 &lt;+61&gt;: mov   -0x8(%rbp),%rax        # copy s to %rax<br/>&#13;
0x4006eb &lt;+65&gt;: mov   -0x14(%rbp),%edx       # copy ag to %edx<br/>&#13;
0x4006ee &lt;+68&gt;: mov   %edx,0x40(%rax)        # copy ag to %rax+0x40 (s-&gt;age)</pre>&#13;
<p class="indent">Lastly, the <code>g</code> parameter value is copied to the <code>s-&gt;gpa</code> field (byte offset 72 or 0x48) of the <code>struct</code>. Notice the use of the <code>%xmm0</code> register since the data contained at location <code>%rbp-0x1c</code> is single-precision floating point:</p>&#13;
<pre>0x4006f1 &lt;+71&gt;: mov   -0x8(%rbp),%rax        # copy s to %rax<br/>&#13;
0x4006f5 &lt;+75&gt;: movss -0x1c(%rbp),%xmm0      # copy g to %xmm0<br/>&#13;
0x4006fa &lt;+80&gt;: movss %xmm0,0x48(%rax)       # copy g to %rax+0x48</pre>&#13;
<h4 class="h4" id="lev2_132">7.9.1 Data Alignment and structs</h4>&#13;
<p class="noindent">Consider the following modified declaration of <code>struct studentT</code>:</p>&#13;
<pre>struct studentTM {<br/>&#13;
    char name[63]; //updated to 63 instead of 64<br/>&#13;
    int  age;<br/>&#13;
    int  grad_yr;<br/>&#13;
    float gpa;<br/>&#13;
};<br/>&#13;
<br/>&#13;
struct studentTM student2;</pre>&#13;
<p class="indent">The size of the <code>name</code> field is modified to be 63 bytes, instead of the original 64. Consider how this affects the way the <code>struct</code> is laid out in memory. It may be tempting to visualize it as in <a href="ch07.xhtml#ch7fig14">Figure 7-14</a>.</p>&#13;
<div class="imagec" id="ch7fig14"><img alt="image" src="../images/07fig14.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-14: An incorrect memory layout for the updated <code>struct</code> <code>studentTM</code>. Note that the <code>name</code> field is reduced from 64 to 63 bytes.</em></p>&#13;
<p class="indent">In this depiction, the <code>age</code> field occurs in the byte immediately following the <code>name</code> field. But this is incorrect. <a href="ch07.xhtml#ch7fig15">Figure 7-15</a> depicts the actual layout in memory.</p>&#13;
<div class="imagec" id="ch7fig15"><img alt="image" src="../images/07fig15.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-15: The correct memory layout for the updated <code>struct</code> <code>studentTM</code>. Byte <em>x</em><sub>63</sub> is added by the compiler to satisfy memory alignment constraints, but it doesn’t correspond to any of the fields.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_362"/>x64’s alignment policy requires that two-byte data types (that is, <code>short</code>) reside at a two-byte-aligned address, four-byte data types (i.e., <code>int</code>, <code>float</code>, and <code>unsigned</code>) reside at four-byte-aligned addresses, whereas larger data types (<code>long</code>, <code>double</code>, and pointer data) reside at eight-byte-aligned addresses. For a <code>struct</code>, the compiler adds empty bytes as <em>padding</em> between fields to ensure that each field satisfies its alignment requirements. For example, in the <code>struct</code> declared in <a href="ch07.xhtml#ch7fig15">Figure 7-15</a> the compiler adds a byte of padding at byte <em>x</em><sub>63</sub> to ensure that the <code>age</code> field starts at an address that is at a multiple of four. Values aligned properly in memory can be read or written in a single operation, enabling greater efficiency.</p>&#13;
<p class="indent">Consider what happens when a <code>struct</code> is defined as follows:</p>&#13;
<pre>struct studentTM {<br/>&#13;
    int  age;<br/>&#13;
    int  grad_yr;<br/>&#13;
    float gpa;<br/>&#13;
    char name[63];<br/>&#13;
};<br/>&#13;
<br/>&#13;
struct studentTM student3;</pre>&#13;
<p class="indent">Moving the <code>name</code> array to the end ensures that <code>age</code>, <code>grad_yr</code>, and <code>gpa</code> are four-byte aligned. Most compilers will remove the filler byte at the end of the <code>struct</code>. However, if the <code>struct</code> is ever used in the context of an array (e.g., <code>struct studentTM courseSection[20];</code>) the compiler will once again add the filler byte as padding between each <code>struct</code> in the array to ensure that alignment requirements are properly met.</p>&#13;
<h3 class="h3" id="lev1_60">7.10 Real World: Buffer Overflow</h3>&#13;
<p class="noindent">The C language does not perform automatic array bounds checking. Accessing memory outside of the bounds of an array is problematic and often results in errors such as segmentation faults. However, a clever attacker can inject malicious code that intentionally overruns the boundary of an array (also known as a <em>buffer</em>) to force the program to execute in an unintended manner. In the worst cases, the attacker can run code that allows them to gain <em>root privilege</em>, or OS-level access to the computer system. A piece of software that takes advantage of the existence of a known buffer overrun error in a program is known as a <em>buffer overflow exploit</em>.</p>&#13;
<p class="indent">In this section, we use GDB and assembly language to fully characterize the mechanics of a buffer overflow exploit. Prior to reading this chapter we encourage you to explore “Debugging Assembly Code” on <a href="ch03.xhtml#lev1_24">page 177</a>.</p>&#13;
<h4 class="h4" id="lev2_133">7.10.1 Famous Examples of Buffer Overflow</h4>&#13;
<p class="noindent">Buffer overflow exploits emerged in the 1980s and remained a chief scourge of the computing industry through the early parts of the 2000s. While many modern operating systems have protections against the simplest buffer overflow <span epub:type="pagebreak" id="page_363"/>attacks, careless programming errors can still leave modern programs wide open to attack. Buffer overflow exploits have recently been discovered in Skype,<sup><a href="ch07.xhtml#fn7_3" id="rfn7_3">3</a></sup> Android,<sup><a href="ch07.xhtml#fn7_4" id="rfn7_4">4</a></sup> Google Chrome,<sup><a href="ch07.xhtml#fn7_5" id="rfn7_5">5</a></sup> and others.</p>&#13;
<p class="indent">Here are some notable historic examples of buffer overflow exploits.</p>&#13;
<h5 class="h5" id="lev3_61">The Morris Worm</h5>&#13;
<p class="noindent">The Morris Worm<sup><a href="ch07.xhtml#fn7_6" id="rfn7_6">6</a></sup> was released in 1998 on ARPANet from MIT (to hide that it was written by a student at Cornell) and exploited a buffer overrun vulnerability that existed in the Unix finger daemon (<code>fingerd</code>). In Linux and other Unix-like systems, a <em>daemon</em> is a type of process that continuously executes in the background, usually performing clean-up and monitoring tasks. The <code>fingerd</code> daemon returns a user-friendly report on a computer or person. Most crucially, the worm had a replication mechanism that caused it to be sent to the same computer multiple times, bogging down the system to an unusable state. Although the author claimed that the worm was meant as a harmless intellectual exercise, the replication mechanism enabled the worm to spread easily and made it difficult to remove. In future years, other worms would employ buffer overflow exploits to gain unauthorized access into systems. Notable examples include Code Red (2001), MS-SQLSlammer (2003), and W32/Blaster (2003).</p>&#13;
<h5 class="h5" id="lev3_62">AOL Chat Wars</h5>&#13;
<p class="noindent">David Auerbach,<sup><a href="ch07.xhtml#fn7_7" id="rfn7_7">7</a></sup> a former Microsoft engineer, detailed his experience with a buffer overflow during his efforts to integrate Microsoft’s Messenger Service (MMS) with AOL Instant Messenger in the late 1990s. Back then, AOL Instant Messenger (AIM) was <em>the</em> service to use if you wanted to instant message (or IM) friends and family. Microsoft tried to gain a foothold in this market by designing a feature in MMS that enabled MMS users to talk to their AIM “buddies.” Displeased, AOL patched their servers so that MMS could no longer connect to them. Microsoft engineers figured out a way for MMS clients to mimic the messages sent by AIM clients to AOL servers, making it difficult for AOL to distinguish between messages received by MMS and AIM. AOL responded by changing the way AIM sent messages, and MMS engineers duly changed their client’s messages to once again match AIM’s. This “chat war” continued until AOL started using a buffer overflow error <em>in their own client</em> to verify that sent messages came from AIM clients. Since MMS clients did not have the same vulnerability, the chat wars ended, with AOL as the victor.</p>&#13;
<h4 class="h4" id="lev2_134">7.10.2 A First Look: The Guessing Game</h4>&#13;
<p class="noindent">To help you understand the mechanism of the buffer overflow attack, we provide the executable of a simple program that enables the user to play a guessing game with the program. Download the <code>secret</code> executable<sup><a href="ch07.xhtml#fn7_8" id="rfn7_8">8</a></sup> and extract it using the <code>tar</code> command:</p>&#13;
<pre>$ <span class="codestrong1">tar -xzvf secretx86-64.tar.gz</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_364"/>In the following, we provide a copy of the main file associated with the executable:</p>&#13;
<p class="margnote">main.c</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;stdlib.h&gt;<br/>&#13;
#include "other.h" //contains secret function definitions<br/>&#13;
<br/>&#13;
/*prints out the You Win! message*/<br/>&#13;
void endGame(void) {<br/>&#13;
    printf("You win!\n");<br/>&#13;
    exit(0);<br/>&#13;
}<br/>&#13;
<br/>&#13;
/*main function of the game*/<br/>&#13;
int main() {<br/>&#13;
    int guess, secret, len, x=3<br/>&#13;
    char buf[12]; //buffer (12 bytes long)<br/>&#13;
<br/>&#13;
    printf("Enter secret number:\n");<br/>&#13;
    scanf("%s", buf); //read guess from user input<br/>&#13;
    guess = atoi(buf); //convert to an integer<br/>&#13;
<br/>&#13;
    secret = getSecretCode(); //call the getSecretCode function<br/>&#13;
<br/>&#13;
    //check to see if guess is correct<br/>&#13;
    if (guess == secret) {<br/>&#13;
        printf("You got it right!\n");<br/>&#13;
    }<br/>&#13;
    else {<br/>&#13;
        printf("You are so wrong!\n");<br/>&#13;
        return 1; //if incorrect, exit<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    printf("Enter the secret string to win:\n");<br/>&#13;
    scanf("%s", buf); //get secret string from user input<br/>&#13;
<br/>&#13;
    guess = calculateValue(buf, strlen(buf)); //call calculateValue function<br/>&#13;
<br/>&#13;
    //check to see if guess is correct<br/>&#13;
    if (guess != secret) {<br/>&#13;
        printf("You lose!\n");<br/>&#13;
        return 2; //if guess is wrong, exit<br/>&#13;
    }<br/>&#13;
<span epub:type="pagebreak" id="page_365"/>    /*if both the secret string and number are correct<br/>&#13;
    call endGame()*/<br/>&#13;
    endGame();<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="indent">This game prompts the user to enter first a secret number and then a secret string to win the guessing game. The header file <code>other.h</code> contains the definition of the <code>getSecretCode</code> and <code>calculateValue</code> functions, but it is unavailable to us. How then can a user beat the program? Brute forcing the solution will take too long. One strategy is to analyze the <code>secret</code> executable in GDB and step through the assembly to reveal the secret number and string. The process of examining assembly code to reveal knowledge of how it works is commonly referred to as <em>reverse engineering</em> assembly. Readers comfortable enough with their GDB and assembly reading skills should be able to figure out what the secret number and the secret string should be by using GDB to reverse engineer their values.</p>&#13;
<p class="indent">However, there is a different, sneakier way to win.</p>&#13;
<h4 class="h4" id="lev2_135">7.10.3 Taking a Closer Look (Under the C)</h4>&#13;
<p class="noindent">The program contains a potential buffer overrun vulnerability at the first call to <code>scanf</code>. To understand what is going on, let’s inspect the assembly code of the <code>main</code> function using GDB. Let’s also place a breakpoint at address 0x0000000000400717, which is the address of the instruction immediately before the call to <code>scanf</code> (note that placing the breakpoint at the address of <code>scanf</code> causes program execution to halt <em>inside</em> the call to <code>scanf</code>, not in <code>main</code>).</p>&#13;
<pre>   0x00000000004006f2 &lt;+0&gt;:   push   %rbp<br/>&#13;
   0x00000000004006f3 &lt;+1&gt;:   mov    %rsp,%rbp<br/>&#13;
   0x00000000004006f6 &lt;+4&gt;:   sub    $0x20,%rsp<br/>&#13;
   0x00000000004006fa &lt;+8&gt;:   movl   $0x3,-0x4(%rbp)<br/>&#13;
   0x0000000000400701 &lt;+15&gt;:  mov    $0x400873,%edi<br/>&#13;
   0x0000000000400706 &lt;+20&gt;:  callq  0x400500 &lt;printf@plt&gt;<br/>&#13;
   0x000000000040070b &lt;+25&gt;:  lea    -0x20(%rbp),%rax<br/>&#13;
   0x000000000040070f &lt;+29&gt;:  mov    %rax,%rsi<br/>&#13;
   0x0000000000400712 &lt;+32&gt;:  mov    $0x400888,%edi<br/>&#13;
=&gt; 0x0000000000400717 &lt;+37&gt;:  mov    $0x0,%eax<br/>&#13;
   0x000000000040071c &lt;+42&gt;:  callq  0x400540 &lt;scanf@plt&gt;</pre>&#13;
<p class="indent"><a href="ch07.xhtml#ch7fig16">Figure 7-16</a> depicts the stack immediately before the call to <code>scanf</code>.</p>&#13;
<span epub:type="pagebreak" id="page_366"/>&#13;
<div class="imagec" id="ch7fig16"><img alt="image" src="../images/07fig16.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-16: The call stack immediately before the call to <code>scanf</code></em></p>&#13;
<p class="indent">Prior to the call to <code>scanf</code>, the first two arguments for <code>scanf</code> are preloaded into registers <code>%edi</code> and <code>%rsi</code>, respectively. The <code>lea</code> instruction at location <code>&lt;main+25&gt;</code> creates the reference for array <code>buf</code>.</p>&#13;
<p class="indent">Now, suppose that the user enters <code>1234567890</code> at the prompt. <a href="ch07.xhtml#ch7fig17">Figure 7-17</a> illustrates what the stack looks like immediately after the call to <code>scanf</code> completes.</p>&#13;
<span epub:type="pagebreak" id="page_367"/>&#13;
<div class="imagec" id="ch7fig17"><img alt="image" src="../images/07fig17.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-17: The call stack immediately after the call to <code>scanf</code> with input <code>1234567890</code></em></p>&#13;
<p class="indent">Recall that the hex values for the ASCII encodings of the digits 0 to 9 are 0x30 to 0x39, and that each stack memory location is eight bytes long. The frame pointer is 32 bytes away from the stack pointer. Readers tracing along can confirm the value of <code>%rbp</code> by using GDB to print its value (<code>p</code> <code>$rbp</code>). In the example shown, the value of <code>%rbp</code> is 0x7fffffffdd10. The following command allows the reader to inspect the 48 bytes (in hex) below <code>%rsp</code>:</p>&#13;
<pre>(gdb) <span class="codestrong1">x /48bx $rsp</span></pre>&#13;
<p class="indent">This GDB command yields output that looks similar to the following:</p>&#13;
<pre>(gdb) <span class="codestrong1">x /48bx $rsp</span><br/>&#13;
0x7fffffffdcf0: 0x31  0x32  0x33  0x34  0x35  0x36  0x37  0x38<br/>&#13;
0x7fffffffdcf8: 0x39  0x30  0x00  0x00  0x00  0x00  0x00  0x00<br/>&#13;
0x7fffffffdd00: 0xf0  0xdd  0xff  0xff  0xff  0x7f  0x00  0x00<br/>&#13;
0x7fffffffdd08: 0x00  0x00  0x00  0x00  0x03  0x00  0x00  0x00<br/>&#13;
0x7fffffffdd10: 0xd0  0x07  0x40  0x00  0x00  0x00  0x00  0x00<br/>&#13;
0x7fffffffdd18: 0x30  0xd8  0xa2  0xf7  0xff  0x7f  0x00  0x00</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_368"/>Each line represents one 64-bit address, or two 32-bit addresses. So, the value associated with the 32-bit address 0x7fffffffdd0c is located at the rightmost four bytes of the line showing 0x7fffffffdd08.</p>&#13;
<p class="note"><strong><span class="black">Note</span> MULTIBYTE VALUES ARE STORED IN LITTLE-ENDIAN ORDER</strong></p>&#13;
<p class="note1">In the preceding assembly segment, the byte at address 0xf7ffffffdd00 is 0xf0, the byte at address 0xf7ffffffdd01 is 0xdd, the byte at address 0xf7ffffffdd02 is 0xff, the byte at address 0xf7ffffffdd03 is 0xff, the byte at address 0xf7ffffffdd04 is 0xff, and the byte at address 0xf7ffffffdd05 is 0x7f. However, the 64-bit <em>value</em> at address 0x7fffffffdd00 is in fact 0x7fffffffddf0. Remember that since x86-64 is a little-endian system (see “Integer Byte Order” on <a href="ch04.xhtml#lev1_34">page 224</a>), the bytes for multibyte values such as addresses are stored in reverse order.</p>&#13;
<p class="indent">In this example, the address for <code>buf</code> is located at the top of the stack. Therefore, the first two addresses hold the inputted bytes associated with the input string 1234567890:</p>&#13;
<pre>0x7fffffffdcf0: 0x31  0x32  0x33  0x34  0x35  0x36  0x37  0x38<br/>&#13;
0x7fffffffdcf8: 0x39  0x30  0x00  0x00  0x00  0x00  0x00  0x00</pre>&#13;
<p class="indent">The null termination byte <code>\0</code> appears in the third most significant byte location at address 0x7fffffffdcf8 (i.e., at address 0x7fffffffdcfa). Recall that <code>scanf</code> terminates all strings with a null byte.</p>&#13;
<p class="indent">Of course, 1234567890 is not the secret number. Here is the output when we try to run <code>secret</code> with input string 1234567890:</p>&#13;
<pre>$ <span class="codestrong1">./secret</span><br/>&#13;
Enter secret number:<br/>&#13;
<span class="codestrong1">1234567890</span><br/>&#13;
You are so wrong!<br/>&#13;
$ <span class="codestrong1">echo $?</span><br/>&#13;
1</pre>&#13;
<p class="indent">The <code>echo $?</code> command prints out the return value of the last executed command in the shell. In this case, the program returned 1 because the secret number we entered is wrong. Recall that by convention, programs return 0 when there are no errors. Our goal going forward is to trick the program into exiting with a return value of 0, indicating that we won the game.</p>&#13;
<h4 class="h4" id="lev2_136">7.10.4 Buffer Overflow: First Attempt</h4>&#13;
<p class="noindent">Next, let’s try typing in the string <span class="codestrong">1234567890123456789012345678901234567890123</span>:</p>&#13;
<pre>$ <span class="codestrong1">./secret</span><br/>&#13;
Enter secret number:<br/>&#13;
<span class="codestrong1">1234567890123456789012345678901234567890123</span><br/>&#13;
You are so wrong!<br/>&#13;
Segmentation fault (core dumped)<br/>&#13;
<span epub:type="pagebreak" id="page_369"/>$ <span class="codestrong1">echo $?</span><br/>&#13;
139</pre>&#13;
<p class="indent">Interesting! Now the program crashes with a segmentation fault, with return code 139. <a href="ch07.xhtml#ch7fig18">Figure 7-18</a> shows what the call stack for <code>main</code> looks like immediately after the call to <code>scanf</code> with this new input.</p>&#13;
<div class="imagec" id="ch7fig18"><img alt="image" src="../images/07fig18.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-18: The call stack immediately after the call to <code>scanf</code> with input 1234567890123456789012345678901234567890123</em></p>&#13;
<p class="indent">The input string is so long that it not only overwrote the values stored at 0xd08 and 0xd10, but it spilled over into the return address below the stack frame for <code>main</code>. Recall that when a function returns, the program tries to resume execution at the address specified by the return address. In this example, the program tries to resume execution at address 0xf7ff00333231 after exiting <code>main</code>, which does not appear to exist. So the program crashes with a segmentation fault.</p>&#13;
<p class="indent">Rerunning the program in GDB (<code>input.txt</code> contains the input string above) reveals this devilry in action:</p>&#13;
<pre>$ <span class="codestrong1">gdb secret</span><br/>&#13;
(gdb) <span class="codestrong1">break *0x0000000000400717</span><br/>&#13;
(gdb) <span class="codestrong1">run &lt; input.txt</span><br/>&#13;
(gdb) <span class="codestrong1">ni</span><br/>&#13;
(gdb) <span class="codestrong1">x /48bx $rsp</span><br/>&#13;
0x7fffffffdcf0: 0x31  0x32  0x33  0x34  0x35  0x36  0x37  0x38<br/>&#13;
0x7fffffffdcf8: 0x39  0x30  0x31  0x32  0x33  0x34  0x35  0x36<br/>&#13;
0x7fffffffdd00: 0x37  0x38  0x39  0x30  0x31  0x32  0x33  0x34<br/>&#13;
0x7fffffffdd08: 0x35  0x36  0x37  0x38  0x39  0x30  0x31  0x32<br/>&#13;
<span epub:type="pagebreak" id="page_370"/>0x7fffffffdd10: 0x33  0x34  0x35  0x36  0x37  0x38  0x39  0x30<br/>&#13;
0x7fffffffdd18: 0x31  0x32  0x33  0x00  0xff  0x7f  0x00  0x00<br/>&#13;
(gdb) <span class="codestrong1">n</span><br/>&#13;
Single stepping until exit from function main,<br/>&#13;
which has no line number information.<br/>&#13;
You are so wrong!<br/>&#13;
0x00007fff00333231 in ?? ()</pre>&#13;
<p class="indent">Notice that our input string blew past the stated limits of the array <code>buf</code>, overwriting all the other values stored on the stack. In other words, our string created a buffer overrun and corrupted the call stack, causing the program to crash. This process is also known as <em>smashing the stack</em>.</p>&#13;
<h4 class="h4" id="lev2_137">7.10.5 A Smarter Buffer Overflow: Second Attempt</h4>&#13;
<p class="noindent">Our first example smashed the stack by overwriting the <code>%rbp</code> register and return address with junk, causing the program to crash. An attacker whose goal is to simply crash a program would be satisfied at this point. However, our goal is to trick the guessing game to return 0, indicating that we won the game. We accomplish this by filling the call stack with data more meaningful than junk values. For example, we could overwrite the stack so that the return address is replaced with the address of <code>endGame</code>. Then, when the program attempts to return from <code>main</code>, it will instead execute <code>endGame</code> rather than crashing with a segmentation fault.</p>&#13;
<p class="indent">To find out the address of <code>endGame</code>, let’s inspect <code>secret</code> again in GDB:</p>&#13;
<pre>$ <span class="codestrong1">gdb secret</span><br/>&#13;
(gdb) <span class="codestrong1">disas endGame</span><br/>&#13;
Dump of assembler code for function endGame:<br/>&#13;
   0x00000000004006da &lt;+0&gt;:   push   %rbp<br/>&#13;
   0x00000000004006db &lt;+1&gt;:   mov    %rsp,%rbp<br/>&#13;
   0x00000000004006de &lt;+4&gt;:   mov    $0x40086a,%edi<br/>&#13;
   0x00000000004006e3 &lt;+9&gt;:   callq  0x400500 &lt;puts@plt&gt;<br/>&#13;
   0x00000000004006e8 &lt;+14&gt;:  mov    $0x0,%edi<br/>&#13;
   0x00000000004006ed &lt;+19&gt;:  callq  0x400550 &lt;exit@plt&gt;<br/>&#13;
End of assembler dump.</pre>&#13;
<p class="indent">Observe that <code>endGame</code> starts at address 0x00000000004006da. <a href="ch07.xhtml#ch7fig19">Figure 7-19</a> illustrates a sample exploit that forces <code>secret</code> to run the <code>endGame</code> function.</p>&#13;
<span epub:type="pagebreak" id="page_371"/>&#13;
<div class="imagec" id="ch7fig19"><img alt="image" src="../images/07fig19.jpg"/></div>&#13;
<p class="figcap"><em>Figure 7-19: A sample string that can force <code>secret</code> to execute the <code>endGame</code> function</em></p>&#13;
<p class="indent">Essentially, there are 40 bytes of junk values followed by the return address. Again, because x86-64 is a little-endian system, the bytes in the return address appear to be in reverse order.</p>&#13;
<p class="indent">The following program illustrates how an attacker could construct the preceding exploit:</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
char ebuff[]=<br/>&#13;
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x30" /*first 10 bytes of junk*/<br/>&#13;
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x30" /*next 10 bytes of junk*/<br/>&#13;
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x30" /*following 10 bytes of junk*/<br/>&#13;
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x30" /*last 10 bytes of junk*/<br/>&#13;
"\xda\x06\x40\x00\x00\x00\x00\x00" /*address of endGame (little endian)*/<br/>&#13;
;<br/>&#13;
<br/>&#13;
int main(void) {<br/>&#13;
    int i;<br/>&#13;
    for (i = 0; i &lt; sizeof(ebuff); i++) { /*print each character*/<br/>&#13;
        printf("%c", ebuff[i]);<br/>&#13;
    }<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="indent">The <code>\x</code> before each number indicates that the number is formatted as the hexadecimal representation of a character. After defining <code>ebuff[]</code>, the <span epub:type="pagebreak" id="page_372"/><code>main</code> function simply prints it out, character by character. To get the associated byte string, compile and run this program as follows:</p>&#13;
<pre>$ <span class="codestrong1">gcc -o genEx genEx.c</span><br/>&#13;
$ <span class="codestrong1">./genEx &gt; exploit</span></pre>&#13;
<p class="indent">To use the file <code>exploit</code> as input to <code>scanf</code>, it suffices to run <code>secret</code> with <code>exploit</code> as follows:</p>&#13;
<pre>$ <span class="codestrong1">./secret &lt; exploit</span><br/>&#13;
Enter secret number:<br/>&#13;
You are so wrong!<br/>&#13;
You win!</pre>&#13;
<p class="indent">The program prints out “You are so wrong!” since the string contained in <code>exploit</code> is <em>not</em> the secret number. However, the program also prints out the string “You win!” Recall, though, that our goal is to trick the program to return 0. In a larger system, where the notion of “success” is tracked by an external program, it is often most important what a program returns, not what it prints out.</p>&#13;
<p class="indent">Checking the return value yields:</p>&#13;
<pre>$ <span class="codestrong1">echo $?</span><br/>&#13;
0</pre>&#13;
<p class="indent">Our exploit works! We won the game!</p>&#13;
<h4 class="h4" id="lev2_138">7.10.6 Protecting Against Buffer Overflow</h4>&#13;
<p class="noindent">The example we showed changed the control flow of the <code>secret</code> executable, forcing it to return a zero value associated with success. However, an exploit like this could do some real damage. Furthermore, some older computer systems <em>executed</em> bytes from stack memory. If an attacker placed bytes associated with assembly instructions on the call stack, the CPU would interpret the bytes as <em>real</em> instructions, enabling the attacker to force the CPU to execute <em>any arbitrary code of their choosing</em>. Fortunately, there are strategies that modern computer systems employ to make it more difficult for attackers to run buffer overflow exploits:</p>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><strong>Stack randomization.</strong>   The OS allocates the starting address of the stack at a random location in stack memory, causing the position/size of the call stack to vary from one run of a program to another. Multiple machines running the same code would have different stack addresses. Modern Linux systems use stack randomization as a standard practice. However, a determined attacker can brute force the attack, by attempting to repeat attacks with different addresses. A common trick is to use a <em>NOP sled</em> (i.e., a large number of <code>nop</code> instructions) before the actual exploit code. Executing the <code>nop</code> instruction (<code>0x90</code>) has no effect, other than causing the program counter to increment to the next instruction. As long as the attacker can get the CPU to execute somewhere in the NOP <span epub:type="pagebreak" id="page_373"/>sled, the NOP sled will eventually lead to the exploit code that follows it. Aleph One’s writeup<sup><a href="ch07.xhtml#fn7_9" id="rfn7_9">9</a></sup> details the mechanism of this type of attack.</p>&#13;
<p class="ul-noindent"><strong>Stack corruption detection.</strong>   Another line of defense is to try to detect when the stack is corrupted. Recent versions of GCC use a stack protector known as a <em>canary</em> that acts as a guard between the buffer and the other elements of the stack. A canary is a value stored in a nonwriteable section of memory that can be compared to a value put on the stack. If the canary “dies” during a program’s execution, the program knows that it is under attack and aborts with an error message. A clever attacker can, however, replace the canary to prevent the program from detecting stack corruption.</p>&#13;
<p class="ul-noindent"><strong>Limiting executable regions.</strong>   In this line of defense, executable code is restricted to only particular regions of memory. In other words, the call stack is no longer executable. However, even this defense can be defeated. In an attack utilizing <em>return-oriented programming</em> (ROP), an attacker can “cherry-pick” instructions in executable regions and jump from instruction to instruction to build an exploit. There are some famous examples of this online, especially in video games.<sup><a href="ch07.xhtml#fn7_10" id="rfn7_10">10</a></sup></p>&#13;
</div>&#13;
<p class="indent">However, the best line of defense is always the programmer. To prevent buffer overflow attacks on your programs, use C functions with <em>length specifiers</em> whenever possible and add code that performs array bounds checking. It is crucial that any defined arrays match the chosen length specifiers. <a href="ch07.xhtml#ch7tab19">Table 7-19</a> lists some common “bad” C functions that are vulnerable to buffer overflow and the corresponding “good” function to use (assume that <code>buf</code> is allocated 12 bytes).</p>&#13;
<p class="tabcap" id="ch7tab19"><strong>Table 7-19:</strong> C Functions with Length Specifiers</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Instead of</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Use</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>gets(buf)</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>fgets(buf, 12, stdin)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>scanf("%s", buf)</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>scanf("%12s", buf)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>strcpy(buf2, buf)</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>strncpy(buf2, buf, 12)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>strcat(buf2, buf)</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>strncat(buf2, buf, 12)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>sprintf(buf, "%d", num)</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><code>snprintf(buf, 12, "%d", num)</code></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">The <code>secret2</code> binary<sup><a href="ch07.xhtml#fn7_11" id="rfn7_11">11</a></sup> no longer has the buffer overflow vulnerability. Here’s the <code>main</code> function of this new binary:</p>&#13;
<p class="margnote">main2.c</p>&#13;
<pre>#include &lt;stdio.h&gt;<br/>&#13;
#include &lt;stdlib.h&gt;<br/>&#13;
#include "other.h" //contain secret function definitions<br/>&#13;
<br/>&#13;
/*prints out the You Win! message*/<br/>&#13;
void endGame(void) {<br/>&#13;
    printf("You win!\n");<br/>&#13;
    exit(0);<br/>&#13;
}<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_374"/>/*main function of the game*/<br/>&#13;
int main() {<br/>&#13;
    int guess, secret, len, x=3<br/>&#13;
    char buf[12]; //buffer (12 bytes long)<br/>&#13;
<br/>&#13;
    printf("Enter secret number:\n");<br/>&#13;
    scanf("%12s", buf); //read guess from user input (fixed!)<br/>&#13;
    guess = atoi(buf); //convert to an integer<br/>&#13;
<br/>&#13;
    secret=getSecretCode(); //call the getSecretCode function<br/>&#13;
<br/>&#13;
    //check to see if guess is correct<br/>&#13;
    if (guess == secret) {<br/>&#13;
        printf("You got it right!\n");<br/>&#13;
    }<br/>&#13;
    else {<br/>&#13;
        printf("You are so wrong!\n");<br/>&#13;
        return 1; //if incorrect, exit<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    printf("Enter the secret string to win:\n");<br/>&#13;
    scanf("%12s", buf); //get secret string from user input (fixed!)<br/>&#13;
<br/>&#13;
    guess = calculateValue(buf, strlen(buf)); //call calculateValue function<br/>&#13;
<br/>&#13;
    //check to see if guess is correct<br/>&#13;
    if (guess != secret) {<br/>&#13;
        printf("You lose!\n");<br/>&#13;
        return 2; //if guess is wrong, exit<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    /*if both the secret string and number are correct<br/>&#13;
    call endGame()*/<br/>&#13;
    endGame();<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</pre>&#13;
<p class="indent">Notice that we added a length specifier to all calls of <code>scanf</code>, causing the <code>scanf</code> function to stop reading from the input after the first 12 bytes are read. The exploit string no longer breaks the program:</p>&#13;
<pre>$ <span class="codestrong1">./secret2 &lt; exploit</span><br/>&#13;
Enter secret number:<br/>&#13;
You are so wrong!<br/>&#13;
$ <span class="codestrong1">echo $?</span><br/>&#13;
1</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_375"/>Of course, any reader with basic reverse-engineering skills can still win the guessing game by analyzing the assembly code. If you haven’t tried to beat the program yet with reverse engineering, we encourage you to do so now.</p>&#13;
<h3 class="h3" id="lev1_61">Notes</h3>&#13;
<p class="fnote"><a href="ch07.xhtml#rfn7_1" id="fn7_1">1.</a> Edsger Dijkstra,“Go To Statement Considered Harmful,” <em>Communications of the ACM</em> 11(3), pp. 147–148, 1968.</p>&#13;
<p class="fnote"><a href="ch07.xhtml#rfn7_2" id="fn7_2">2.</a> <em><a href="https://diveintosystems.org/book/C7-x86_64/recursion.html">https://diveintosystems.org/book/C7-x86_64/recursion.html</a></em></p>&#13;
<p class="fnote"><a href="ch07.xhtml#rfn7_3" id="fn7_3">3.</a> Mohit Kumar, “Critical Skype Bug Lets Hackers Remotely Execute Malicious Code,” <em><a href="https://thehackernews.com/2017/06/skype-crash-bug.html">https://thehackernews.com/2017/06/skype-crash-bug.html</a></em>, 2017.</p>&#13;
<p class="fnote"><a href="ch07.xhtml#rfn7_4" id="fn7_4">4.</a> Tamir Zahavi-Brunner, “CVE-2017-13253: Buffer overflow in multiple Android DRM services,” <em><a href="https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/">https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/</a></em>, 2018.</p>&#13;
<p class="fnote"><a href="ch07.xhtml#rfn7_5" id="fn7_5">5.</a> Tom Spring, “Google Patches ‘High Severity’ Browser Bug,” <em><a href="https://threatpost.com/google-patches-high-severity-browser-bug/128661/">https://threatpost.com/google-patches-high-severity-browser-bug/128661/</a></em>, 2017.</p>&#13;
<p class="fnote"><a href="ch07.xhtml#rfn7_6" id="fn7_6">6.</a> Christopher Kelty, “The Morris Worm,” <em>Limn Magazine</em>, Issue 1: Systemic Risk, 2011. <em><a href="https://limn.it/articles/the-morris-worm/">https://limn.it/articles/the-morris-worm/</a></em></p>&#13;
<p class="fnote"><a href="ch07.xhtml#rfn7_7" id="fn7_7">7.</a> David Auerbach, “Chat Wars: Microsoft vs. AOL,” <em>NplusOne Magazine</em>, Issue 19, Spring 2014. <em><a href="https://nplusonemag.com/issue-19/essays/chat-wars/">https://nplusonemag.com/issue-19/essays/chat-wars/</a></em></p>&#13;
<p class="fnote"><a href="ch07.xhtml#rfn7_8" id="fn7_8">8.</a> <em><a href="https://diveintosystems.org/book/C7-x86_64/_attachments/secretx86-64.tar.gz">https://diveintosystems.org/book/C7-x86_64/_attachments/secretx86-64.tar.gz</a></em></p>&#13;
<p class="fnote"><a href="ch07.xhtml#rfn7_9" id="fn7_9">9.</a> Aleph One, “Smashing the Stack for Fun and Profit,” <em><a href="http://insecure.org/stf/smashstack.html">http://insecure.org/stf/smashstack.html</a></em>, 1996.</p>&#13;
<p class="fnote1"><a href="ch07.xhtml#rfn7_10" id="fn7_10">10.</a> DotsAreCool, “Super Mario World Credit Warp” (Nintendo ROP example), <em><a href="https://youtu.be/vAHXK2wut_I">https://youtu.be/vAHXK2wut_I</a></em>, 2015.</p>&#13;
<p class="fnote1"><a href="ch07.xhtml#rfn7_11" id="fn7_11">11.</a> <em><a href="https://diveintosystems.org/book/C7-x86_64/_attachments/secret2x86-64.tar.gz">https://diveintosystems.org/book/C7-x86_64/_attachments/secret2x86-64.tar.gz</a></em></p>&#13;
<span epub:type="pagebreak" id="page_376"/>&#13;
</body></html>