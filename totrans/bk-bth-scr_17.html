<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch16" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="title" id="ch16">
<span class="cn"><span aria-label=" Page 167. " epub:type="pagebreak" id="pg_167" role="doc-pagebreak" class="calibre2"/><span class="sans_dogma_ot_bold_b_">16</span></span>
<span class="ct1"><span class="sans_dogma_ot_bold_b_">CODE BLOCKS</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="407" src="../images/chapter.jpg" width="408"/>
</figure>
<p class="chapterintro">A <i class="calibre13">code block</i> can sometimes be a rather generic term, referring to some amorphous section of a program or a few lines of code. In Batch, it’s a well-defined entity: one or more commands in between a set of open and close parentheses. A prominent example is the code often executed when an <span class="sans_thesansmonocd_w5regular_1">if</span> command is true.</p>
<p class="tx">That seems simple enough, but it’s far more difficult to use a code block properly and wisely than it is to define it. A very powerful feature of Batch is that delayed expansion allows you to resolve variables in two distinct ways inside a code block, but the uninitiated often misinterpret that functionality as a bug. In this chapter, I’ll detail all the intricacies involved, and you’ll also learn how code blocks, specifically naked code blocks, provide an interesting technique for allowing a variable to survive code of limited scope. If that doesn’t yet sound impressive, I’m confident that it will soon.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="h" id="sec1"><span id="h1-113"/><span aria-label=" Page 168. " epub:type="pagebreak" id="pg_168" role="doc-pagebreak"/><span class="sans_futura_std_bold_b_">Resolving Variables in a Code Block</span></h3>
<p class="tni">I discussed in detail the process of setting and resolving a variable in <span class="xref"><a href="chapter2.xhtml" class="calibre3">Chapter 2</a></span>, but those rules change inside of a code block. As I’ll soon demonstrate, this is a great feature of Batch, but it’s often misunderstood and can result in a perplexed and cranky coder. Even after many years of Batch coding, it’s still easy to stumble into this particular issue from time to time. While I usually find and fix the issue relatively quickly (after letting out an audible “D’oh!”), it can lead to hours of frustration for more novice coders. This batveat is best described with an example.</p>
<p class="tx">On many occasions, co-workers have presented me with an apparently simple code snippet such as the one in <a href="#Lis16-1" class="calibre3">Listing 16-1</a>.</p>
<span id="Lis16-1"/>
<pre class="pre"><code class="calibre11">set price=$450
if %bSale% (
   set price=$350
   &gt; con echo The sale price of a 50-inch TV is %price%.
)
</code></pre>
<p class="listingcaption"><span class="futura_std_book_oblique_i_">Listing 16-1: A variable set and resolved in a code block ... and a mystery</span></p>
<p class="tni">The code block is accompanied by an exasperated query:</p>
<p class="blockquotesingle">A variable has an initial setting, but I’m resetting it to something else and it doesn’t seem to “take.” I’m setting the price of a 50-inch TV to $450, and I know that the <span class="sans_thesansmonocd_w5regular_">bSale</span> boolean is true because the <span class="sans_thesansmonocd_w5regular_">echo</span> to the console happens, but the variable’s not being reset to $350. The <span class="sans_thesansmonocd_w5regular_">echo</span> command writes out $450. It’s as if the first command inside the code block doesn’t execute while the second one does. Crazy, huh? To test this theory, I moved only the <span class="sans_thesansmonocd_w5regular_">echo</span> command from inside the <span class="sans_thesansmonocd_w5regular_">if</span> command code block to just after it. Suddenly, I get the sale price to display like I wanted, but that’s not a solution because I want to execute the command only if there’s a sale. I even tried not setting the variable prior to the <span class="sans_thesansmonocd_w5regular_">if</span> command, but then it resolved to nothing at all. Ugh! This makes no sense. What’s going on?</p>
<p class="tx">The quick and much too brief reply is, “Replace the percent signs with exclamation marks.” The only change needed to <a href="#Lis16-1" class="calibre3">Listing 16-1</a> is the resolution of <span class="sans_thesansmonocd_w5regular_">price</span> at the end of the <span class="sans_thesansmonocd_w5regular_">echo</span> command:</p>
<pre class="pre"><code class="calibre11">set price=$450
if %bSale% (
   set price=$350
   &gt; con echo The sale price of a 50-inch TV is !price!.
)
</code></pre>
<p class="tni">The result is what the confounded coder had expected all along:</p>
<pre class="pre"><code class="calibre11">The sale price of a 50-inch TV is $350.</code></pre>
<p class="tx"><span aria-label=" Page 169. " epub:type="pagebreak" id="pg_169" role="doc-pagebreak"/>After the coder incredulously tries and sees the exclamation marks work, they typically return more peeved than relieved and with the combination of another query and a new complaint: “Sometimes you use percent signs to resolve a variable, and at other times, you use exclamation marks. What kind of a programmatical sadist would dream this up? Isn’t Batch esoteric enough? When I set a variable, I expect it to be set. Period. What possible use could this have?” The only variations in this diatribe are in its intensity and level of vulgarity. These comments are from a very subdued and pious co-worker. Before addressing the question of this feature’s use, I owe you a far better explanation of what’s going on with the <span class="sans_thesansmonocd_w5regular_">price</span> variable.</p>
<p class="tx">The coexistence of two values of a variable is another application of delayed expansion, first introduced in <span class="xref"><a href="chapter3.xhtml" class="calibre3">Chapter 3</a></span>, which allows for the resolution of variables at either parse time or execution time. When a variable is set inside a code block, you can think of it as having two values at one time. One is the current value to which it was set in the code block, resolved at execution time. The other is the value assigned to it as it entered the code block, resolved at parse time.</p>
<p class="tx">If a variable simultaneously has two distinct values, we need two different means of resolving the variable. To that end, <i class="calibre6">percent signs are the delimiter for revealing its value as it entered the code block</i>, and <i class="calibre6">exclamation marks are the delimiter for retrieving its current value inside of the code block</i>. The code can reset a variable multiple times in the code block, and percent sign delimiters will still resolve it to its state before entering the code block.</p>
<p class="tx">The upshot is that at the time of the <span class="sans_thesansmonocd_w5regular_">echo</span> command in <a href="#Lis16-1" class="calibre3">Listing 16-1</a>, <span class="sans_thesansmonocd_w5regular_">%price%</span> resolves to <span class="sans_thesansmonocd_w5regular_">$450</span>, and <span class="sans_thesansmonocd_w5regular_">!price!</span> resolves to <span class="sans_thesansmonocd_w5regular_">$350</span>.</p>
<p class="tx">Despite my co-worker’s protestation, this isn’t sadistic at all; it actually represents a fascinating feature that’s lacking in most programming languages. The ability for a single variable to hold two values may be hard to grasp, but once understood, it offers many possibilities. To demonstrate, I’ll alter the message written to the console in <a href="#Lis16-1" class="calibre3">Listing 16-1</a>. Instead of just giving the sale price, it would be easier to see the savings by showing both the original and sale prices. I’m using the same <span class="sans_thesansmonocd_w5regular_">price</span> variable for both values in <a href="#Lis16-2" class="calibre3">Listing 16-2</a>—once resolved with percent signs and once with exclamation marks.</p>
<span id="Lis16-2"/>
<pre class="pre"><code class="calibre11">set price=$450
if %bSale% (
   set price=$350
   &gt; con echo A 50-inch TV has been marked down from %price% to !price!.
)
</code></pre>
<p class="listingcaption"><span class="futura_std_book_oblique_i_">Listing 16-2: A variable resolved to two distinct values</span></p>
<p class="tx">This makes a great deal of sense intrinsically because both values are in fact a <i class="calibre6">price</i>; one is the original price, and the other is the sale price. You could have used two different variables, perhaps <span class="sans_thesansmonocd_w5regular_">origPrice</span> and <span class="sans_thesansmonocd_w5regular_">salePrice</span>, but coders with a discerning eye might describe <a href="#Lis16-2" class="calibre3">Listing 16-2</a> as elegant, <span aria-label=" Page 170. " epub:type="pagebreak" id="pg_170" role="doc-pagebreak"/>the greatest of all possible praises of its author, especially after seeing the output:</p>
<pre class="pre"><code class="calibre11">A 50-inch TV has been marked down from $450 to $350.</code></pre>
<p class="tx">This feature allows the imaginative coder many possibilities. You might have a counter or a variable tallying up numbers, both updated inside of a loop. (In the next few chapters, I’ll finally get to the <span class="sans_thesansmonocd_w5regular_">for</span> command and looping.) While inside that loop, you might want access to the original counter or tally value for comparison. A data condition in some iterations of the loop might alert you to the fact that the loop shouldn’t have been processed. Without this feature, you’ll need to execute the loop once for validation and another time for the core logic. With delayed expansion, you’ll need only one loop, and at any point you can restore all variables to their original values and abandon the loop.</p>
<p class="tx">This does beg the question as to what happens in nested code blocks. Are there three active values for a variable defined inside an <span class="sans_thesansmonocd_w5regular_">if</span> command code block nested inside another <span class="sans_thesansmonocd_w5regular_">if</span> command code block? No. There are exactly two values; one is its value before entering the outermost code block, and the other is its current value inside the code blocks, regardless of the level of nesting.</p>
<p class="tx">F. Scott Fitzgerald famously wrote, “The test of a first-rate intelligence is the ability to hold two opposing ideas in mind at the same time and still retain the ability to function.” I’ve insulted the interpreter’s intelligence in past chapters, but Batch’s ability to function in this duality does suggest that I may have been too harsh. Maybe the interpreter can handle advanced topics, even theoretical physics. The <span class="sans_thesansmonocd_w5regular_">SchrodingersCat</span> variable can simultaneously hold two values: <span class="sans_thesansmonocd_w5regular_">alive</span> and <span class="sans_thesansmonocd_w5regular_">dead</span>.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="h" id="sec2"><span id="h1-114"/><span class="sans_futura_std_bold_b_">The Naked Code Block</span></h3>
<p class="tni">In the prior examples, I dealt only with variables inside the code block of an <span class="sans_thesansmonocd_w5regular_">if</span> command, but everything previously discussed in this chapter applies to any code block. Remember that a code block is really just one or more commands inside a set of parentheses.</p>
<p class="tx">Another example of a code block is the code that comes after the <span class="sans_thesansmonocd_w5regular_">else</span> keyword of an <span class="sans_thesansmonocd_w5regular_">if</span> command. I’ve already hinted that the <span class="sans_thesansmonocd_w5regular_">for</span> command uses code blocks, and those code blocks can become very complex with nesting and with multiple variables being assigned and reassigned often. That’s why this chapter is the final prerequisite to the upcoming discussion on the most significant Batch command. But code blocks don’t have to be associated with a command at all.</p>
<p class="tx">A <i class="calibre6">naked code block</i> is created as its own entity and not associated with a command such as the <span class="sans_thesansmonocd_w5regular_">if</span> or <span class="sans_thesansmonocd_w5regular_">for</span>. For instance, we can rewrite the <span class="sans_thesansmonocd_w5regular_">if</span> command from <a href="#Lis16-2" class="calibre3">Listing 16-2</a> without the <span class="sans_thesansmonocd_w5regular_">if</span> and the conditional clause. The naked code block in <a href="#Lis16-3" class="calibre3">Listing 16-3</a> looks a bit odd at first, but notice that everything is identical except that I have removed the text <span class="sans_thesansmonocd_w5regular_">if %bSale%</span>.</p>
<span id="Lis16-3"/>
<pre class="pre"><code class="calibre11"><span aria-label=" Page 171. " epub:type="pagebreak" id="pg_171" role="doc-pagebreak"/>set price=$450
(
   set price=$350
   &gt; con echo A 50-inch TV has been marked down from %price% to !price!.
)
</code></pre>
<p class="listingcaption"><span class="futura_std_book_oblique_i_">Listing 16-3: A naked code block where price has two values</span></p>
<p class="tni">This code is still setting the <span class="sans_thesansmonocd_w5regular_">price</span> variable to the original price before entering the code block, where we reset the variable to the sale price.</p>
<p class="tx">In the output we see the same text including both prices, with the only difference being that the code always writes the following to the console, because what was conditional logic now executes unconditionally:</p>
<pre class="pre"><code class="calibre11">A 50-inch TV has been marked down from $450 to $350.</code></pre>
<p class="tx">To truly demonstrate the power of these parentheses, simply remove them and examine the effect. That’s exactly what I’ve done here, and I didn’t even realign the indenting, although doing so would have absolutely no effect on the result. Compare this to <a href="#Lis16-3" class="calibre3">Listing 16-3</a>:</p>
<pre class="pre"><code class="calibre11">set price=$450
   set price=$350
   &gt; con echo A 50-inch TV has been marked down from %price% to !price!.
</code></pre>
<p class="tx">In practice, this code makes no sense. The fact that we’re setting the variable on one line and resetting it on the very next completely obviates the first <span class="sans_thesansmonocd_w5regular_">set</span> command, which might as well be commented out or deleted. The <span class="sans_thesansmonocd_w5regular_">price</span> variable now has a single value, and percent signs and exclamation marks both resolve the variable to its sole value of <span class="sans_thesansmonocd_w5regular_">$350</span>, resulting in the nonsensical output:</p>
<pre class="pre"><code class="calibre11">A 50-inch TV has been marked down from $350 to $350.</code></pre>
<p class="tx">The set of parentheses had a marked effect on the code listing. They created a naked code block, allowing the variable to have two values, each accessible with different delimiters. Without the parentheses, the code is junk.</p>
<p class="tx">When using a naked code block, it’s good form to always line up the open and close parentheses in the same column on unadulterated lines with the code in the code block indented as if it followed an <span class="sans_thesansmonocd_w5regular_">if</span> command. You could rewrite <a href="#Lis16-3" class="calibre3">Listing 16-3</a> with the second <span class="sans_thesansmonocd_w5regular_">set</span> command on the same line as the open parenthesis and the close parenthesis trailing the <span class="sans_thesansmonocd_w5regular_">echo</span> command, but doing so would make the code very difficult to read. (I don’t even want to show it.) If you’re coding a naked code block, there’s probably a good reason for it, and if you hide its existence, an elegant solution suddenly turns cryptic.</p>
<p class="tx"><span aria-label=" Page 172. " epub:type="pagebreak" id="pg_172" role="doc-pagebreak"/>One good reason for using a naked code block is to swap the values of two variables without an intermediate variable. This code turns <span class="sans_thesansmonocd_w5regular_">fact</span> into <span class="sans_thesansmonocd_w5regular_">fiction</span> and <span class="sans_thesansmonocd_w5regular_">fiction</span> into <span class="sans_thesansmonocd_w5regular_">fact</span> better than any politician:</p>
<pre class="pre"><code class="calibre11">(
   set fact=%fiction%
   set fiction=%fact%
)
</code></pre>
<p class="tx">The first <span class="sans_thesansmonocd_w5regular_">set</span> command is simply resetting the <span class="sans_thesansmonocd_w5regular_">fact</span> variable, but the second <span class="sans_thesansmonocd_w5regular_">set</span> command isn’t using this updated value when it resets <span class="sans_thesansmonocd_w5regular_">fiction</span>. Instead, the percent signs resolve <span class="sans_thesansmonocd_w5regular_">fact</span> to its value before entering the naked code block. The interpreter reads and parses both <span class="sans_thesansmonocd_w5regular_">set</span> commands—and resolves both variables—before setting either variable. If you were to remove the parentheses, both variables would take on the value initially defined as <span class="sans_thesansmonocd_w5regular_">fiction</span>, completely defeating the value swap.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="h" id="sec3"><span id="h1-115"/><span class="sans_futura_std_bold_b_">Surviving an endlocal Command</span></h3>
<p class="tni">Any code block, but specifically the naked code block, has another very useful purpose: allowing a variable to survive an <span class="sans_thesansmonocd_w5regular_">endlocal</span> command. In <span class="xref"><a href="chapter3.xhtml" class="calibre3">Chapter 3</a></span>, you learned that all variables between a <span class="sans_thesansmonocd_w5regular_">setlocal</span> command and an <span class="sans_thesansmonocd_w5regular_">endlocal</span> command will revert to their prior state once the <span class="sans_thesansmonocd_w5regular_">endlocal</span> executes. This wonderful Batch feature ensures that a called routine doesn’t step on variables that might be used by the caller, but it raises a very pertinent question. How can that called routine return a result if nothing can survive its <span class="sans_thesansmonocd_w5regular_">endlocal</span> command?</p>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="h1" id="sec4"><span id="h2-44"/><span class="sans_futura_std_heavy_oblique_bi_">The “Problem” with the endlocal Command</span></h4>
<p class="tni">To demonstrate the problem, the routine shown in <a href="#Lis16-4" class="calibre3">Listing 16-4</a> accepts a monetary amount as dollars and cents as its first parameter and attempts to pass back that amount with a 6 percent sales tax added as its second parameter.</p>
<span id="Lis16-4"/>
<pre class="pre"><code class="calibre11">:AddTax
 setlocal
 set factor=106
 set inAmt=%~1
 set amtNoDec=%inAmt:.=%
 set /A wTaxNoDec = amtNoDec * factor + 50
 set wTaxDec=%wTaxNoDec:~0,-4%.%wTaxNoDec:~-4,2%
<span aria-label="annotation1" class="codeannotationhang1">❶</span> set %2=%wTaxDec%
<span aria-label="annotation2" class="codeannotationhang1">❷</span> endlocal
 goto :eof
</code></pre>
<p class="listingcaption"><span class="futura_std_book_oblique_i_">Listing 16-4: Some good math wasted</span></p>
<p class="tx">For now, don’t get bogged down in the math. (See the “An Arithmetic Digression for My Fellow Math Geeks” box for those details.) Pertinent to <span aria-label=" Page 173. " epub:type="pagebreak" id="pg_173" role="doc-pagebreak"/>this discussion, the <span class="sans_thesansmonocd_w5regular_">:AddTax</span> routine starts with a <span class="sans_thesansmonocd_w5regular_">setlocal</span> command, followed by six <span class="sans_thesansmonocd_w5regular_">set</span> commands. The last <span class="sans_thesansmonocd_w5regular_">set</span> command <span aria-label="annotation1" class="codeannotation">❶</span> assigns the result of the arithmetic to the second parameter, but the <span class="sans_thesansmonocd_w5regular_">endlocal</span> command <span aria-label="annotation2" class="codeannotation">❷</span> immediately wipes it out. Nothing’s returned. I’m trying to protect or hide changes to the first five variables from being seen by the code outside of the routine, but I also want to let this last variable through. As of yet, I’m unsuccessful.</p>
<p class="tx">After some contemplation, it might make sense to reverse the commands before the <span class="sans_thesansmonocd_w5regular_">goto :eof</span>:</p>
<pre class="pre"><code class="calibre11">endlocal
set %2=%wTaxDec%
goto :eof
</code></pre>
<p class="tx">But alas, that doesn’t work either. Now, the <span class="sans_thesansmonocd_w5regular_">wTaxDec</span> variable doesn’t survive the <span class="sans_thesansmonocd_w5regular_">endlocal</span>, so this logic most likely sets the return parameter to nothing at all (or whatever value <span class="sans_thesansmonocd_w5regular_">wTaxDec</span> was set to prior to the routine). It’s a different manifestation of the same issue; nothing set between the <span class="sans_thesansmonocd_w5regular_">setlocal</span> and the <span class="sans_thesansmonocd_w5regular_">endlocal</span> survives.</p>
<aside aria-label="box-3" class="box">
<p class="boxtitle" id="box-3"><span class="sans_futura_std_bold_b_">AN ARITHMETIC DIGRESSION FOR MY FELLOW MATH GEEKS</span></p>
<p class="boxbodyfirst"><span class="sans_futura_std_book_">The best way to add 6 percent to an amount is to multiply it by 1.06, but since Batch doesn’t intrinsically support floating-point numbers or decimals, I’ll ultimately multiply the amount by a</span> <span class="sans_thesansmonocd_w5regular_">factor</span> <span class="sans_futura_std_book_">of</span> <span class="sans_thesansmonocd_w5regular_">106</span> <span class="sans_futura_std_book_">and then deal with the skewed place value.</span></p>
<p class="boxbody"><span class="sans_futura_std_book_">To start, I set the “amount with no decimal point” (</span><span class="sans_thesansmonocd_w5regular_">amtNoDec</span><span class="sans_futura_std_book_">) to the input amount (</span><span class="sans_thesansmonocd_w5regular_">inAmt</span><span class="sans_futura_std_book_">) with its decimal removed. The</span> <span class="sans_thesansmonocd_w5regular_">set /A</span> <span class="sans_futura_std_book_">command multiplies the two integers to produce the “with tax amount with no decimal” (</span><span class="sans_thesansmonocd_w5regular_">wTaxNoDec</span><span class="sans_futura_std_book_">) while adding</span> <span class="sans_thesansmonocd_w5regular_">50</span> <span class="sans_futura_std_book_">to the product solely for the sake of rounding. Since both numbers have in essence been multiplied by 100, the product is 10,000 times the actual amount, so adding</span> <span class="sans_thesansmonocd_w5regular_">50</span> <span class="sans_futura_std_book_">amounts to adding a mere half cent.</span></p>
<p class="boxbody"><span class="sans_futura_std_book_">To get the final result of</span> <span class="sans_thesansmonocd_w5regular_">wTaxDec</span><span class="sans_futura_std_book_">, or the “with tax amount with a decimal,” we must essentially divide the prior number by 10,000. Two substrings, one with a length of</span> <span class="sans_thesansmonocd_w5regular_">-4</span> <span class="sans_futura_std_book_">and the other with an offset of</span> <span class="sans_thesansmonocd_w5regular_">-4</span><span class="sans_futura_std_book_">, break up the number into two values, four bytes from its end. I then insert a decimal point between the two substrings, while also truncating the last two bytes off the second with a length of</span> <span class="sans_thesansmonocd_w5regular_">2</span><span class="sans_futura_std_book_">, thus leaving the result as dollars and cents. If this doesn’t look familiar, refer to <a href="chapter6.xhtml" class="calibre3">Chapter 6</a>.</span></p>
<p class="boxbodylast"><span class="sans_futura_std_book_">This code assumes the input is formatted just so, and it isn’t bullet-proof. The dollar amount must contain exactly two numbers after the decimal denoting the cents, and there mustn’t be a leading zero, so 0.99 and anything less than 10 cents won’t work. OCTAL!</span></p>
</aside>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="h1" id="sec5"><span id="h2-45"/><span aria-label=" Page 174. " epub:type="pagebreak" id="pg_174" role="doc-pagebreak"/><span class="sans_futura_std_heavy_oblique_bi_">The Naked Code Block Solution</span></h4>
<p class="tni">The simple addition of two parentheses (and some indentation for readability) creates a code block starting with an <span class="sans_thesansmonocd_w5regular_">endlocal</span> command—and solves the problem. Compare this to <a href="#Lis16-4" class="calibre3">Listing 16-4</a>:</p>
<pre class="pre"><code class="calibre11">:AddTax
 setlocal
 set factor=106
 set inAmt=%~1
 set amtNoDec=%inAmt:.=%
 set /A wTaxNoDec = amtNoDec * factor + 50
 set wTaxDec=%wTaxNoDec:~0,-4%.%wTaxNoDec:~-4,2%
 (
    endlocal
    set %2=%wTaxDec%
 )
 goto :eof
</code></pre>
<p class="tx">The open parenthesis starts the code block. The <span class="sans_thesansmonocd_w5regular_">endlocal</span> command wipes out the <i class="calibre6">current</i> state of the five variables, returning them to their pre-<span class="sans_thesansmonocd_w5regular_">setlocal</span> states. Now it gets interesting. Exclamation marks resolve a variable to its current state inside the code block, but percent signs resolve a variable to its state at the beginning of the code block before the <span class="sans_thesansmonocd_w5regular_">endlocal</span> executed. Hence, <span class="sans_thesansmonocd_w5regular_">!wTaxDec!</span> resolves to nothing (or junk), but <span class="sans_thesansmonocd_w5regular_">%wTaxDec%</span> resolves to the value to which it was assigned just before the code block, and that’s the value I’m assigning to the second parameter just before getting out of the routine.</p>
<p class="tx">The upshot is that there’s a narrow window inside the naked code block—between the <span class="sans_thesansmonocd_w5regular_">endlocal</span> and the close parenthesis—where we can resolve these five variables with percent signs. I’ve capitalized on this window by using percent signs to resolve the only one that I want, assigning its value to the return parameter.</p>
<p class="tx">Now we just need to call the routine to see it work:</p>
<pre class="pre"><code class="calibre11">call :AddTax 25.75 result
&gt; con echo The amount with tax is $%result%.
</code></pre>
<p class="tx">The following output shows the 6 percent sales tax successfully added to the original amount:</p>
<pre class="pre"><code class="calibre11">The amount with tax is $27.30.</code></pre>
<p class="tx">This example sets a parameter being returned by a routine, but a routine isn’t a requirement of this technique. At any point in a bat file, you can hide variables by invoking a <span class="sans_thesansmonocd_w5regular_">setlocal</span> command. In the following example, two variables, <span class="sans_thesansmonocd_w5regular_">survive</span> and <span class="sans_thesansmonocd_w5regular_">persist</span>, survive the <span class="sans_thesansmonocd_w5regular_">endlocal</span> in the code block, but <span class="sans_thesansmonocd_w5regular_">extinct</span> does not:</p>
<pre class="pre"><code class="calibre11"><span aria-label=" Page 175. " epub:type="pagebreak" id="pg_175" role="doc-pagebreak"/>setlocal
set survive=This variable will survive the endlocal
set persist=Multiple variables can survive and persist past the endlocal
set extinct=Time is very short for this variable
(
   endlocal
   set survive=%survive%
   set persist=%persist%
)
</code></pre>
<p class="tx">This code block is similar to the prior example, but there are two pertinent differences. First, it’s preserving multiple variables. Second, the <span class="sans_thesansmonocd_w5regular_">set</span> commands look redundant—each variable is being set to its own resolved value. The current value of each variable is null after the <span class="sans_thesansmonocd_w5regular_">endlocal</span>, but the last two <span class="sans_thesansmonocd_w5regular_">set</span> commands are restoring the variable’s own values from just before the code block.</p>
<p class="tx">This technique is simple yet unintuitive. An <span class="sans_thesansmonocd_w5regular_">endlocal</span> command starts a naked code block, followed by one or more <span class="sans_thesansmonocd_w5regular_">set</span> commands assigning variables, often to themselves. The world outside of the naked code block can now use the shared variables, but not any unshared variables. If you want to do this assignment conditionally, simply place an <span class="sans_thesansmonocd_w5regular_">if</span> command with the conditional clause of your choosing around the <span class="sans_thesansmonocd_w5regular_">set</span> command inside the naked code block.</p>
<p class="tx">I must admit that there’s an alternative solution for this task not involving the naked code block. Part of me regrets even sharing it, but I will because you might just run across it someday. You can also make these two variables survive an <span class="sans_thesansmonocd_w5regular_">endlocal</span> by replacing the prior naked code block with these three commands on this one very ugly line of code:</p>
<pre class="pre"><code class="calibre11">endlocal&amp;set survive=%survive%&amp;set persist=%persist%</code></pre>
<p class="tni">Adding a space or two after each command separator (<span class="sans_thesansmonocd_w5regular_">&amp;</span>) might make this a bit more readable, but not nearly enough. Use the naked code block.</p>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="h" id="sec6"><span id="h1-116"/><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">In this chapter, you learned exactly how variables are resolved in code blocks. The next time you hear someone say, “Use exclamation marks inside and percent signs outside of a code block,” I hope that you’ll have the knowledge to add a little more depth to the conversation. Now that you’ve learned the nuances concerning delayed expansion and variable resolution in a code block, you won’t just manage to make something work; you’ll be able to use both values contained in a variable where appropriate. I also introduced the naked code block and demonstrated its crucial role in allowing variables to survive an <span class="sans_thesansmonocd_w5regular_">endlocal</span> command.</p>
<p class="tx">Next up is the long-awaited <span class="sans_thesansmonocd_w5regular_">for</span> command. We now have everything in place to explore this greatly important Batch command in <span class="xref"><a href="part2.xhtml" class="calibre3">Part II</a></span>.</p>
</section>
</section>
</div></body></html>