<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Garbage Collection in MRI, JRuby, and Rubinius"><div class="titlepage"><div><div><h1 class="title"><a id="garbage_collection_in_mricomma_jrubycomm"/>Chapter 12. Garbage Collection in MRI, JRuby, and Rubinius</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="informalfigure"><div class="mediaobject"><a id="med_id00269"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1853819.png.jpg"/></div></div><p><a class="indexterm" id="iddle1031"/><span class="emphasis"><em>The garbage collector is where Ruby objects are born and where they die.</em></span></p></blockquote></div><p><a class="indexterm" id="iddle1308"/><a class="indexterm" id="iddle1545"/><a class="indexterm" id="iddle1584"/><span class="emphasis"><em>Garbage collection (GC)</em></span> is the process high-level languages like Ruby use to manage memory for you. Where do your Ruby objects live while you’re using them? How does Ruby clean up objects your program no longer uses? Ruby’s GC system solves these problems.</p><p>Garbage collection is not unique to Ruby. The first implementation of garbage collection was in the Lisp programming language, invented by John McCarthy around 1960. Like Ruby, Lisp manages memory for you automatically using garbage collection. Since its invention, garbage collection has been the subject of decades of computer science research and has become an important feature of numerous computer languages, including Java, C#, and, of course, Ruby.</p><p>Computer scientists have invented many different algorithms for performing garbage collection. As it turns out, MRI uses the same GC algorithm John McCarthy invented over 50 years ago: <span class="emphasis"><em>mark-and-sweep garbage collection</em></span>. JRuby and Rubinius, on the other hand, use a different algorithm, invented just a few years later in 1963: <span class="emphasis"><em>copying garbage collection</em></span>. They also employ another innovation called <span class="emphasis"><em>generational garbage collection</em></span> and can even perform GC tasks in a separate thread while your application continues to run using <span class="emphasis"><em>concurrent garbage collection</em></span>. In this chapter we’ll touch on the basic ideas behind these complex GC algorithms. The MRI, JRuby, and Rubinius garbage collectors use more complex versions of these algorithms, but the same fundamental principles apply.</p><div class="sidebar"><a id="roadmap-id00045"/><p class="title">Roadmap</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch12.html#garbage_collectors_solve_three_problems" title="Garbage Collectors Solve Three Problems">Garbage Collectors Solve Three Problems</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#garbage_collection_in_mri_mark_and_sweep" title="Garbage Collection in MRI: Mark and Sweep">Garbage Collection in MRI: Mark and Sweep</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch12.html#free_list" title="The Free List">The Free List</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#mriapostrophes_use_of_multiple_free_list" title="MRI’S Use of Multiple Free Lists">MRI’S Use of Multiple Free Lists</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#marking" title="Marking">Marking</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#how_does_mri_mark_live_objectsquestion_m" title="How Does MRI Mark Live Objects?">How Does MRI Mark Live Objects?</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#sweeping" title="Sweeping">Sweeping</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#lazy_sweeping" title="Lazy Sweeping">Lazy Sweeping</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#rvalue_structure" title="The RVALUE Structure">The RVALUE Structure</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#disadvantages_of_mark_and_sweep" title="Disadvantages of Mark and Sweep">Disadvantages of Mark and Sweep</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch12.html#experiment_12-1_seeing_mri_garbage_colle" title="Experiment 12-1: Seeing MRI Garbage Collection in Action">Experiment 12-1: Seeing MRI Garbage Collection in Action</a></strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch12.html#seeing_mri_perform_a_lazy_sweep" title="Seeing MRI Perform a Lazy Sweep">Seeing MRI Perform a Lazy Sweep</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#seeing_mri_perform_a_full_collection" title="Seeing MRI Perform a Full Collection">Seeing MRI Perform a Full Collection</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#interpreting_a_gc_profile_report" title="Interpreting a GC Profile Report">Interpreting a GC Profile Report</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch12.html#garbage_collection_in_jruby_and_rubinius" title="Garbage Collection in JRuby and Rubinius">Garbage Collection in JRuby and Rubinius</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#copying_garbage_collection" title="Copying Garbage Collection">Copying Garbage Collection</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch12.html#bump_allocation" title="Bump Allocation">Bump Allocation</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#semi-space_algorithm" title="The Semi-Space Algorithm">The Semi-Space Algorithm</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#eden_heap" title="The Eden Heap">The Eden Heap</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch12.html#generational_garbage_collection" title="Generational Garbage Collection">Generational Garbage Collection</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch12.html#weak_generational_hypothesis" title="The Weak Generational Hypothesis">The Weak Generational Hypothesis</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#using_the_semi-space_algorithm_for_young" title="Using the Semi-Space Algorithm for Young Objects">Using the Semi-Space Algorithm for Young Objects</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#promoting_objects" title="Promoting Objects">Promoting Objects</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#garbage_collection_for_mature_objects" title="Garbage Collection for Mature Objects">Garbage Collection for Mature Objects</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#references_between_generations" title="References Between Generations">References Between Generations</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch12.html#concurrent_garbage_collection" title="Concurrent Garbage Collection">Concurrent Garbage Collection</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch12.html#marking_while_the_object_graph_changes" title="Marking While the Object Graph Changes">Marking While the Object Graph Changes</a></p></li><li class="listitem"><p><a class="indexterm" id="iddle1300"/><a class="indexterm" id="iddle1320"/><a class="indexterm" id="iddle1325"/><a class="indexterm" id="iddle1327"/><a class="indexterm" id="iddle1338"/><a class="indexterm" id="iddle1399"/><a class="indexterm" id="iddle1546"/><a class="indexterm" id="iddle1548"/><a class="indexterm" id="iddle1567"/><a class="indexterm" id="iddle1569"/><a class="indexterm" id="iddle1708"/><a class="indexterm" id="iddle1834"/><a class="xref" href="ch12.html#tricolor_marking" title="Tricolor Marking">Tricolor Marking</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#three_garbage_collectors_in_the_jvm" title="Three Garbage Collectors in the JVM">Three Garbage Collectors in the JVM</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch12.html#experiment_12-2_using_verbose_gc_mode_in" title="Experiment 12-2: Using Verbose GC Mode in JRuby">Experiment 12-2: Using Verbose GC Mode in JRuby</a></strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch12.html#triggering_major_collections" title="Triggering Major Collections">Triggering Major Collections</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch12.html#further_reading" title="Further Reading">Further Reading</a></p></li><li class="listitem"><p><a class="xref" href="ch12.html#summary-id00048" title="Summary">Summary</a></p></li></ul></div></div><div class="sect1" title="Garbage Collectors Solve Three Problems"><div class="titlepage"><div><div><h1 class="title"><a id="garbage_collectors_solve_three_problems"/>Garbage Collectors Solve Three Problems</h1></div></div></div><p>Despite its name, garbage collection is not only the process of cleaning up garbage objects. Garbage collectors, in fact, solve three problems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>They <span class="emphasis"><em>allocate</em></span> memory for use by new objects.</p></li><li class="listitem"><p>They <span class="emphasis"><em>identify</em></span> which objects your program is no longer using.</p></li><li class="listitem"><p>They <span class="emphasis"><em>reclaim</em></span> memory from unused objects.</p></li></ul></div><p>Ruby’s GC system is no different. When you create a new Ruby object, the garbage collector allocates memory for that object. Later, Ruby’s garbage collector determines when your program has stopped using the object so it can reuse that memory to create new Ruby objects. Allocating memory and reclaiming memory are two sides of the same coin; it makes sense for Ruby’s garbage collector to perform both tasks.</p></div><div class="sect1" title="Garbage Collection in MRI: Mark and Sweep"><div class="titlepage"><div><div><h1 class="title"><a id="garbage_collection_in_mri_mark_and_sweep"/>Garbage Collection in MRI: Mark and Sweep</h1></div></div></div><p>A great place to start learning about garbage collection is MRI’s relatively simple GC algorithm, which is similar to the one used by John McCarthy in 1960 with his groundbreaking work on Lisp. Once we understand how the algorithm works, we’ll look at the more complex garbage collection in JRuby and Rubinius and explore how MRI is adopting some of their techniques.</p><p>MRI’s <span class="emphasis"><em>mark-and-sweep</em></span> algorithm hands your program memory for new objects until the available memory, or <span class="emphasis"><em>heap</em></span>, is exhausted, at which point MRI stops your program and <span class="emphasis"><em>marks</em></span> the objects that variables or other objects in your code still hold a reference to as <span class="emphasis"><em>live objects</em></span>. Ruby then <span class="emphasis"><em>sweeps</em></span> up the remaining objects, called <span class="emphasis"><em>garbage objects</em></span>, allowing their memory to be reused. Once this process is complete, Ruby allows your program to continue again.</p><div class="sect2" title="The Free List"><div class="titlepage"><div><div><h2 class="title"><a id="free_list"/>The Free List</h2></div></div></div><p>Standard MRI Ruby uses McCarthy’s original allocation solution, which is called the <span class="emphasis"><em>free list</em></span>. <a class="xref" href="ch12.html#conceptual_view_of_the_free_list_insid" title="Figure 12-1. A conceptual view of the free list inside MRI">Figure 12-1</a> shows what a free list looks like conceptually.</p><div class="figure"><a id="conceptual_view_of_the_free_list_insid"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00270"/><img alt="A conceptual view of the free list inside MRI" src="httpatomoreillycomsourcenostarchimages1854349.png"/></div></div><p class="title">Figure 12-1. A conceptual view of the free list inside MRI</p></div><p><a class="indexterm" id="iddle1452"/><a class="indexterm" id="iddle1707"/><a class="indexterm" id="iddle1956"/>Each white square in the diagram represents a small piece of memory that is available for creating new objects. Think of this diagram as a linked list of unused Ruby objects. When you create a new Ruby object, MRI pulls a free memory block from the head of the list and uses it to create a new Ruby object, as shown in <a class="xref" href="ch12.html#ruby_has_taken_the_first_memory_block_fr" title="Figure 12-2. Ruby has taken the first memory block from the free list and used it to create a new Ruby object.">Figure 12-2</a>.</p><div class="figure"><a id="ruby_has_taken_the_first_memory_block_fr"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00271"/><img alt="Ruby has taken the first memory block from the free list and used it to create a new Ruby object." src="httpatomoreillycomsourcenostarchimages1854351.png"/></div></div><p class="title">Figure 12-2. Ruby has taken the first memory block from the free list and used it to create a new Ruby object.</p></div><p>The gray box in this figure is an allocated, live object. The remaining white boxes are still available. Internally all Ruby objects are represented by a C structure called <code class="literal">RVALUE</code>. MRI uses a C <span class="emphasis"><em>union</em></span> inside <code class="literal">RVALUE</code> to encompass all of the C structures we’ve seen so far in MRI, such as <code class="literal">RArray</code>, <code class="literal">RString</code>, <code class="literal">RRegexp</code>, and so on. In other words, each square could be any kind of Ruby object or an instance of a custom Ruby class (via <code class="literal">RObject</code>). The contents of each object, such as the characters in a string, are often stored in a separate memory location.</p><p>As your program starts to allocate more new objects, MRI takes more new <code class="literal">RVALUE</code> structures from the free list, and the list of unused values shrinks, as shown in <a class="xref" href="ch12.html#as_your_program_creates_more_objectscomm" title="Figure 12-3. As your program creates more objects, MRI starts to use up the free list.">Figure 12-3</a>.</p><div class="figure"><a id="as_your_program_creates_more_objectscomm"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00272"/><img alt="As your program creates more objects, MRI starts to use up the free list." src="httpatomoreillycomsourcenostarchimages1854353.png"/></div></div><p class="title">Figure 12-3. As your program creates more objects, MRI starts to use up the free list.</p></div><div class="sidebar"><a id="mriapostrophes_use_of_multiple_free_list"/><p class="title">MRI’S Use of Multiple Free Lists</p><p>When MRI starts to execute a Ruby script, it allocates memory for use in the free list. It sets the length of the initial free list to about 10,000 <code class="literal">RVALUE</code> structures, which means that MRI can create 10,000 Ruby objects without allocating more memory. As more objects are needed, MRI allocates more memory, placing more empty RVALUEs onto the free list.</p><p>Rather than create a single, long linked list with 10,000 elements, Ruby divides the allocated memory into subsections known as <span class="emphasis"><em>heaps</em></span> in the MRI source code, each about 16k in size. It then creates a free list for each of these heaps, initially creating 24 lists of 407 objects each, using some of the remaining memory for other internal data structures.</p><p>Because there are multiple free lists, MRI repeatedly returns <code class="literal">RVALUE</code> structures from one free list until it’s empty and then steps to another free list, returning more structures from that second list. In this way, MRI iterates over the available free lists until they are all empty.</p></div></div><div class="sect2" title="Marking"><div class="titlepage"><div><div><h2 class="title"><a id="marking"/>Marking</h2></div></div></div><p><a class="indexterm" id="iddle1076"/><a class="indexterm" id="iddle1339"/><a class="indexterm" id="iddle1549"/><a class="indexterm" id="iddle1572"/><a class="indexterm" id="iddle1576"/><a class="indexterm" id="iddle1741"/><a class="indexterm" id="iddle1920"/>As your program runs, it creates new objects, and eventually MRI uses up all remaining objects on the free list. At that point, the GC system stops your program, identifies objects that your code is no longer using, and reclaims their memory for allocation to new objects. If no unused objects are found, Ruby asks the operating system for more memory; if there is none to be had, Ruby throws an out-of-memory exception and stops.</p><p>Objects that your program allocated but that are no longer being used are known as <span class="emphasis"><em>garbage objects</em></span>. To identify garbage objects, MRI traverses pointers in your objects’ C structures, following references from one to another in order to find all active objects (see <a class="xref" href="ch12.html#ruby_follows_pointerscomma_or_references" title="Figure 12-4. Ruby follows pointers, or references, from one object to another, starting with a root object on the left.">Figure 12-4</a>). MRI knows your code is no longer using an object if it finds no references to them.</p><div class="figure"><a id="ruby_follows_pointerscomma_or_references"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00273"/><img alt="Ruby follows pointers, or references, from one object to another, starting with a root object on the left." src="httpatomoreillycomsourcenostarchimages1854355.png.jpg"/></div></div><p class="title">Figure 12-4. Ruby follows pointers, or references, from one object to another, starting with a root object on the left.</p></div><p>The gray box on the left is a <span class="emphasis"><em>root object</em></span>, a global variable that you create or an internal object that Ruby knows your application must be using. There are typically many root objects at any given time. The arrows represent references from this root object to other objects, which in turn may contain references to other objects. This network of objects and references is known as the <span class="emphasis"><em>object graph</em></span>. MRI marks each Ruby object that it finds as it traverses the object graph, stopping your program during the marking process in order to insure that no new object references are created.</p><p>Once the marking process completes, the heap contains a series of objects, both marked and unmarked, as shown in <a class="xref" href="ch12.html#mri_has_marked_five_active_objects_left" title="Figure 12-5. MRI has marked five active objects (gray) with five garbage objects remaining in the heap (white).">Figure 12-5</a>. The marked objects are <span class="emphasis"><em>live</em></span>, which means your code is actively using them. The unmarked objects are garbage, meaning Ruby can release or reclaim their memory. Your code is still using the marked objects, so their memory must be preserved.</p><div class="figure"><a id="mri_has_marked_five_active_objects_left"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00274"/><img alt="MRI has marked five active objects (gray) with five garbage objects remaining in the heap (white)." src="httpatomoreillycomsourcenostarchimages1854357.png.jpg"/></div></div><p class="title">Figure 12-5. MRI has marked five active objects (gray) with five garbage objects remaining in the heap (white).</p></div></div><div class="sect2" title="How Does MRI Mark Live Objects?"><div class="titlepage"><div><div><h2 class="title"><a id="how_does_mri_mark_live_objectsquestion_m"/>How Does MRI Mark Live Objects?</h2></div></div></div><p>MRI saves the information about marked and unmarked objects using a technique known as <span class="emphasis"><em>bitmap marking</em></span>. Bitmap marking refers to the technique <a class="indexterm" id="iddle1210"/><a class="indexterm" id="iddle1299"/><a class="indexterm" id="iddle1531"/><a class="indexterm" id="iddle1571"/><a class="indexterm" id="iddle1575"/><a class="indexterm" id="iddle2038"/>of saving the live object marks as a series of bits in a data structure known as the <span class="emphasis"><em>free bitmap</em></span> (see <a class="xref" href="ch12.html#mri_saves_the_gc_mark_flags_in_a_separat" title="Figure 12-6. MRI saves the GC mark flags in a separate data structure known as the free bitmap.">Figure 12-6</a>). MRI uses a separate memory structure to hold the free bitmap and doesn’t save the marks near the objects.</p><div class="figure"><a id="mri_saves_the_gc_mark_flags_in_a_separat"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00275"/><img alt="MRI saves the GC mark flags in a separate data structure known as the free bitmap." src="httpatomoreillycomsourcenostarchimages1854359.png"/></div></div><p class="title">Figure 12-6. MRI saves the GC mark flags in a separate data structure known as the <span class="emphasis"><em>free bitmap</em></span>.</p></div><p>The reason to use a separate memory structure for the mark bits has to do with a Unix memory optimization technique called <span class="emphasis"><em>copy-on-write</em></span> (see <a class="xref" href="ch10.html#copy-on-write" title="Copy-on-Write">Copy-on-Write</a>). Similar to how Ruby shares memory between different strings that contain the same letters, copy-on-write allows Unix processes to share memory that contains the same values. By saving the mark bits separately, MRI maximizes the amount of memory that will contain the same values across processes. (In Ruby 1.9 and earlier, the mark bits were saved inside each <code class="literal">RVALUE</code> structure, causing the garbage collector to modify almost all of Ruby’s shared memory while marking live objects and rendering the copy-on-write optimization ineffective.)</p></div><div class="sect2" title="Sweeping"><div class="titlepage"><div><div><h2 class="title"><a id="sweeping"/>Sweeping</h2></div></div></div><p>Having identified garbage objects, it’s time to reclaim them. Ruby’s GC algorithm places the unmarked objects back on the free list, as shown in <a class="xref" href="ch12.html#while_sweepingcomma_mri_places_unused_rv" title="Figure 12-7. While sweeping, MRI places unused RVALUE structures back on the free list.">Figure 12-7</a>.</p><div class="figure"><a id="while_sweepingcomma_mri_places_unused_rv"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00276"/><img alt="While sweeping, MRI places unused RVALUE structures back on the free list." src="httpatomoreillycomsourcenostarchimages1854361.png"/></div></div><p class="title">Figure 12-7. While sweeping, MRI places unused <code class="literal">RVALUE</code> structures back on the free list.</p></div><p>The process of moving unused objects back onto the free list is referred to as <span class="emphasis"><em>sweeping</em></span> the objects. Normally this process runs very quickly because MRI doesn’t actually copy objects; it simply adjusts the pointers in each <code class="literal">RVALUE</code> to create the free linked list (the solid arrows in <a class="xref" href="ch12.html#while_sweepingcomma_mri_places_unused_rv" title="Figure 12-7. While sweeping, MRI places unused RVALUE structures back on the free list.">Figure 12-7</a>).</p></div><div class="sect2" title="Lazy Sweeping"><div class="titlepage"><div><div><h2 class="title"><a id="lazy_sweeping"/>Lazy Sweeping</h2></div></div></div><p>Beginning with version 1.9.3, MRI introduced an optimization known as <span class="emphasis"><em>lazy sweeping</em></span>. The lazy sweep algorithm reduces the amount of time a program is stopped by the garbage collector. (Remember, during the normal mark and sweep, MRI stops executing your code.)</p><p><a class="indexterm" id="iddle1331"/><a class="indexterm" id="iddle1957"/>Lazy sweeping sweeps only enough garbage objects back to the free list to create a few new Ruby objects and to allow your program to continue, thus reducing the amount of time required to sweep. Ruby sweeps all of the garbage <code class="literal">RVALUE</code> objects found in only one of MRI’s internal heap structures back to that heap’s free list. If no garbage objects are found in the current heap, Ruby tries a lazy sweep on the next heap and works its way through the remaining heaps. (We’ll see this algorithm at work in <a class="xref" href="ch12.html#experiment_12-1_seeing_mri_garbage_colle" title="Experiment 12-1: Seeing MRI Garbage Collection in Action">Experiment 12-1: Seeing MRI Garbage Collection in Action</a>.)</p><p>Lazy sweeping can reduce the amount of time your program is paused waiting for garbage collection; however, it doesn’t reduce the overall amount of garbage collection work to do. Lazy sweeping amortizes the same total amount of sweeping work over multiple GC pauses.</p><div class="sidebar"><a id="rvalue_structure"/><p class="title">The RVALUE Structure</p><p>You can find the definition of the <code class="literal">RVALUE</code> C structure in the <span class="emphasis"><em>gc.c</em></span> MRI source code file, which contains the implementation of MRI’s garbage collector. <a class="xref" href="ch12.html#part_of_the_rvalue_definition_from_gcdot" title="Example 12-1. Part of the RVALUE definition from gc.c">Example 12-1</a> shows part of the <code class="literal">RVALUE</code> definition.</p><div class="example"><a id="part_of_the_rvalue_definition_from_gcdot"/><p class="title">Example 12-1. <span class="emphasis"><em>Part of the <code class="literal">RVALUE</code> definition</em></span> from gc.c</p><div class="example-contents"><pre class="programlisting">    typedef struct RVALUE {
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   union {
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>     struct {
          VALUE flags;        /* always 0 for freed obj */
          struct RVALUE *next;
        } free;
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>     struct RBasic  basic;
        struct RObject object;
        struct RClass  klass;
        struct RFloat  flonum;
        struct RString string;
        struct RArray  array;
        struct RRegexp regexp;

    --<span class="emphasis"><em>snip</em></span>--

        } as;
    #ifdef GC_DEBUG    const char *file;
        int   line;
    #endif} RVALUE;</pre></div></div><p>Notice at <span class="inlinemediaobject"><a id="inline_id00476"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> that <code class="literal">RVALUE</code> uses a union to hold one of many different types of values internally. The first possible value is the <code class="literal">free</code> structure, defined at <span class="inlinemediaobject"><a id="inline_id00477"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>, which represents <code class="literal">RVALUE</code>s still on the free list. MRI includes every other possible type of Ruby object in the union starting at <span class="inlinemediaobject"><a id="inline_id00478"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span>: <code class="literal">RObject</code>, <code class="literal">RString</code>, and so forth.</p></div></div><div class="sect2" title="Disadvantages of Mark and Sweep"><div class="titlepage"><div><div><h2 class="title"><a id="disadvantages_of_mark_and_sweep"/>Disadvantages of Mark and Sweep</h2></div></div></div><p><a class="indexterm" id="iddle1235"/><a class="indexterm" id="iddle1272"/><a class="indexterm" id="iddle1332"/><a class="indexterm" id="iddle1568"/><a class="indexterm" id="iddle1574"/><a class="indexterm" id="iddle1648"/><a class="indexterm" id="iddle1750"/>The chief disadvantage of mark and sweep is that it requires your program to stop and wait while the marking and sweeping processes take place. Beginning with version 1.9.3, however, MRI’s lazy sweeping technique shortens the GC pauses somewhat.</p><p>Another disadvantage is that the time required to perform a mark-and-sweep garbage collection is proportional to the total size of the heap. During the marking phase, Ruby needs to visit every active object in your program. During the sweeping phase, Ruby needs to iterate over all of the unused garbage objects left in the heap. As the number of objects created by your program and the total heap size grows, both tasks become more time intensive.</p><p>The final issue with mark and sweep is that all of the free list elements—all of the unused objects available for your program to use—must be the same size. MRI doesn’t know ahead of time when you allocate a new object whether it will be a string, an array, or a simple number. This is why the <code class="literal">RVALUE</code> structure MRI uses in the free list must encompass any possible type of Ruby object.</p></div></div><div class="sect1" title="Experiment 12-1: Seeing MRI Garbage Collection in Action"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_12-1_seeing_mri_garbage_colle"/>Experiment 12-1: Seeing MRI Garbage Collection in Action</h1></div></div></div><p>You’ve learned how the MRI GC algorithm works at a theoretical level. Let’s switch gears now to see how MRI performs actual garbage collection. The script in <a class="xref" href="ch12.html#creating_10_ruby_objects_using_objectdot" title="Example 12-2. Creating 10 Ruby objects using Object.new">Example 12-2</a> creates 10 Ruby objects.</p><div class="example"><a id="creating_10_ruby_objects_using_objectdot"/><p class="title">Example 12-2. Creating 10 Ruby objects using <code class="literal">Object.new</code></p><div class="example-contents"><pre class="programlisting">10.times do
  obj = Object.new
end</pre></div></div><p>If it’s true that MRI assigns unused space from the free list to new objects, Ruby should remove 10 <code class="literal">RVALUE</code> structures from the free list and assign them to these 10 new objects when we run <a class="xref" href="ch12.html#creating_10_ruby_objects_using_objectdot" title="Example 12-2. Creating 10 Ruby objects using Object.new">Example 12-2</a>. To see this in action, we use the <code class="literal">ObjectSpace#count_objects</code> method, as shown in <a class="xref" href="ch12.html#using_objectspacehashcountunderscoreobje" title="Example 12-3. Using ObjectSpace#count_objects to display information about MRI’s heap">Example 12-3</a>.</p><div class="example"><a id="using_objectspacehashcountunderscoreobje"/><p class="title">Example 12-3. Using <code class="literal">ObjectSpace#count_objects</code> to display information about MRI’s heap</p><div class="example-contents"><pre class="programlisting">    def display_count
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   data = ObjectSpace.count_objects
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   puts "Total: #{data[:TOTAL]} Free: #{data[:FREE]} Object: #{data[:T_OBJECT]}"end

    10.times do
      obj = Object.new
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>   display_count
    end</pre></div></div><p><a class="indexterm" id="iddle1330"/><a class="indexterm" id="iddle1532"/>Now we call <code class="literal">display_count</code> at <span class="inlinemediaobject"><a id="inline_id00482"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> each time around the loop. <code class="literal">display_count</code> uses <code class="literal">ObjectSpace#count_objects</code> at <span class="inlinemediaobject"><a id="inline_id00483"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> to display information at <span class="inlinemediaobject"><a id="inline_id00484"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> about the total number of objects, the number of free objects, and the number of <code class="literal">RObject</code> structures active each time around the loop.</p><p>Running <a class="xref" href="ch12.html#using_objectspacehashcountunderscoreobje" title="Example 12-3. Using ObjectSpace#count_objects to display information about MRI’s heap">Example 12-3</a> gives the output shown in <a class="xref" href="ch12.html#output_produced_by_listing_12-3" title="Example 12-4. The output produced by Example 12-3">Example 12-4</a>.</p><div class="example"><a id="output_produced_by_listing_12-3"/><p class="title">Example 12-4. The output produced by <a class="xref" href="ch12.html#using_objectspacehashcountunderscoreobje" title="Example 12-3. Using ObjectSpace#count_objects to display information about MRI’s heap">Example 12-3</a></p><div class="example-contents"><pre class="programlisting">Total: 17491 Free: 171 Object: 85
Total: 17491 Free: 139 Object: 86
Total: 17491 Free: 132 Object: 87
Total: 17491 Free: 125 Object: 88
Total: 17491 Free: 118 Object: 89
Total: 17491 Free: 111 Object: 90
Total: 17491 Free: 104 Object: 91
Total: 17491 Free: 97 Object: 92
Total: 17491 Free: 90 Object: 93
Total: 17491 Free: 83 Object: 94</pre></div></div><p>The <code class="literal">Total:</code> field displays the value that MRI returns for <code class="literal">ObjectSpace.count_objects[:TOTAL]</code>. This value (17491) is the total number of objects currently active inside Ruby. It includes objects we create; objects Ruby creates internally while parsing, compiling, and executing our program; and objects on the free list. This number does not change when we create new objects because it already includes the entire free list.</p><p>The <code class="literal">Free:</code> field displays the value returned by <code class="literal">ObjectSpace.count_objects[:FREE]</code> for the length of the free list. Notice that the value drops by about 7 each time around the loop. We create only one object per iteration, but Ruby creates 6 other objects each time around the loop while running the code in the <code class="literal">display_count</code> method.</p><p>The <code class="literal">Object:</code> field displays the count of <code class="literal">RObject</code> structures currently active in Ruby. Notice that this value increases by 1 each time around the loop, even though we don’t keep an active reference to the new objects. That is, we don’t save the value returned by <code class="literal">Object.new</code> anywhere. The <code class="literal">RObject</code> count includes active and garbage objects.</p><div class="sect2" title="Seeing MRI Perform a Lazy Sweep"><div class="titlepage"><div><div><h2 class="title"><a id="seeing_mri_perform_a_lazy_sweep"/>Seeing MRI Perform a Lazy Sweep</h2></div></div></div><p>Now if we increase the number of iterations from 10 to 30 and rerun <a class="xref" href="ch12.html#using_objectspacehashcountunderscoreobje" title="Example 12-3. Using ObjectSpace#count_objects to display information about MRI’s heap">Example 12-3</a>, we see the following output in <a class="xref" href="ch12.html#running_listing_12-3_with_30_iterations" title="Example 12-5. Running Example 12-3 with 30 iterations instead of 10">Example 12-5</a>.</p><div class="example"><a id="running_listing_12-3_with_30_iterations"/><p class="title">Example 12-5. Running <a class="xref" href="ch12.html#using_objectspacehashcountunderscoreobje" title="Example 12-3. Using ObjectSpace#count_objects to display information about MRI’s heap">Example 12-3</a> with 30 iterations instead of 10</p><div class="example-contents"><pre class="programlisting">    Total: 17493 Free: 166 Object: 85
    Total: 17493 Free: 134 Object: 86
    Total: 17493 Free: 127 Object: 87
    Total: 17493 Free: 120 Object: 88

    --<span class="emphasis"><em>snip</em></span>--

    Total: 17493 Free: 29 Object: 101
    Total: 17493 Free: 22 Object: 102
    Total: 17493 Free: 15 Object: 103
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> Total: 17493 Free: 8 Object: 104
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> Total: 17493 Free: 246 Object: 104
    Total: 17493 Free: 239 Object: 105
    Total: 17493 Free: 232 Object: 106
    Total: 17493 Free: 225 Object: 107</pre></div></div><p><a class="indexterm" id="iddle1328"/><a class="indexterm" id="iddle1344"/>This time the free list count drops to 8 at <span class="inlinemediaobject"><a id="inline_id00487"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>. Then at <span class="inlinemediaobject"><a id="inline_id00488"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> the free count increases to 246, but the object count remains at 104. This must be a full garbage collection. But it’s not! If Ruby had collected all available garbage objects, it would have reduced the <code class="literal">RObject</code> count when it increased the free count because all of our objects become garbage immediately. What’s going on here?</p><p>This was a lazy sweep. Ruby first marked all active objects, indirectly identifying the garbage ones. Instead of moving all the garbage objects to the free list, however, it swept only a portion of them: the garbage objects it found in one of its internal heap structures. The free count increased, but the <code class="literal">RObject</code> count remained the same because MRI reused an <code class="literal">RObject</code> structure created by one of the previous iterations in order to create the new object.</p></div><div class="sect2" title="Seeing MRI Perform a Full Collection"><div class="titlepage"><div><div><h2 class="title"><a id="seeing_mri_perform_a_full_collection"/>Seeing MRI Perform a Full Collection</h2></div></div></div><p>We can see the effect of a full garbage collection by triggering one manually with the <code class="literal">GC.start</code> method (see <a class="xref" href="ch12.html#triggering_a_full_garbage_collection" title="Example 12-6. Triggering a full garbage collection">Example 12-6</a>).</p><div class="example"><a id="triggering_a_full_garbage_collection"/><p class="title">Example 12-6. Triggering a full garbage collection</p><div class="example-contents"><pre class="programlisting">    def display_count
      data = ObjectSpace.count_objects
      puts "Total: #{data[:TOTAL]} Free: #{data[:FREE]} Object: #{data[:T_OBJECT]}"end

    30.times do
      obj = Object.new
      display_count
    end

<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> GC.start
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> display_count</pre></div></div><p>Here, we again iterate 30 times, creating new objects and calling <code class="literal">display_count</code>. Then, we call <code class="literal">GC.start</code> at <span class="inlinemediaobject"><a id="inline_id00491"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>, which triggers MRI to run a full garbage collection. Finally, at <span class="inlinemediaobject"><a id="inline_id00492"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> we call <code class="literal">display_count</code> again to display the same technical information. <a class="xref" href="ch12.html#output_generated_by_listing_12-6" title="Example 12-7. The output generated by Example 12-6">Example 12-7</a> shows the new output.</p><div class="example"><a id="output_generated_by_listing_12-6"/><p class="title">Example 12-7. The output generated by <a class="xref" href="ch12.html#triggering_a_full_garbage_collection" title="Example 12-6. Triggering a full garbage collection">Example 12-6</a></p><div class="example-contents"><pre class="programlisting">    --<span class="emphasis"><em>snip</em></span>--

    Total: 17491 Free: 26 Object: 101
    Total: 17491 Free: 19 Object: 102
    Total: 17491 Free: 12 Object: 103
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> Total: 17491 Free: 251 Object: 103
    Total: 17491 Free: 244 Object: 104
    Total: 17491 Free: 237 Object: 105
    Total: 17491 Free: 230 Object: 106
    Total: 17491 Free: 223 Object: 107
    Total: 17491 Free: 216 Object: 108
    Total: 17491 Free: 209 Object: 109
    Total: 17491 Free: 202 Object: 110
    Total: 17491 Free: 195 Object: 111
    Total: 17491 Free: 188 Object: 112
    Total: 17491 Free: 181 Object: 113
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> Total: 17491 Free: 9527 Object: 43</pre></div></div><p><a class="indexterm" id="iddle1329"/><a class="indexterm" id="iddle1453"/>Most of <a class="xref" href="ch12.html#output_generated_by_listing_12-6" title="Example 12-7. The output generated by Example 12-6">Example 12-7</a> shows output similar to <a class="xref" href="ch12.html#running_listing_12-3_with_30_iterations" title="Example 12-5. Running Example 12-3 with 30 iterations instead of 10">Example 12-5</a>. The total remains the same, while the free count gradually decreases. At <span class="inlinemediaobject"><a id="inline_id00495"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> we see the lazy sweep occur again, increasing the free count to 251. But at <span class="inlinemediaobject"><a id="inline_id00496"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> we see a dramatic change. The total number of objects remains at 17491, but the free count jumps to 9527 and the number of objects reduces dramatically to 43!</p><p>From this observation, we know the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The free count increased dramatically at <span class="inlinemediaobject"><a id="inline_id00497"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> because Ruby swept all of the garbage objects onto the free list in one large operation. This garbage included the objects our code created in previous iterations as well as objects that Ruby created internally during the parsing and compilation phases.</p></li><li class="listitem"><p>The <code class="literal">RObject</code> count reduced to 43 because all of the objects created in previous iterations were garbage (because we didn’t save them anywhere). The 43 count includes only objects Ruby created internally and none of the objects our code created. If we had saved our new objects somewhere, the <code class="literal">RObject</code> count would have remained the same. (We’ll try this next.)</p></li></ul></div></div><div class="sect2" title="Interpreting a GC Profile Report"><div class="titlepage"><div><div><h2 class="title"><a id="interpreting_a_gc_profile_report"/>Interpreting a GC Profile Report</h2></div></div></div><p>So far in this experiment we’ve allocated just a few objects from the free list. Of course, your Ruby programs will typically create many more than 30 objects. How does MRI’s garbage collector behave when we create thousands or even millions of objects? How can you find out how much time is being taken by the garbage collector in a complex Ruby application?</p><p><a class="indexterm" id="iddle1343"/>The answer is to use the <code class="literal">GC::Profiler</code> class. If you enable it, MRI’s internal GC code will collect statistics about each GC run. <a class="xref" href="ch12.html#displaying_a_gc_usage_profile_using_gcpr" title="Example 12-8. Displaying a GC usage profile using GC::Profiler (gc-profile.rb)">Example 12-8</a> shows how to use <code class="literal">GC::Profiler</code>.</p><div class="example"><a id="displaying_a_gc_usage_profile_using_gcpr"/><p class="title">Example 12-8. Displaying a GC usage profile using <code class="literal">GC::Profiler</code> <span class="emphasis"><em>(gc-profile.rb)</em></span></p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> GC::Profiler.enable

    10000000.times do
      obj = Object.new
    end

<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> GC::Profiler.report</pre></div></div><p>We first enable the profiler at <span class="inlinemediaobject"><a id="inline_id00500"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> by calling <code class="literal">GC::Profiler.enable</code>. The following code creates 10 million Ruby objects. At <span class="inlinemediaobject"><a id="inline_id00501"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> we display the GC profile report by calling <code class="literal">GC::Profiler.report</code>. <a class="xref" href="ch12.html#portion_of_the_gc_profile_report_gener" title="Example 12-9. A portion of the GC profile report generated in Example 12-8">Example 12-9</a> shows the report generated in <a class="xref" href="ch12.html#displaying_a_gc_usage_profile_using_gcpr" title="Example 12-8. Displaying a GC usage profile using GC::Profiler (gc-profile.rb)">Example 12-8</a>.</p><div class="example"><a id="portion_of_the_gc_profile_report_gener"/><p class="title">Example 12-9. A portion of the GC profile report generated in <a class="xref" href="ch12.html#displaying_a_gc_usage_profile_using_gcpr" title="Example 12-8. Displaying a GC usage profile using GC::Profiler (gc-profile.rb)">Example 12-8</a></p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>ruby gc-profile.rb</strong></span>
GC 1046 invokes.
Invoke Time(sec)       Use Size(byte)     Total Size(byte)         Total Object      GC Time(ms)
           0.036               690920               700040                17501         0.694000
           0.039               695200               700040                17501         0.433999
           0.041               695200               700040                17501         0.585000
           0.046               695200               700040                17501         0.577000
           0.049               695200               700040                17501         0.466000
           0.051               695200               700040                17501         0.516999
           0.054               695200               700040                17501         0.419000
           0.056               695200               700040                17501         0.535000
           0.059               695200               700040                17501         0.410000
           0.062               695200               700040                17501         0.426999
--<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>To save space, I’ve removed the first column from the report, a simple counter. Here’s what the other columns mean:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Invoke time</em></span> shows when the garbage collection occurred, measured as seconds after the Ruby script started to run.</p></li><li class="listitem"><p><span class="emphasis"><em>Use size</em></span> shows how much heap memory is used by all live Ruby objects after each collection is finished.</p></li><li class="listitem"><p><span class="emphasis"><em>Total size</em></span> shows the total size of the heap after collection—in other words, the memory taken by live objects plus the size of the free list.</p></li><li class="listitem"><p><span class="emphasis"><em>Total object</em></span> shows the total number of Ruby objects, either live or on the free list.</p></li><li class="listitem"><p>Finally, <span class="emphasis"><em>GC time</em></span> shows the amount of time each collection took.</p></li></ul></div><p>Notice in this experiment that, aside from <span class="emphasis"><em>invoke time</em></span>, none of the values change. The amount of memory used by live Ruby objects, the total size of the heap, and the total number of objects all remain the same. This is because we don’t save the new Ruby objects anywhere. They all immediately become garbage. The <span class="emphasis"><em>GC time</em></span> value fluctuates somewhat but more or less remains the same. The amount of time required by the collector to sweep all of the new objects back to the free list remains about the same because the collector sweeps about the same number of objects each time.</p><p>However, if we save all of the new objects in an array, they will remain live and not become garbage. <a class="xref" href="ch12.html#saving_10_million_ruby_objects_in_an_arr" title="Example 12-10. Saving 10 million Ruby objects in an array (gc-profile-array.rb)">Example 12-10</a> shows code that saves each object into a single, large array.</p><div class="example"><a id="saving_10_million_ruby_objects_in_an_arr"/><p class="title">Example 12-10. Saving 10 million Ruby objects in an array <span class="emphasis"><em>(gc-profile-array.rb)</em></span></p><div class="example-contents"><pre class="programlisting">    GC::Profiler.enable

<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> arr = []
10000000.times do
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   arr &lt;&lt; Object.new
    end

    GC.start

    GC::Profiler.report</pre></div></div><p>Here, we create an empty array at <span class="inlinemediaobject"><a id="inline_id00504"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> and save each of the new objects in it at <span class="inlinemediaobject"><a id="inline_id00505"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>. Because the array holds a reference to all of the new objects, they remain active. The garbage collector can’t reclaim memory from any of them. <a class="xref" href="ch12.html#ruby_has_to_increase_the_heap_size_to_ac" title="Example 12-11. Ruby has to increase the heap size to accommodate all the new, live objects.">Example 12-11</a> shows the GC profile report produced by <a class="xref" href="ch12.html#saving_10_million_ruby_objects_in_an_arr" title="Example 12-10. Saving 10 million Ruby objects in an array (gc-profile-array.rb)">Example 12-10</a>.</p><div class="example"><a id="ruby_has_to_increase_the_heap_size_to_ac"/><p class="title">Example 12-11. Ruby has to increase the heap size to accommodate all the new, live objects.</p><div class="example-contents"><pre class="programlisting">    $ <span class="strong"><strong>ruby gc-profile-array.rb</strong></span>
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> GC 17 invokes.
    Invoke Time(sec)       Use Size(byte)     Total Size(byte)         Total Object      GC Time(ms)
               0.031               690920               700040                17501         0.575000
               0.034               708480               716320                17908         0.689000
               0.037              1261680              1269840                31746         1.077000
               0.043              2254280              2262920                56573         1.994999
               0.054              4044200              4053720               101343         3.454999
               0.074              7266080              7277160               181929         5.288000
               0.108             13058920             13072840               326821         9.417000
               0.170             23489240             23508320               587708        14.465000
               0.279             42267080             42311720              1057793        26.015999
               0.478             76096560             76157840              1903946        45.910000</pre></div></div><p>This time the profile report is very different! The garbage collector can’t free any of the new objects because they remain active in the array. This means Ruby has no choice but to repeatedly allocate more memory to hold them. When you read <a class="xref" href="ch12.html#ruby_has_to_increase_the_heap_size_to_ac" title="Example 12-11. Ruby has to increase the heap size to accommodate all the new, live objects.">Example 12-11</a>, notice that all three important values—<span class="emphasis"><em>use size</em></span>, <span class="emphasis"><em>total size</em></span>, and <span class="emphasis"><em>total object</em></span>—increase exponentially. This increase is why at <span class="inlinemediaobject"><a id="inline_id00507"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> we see the garbage collector was called only 17 times. (Ruby also ran a few collections before we called <code class="literal">GC::Profiler.enable</code> as it parsed and compiled our script.) Each time the collector more or less doubled the size of the heap, allowing the script to continue to run for longer and longer periods of time. Instead of running many collections quickly, as we saw in <a class="xref" href="ch12.html#portion_of_the_gc_profile_report_gener" title="Example 12-9. A portion of the GC profile report generated in Example 12-8">Example 12-9</a>, Ruby ran just a few slow collections.</p><p>If we draw a graph of the time required for each collection (<span class="emphasis"><em>GC Time</em></span>) against the total size of the heap (<span class="emphasis"><em>Total Heap Size</em></span>), as shown in <a class="xref" href="ch12.html#time_required_to_perform_mark_and_sw" title="Figure 12-8. The time required to perform mark and sweep increases linearly with the heap size.">Figure 12-8</a>, we can draw another interesting conclusion.</p><div class="figure"><a id="time_required_to_perform_mark_and_sw"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00277"/><img alt="The time required to perform mark and sweep increases linearly with the heap size." src="httpatomoreillycomsourcenostarchimages1854363.png.jpg"/></div></div><p class="title">Figure 12-8. The time required to perform mark and sweep increases linearly with the heap size.</p></div><p><a class="xref" href="ch12.html#time_required_to_perform_mark_and_sw" title="Figure 12-8. The time required to perform mark and sweep increases linearly with the heap size.">Figure 12-8</a> uses a logarithmic scale for both the x-axis (<span class="emphasis"><em>Total Heap Size</em></span>) and the y-axis (<span class="emphasis"><em>GC Time</em></span>). Because Ruby doubled the heap size during each collection, the data points are more or less evenly spaced across the logarithmic x-axis scale. They are also evenly spaced along the logarithmic y-axis because the time increases exponentially.</p><p>Most importantly, note the data points form a straight line: This straight line means the time required to perform a garbage collection increases linearly as a function of the total heap size. As you create more Ruby objects, it takes longer to mark them. Sweeping also takes longer when there are more garbage objects; however, in this example, we don’t see any sweep time because all our objects remain live.</p></div></div><div class="sect1" title="Garbage Collection in JRuby and Rubinius"><div class="titlepage"><div><div><h1 class="title"><a id="garbage_collection_in_jruby_and_rubinius"/>Garbage Collection in JRuby and Rubinius</h1></div></div></div><p><a class="indexterm" id="iddle1066"/><a class="indexterm" id="iddle1205"/><a class="indexterm" id="iddle1292"/><a class="indexterm" id="iddle1315"/><a class="indexterm" id="iddle1322"/><a class="indexterm" id="iddle1334"/><a class="indexterm" id="iddle1335"/><a class="indexterm" id="iddle1470"/><a class="indexterm" id="iddle1480"/><a class="indexterm" id="iddle1493"/><a class="indexterm" id="iddle1570"/><a class="indexterm" id="iddle1573"/><a class="indexterm" id="iddle1685"/><a class="indexterm" id="iddle1935"/><a class="indexterm" id="iddle1939"/><a class="indexterm" id="iddle2136"/>Because JRuby uses the Java Virtual Machine (JVM) to implement Ruby, it’s able to use the JVM’s sophisticated GC system to manage memory for Ruby objects. In fact, garbage collection is one of the primary benefits of using the JVM platform: The JVM garbage collector has been refined over many years.</p><p>The Rubinius C++ virtual machine also includes a sophisticated, efficient garbage collector that uses some of the same underlying algorithms as the JVM. One of the benefits of choosing Rubinius as your Ruby platform is its sophisticated GC system.</p><p>The garbage collectors used by JRuby and Rubinius differ from MRI’s garbage collector in three ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Instead of using a free list, they allocate memory for new objects and reclaim memory from garbage objects using an algorithm called <span class="emphasis"><em>copying garbage collection</em></span>.</p></li><li class="listitem"><p>They handle old and young Ruby objects differently using <span class="emphasis"><em>generational garbage collection</em></span>.</p></li><li class="listitem"><p>They use <span class="emphasis"><em>concurrent garbage collection</em></span> to perform some GC tasks at the same time that your application code is running.</p></li></ul></div><div class="note" title="Note"><h3 class="title"><a id="ch12note01"/>Note</h3><p><span class="emphasis"><em>Although the GC systems used by JRuby and Rubinius are dramatically different from MRI’s mark-and-sweep garbage collector, MRI has begun to incorporate some of these ideas as well. Specifically, the GC system in Ruby 2.1 has begun to use generational and concurrent garbage collection.</em></span></p></div><p>In the following sections, we’ll explore the basic algorithms underpinning copying, generational, and concurrent garbage collection, as we learn more about how garbage collection works in Rubinius and JRuby.</p></div><div class="sect1" title="Copying Garbage Collection"><div class="titlepage"><div><div><h1 class="title"><a id="copying_garbage_collection"/>Copying Garbage Collection</h1></div></div></div><p>In 1963, three years after John McCarthy built the first Lisp garbage collector, Marvin Minsky developed a different way of allocating and reclaiming memory known as <span class="emphasis"><em>copying garbage collection</em></span>. (Minsky’s research was also originally used for Lisp. The algorithm was later refined by Fenichel and Yochelson in 1969 and by Baker in 1978.) Instead of using a free list to track available objects, copying garbage collectors allocate memory for new objects from a single large heap or memory segment. When that memory segment is used up, these collectors <span class="emphasis"><em>copy</em></span> only the live objects over to a second memory segment, leaving the garbage objects behind. The two segments are then swapped, immediately reclaiming all of the memory from the garbage objects. (Rubinius and the JVM both use complex algorithms based on this original idea.)</p><div class="sect2" title="Bump Allocation"><div class="titlepage"><div><div><h2 class="title"><a id="bump_allocation"/>Bump Allocation</h2></div></div></div><p><a class="indexterm" id="iddle1090"/><a class="indexterm" id="iddle1206"/><a class="indexterm" id="iddle1316"/><a class="indexterm" id="iddle1552"/>When you allocate memory for a new object using a copying garbage collector, such as the collectors in the JVM and Rubinius, the garbage collector uses an algorithm called <span class="emphasis"><em>bump allocation</em></span>. Bump allocation allocates adjacent memory segments from a large, continuous heap by <span class="emphasis"><em>bumping</em></span>, or incrementing, a pointer to keep track of where the next allocation will occur. <a class="xref" href="ch12.html#allocating_three_objects_using_bump_allo" title="Figure 12-9. Allocating three objects using bump allocation">Figure 12-9</a> shows how this process works for three repeated allocations. (The large rectangle represents the Rubinius or JVM heap.)</p><div class="figure"><a id="allocating_three_objects_using_bump_allo"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00278"/><img alt="Allocating three objects using bump allocation" src="httpatomoreillycomsourcenostarchimages1854365.png"/></div></div><p class="title">Figure 12-9. Allocating three objects using bump allocation</p></div><p>A copying collector keeps a pointer that tracks where in the heap the next allocation will occur. Each time the collector allocates memory for a new object, it returns some memory from the heap and moves this pointer to the right. As more objects are created, the memory allocated from the heap also moves to the right. Notice, too, that the new objects are not all the same size; each object uses a different number of bytes. As a result, the objects are not spaced evenly across the heap.</p><p>The advantages of this technique are that it’s very fast and simple to implement and it provides good <span class="emphasis"><em>locality of reference</em></span>, meaning that related values in your program should be located near each other in memory. Locality is important because if your code repeatedly accesses the same area of memory, your CPU can cache that memory and access it much more quickly. If your program often accesses very different areas of memory, the CPU must continually reload the memory cache, slowing down your program’s performance.</p><p><a class="indexterm" id="iddle1011"/><a class="indexterm" id="iddle1208"/><a class="indexterm" id="iddle1301"/><a class="indexterm" id="iddle1318"/><a class="indexterm" id="iddle1982"/><a class="indexterm" id="iddle2053"/>Another benefit of copying garbage collection is the ability to create objects of different sizes. Unlike the <code class="literal">RVALUE</code> structure in MRI, JRuby and Rubinius can allocate new objects of any size.</p></div><div class="sect2" title="The Semi-Space Algorithm"><div class="titlepage"><div><div><h2 class="title"><a id="semi-space_algorithm"/>The Semi-Space Algorithm</h2></div></div></div><p>The real benefit and elegance of copying garbage collectors becomes evident when the initial heap is used up and a garbage collection occurs. Copying garbage collectors identify live and garbage objects the way that mark-and-sweep collectors do—by traversing the object graph following object references or pointers. Once the garbage objects have been identified, however, copying garbage collectors work very differently.</p><p>Copying garbage collectors actually use two heaps: one to create new objects with bump allocation and a second, empty one, as shown in <a class="xref" href="ch12.html#semi-space_algorithm_uses_two_heapsc" title="Figure 12-10. The semi-space algorithm uses two heaps, one initially empty.">Figure 12-10</a>.</p><div class="figure"><a id="semi-space_algorithm_uses_two_heapsc"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00279"/><img alt="The semi-space algorithm uses two heaps, one initially empty." src="httpatomoreillycomsourcenostarchimages1854367.png"/></div></div><p class="title">Figure 12-10. The semi-space algorithm uses two heaps, one initially empty.</p></div><p>The heap at the top contains the objects already created and is known as the <span class="emphasis"><em>from-space</em></span>. Note that the objects in the from-space were already marked as live (gray with an <span class="emphasis"><em>M</em></span>) or garbage (white). The lower heap is the <span class="emphasis"><em>to-space</em></span>, and it’s initially empty. The algorithm I’m about to describe is known as the <span class="emphasis"><em>semi-space</em></span> algorithm because the total available memory is divided between the from-space and the to-space.</p><p>When the from-space becomes completely full, copying garbage collectors copy all of the live objects down into the to-space, leaving the garbage objects behind. <a class="xref" href="ch12.html#semi-space_algorithm_copies_only_liv" title="Figure 12-11. The semi-space algorithm copies only live objects to the second heap.">Figure 12-11</a> shows the copying process.</p><div class="figure"><a id="semi-space_algorithm_copies_only_liv"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00280"/><img alt="The semi-space algorithm copies only live objects to the second heap." src="httpatomoreillycomsourcenostarchimages1854369.png"/></div></div><p class="title">Figure 12-11. The semi-space algorithm copies only live objects to the second heap.</p></div><p><a class="indexterm" id="iddle1207"/><a class="indexterm" id="iddle1241"/><a class="indexterm" id="iddle1317"/><a class="indexterm" id="iddle1340"/>The from-space again appears at the top of the diagram and the to-space below. Notice how the live objects are copied down into the to-space. The arrows pointing down indicate this copying process. A pointer similar to the one used for bump allocation keeps track of where the next live object should be copied to.</p><p>Once the copying process is finished, the semi-space algorithm swaps heaps, as shown in <a class="xref" href="ch12.html#after_copying_the_live_objectscomma_the" title="Figure 12-12. After copying the live objects, the semi-space algorithm switches heaps.">Figure 12-12</a>.</p><div class="figure"><a id="after_copying_the_live_objectscomma_the"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00281"/><img alt="After copying the live objects, the semi-space algorithm switches heaps." src="httpatomoreillycomsourcenostarchimages1854371.png.jpg"/></div></div><p class="title">Figure 12-12. After copying the live objects, the semi-space algorithm switches heaps.</p></div><p>In <a class="xref" href="ch12.html#after_copying_the_live_objectscomma_the" title="Figure 12-12. After copying the live objects, the semi-space algorithm switches heaps.">Figure 12-12</a>, the to-space has become the new from-space and is now ready to allocate more memory for new objects using bump allocation. You might expect the algorithm to be slow because so much copying is involved, but it’s not, because only active, live objects are copied. Garbage objects are left in place and then reclaimed.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note02"/>Note</h3><p><span class="emphasis"><em>All of the live objects were copied to the left side of the heap; this allows the garbage collector to allocate the remaining unused memory most efficiently. This compaction of the heap is a natural result of the semi-space algorithm.</em></span></p></div><p>While the semi-space algorithm is an elegant way to manage memory, it is somewhat memory inefficient. It requires the collector to allocate twice as much memory as it actually uses because all of your objects might remain active and could be copied into the second heap. The algorithm is also somewhat difficult to implement because when the collector moves live objects, it also has to update references and pointers to them internally.</p></div><div class="sect2" title="The Eden Heap"><div class="titlepage"><div><div><h2 class="title"><a id="eden_heap"/>The Eden Heap</h2></div></div></div><p>As it turns out, both Rubinius and the JVM use a variation of the semi-space algorithm with a third heap structure for allocating new objects called the <span class="emphasis"><em>Garden of Eden</em></span>, or <span class="emphasis"><em>Eden heap</em></span>. <a class="xref" href="ch12.html#eden_heap_is_for_allocating_memory_f" title="Figure 12-13. The Eden heap is for allocating memory for brand-new objects.">Figure 12-13</a> shows the three memory structures.</p><div class="figure"><a id="eden_heap_is_for_allocating_memory_f"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00282"/><img alt="The Eden heap is for allocating memory for brand-new objects." src="httpatomoreillycomsourcenostarchimages1854373.png"/></div></div><p class="title">Figure 12-13. The Eden heap is for allocating memory for brand-new objects.</p></div><p><a class="indexterm" id="iddle1346"/><a class="indexterm" id="iddle1351"/><a class="indexterm" id="iddle2102"/>The Eden heap is where the JVM and Rubinius allocate memory for new objects; the from-space contains all of the live objects copied in the previous garbage collection process; and the to-space remains empty until the next garbage collection runs. Each time the garbage collection process runs, the collector copies your objects from both the Eden heap and from-space into the to-space, thereby allowing more memory to be available for new objects because the Eden heap will always be empty after each semi-space copy operation.</p></div></div><div class="sect1" title="Generational Garbage Collection"><div class="titlepage"><div><div><h1 class="title"><a id="generational_garbage_collection"/>Generational Garbage Collection</h1></div></div></div><p>Many modern garbage collectors, including the collectors in the JVM and the Rubinius VM, use <span class="emphasis"><em>generational GC</em></span> algorithms, a technique that treats new objects differently than older ones. A new, or <span class="emphasis"><em>young</em></span>, object is one that your program has just created, while an old, or <span class="emphasis"><em>mature</em></span>, object is one that your program is continuing to use. The time that an object has to remain active for in order for it to be considered mature is usually measured by the number of times the garbage collection system has run.</p><div class="sect2" title="The Weak Generational Hypothesis"><div class="titlepage"><div><div><h2 class="title"><a id="weak_generational_hypothesis"/>The Weak Generational Hypothesis</h2></div></div></div><p>The reason objects are categorized as either young or mature is based on the assumption that most young objects will have a short lifetime while mature objects are likely to continue to live for a long time. This assumption is known as the <span class="emphasis"><em>weak generational hypothesis</em></span>. In simple terms, new objects are likely to die young. Because young and mature objects have different life expectancies, different GC algorithms are appropriate for each category, or <span class="emphasis"><em>generation</em></span>.</p><p><a class="indexterm" id="iddle1348"/><a class="indexterm" id="iddle1350"/><a class="indexterm" id="iddle1717"/><a class="indexterm" id="iddle1842"/><a class="indexterm" id="iddle2033"/>For example, consider a Ruby on Rails website. To generate a web page for each client request, a Rails application creates many new Ruby objects. However, once a web page has been generated and returned to the client, all of those Ruby objects are no longer needed and the GC system can reclaim their memory. At the same time, the application might also create a few Ruby objects that live between requests, such as ones that represent a controller, some configuration data, or a user session. These few mature objects would have a longer lifetime.</p></div><div class="sect2" title="Using the Semi-Space Algorithm for Young Objects"><div class="titlepage"><div><div><h2 class="title"><a id="using_the_semi-space_algorithm_for_young"/>Using the Semi-Space Algorithm for Young Objects</h2></div></div></div><p>According to the weak generational hypothesis, young objects are created continually by your program but also become garbage quite frequently. Because of this, both the JVM and Rubinius run the GC process more frequently for young objects than for mature ones (you’ll see just how much more frequently in <a class="xref" href="ch12.html#experiment_12-2_using_verbose_gc_mode_in" title="Experiment 12-2: Using Verbose GC Mode in JRuby">Experiment 12-2: Using Verbose GC Mode in JRuby</a>). The semi-space algorithm is ideal for young objects because it copies only live objects. When the Eden heap fills up with new objects, the garbage collector identifies most of them as garbage because new objects usually die young. Because there are fewer live objects, the collector has less copying to do. The JVM refers to these objects as <span class="emphasis"><em>survivors</em></span> and calls the from-space and the to-space <span class="emphasis"><em>survivor spaces</em></span>.</p></div><div class="sect2" title="Promoting Objects"><div class="titlepage"><div><div><h2 class="title"><a id="promoting_objects"/>Promoting Objects</h2></div></div></div><p>When a new object becomes old (that is, when it has survived a certain number of runs of the GC system), it is <span class="emphasis"><em>promoted</em></span>, or copied, into the mature generation heap during the semi-space copy process, as shown in <a class="xref" href="ch12.html#generational_garbage_collectors_promote" title="Figure 12-14. Generational garbage collectors promote old objects from the young heap to the mature one.">Figure 12-14</a>.</p><div class="figure"><a id="generational_garbage_collectors_promote"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00283"/><img alt="Generational garbage collectors promote old objects from the young heap to the mature one." src="httpatomoreillycomsourcenostarchimages1854375.png"/></div></div><p class="title">Figure 12-14. Generational garbage collectors promote old objects from the young heap to the mature one.</p></div><p>Notice that the from-space contains five active objects, shown as gray rectangles. Two of these are copied down to the to-space by the semi-space algorithm, but the other three are promoted. Their age has exceeded the <span class="emphasis"><em>new object lifetime</em></span> because they have remained active for a certain number of GC runs.</p><p><a class="indexterm" id="iddle1008"/><a class="indexterm" id="iddle1336"/><a class="indexterm" id="iddle1347"/><a class="indexterm" id="iddle1404"/><a class="indexterm" id="iddle1564"/><a class="indexterm" id="iddle1683"/><a class="indexterm" id="iddle1784"/><a class="indexterm" id="iddle1940"/><a class="indexterm" id="iddle2039"/>In Rubinius, the new object lifetime is set to 2 by default, meaning that a young object becomes mature once the GC system has run twice with your code still holding a reference to that object. (This means that Rubinius will copy a live object twice between the from- and to-space, using the semi-space algorithm.) Over time, Rubinius adjusts the object lifetime value, based on various statistics, to optimize garbage collection as much as possible.</p><p>The JVM’s garbage collector internally calculates the new object lifetime, attempting to keep the from- and to-space heaps about half full. If these heaps start to fill up, the new object lifetime will decrease, and objects will be promoted more quickly. If the spaces are mostly empty, the JVM will increase the new object lifetime, allowing new objects to remain there longer.</p></div><div class="sect2" title="Garbage Collection for Mature Objects"><div class="titlepage"><div><div><h2 class="title"><a id="garbage_collection_for_mature_objects"/>Garbage Collection for Mature Objects</h2></div></div></div><p>Once your objects are promoted into the mature collection, they will likely live on for a long time due to the weak generational hypothesis. As a result, both the JVM and Rubinius need to run garbage collection on the mature generation much less frequently. Garbage collection on the mature generation runs once the heap allocated for mature objects fills up. Because most new objects don’t live past the new object lifetime, the mature collection fills up slowly.</p><p>The JVM offers many command-line options that allow you to configure the relative or absolute sizes of young and mature generation heaps (the JVM documentation refers to the mature generation as the <span class="emphasis"><em>tenured generation</em></span>). The JVM also maintains a third generation for internal objects created by the JVM itself: the <span class="emphasis"><em>permanent generation</em></span>. Garbage collection on the young generation is called a <span class="emphasis"><em>minor collection</em></span>, and on the tenured generation, it’s a <span class="emphasis"><em>major collection</em></span>.</p><p>Rubinius uses a sophisticated GC algorithm called <span class="emphasis"><em>Immix</em></span> for the mature generation of objects. Immix attempts to reduce the amount of total memory used and the amount of heap fragmentation by collecting active objects into continuous regions. Rubinius also uses a third generation for very large objects and collects them using a standard mark-and-sweep process.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note03"/>Note</h3><p><span class="emphasis"><em>MRI Ruby version 2.1 implements a generational GC algorithm for standard Ruby like the one the JVM and Rubinius have used for years. Its primary challenge is also detecting which mature objects reference young ones (see <a class="xref" href="ch12.html#references_between_generations" title="References Between Generations">References Between Generations</a>). MRI solves this problem by using write barriers to track each time a mature object references a young one, though implementing write barriers in MRI is complex because existing C extensions won’t contain them.</em></span></p></div><div class="sidebar"><a id="references_between_generations"/><p class="title">References Between Generations</p><p><a class="indexterm" id="iddle1349"/><a class="indexterm" id="iddle1895"/><a class="indexterm" id="iddle2105"/>In addition to the new object lifetime, generational garbage collectors have to track another important detail: young objects that are active because of a reference from an old object. Because collections on the young generation will not mark mature objects, the collector might assume that certain young objects are garbage when they are not. <a class="xref" href="ch12.html#generational_garbage_collectors_need_to" title="Figure 12-15. Generational garbage collectors need to find mature objects that reference young objects.">Figure 12-15</a> shows an example of the problem.</p><div class="figure"><a id="generational_garbage_collectors_need_to"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00284"/><img alt="Generational garbage collectors need to find mature objects that reference young objects." src="httpatomoreillycomsourcenostarchimages1854377.png.jpg"/></div></div><p class="title">Figure 12-15. Generational garbage collectors need to find mature objects that reference young objects.</p></div><p>The young collection contains several live objects (gray) and garbage objects (white). During the young object marking phase, the generational garbage collector follows only references from young objects in order to speed up the process, which occurs frequently. Notice, however, the center object marked with a question mark: Is it live or garbage? There are no references to it from other young objects, but there is a reference to it from a mature object. If Rubinius or the JVM were to run the semi-space algorithm on the young objects at left after marking them, the center object would be incorrectly considered garbage and its contents overwritten!</p><p><span class="strong"><strong>Write Barriers</strong></span></p><p>Generational garbage collectors can solve this problem using <span class="emphasis"><em>write barriers</em></span>. These are bits of code that keep track of when your program adds a reference from a mature object to a young one. When the garbage collector encounters such a reference, it considers that one mature object to be another root for use in marking young objects, thereby allowing the object in question to be considered live and to be copied properly by the semi-space algorithm.</p></div></div></div><div class="sect1" title="Concurrent Garbage Collection"><div class="titlepage"><div><div><h1 class="title"><a id="concurrent_garbage_collection"/>Concurrent Garbage Collection</h1></div></div></div><p><a class="indexterm" id="iddle1188"/><a class="indexterm" id="iddle1190"/><a class="indexterm" id="iddle1310"/><a class="indexterm" id="iddle1312"/><a class="indexterm" id="iddle1578"/>Both Rubinius and the JVM use another sophisticated technique to reduce the amount of time your application spends waiting for garbage collection: <span class="emphasis"><em>concurrent garbage collection</em></span>. When using concurrent garbage collection, the garbage collector runs at the same time as your application code. This eliminates, or at least reduces, pauses in your program due to garbage collection because your application doesn’t have to stop and wait while the garbage collector runs.</p><p>Concurrent garbage collectors run in a separate thread from the primary application. Although in theory this could mean that your application will slow a bit because part of the CPU’s time has to be spent running the GC thread, most computers today contain microprocessors with multiple cores, which allow different threads to run in parallel. This means one of the cores can be dedicated to running the GC thread, leaving the other cores to run the primary application. (In practice, this still might slow down your application because fewer cores are available.)</p><div class="note" title="Note"><h3 class="title"><a id="ch12note04"/>Note</h3><p><span class="emphasis"><em>MRI Ruby 2.1 also supports a form of concurrent garbage collection by performing the sweep portion of the mark-and-sweep algorithm in parallel while your Ruby code continues to run. This helps to reduce the amount of time your application is paused while garbage collection runs.</em></span></p></div><div class="sect2" title="Marking While the Object Graph Changes"><div class="titlepage"><div><div><h2 class="title"><a id="marking_while_the_object_graph_changes"/>Marking While the Object Graph Changes</h2></div></div></div><p>Marking objects while your application is running presents one large obstacle for concurrent garbage collectors: What if your application changes the object graph while the collector is marking it? To better understand this problem, see the example object graph in <a class="xref" href="ch12.html#garbage_collector_marking_an_object_gr" title="Figure 12-16. A garbage collector marking an object graph">Figure 12-16</a>.</p><p>This figure shows a small set of objects being marked by a concurrent garbage collector. On the left is a root object, and to the right are various child objects referenced by the root object. All of the live objects are marked with <span class="emphasis"><em>M</em></span> and shown in gray. The garbage collector, indicated by the large arrow, has already marked the live objects and is now processing the objects near the bottom. The collector is about to mark the two remaining white objects at the bottom right.</p><div class="figure"><a id="garbage_collector_marking_an_object_gr"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00285"/><img alt="A garbage collector marking an object graph" src="httpatomoreillycomsourcenostarchimages1854379.png.jpg"/></div></div><p class="title">Figure 12-16. A garbage collector marking an object graph</p></div><p>Now suppose your application, which is also running while the marking process is underway, creates a new object and adds it as a child of one of the previously marked objects. <a class="xref" href="ch12.html#your_application_creates_a_new_object_wh" title="Figure 12-17. Your application creates a new object while the marking process is underway.">Figure 12-17</a> shows the new situation.</p><div class="figure"><a id="your_application_creates_a_new_object_wh"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00286"/><img alt="Your application creates a new object while the marking process is underway." src="httpatomoreillycomsourcenostarchimages1854381.png.jpg"/></div></div><p class="title">Figure 12-17. Your application creates a new object while the marking process is underway.</p></div><p>Notice that one of the live, marked objects points to a new object that hasn’t been marked yet.</p><p>Now suppose the garbage collector finishes marking the object graph. It has marked all of the live objects, meaning that any remaining objects are assumed to be garbage. <a class="xref" href="ch12.html#collector_incorrectly_considers_the" title="Figure 12-18. The collector incorrectly considers the new live object to be garbage.">Figure 12-18</a> shows how the object graph appears at the end of the marking process.</p><div class="figure"><a id="collector_incorrectly_considers_the"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00287"/><img alt="The collector incorrectly considers the new live object to be garbage." src="httpatomoreillycomsourcenostarchimages1854383.png.jpg"/></div></div><p class="title">Figure 12-18. The collector incorrectly considers the new live object to be garbage.</p></div><p><a class="indexterm" id="iddle1191"/><a class="indexterm" id="iddle1313"/><a class="indexterm" id="iddle1577"/><a class="indexterm" id="iddle1579"/><a class="indexterm" id="iddle2055"/>The garbage collector has finished marking all live objects, but it missed the new object. The collector will now reclaim its memory, but the application will have lost valid data or will have garbage data added to one of its objects!</p></div><div class="sect2" title="Tricolor Marking"><div class="titlepage"><div><div><h2 class="title"><a id="tricolor_marking"/>Tricolor Marking</h2></div></div></div><p>The solution to this problem is to maintain a <span class="emphasis"><em>mark stack</em></span>, or a list of objects that still need to be examined by the marking process, as shown in <a class="xref" href="ch12.html#marking_process_works_through_the_ob" title="Figure 12-19. The marking process works through the objects in the mark stack.">Figure 12-19</a>.</p><div class="figure"><a id="marking_process_works_through_the_ob"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00288"/><img alt="The marking process works through the objects in the mark stack." src="httpatomoreillycomsourcenostarchimages1854385.png.jpg"/></div></div><p class="title">Figure 12-19. The marking process works through the objects in the mark stack.</p></div><p>Initially all of the root objects are placed on the mark stack. As the garbage collector marks objects, it moves them from the mark stack to the list of marked objects on the left, and it adds any child objects it finds to the mark stack. When the mark stack is exhausted, the garbage collector is finished; it has identified all live objects and any remaining objects on the right are assumed to be garbage. But with this scheme, if the application modifies one of the objects during marking, the collector can move the modified object back to the mark stack, even if it was previously marked, as shown in <a class="xref" href="ch12.html#collector_moves_a_marked_object_back" title="Figure 12-20. The collector moves a marked object back to the mark stack because the application modified it.">Figure 12-20</a>.</p><div class="figure"><a id="collector_moves_a_marked_object_back"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00289"/><img alt="The collector moves a marked object back to the mark stack because the application modified it." src="httpatomoreillycomsourcenostarchimages1854387.png"/></div></div><p class="title">Figure 12-20. The collector moves a marked object back to the mark stack because the application modified it.</p></div><p>The application has added a new object to the system, as shown at right in the figure’s remaining objects list. This time, however, the collector notices that an existing object was modified because it now contains a <a class="indexterm" id="iddle1098"/><a class="indexterm" id="iddle1186"/><a class="indexterm" id="iddle1189"/><a class="indexterm" id="iddle1201"/><a class="indexterm" id="iddle1305"/><a class="indexterm" id="iddle1311"/><a class="indexterm" id="iddle1324"/><a class="indexterm" id="iddle1337"/><a class="indexterm" id="iddle1471"/><a class="indexterm" id="iddle1494"/><a class="indexterm" id="iddle1766"/><a class="indexterm" id="iddle1985"/>reference to the new object and it moves the modified object to the mark stack in the center. As a result, the collector will eventually find and mark the new object as it works through the mark stack.</p><p>This modified marking algorithm is known as <span class="emphasis"><em>tricolor marking</em></span>: Objects already processed are considered “black”; objects on the mark stack, “gray”; and the remaining objects, “white,” as shown in <a class="xref" href="ch12.html#marking_process_works_through_the_ob" title="Figure 12-19. The marking process works through the objects in the mark stack.">Figure 12-19</a> and <a class="xref" href="ch12.html#collector_moves_a_marked_object_back" title="Figure 12-20. The collector moves a marked object back to the mark stack because the application modified it.">Figure 12-20</a>.</p><div class="note" title="Note"><h3 class="title"><a id="ch12note05"/>Note</h3><p><span class="emphasis"><em>Concurrent garbage collectors can use write barriers to detect when an application changes the object graph. Write barriers are used by both generational and concurrent garbage collectors.</em></span></p></div></div><div class="sect2" title="Three Garbage Collectors in the JVM"><div class="titlepage"><div><div><h2 class="title"><a id="three_garbage_collectors_in_the_jvm"/>Three Garbage Collectors in the JVM</h2></div></div></div><p>In order to support different types of applications and server hardware, the JVM includes three separate garbage collectors that implement concurrent garbage collection differently. You can use command-line parameters to choose which collector to run in your JRuby program. The three collectors are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="Serial"><span class="title"><strong><span class="strong"><strong>Serial</strong></span></strong></span>. This collector stops your application and performs garbage collection while your application is waiting. It doesn’t use concurrent garbage collection at all.</p></li><li class="listitem"><p title="Parallel"><span class="title"><strong><span class="strong"><strong>Parallel</strong></span></strong></span>. This collector performs many GC tasks, including minor collections, in a separate thread while your application is running.</p></li><li class="listitem"><p title="Concurrent"><span class="title"><strong><span class="strong"><strong>Concurrent</strong></span></strong></span>. This collector performs most GC tasks in parallel with your application. It’s optimized to reduce GC pauses as much as possible, but its use may slow down your application’s overall throughput.</p></li></ul></div><div class="note" title="Note"><h3 class="title"><a id="ch12note06"/>Note</h3><p><span class="emphasis"><em>In addition to these three, a variety of new, experimental garbage collectors are also available for the JVM. One of these is the garbage-first (G1) collector, and another is the continuously concurrent compacting (C4) collector.</em></span></p></div><p>Unless you direct it to do otherwise, the JVM automatically selects one of these garbage collectors, depending on the type of hardware being used. For most computers, the JVM uses the parallel collector by default; for server-class machines, it uses the concurrent collector instead. You can change the JVM’s default garbage collection choice by using command-line options when you start your JRuby program. See the article “Java SE 6 HotSpot Virtual Machine Garbage Collection Tuning” (<span class="emphasis"><em><a class="ulink" href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html">http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html</a></em></span>) for more details.</p><p>The ability to choose from these different GC algorithms and to further tune the behavior of the collector using many other configuration options is one of the great benefits of using JRuby. The effectiveness and performance of a garbage collector depends on your application’s behavior as well as the underlying algorithms used.</p><p><a class="indexterm" id="iddle1287"/><a class="indexterm" id="iddle1323"/><a class="indexterm" id="iddle1481"/><a class="indexterm" id="iddle1490"/><a class="indexterm" id="iddle1736"/>To help make sense of the myriad GC-related options provided by the JVM, Charles Nutter, one of the lead developers behind the JRuby project, suggests using the following rules of thumb:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When in doubt, stick with the JVM’s default settings. These settings work well in most cases.</p></li><li class="listitem"><p>If you have a lot of data that need to be collected frequently or periodically, the concurrent or experimental G1 collectors may do a better job than the parallel collector.</p></li><li class="listitem"><p>Try to improve your code so it uses less memory before tuning garbage collection. Tuning the JVM’s garbage collector when you are allocating too much memory solves only half the problem.</p></li></ul></div></div></div><div class="sect1" title="Experiment 12-2: Using Verbose GC Mode in JRuby"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_12-2_using_verbose_gc_mode_in"/>Experiment 12-2: Using Verbose GC Mode in JRuby</h1></div></div></div><p><a class="xref" href="ch12.html#experiment_12-1_seeing_mri_garbage_colle" title="Experiment 12-1: Seeing MRI Garbage Collection in Action">Experiment 12-1: Seeing MRI Garbage Collection in Action</a> explored garbage collection in MRI. In this experiment, we’ll see how garbage collection works in JRuby by asking the JVM to display technical information about what the JVM’s garbage collector is doing. <a class="xref" href="ch12.html#creating_10_ruby_objects_using_o-id00046" title="Example 12-12. Creating 10 Ruby objects using Object.new (jruby-gc.rb)">Example 12-12</a> shows the code from <a class="xref" href="ch12.html#experiment_12-1_seeing_mri_garbage_colle" title="Experiment 12-1: Seeing MRI Garbage Collection in Action">Experiment 12-1: Seeing MRI Garbage Collection in Action</a> that creates 10 Ruby objects.</p><div class="example"><a id="creating_10_ruby_objects_using_o-id00046"/><p class="title">Example 12-12. Creating 10 Ruby objects using <code class="literal">Object.new</code> <span class="emphasis"><em>(jruby-gc.rb)</em></span></p><div class="example-contents"><pre class="programlisting">10.times do
  obj = Object.new
end</pre></div></div><p>When we run this simple program using the <code class="literal">-J-verbose:gc</code> option, the JVM displays internal debugging information about garbage collection. Here’s the command to use:</p><a id="pro_id00076"/><pre class="programlisting">$ <span class="strong"><strong>jruby -J-verbose:gc jruby-gc.rb</strong></span></pre><p>But this command doesn’t produce any output. Perhaps we aren’t creating enough objects to trigger a garbage collection.</p><p>Let’s increase the number of new objects to 10 million, as shown in <a class="xref" href="ch12.html#creating_10_million_ruby_objects_using_o" title="Example 12-13. Creating 10 million Ruby objects using Object.new (jruby-gc.rb)">Example 12-13</a>.</p><div class="example"><a id="creating_10_million_ruby_objects_using_o"/><p class="title">Example 12-13. Creating 10 million Ruby objects using <code class="literal">Object.new</code> <span class="emphasis"><em>(jruby-gc.rb)</em></span></p><div class="example-contents"><pre class="programlisting">10000000.times do
  obj = Object.new
end</pre></div></div><p><a class="indexterm" id="iddle1684"/>The new output is shown in <a class="xref" href="ch12.html#output_produced_by_running_listing_1" title="Example 12-14. The output produced by running Example 12-13 with -J-verbose:gc">Example 12-14</a>.</p><div class="example"><a id="output_produced_by_running_listing_1"/><p class="title">Example 12-14. The output produced by running <a class="xref" href="ch12.html#creating_10_million_ruby_objects_using_o" title="Example 12-13. Creating 10 million Ruby objects using Object.new (jruby-gc.rb)">Example 12-13</a> with <code class="literal">-J-verbose:gc</code></p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>jruby -J-verbose:gc jruby-gc.rb</strong></span>
[GC 17024K-&gt;1292K(83008K), 0.0072491 secs]
[GC 18316K-&gt;1538K(83008K), 0.0091344 secs]
[GC 18562K-&gt;1349K(83008K), 0.0006953 secs]
[GC 18373K-&gt;1301K(83008K), 0.0006876 secs]
[GC 18325K-&gt;1289K(83008K), 0.0004180 secs]
[GC 18313K-&gt;1285K(83008K), 0.0006950 secs]
[GC 18309K-&gt;1285K(83008K), 0.0006597 secs]
[GC 18309K-&gt;1285K(83008K), 0.0007186 secs]
[GC 18309K-&gt;1285K(83008K), 0.0005617 secs]
[GC 18309K-&gt;1285K(83008K), 0.0006873 secs]
[GC 18309K-&gt;1285K(83008K), 0.0004944 secs]
[GC 18309K-&gt;1285K(83008K), 0.0006644 secs]
[GC 18309K-&gt;1285K(83008K), 0.0006448 secs]
[GC 18309K-&gt;1285K(83008K), 0.0007203 secs]</pre></div></div><p>The JVM displays a line of information each time garbage collection occurs while running our Ruby program. There are 14 GC events shown here. Each line contains the following information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="[GC..."><span class="title"><strong><span class="strong"><strong><code class="literal">[GC...</code></strong></span></strong></span> The <span class="emphasis"><em>GC</em></span> prefix means this event was a minor collection. The JVM cleaned up only new objects in the Eden heap or young objects in the survivor spaces.</p></li><li class="listitem"><p title="17024K-&gt;1292K"><span class="title"><strong><span class="strong"><strong><code class="literal">17024K-&gt;1292K</code></strong></span></strong></span>. These values show the amount of data used by live objects before (left of the arrow) and after (right of the arrow) the garbage collection. In this example, the amount of space taken up by live objects in the young collection dropped from about 17MB or 18MB to about 1.3MB each time.</p></li><li class="listitem"><p title="(83008K)"><span class="title"><strong><span class="strong"><strong><code class="literal">(83008K)</code></strong></span></strong></span>. The value in parentheses shows the total size of the JVM heap for this process. This value has not changed.</p></li><li class="listitem"><p title="0.0072491 secs"><span class="title"><strong><span class="strong"><strong><code class="literal">0.0072491 secs</code></strong></span></strong></span>. This value shows the amount of time taken to perform each garbage collection.</p></li></ul></div><p><a class="xref" href="ch12.html#output_produced_by_running_listing_1" title="Example 12-14. The output produced by running Example 12-13 with -J-verbose:gc">Example 12-14</a> shows that the JVM’s young heap repeatedly fills up as we create more Ruby objects. Notice that each time the JVM garbage collector usually takes less than 1 millisecond to clean up the many thousands of garbage objects.</p><p>Notice, too, that there were no major garbage collections. Why? Because we don’t save our Ruby objects. <a class="xref" href="ch12.html#creating_10_million_ruby_objects_using_o" title="Example 12-13. Creating 10 million Ruby objects using Object.new (jruby-gc.rb)">Example 12-13</a> creates 10 million objects but doesn’t use them, so the JVM’s garbage collector determines that they are all garbage and reclaims their memory immediately before they are promoted to become mature objects.</p><div class="sect2" title="Triggering Major Collections"><div class="titlepage"><div><div><h2 class="title"><a id="triggering_major_collections"/>Triggering Major Collections</h2></div></div></div><p><a class="indexterm" id="iddle1565"/><a class="indexterm" id="iddle2056"/>In order to trigger major collections, we need to create some mature objects by creating Ruby objects that don’t die young but that live on for some time. We can achieve this by saving our new objects in an array, as we did in <a class="xref" href="ch12.html#experiment_12-1_seeing_mri_garbage_colle" title="Experiment 12-1: Seeing MRI Garbage Collection in Action">Experiment 12-1: Seeing MRI Garbage Collection in Action</a>. <a class="xref" href="ch12.html#saving_10_million_ruby_objects_i-id00047" title="Example 12-15. Saving 10 million Ruby objects in an array">Example 12-15</a> repeats the same script again here for convenience.</p><div class="example"><a id="saving_10_million_ruby_objects_i-id00047"/><p class="title">Example 12-15. Saving 10 million Ruby objects in an array</p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> arr = []
    10000000.times do
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   arr &lt;&lt; Object.new
    end</pre></div></div><p>Notice at <span class="inlinemediaobject"><a id="inline_id00510"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> that we create an empty array and then insert all 10 million new objects into it at <span class="inlinemediaobject"><a id="inline_id00511"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>. Because the array contains a reference to all objects, the objects will all remain live.</p><p>Now let’s rerun our experiment using the <code class="literal">-J-verbose:gc</code> command. <a class="xref" href="ch12.html#beginning_of_the_output_produced_by" title="Example 12-16. The beginning of the output produced by running Example 12-15 with -J-verbose:gc">Example 12-16</a> shows the result.</p><div class="example"><a id="beginning_of_the_output_produced_by"/><p class="title">Example 12-16. The beginning of the output produced by running <a class="xref" href="ch12.html#saving_10_million_ruby_objects_i-id00047" title="Example 12-15. Saving 10 million Ruby objects in an array">Example 12-15</a> with <code class="literal">-J-verbose:gc</code></p><div class="example-contents"><pre class="programlisting">    $ <span class="strong"><strong>jruby -J-verbose:gc jruby-gc.rb</strong></span>
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> [GC 16196K-&gt;8571K(<span class="strong"><strong>83008K</strong></span>), 0.0873137 secs]
    [GC 25595K-&gt;20319K(83008K), 0.0480336 secs]
    [GC 37343K-&gt;37342K(83008K), 0.0611792 secs]
    [GC 37586K(83008K), 0.0029985 secs]
    [GC 54366K-&gt;54365K(83008K), 0.0617091 secs]
    [GC 65553K-&gt;65360K(83008K), 0.0586615 secs]
    [GC 82384K-&gt;82384K(100040K), 0.0479422 secs]
    [GC 89491K(100040K), 0.0124503 secs]
    [GC 95890K-&gt;95888K(147060K), 0.0795343 secs]
    [GC 96144K(147060K), 0.0030345 secs]
    [GC 130683K-&gt;130682K(148020K), 0.0941640 secs]
    [GC 147706K-&gt;147704K(165108K), 0.0925857 secs]
    [GC 150767K-&gt;151226K(168564K), 0.0226121 secs]
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> [Full GC 151226K-&gt;125676K(168564K), 0.5317203 secs]
    [GC 176397K-&gt;176404K(<span class="strong"><strong>236472K</strong></span>), 0.0999831 secs]

    --<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>Notice at <span class="inlinemediaobject"><a id="inline_id00514"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> that the output <code class="literal">[Full GC...]</code> first appears after 13 young collections. (The output continues past what is shown in <a class="xref" href="ch12.html#beginning_of_the_output_produced_by" title="Example 12-16. The beginning of the output produced by running Example 12-15 with -J-verbose:gc">Example 12-16</a>.) This tells us that many Ruby objects were promoted, filling up the mature generation and forcing a mature collection to run.</p><p><a class="indexterm" id="iddle1077"/><a class="indexterm" id="iddle1304"/><a class="indexterm" id="iddle1319"/><a class="indexterm" id="iddle1400"/><a class="indexterm" id="iddle1476"/><a class="indexterm" id="iddle1542"/><a class="indexterm" id="iddle1547"/><a class="indexterm" id="iddle1585"/><a class="indexterm" id="iddle1586"/><a class="indexterm" id="iddle1702"/>We can draw some other interesting conclusions from this output. First, the size of the young collection gradually grew from the first GC run at <span class="inlinemediaobject"><a id="inline_id00515"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> to the mature collection at <span class="inlinemediaobject"><a id="inline_id00516"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>. This tells us that the JVM was automatically increasing the total heap size as more objects were created. Notice that the total heap size value in parentheses started at around 83MB and grew to over 200MB, as shown in bold. Also, each young collection was still relatively fast at under 0.1 seconds, though much slower than the ones we saw in <a class="xref" href="ch12.html#output_produced_by_running_listing_1" title="Example 12-14. The output produced by running Example 12-13 with -J-verbose:gc">Example 12-14</a>, which took less than 1 millisecond. Remember that the semi-space algorithm copies only live objects. This time all of our Ruby objects remained alive, and the JVM had to copy them repeatedly. Finally, notice that the mature, or full, collection at <span class="inlinemediaobject"><a id="inline_id00517"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> took about 0.53 seconds, which was much longer than any of the young collections.</p></div></div><div class="sect1" title="Further Reading"><div class="titlepage"><div><div><h1 class="title"><a id="further_reading"/>Further Reading</h1></div></div></div><p>There’s a vast amount of information available on the topic of garbage collection. To learn more about John McCarthy’s original free list implementation, see his article on Lisp: “Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part 1” (<span class="emphasis"><em>Communications of the ACM</em></span>, 1960).</p><p>For a taste of modern GC research, you can read about the Immix algorithm used by Rubinius in Stephen M. Blackburn and Kathryn S. McKinley’s “A Mark-Region Garbage Collector with Space Efficiency, Fast Collection, and Mutator Performance” (<span class="emphasis"><em>ACM SIGPLAN Notices</em></span>, 2008). The following article from Oracle both explains the JVM’s overall GC algorithm and serves as a good reference for the many command-line options you can use to customize and tune the JVM’s garbage collector’s behavior: “Java SE 6 HotSpot Virtual Machine Garbage Collection Tuning” (<span class="emphasis"><em><a class="ulink" href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html">http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html</a></em></span>).</p><p>Finally, two definitive sources on GC algorithms in general and how they have changed over the years are Jones and Lins’s <span class="emphasis"><em>Garbage Collection: Algorithms for Automatic Dynamic Memory Management</em></span> (Wiley, 1996) and Jones, Hosking, and Moss’s, <span class="emphasis"><em>The Garbage Collection Handbook: The Art of Automatic Memory Management</em></span> (CRC Press, 2012).</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00048"/>Summary</h1></div></div></div><p>This chapter has covered one of the most important but least understood areas of Ruby internals: garbage collection. We learned that garbage collectors allocate memory for new objects and clean up unused garbage objects. We examined the basic algorithms used by MRI, Rubinius, and JRuby for garbage collection and discovered that MRI allocates and reclaims memory using a free list, while Rubinius and the JVM use the semi-space algorithm. We also saw how Rubinius and JRuby employ concurrent and generational GC techniques, which MRI starts to use in Ruby 2.1.</p><p>But we’ve only scratched the surface of garbage collection. Since its invention in 1960, many complex GC algorithms have been developed; indeed, garbage collection is still an active area of computer science research. The GC implementations in MRI, Rubinius, and JRuby are likely to continue to evolve and improve over time.</p></div></div></body></html>