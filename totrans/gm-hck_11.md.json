["```\nfor (int i = 0; i < creatures.size(); i++) {\n    auto c = creatures[i];\n    if (c.isEnemy && c.isCloaked) continue;\n    drawHealthBar(c.healthBar);\n}\n```", "```\n  startOfLoop:                        ; for\n      MOV i, 0                        ; int i = 0\n      JMP condition                   ; first loop, skip increment\n  increment:\n      ADD i, 1                        ; i++\n  condition:\n      CMP i, creatures.Size()         ; i < creatures.size()\n      JNB endOfLoop                   ; exit loop if i >= creatures.size()\n  body:\n      MOV c, creatures[i]             ; auto c = creatures[i]\n      TEST c.isEnemy, c.isEnemy       ; if c.isEnemy\n      JZ drawHealthBar                ; draw bar if c.isEnemy == false\n      TEST c.isCloaked, c.isCloaked   ; && c.isCloaked\n      JZ drawHealthBar                ; draw bar if c.isCloaked == false\n➊     JMP increment                   ; continue\n  drawHealthBar:\n      CALL drawHealthBar(c.healthBar) ; drawHealthBar(c.healthBar)\n      JMP increment                   ; continue\n  endOfLoop:\n```", "```\ntemplate<int SIZE>\nvoid writeNop(DWORD address)\n{\n    auto oldProtection =\n        protectMemory<BYTE[SIZE]>(address, PAGE_EXECUTE_READWRITE);\n\n    for (int i = 0; i < SIZE; i++)\n        writeMemory<BYTE>(address + i, 0x90);\n\n    protectMemory<BYTE[SIZE]>(address, oldProtection);\n}\n```", "```\nwriteNop<2>(0xDEADBEEF);\n```", "```\nCALL 0x0BADF00D\n```", "```\n0xE8 0x0BADF00D\n```", "```\n0xE8 0x0D 0xF0 0xAD 0x0B\n```", "```\ncalleeAddress – (callAddress + 5)\n```", "```\n0x0BADF00D – (0xDEADBEEF + 5) = 0x2D003119\n```", "```\n0xE8 0x19 0x31 0x00 0x2D\n```", "```\n  DWORD callHook(DWORD hookAt, DWORD newFunc)\n  {\n      DWORD newOffset = newFunc - hookAt - 5;\n\n      auto oldProtection =\n          protectMemory<DWORD>(hookAt + 1, PAGE_EXECUTE_READWRITE);\n\n      DWORD originalOffset = readMemory<DWORD>(➊hookAt + 1);\n      writeMemory<DWORD>(hookAt + 1, newOffset);\n      protectMemory<DWORD>(hookAt + 1, oldProtection);\n\n➋     return originalOffset + hookAt + 5;\n  }\n```", "```\nDWORD origFunc = callHook(0xDEADBEEF, (DWORD)&someNewFunction);\n```", "```\nPUSH 1\nPUSH 456\nPUSH 321\nCALL 0x0BADF00D \nADD ESP, 0x0C\n```", "```\nDWORD __cdecl someNewFunction(DWORD arg1, DWORD arg2, DWORD arg3)\n{\n\n}\n```", "```\ntypedef DWORD (__cdecl _origFunc)(DWORD arg1, DWORD arg2, DWORD arg3);\n\n_origFunc* originalFunction =\n    (_origFunc*)hookCall(0xDEADBEEF, (DWORD)&someNewFunction);\n\nDWORD __cdecl someNewFunction(DWORD arg1, DWORD arg2, DWORD arg3)\n{\n    return originalFunction(arg1, arg2, arg3);\n}\n```", "```\nclass someBaseClass {\n    public:\n        virtual DWORD someFunction(DWORD arg1) {}\n};\nclass someClass : public someBaseClass {\n    public:\n        virtual DWORD someFunction(DWORD arg1) {}\n};\n```", "```\n   DWORD __stdcall someNewVFFunction(DWORD arg1)\n   { \n➊      static DWORD _this;\n        __asm MOV _this, ECX\n   }\n```", "```\nDWORD __stdcall someNewVFFunction(DWORD arg1)\n{\n    static DWORD _this;\n    __asm MOV _this, ECX\n\n    // do game modifying stuff here\n\n __asm ➊MOV ECX, _this\n}\n```", "```\n   DWORD __stdcall someNewVFFunction(DWORD arg1)\n   {\n       static DWORD _this, _ret;\n       __asm MOV _this, ECX\n\n       // do pre-call stuff here\n\n       __asm {\n           PUSH arg1\n           MOV ECX, _this\n➊          CALL [originalVFFunction]\n➋          MOV _ret, EAX\n       }\n\n       // do post-call stuff here\n\n➌      __asm MOV ECX, _this\n       return _ret;\n   }\n```", "```\nDWORD hookVF(DWORD classInst, DWORD funcIndex, DWORD newFunc)\n{\n    DWORD VFTable = ➊readMemory<DWORD>(classInst);\n    DWORD hookAt = VFTable + funcIndex * sizeof(DWORD);\n\n    auto oldProtection =\n        protectMemory<DWORD>(hookAt, PAGE_READWRITE);\n    DWORD originalFunc = readMemory<DWORD>(hookAt);\n    writeMemory<DWORD>(hookAt, newFunc);\n    protectMemory<DWORD>(hookAt, oldProtection);\n\n    return originalFunc;\n}\n```", "```\nDWORD origVFFunction =\n    hookVF(classInstAddr, 0, (DWORD)&someNewVFFunction);\n```", "```\nDWORD baseAddr = (DWORD)GetModuleHandle(NULL);\n```", "```\nauto dosHeader = pointMemory<IMAGE_DOS_HEADER>(baseAddr);\nif (dosHeader->e_magic != 0x5A4D)\n    return 0;\n\nauto optHeader =\n    pointMemory<IMAGE_OPTIONAL_HEADER>(baseAddr + dosHeader->e_lfanew + 24);\nif (optHeader->Magic != 0x10B)\n    return 0;\n```", "```\nauto IAT = optHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];\nif (IAT.Size == 0 || IAT.VirtualAddress == 0)\n    return 0;\n```", "```\n   auto impDesc =\n       pointMemory<IMAGE_IMPORT_DESCRIPTOR>(➊baseAddr + IAT.VirtualAddress);\n\n➋ while (impDesc->FirstThunk) {\n➌     auto thunkData =\n          pointMemory<IMAGE_THUNK_DATA>(baseAddr + impDesc->OriginalFirstThunk);\n      int n = 0;\n➍     while (thunkData->u1.Function) {\n          // the hook happens in here\n          n++;\n          thunkData++;\n      }\n      impDesc++;\n   }\n```", "```\nchar* importFunctionName =\n    pointMemory<char>(baseAddr + (DWORD)thunkData->u1.AddressOfData + 2);\n```", "```\nif (strcmp(importFuncName, funcName) == 0) {\n    // the final step happens in here\n}\n```", "```\n   auto vfTable = pointMemory<DWORD> (baseAddr + impDesc->FirstThunk);\n   DWORD original = vfTable[n];\n\n➊ auto oldProtection = protectMemory<DWORD>((DWORD)&vfTable[n], PAGE_READWRITE);\n➋ vfTable[n] = newFunc;\n   protectMemory<DWORD>((DWORD)&vfTable[n], oldProtection);\n```", "```\nDWORD hookIAT(const char* funcName, DWORD newFunc)\n                 {\n    DWORD baseAddr = (DWORD)GetModuleHandle(NULL);\n    auto dosHeader = pointMemory<IMAGE_DOS_HEADER>(baseAddr);\n    if (dosHeader->e_magic != 0x5A4D)\n        return 0;\n\n    auto optHeader =\n        pointMemory<IMAGE_OPTIONAL_HEADER>(baseAddr + dosHeader->e_lfanew + 24);\n    if (optHeader->Magic != 0x10B)\n        return 0;\n\n    auto IAT =\n        optHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];\n    if (IAT.Size == 0 || IAT.VirtualAddress == 0)\n        return 0;\n\n    auto impDesc =\n        pointMemory<IMAGE_IMPORT_DESCRIPTOR>(baseAddr + IAT.VirtualAddress);\n\n    while (impDesc->FirstThunk) {\n        auto thunkData =\n            pointMemory<IMAGE_THUNK_DATA>(baseAddr + impDesc->OriginalFirstThunk);\n        int n = 0;\n        while (thunkData->u1.Function) {\n            char* importFuncName = pointMemory<char>\n                (baseAddr + (DWORD)thunkData->u1.AddressOfData + 2);\n            if (strcmp(importFuncName, funcName) == 0) {\n                auto vfTable = pointMemory<DWORD>(baseAddr + impDesc->FirstThunk);\n                DWORD original = vfTable[n];\n                auto oldProtection =\n                    protectMemory<DWORD>((DWORD)&vfTable[n], PAGE_READWRITE);\n                vfTable[n] = newFunc;\n                protectMemory<DWORD>((DWORD)&vfTable[n], oldProtection);\n                return original;\n            }\n            n++;\n            thunkData++;\n        }\n        impDesc++;\n    }\n}\n```", "```\nVOID WINAPI newSleepFunction(DWORD ms)\n{\n    // do thread-sensitive things\n    originalSleep(ms);\n}\n\ntypedef VOID (WINAPI _origSleep)(DWORD ms);\n_origSleep* originalSleep =\n    (_origSleep*)hookIAT(\"Sleep\", (DWORD)&newSleepFunction);\n```", "```\nPOP EAX\nMOV AL, 1\nPOP EDI\nPOP ESI\n```", "```\n   DWORD hookWithJump(DWORD hookAt, DWORD newFunc, int size)\n   {\n       if (size > 12) // shouldn't ever have to replace 12+ bytes\n           return 0;\n➊      DWORD newOffset = newFunc - hookAt - 5;\n\n       auto oldProtection =\n           protectMemory<DWORD[3]>(hookAt + 1,PAGE_EXECUTE_READWRITE);\n➋      writeMemory<BYTE>(hookAt, 0xE9);\n➌      writeMemory<DWORD>(hookAt + 1, newOffset);\n       for (unsigned int i = 5; i < size; i++)\n           writeMemory<BYTE>(hookAt + i, 0x90);\n       protectMemory<DWORD[3]>(hookAt + 1, oldProtection);\n\n       return hookAt + 5;\n   }\n```", "```\n   DWORD restoreJumpHook = 0;\n   void __declspec(naked) myTrampoline()\n   {\n      __asm {\n➊         PUSHFD\n➋         PUSHAD\n➌         CALL jumpHookCallback\n➍         POPAD\n➎         POPFD\n➏         POP EAX\n          MOV AL, 1\n          POP EDI\n➐         POP ESI\n➑         JMP [restoreJumpHook]\n      }\n  }\n```", "```\nvoid jumpHookCallback() {\n    // do stuff\n}\nrestoreJumpHook = hookWithJump(0xDEADBEEF, &myTrampoline, 5);\n```", "```\nvoid jumpHookCallback(DWORD EDI, DWORD ESI, DWORD EBP, DWORD ESP,\n                      DWORD EBX, DWORD EDX, DWORD ECX, DWORD EAX) {\n    // do stuff\n}\nrestoreJumpHook = hookWithJump(0xDEADBEEF, &myTrampoline, 5);\n```", "```\n_emit BYTE\n```", "```\n   loop:\n       MOV EAX, [ESI+3C58]\n       SUB EAX,EDI\n       PUSH EAX\n➊      LEA EAX, [ESI+EDI+1C58]\n       PUSH EAX\n       MOV ECX,ESI\n➋      CALL encode\n       CMP EAX,-1\n➌      JE SHORT endLoop\n       ADD EDI,EAX\n➍      CMP EDI, [ESI+3C58]\n       JL loop\n   endLoop:\n```", "```\nfor (EDI = 0; EDI < ➍[ESI+3C58]; ) {\n    EAX = ➋encode(➊&[ESI+EDI+1C58], [ESI+3C58] - EDI);\n    if (EAX == -1) ➌break;\n    EDI += EAX;\n}\n```", "```\nDWORD __stdcall reportEncode(\n    const unsigned char* buffer,\n    unsigned int size,\n    unsigned int loopCounter)\n{\n    if (loopCounter == 0)\n        printBuffer(buffer, size);\n    return origEncodeFunc;\n}\n```", "```\nvoid __declspec(naked) myEncode()\n{\n    __asm {\n        MOV EAX, DWORD PTR SS:[ESP + 0x4]     // get buffer\n        MOV EDX, DWORD PTR DS:[ESI + 0x3C58]  // get full size\n        PUSH ECX           // store ecx\n        PUSH EDI           // push current pos (loop counter)\n        PUSH EDX           // push size\n        PUSH EAX           // push buffer\n        CALL reportEncode  // report the encode call\n        POP ECX            // restore ecx\n        JMP EAX            // jump to encode\n    }\n}\n```", "```\nvoid __stdcall reportDecode(const unsigned char* buffer, unsigned int size)\n{\n    printBuffer(buffer, size);\n}\n```", "```\n   void __declspec(naked) myDecode()\n   {\n       __asm {\n           MOV EAX, DWORD PTR SS:[ESP + 0x4] // get buffer\n           MOV EDX, DWORD PTR SS:[ESP + 0x8] // get size\n           PUSH EDX                          // push size\n           PUSH EAX                          // push buffer\n➊          CALL [origDecodeFunc]\n\n           MOV EDX, DWORD PTR SS:[ESP + 0x4] // get the buffer\n\n           PUSH EAX                          // store eax (return value)\n           PUSH ECX                          // store ecx\n           PUSH EAX                          // push size\n           PUSH EDX                          // push buffer\n           CALL reportDecode                 // report the results now\n           POP ECX                           // restore ecx\n➋          POP EAX                           // restore eax (return value)\n➌          RETN 8                            // return and clean stack\n       }\n   }\n```", "```\n   MODULEENTRY32 entry;\n   entry.dwSize = sizeof(MODULEENTRY32);\n   HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, NULL);\n\n   DWORD base, size;\n   if (Module32First(snapshot, &entry) == TRUE) {\n➊      while (Module32Next(snapshot, &entry) == TRUE) {\n           std::wstring binaryPath = entry.szModule;\n➋          if (binaryPath.find(\"Adobe AIR.dll\") != std::wstring::npos) {\n               size = (DWORD)entry.modBaseSize;\n               base = (DWORD)entry.modBaseAddr;\n               break;\n           }\n       }\n   }\n\n   CloseHandle(snapshot);\n```", "```\nconst char encodeSeq[16] = {\n    0x8B, 0xCE,                   // MOV ECX, ESI\n    0xE8, 0xA6, 0xFF, 0xFF, 0xFF, // CALL encode\n    0x83, 0xF8, 0xFF,             // CMP EAX, -1\n    0x74, 0x16,                   // JE SHORT endLoop\n    0x03, 0xF8,                   // ADD EDI, EAX\n    0x3B, 0xBE};                  // part of CMP EDI, [ESI+0x3C58]\nconst char decodeSeq[12] = {\n    0x8B, 0xCE,                   // MOV ECX, ESI\n    0xE8, 0x7F, 0xF7, 0xFF, 0xFF, // CALL decode\n    0x83, 0xF8, 0xFF,             // CMP EAX, -1\n    0x89, 0x86};                  // part of MOV [ESI+0x1C54], EAX\n```", "```\nDWORD findSequence(\n    DWORD base, DWORD size,\n    const char* sequence,\n    unsigned int seqLen){\n    for (DWORD adr = base; adr <= base + size – seqLen; adr++) {\n        if (memcmp((LPVOID)sequence, (LPVOID)adr, seqLen) == 0)\n            return adr;\n    }\n    return 0;\n}\n```", "```\nDWORD encodeHookAt =\n    findSequence(base, size, encodeSeq, 16) + 2;\nDWORD decodeHookAt =\n    findSequence(base, size, decodeSeq, 12) + 2;\n```", "```\nint WINAPI WinMain(args)\n{\n    /* Some code here would be called\n       to set up Direct3D and initialize\n       the game. Leaving it out for brevity. */\n    MSG msg;\n    while(TRUE) {\n        /* Some code would be here to handle incoming\n           mouse and keyboard messages. */\n        drawFrame(); // this is the function we care about\n    }\n    /* Some code here would be called to\n       clean up everything before exiting. */\n}\n```", "```\n   void drawFrame()\n   { \n➊      device->Clear(0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0, 0, 0), 1.0f, 0);\n       device->BeginScene();\n       // drawing will happen here\n       device->EndScene();\n       device->Present(NULL, NULL, NULL, NULL);\n   }\n```", "```\nLPDIRECT3D9 pD3D = Direct3DCreate9(D3D_SDK_VERSION);\nif (!pD3D) return 0;\n\nD3DPRESENT_PARAMETERS d3dpp;\nZeroMemory( &d3dpp, sizeof(d3dpp) );\nd3dpp.Windowed = TRUE;\nd3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;\nd3dpp.hDeviceWindow = hWnd;\n\nLPDIRECT3DDEVICE9 device;\nHRESULT res = pD3D->CreateDevice(\n    D3DADAPTER_DEFAULT,\n    D3DDEVTYPE_HAL,\n    hWnd,\n    D3DCREATE_SOFTWARE_VERTEXPROCESSING,\n    &d3dpp, &device);\nif (FAILED(res)) return 0;\n```", "```\nDWORD getVF(DWORD classInst, DWORD funcIndex)\n{\n    DWORD VFTable = readMemory<DWORD>(classInst);\n    DWORD hookAddress = VFTable + funcIndex * sizeof(DWORD);\n    return readMemory<DWORD>(hookAddress);\n}\nDWORD EndSceneAddress = getVF((DWORD)device, 42);\n```", "```\npD3D->Release();\ndevice->Release();\n```", "```\n   unsigned char* hookWithJump(DWORD hookAt, DWORD newFunc)\n   {\n       DWORD newOffset = newFunc - hookAt - 5;\n➊      auto oldProtection = protectMemory<BYTE[5]>(hookAt, PAGE_EXECUTE_READWRITE);\n       unsigned char* originals = new unsigned char[5];\n       for (int i = 0; i < 5; i++)\n➋          originals[i] = readMemory<unsigned char>(hookAt + i);\n➌      writeMemory<BYTE>(hookAt, 0xE9);\n       writeMemory<DWORD>(hookAt + 1, newOffset);\n       protectMemory<BYTE[5]>(hookAt, oldProtection);\n       return originals;\n   }\n```", "```\nvoid unhookWithJump(DWORD hookAt, unsigned char* originals)\n{\n    auto oldProtection = protectMemory<BYTE[5]>(hookAt, PAGE_EXECUTE_READWRITE);\n    for (int i = 0; i < 5; i++)\n        writeMemory<BYTE>(hookAt + i, originals[i]);\n    protectMemory<BYTE[5]>(hookAt, oldProtection);\n    delete [] originals;\n}\n```", "```\nauto originals = hookWithJump(EndSceneAddress, (DWORD)&endSceneTrampoline);\nunhookWithJump(EndSceneAddress, originals);\n```", "```\n   LPDIRECT3DDEVICE9 discoveredDevice;\n   DWORD __stdcall reportInitEndScene(LPDIRECT3DDEVICE9 device)\n   {\n       discoveredDevice = device;\n       unhookWithJump(EndSceneAddress, originals);\n       return EndSceneAddress;\n   }\n   __declspec(naked) void endSceneTrampoline()\n   {\n       __asm {\n           MOV EAX, DWORD PTR SS:[ESP + 0x4]\n           PUSH EAX  // give the device to the callback\n➊          CALL reportInitEndScene\n           JMP EAX   // jump to the start of EndScene\n       }\n   }\n```", "```\ntypedef HRESULT (WINAPI* _endScene)(LPDIRECT3DDEVICE9 pDevice);\n_endScene origEndScene =\n    (_endScene)hookVF((DWORD)discoveredDevice, 42,(DWORD)&myEndScene);\nHRESULT WINAPI myEndScene(LPDIRECT3DDEVICE9 pDevice)\n{\n    // draw your own stuff here\n    return origEndScene(pDevice);\n}\n```", "```\n_endScene origEndScene = NULL;\nvoid placeHooks()\n{\n    auto ret = hookVF((DWORD)discoveredDevice, 42, (DWORD)&myEndScene);\n    if (ret != (DWORD)&myEndScene) // don't point to your hook\n        origEndScene = (_endScene)ret;\n}\nplaceHooks();\n\nHRESULT WINAPI myEndScene(LPDIRECT3DDEVICE9 pDevice)\n{\n    // draw your own stuff here\n    auto ret = origEndScene(pDevice);\n    placeHooks(); // update hooks\n    return ret;\n}\n```", "```\nauto ret = hookVF((DWORD)discoveredDevice, 16, (DWORD)&myReset);\nif (ret != (DWORD)&myReset)\n    origReset = (_reset)ret;\n```", "```\ntypedef HRESULT (WINAPI* _reset)(\n    LPDIRECT3DDEVICE9 pDevice,\n    D3DPRESENT_PARAMETERS* pPresentationParameters);\n_reset origReset = NULL;\n```", "```\nHRESULT WINAPI myReset(\n    LPDIRECT3DDEVICE9 pDevice,\n    D3DPRESENT_PARAMETERS* pPresentationParameters)\n{\n    auto result = origReset(pDevice, pPresentationParameters);\n    if (result == D3D_OK) {\n        // call onLostDevice() for all of your objects\n    }\n    return result;\n}\n```"]