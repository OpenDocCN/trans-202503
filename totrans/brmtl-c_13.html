<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="207" id="Page_207"/>12</span><br/>
<span class="ChapterTitle">The Preprocessor</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">The basic C compiler has a number of powerful features, but there are some things it just can’t do. To get around its limitations, a preprocessor was added to the language. The preprocessor is primarily a <em>macro processor</em>, a program that replaces text with other text, but it can also include and exclude text and perform other actions based on certain conditions. The idea is to have one program (the preprocessor) do a small, simple text editing job and then feed that into the compiler proper. Since those two steps (and a few others) are hidden behind the <code>gcc</code> command, you hardly think about them, but they are there.</p>
<p><span epub:type="pagebreak" title="208" id="Page_208"/>For example, let’s look at the following code:</p>
<pre><code>#define SIZE 20    // Size of the array
int array[SIZE];   // The array
<var>--snip--</var>
    for (unsigned int i = 0; i &lt; SIZE; ++i) {</code></pre>
<p>When <code>SIZE</code> is defined to mean <code>20</code>, the preprocessor essentially does a global search and replace of <code>SIZE</code> with <code>20</code>.</p>
<p>The HAL library we’re using with our STM microprocessor makes extensive use of the preprocessor in a couple of ways. First, the headers contain a <code>#define</code> for every gettable and settable bit in the processor, and there are quite a few of them. Second, STMicroelectronics doesn’t make only one chip; it makes a wide variety. Rather than have 20 different header files with information on 20 chips, it uses a process called <em>conditional compilation</em> to compile only the parts of the header file that are needed.</p>
<h2 id="h1-501621c12-0001">Simple Macros</h2>
<p class="BodyFirst">Let’s start with the simple macros. A <em>macro</em> is basically a pattern (in this case, <code>SIZE</code>) that is replaced by something else (in this case, <code>20</code>). The <code>#define</code> preprocessor directive is used to define the pattern and replacement:</p>
<p class="CodeLabel"><b>size.c</b></p>
<pre><code>#define SIZE 20
The size is SIZE</code></pre>
<p>This is not a C program. The preprocessor works on anything, including just English text. Let’s run it through the preprocessor using the <code>-E</code> flag, which tells <code>gcc</code> to run the program through the preprocessor only and stop:</p>
<pre><code>$ <b>gcc -E size.c</b></code></pre>
<p>Here are the preprocessed results:</p>
<pre><code># 1 "size.c"
# 1 "&lt;built-in&gt;"
# 1 "&lt;command-line&gt;"
# 31 "&lt;command-line&gt;"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 32 "&lt;command-line&gt;" 2
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> # 1 "size.c"

<span class="CodeAnnotationHang" aria-label="annotation2">2</span> The size is 20</code></pre>
<p>The lines beginning with a hash mark (<code>#</code>) are called <em>line markers</em>. They consist of a hash mark, a line number, and the name of the file (and some other junk). Since the preprocessor may add or remove lines, it would be impossible for the compiler to know where it was in the original input file without them.</p>
<p><span epub:type="pagebreak" title="209" id="Page_209"/>A lot happens before the first line is processed, but finally we get to the second occurrence of it <span class="CodeAnnotation" aria-label="annotation1">1</span>, and the output <span class="CodeAnnotation" aria-label="annotation2">2</span> shows that <code>SIZE</code> has been replaced with the defined value.</p>
<p>The preprocessor takes things literally, which can get you into trouble, as shown here:</p>
<p class="CodeLabel"><b>square.c</b></p>
<pre><code>#include &lt;stdio.h&gt;

<span class="CodeAnnotationHang" aria-label="annotation1">1</span> #define SIDE 10 + 2   // Size + margin

int main()
{
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> printf("Area %d\n", SIDE * SIDE);
    return (0);
}       </code></pre>
<p>This example finds the area of a square. It includes a little margin so the side of the square is defined <span class="CodeAnnotation" aria-label="annotation1">1</span>. To get the area, we multiply the sides together and print the result <span class="CodeAnnotation" aria-label="annotation2">2</span>. However, this program contains a bug: <code>SIZE</code> is not <code>12</code>; it is <code>10 + 2</code>. The preprocessor is a dumb text editor. It does not understand C syntax or arithmetic.</p>
<p>After passing the program through the preprocessor, we can see where we made our mistake:</p>
<p class="CodeLabel"><b>square.i</b></p>
<pre><code># 5 "square.c"
int main()
{
    printf("Area %d\n", 10 + 2 * 10 + 2);
    return (0);
}</code></pre>
<p>As mentioned previously, the preprocessor doesn’t understand C. When we use the following statement, it defines <code>SIZE</code> as literally <code>10 + 2</code> rather than <code>12</code>:</p>
<pre><code>#define SIDE 10 + 2   // Size + margin</code></pre>
<p>And as you can see, <code>12 * 12</code> is a different number from <code>10 + 2 * 10 + 2</code>.</p>
<p>When using <code>#define</code> to define constants more complex than a simple number, we put parentheses around the entire expression, as shown here:</p>
<pre><code>#define SIDE (10 + 2)   // Size + margin</code></pre>
<p>Following this style rule prevents incorrect results from an unexpected order of operations after substitution.</p>
<p>To avoid the issue of incorrect macro evaluation entirely when the purpose of a <code>#define</code> is to set or calculate a value in one place and then use it throughout the program, use <code>const</code>, which is preferred over <code>#define</code> wherever possible. Here’s an example:</p>
<pre><code>const unsigned int SIDE = 10 + 2;       // This works.</code></pre>
<p><span epub:type="pagebreak" title="210" id="Page_210"/>The main reason for this rule is that the <code>const</code> modifier is part of the C language, and the compiler will evaluate the expression assigned to a <code>const</code> variable, so <code>SIDE</code> is actually <code>12</code>.</p>
<p>When C was first designed, it had no <code>const</code> modifier, so everyone had to use the <code>#define</code> statement, which is why <code>#define</code> is so widely used, even though the more modern <code>const</code> has been available for some time.</p>
<h3 id="h2-501621c12-0001">Parameterized Macros</h3>
<p class="BodyFirst"><em>Parameterized</em> <em>macros</em> allow us to give arguments to macros. Here’s an example:</p>
<pre><code>#define DOUBLE(x) (2 * (x))
<var>--snip--</var>
    printf("Twice %d is %d\n", 32, DOUBLE(32);</code></pre>
<p>In this case, we don’t need to put the parentheses around the argument in the expansion. We could write the macro as follows:</p>
<pre><code>#define DOUBLE_BAD(x) (2 * x)</code></pre>
<p>Why is this bad? Consider what happens when we use this macro with an expression:</p>
<pre><code>    value = DOUBLE_BAD(1 + 2)</code></pre>
<p>The style rule is to include parentheses around the arguments to parameterized macros. Without the parentheses, <code>DOUBLE(1+2)</code> expands to the following:</p>
<pre><code>DOUBLE(1+2) = (2 * 1 + 2) = 4   // Wrong</code></pre>
<p>With the parentheses, we get this:</p>
<pre><code>DOUBLE(1+2) = (2 * (1 + 2)) = 6</code></pre>
<p>We already have a rule that states to not use <code>++</code> or <code>--</code> except on lines by themselves. Let’s see what happens when we break that rule using a parameterized macro:</p>
<pre><code>#define CUBE(x) ((x) * (x) * (x))

    int x = 5;

    int y = CUBE(x++);</code></pre>
<p>What’s the value of <code>x</code> after this is executed? It’s <code>8</code> instead of <code>6</code>, as expected. Worse, the value of <code>y</code> can be anything, because C’s order of execution rules are ambiguous when it comes to mixing multiply (<code>*</code>) and increment (<code>++</code>) operations.</p>
<p><span epub:type="pagebreak" title="211" id="Page_211"/>If you’re going to write code like this, consider <code>inline</code> functions, which replace the function call with the body of the function:</p>
<pre><code>static inline int CUBE_INLINE(const int x) {
    return (x * x * x);
}</code></pre>
<p>It works even if you use the following statement:</p>
<pre><code>y = CUBE_INLINE(x++);</code></pre>
<p>But again, you shouldn’t write code like this. Instead, write code like this:</p>
<pre><code>x++;
y = CUBE_INLINE(x);</code></pre>
<p>Use <code>inline</code> functions instead of parameterized macros whenever possible. Because <code>inline</code> functions are part of the C language, the compiler can make sure they’re being used correctly (unlike the preprocessor, which just replaces text blindly).</p>
<h3 id="h2-501621c12-0002">Code Macros</h3>
<p class="BodyFirst">So far, we’ve been writing macros to define constants and simple expressions. We can use <code>#define</code> to define code. Here’s an example:</p>
<pre><code>#define FOR_EACH_VALUE for (unsigned int i = 0; i &lt; VALUE_SIZE; ++i)
<var>--snip--</var>
    int sum = 0;
    FOR_EACH_VALUE
        sum += value[i]</code></pre>
<p>However, this code has some problems. First, it’s not obvious where the variable <code>i</code> comes from. We’ve also obscured what’s incrementing it, which is why this sort of macro is rarely seen.</p>
<p>A more common macro is one that emulates a short function. Let’s define a macro called <code>DIE</code> that writes out a message and then kills the program:</p>
<pre><code>// Defined badly
#define DIE(why)              \
    printf("Die: %s\n", why); \
    exit(99);</code></pre>
<p>We use the backslash (<code>\</code>) to extend the macro over multiple lines. We can use this macro as follows:</p>
<pre><code>void functionYetToBeImplemented(void) {
    DIE("Function has not been written yet");
}</code></pre>
<p><span epub:type="pagebreak" title="212" id="Page_212"/>In this case, it works, which is due more to luck than design. The problem is that <code>DIE</code> looks like a function, so we can treat it as a function. Let’s put it inside an <code>if</code> statement:</p>
<pre><code>// Problem code
if (index &lt; 0)
    DIE("Illegal index");</code></pre>
<p>To understand why this is a problem, let’s look at the expansion of this code:</p>
<pre><code>if (index &lt; 0)
   printf("Die %s\n", "Illegal index");
   exit(99);  </code></pre>
<p>Here it is properly indented:</p>
<pre><code>if (index &lt; 0)
    printf("Die %s\n", "Illegal index");
exit(99);  </code></pre>
<p>In other words, it will always exit, even if the index is good.</p>
<p>Let’s see if we can fix this issue by putting curly brackets (<code>{}</code>) around our statements:</p>
<pre><code>// Defined not as badly
#define DIE(why) {            \
    printf("Die: %s\n", why); \
    exit(99);                 \
}</code></pre>
<p>This now works in the following case:</p>
<pre><code>// Problem code
if (index &lt; 0)
    DIE("Illegal index");</code></pre>
<p>However, it does not work in this case:</p>
<pre><code>if (index &lt; 0)
    DIE("Illegal index");
else
    printf("Did not die\n");</code></pre>
<p>This code generates an error message: <code>else without previous if</code>. However, we have an <code>if</code> right there. Let’s look at the expansion:</p>
<pre><code>if (index &lt; 0)
{
    printf("Die: %s\n", why); \
    exit(99);                 \
};                 // &lt;=== Notice two characters here.
<span epub:type="pagebreak" title="213" id="Page_213"/>else
    print("Did not die\n");</code></pre>
<p>The problem here is that before the <code>else</code>, C wants a statement ending with a semicolon (<code>;</code>) <em>or</em> a set of statements enclosed in curly brackets (<code>{}</code>). It doesn’t know what to do with a set of statements enclosed in curly brackets that ends in a semicolon.</p>
<p>The solution to this problem is to use an obscure C statement called the <code>do</code>/<code>while</code>. It looks like this:</p>
<pre><code>do {
   // Statements
}
while (<var>condition</var>);</code></pre>
<p>The statements in the block after <code>do</code> always execute once, and then again as long the <var>condition</var> is true. Although it is part of the C language standard, I’ve seen it used only twice in the wild, and one of those times was as a punch line to a joke.</p>
<p>However, it is used for code macros:</p>
<pre><code>#define DIE(why)
do {            \
    printf("Die: %s\n", why); \
    exit(99);                 \
} while (0)</code></pre>
<p>It works because we can put a semicolon after it:</p>
<pre><code>if (index &lt; 0)
    DIE("Illegal index");   // Note semicolon at the end of the statement.
else
    printf("Did not die\n");</code></pre>
<p>This code expands to the following:</p>
<pre><code>if (index &lt; 0)
    do {
        printf("Die: %s\n", "Illegal index");
        exit(99);
    } while (0);
else
    printf("Did not die\n");</code></pre>
<p>Syntactically, <code>do</code>/<code>while</code> is a single statement, and we can include a semicolon after it without trouble. The code within the curly brackets (<code>printf</code> and <code>exit</code>) is safely encapsulated inside the <code>do</code>/<code>while</code>. The code outside the curly brackets is one statement, and that’s what we want. Now the compiler will accept the code macro.</p>
<h2 id="h1-501621c12-0002"><span epub:type="pagebreak" title="214" id="Page_214"/>Conditional Compilation</h2>
<p class="BodyFirst">Conditional compilation allows us to change what’s in our code at compile time. The classic use for this feature is to have a debug version and a production version of a program.</p>
<p>The <code>#ifdef</code>/<code>#endif</code> directive pair will compile the code between the two directives if a symbol is defined. Here’s an example:</p>
<pre><code>int main()
{
#ifdef DEBUG
    printf("Debug version\n");
#endif // DEBUG</code></pre>
<p>Strictly speaking, the <code>// DEBUG</code> comment is not required, but be sure to include it because matching <code>#ifdef</code>/<code>#endif</code> pairs is hard enough.</p>
<p>If your program looks like:</p>
<pre><code>#define DEBUG   // Debug version

int main()
{
#ifdef DEBUG
    printf("Debug version\n");
#endif // DEBUG</code></pre>
<p class="BodyContinued">then the preprocessed result will be the following:</p>
<pre><code>int main()
{
    printf("Debug version\n");</code></pre>
<p>On the other hand, if your program looks like:</p>
<pre><code>//#define DEBUG         // Release version

int main()
{
#ifdef DEBUG
    printf("Debug version\n");
#endif // DEBUG</code></pre>
<p class="BodyContinued">then the preprocessed result will be the following:</p>
<pre><code>int main()
{
    // Nothing</code></pre>
<p>Because <code>DEBUG</code> is not defined, no code is generated.</p>
<p><span epub:type="pagebreak" title="215" id="Page_215"/>One problem is that all the <code>#ifdef</code> statements tend to make the program look ugly. Consider the following:</p>
<pre><code>int main()
{
#ifdef DEBUG
    printf("Debug version\n");
#endif // DEBUG

#ifdef DEBUG
    printf("Starting main loop\n");
#endif // DEBUG

    while (1) {
#ifdef DEBUG
        printf("Before process file \n");
#endif // DEBUG
        processFile();
#ifdef DEBUG
        printf("After process file \n");
#endif // DEBUG</code></pre>
<p>We can do the same thing with a lot less code:</p>
<pre><code>#ifdef DEBUG
#define debug(msg) printf(msg)
#else // DEBUG
#define debug(msg) /* nothing */
#endif // DEBUG

int main()
{
    debug("Debug version\n");
    debug("Starting main loop\n");

    while (1) {
        debug("Before process file \n");
        processFile();
        debug("After process file \n");</code></pre>
<p>Notice that we used the <code>#else</code> directive to tell the preprocessor to reverse the sense of the <code>#if</code>. If <code>DEBUG</code> is defined, calls to <code>debug</code> will be replaced with calls to <code>printf</code>; otherwise, they’ll be replaced by blank space. In this case, we don’t need the <code>do</code>/<code>while</code> trick because the code macro contains a single function call (with no semicolon).</p>
<p>Another directive, <code>#ifndef</code>, is true if a symbol is not defined and otherwise is used the same way as the <code>#ifdef</code> directive.</p>
<h2 id="h1-501621c12-0003"><span epub:type="pagebreak" title="216" id="Page_216"/>Where Symbols Get Defined</h2>
<p class="BodyFirst">We can define symbols in three ways:</p>
<ol class="decimal">
<li value="1">Inside the program with a <code>#define</code></li>
<li value="2">From the command line</li>
<li value="3">Predefined inside the preprocessor</li>
</ol>
<p>We’ve already described symbols defined inside a program, so let’s look at the other two options.</p>
<h3 id="h2-501621c12-0003">Command Line Symbols</h3>
<p class="BodyFirst">To define a symbol on the command line, use the <code>-D</code> option:</p>
<pre><code><b>$ gcc -Wall -Wextra -DDEBUG -o prog prog.c</b></code></pre>
<p>The <code>-DDEBUG</code> argument defines the <code>DEBUG</code> symbol so the preprocessor can use it. In this example, it does a <code>#define DEBUG 1</code> before the program starts. We used this symbol in the previous code to control whether <code>debug</code> statements were compiled in.</p>
<p>In addition to symbols, we add to the compilation command manually, and the STM32 Workbench generates a makefile to compile a program that defines a number of symbols on the command line. The most significant is defined by the <code>-DSTM32F030x8</code> option. The <em>CMSIS/device/stm32f0xx.h</em> file uses the <code>STM32F030x8</code> symbol to include board-specific files:</p>
<pre><code>#if defined(STM32F030x6)
  #include "stm32f030x6.h"
#elif defined(STM32F030x8)
  #include "stm32f030x8.h"
#elif defined(STM32F031x6)
  #include "stm32f031x6.h"
#elif defined(STM32F038xx)</code></pre>
<p>The STM firmware supports a number of boards, only one of which is the NUCLEO-F030R8. Each chip has a different set of I/O devices located at different places. You don’t need to worry about where they are, as the firmware will find the right place using the preceding code. This file says, “If I’m an STM32F030x6, include the header file for that board; if I’m an STM32F030x8, include the header file for that board,” and so on.</p>
<p>The directives used are <code>#if</code> and <code>#elif</code>. The <code>#if</code> tests to see whether the expression that follows is true (in this case, whether <code>STM32F030x6</code> is defined). If it is, the code following it will be compiled. The <code>#elif</code> is a combination of <code>#else</code> and <code>#if</code>, which says if the expression is not true, then test another expression. The other directive, <code>defined</code>, is true if the symbol is defined.</p>
<h3 id="h2-501621c12-0004"><span epub:type="pagebreak" title="217" id="Page_217"/>Predefined Symbols</h3>
<p>Finally, the preprocessor itself defines a number of symbols, such as <code>__VERSION__</code> (to specify the compiler version) and <code>__linux</code> (on Linux systems). To see what’s predefined on your system, use the following command:</p>
<pre><code>$ <b>gcc -dM -E - &lt; /dev/null</b></code></pre>
<p>The <code>__cplusplus</code> symbol is defined only if you are compiling a C++ program. Frequently, you’ll see something like this in files:</p>
<pre><code>#ifdef   __cplusplus
extern "C"
{
#endif</code></pre>
<p>It’s part of a song and dance needed by C++ so it can use C programs. You can just ignore it for now.</p>
<h2 id="h1-501621c12-0004">Include Files</h2>
<p class="BodyFirst">The <code>#include</code> directive tells the preprocessor to bring in an entire file as if it were part of the original file. There are two forms of this directive:</p>
<pre><code>#include &lt;file.h&gt;
#include "file.h"</code></pre>
<p>The first form brings in system header files (files that come with the compiler or system libraries you are using). The second brings in files you create.</p>
<p>One problem with header files is that they can be included twice. If that happens, you get a lot of duplicate defined symbols and other problems. The solution to this problem is to add a <em>sentinel</em> by using the following design pattern:</p>
<pre><code>#ifndef __FILE_NAME_H__
#define __FILE_NAME_H__
// Body of the file
#endif __FILE_NAME_H__</code></pre>
<p>The first time through, the <code>__FILE_NAME_H__</code> symbol (the sentinel) is not defined, so the entire header file is included. This is good, because we wanted it included—<em>once</em>. The next time through, <code>__FILE_NAME_H__</code> is defined, and the <code>#ifndef</code> prevents the code below it from being included until the <code>#endif</code> is reached at the end of the file. Thus, although the header file is included twice, the contents of the file appear only once.</p>
<h2 id="h1-501621c12-0005">Other Preprocessor Directives</h2>
<p class="BodyFirst">A few minor preprocessor directives are also useful, such as <code>#warning</code>, <code>#error</code>, and <code>#pragma</code>.</p>
<p><span epub:type="pagebreak" title="218" id="Page_218"/>The <code>#warning</code> directive displays a compiler warning if seen:</p>
<pre><code>#ifndef PROCESSOR
#define PROCESSOR DEFAULT_PROCESSOR
#warning "No processor -- taking default"
#endif // PROCESSOR</code></pre>
<p>The related <code>#error</code> directive issues an error and stops your program from compiling:</p>
<pre><code>#ifndef RELEASE_VERSION
#error "No release version defined. It must be defined."
#endif // RELEASE_VERSION</code></pre>
<p>The <code>#pragma</code> directive defines compiler-dependent controls. Here’s an example:</p>
<pre><code>// I wish they would fix this include file.
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#include "buggy.h"
#pragma GCC diagnostic warning "-Wmissing-prototypes"</code></pre>
<p>This GCC-specific <code>#pragma</code> turns off warnings about missing prototypes, includes a buggy include file, and turns warnings back on.</p>
<h2 id="h1-501621c12-0006">Preprocessor Tricks</h2>
<p class="BodyFirst">The preprocessor is a dumb macro processor, and as a result, we’ve had to adopt a number of style rules, described previously, to keep us out of trouble. The power of the preprocessor also allows us to perform some interesting tricks to make our lives easier. One of them is the <code>enum</code> trick, which we discussed in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>. In this section, we’ll look at commenting out code.</p>
<p>Sometimes, we need to disable some code for testing. One way to do that is to comment out the code. For example, suppose the auditing process is buggy; we can disable it until the audit group gets its act together.</p>
<p>Here’s the original code:</p>
<pre><code>int processFile(void) {
    readFile();
    connectToAuditServer();
    if (!audit()) {
        printf("ERROR: Audit failed\n");
        return;
    }
    crunchData();
    writeReport();
}    </code></pre>
<p><span epub:type="pagebreak" title="219" id="Page_219"/>And here’s the code with the audit removed:</p>
<pre><code>int processFile(void) {
    readFile();
//    connectToAuditServer();
//    if (!audit()) {
//        printf("ERROR: Audit failed\n");
//        return;
//    }
    crunchData();
    writeReport();
}</code></pre>
<p>Every line that we wanted removed now begins with the comment (<code>//</code>) marker.</p>
<p>Commenting out every line is labor-intensive, however. Instead, we can use conditional compilation to remove the code. All we need to do is surround it with <code>#ifdef UNDEF</code> and <code>#endif // UNDEF</code> statements, like this:</p>
<pre><code>int processFile(void) {
    readFile();
#ifdef UNDEF
    connectToAuditServer();
    if (!audit()) {
        printf("ERROR: Audit failed\n");
        return;
    }
#endif // UNDEF
    crunchData();
    writeReport();
}</code></pre>
<p>The code inside the <code>#ifdef</code>/<code>#endif</code> block will be compiled only if <code>UNDEF</code> is defined, and no sane programmer would do that. Using <code>#if 0</code> / <code>#endif</code> does the same thing without depending on the sanity of other programmers.</p>
<h2 id="h1-501621c12-0007">Summary</h2>
<p class="BodyFirst">The C preprocessor is a simple yet powerful automatic text editor. Used properly, it can make programming tremendously easier. It allows you to define simple numeric macros as well as small code macros. (Actually, you can define large code macros, but you really don’t want to do that.)</p>
<p>One of its biggest features is the <code>#include</code> directive, which facilitates the sharing of interfaces between modules. Also, the <code>#ifdef</code> capabilities allow you to write one program that has multiple personalities through the use of conditional compilation.</p>
<p>However, you must remember that the preprocessor does not understand C syntax. As a result, you must remember several style rules and programming patterns to use the system effectively.</p>
<p>For all of its limitations and quirks, the preprocessor can be a powerful tool when it comes to creating C programs.</p>
<h2 id="h1-501621c12-0008"><span epub:type="pagebreak" title="220" id="Page_220"/>Programming Problems</h2>
<ol class="decimal">
<li value="1">Write a macro to swap two integers.</li>
<li value="2">Advanced: Write a macro to swap two integers of any type. (Read the documentation for GCC’s <code>typeof</code> keyword before doing this.)</li>
<li value="3">Create a macro called <code>islower(x)</code> that returns true if <code>x</code> is a lowercase letter.</li>
<li value="4">Crazy advanced: Figure out how the program <em>zsmall.c</em> works (<a href="https://www.cise.ufl.edu/~manuel/obfuscate/zsmall.hint" class="LinkURL">https://www.cise.ufl.edu/~manuel/obfuscate/zsmall.hint</a>). This program is a winner of the obfuscated C contest (it won an award for “Best Abuse of the Preprocessor”). All it does is print a list of primes, but all the calculations and loops are done using the preprocessor.</li>
</ol>
</section>
</body></html>