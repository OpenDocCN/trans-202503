- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Ansible to Configure SSH
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: '*SSH* is a protocol and tool that provides command line access to a remote
    host from your own machine. If you are managing a remote host or a fleet of remote
    hosts, the most common way to access them is over SSH. Most servers are likely
    to be headless, so the easiest way to access them is from a terminal. Since SSH
    opens access to a host, misconfiguration or default installations can lead to
    unauthorized access. As with a lot of Linux services out of the box, the default
    security settings are adequate for most cases, but you will want to know how to
    increase security and then automate it. As an engineer, you should understand
    the steps required to lock down SSH on a host or hosts.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to use Ansible to secure SSH access to your
    VM. You’ll do this by disabling password access over SSH, requiring public key
    authentication over SSH, and enabling two-factor authentication (2FA) over SSH
    for your user *bender*. You’ll use a combination of some familiar Ansible modules,
    and you’ll be introduced to some new ones. By the end of this chapter, you’ll
    have a better understanding of how to enforce strict access to SSH and the automation
    steps required to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and Activating Public Key Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most Linux distributions use passwords to authenticate over SSH by default.
    Although this is okay for many setups, you should beef up security by adding another
    option: *public key authentication**.* This method uses a key pair, consisting
    of a public key file and a private key file, to confirm your identity. Public
    key authentication is considered best practice for authenticating users over SSH
    because potential attackers who want to hijack a user’s identity need both a copy
    of a user’s private key and the passphrase to unlock it.'
  prefs: []
  type: TYPE_NORMAL
- en: When you create an SSH session with a key, the remote host encrypts a *challenge*
    with your public key andsends the challenge back to you. Because you are in possession
    of the private key, you can decode the message and send back a response to the
    remote server. If the server can validate the response, it will know you are in
    possession of the private key and will thus confirm your identity. To learn more
    about the key exchange and SSH, visit [https://www.ssh.com/academy/ssh/](https://www.ssh.com/academy/ssh/).
  prefs: []
  type: TYPE_NORMAL
- en: Generating a Public Key Pair
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To generate a key pair, you’ll use the `ssh-keygen` command line tool. This
    tool, usually installed on Unix hosts by default as part of the `ssh` package,
    generates and manages authentication key pairs for SSH. There’s a good chance
    you already have a public key pair on your local host, but for this book, let’s
    create a new key pair so you don’t interfere with it. You’ll also add a passphrase
    to the private key. A *passphrase* is like a password, but it’s usually longer
    (more like a group of unrelated words than a complex stream of characters). You
    add it so that if your private key ever fell into the wrong hands, the bad actors
    would need to have your passphrase to unlock it and spoof your identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal on your local host, enter the following command to generate a
    new key pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You first instruct `ssh-keygen` to create an `rsa` key pair that has a name
    of `dftd` (DevOps for the Desperate). If you do not specify a name, it defaults
    to *id_rsa*, which might override your existing local key. The `-C` flag adds
    a human-readable comment to the end of the key that can help identify what the
    key is for. Here, it’s also set to `dftd`. During execution, the command should
    prompt you to secure your key by adding a passphrase. Enter a strong passphrase
    to protect the key. Also remember to always keep your passphrase safe, because
    if you lose it, your key will become forever locked and you will never be able
    to use it for authentication again.
  prefs: []
  type: TYPE_NORMAL
- en: After you confirm the passphrase, the private key and public key files are created
    under your local *~./ssh/* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible to Get Your Public Key on the VM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each user’s home folder on the VM has a file called *authorized_keys**.* This
    file contains a list of public keys the SSH server can use to authenticate that
    user. You’ll use this file to authenticate *bender* when accessing the VM over
    SSH. To do this, you need to copy the local public key you just created in the
    previous section (*/Users/bradleyd/.ssh/dftd.pub,* in my case) and append the
    contents of that file to the */home/bender/.ssh/authorized_keys* file on the VM.
  prefs: []
  type: TYPE_NORMAL
- en: To copy the file’s content, you’ll use a provided Ansible task. This task and
    all the other tasks related to this chapter are located in the cloned repository
    under the *ansible/chapter3/* directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the *authorized_keys.yml* file in your favorite editor to review the Ansible
    task. The first thing you should notice is that this file has only one task. It
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First, set the `name` of the task to identify its intent. Use the Ansible `authorized_key`
    module to copy your public key from the local host over to *bender* on the VM.
    The `authorized_key` module is quite simple and requires that you set only the
    `user` and `key` parameters. In this example, it copies the local public key you
    made earlier into `bender`’s */home/bender/.ssh/authorized_keys* file. Set the
    `state` to `present`, as you want to add the key and not remove it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the contents of the local public key, you’ll use Ansible’s evaluation
    expansion operators (`{{` `}}`) and a built-in Ansible function called `lookup`*.*
    The `lookup` function retrieves information from outside resources, based on the
    plug-in specified as its first argument. In this example, `lookup` uses the `file`
    plug-in to read the contents of the *~/.ssh/dftd.pub* public key file. The full
    path to this public key file is constructed with the ``lookup `env` plug-in and
    string concatenation denoted by the *+* sign. The final result should look similar
    to this if you’re on a Mac: */Users/bradleyd/.ssh/dftd.pub*. If you are on Linux,
    it should like similar to this: */home/bradleyd/.ssh/dftd.pub*. The file path
    will be different, depending on your OS and username.``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
