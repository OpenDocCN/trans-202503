- en: '3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C DEBUGGING TOOLS
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this section, we introduce two debugging tools: the GNU debugger (GDB),^([1](ch03.xhtml#fn3_1))
    which is useful for examining a program’s runtime state, and Valgrind^([2](ch03.xhtml#fn3_2))
    (pronounced “Val-grinned”), a popular code profiling suite. Specifically, we introduce
    Valgrind’s Memcheck tool,^([3](ch03.xhtml#fn3_3)) which analyzes a program’s memory
    accesses to detect invalid memory usage, uninitialized memory usage, and memory
    leaks.'
  prefs: []
  type: TYPE_NORMAL
- en: The GDB section includes two sample GDB sessions that illustrate commonly used
    GDB commands for finding bugs in programs. We also discuss some advanced GDB features,
    including attaching GDB to a running process, GDB and Makefiles, signal control
    in GDB, debugging at the assembly code level, and debugging multithreaded Pthreads
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: The Valgrind section discusses memory access errors and why they can be so difficult
    to detect. It also includes an example run of Memcheck on a program with some
    bad memory access errors. The Valgrind suite includes other program profiling
    and debugging tools, which we cover in later chapters. For example, we cover the
    cache profiling tool Cachegrind^([4](ch03.xhtml#fn3_4)) in “Cache Analysis and
    Valgrind” in [Chapter 11](ch11.xhtml#ch11), and the function call profiling tool
    Callgrind^([5](ch03.xhtml#fn3_5)) in “Using Callgrind to Profile" in [Chapter
    12](ch12.xhtml#ch12).
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Debugging with GDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GDB can help programmers find and fix bugs in their programs. GDB works with
    programs compiled in a variety of languages, but we focus on C here. A debugger
    is a program that controls the execution of another program (the program being
    debugged)—it allows programmers to see what their programs are doing as they run.
    Using a debugger can help programmers discover bugs and determine the causes of
    the bugs they find. Here are some useful actions that GDB can perform:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a program and step through it line by line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause the execution of a program when it reaches certain points in its code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause the execution of a program on user-specified conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show the values of variables at the point in execution that a program is paused
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continue a program’s execution after a pause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine the program’s execution state at the point when it crashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine the contents of any stack frame on the call stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GDB users typically set *breakpoints* in their programs. A breakpoint specifies
    a point in the program where GDB will pause the program’s execution. When the
    executing program hits a breakpoint, GDB pauses its execution and allows the user
    to enter GDB commands to examine program variables and stack contents, step through
    the execution of the program one line at a time, add new breakpoints, and continue
    the program’s execution until it hits the next breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Many Unix systems also provide the Data Display Debugger (DDD), an easy-to-use
    GUI wrapper around a command line debugger program (GDB, for example). The DDD
    program accepts the same parameters and commands as GDB, but it provides a GUI
    interface with debugging menu options as well as the command line interface to
    GDB.
  prefs: []
  type: TYPE_NORMAL
- en: After discussing a few preliminaries about how to get started with GDB, we present
    two example GDB debugging sessions that introduce commonly used GDB commands in
    the context of finding different types of bugs. The first session, “Example Using
    GDB to Debug a Program (badprog.c)” on [page 152](ch03.xhtml#lev3_33), shows how
    to use GDB commands to find logic bugs in a C program. The second session, “Example
    Using GDB to Debug a Program That Crashes (segfaulter.c)” on [page 159](ch03.xhtml#lev3_34),
    shows an example of using GDB commands to examine the program execution state
    at the point when a program crashes in order to discover the cause of the crash.
  prefs: []
  type: TYPE_NORMAL
- en: In the “Common GDB Commands” section on [page 161](ch03.xhtml#lev2_46), we describe
    commonly used GDB commands in more detail, showing more examples of some commands.
    In later sections, we discuss some advanced GDB features.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.1 Getting Started with GDB
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When debugging a program, it helps to compile it with the `-g` option, which
    adds extra debugging information to the binary executable file. This extra information
    helps the debugger find program variables and functions in the binary executable
    and enables it to map machine code instructions to lines of C source code (the
    form of the program that the C programmer understands). Also, when compiling for
    debugging, avoid compiler optimizations (for example, do not build with `-O2`).
    Compiler-optimized code is often very difficult to debug because sequences of
    optimized machine code often do not clearly map back to C source code. Although
    we cover the use of the `-g` flag in the following sections, some users may get
    better results with the `-g3` flag, which can reveal extra debugging information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example `gcc` command that will build a suitable executable for
    debugging with GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To start GDB, invoke it on the executable file. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When GDB starts, it prints the `(gdb)` prompt, which allows the user to enter
    GDB commands (such as setting breakpoints) before it starts running the `a.out`
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, to invoke DDD on the executable file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, when a program terminates with an error, the operating system dumps
    a core file containing information about the state of the program when it crashed.
    The contents of this core file can be examined in GDB by running GDB with the
    core file and the executable that generated it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 3.1.2 Example GDB Sessions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We demonstrate common features of GDB through two example sessions of using
    GDB to debug programs. The first is an example of using GDB to find and fix two
    bugs in a program, and the second is an example of using GDB to debug a program
    that crashes. The set of GDB commands that we demonstrate in these two example
    sessions includes those listed in the table that follows.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `break` | Set a breakpoint |'
  prefs: []
  type: TYPE_TB
- en: '| `run` | Start a program running from the beginning |'
  prefs: []
  type: TYPE_TB
- en: '| `cont` | Continue execution of the program until it hits a breakpoint |'
  prefs: []
  type: TYPE_TB
- en: '| `quit` | Quit the GDB session |'
  prefs: []
  type: TYPE_TB
- en: '| `next` | Allow program to execute the next line of C code and then pause
    it |'
  prefs: []
  type: TYPE_TB
- en: '| `step` | Allow program to execute the next line of C code; if the next line
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | contains a function call, step into the function and pause |'
  prefs: []
  type: TYPE_TB
- en: '| `list` | List C source code around pause point or specified point |'
  prefs: []
  type: TYPE_TB
- en: '| `print` | Print out the value of a program variable (or expression) |'
  prefs: []
  type: TYPE_TB
- en: '| `where` | Print the call stack |'
  prefs: []
  type: TYPE_TB
- en: '| `frame` | Move into the context of a specific stack frame |'
  prefs: []
  type: TYPE_TB
- en: Example Using GDB to Debug a Program (badprog.c)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first example GDB session debugs the `badprog.c` program. This program
    is supposed to find the largest value in an array of `int` values. However, when
    run, it incorrectly finds that 17 is the largest value in the array instead of
    the correct largest value, which is 60\. This example shows how GDB can examine
    the program’s runtime state to determine why the program is not computing the
    expected result. In particular, this example debugging session reveals two bugs:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. An error with loop bounds resulting in the program accessing elements beyond
    the bounds of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. An error in a function not returning the correct value to its caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'To examine a program with GDB, first compile the program with `-g` to add debugging
    information to the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run GDB on the binary executable program (`a.out`). GDB initializes and
    prints the `(gdb)` prompt, where the user can enter GDB commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, GDB has not yet started running the program. A common first
    debugging step is to set a breakpoint in the `main()` function to pause the program’s
    execution right before it executes the first instruction in `main()`. The `break`
    command sets a “breakpoint” (pauses the program) at a specified location (in this
    case at the start of the `main()` function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `run` command tells GDB to start the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If the program takes command line arguments, provide them after the `run` command
    (for example, run 100 200 would run `a.out` with the command line arguments `100`
    and `200`).
  prefs: []
  type: TYPE_NORMAL
- en: 'After entering `run`, GDB starts the program’s execution at its beginning,
    and it runs until it hits a breakpoint. Upon reaching a breakpoint, GDB pauses
    the program before executing the line of code at the breakpoint, and prints out
    the breakpoint number and source code line associated with the breakpoint. In
    this example, GDB pauses the program just before executing line 36 of the program.
    It then prints out the `(gdb)` prompt and waits for further instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Often when a program pauses at a breakpoint, the user wants to see the C source
    code around the breakpoint. The GDB `list` command displays the code surrounding
    the breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Subsequent calls to `list` display the next lines of source code following
    these. `list` can also be used with a specific line number (for example, `list
    11`) or with a function name to list the source code at a specified part of the
    program. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The user may want to execute one line of code at a time after hitting a breakpoint,
    examining program state after each line is executed. The GDB `next` command executes
    just the very next line of C code. After the program executes this line of code,
    GDB pauses the program again. The `print` command prints the values of program
    variables. Here are a few calls to `next` and `print` to show their effects on
    the next two lines of execution. Note that the source code line listed after a
    `next` has not yet been executed—it shows the line where the program is paused,
    which represents the line that will be executed next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point in the program’s execution, the main function has initialized
    its local variables `arr` and `max` and is about to make a call to the `findAnd`
    `ReturnMax()` function. The GDB `next` command executes the next full line of
    C source code. If that line includes a function call, the full execution of that
    function call and its return is executed as part of a single `next` command. A
    user who wants to observe the execution of the function should issue GDB’s `step`
    command instead of the `next` command: `step` steps into a function call, pausing
    the program before the first line of the function is executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we suspect that the bug in this program is related to the `findAnd`
    `ReturnMax()` function, we want to step into the function’s execution rather than
    past it. So, when paused at line 40, the `step` command will next pause the program
    at the start of the `findAndReturnMax()` (alternately, the user could set a breakpoint
    at `findAndReturnMax()` to pause the program’s execution at that point):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The program is now paused inside the `findAndReturnMax` function, whose local
    variables and parameters are now in scope. The `print` command shows their values,
    and `list` displays the C source code around the pause point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Because we think there is a bug related to this function, we may want to set
    a breakpoint inside the function so that we can examine the runtime state part
    way through its execution. In particular, setting a breakpoint on the line when
    `max` is changed may help us see what this function is doing.
  prefs: []
  type: TYPE_NORMAL
- en: We can set a breakpoint at a specific line number in the program (line 27) and
    use the `cont` command to tell GDB to let the application’s execution continue
    from its paused point. Only when the program hits a breakpoint will GDB pause
    the program and grab control again, allowing the user to enter other GDB commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `display` command asks GDB to automatically print out the same set of program
    variables every time a breakpoint is hit. For example, we will display the values
    of `i`, `max`, and `array1[i]` every time the program hits a breakpoint (in each
    iteration of the loop in `findAndReturnMax()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We found our first bug! The value of `array1[i]` is 32767, a value not in the
    passed array, and the value of `i` is 5, but 5 is not a valid index into this
    array. Through GDB we discovered that the `for` loop bounds need to be fixed to
    `i <` `len`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we could exit the GDB session and fix this bug in the code.
    To quit a GDB session, type quit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After fixing this bug, recompiling, and running the program, it still does
    not find the correct max value (it still finds that 17 is the max value and not
    60). Based on our previous GDB run, we may suspect that there is an error in calling
    or returning from the `findAndReturnMax()` function. We rerun the new version
    of our program in GDB, this time setting a breakpoint at the entry to the `findAndReturnMax()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we suspect a bug in the arguments or return value of a function, it may
    be helpful to examine the contents of the stack. The `where` (or `bt`, for “backtrace”)
    GDB command prints the current state of the stack. In this example, the `main()`
    function is on the bottom of the stack (in frame 1) and is executing a call to
    `findAndReturnMax()` at line 40\. The `findAndReturnMax()` function is on the
    top of the stack (in frame 0) and is currently paused at line 21:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'GDB’s `frame` command moves into the context of any frame on the stack. Within
    each stack frame context, a user can examine the local variables and parameters
    in that frame. In this example, we move into stack frame 1 (the caller’s context)
    and print out the values of the arguments that the `main()` function passes to
    `findAndReturnMax()` (for example, `arr` and `max`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The argument values look fine, so let’s check the `findAndReturnMax()` function’s
    return value. To do this, we insert a breakpoint immediately before `findAndReturnMax()`
    returns to see what value it computes for its `max`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that the function has found the correct max value (60). Let’s execute
    the next few lines of code and see what value the `main()` function receives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We found the second bug! The `findAndReturnMax()` function identifies the correct
    largest value in the passed array (60), but it doesn’t return that value back
    to the `main()` function. To fix this error, we need to either change `findAndReturnMax()`
    to return its value of `max` or add a “pass-by-pointer” parameter that the function
    will use to modify the value of the `main()` function’s `max` local variable.
  prefs: []
  type: TYPE_NORMAL
- en: Example Using GDB to Debug a Program That Crashes (segfaulter.c)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The second example GDB session (run on the `segfaulter.c` program) demonstrates
    how GDB behaves when a program crashes and how we can use GDB to help discover
    why the crash occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we just run the `segfaulter` program in GDB and let it crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as the program crashes, GDB pauses the program’s execution at the point
    it crashes and grabs control. GDB allows a user to issue commands to examine the
    program’s runtime state at the point of the program crash, often leading to discovering
    why the program crashed and how to fix the cause of the crash. The GDB `where`
    and `list` commands are particularly useful for determining where a program crashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This output tells us that the program crashes on line 14, in the `initfunc()`
    function. Examining the values of the parameters and local variables on line 14
    may tell us why it crashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `i` seems fine, but we see an error when trying to access index
    `i` of `array`. Let’s print out the value of `array` (the value of the base address
    of the array) to see if that tells us anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have found the cause of the crash! The base address of the array is zero
    (or `NULL`), and we know that dereferencing a null pointer (via `array[i]`) causes
    programs to crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see if we can figure out why the `array` parameter is `NULL` by looking
    in the caller’s stack frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Moving into the caller’s stack frame and printing out the value of the arguments
    `main()` passes to `initfunc()` shows that the `main()` function passes a null
    pointer to the `initfunc()` function. In other words, the user forgot to allocate
    the `arr` array prior to the call to `initfunc()`. The fix is to use the `malloc()`
    function to allocate some space to `arr` at line 34.
  prefs: []
  type: TYPE_NORMAL
- en: These two example GDB sessions illustrate commonly used commands for finding
    bugs in programs. In the next section, we discuss these and other GDB commands
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 GDB Commands in Detail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we list common GDB commands and show some of their features
    with examples. We first discuss some common keyboard shortcuts that make GDB even
    easier to use.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.1 Keyboard Shortcuts in GDB
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: GDB supports *command line completion*. A user can enter a unique prefix of
    a command and hit the TAB key, and GDB will try to complete the command line.
    Also, a unique *short abbreviation* can be used to issue many common GDB commands.
    For example, rather than entering the command `print x`, a user can just enter
    `p x` to print out the value of `x`, or `l` can be used for the `list` command,
    or `n` for `next`.
  prefs: []
  type: TYPE_NORMAL
- en: The *up and down arrow keys* scroll through previous GDB command lines, eliminating
    the need to retype them each time.
  prefs: []
  type: TYPE_NORMAL
- en: Hitting the RETURN key at the GDB prompt executes the *most recent previous
    command*. This is particularly useful when stepping through the execution with
    a sequence of `next` or `step` commands; just press RETURN and GDB executes the
    next instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.2 Common GDB Commands
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We summarize GDB’s most common commands here, grouping them by similar functionality:
    commands for controlling program execution; commands for evaluating the point
    in the program’s execution; commands for setting and controlling breakpoints;
    and commands for printing program state and evaluating expressions. The GDB `help`
    command provides information about all GDB commands:'
  prefs: []
  type: TYPE_NORMAL
- en: help   Help documentation for topics and GDB commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Commands for Execution Control Flow
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: break   Set a breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Specifying a line in a specific file (as in `break gofish.c:34`) allows a user
    to set breakpoints in C programs that span several C source code files (`.c` files).
    This feature is particularly useful when the breakpoint being set is not in the
    same file as the code at the pause point of the program.
  prefs: []
  type: TYPE_NORMAL
- en: run   Start running the debugged program from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: continue **(**cont**)**   Continue execution from breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: step **(**s**)**   Execute the next line(s) of the program’s C source code,
    stepping into a function if a function call is executed on the line(s).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the case of the `step <count>` command, if a line contains a function call,
    lines of the called function are counted in the `count` total of lines to step
    through. Thus, `step <count>` may result in the program pausing inside a function
    that was called from the pause point at which the `step <count>` command was issued.
  prefs: []
  type: TYPE_NORMAL
- en: next   Similar to the `step` command, but it treats a function call as a single
    line. In other words, when the next instruction contains a function call, `next`
    does not step into the execution of the function but pauses the program after
    the function call returns (pausing the program at the next line in the code following
    the one with the function call).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: until   Execute the program until it reaches the specified source code line
    number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: quit   Exit GDB.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Commands for Examining the Execution Point and Listing Program Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: list   List program source code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: where **(**backtrace**,** bt**)**   Show the contents of the stack (the sequence
    of function calls at the current point in the program’s execution). The `where`
    command is helpful for pinpointing the location of a program crash and for examining
    state at the interface between function calls and returns, such as argument values
    passed to functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: frame <frame-num>   Move into the context of stack frame number `<frame-num>`.
    As a default, the program is paused in the context of frame 0, the frame at the
    top of the stack. The `frame` command can be used to move into the context of
    another stack frame. Typically, GDB users move into another stack frame to print
    out the values of parameters and local variables of another function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Commands for Setting and Manipulating Breakpoints
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: break   Set a breakpoint (there is more explanation about this command in “Commands
    for Execution Control Flow” on [page 162](ch03.xhtml#lev3_35)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: enable**,** disable**,** ignore**,** delete**,** clear   Enable, disable, ignore
    for some number of times, or delete one or more breakpoints. The `delete` command
    deletes a breakpoint by its number. In contrast, using the `clear` command deletes
    a breakpoint at a particular location in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: condition   Set conditions on breakpoints. A conditional breakpoint is one that
    only transfers control to GDB when a certain condition is true. It can be used
    to pause at a breakpoint inside a loop only after some number of iterations (by
    adding a condition on the loop counter variable), or to pause the program at a
    breakpoint only when the value of a variable has an interesting value for debugging
    purposes (avoiding pausing the program at other times).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Commands for Examining and Evaluating Program State and Expressions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: print **(**p**)**   Display the value of an expression. Although GDB users typically
    print the value of a program variable, GDB will print the value of any C expression
    (even expressions that are not in the program code). The print command supports
    printing in different formats and supports operands in different numeric representations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To print in different formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To specify different numeric representations in the expression (the default
    for numbers is decimal representation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, expressions may require explicit type casting to inform `print`
    how to interpret them. For example, here, recasting an address value to a specific
    type (`int *`) is necessary before the address can be dereferenced (otherwise,
    GDB does not know how to dereference the address):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `print` to display the value of a dereferenced pointer variable,
    type casting is not necessary, because GDB knows the type of the pointer variable
    and knows how to dereference its value. For example, if `ptr` is declared as an
    `int *`, then the int value it points to can be displayed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To print out a value stored in a hardware register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: display   Automatically display the value of an expression upon reaching a breakpoint.
    The expression syntax is the same as the `print` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: x **(examine memory)**   Display the contents of a memory location. This command
    is similar to `print`, but it interprets its argument as an address value that
    it dereferences to print the value stored at the address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Like `print`, `x` can display values in different formats (for example, as an
    `int`, a `char`, or a string).
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning EXAMINE’S FORMATTING IS STICKY**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sticky formatting* means that GDB remembers the current format setting, and
    applies it to subsequent calls to `x` that do not specify formatting. For example,
    if the user enters the command `x/c`, all subsequent executions of `x` without
    formatting will use the `/c` format. As a result, formatting options only need
    to be explicitly specified with an `x` command when the user desires changes in
    the memory address units, repetition, or display format of the most recent call
    to `x`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, `x` takes up to three formatting arguments (`x/nfu <memory` `address>`);
    the order in which they are listed does not matter:'
  prefs: []
  type: TYPE_NORMAL
- en: n   the repeat count (a positive integer value)
  prefs: []
  type: TYPE_NORMAL
- en: 'f   the display format (`s`: string; `i`: instruction; `x`: hex; `d`: decimal;
    `t`: binary; `a`: address; . . .)'
  prefs: []
  type: TYPE_NORMAL
- en: 'u   the units format (number of bytes) (`b`: byte; `h`: 2 bytes; `w`: 4 bytes;
    `g`: 8 bytes)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples (assume `s1 = "Hello There"` is at memory address `0x40062d`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: whatis   Show the type of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: set   Assign/change the value of a program variable, or assign a value to be
    stored at a specific memory address or in a specific machine register.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'info     Lists information about program state and debugger state. There are
    a large number of `info` options for obtaining information about the program’s
    current execution state and about the debugger. A few examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: For more information about these and other GDB commands, see the GDB man page
    (`man gdb`) and the GNU Debugger home page at *[https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)*.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Debugging Memory with Valgrind
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Valgrind’s Memcheck debugging tool highlights heap memory errors in programs.
    Heap memory is the part of a running program’s memory that is dynamically allocated
    by calls to `malloc()` and freed by calls to `free()` in C programs. The types
    of memory errors that Valgrind finds include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading (getting) a value from uninitialized memory. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reading (getting) or writing (setting) a value at an unallocated memory location,
    which often indicates an array out-of-bounds error. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Freeing already freed memory. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Memory leaks. A *memory leak* is a chunk of allocated heap memory space that
    is not referred to by any pointer variable in the program, and thus it cannot
    be freed. That is, a memory leak occurs when a program loses the address of an
    allocated chunk of heap space. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Memory leaks can eventually cause the program to run out of heap memory space,
    resulting in subsequent calls to `malloc()` failing. The other types of memory
    access errors, such as invalid reads and writes, can lead to the program crashing
    or can result in some program memory contents being modified in seemingly mysterious
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: Memory access errors are some of the most difficult bugs to find in programs.
    Often a memory access error does not immediately result in a noticeable error
    in the program’s execution. Instead, it may trigger an error that occurs later
    in the execution, often in a part of the program that seemingly has little to
    do with the source of the error. At other times, a program with a memory access
    error may run correctly on some inputs and crash on other inputs, making the cause
    of the error difficult to find and fix.
  prefs: []
  type: TYPE_NORMAL
- en: Using Valgrind helps a programmer identify these difficult to find and fix heap
    memory access errors, saving significant amounts of debugging time and effort.
    Valgrind also assists the programmer in identifying any lurking heap memory errors
    that were not discovered in the testing and debugging of their code.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.1 An Example Program with a Heap Memory Access Error
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As an example of how difficult it can be to discover and fix programs with
    memory access errors, consider the following small program. This program exhibits
    a “write to unallocated heap memory” error in the second `for` loop, when it assigns
    values beyond the bounds of the `bigfish` array (note: the listing includes source
    code line numbers, and the `print_array()` function definition is not shown, but
    it behaves as described):'
  prefs: []
  type: TYPE_NORMAL
- en: bigfish.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main()` function, the second `for` loop causes a heap memory access
    error when it writes to three indices beyond the bounds of the `bigfish` array
    (to indices 10, 11, and 12). The program does not crash at the point where the
    error occurs (at the execution of the second `for` loop); instead, it crashes
    later in its execution at the call to `free(littlefish)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Running this program in GDB indicates that the program crashes with a segfault
    at the call to `free(littlefish)`. Crashing at this point may make the programmer
    suspect that there is a bug with accesses to the `littlefish` array. However,
    the cause of the error is due to writes to the `bigfish` array and has nothing
    to do with errors in how the program accesses the `littlefish` array.
  prefs: []
  type: TYPE_NORMAL
- en: The most likely reason that the program crashes is that the `for` loop goes
    beyond the bounds of the `bigfish` array and overwrites memory between the heap
    memory location of the last allocated element of `bigfish` and the first allocated
    element of `littlefish`. The heap memory locations between the two (and right
    before the first element of `littlefish`) are used by `malloc()` to store metadata
    about the heap memory allocated for the `littlefish` array. Internally, the `free()`
    function uses this metadata to determine how much heap memory to free. The modifications
    to indices 10 and 11 of `bigfish` overwrite these metadata values, resulting in
    the program crash on the call to `free(littlefish)`. We note, however, that not
    all implementations of the `malloc()` function use this strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the program includes code to print out `littlefish` after the memory
    access error to `bigfish`, the cause of the error may be more obvious to the programmer:
    the second `for` loop is somehow modifying the contents of the `littlefish` array
    (its element 0 value “mysteriously” changes from `0` to `78` after the loop).
    However, even in this very small program, it may be difficult to find the real
    error: if the program didn’t print out `littlefish` after the second `for` loop
    with the memory access error, or if the `for` loop upper bound was `12` instead
    of `13`, there would be no visible mysterious change to program variable values
    that could help a programmer see that there is an error with how the program accesses
    the `bigfish` array.'
  prefs: []
  type: TYPE_NORMAL
- en: In larger programs, a memory access error of this type could be in a very different
    part of the program code than the part that crashes. There also may be no logical
    association between variables used to access heap memory that has been corrupted
    and the variables that were used to erroneously overwrite that same memory; instead,
    their only association is that they happen to refer to memory addresses that are
    allocated close together in the heap. Note that this situation can vary from run
    to run of a program and that such behavior is often hidden from the programmer.
    Similarly, sometimes bad memory accesses will have no noticeable affect on a run
    of the program, making these errors hard to discover. Whenever a program seems
    to run fine for some input, but crashes on other input, this is a sign of a memory
    access error in the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tools like Valgrind can save days of debugging time by quickly pointing programmers
    to the source and type of heap memory access errors in their code. In the previous
    program, Valgrind delineates the point where the error occurs (when the program
    accesses elements beyond the bounds of the `bigfish` array). The Valgrind error
    message includes the type of error, the point in the program where the error occurs,
    and where in the program the heap memory near the bad memory access was allocated.
    For example, here is the information Valgrind will display when the program executes
    line 27 (some details from the actual Valgrind error message are omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This Valgrind error message says that the program is writing to invalid (unallocated)
    heap memory at line 27 and that this invalid memory is located immediately after
    a block of memory that was allocated at line 11, indicating that the loop is accessing
    some elements beyond the bounds of the allocated memory in heap space to which
    `bigfish` points. A potential fix to this bug is to either increase the number
    of bytes passed to `malloc()` or change the second `for` loop bounds to avoid
    writing beyond the bounds of the allocated heap memory space.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to finding memory access errors in heap memory, Valgrind can also
    find some errors with stack memory accesses, such as using uninitialized local
    variables or trying to access stack memory locations that are beyond the bounds
    of the current stack. However, Valgrind does not detect stack memory access errors
    at the same granularity as it does with heap memory, and it does not detect memory
    access errors with global data memory.
  prefs: []
  type: TYPE_NORMAL
- en: A program can have memory access errors with stack and global memory that Valgrind
    cannot find. However, these errors result in erroneous program behavior or program
    crashing that is similar to the behavior that can occur with heap memory access
    errors. For example, overwriting memory locations beyond the bounds of a statically
    declared array on the stack may result in “mysteriously” changing the values of
    other local variables or may overwrite state saved on the stack that is used for
    returning from a function call, leading to a crash when the function returns.
    Experience using Valgrind for heap memory errors can help a programmer identify
    and fix similar errors with accesses to stack and global memory.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.2 How to Use Memcheck
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We illustrate some of the main features of Valgrind’s Memcheck memory analysis
    tool on an example program, `valgrindbadprog.c`, which contains several bad memory
    access errors (comments in the code describe the type of error). Valgrind runs
    the Memcheck tool by default; we depend on this default behavior in the code snippets
    that follow. You can explicitly specify the Memcheck tool by using the `--tool=memcheck`
    option. In later sections, we will invoke other Valgrind profiling tools by invoking
    the `--tool` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run Memcheck, first compile the `valgrindbadprog.c` program with the `-g`
    flag to add debugging information to the executable file. Then, run the executable
    with `valgrind`. Note that for noninteractive programs, it may be helpful to redirect
    Valgrind’s output to a file for viewing after the program exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Valgrind’s Memcheck tool prints out memory access errors and warnings as they
    occur during the program’s execution. At the end of the program’s execution, Memcheck
    also prints out a summary about any memory leaks in the program. Even though memory
    leaks are important to fix, the other types of memory access errors are much more
    critical to a program’s correctness. As a result, unless memory leaks are causing
    a program to run out of heap memory space and crash, a programmer should focus
    first on fixing these other types of memory access errors before considering memory
    leaks. To view details of individual memory leaks, use the `--leak-check=yes`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'When first using Valgrind, its output may seem a bit difficult to parse. However,
    the output all follows the same basic format, and once you know this format, it’s
    easier to understand the information that Valgrind is displaying about heap memory
    access errors and warnings. Here is an example Valgrind error from a run of the
    `valgrindbadprog.c` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line of Valgrind output is prefixed with the process’s ID (PID) number
    (31059 in this example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Most Valgrind errors and warnings have the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of error or warning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where the error occurred (a stack trace at the point in the program’s execution
    when the error occurs.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where heap memory around the error was allocated (usually the memory allocation
    related to the error.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding example error, the first line indicates an invalid write to
    memory (writing to unallocated memory in the heap—a very bad error!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The next few lines show the stack trace where the error occurred. These indicate
    an invalid write occurred at line 29 in function `foo()`, which was called from
    function `main()` at line 56:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining lines indicate where the heap space near the invalid write was
    allocated in the program. This section of Valgrind’s output says that the invalid
    write was immediately after (`0 bytes after`) a block of 5 bytes of heap memory
    space that was allocated by a call to `malloc()` at line 18 in function `foo()`,
    called by `main()` at line 56:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The information from this error identifies that there is an unallocated heap
    memory write error in the program, and it directs the user to specific parts of
    the program where the error occurs (line 29) and where memory around the error
    was allocated (line 18). By looking at these points in the program, the programmer
    may see the cause of and the fix for the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The cause is that the `for` loop executes one time too many, accessing `c[5]`,
    which is beyond the end of array `c`. The fix is to either change the loop bounds
    at line 29 or to allocate a larger array at line 18.
  prefs: []
  type: TYPE_NORMAL
- en: If examining the code around a Valgrind error is not sufficient for a programmer
    to understand or fix the error, using GDB might be helpful. Setting breakpoints
    around the points in the code associated with the Valgrind errors can help a programmer
    evaluate the program’s runtime state and understand the cause of the Valgrind
    error. For example, by putting a breakpoint at line 29 and printing the values
    of `i` and `str`, the programmer can see the array out-of-bounds error when `i`
    is 5\. In this case, the combination of using Valgrind and GDB helps the programmer
    determine how to fix the memory access bugs that Valgrind finds.
  prefs: []
  type: TYPE_NORMAL
- en: Although this chapter has focused on Valgrind’s default Memcheck tool, we characterize
    some of Valgrind’s other capabilities later in the book, including the Cachegrind
    cache profiling tool ([Chapter 11](ch11.xhtml#ch11)), the Callgrind code profiling
    tool ([Chapter 12](ch12.xhtml#ch12)), and the Massif memory profiling tool ([Chapter
    12](ch12.xhtml#ch12)). For more information about using Valgrind, see the Valgrind
    home page at *[https://valgrind.org](https://valgrind.org),* and its online manual
    at *[https://valgrind.org/docs/manual/](https://valgrind.org/docs/manual/)*.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 Advanced GDB Features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section presents advanced GDB features, some of which may make sense only
    after reading [Chapter 13](ch13.xhtml#ch13), “Notes.”
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.1 GDB and make
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: GDB accepts the `make` command to rebuild an executable during a debugging session,
    and if the build is successful it will run the newly built program (when issued
    the `run` command).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Building from within GDB is convenient for a user who has set many breakpoints
    and has fixed one bug but wants to continue the debugging session. In this case,
    rather than quitting GDB, recompiling, restarting GDB with the new executable,
    and resetting all the breakpoints, a GDB user can run `make` and start debugging
    the new version of the program with all the breakpoints still set. Keep in mind,
    however, that modifying the C source and recompiling by running `make` from within
    GDB may result in the breakpoints not being at the same logical location in the
    new version of the program as in the old version if source code lines have been
    added or deleted. When this problem occurs, either exit GDB and restart the GDB
    session on the new executable, or use `disable` or `delete` to disable or delete
    the old breakpoints and then `break` to set new breakpoints at the correct locations
    in the newly compiled version of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.2 Attaching GDB to a Running Process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'GDB supports debugging a program that is already running (rather than starting
    a program to run from within a GDB session) by *attaching* GDB to a running process.
    To do this, the user needs to get the process ID (PID) value:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Get the process’s PID using the `ps` shell command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ps to get process''s PID (lists all processes started in current shell):'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: $ ps
  prefs: []
  type: TYPE_NORMAL
- en: 'list all processes and pipe through grep for just those named a.out:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: $ ps -A | grep a.out
  prefs: []
  type: TYPE_NORMAL
- en: PID TTY          TIME CMD
  prefs: []
  type: TYPE_NORMAL
- en: 12345 pts/3     00:00:00 a.out
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Start GDB and attach it to the specific running process (with PID 12345):'
  prefs: []
  type: TYPE_NORMAL
- en: gdb <executable> <pid>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: $ gdb a.out 12345
  prefs: []
  type: TYPE_NORMAL
- en: (gdb)
  prefs: []
  type: TYPE_NORMAL
- en: 'OR alternative syntax: gdb attach <pid>  <executable>'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: $ gdb attach 12345 a.out
  prefs: []
  type: TYPE_NORMAL
- en: (gdb)
  prefs: []
  type: TYPE_NORMAL
- en: Attaching GDB to a process pauses it, and the user can issue GDB commands before
    continuing its execution.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, a program can explicitly pause itself to wait for debugging by
    calling `kill(getpid(), SIGSTOP)` (as in the `attach_example.c` example). When
    the program pauses at this point, a programmer can attach GDB to the process to
    debug it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of how a program pauses, after GDB attaches and the user enters
    some GDB commands, the program’s execution continues from its attach point using
    `cont`. If `cont` doesn’t work, GDB may need to explicitly send the process a
    `SIGCONT` signal in order to continue its execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 3.4.3 Following a Process on a Fork
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When GDB debugs a program that calls the `fork()` function to create a new
    child process, GDB can be set to follow (to debug) either the parent process or
    the child process, leaving the execution of the other process unaffected by GDB.
    By default, GDB follows the parent after a call to `fork()`. To set GDB to follow
    the child process, instead, use the `set follow-fork-mode` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Setting breakpoints at `fork()` calls in the program is useful when the user
    wants to change this behavior during a GDB session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `attach_example.c` example shows one way to “follow” both processes on
    a fork: GDB follows the parent process after the fork, and the child sends itself
    a `SIGSTOP` signal to explicitly pause after the fork, allowing the programmer
    to attach a second GDB process to the child before it continues.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.4 Signal Control
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The GDB process can send signals to the target process it is debugging and can
    handle signals received by the target process.
  prefs: []
  type: TYPE_NORMAL
- en: 'GDB can send signals to the process it is debuging by using the `signal` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes a user would like GDB to perform some action when a signal is received
    by the debugged process. For example, if a program tries to access memory with
    a misaligned memory address for the type it is accessing, it receives a `SIGBUS`
    signal and usually exits. The default behavior of GDB on a `SIGBUS` is also to
    let the process exit. If, however, you want GDB to examine the program state when
    it receives a `SIGBUS`, you can specify that GDB handle the `SIGBUS` signal differently
    using the `handle` command (the `info` command shows additional information about
    how GDB handles signals received by the process during debugging):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 3.4.5 DDD Settings and Bug Fixes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Running DDD creates a `.ddd` directory in your home directory, which it uses
    to store its settings so that users don’t need to reset all their preferences
    from scratch on each invocation. Some examples of saved settings include sizes
    of subwindows, menu display options, and enabling windows to view register values
    and assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes DDD hangs on startup with a “Waiting until GDB ready” message. This
    often indicates an error in its saved settings files. The easiest way to fix this
    is remove the `.ddd` directory (you will lose all your saved settings and need
    to reset them when it starts up again):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 3.5 Debugging Assembly Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to high-level C and C++ debugging, GDB can debug a program at its
    assembly code level. Doing so enables GDB to list disassembled code sequences
    from functions, set breakpoints at the assembly instruction level, step through
    program execution one assembly instruction at a time, and examine the values stored
    in machine registers and in stack and heap memory addresses at runtime. We use
    IA32 as the example assembly language in this section, but the GDB commands presented
    here apply to any assembly language that GCC supports. We note that readers may
    find this subsection most useful after reading more about assembly code in later
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the following short C program as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile to an IA32 executable, use the `-m32` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, compiling with `gcc`’s `-fno-asynchronous-unwind-tables` command
    line option generates IA32 code that’s a bit easier for the programmer to read
    and understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 3.5.1 Using GDB to Examine Binary Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this section we show some example GDB commands to debug the short C program
    at the assembly code level. The following table summarizes many of the commands
    this section demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **GDB command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `break sum` | Set a breakpoint at the beginning of the function `sum` |'
  prefs: []
  type: TYPE_TB
- en: '| `break *0x0804851a` | Set a breakpoint at memory address 0x0804851a |'
  prefs: []
  type: TYPE_TB
- en: '| `disass main` | Disassemble the `main` function |'
  prefs: []
  type: TYPE_TB
- en: '| `ni` | Execute the next instruction |'
  prefs: []
  type: TYPE_TB
- en: '| `si` | Step into a function call (step instruction) |'
  prefs: []
  type: TYPE_TB
- en: '| `info registers` | List the register contents |'
  prefs: []
  type: TYPE_TB
- en: '| `p $eax` | Print the value stored in register %eax |'
  prefs: []
  type: TYPE_TB
- en: '| `p *(int *)($ebp+8)` | Print out the value of an int at an address (%ebp+8)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `x/d $ebp+8` | Examine the contents of memory at an address |'
  prefs: []
  type: TYPE_TB
- en: 'First, compile to IA32 assembly and run GDB on the IA32 executable program
    `simpleops`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, set a breakpoint in `main`, and then start running the program with the
    `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The `disass` command disassembles (lists the assembly code associated with)
    parts of the program. For example, to view the assembly instructions of the main
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'GDB allows a programmer to set breakpoints at individual assembly instructions
    by dereferencing the memory address of the instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The program’s execution can be executed one assembly instruction at a time
    using `si` or `ni` to step into or execute the next instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The `si` command steps into function calls, meaning that GDB will pause the
    program at the first instruction of the called function. The `ni` command skips
    over them, meaning that GDB will pause the program at the next instruction following
    the call instruction (after the function executes and returns to the caller).
  prefs: []
  type: TYPE_NORMAL
- en: 'The programmer can print values stored in machine registers using the `print`
    command and the name of the register prefixed by `$`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The `display` command automatically displays values upon reaching a breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The `info registers` command shows all of the values stored in the machine
    registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 3.5.2 Using DDD to Debug at the Assembly Level
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The DDD debugger provides a graphical interface on top of another debugger (GDB
    in this case). It provides a nice interface for displaying assembly code, viewing
    registers, and stepping through IA32 instruction execution. Because DDD has separate
    windows for displaying disassembled code, register values, and the GDB command
    prompt, it’s often easier to use than GDB when debugging at the assembly code
    level.
  prefs: []
  type: TYPE_NORMAL
- en: 'To debug with DDD, substitute `ddd` for `gdb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The GDB prompt appears in the bottom window, where it accepts GDB commands at
    the prompt. Although it provides menu options and buttons for some GDB commands,
    often the GDB prompt at the bottom is easier to use.
  prefs: []
  type: TYPE_NORMAL
- en: DDD displays the assembly code view of a program by selecting the View ▶Machine
    Code Window menu option. That option creates a new subwindow with a listing of
    the program’s assembly code (you will likely want to resize this window to make
    it larger).
  prefs: []
  type: TYPE_NORMAL
- en: To view all of the program’s register values in a separate window, enable the
    Status ▶Registers menu option.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5.3 GDB Assembly Code Debugging Commands and Examples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here are some details and examples of GDB commands that are useful for debugging
    at the assembly code level (see the “Common GDB Commands” section on [page 161](ch03.xhtml#lev2_46)
    for more details about some of these commands, particularly for the `print` and
    `x` formatting options):'
  prefs: []
  type: TYPE_NORMAL
- en: disass   Disassemble code for a function or range of addresses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: break   Set a breakpoint at an instruction address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: stepi **(**si**),** nexti **(**ni**)**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: info registers   Lists all the register values.
  prefs: []
  type: TYPE_NORMAL
- en: print   Displays the value of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: x   Display the contents of the memory location given an address. Remember that
    the format of `x` is sticky, so it needs to be explicitly changed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: set   Set the contents of memory locations and registers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: display   print an expression each time a breakpoint is hit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 3.5.4 Quick Summary of Common Commands for Assembly Debugging
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 3.6 Debugging Multithreaded Programs with GDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Debugging multithreaded programs can be tricky due to the multiple streams of
    execution and due to interactions between the concurrently executing threads.
    In general, here are some things to make debugging multithreaded programs a bit
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: When you can, try to debug a version of the program with as few threads as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When adding debugging `printf` statements to the code, print out the executing
    thread’s ID to identify which thread is printing and end the line with a `\n`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Limit the amount of debug output by having only one of the threads print its
    information and common information. For example, if each thread stores its logical
    ID in a local variable named `my_tid`, then a conditional statement on the value
    of `my_tid` can be used to limit printing debug output to one thread:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 3.6.1 GDB and Pthreads
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The GDB debugger has specific support for debugging threaded programs, including
    setting breakpoints for individual threads and examining the stacks of individual
    threads. One thing to note when debugging Pthreads programs in GDB is that there
    are at least three identifiers for each thread:'
  prefs: []
  type: TYPE_NORMAL
- en: The Pthreads library’s ID for the thread (its `pthread_t` value).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operating system’s lightweight process (LWP) ID value for the thread. This
    ID is used in part for the OS to keep track of this thread for scheduling purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GDB ID for the thread. This is the ID to use when specifying a specific
    thread in GDB commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specific relationship between thread IDs can differ from one OS and Pthreads
    library implementation to another, but on most systems there is a one-to-one-to-one
    correspondence between a Pthreads ID, an LWP ID, and a GDB thread ID.
  prefs: []
  type: TYPE_NORMAL
- en: We present a few GDB basics for debugging threaded programs in GDB. For more
    information about debugging threaded programs in GDB, see *[https://www.sourceware.org/gdb/current/onlinedocs/gdb/Threads.html](https://www.sourceware.org/gdb/current/onlinedocs/gdb/Threads.html).*
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.2 GDB Thread-Specific Commands
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Enable printing thread start and exit events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'List all existing threads in the program (the GDB thread number is the first
    value listed, and the thread that hit the breakpoint is denoted with an `*`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch to a specific thread’s execution context (for example, to examine its
    stack when executing `where`), specify the thread by its thread ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a breakpoint for just a particular thread. Other threads executing at the
    point in the code where the breakpoint is set will not trigger the breakpoint
    to pause the program and print the GDB prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply a specific GDB command to all or to a subset of threads, by adding
    the prefix `thread apply <threadno | all>` to a GDB command, where `threadno`
    refers to the GDB thread ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'This doesn’t work for every GDB command, setting breakpoints in particular,
    so use this syntax instead for setting thread-specific breakpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Upon reaching a breakpoint, by default, GDB pauses all threads until the user
    types `cont`. The user can change the behavior to request that GDB only pause
    the threads that hit a breakpoint, allowing other threads to continue executing.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.3 Examples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We show some GDB commands and output from a GDB run on a multithreaded executable
    compiled from the file `racecond.c`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This errant program lacks synchronization around accesses to the shared variable
    `count`. As a result, different runs of the program produce different final values
    for `count`, indicating a race condition. For example, here are two runs of the
    program with five threads that produce different results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The fix is to put accesses to `count` inside a critical section, using a `pthread_mutex_t`
    variable. If the user was not able to see this fix by examining the C code alone,
    then running in GDB and putting breakpoints around accesses to the `count` variable
    may help the programmer discover the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some example commands from a GDB run of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Shown in the example that follows is partial output of a GDB run of the `racecond.c`
    program with three threads (`run 3`), showing examples of GDB thread commands
    in the context of a GDB debugging session. The main thread is always GDB thread
    number 1, and the three spawned threads are GDB threads 2 to 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'When debugging multithreaded programs, the GDB user must keep track of which
    threads exist when issuing commands. For example, when the breakpoint in `main`
    is hit, only thread 1 (the main thread) exists. As a result, the GDB user must
    wait until threads are created before setting a breakpoint for a specific thread
    (this example shows setting a breakpoint for thread 4 at line 77 in the program).
    In viewing this output, note when breakpoints are set and deleted, and note the
    value of each thread’s local variable `i` when thread contexts are switched with
    GDB’s `thread` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 3.7 Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter concludes our coverage of the C programming language. Compared
    to other high-level programming languages, C is a relatively small programming
    language with a few basic constructs from which a programmer builds their program.
    Because C language abstractions are closer to the underlying machine code executed
    by the computer, a C programmer can write code that runs much more efficiently
    than equivalent code written using the higher-level abstractions provided by other
    programming languages. In particular, a C programmer has much more control over
    how their program uses memory, which can have a significant impact on the program’s
    performance. C is the language of computer systems programming where low-level
    control and efficiency are crucial.
  prefs: []
  type: TYPE_NORMAL
- en: In subsequent chapters we use C examples to illustrate how a computer system
    is designed to run a program.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[1.](ch03.xhtml#rfn3_1) GDB is available at *[https://www.gnu.org/software/gdb](https://www.gnu.org/software/gdb)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[2.](ch03.xhtml#rfn3_2) Valgrind is available at *[https://valgrind.org/info/tools.html](https://valgrind.org/info/tools.html)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[3.](ch03.xhtml#rfn3_3) The Memcheck tool is available at *[https://valgrind.org/docs/manual/mc-manual.html](https://valgrind.org/docs/manual/mc-manual.html)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.](ch03.xhtml#rfn3_4) *[https://valgrind.org/docs/manual/cg-manual.html](https://valgrind.org/docs/manual/cg-manual.html)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[5.](ch03.xhtml#rfn3_5) *[http://valgrind.org/docs/manual/cl-manual.html](http://valgrind.org/docs/manual/cl-manual.html)*'
  prefs: []
  type: TYPE_NORMAL
