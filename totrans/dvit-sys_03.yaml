- en: '3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '3'
- en: C DEBUGGING TOOLS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C 调试工具
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: 'In this section, we introduce two debugging tools: the GNU debugger (GDB),^([1](ch03.xhtml#fn3_1))
    which is useful for examining a program’s runtime state, and Valgrind^([2](ch03.xhtml#fn3_2))
    (pronounced “Val-grinned”), a popular code profiling suite. Specifically, we introduce
    Valgrind’s Memcheck tool,^([3](ch03.xhtml#fn3_3)) which analyzes a program’s memory
    accesses to detect invalid memory usage, uninitialized memory usage, and memory
    leaks.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了两个调试工具：GNU调试器（GDB），^([1](ch03.xhtml#fn3_1))它有助于检查程序的运行时状态，和Valgrind^([2](ch03.xhtml#fn3_2))（发音为“Val-grinned”），一个流行的代码分析工具套件。具体来说，我们介绍了Valgrind的Memcheck工具，^([3](ch03.xhtml#fn3_3))它分析程序的内存访问情况，以检测无效内存使用、未初始化内存使用和内存泄漏。
- en: The GDB section includes two sample GDB sessions that illustrate commonly used
    GDB commands for finding bugs in programs. We also discuss some advanced GDB features,
    including attaching GDB to a running process, GDB and Makefiles, signal control
    in GDB, debugging at the assembly code level, and debugging multithreaded Pthreads
    programs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: GDB部分包括两个示范GDB会话，展示了常用的GDB命令，用于查找程序中的错误。我们还讨论了一些高级GDB功能，包括将GDB附加到正在运行的进程、GDB与Makefile的结合、GDB中的信号控制、在汇编级别调试，以及调试多线程Pthreads程序。
- en: The Valgrind section discusses memory access errors and why they can be so difficult
    to detect. It also includes an example run of Memcheck on a program with some
    bad memory access errors. The Valgrind suite includes other program profiling
    and debugging tools, which we cover in later chapters. For example, we cover the
    cache profiling tool Cachegrind^([4](ch03.xhtml#fn3_4)) in “Cache Analysis and
    Valgrind” in [Chapter 11](ch11.xhtml#ch11), and the function call profiling tool
    Callgrind^([5](ch03.xhtml#fn3_5)) in “Using Callgrind to Profile" in [Chapter
    12](ch12.xhtml#ch12).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind部分讨论了内存访问错误及其为何如此难以检测。它还包括对一个存在错误内存访问的程序执行Memcheck的示例。Valgrind套件包括其他程序分析和调试工具，我们将在后续章节中介绍。例如，我们将在[第11章](ch11.xhtml#ch11)的《缓存分析与Valgrind》一节中介绍缓存分析工具Cachegrind^([4](ch03.xhtml#fn3_4))，以及在[第12章](ch12.xhtml#ch12)的《使用Callgrind进行分析》一节中介绍函数调用分析工具Callgrind^([5](ch03.xhtml#fn3_5))。
- en: 3.1 Debugging with GDB
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1 使用GDB调试
- en: 'GDB can help programmers find and fix bugs in their programs. GDB works with
    programs compiled in a variety of languages, but we focus on C here. A debugger
    is a program that controls the execution of another program (the program being
    debugged)—it allows programmers to see what their programs are doing as they run.
    Using a debugger can help programmers discover bugs and determine the causes of
    the bugs they find. Here are some useful actions that GDB can perform:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: GDB可以帮助程序员发现并修复程序中的错误。GDB支持多种编程语言的编译程序，但我们这里主要关注C语言。调试器是一个控制另一个程序（即被调试程序）执行的程序——它允许程序员在程序运行时看到程序的行为。使用调试器可以帮助程序员发现错误并找出错误的原因。以下是GDB可以执行的一些有用操作：
- en: Start a program and step through it line by line
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动程序并逐行调试
- en: Pause the execution of a program when it reaches certain points in its code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当程序执行到代码中的某些位置时暂停其执行
- en: Pause the execution of a program on user-specified conditions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户指定的条件下暂停程序执行
- en: Show the values of variables at the point in execution that a program is paused
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示程序在暂停执行时的变量值
- en: Continue a program’s execution after a pause
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在暂停后继续程序的执行
- en: Examine the program’s execution state at the point when it crashes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查程序在崩溃时的执行状态
- en: Examine the contents of any stack frame on the call stack
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查调用栈中任何栈帧的内容
- en: GDB users typically set *breakpoints* in their programs. A breakpoint specifies
    a point in the program where GDB will pause the program’s execution. When the
    executing program hits a breakpoint, GDB pauses its execution and allows the user
    to enter GDB commands to examine program variables and stack contents, step through
    the execution of the program one line at a time, add new breakpoints, and continue
    the program’s execution until it hits the next breakpoint.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: GDB用户通常会在程序中设置*断点*。断点指定了程序中的某个位置，GDB将在此位置暂停程序的执行。当执行中的程序达到断点时，GDB会暂停程序的执行，并允许用户输入GDB命令来检查程序变量和栈内容，逐行执行程序，添加新的断点，并继续执行程序直到达到下一个断点。
- en: Many Unix systems also provide the Data Display Debugger (DDD), an easy-to-use
    GUI wrapper around a command line debugger program (GDB, for example). The DDD
    program accepts the same parameters and commands as GDB, but it provides a GUI
    interface with debugging menu options as well as the command line interface to
    GDB.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Unix 系统还提供了数据展示调试器（DDD），这是一个易于使用的图形化界面（GUI）程序，它将命令行调试器（例如 GDB）包装成图形界面。DDD
    程序接受与 GDB 相同的参数和命令，但它提供了图形界面以及 GDB 的命令行接口。
- en: After discussing a few preliminaries about how to get started with GDB, we present
    two example GDB debugging sessions that introduce commonly used GDB commands in
    the context of finding different types of bugs. The first session, “Example Using
    GDB to Debug a Program (badprog.c)” on [page 152](ch03.xhtml#lev3_33), shows how
    to use GDB commands to find logic bugs in a C program. The second session, “Example
    Using GDB to Debug a Program That Crashes (segfaulter.c)” on [page 159](ch03.xhtml#lev3_34),
    shows an example of using GDB commands to examine the program execution state
    at the point when a program crashes in order to discover the cause of the crash.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了如何开始使用 GDB 的一些基本内容后，我们展示了两个示例 GDB 调试会话，介绍了在寻找不同类型的 bug 时常用的 GDB 命令。第一个会话，“使用
    GDB 调试程序示例（badprog.c）”在[第 152 页](ch03.xhtml#lev3_33)上，展示了如何使用 GDB 命令来寻找 C 程序中的逻辑错误。第二个会话，“使用
    GDB 调试崩溃程序示例（segfaulter.c）”在[第 159 页](ch03.xhtml#lev3_34)上，展示了如何使用 GDB 命令检查程序崩溃时的执行状态，以找出崩溃的原因。
- en: In the “Common GDB Commands” section on [page 161](ch03.xhtml#lev2_46), we describe
    commonly used GDB commands in more detail, showing more examples of some commands.
    In later sections, we discuss some advanced GDB features.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 161 页](ch03.xhtml#lev2_46)的“常用 GDB 命令”部分，我们更详细地描述了常用的 GDB 命令，展示了更多命令的示例。在后续章节中，我们将讨论一些高级的
    GDB 功能。
- en: 3.1.1 Getting Started with GDB
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1 开始使用 GDB
- en: When debugging a program, it helps to compile it with the `-g` option, which
    adds extra debugging information to the binary executable file. This extra information
    helps the debugger find program variables and functions in the binary executable
    and enables it to map machine code instructions to lines of C source code (the
    form of the program that the C programmer understands). Also, when compiling for
    debugging, avoid compiler optimizations (for example, do not build with `-O2`).
    Compiler-optimized code is often very difficult to debug because sequences of
    optimized machine code often do not clearly map back to C source code. Although
    we cover the use of the `-g` flag in the following sections, some users may get
    better results with the `-g3` flag, which can reveal extra debugging information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试程序时，建议使用 `-g` 选项进行编译，这会将额外的调试信息添加到二进制可执行文件中。这些额外的信息帮助调试器在二进制可执行文件中找到程序的变量和函数，并使它能够将机器代码指令映射到
    C 源代码的行号（这是 C 程序员能够理解的程序形式）。此外，在进行调试编译时，避免使用编译器优化（例如，不要使用 `-O2` 编译）。编译器优化后的代码通常很难调试，因为优化后的机器代码序列往往不能清晰地映射回
    C 源代码。尽管我们在后续部分会讲解 `-g` 标志的使用，某些用户可能会发现使用 `-g3` 标志能获得更好的调试效果，它会提供更多的调试信息。
- en: 'Here is an example `gcc` command that will build a suitable executable for
    debugging with GDB:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例的 `gcc` 命令，它将构建一个适合用于 GDB 调试的可执行文件：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To start GDB, invoke it on the executable file. For example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 GDB，可以在可执行文件上调用它。例如：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When GDB starts, it prints the `(gdb)` prompt, which allows the user to enter
    GDB commands (such as setting breakpoints) before it starts running the `a.out`
    program.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当 GDB 启动时，它会打印 `(gdb)` 提示符，允许用户在运行 `a.out` 程序之前输入 GDB 命令（例如设置断点）。
- en: 'Similarly, to invoke DDD on the executable file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要在可执行文件上调用 DDD：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Sometimes, when a program terminates with an error, the operating system dumps
    a core file containing information about the state of the program when it crashed.
    The contents of this core file can be examined in GDB by running GDB with the
    core file and the executable that generated it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当程序因错误终止时，操作系统会生成一个核心文件，其中包含程序崩溃时的状态信息。可以通过在 GDB 中运行该核心文件和生成该文件的可执行文件来检查其内容：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 3.1.2 Example GDB Sessions
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2 示例 GDB 会话
- en: We demonstrate common features of GDB through two example sessions of using
    GDB to debug programs. The first is an example of using GDB to find and fix two
    bugs in a program, and the second is an example of using GDB to debug a program
    that crashes. The set of GDB commands that we demonstrate in these two example
    sessions includes those listed in the table that follows.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过两个示例会话演示 GDB 的常见功能，第一例是使用 GDB 查找并修复程序中的两个 bug，第二例是使用 GDB 调试一个崩溃的程序。这两个示例会话中，我们展示的
    GDB 命令集包括下表中列出的命令。
- en: '| **Command** | **Description** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** |'
- en: '| `break` | Set a breakpoint |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `break` | 设置一个断点 |'
- en: '| `run` | Start a program running from the beginning |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `run` | 从头开始启动程序 |'
- en: '| `cont` | Continue execution of the program until it hits a breakpoint |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `cont` | 继续执行程序，直到它命中一个断点 |'
- en: '| `quit` | Quit the GDB session |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `quit` | 退出 GDB 会话 |'
- en: '| `next` | Allow program to execute the next line of C code and then pause
    it |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `next` | 允许程序执行下一行 C 代码，然后暂停 |'
- en: '| `step` | Allow program to execute the next line of C code; if the next line
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `step` | 允许程序执行下一行 C 代码；如果下一行 |'
- en: '|  | contains a function call, step into the function and pause |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|  | 包含一个函数调用，进入函数并暂停 |'
- en: '| `list` | List C source code around pause point or specified point |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `list` | 列出暂停点附近或指定位置的 C 源代码 |'
- en: '| `print` | Print out the value of a program variable (or expression) |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `print` | 打印程序变量（或表达式）的值 |'
- en: '| `where` | Print the call stack |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `where` | 打印调用栈 |'
- en: '| `frame` | Move into the context of a specific stack frame |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `frame` | 进入特定栈帧的上下文 |'
- en: Example Using GDB to Debug a Program (badprog.c)
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 GDB 调试程序示例（badprog.c）
- en: 'The first example GDB session debugs the `badprog.c` program. This program
    is supposed to find the largest value in an array of `int` values. However, when
    run, it incorrectly finds that 17 is the largest value in the array instead of
    the correct largest value, which is 60\. This example shows how GDB can examine
    the program’s runtime state to determine why the program is not computing the
    expected result. In particular, this example debugging session reveals two bugs:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例 GDB 会话调试的是 `badprog.c` 程序。这个程序的目的是在一个 `int` 类型数组中找到最大值。然而，当程序运行时，它错误地认为
    17 是数组中的最大值，而不是正确的最大值 60。这个示例展示了如何使用 GDB 来检查程序的运行时状态，以确定程序为何没有计算出预期的结果。特别地，这个调试会话揭示了两个
    bug：
- en: 1\. An error with loop bounds resulting in the program accessing elements beyond
    the bounds of the array.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 循环边界的错误，导致程序访问数组边界之外的元素。
- en: 2\. An error in a function not returning the correct value to its caller.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 函数未返回正确的值给调用者的错误。
- en: 'To examine a program with GDB, first compile the program with `-g` to add debugging
    information to the executable:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 GDB 检查程序，首先使用 `-g` 编译程序，以将调试信息添加到可执行文件中：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, run GDB on the binary executable program (`a.out`). GDB initializes and
    prints the `(gdb)` prompt, where the user can enter GDB commands:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行 GDB 对二进制可执行程序（`a.out`）进行调试。GDB 初始化并打印 `(gdb)` 提示符，用户可以在此处输入 GDB 命令：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At this point, GDB has not yet started running the program. A common first
    debugging step is to set a breakpoint in the `main()` function to pause the program’s
    execution right before it executes the first instruction in `main()`. The `break`
    command sets a “breakpoint” (pauses the program) at a specified location (in this
    case at the start of the `main()` function):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，GDB 尚未开始运行程序。一个常见的调试步骤是在 `main()` 函数中设置一个断点，以在程序执行 `main()` 函数中的第一条指令之前暂停程序的执行。`break`
    命令将在指定的位置设置一个“断点”（暂停程序），在此例中就是在 `main()` 函数的开始处：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `run` command tells GDB to start the program:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`run` 命令告诉 GDB 启动程序：'
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the program takes command line arguments, provide them after the `run` command
    (for example, run 100 200 would run `a.out` with the command line arguments `100`
    and `200`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序接受命令行参数，可以在 `run` 命令后提供这些参数（例如，运行 `100 200` 将以命令行参数 `100` 和 `200` 启动 `a.out`）。
- en: 'After entering `run`, GDB starts the program’s execution at its beginning,
    and it runs until it hits a breakpoint. Upon reaching a breakpoint, GDB pauses
    the program before executing the line of code at the breakpoint, and prints out
    the breakpoint number and source code line associated with the breakpoint. In
    this example, GDB pauses the program just before executing line 36 of the program.
    It then prints out the `(gdb)` prompt and waits for further instructions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入`run`后，GDB 从程序的开头开始执行，并一直执行到遇到断点为止。到达断点后，GDB 在执行断点所在的代码行之前暂停程序，并打印出与断点相关的断点编号和源代码行。在这个例子中，GDB
    在执行程序的第36行之前暂停程序。然后，它会打印出 `(gdb)` 提示符，等待进一步的指令：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Often when a program pauses at a breakpoint, the user wants to see the C source
    code around the breakpoint. The GDB `list` command displays the code surrounding
    the breakpoint:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序在断点处暂停时，用户通常希望查看断点周围的 C 源代码。GDB 的`list`命令显示断点周围的代码：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Subsequent calls to `list` display the next lines of source code following
    these. `list` can also be used with a specific line number (for example, `list
    11`) or with a function name to list the source code at a specified part of the
    program. For example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的`list`命令调用会显示这些代码之后的下一行源代码。`list`也可以与特定的行号一起使用（例如，`list 11`）或与函数名一起使用，以列出程序中指定部分的源代码。例如：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The user may want to execute one line of code at a time after hitting a breakpoint,
    examining program state after each line is executed. The GDB `next` command executes
    just the very next line of C code. After the program executes this line of code,
    GDB pauses the program again. The `print` command prints the values of program
    variables. Here are a few calls to `next` and `print` to show their effects on
    the next two lines of execution. Note that the source code line listed after a
    `next` has not yet been executed—it shows the line where the program is paused,
    which represents the line that will be executed next:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可能希望在击中断点后逐行执行代码，在每行执行后检查程序状态。GDB 的`next`命令仅执行下一行 C 代码。程序执行该行代码后，GDB会再次暂停程序。`print`命令用于打印程序变量的值。以下是一些`next`和`print`命令的调用，展示它们对接下来的两行执行的影响。请注意，`next`后的源代码行尚未执行——它显示的是程序暂停的地方，代表着下一行将被执行的地方：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At this point in the program’s execution, the main function has initialized
    its local variables `arr` and `max` and is about to make a call to the `findAnd`
    `ReturnMax()` function. The GDB `next` command executes the next full line of
    C source code. If that line includes a function call, the full execution of that
    function call and its return is executed as part of a single `next` command. A
    user who wants to observe the execution of the function should issue GDB’s `step`
    command instead of the `next` command: `step` steps into a function call, pausing
    the program before the first line of the function is executed.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行的这个时刻，主函数已经初始化了它的局部变量`arr`和`max`，并即将调用`findAnd` `ReturnMax()`函数。GDB 的`next`命令执行下一行完整的
    C 源代码。如果该行包含函数调用，那么该函数的完整执行及返回会作为单个`next`命令的一部分执行。希望观察函数执行过程的用户应该使用 GDB 的`step`命令，而不是`next`命令：`step`会进入函数调用，在执行函数的第一行代码之前暂停程序。
- en: 'Because we suspect that the bug in this program is related to the `findAnd`
    `ReturnMax()` function, we want to step into the function’s execution rather than
    past it. So, when paused at line 40, the `step` command will next pause the program
    at the start of the `findAndReturnMax()` (alternately, the user could set a breakpoint
    at `findAndReturnMax()` to pause the program’s execution at that point):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们怀疑程序中的 bug 与`findAnd` `ReturnMax()`函数相关，所以我们希望进入该函数的执行，而不是跳过它。因此，在第40行暂停时，`step`命令将使程序在`findAndReturnMax()`的开始处暂停（另外，用户也可以在`findAndReturnMax()`设置断点，来在该点暂停程序的执行）：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The program is now paused inside the `findAndReturnMax` function, whose local
    variables and parameters are now in scope. The `print` command shows their values,
    and `list` displays the C source code around the pause point:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 程序此时暂停在`findAndReturnMax`函数内部，该函数的局部变量和参数现在处于作用域内。`print`命令显示它们的值，`list`命令显示暂停点周围的
    C 源代码：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because we think there is a bug related to this function, we may want to set
    a breakpoint inside the function so that we can examine the runtime state part
    way through its execution. In particular, setting a breakpoint on the line when
    `max` is changed may help us see what this function is doing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们认为这个函数可能有 bug，所以我们可能想在函数内部设置一个断点，以便我们可以在执行过程中检查运行时状态。特别是，设置一个在 `max` 发生变化时的断点，可能有助于我们看到这个函数在做什么。
- en: We can set a breakpoint at a specific line number in the program (line 27) and
    use the `cont` command to tell GDB to let the application’s execution continue
    from its paused point. Only when the program hits a breakpoint will GDB pause
    the program and grab control again, allowing the user to enter other GDB commands.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在程序中的特定行号（第 27 行）设置断点，并使用 `cont` 命令告诉 GDB 继续执行应用程序，直到遇到下一个断点。只有当程序遇到断点时，GDB
    才会暂停程序并重新控制它，允许用户输入其他 GDB 命令。
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `display` command asks GDB to automatically print out the same set of program
    variables every time a breakpoint is hit. For example, we will display the values
    of `i`, `max`, and `array1[i]` every time the program hits a breakpoint (in each
    iteration of the loop in `findAndReturnMax()`):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`display` 命令要求 GDB 在每次遇到断点时自动打印出相同的一组程序变量。例如，我们将在每次程序遇到断点时显示 `i`、`max` 和 `array1[i]`
    的值（在 `findAndReturnMax()` 中的每次循环迭代时）：'
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We found our first bug! The value of `array1[i]` is 32767, a value not in the
    passed array, and the value of `i` is 5, but 5 is not a valid index into this
    array. Through GDB we discovered that the `for` loop bounds need to be fixed to
    `i <` `len`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现了第一个 bug！`array1[i]` 的值是 32767，这是一个不在传入数组中的值，而 `i` 的值是 5，但 5 不是这个数组的有效索引。通过
    GDB，我们发现 `for` 循环的边界需要修正为 `i < len`。
- en: 'At this point, we could exit the GDB session and fix this bug in the code.
    To quit a GDB session, type quit:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到了这个时候，我们可以退出 GDB 会话并修复代码中的这个 bug。要退出 GDB 会话，输入 quit：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After fixing this bug, recompiling, and running the program, it still does
    not find the correct max value (it still finds that 17 is the max value and not
    60). Based on our previous GDB run, we may suspect that there is an error in calling
    or returning from the `findAndReturnMax()` function. We rerun the new version
    of our program in GDB, this time setting a breakpoint at the entry to the `findAndReturnMax()`
    function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 修复了这个 bug 后，重新编译并运行程序，它仍然没有找到正确的最大值（它仍然认为 17 是最大值而不是 60）。根据我们之前的 GDB 调试，我们可能怀疑在调用或从
    `findAndReturnMax()` 函数返回时存在错误。我们重新在 GDB 中运行程序，并这次在 `findAndReturnMax()` 函数入口处设置了断点：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we suspect a bug in the arguments or return value of a function, it may
    be helpful to examine the contents of the stack. The `where` (or `bt`, for “backtrace”)
    GDB command prints the current state of the stack. In this example, the `main()`
    function is on the bottom of the stack (in frame 1) and is executing a call to
    `findAndReturnMax()` at line 40\. The `findAndReturnMax()` function is on the
    top of the stack (in frame 0) and is currently paused at line 21:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们怀疑函数的参数或返回值有 bug，检查堆栈内容可能会很有帮助。`where`（或 `bt`，即“回溯”）GDB 命令会打印堆栈的当前状态。在这个例子中，`main()`
    函数位于堆栈的底部（在帧 1 中），并且正在执行对 `findAndReturnMax()` 的调用（第 40 行）。`findAndReturnMax()`
    函数位于堆栈的顶部（在帧 0 中），并且当前暂停在第 21 行：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'GDB’s `frame` command moves into the context of any frame on the stack. Within
    each stack frame context, a user can examine the local variables and parameters
    in that frame. In this example, we move into stack frame 1 (the caller’s context)
    and print out the values of the arguments that the `main()` function passes to
    `findAndReturnMax()` (for example, `arr` and `max`):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 的 `frame` 命令可以让我们进入堆栈中任何一个帧的上下文。在每个堆栈帧的上下文中，用户可以检查该帧的局部变量和参数。在这个例子中，我们进入了堆栈帧
    1（调用者的上下文），并打印出 `main()` 函数传递给 `findAndReturnMax()` 的参数值（例如，`arr` 和 `max`）：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The argument values look fine, so let’s check the `findAndReturnMax()` function’s
    return value. To do this, we insert a breakpoint immediately before `findAndReturnMax()`
    returns to see what value it computes for its `max`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 参数值看起来没有问题，因此我们检查 `findAndReturnMax()` 函数的返回值。为此，我们在 `findAndReturnMax()` 返回之前设置了一个断点，看看它计算出的
    `max` 值是什么：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This shows that the function has found the correct max value (60). Let’s execute
    the next few lines of code and see what value the `main()` function receives:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示出函数已经找到了正确的最大值（60）。让我们执行接下来的几行代码，看看 `main()` 函数接收到的值是什么：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We found the second bug! The `findAndReturnMax()` function identifies the correct
    largest value in the passed array (60), but it doesn’t return that value back
    to the `main()` function. To fix this error, we need to either change `findAndReturnMax()`
    to return its value of `max` or add a “pass-by-pointer” parameter that the function
    will use to modify the value of the `main()` function’s `max` local variable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了第二个 bug！`findAndReturnMax()` 函数识别了传递数组中的最大值（60），但是它没有将该值返回给 `main()` 函数。为了解决这个错误，我们需要修改
    `findAndReturnMax()` 函数，使其返回 `max` 值，或者添加一个“按指针传递”的参数，供函数用来修改 `main()` 函数中 `max`
    局部变量的值。
- en: Example Using GDB to Debug a Program That Crashes (segfaulter.c)
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 GDB 调试崩溃程序的示例（segfaulter.c）
- en: The second example GDB session (run on the `segfaulter.c` program) demonstrates
    how GDB behaves when a program crashes and how we can use GDB to help discover
    why the crash occurs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例 GDB 会话（在 `segfaulter.c` 程序上运行）演示了当程序崩溃时 GDB 的行为，以及我们如何利用 GDB 帮助发现崩溃发生的原因。
- en: 'In this example, we just run the `segfaulter` program in GDB and let it crash:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是运行 `segfaulter` 程序并让它崩溃：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As soon as the program crashes, GDB pauses the program’s execution at the point
    it crashes and grabs control. GDB allows a user to issue commands to examine the
    program’s runtime state at the point of the program crash, often leading to discovering
    why the program crashed and how to fix the cause of the crash. The GDB `where`
    and `list` commands are particularly useful for determining where a program crashes:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序崩溃，GDB 会在崩溃点暂停程序的执行并接管控制。GDB 允许用户发出命令检查程序在崩溃点的运行时状态，这通常能帮助我们发现程序崩溃的原因，并找出修复崩溃的办法。GDB
    的 `where` 和 `list` 命令对于确定程序崩溃的位置特别有用：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This output tells us that the program crashes on line 14, in the `initfunc()`
    function. Examining the values of the parameters and local variables on line 14
    may tell us why it crashes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出告诉我们程序在第 14 行的 `initfunc()` 函数处崩溃。检查第 14 行参数和局部变量的值可能能告诉我们崩溃的原因：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The value of `i` seems fine, but we see an error when trying to access index
    `i` of `array`. Let’s print out the value of `array` (the value of the base address
    of the array) to see if that tells us anything:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`i` 的值看起来没问题，但我们在尝试访问 `array` 的索引 `i` 时看到错误。让我们打印出 `array` 的值（即数组基地址的值），看看它是否能告诉我们什么：'
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have found the cause of the crash! The base address of the array is zero
    (or `NULL`), and we know that dereferencing a null pointer (via `array[i]`) causes
    programs to crash.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经找到了崩溃的原因！数组的基地址为零（或 `NULL`），我们知道解引用空指针（通过 `array[i]`）会导致程序崩溃。
- en: 'Let’s see if we can figure out why the `array` parameter is `NULL` by looking
    in the caller’s stack frame:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看通过查看调用者的栈帧，是否能找出为什么 `array` 参数是 `NULL`：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Moving into the caller’s stack frame and printing out the value of the arguments
    `main()` passes to `initfunc()` shows that the `main()` function passes a null
    pointer to the `initfunc()` function. In other words, the user forgot to allocate
    the `arr` array prior to the call to `initfunc()`. The fix is to use the `malloc()`
    function to allocate some space to `arr` at line 34.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 进入调用者的栈帧并打印出 `main()` 传递给 `initfunc()` 的参数值显示，`main()` 函数向 `initfunc()` 传递了一个空指针。换句话说，用户在调用
    `initfunc()` 之前忘记为 `arr` 数组分配内存。解决方法是在第 34 行使用 `malloc()` 函数为 `arr` 分配内存空间。
- en: These two example GDB sessions illustrate commonly used commands for finding
    bugs in programs. In the next section, we discuss these and other GDB commands
    in more detail.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 GDB 示例会话展示了常用的命令，用于查找程序中的 bug。在接下来的章节中，我们将更详细地讨论这些和其他 GDB 命令。
- en: 3.2 GDB Commands in Detail
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2 GDB 命令详解
- en: In this section, we list common GDB commands and show some of their features
    with examples. We first discuss some common keyboard shortcuts that make GDB even
    easier to use.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们列出了常见的 GDB 命令，并通过示例展示了一些功能。我们首先讨论一些常用的键盘快捷键，使 GDB 更易使用。
- en: 3.2.1 Keyboard Shortcuts in GDB
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1 GDB 中的键盘快捷键
- en: GDB supports *command line completion*. A user can enter a unique prefix of
    a command and hit the TAB key, and GDB will try to complete the command line.
    Also, a unique *short abbreviation* can be used to issue many common GDB commands.
    For example, rather than entering the command `print x`, a user can just enter
    `p x` to print out the value of `x`, or `l` can be used for the `list` command,
    or `n` for `next`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 支持*命令行补全*。用户可以输入命令的唯一前缀并按下 TAB 键，GDB 会尝试补全命令行。此外，用户还可以使用唯一的*简短缩写*来执行许多常见的
    GDB 命令。例如，用户可以输入 `p x` 来打印变量 `x` 的值，而不必输入完整的命令 `print x`；`l` 可以用来执行 `list` 命令，`n`
    用来执行 `next` 命令。
- en: The *up and down arrow keys* scroll through previous GDB command lines, eliminating
    the need to retype them each time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*上下箭头键*可滚动查看之前的 GDB 命令行，省去了每次重新输入命令的需要。'
- en: Hitting the RETURN key at the GDB prompt executes the *most recent previous
    command*. This is particularly useful when stepping through the execution with
    a sequence of `next` or `step` commands; just press RETURN and GDB executes the
    next instruction.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GDB 提示符下按下 RETURN 键会执行*最近的上一条命令*。这在通过一系列 `next` 或 `step` 命令逐步执行时特别有用；只需按下
    RETURN，GDB 就会执行下一条指令。
- en: 3.2.2 Common GDB Commands
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2 常用 GDB 命令
- en: 'We summarize GDB’s most common commands here, grouping them by similar functionality:
    commands for controlling program execution; commands for evaluating the point
    in the program’s execution; commands for setting and controlling breakpoints;
    and commands for printing program state and evaluating expressions. The GDB `help`
    command provides information about all GDB commands:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里总结了 GDB 最常用的命令，将它们按相似功能分组：控制程序执行的命令；评估程序执行点的命令；设置和控制断点的命令；打印程序状态和评估表达式的命令。GDB
    的 `help` 命令提供了关于所有 GDB 命令的信息：
- en: help   Help documentation for topics and GDB commands.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: help   显示有关主题和 GDB 命令的帮助文档。
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Commands for Execution Control Flow
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行控制流命令
- en: break   Set a breakpoint.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: break   设置断点。
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Specifying a line in a specific file (as in `break gofish.c:34`) allows a user
    to set breakpoints in C programs that span several C source code files (`.c` files).
    This feature is particularly useful when the breakpoint being set is not in the
    same file as the code at the pause point of the program.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定文件中指定一行（如`break gofish.c:34`）允许用户在多个 C 源代码文件（`.c` 文件）中设置断点。此功能在设置的断点不在程序暂停点的同一文件时特别有用。
- en: run   Start running the debugged program from the beginning.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: run   从头开始运行调试程序。
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: continue **(**cont**)**   Continue execution from breakpoint.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: continue **（cont）**   从断点继续执行。
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: step **(**s**)**   Execute the next line(s) of the program’s C source code,
    stepping into a function if a function call is executed on the line(s).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: step **（s）**   执行程序 C 源代码的下一行，如果该行执行了函数调用，则进入该函数。
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the case of the `step <count>` command, if a line contains a function call,
    lines of the called function are counted in the `count` total of lines to step
    through. Thus, `step <count>` may result in the program pausing inside a function
    that was called from the pause point at which the `step <count>` command was issued.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `step <count>` 命令的情况下，如果一行包含函数调用，则该行调用的函数的行数会计入 `count` 总数中。因此，`step <count>`
    可能会导致程序在一个函数内部暂停，这个函数是从 `step <count>` 命令发出时程序的暂停点调用的。
- en: next   Similar to the `step` command, but it treats a function call as a single
    line. In other words, when the next instruction contains a function call, `next`
    does not step into the execution of the function but pauses the program after
    the function call returns (pausing the program at the next line in the code following
    the one with the function call).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: next   类似于 `step` 命令，但它将函数调用视为单独的一行。换句话说，当下一条指令包含函数调用时，`next` 不会进入函数的执行，而是在函数调用返回后暂停程序（在函数调用后面紧接着的下一行暂停程序）。
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: until   Execute the program until it reaches the specified source code line
    number.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: until   执行程序，直到达到指定的源代码行号。
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: quit   Exit GDB.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: quit   退出 GDB。
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Commands for Examining the Execution Point and Listing Program Code
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 检查执行点和列出程序代码的命令
- en: list   List program source code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: list   列出程序源代码。
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: where **(**backtrace**,** bt**)**   Show the contents of the stack (the sequence
    of function calls at the current point in the program’s execution). The `where`
    command is helpful for pinpointing the location of a program crash and for examining
    state at the interface between function calls and returns, such as argument values
    passed to functions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: where **(**backtrace**,** bt**)**   显示堆栈内容（当前程序执行点的函数调用序列）。`where` 命令有助于定位程序崩溃的位置，并检查函数调用和返回之间接口的状态，例如传递给函数的参数值。
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: frame <frame-num>   Move into the context of stack frame number `<frame-num>`.
    As a default, the program is paused in the context of frame 0, the frame at the
    top of the stack. The `frame` command can be used to move into the context of
    another stack frame. Typically, GDB users move into another stack frame to print
    out the values of parameters and local variables of another function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: frame <frame-num>   进入栈帧编号 `<frame-num>` 的上下文。默认情况下，程序会在栈顶的帧 0 上暂停。`frame` 命令可以用来进入另一个栈帧的上下文。通常，GDB
    用户会进入另一个栈帧，以打印出另一个函数的参数值和局部变量。
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Commands for Setting and Manipulating Breakpoints
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置和操作断点的命令
- en: break   Set a breakpoint (there is more explanation about this command in “Commands
    for Execution Control Flow” on [page 162](ch03.xhtml#lev3_35)).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: break   设置一个断点（关于此命令的更多解释见“执行控制流命令”部分，参见 [第 162 页](ch03.xhtml#lev3_35)）。
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: enable**,** disable**,** ignore**,** delete**,** clear   Enable, disable, ignore
    for some number of times, or delete one or more breakpoints. The `delete` command
    deletes a breakpoint by its number. In contrast, using the `clear` command deletes
    a breakpoint at a particular location in the source code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: enable**,** disable**,** ignore**,** delete**,** clear   启用、禁用、忽略一定次数，或者删除一个或多个断点。`delete`
    命令通过编号删除一个断点。与此相对，使用 `clear` 命令可以删除源代码中特定位置的断点。
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: condition   Set conditions on breakpoints. A conditional breakpoint is one that
    only transfers control to GDB when a certain condition is true. It can be used
    to pause at a breakpoint inside a loop only after some number of iterations (by
    adding a condition on the loop counter variable), or to pause the program at a
    breakpoint only when the value of a variable has an interesting value for debugging
    purposes (avoiding pausing the program at other times).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: condition   设置断点条件。条件断点是在某个条件为真时，才会将控制权转交给 GDB。它可以用来在循环内某个断点处，仅在循环迭代了指定次数后暂停（通过为循环计数器变量添加条件），或者仅当变量值对调试有意义时暂停程序（避免在其他情况下暂停程序）。
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Commands for Examining and Evaluating Program State and Expressions
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 检查和评估程序状态及表达式的命令
- en: print **(**p**)**   Display the value of an expression. Although GDB users typically
    print the value of a program variable, GDB will print the value of any C expression
    (even expressions that are not in the program code). The print command supports
    printing in different formats and supports operands in different numeric representations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: print **(**p**)**   显示表达式的值。尽管 GDB 用户通常打印程序变量的值，但 GDB 会打印任何 C 表达式的值（即使是程序代码中没有的表达式）。`print`
    命令支持以不同格式打印，并支持不同数字表示法的操作数。
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To print in different formats:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要以不同格式打印：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To specify different numeric representations in the expression (the default
    for numbers is decimal representation):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要在表达式中指定不同的数字表示法（数字的默认表示法为十进制表示法）：
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Sometimes, expressions may require explicit type casting to inform `print`
    how to interpret them. For example, here, recasting an address value to a specific
    type (`int *`) is necessary before the address can be dereferenced (otherwise,
    GDB does not know how to dereference the address):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，表达式可能需要显式的类型转换，以告知 `print` 如何解释它们。例如，在这里，需要将地址值重新转换为特定类型（`int *`），才能解引用该地址（否则，GDB
    不知道如何解引用该地址）：
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When using `print` to display the value of a dereferenced pointer variable,
    type casting is not necessary, because GDB knows the type of the pointer variable
    and knows how to dereference its value. For example, if `ptr` is declared as an
    `int *`, then the int value it points to can be displayed like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `print` 显示解引用指针变量的值时，不需要类型转换，因为 GDB 知道指针变量的类型，并知道如何解引用它的值。例如，如果 `ptr` 被声明为
    `int *`，则可以这样显示它指向的 int 值：
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To print out a value stored in a hardware register:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印存储在硬件寄存器中的值：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: display   Automatically display the value of an expression upon reaching a breakpoint.
    The expression syntax is the same as the `print` command.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'display   在达到断点时自动显示表达式的值。表达式语法与`print`命令相同。  '
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: x **(examine memory)**   Display the contents of a memory location. This command
    is similar to `print`, but it interprets its argument as an address value that
    it dereferences to print the value stored at the address.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 'x **(检查内存)**   显示内存位置的内容。此命令类似于`print`，但它将参数解释为一个地址值，并通过解引用该地址来打印存储在该地址上的值。  '
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Like `print`, `x` can display values in different formats (for example, as an
    `int`, a `char`, or a string).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '像`print`一样，`x`可以以不同的格式显示值（例如，作为`int`、`char`或字符串）。  '
- en: '**Warning EXAMINE’S FORMATTING IS STICKY**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告 EXAMINE的格式设置是粘性的**  '
- en: '*Sticky formatting* means that GDB remembers the current format setting, and
    applies it to subsequent calls to `x` that do not specify formatting. For example,
    if the user enters the command `x/c`, all subsequent executions of `x` without
    formatting will use the `/c` format. As a result, formatting options only need
    to be explicitly specified with an `x` command when the user desires changes in
    the memory address units, repetition, or display format of the most recent call
    to `x`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*粘性格式*意味着GDB会记住当前的格式设置，并将其应用于后续没有指定格式的`x`调用。例如，如果用户输入命令`x/c`，那么所有后续没有格式设置的`x`执行将使用`/c`格式。因此，只有在用户希望更改最近一次调用`x`的内存地址单位、重复次数或显示格式时，才需要显式指定`x`命令的格式选项。  '
- en: 'In general, `x` takes up to three formatting arguments (`x/nfu <memory` `address>`);
    the order in which they are listed does not matter:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '一般而言，`x`最多接受三个格式化参数（`x/nfu <memory` `address>`）；它们的列出顺序无关紧要：  '
- en: n   the repeat count (a positive integer value)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'n   重复计数（正整数值）  '
- en: 'f   the display format (`s`: string; `i`: instruction; `x`: hex; `d`: decimal;
    `t`: binary; `a`: address; . . .)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'f   显示格式（`s`：字符串；`i`：指令；`x`：十六进制；`d`：十进制；`t`：二进制；`a`：地址；……）  '
- en: 'u   the units format (number of bytes) (`b`: byte; `h`: 2 bytes; `w`: 4 bytes;
    `g`: 8 bytes)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: u   单位格式（字节数）（`b`：字节；`h`：2字节；`w`：4字节；`g`：8字节）
- en: 'Here are some examples (assume `s1 = "Hello There"` is at memory address `0x40062d`):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '下面是一些例子（假设`s1 = "Hello There"`位于内存地址`0x40062d`）：  '
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: whatis   Show the type of an expression.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'whatis   显示表达式的类型。  '
- en: '[PRE50]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: set   Assign/change the value of a program variable, or assign a value to be
    stored at a specific memory address or in a specific machine register.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 'set   分配/更改程序变量的值，或者分配一个值到特定的内存地址或特定的机器寄存器中。  '
- en: '[PRE51]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'info     Lists information about program state and debugger state. There are
    a large number of `info` options for obtaining information about the program’s
    current execution state and about the debugger. A few examples include:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'info     列出有关程序状态和调试器状态的信息。`info`有许多选项，可以获取关于程序当前执行状态和调试器的各种信息。一些例子包括：  '
- en: '[PRE52]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: For more information about these and other GDB commands, see the GDB man page
    (`man gdb`) and the GNU Debugger home page at *[https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '有关这些及其他GDB命令的更多信息，请参阅GDB手册（`man gdb`）和GNU调试器主页：[https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)。  '
- en: 3.3 Debugging Memory with Valgrind
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '3.3 使用Valgrind调试内存  '
- en: 'Valgrind’s Memcheck debugging tool highlights heap memory errors in programs.
    Heap memory is the part of a running program’s memory that is dynamically allocated
    by calls to `malloc()` and freed by calls to `free()` in C programs. The types
    of memory errors that Valgrind finds include:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'Valgrind的Memcheck调试工具可以突出显示程序中的堆内存错误。堆内存是运行程序的内存部分，通过调用`malloc()`动态分配，并通过调用`free()`释放。在C程序中，Valgrind可以发现的内存错误类型包括：  '
- en: 'Reading (getting) a value from uninitialized memory. For example:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '从未初始化的内存读取（获取）值。例如：  '
- en: '[PRE53]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Reading (getting) or writing (setting) a value at an unallocated memory location,
    which often indicates an array out-of-bounds error. For example:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在未分配的内存位置读取（获取）或写入（设置）值，这通常表示数组越界错误。例如：  '
- en: '[PRE54]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Freeing already freed memory. For example:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '释放已经释放的内存。例如：  '
- en: '[PRE55]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Memory leaks. A *memory leak* is a chunk of allocated heap memory space that
    is not referred to by any pointer variable in the program, and thus it cannot
    be freed. That is, a memory leak occurs when a program loses the address of an
    allocated chunk of heap space. For example:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '内存泄漏。*内存泄漏*是指一块已分配的堆内存空间没有被程序中的任何指针变量引用，因此无法释放。也就是说，当程序丢失了已分配堆空间的地址时，就会发生内存泄漏。例如：  '
- en: '[PRE56]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Memory leaks can eventually cause the program to run out of heap memory space,
    resulting in subsequent calls to `malloc()` failing. The other types of memory
    access errors, such as invalid reads and writes, can lead to the program crashing
    or can result in some program memory contents being modified in seemingly mysterious
    ways.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏最终可能导致程序耗尽堆内存空间，从而导致后续对`malloc()`的调用失败。其他类型的内存访问错误，如无效的读取和写入，可能会导致程序崩溃，或导致程序内存中的某些内容以看似神秘的方式被修改。
- en: Memory access errors are some of the most difficult bugs to find in programs.
    Often a memory access error does not immediately result in a noticeable error
    in the program’s execution. Instead, it may trigger an error that occurs later
    in the execution, often in a part of the program that seemingly has little to
    do with the source of the error. At other times, a program with a memory access
    error may run correctly on some inputs and crash on other inputs, making the cause
    of the error difficult to find and fix.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 内存访问错误是程序中最难以发现的错误之一。通常，内存访问错误不会立即导致程序执行中明显的错误。相反，它可能会触发一个在后续执行中出现的错误，通常发生在与错误源看似无关的程序部分。有时，带有内存访问错误的程序可能在某些输入下运行正常，而在其他输入下崩溃，这使得错误的原因难以找到和修复。
- en: Using Valgrind helps a programmer identify these difficult to find and fix heap
    memory access errors, saving significant amounts of debugging time and effort.
    Valgrind also assists the programmer in identifying any lurking heap memory errors
    that were not discovered in the testing and debugging of their code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Valgrind可以帮助程序员发现这些难以找到和修复的堆内存访问错误，节省大量的调试时间和精力。Valgrind还帮助程序员识别在代码测试和调试中未发现的潜在堆内存错误。
- en: 3.3.1 An Example Program with a Heap Memory Access Error
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1 带有堆内存访问错误的示例程序
- en: 'As an example of how difficult it can be to discover and fix programs with
    memory access errors, consider the following small program. This program exhibits
    a “write to unallocated heap memory” error in the second `for` loop, when it assigns
    values beyond the bounds of the `bigfish` array (note: the listing includes source
    code line numbers, and the `print_array()` function definition is not shown, but
    it behaves as described):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个发现和修复内存访问错误的难度的例子，考虑以下这个小程序。这个程序在第二个`for`循环中展示了一个“写入未分配堆内存”的错误，当它赋值超出了`bigfish`数组的边界（注意：代码列出了源代码的行号，`print_array()`函数的定义未显示，但其行为如描述所示）：
- en: bigfish.c
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: bigfish.c
- en: '[PRE57]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the `main()` function, the second `for` loop causes a heap memory access
    error when it writes to three indices beyond the bounds of the `bigfish` array
    (to indices 10, 11, and 12). The program does not crash at the point where the
    error occurs (at the execution of the second `for` loop); instead, it crashes
    later in its execution at the call to `free(littlefish)`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，第二个`for`循环在写入超出`bigfish`数组边界的三个索引（索引10、11和12）时，会导致堆内存访问错误。程序不会在错误发生时（第二个`for`循环执行时）崩溃；相反，它会在稍后的执行中，在调用`free(littlefish)`时崩溃：
- en: '[PRE58]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Running this program in GDB indicates that the program crashes with a segfault
    at the call to `free(littlefish)`. Crashing at this point may make the programmer
    suspect that there is a bug with accesses to the `littlefish` array. However,
    the cause of the error is due to writes to the `bigfish` array and has nothing
    to do with errors in how the program accesses the `littlefish` array.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在GDB中运行此程序时，会显示程序在调用`free(littlefish)`时发生段错误（segfault）并崩溃。此时崩溃可能让程序员怀疑是`littlefish`数组的访问存在问题。然而，错误的根本原因是对`bigfish`数组的写操作，与程序访问`littlefish`数组的方式无关。
- en: The most likely reason that the program crashes is that the `for` loop goes
    beyond the bounds of the `bigfish` array and overwrites memory between the heap
    memory location of the last allocated element of `bigfish` and the first allocated
    element of `littlefish`. The heap memory locations between the two (and right
    before the first element of `littlefish`) are used by `malloc()` to store metadata
    about the heap memory allocated for the `littlefish` array. Internally, the `free()`
    function uses this metadata to determine how much heap memory to free. The modifications
    to indices 10 and 11 of `bigfish` overwrite these metadata values, resulting in
    the program crash on the call to `free(littlefish)`. We note, however, that not
    all implementations of the `malloc()` function use this strategy.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 程序崩溃最可能的原因是`for`循环超出了`bigfish`数组的边界，并覆盖了`bigfish`最后一个元素的堆内存位置和`littlefish`第一个元素的堆内存位置之间的内存。这两者之间的堆内存位置（以及`littlefish`第一个元素之前的内存）被`malloc()`用来存储关于分配给`littlefish`数组的堆内存的元数据。在内部，`free()`函数使用这些元数据来确定需要释放多少堆内存。对`bigfish`的索引10和11的修改覆盖了这些元数据值，导致程序在调用`free(littlefish)`时崩溃。然而，我们需要注意的是，并非所有`malloc()`函数的实现都使用这种策略。
- en: 'Because the program includes code to print out `littlefish` after the memory
    access error to `bigfish`, the cause of the error may be more obvious to the programmer:
    the second `for` loop is somehow modifying the contents of the `littlefish` array
    (its element 0 value “mysteriously” changes from `0` to `78` after the loop).
    However, even in this very small program, it may be difficult to find the real
    error: if the program didn’t print out `littlefish` after the second `for` loop
    with the memory access error, or if the `for` loop upper bound was `12` instead
    of `13`, there would be no visible mysterious change to program variable values
    that could help a programmer see that there is an error with how the program accesses
    the `bigfish` array.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序包含了在内存访问`bigfish`出错后打印`littlefish`的代码，错误的原因可能对程序员来说更加明显：第二个`for`循环以某种方式修改了`littlefish`数组的内容（它的元素0值在循环后“神秘地”从`0`变成了`78`）。然而，即使在这个非常小的程序中，也可能很难找到真正的错误：如果程序在第二个`for`循环发生内存访问错误后没有打印出`littlefish`，或者如果`for`循环的上限是`12`而不是`13`，那么程序变量的值就不会有明显的神秘变化，这也就无法帮助程序员发现程序在访问`bigfish`数组时存在错误。
- en: In larger programs, a memory access error of this type could be in a very different
    part of the program code than the part that crashes. There also may be no logical
    association between variables used to access heap memory that has been corrupted
    and the variables that were used to erroneously overwrite that same memory; instead,
    their only association is that they happen to refer to memory addresses that are
    allocated close together in the heap. Note that this situation can vary from run
    to run of a program and that such behavior is often hidden from the programmer.
    Similarly, sometimes bad memory accesses will have no noticeable affect on a run
    of the program, making these errors hard to discover. Whenever a program seems
    to run fine for some input, but crashes on other input, this is a sign of a memory
    access error in the program.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的程序中，这种类型的内存访问错误可能出现在程序代码的完全不同部分，而不是崩溃的那部分。可能没有逻辑关联性在访问已被破坏的堆内存的变量和那些错误覆盖该内存的变量之间；它们唯一的关联是它们恰好引用了堆中相邻分配的内存地址。请注意，这种情况可能在程序的每次运行中有所不同，而且这种行为通常对程序员是隐藏的。同样，有时不良的内存访问可能对程序的运行没有明显的影响，这使得这些错误很难被发现。每当程序对某些输入运行正常，但对其他输入崩溃时，这就是程序中内存访问错误的一个信号。
- en: 'Tools like Valgrind can save days of debugging time by quickly pointing programmers
    to the source and type of heap memory access errors in their code. In the previous
    program, Valgrind delineates the point where the error occurs (when the program
    accesses elements beyond the bounds of the `bigfish` array). The Valgrind error
    message includes the type of error, the point in the program where the error occurs,
    and where in the program the heap memory near the bad memory access was allocated.
    For example, here is the information Valgrind will display when the program executes
    line 27 (some details from the actual Valgrind error message are omitted):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Valgrind 这样的工具可以通过迅速指示程序员代码中堆内存访问错误的来源和类型，从而节省数天的调试时间。在前面的程序中，Valgrind 划定了错误发生的位置（当程序访问超出
    `bigfish` 数组边界的元素时）。Valgrind 错误信息包括错误类型、程序中错误发生的位置，以及程序中堆内存分配的位置，该内存紧邻错误内存访问附近。例如，以下是当程序执行第
    27 行时 Valgrind 会显示的信息（实际 Valgrind 错误信息中的一些细节已省略）：
- en: '[PRE59]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This Valgrind error message says that the program is writing to invalid (unallocated)
    heap memory at line 27 and that this invalid memory is located immediately after
    a block of memory that was allocated at line 11, indicating that the loop is accessing
    some elements beyond the bounds of the allocated memory in heap space to which
    `bigfish` points. A potential fix to this bug is to either increase the number
    of bytes passed to `malloc()` or change the second `for` loop bounds to avoid
    writing beyond the bounds of the allocated heap memory space.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 该 Valgrind 错误信息表明程序在第 27 行写入了无效（未分配）的堆内存，并且该无效内存在第 11 行分配的一块内存后立即出现，表明循环访问了一些超出
    `bigfish` 所指向的分配内存边界的元素。解决此 bug 的潜在方法是增加传递给 `malloc()` 的字节数，或者更改第二个 `for` 循环的边界，以避免写入超过分配的堆内存空间的边界。
- en: In addition to finding memory access errors in heap memory, Valgrind can also
    find some errors with stack memory accesses, such as using uninitialized local
    variables or trying to access stack memory locations that are beyond the bounds
    of the current stack. However, Valgrind does not detect stack memory access errors
    at the same granularity as it does with heap memory, and it does not detect memory
    access errors with global data memory.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够发现堆内存中的内存访问错误外，Valgrind 还可以发现一些与栈内存访问相关的错误，例如使用未初始化的局部变量或尝试访问超出当前栈边界的栈内存位置。然而，Valgrind
    在检测栈内存访问错误时，粒度不如堆内存，并且它无法检测到全局数据内存的内存访问错误。
- en: A program can have memory access errors with stack and global memory that Valgrind
    cannot find. However, these errors result in erroneous program behavior or program
    crashing that is similar to the behavior that can occur with heap memory access
    errors. For example, overwriting memory locations beyond the bounds of a statically
    declared array on the stack may result in “mysteriously” changing the values of
    other local variables or may overwrite state saved on the stack that is used for
    returning from a function call, leading to a crash when the function returns.
    Experience using Valgrind for heap memory errors can help a programmer identify
    and fix similar errors with accesses to stack and global memory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序可能会有栈内存和全局内存的访问错误，Valgrind 无法找到这些错误。然而，这些错误会导致程序行为异常或程序崩溃，这种现象与堆内存访问错误引起的行为类似。例如，在栈上超出静态声明数组边界的内存位置写入可能会“神秘地”改变其他局部变量的值，或者可能会覆盖用于从函数调用返回时保存的栈状态，导致函数返回时崩溃。使用
    Valgrind 调试堆内存错误的经验可以帮助程序员识别和修复类似的栈内存和全局内存访问错误。
- en: 3.3.2 How to Use Memcheck
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.2 如何使用 Memcheck
- en: We illustrate some of the main features of Valgrind’s Memcheck memory analysis
    tool on an example program, `valgrindbadprog.c`, which contains several bad memory
    access errors (comments in the code describe the type of error). Valgrind runs
    the Memcheck tool by default; we depend on this default behavior in the code snippets
    that follow. You can explicitly specify the Memcheck tool by using the `--tool=memcheck`
    option. In later sections, we will invoke other Valgrind profiling tools by invoking
    the `--tool` option.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个包含多个错误内存访问的示例程序 `valgrindbadprog.c` 来展示 Valgrind Memcheck 内存分析工具的主要功能（代码中的注释描述了错误类型）。Valgrind
    默认运行 Memcheck 工具；我们在接下来的代码片段中依赖于这种默认行为。您也可以通过使用 `--tool=memcheck` 选项显式指定 Memcheck
    工具。在后续部分，我们将通过调用 `--tool` 选项来调用其他 Valgrind 性能分析工具。
- en: 'To run Memcheck, first compile the `valgrindbadprog.c` program with the `-g`
    flag to add debugging information to the executable file. Then, run the executable
    with `valgrind`. Note that for noninteractive programs, it may be helpful to redirect
    Valgrind’s output to a file for viewing after the program exits:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行Memcheck，首先使用`-g`标志编译`valgrindbadprog.c`程序，向可执行文件添加调试信息。然后，使用`valgrind`运行可执行文件。请注意，对于非交互式程序，将Valgrind的输出重定向到文件以在程序退出后查看可能是有帮助的：
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Valgrind’s Memcheck tool prints out memory access errors and warnings as they
    occur during the program’s execution. At the end of the program’s execution, Memcheck
    also prints out a summary about any memory leaks in the program. Even though memory
    leaks are important to fix, the other types of memory access errors are much more
    critical to a program’s correctness. As a result, unless memory leaks are causing
    a program to run out of heap memory space and crash, a programmer should focus
    first on fixing these other types of memory access errors before considering memory
    leaks. To view details of individual memory leaks, use the `--leak-check=yes`
    option.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind的Memcheck工具会在程序执行期间打印出内存访问错误和警告。在程序执行结束时，Memcheck还会打印关于程序中任何内存泄漏的摘要。尽管修复内存泄漏很重要，但程序正确性的其他类型的内存访问错误则更为关键。因此，除非内存泄漏导致程序耗尽堆内存空间并崩溃，否则程序员应首先专注于修复这些其他类型的内存访问错误，而不是考虑内存泄漏。要查看单个内存泄漏的详细信息，请使用`--leak-check=yes`选项。
- en: 'When first using Valgrind, its output may seem a bit difficult to parse. However,
    the output all follows the same basic format, and once you know this format, it’s
    easier to understand the information that Valgrind is displaying about heap memory
    access errors and warnings. Here is an example Valgrind error from a run of the
    `valgrindbadprog.c` program:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 初次使用Valgrind时，其输出可能看起来有些难以解析。然而，输出都遵循同一基本格式，一旦了解了这个格式，就更容易理解Valgrind显示的关于堆内存访问错误和警告的信息。以下是运行`valgrindbadprog.c`程序时的一个Valgrind错误示例：
- en: '[PRE61]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Each line of Valgrind output is prefixed with the process’s ID (PID) number
    (31059 in this example):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 每行Valgrind输出都以进程的ID（PID）号（例如此处的31059）开头。
- en: '[PRE62]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Most Valgrind errors and warnings have the following format:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Valgrind的错误和警告具有以下格式：
- en: The type of error or warning.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误或警告的类型。
- en: Where the error occurred (a stack trace at the point in the program’s execution
    when the error occurs.)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误发生的位置（程序执行到达错误位置时的堆栈跟踪。）
- en: Where heap memory around the error was allocated (usually the memory allocation
    related to the error.)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误周围的堆内存分配位置（通常是与错误相关的内存分配。）
- en: 'In the preceding example error, the first line indicates an invalid write to
    memory (writing to unallocated memory in the heap—a very bad error!):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例错误中，第一行指示对内存的无效写入（写入到堆中未分配的内存——这是一个非常严重的错误！）：
- en: '[PRE63]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The next few lines show the stack trace where the error occurred. These indicate
    an invalid write occurred at line 29 in function `foo()`, which was called from
    function `main()` at line 56:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行显示了错误发生的堆栈跟踪。这些指示表明，在`foo()`函数的第29行发生了无效写入，而`foo()`函数是由`main()`函数在第56行调用的。
- en: '[PRE64]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The remaining lines indicate where the heap space near the invalid write was
    allocated in the program. This section of Valgrind’s output says that the invalid
    write was immediately after (`0 bytes after`) a block of 5 bytes of heap memory
    space that was allocated by a call to `malloc()` at line 18 in function `foo()`,
    called by `main()` at line 56:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的行显示了发生无效写入附近的堆空间位置。Valgrind的输出部分显示，该无效写入是在分配了一个5字节堆内存空间块之后（由第18行`foo()`函数中的`malloc()`调用分配），立即发生的，由`main()`函数在第56行调用`foo()`函数：
- en: '[PRE65]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The information from this error identifies that there is an unallocated heap
    memory write error in the program, and it directs the user to specific parts of
    the program where the error occurs (line 29) and where memory around the error
    was allocated (line 18). By looking at these points in the program, the programmer
    may see the cause of and the fix for the error:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误信息显示了程序中存在一个未分配的堆内存写入错误，并指导用户到程序中特定的错误发生位置（第29行）和错误周围的内存分配位置（第18行）。通过查看程序中的这些点，程序员可以找到错误的原因和修复方法：
- en: '[PRE66]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The cause is that the `for` loop executes one time too many, accessing `c[5]`,
    which is beyond the end of array `c`. The fix is to either change the loop bounds
    at line 29 or to allocate a larger array at line 18.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是`for`循环执行了一次过多，访问了数组`c`的`c[5]`，这超出了数组`c`的末尾。修复方法可以是修改第29行的循环边界，或者在第18行分配一个更大的数组。
- en: If examining the code around a Valgrind error is not sufficient for a programmer
    to understand or fix the error, using GDB might be helpful. Setting breakpoints
    around the points in the code associated with the Valgrind errors can help a programmer
    evaluate the program’s runtime state and understand the cause of the Valgrind
    error. For example, by putting a breakpoint at line 29 and printing the values
    of `i` and `str`, the programmer can see the array out-of-bounds error when `i`
    is 5\. In this case, the combination of using Valgrind and GDB helps the programmer
    determine how to fix the memory access bugs that Valgrind finds.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仅查看Valgrind错误周围的代码对程序员来说不足以理解或修复错误，可以考虑使用GDB进行调试。在与Valgrind错误相关联的代码点设置断点可以帮助程序员评估程序的运行状态，并理解Valgrind错误的原因。例如，在第29行设置断点并打印`i`和`str`的值，程序员可以看到当`i`为5时的数组越界错误。在这种情况下，结合使用Valgrind和GDB有助于程序员确定如何修复Valgrind发现的内存访问错误。
- en: Although this chapter has focused on Valgrind’s default Memcheck tool, we characterize
    some of Valgrind’s other capabilities later in the book, including the Cachegrind
    cache profiling tool ([Chapter 11](ch11.xhtml#ch11)), the Callgrind code profiling
    tool ([Chapter 12](ch12.xhtml#ch12)), and the Massif memory profiling tool ([Chapter
    12](ch12.xhtml#ch12)). For more information about using Valgrind, see the Valgrind
    home page at *[https://valgrind.org](https://valgrind.org),* and its online manual
    at *[https://valgrind.org/docs/manual/](https://valgrind.org/docs/manual/)*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章重点介绍了Valgrind的默认Memcheck工具，但我们稍后在书中还将详细介绍Valgrind的其他功能，包括Cachegrind缓存分析工具（[第11章](ch11.xhtml#ch11)）、Callgrind代码分析工具（[第12章](ch12.xhtml#ch12)）和Massif内存分析工具（[第12章](ch12.xhtml#ch12)）。有关使用Valgrind的更多信息，请参阅Valgrind主页
    *[https://valgrind.org](https://valgrind.org)*，以及其在线手册 *[https://valgrind.org/docs/manual/](https://valgrind.org/docs/manual/)*。
- en: 3.4 Advanced GDB Features
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4 高级GDB功能
- en: This section presents advanced GDB features, some of which may make sense only
    after reading [Chapter 13](ch13.xhtml#ch13), “Notes.”
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了高级GDB功能，其中一些功能只有在阅读 [第13章](ch13.xhtml#ch13) “Notes” 后才会有意义。
- en: 3.4.1 GDB and make
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.1 GDB和make
- en: GDB accepts the `make` command to rebuild an executable during a debugging session,
    and if the build is successful it will run the newly built program (when issued
    the `run` command).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: GDB接受`make`命令在调试会话期间重新构建可执行文件，如果构建成功，则会运行新构建的程序（当发出`run`命令时）。
- en: '[PRE67]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Building from within GDB is convenient for a user who has set many breakpoints
    and has fixed one bug but wants to continue the debugging session. In this case,
    rather than quitting GDB, recompiling, restarting GDB with the new executable,
    and resetting all the breakpoints, a GDB user can run `make` and start debugging
    the new version of the program with all the breakpoints still set. Keep in mind,
    however, that modifying the C source and recompiling by running `make` from within
    GDB may result in the breakpoints not being at the same logical location in the
    new version of the program as in the old version if source code lines have been
    added or deleted. When this problem occurs, either exit GDB and restart the GDB
    session on the new executable, or use `disable` or `delete` to disable or delete
    the old breakpoints and then `break` to set new breakpoints at the correct locations
    in the newly compiled version of the program.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在GDB中重新构建是方便的，适用于已设置许多断点并已修复一个错误，但希望继续调试会话的用户。在这种情况下，用户无需退出GDB，重新编译，用新的可执行文件重新启动GDB，并重新设置所有断点，而是可以运行`make`并开始调试程序的新版本，所有断点仍然保持设置状态。然而，需要注意的是，如果在GDB中运行`make`修改C源代码并重新编译可能导致断点在新程序版本中不在与旧版本相同的逻辑位置，因为源代码行可能已经添加或删除。当出现此问题时，要么退出GDB并在新的可执行文件上重新启动GDB会话，要么使用`disable`或`delete`禁用或删除旧断点，然后使用`break`在新编译的程序版本中设置新的断点位置。
- en: 3.4.2 Attaching GDB to a Running Process
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.2 将GDB附加到正在运行的进程
- en: 'GDB supports debugging a program that is already running (rather than starting
    a program to run from within a GDB session) by *attaching* GDB to a running process.
    To do this, the user needs to get the process ID (PID) value:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: GDB支持调试已经运行的程序（而不是从GDB会话内启动程序），通过*附加*GDB到正在运行的进程。为此，用户需要获取进程ID（PID）值：
- en: '1\. Get the process’s PID using the `ps` shell command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 使用`ps` shell命令获取进程的PID：
- en: 'ps to get process''s PID (lists all processes started in current shell):'
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ps命令获取进程的PID（列出在当前shell中启动的所有进程）：
- en: $ ps
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: $ ps
- en: 'list all processes and pipe through grep for just those named a.out:'
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出所有进程并通过grep管道过滤只有名为a.out的进程：
- en: $ ps -A | grep a.out
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: $ ps -A | grep a.out
- en: PID TTY          TIME CMD
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: PID TTY          TIME CMD
- en: 12345 pts/3     00:00:00 a.out
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 12345 pts/3      00:00:00 a.out
- en: '2\. Start GDB and attach it to the specific running process (with PID 12345):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 启动 GDB 并将其附加到特定的运行中进程（PID 为 12345）：
- en: gdb <executable> <pid>
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gdb <可执行文件> <pid>
- en: $ gdb a.out 12345
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: $ gdb a.out 12345
- en: (gdb)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: (gdb)
- en: 'OR alternative syntax: gdb attach <pid>  <executable>'
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 或者另一种语法：gdb attach <pid> <可执行文件>
- en: $ gdb attach 12345 a.out
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: $ gdb attach 12345 a.out
- en: (gdb)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: (gdb)
- en: Attaching GDB to a process pauses it, and the user can issue GDB commands before
    continuing its execution.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 将 GDB 附加到进程会暂停该进程，用户可以在继续执行之前输入 GDB 命令。
- en: Alternatively, a program can explicitly pause itself to wait for debugging by
    calling `kill(getpid(), SIGSTOP)` (as in the `attach_example.c` example). When
    the program pauses at this point, a programmer can attach GDB to the process to
    debug it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，程序可以通过调用`kill(getpid(), SIGSTOP)`（如`attach_example.c`示例中所示）显式地暂停自身，等待调试。当程序在这一点暂停时，程序员可以将
    GDB 附加到该进程进行调试。
- en: 'Regardless of how a program pauses, after GDB attaches and the user enters
    some GDB commands, the program’s execution continues from its attach point using
    `cont`. If `cont` doesn’t work, GDB may need to explicitly send the process a
    `SIGCONT` signal in order to continue its execution:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 无论程序如何暂停，在 GDB 附加后并且用户输入一些 GDB 命令后，程序的执行将从附加点继续，使用`cont`命令。如果`cont`不起作用，GDB
    可能需要显式地发送`SIGCONT`信号给进程以继续执行：
- en: '[PRE68]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 3.4.3 Following a Process on a Fork
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.3 在 fork 时跟随进程
- en: 'When GDB debugs a program that calls the `fork()` function to create a new
    child process, GDB can be set to follow (to debug) either the parent process or
    the child process, leaving the execution of the other process unaffected by GDB.
    By default, GDB follows the parent after a call to `fork()`. To set GDB to follow
    the child process, instead, use the `set follow-fork-mode` command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当 GDB 调试调用`fork()`函数创建新子进程的程序时，GDB 可以被设置为跟随（调试）父进程或子进程，从而使另一个进程的执行不受 GDB 的影响。默认情况下，GDB
    在调用`fork()`后会跟随父进程。如果要让 GDB 跟随子进程，可以使用`set follow-fork-mode`命令：
- en: '[PRE69]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Setting breakpoints at `fork()` calls in the program is useful when the user
    wants to change this behavior during a GDB session.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的`fork()`调用处设置断点对用户在 GDB 会话中想要改变这一行为时非常有用。
- en: 'The `attach_example.c` example shows one way to “follow” both processes on
    a fork: GDB follows the parent process after the fork, and the child sends itself
    a `SIGSTOP` signal to explicitly pause after the fork, allowing the programmer
    to attach a second GDB process to the child before it continues.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`attach_example.c`示例展示了如何在 fork 后“跟随”两个进程：GDB 在 fork 后跟随父进程，子进程通过发送`SIGSTOP`信号显式地暂停自己，允许程序员在子进程继续执行之前将第二个
    GDB 进程附加到子进程上。'
- en: 3.4.4 Signal Control
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.4 信号控制
- en: The GDB process can send signals to the target process it is debugging and can
    handle signals received by the target process.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 进程可以向它正在调试的目标进程发送信号，并处理目标进程接收到的信号。
- en: 'GDB can send signals to the process it is debuging by using the `signal` command:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 可以通过使用`signal`命令向它正在调试的进程发送信号：
- en: '[PRE70]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Sometimes a user would like GDB to perform some action when a signal is received
    by the debugged process. For example, if a program tries to access memory with
    a misaligned memory address for the type it is accessing, it receives a `SIGBUS`
    signal and usually exits. The default behavior of GDB on a `SIGBUS` is also to
    let the process exit. If, however, you want GDB to examine the program state when
    it receives a `SIGBUS`, you can specify that GDB handle the `SIGBUS` signal differently
    using the `handle` command (the `info` command shows additional information about
    how GDB handles signals received by the process during debugging):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，用户希望 GDB 在调试进程接收到信号时执行某些操作。例如，如果程序尝试访问与它正在访问的类型不匹配的内存地址，它会接收到`SIGBUS`信号并通常退出。GDB
    对`SIGBUS`的默认行为也是让进程退出。然而，如果你希望 GDB 在接收到`SIGBUS`信号时检查程序状态，你可以通过`handle`命令指定 GDB
    以不同的方式处理`SIGBUS`信号（`info`命令显示有关 GDB 如何处理调试过程中接收到的信号的更多信息）：
- en: '[PRE71]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 3.4.5 DDD Settings and Bug Fixes
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.5 DDD 设置与 Bug 修复
- en: Running DDD creates a `.ddd` directory in your home directory, which it uses
    to store its settings so that users don’t need to reset all their preferences
    from scratch on each invocation. Some examples of saved settings include sizes
    of subwindows, menu display options, and enabling windows to view register values
    and assembly code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 运行DDD会在你的主目录下创建一个`.ddd`目录，DDD使用这个目录存储它的设置，这样用户就不需要在每次启动时重新设置所有偏好设置。保存的设置包括子窗口的大小、菜单显示选项以及启用窗口查看寄存器值和汇编代码的功能。
- en: 'Sometimes DDD hangs on startup with a “Waiting until GDB ready” message. This
    often indicates an error in its saved settings files. The easiest way to fix this
    is remove the `.ddd` directory (you will lose all your saved settings and need
    to reset them when it starts up again):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有时DDD在启动时会挂起，显示“Waiting until GDB ready”消息。这通常表示其保存的设置文件存在错误。修复这个问题的最简单方法是删除`.ddd`目录（你会丢失所有保存的设置，并且需要在它重新启动时重新设置）：
- en: '[PRE72]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 3.5 Debugging Assembly Code
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5 调试汇编代码
- en: In addition to high-level C and C++ debugging, GDB can debug a program at its
    assembly code level. Doing so enables GDB to list disassembled code sequences
    from functions, set breakpoints at the assembly instruction level, step through
    program execution one assembly instruction at a time, and examine the values stored
    in machine registers and in stack and heap memory addresses at runtime. We use
    IA32 as the example assembly language in this section, but the GDB commands presented
    here apply to any assembly language that GCC supports. We note that readers may
    find this subsection most useful after reading more about assembly code in later
    chapters.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 除了高级的C和C++调试外，GDB还可以在汇编代码层面调试程序。这样，GDB能够列出来自函数的反汇编代码序列、在汇编指令级别设置断点、逐条执行汇编指令以及在程序运行时检查存储在机器寄存器、栈和堆内存地址中的值。我们在本节使用IA32作为示例汇编语言，但这里介绍的GDB命令适用于GCC支持的任何汇编语言。我们提到，读者可能会在后续章节深入了解汇编代码后，发现本小节特别有用。
- en: 'We use the following short C program as an example:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下简短的C程序作为示例：
- en: '[PRE73]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To compile to an IA32 executable, use the `-m32` flag:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译为IA32可执行文件，请使用`-m32`标志：
- en: '[PRE74]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Optionally, compiling with `gcc`’s `-fno-asynchronous-unwind-tables` command
    line option generates IA32 code that’s a bit easier for the programmer to read
    and understand:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 可选择使用`gcc`的`-fno-asynchronous-unwind-tables`命令行选项进行编译，这会生成一个对程序员来说稍微容易阅读和理解的IA32代码：
- en: '[PRE75]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 3.5.1 Using GDB to Examine Binary Code
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.1 使用GDB检查二进制代码
- en: 'In this section we show some example GDB commands to debug the short C program
    at the assembly code level. The following table summarizes many of the commands
    this section demonstrates:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了一些示例GDB命令，用于在汇编代码层面调试一个简短的C程序。以下表格总结了本节展示的许多命令：
- en: '| **GDB command** | **Description** |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| **GDB命令** | **描述** |'
- en: '| `break sum` | Set a breakpoint at the beginning of the function `sum` |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `break sum` | 在函数`sum`的开始处设置断点 |'
- en: '| `break *0x0804851a` | Set a breakpoint at memory address 0x0804851a |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `break *0x0804851a` | 在内存地址0x0804851a处设置断点 |'
- en: '| `disass main` | Disassemble the `main` function |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `disass main` | 反汇编`main`函数 |'
- en: '| `ni` | Execute the next instruction |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `ni` | 执行下一条指令 |'
- en: '| `si` | Step into a function call (step instruction) |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `si` | 进入函数调用（逐条指令） |'
- en: '| `info registers` | List the register contents |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `info registers` | 列出寄存器内容 |'
- en: '| `p $eax` | Print the value stored in register %eax |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `p $eax` | 打印寄存器%eax中存储的值 |'
- en: '| `p *(int *)($ebp+8)` | Print out the value of an int at an address (%ebp+8)
    |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `p *(int *)($ebp+8)` | 打印地址（%ebp+8）处的整数值 |'
- en: '| `x/d $ebp+8` | Examine the contents of memory at an address |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `x/d $ebp+8` | 检查地址处的内存内容 |'
- en: 'First, compile to IA32 assembly and run GDB on the IA32 executable program
    `simpleops`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编译为IA32汇编并在IA32可执行程序`simpleops`上运行GDB：
- en: '[PRE76]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then, set a breakpoint in `main`, and then start running the program with the
    `run` command:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`main`中设置断点，然后使用`run`命令开始运行程序：
- en: '[PRE77]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `disass` command disassembles (lists the assembly code associated with)
    parts of the program. For example, to view the assembly instructions of the main
    function:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`disass`命令反汇编（列出与之关联的汇编代码）程序的部分代码。例如，要查看`main`函数的汇编指令：'
- en: '[PRE78]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'GDB allows a programmer to set breakpoints at individual assembly instructions
    by dereferencing the memory address of the instruction:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: GDB允许程序员通过解引用指令的内存地址来在单个汇编指令上设置断点：
- en: '[PRE79]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The program’s execution can be executed one assembly instruction at a time
    using `si` or `ni` to step into or execute the next instruction:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的执行可以通过`si`或`ni`逐条执行汇编指令来进行，其中`si`步入调用，`ni`跳过调用指令：
- en: '[PRE80]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The `si` command steps into function calls, meaning that GDB will pause the
    program at the first instruction of the called function. The `ni` command skips
    over them, meaning that GDB will pause the program at the next instruction following
    the call instruction (after the function executes and returns to the caller).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`si`命令会逐步进入函数调用，这意味着GDB会在被调用函数的第一条指令处暂停程序。`ni`命令会跳过它们，这意味着GDB会在调用指令执行并返回到调用者后，暂停程序并停在下一条指令。'
- en: 'The programmer can print values stored in machine registers using the `print`
    command and the name of the register prefixed by `$`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可以使用`print`命令和以`$`前缀的寄存器名称打印存储在机器寄存器中的值：
- en: '[PRE81]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `display` command automatically displays values upon reaching a breakpoint:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`display`命令在达到断点时自动显示值：'
- en: '[PRE82]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `info registers` command shows all of the values stored in the machine
    registers:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`info registers`命令显示所有存储在机器寄存器中的值：'
- en: '[PRE83]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 3.5.2 Using DDD to Debug at the Assembly Level
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.2 使用DDD进行汇编级别调试
- en: The DDD debugger provides a graphical interface on top of another debugger (GDB
    in this case). It provides a nice interface for displaying assembly code, viewing
    registers, and stepping through IA32 instruction execution. Because DDD has separate
    windows for displaying disassembled code, register values, and the GDB command
    prompt, it’s often easier to use than GDB when debugging at the assembly code
    level.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: DDD调试器为另一个调试器（在此为GDB）提供了图形界面。它提供了一个很好的界面，用于显示汇编代码、查看寄存器以及逐步执行IA32指令。由于DDD具有用于显示反汇编代码、寄存器值和GDB命令提示符的独立窗口，因此在汇编代码级别调试时，它通常比GDB更容易使用。
- en: 'To debug with DDD, substitute `ddd` for `gdb`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用DDD调试，请将`ddd`替换为`gdb`：
- en: '[PRE84]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The GDB prompt appears in the bottom window, where it accepts GDB commands at
    the prompt. Although it provides menu options and buttons for some GDB commands,
    often the GDB prompt at the bottom is easier to use.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: GDB提示符出现在底部窗口，在这里接受GDB命令。尽管它提供了一些GDB命令的菜单选项和按钮，但通常底部的GDB提示符更容易使用。
- en: DDD displays the assembly code view of a program by selecting the View ▶Machine
    Code Window menu option. That option creates a new subwindow with a listing of
    the program’s assembly code (you will likely want to resize this window to make
    it larger).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择视图 ▶机器代码窗口菜单选项，DDD显示程序的汇编代码视图。该选项会创建一个新子窗口，列出程序的汇编代码（你可能需要调整窗口大小以使其变大）。
- en: To view all of the program’s register values in a separate window, enable the
    Status ▶Registers menu option.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要在单独的窗口中查看程序的所有寄存器值，请启用状态 ▶寄存器菜单选项。
- en: 3.5.3 GDB Assembly Code Debugging Commands and Examples
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.3 GDB汇编代码调试命令和示例
- en: 'Here are some details and examples of GDB commands that are useful for debugging
    at the assembly code level (see the “Common GDB Commands” section on [page 161](ch03.xhtml#lev2_46)
    for more details about some of these commands, particularly for the `print` and
    `x` formatting options):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些对在汇编代码级别调试有用的GDB命令的详细信息和示例（有关这些命令的更多详细信息，特别是`print`和`x`格式选项，请参见[第161页](ch03.xhtml#lev2_46)的“常见GDB命令”部分）：
- en: disass   Disassemble code for a function or range of addresses.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: disass   反汇编函数或地址范围的代码。
- en: '[PRE85]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: break   Set a breakpoint at an instruction address.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: break   在指令地址处设置一个断点。
- en: '[PRE86]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: stepi **(**si**),** nexti **(**ni**)**
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: stepi **（si）**, nexti **（ni）**
- en: '[PRE87]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: info registers   Lists all the register values.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: info registers   列出所有寄存器的值。
- en: print   Displays the value of an expression.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: print   显示表达式的值。
- en: '[PRE88]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: x   Display the contents of the memory location given an address. Remember that
    the format of `x` is sticky, so it needs to be explicitly changed.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: x   显示给定地址的内存位置的内容。请记住，`x`的格式是固定的，因此需要显式更改。
- en: '[PRE89]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: set   Set the contents of memory locations and registers.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: set   设置内存位置和寄存器的内容。
- en: '[PRE90]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: display   print an expression each time a breakpoint is hit.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: display   每次命中断点时打印表达式的值。
- en: '[PRE91]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 3.5.4 Quick Summary of Common Commands for Assembly Debugging
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.4 常用汇编调试命令快速总结
- en: '[PRE92]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 3.6 Debugging Multithreaded Programs with GDB
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6 使用GDB调试多线程程序
- en: Debugging multithreaded programs can be tricky due to the multiple streams of
    execution and due to interactions between the concurrently executing threads.
    In general, here are some things to make debugging multithreaded programs a bit
    easier.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 调试多线程程序可能会比较棘手，因为存在多个执行流，并且线程之间的交互会影响程序行为。通常来说，以下是一些可以让多线程调试变得稍微容易的技巧。
- en: When you can, try to debug a version of the program with as few threads as possible.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可以，尽量调试一个线程较少的程序版本。
- en: When adding debugging `printf` statements to the code, print out the executing
    thread’s ID to identify which thread is printing and end the line with a `\n`.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中添加调试 `printf` 语句时，打印出执行线程的 ID，以识别哪个线程正在打印，并且在行尾加上 `\n`。
- en: 'Limit the amount of debug output by having only one of the threads print its
    information and common information. For example, if each thread stores its logical
    ID in a local variable named `my_tid`, then a conditional statement on the value
    of `my_tid` can be used to limit printing debug output to one thread:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过让只有一个线程打印其信息和公共信息来限制调试输出的数量。例如，如果每个线程将其逻辑 ID 存储在名为 `my_tid` 的局部变量中，则可以使用一个条件语句来根据
    `my_tid` 的值限制打印调试输出，只对一个线程进行打印：
- en: '[PRE93]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 3.6.1 GDB and Pthreads
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.1 GDB 和 Pthreads
- en: 'The GDB debugger has specific support for debugging threaded programs, including
    setting breakpoints for individual threads and examining the stacks of individual
    threads. One thing to note when debugging Pthreads programs in GDB is that there
    are at least three identifiers for each thread:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 调试器对调试多线程程序提供了特定支持，包括为单独线程设置断点和检查单独线程的堆栈。在 GDB 中调试 Pthreads 程序时，需要注意的一点是，每个线程至少有三个标识符：
- en: The Pthreads library’s ID for the thread (its `pthread_t` value).
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pthreads 库中线程的 ID（其 `pthread_t` 值）。
- en: The operating system’s lightweight process (LWP) ID value for the thread. This
    ID is used in part for the OS to keep track of this thread for scheduling purposes.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统的轻量级进程（LWP）ID 值，用于线程。此 ID 部分用于操作系统跟踪该线程的调度。
- en: The GDB ID for the thread. This is the ID to use when specifying a specific
    thread in GDB commands.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程的 GDB ID。在 GDB 命令中指定特定线程时使用该 ID。
- en: The specific relationship between thread IDs can differ from one OS and Pthreads
    library implementation to another, but on most systems there is a one-to-one-to-one
    correspondence between a Pthreads ID, an LWP ID, and a GDB thread ID.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 线程 ID 之间的具体关系可能因操作系统和 Pthreads 库的实现而有所不同，但在大多数系统中，Pthreads ID、LWP ID 和 GDB 线程
    ID 之间是三者一一对应的。
- en: We present a few GDB basics for debugging threaded programs in GDB. For more
    information about debugging threaded programs in GDB, see *[https://www.sourceware.org/gdb/current/onlinedocs/gdb/Threads.html](https://www.sourceware.org/gdb/current/onlinedocs/gdb/Threads.html).*
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一些 GDB 基础知识，用于在 GDB 中调试线程程序。有关在 GDB 中调试线程程序的更多信息，请参阅 *[https://www.sourceware.org/gdb/current/onlinedocs/gdb/Threads.html](https://www.sourceware.org/gdb/current/onlinedocs/gdb/Threads.html)。*
- en: 3.6.2 GDB Thread-Specific Commands
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.2 GDB 线程特定命令
- en: 'Enable printing thread start and exit events:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 启用打印线程启动和退出事件：
- en: '[PRE94]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'List all existing threads in the program (the GDB thread number is the first
    value listed, and the thread that hit the breakpoint is denoted with an `*`):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 列出程序中所有现有线程（GDB 线程编号是第一个列出的值，触发断点的线程用 `*` 表示）：
- en: '[PRE95]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Switch to a specific thread’s execution context (for example, to examine its
    stack when executing `where`), specify the thread by its thread ID:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到特定线程的执行上下文（例如，执行 `where` 时检查其堆栈），通过线程 ID 指定线程：
- en: '[PRE96]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Set a breakpoint for just a particular thread. Other threads executing at the
    point in the code where the breakpoint is set will not trigger the breakpoint
    to pause the program and print the GDB prompt:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 为特定线程设置断点。在断点设置的位置，其他线程不会触发断点暂停程序并显示 GDB 提示符：
- en: '[PRE97]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'To apply a specific GDB command to all or to a subset of threads, by adding
    the prefix `thread apply <threadno | all>` to a GDB command, where `threadno`
    refers to the GDB thread ID:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要将特定的 GDB 命令应用于所有或某些线程，可以在 GDB 命令前添加前缀 `thread apply <threadno | all>`，其中 `threadno`
    指的是 GDB 线程 ID：
- en: '[PRE98]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This doesn’t work for every GDB command, setting breakpoints in particular,
    so use this syntax instead for setting thread-specific breakpoints:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不适用于所有 GDB 命令，特别是设置断点时，因此设置线程特定断点时请改用此语法：
- en: '[PRE99]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Upon reaching a breakpoint, by default, GDB pauses all threads until the user
    types `cont`. The user can change the behavior to request that GDB only pause
    the threads that hit a breakpoint, allowing other threads to continue executing.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 到达断点时，默认情况下，GDB 会暂停所有线程，直到用户输入 `cont`。用户可以改变此行为，要求 GDB 只暂停触发断点的线程，从而让其他线程继续执行。
- en: 3.6.3 Examples
  id: totrans-361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.3 示例
- en: We show some GDB commands and output from a GDB run on a multithreaded executable
    compiled from the file `racecond.c`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了一些 GDB 命令及其在一个从文件 `racecond.c` 编译的多线程可执行程序中的 GDB 运行输出。
- en: 'This errant program lacks synchronization around accesses to the shared variable
    `count`. As a result, different runs of the program produce different final values
    for `count`, indicating a race condition. For example, here are two runs of the
    program with five threads that produce different results:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误的程序在访问共享变量 `count` 时缺乏同步。因此，程序的不同运行产生了不同的 `count` 最终值，表明存在竞态条件。例如，以下是程序的两次运行，它们有五个线程并产生了不同的结果：
- en: '[PRE100]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The fix is to put accesses to `count` inside a critical section, using a `pthread_mutex_t`
    variable. If the user was not able to see this fix by examining the C code alone,
    then running in GDB and putting breakpoints around accesses to the `count` variable
    may help the programmer discover the problem.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是将对 `count` 的访问放在临界区内，使用 `pthread_mutex_t` 变量。如果用户仅通过检查 C 代码无法看到此修复，那么在
    GDB 中运行并将断点设置在对 `count` 变量的访问处，可能会帮助程序员发现问题。
- en: 'Here are some example commands from a GDB run of this program:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从此程序的 GDB 运行中提取的一些示例命令：
- en: '[PRE101]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Shown in the example that follows is partial output of a GDB run of the `racecond.c`
    program with three threads (`run 3`), showing examples of GDB thread commands
    in the context of a GDB debugging session. The main thread is always GDB thread
    number 1, and the three spawned threads are GDB threads 2 to 4.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了 `racecond.c` 程序的 GDB 运行的部分输出，程序有三个线程（`run 3`），并展示了在 GDB 调试会话中 GDB 线程命令的示例。主线程始终是
    GDB 线程编号 1，三个派生线程是 GDB 线程 2 到 4。
- en: 'When debugging multithreaded programs, the GDB user must keep track of which
    threads exist when issuing commands. For example, when the breakpoint in `main`
    is hit, only thread 1 (the main thread) exists. As a result, the GDB user must
    wait until threads are created before setting a breakpoint for a specific thread
    (this example shows setting a breakpoint for thread 4 at line 77 in the program).
    In viewing this output, note when breakpoints are set and deleted, and note the
    value of each thread’s local variable `i` when thread contexts are switched with
    GDB’s `thread` command:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试多线程程序时，GDB 用户必须跟踪当前存在哪些线程，然后再执行命令。例如，当 `main` 中的断点被触发时，只有线程 1（主线程）存在。因此，GDB
    用户必须等待线程创建之后，才能为特定线程设置断点（本示例展示了在程序的第 77 行为线程 4 设置断点）。查看此输出时，请注意何时设置和删除断点，并注意每个线程的局部变量
    `i` 的值，当线程上下文通过 GDB 的 `thread` 命令切换时：
- en: '[PRE102]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 3.7 Summary
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7 总结
- en: This chapter concludes our coverage of the C programming language. Compared
    to other high-level programming languages, C is a relatively small programming
    language with a few basic constructs from which a programmer builds their program.
    Because C language abstractions are closer to the underlying machine code executed
    by the computer, a C programmer can write code that runs much more efficiently
    than equivalent code written using the higher-level abstractions provided by other
    programming languages. In particular, a C programmer has much more control over
    how their program uses memory, which can have a significant impact on the program’s
    performance. C is the language of computer systems programming where low-level
    control and efficiency are crucial.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了我们对 C 编程语言的介绍。与其他高级编程语言相比，C 是一种相对较小的编程语言，只有少数几个基本构造，程序员通过这些构造来编写程序。由于 C
    语言的抽象更接近计算机执行的底层机器代码，C 程序员可以编写比使用其他编程语言提供的高级抽象写出的等效代码更加高效的代码。特别是，C 程序员对程序如何使用内存有更多的控制权，这对程序的性能有重要影响。C
    是计算机系统编程的语言，其中低级控制和效率至关重要。
- en: In subsequent chapters we use C examples to illustrate how a computer system
    is designed to run a program.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中，我们将使用 C 语言示例来说明计算机系统如何设计来运行程序。
- en: Notes
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: '[1.](ch03.xhtml#rfn3_1) GDB is available at *[https://www.gnu.org/software/gdb](https://www.gnu.org/software/gdb)*'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[1.](ch03.xhtml#rfn3_1) GDB 可通过 *[https://www.gnu.org/software/gdb](https://www.gnu.org/software/gdb)*
    获得'
- en: '[2.](ch03.xhtml#rfn3_2) Valgrind is available at *[https://valgrind.org/info/tools.html](https://valgrind.org/info/tools.html)*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '[2.](ch03.xhtml#rfn3_2) Valgrind 可以在 *[https://valgrind.org/info/tools.html](https://valgrind.org/info/tools.html)*
    获取。'
- en: '[3.](ch03.xhtml#rfn3_3) The Memcheck tool is available at *[https://valgrind.org/docs/manual/mc-manual.html](https://valgrind.org/docs/manual/mc-manual.html)*'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[3.](ch03.xhtml#rfn3_3) Memcheck 工具可以在 *[https://valgrind.org/docs/manual/mc-manual.html](https://valgrind.org/docs/manual/mc-manual.html)*
    获取。'
- en: '[4.](ch03.xhtml#rfn3_4) *[https://valgrind.org/docs/manual/cg-manual.html](https://valgrind.org/docs/manual/cg-manual.html)*'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[4.](ch03.xhtml#rfn3_4) *[https://valgrind.org/docs/manual/cg-manual.html](https://valgrind.org/docs/manual/cg-manual.html)*'
- en: '[5.](ch03.xhtml#rfn3_5) *[http://valgrind.org/docs/manual/cl-manual.html](http://valgrind.org/docs/manual/cl-manual.html)*'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '[5.](ch03.xhtml#rfn3_5) *[http://valgrind.org/docs/manual/cl-manual.html](http://valgrind.org/docs/manual/cl-manual.html)*'
