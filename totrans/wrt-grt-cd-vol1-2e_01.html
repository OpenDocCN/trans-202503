<html><head></head><body>
<h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_9"/><strong><span class="big">2</span><br/>NUMERIC REPRESENTATION</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/comm1.jpg"/></div>&#13;
<p class="noindents">High-level languages shield programmers from the pain of dealing with low-level numeric representation. Writing great code, however, requires that you understand how computers represent numbers, so that is the focus of this chapter. Once you understand internal numeric representation, you’ll discover efficient ways to implement many algorithms and avoid the pitfalls associated with common programming practices.</p>&#13;
<h3 class="h3" id="sec2_1"><strong>2.1 What Is a Number?</strong></h3>&#13;
<p class="noindent">Having taught assembly language programming for many years, I’ve discovered that most people don’t understand the fundamental difference between a number and the representation of that number. Most of the time, this confusion is harmless. However, many algorithms depend on <span epub:type="pagebreak" id="page_10"/>the internal and external representations we use for numbers to operate correctly and efficiently. If you don’t understand the difference between the abstract concept of a number and the representation of that number, you’ll have trouble understanding, using, or creating such algorithms.</p>&#13;
<p class="indent">A <em><a href="gloss01.xhtml#gloss01_176">number</a></em> is an intangible, abstract concept. It is an intellectual device that we use to denote quantity. Let’s say I told you that a book has one hundred pages. You could touch the pages—they are tangible. You could even count those pages to verify that there are one hundred of them. However, “one hundred” is simply an abstraction I’m applying to the book as a way of describing its size.</p>&#13;
<p class="indent">The important thing to realize is that the following is <em>not</em> one hundred:</p>&#13;
<p class="equation">100</p>&#13;
<p class="indent">This is nothing more than ink on paper forming certain lines and curves (called <em><a href="gloss01.xhtml#gloss01_104">glyphs</a></em>). You might recognize this sequence of symbols as a representation of one hundred, but this is not the actual value 100. It’s just three symbols on this page. It isn’t even the only representation for one hundred—consider the following, which are all different representations of the value 100:</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">100</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Decimal representation</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">C</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Roman numeral representation</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">64<sub>16</sub></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Base-16 (hexadecimal) representation</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1100100<sub>2</sub></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Base-2 (binary) representation</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">144<sub>8</sub></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Base-8 (octal) representation</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">one hundred</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">English representation</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The representation of a number is (generally) some sequence of symbols. For example, the common representation of the value one hundred, “100,” is really a sequence of three numeric digits: the digit 1 followed by the digit 0 followed by a second 0 digit. Each of these digits has some specific meaning, but we could have just as easily used the sequence “64” to represent one hundred. Even the individual digits that make up this representation of 100 are not numbers. They are numeric digits, tools we use to represent numbers, but they are not numbers themselves.</p>&#13;
<p class="indent">Now you might be wondering why you should even care whether a sequence of symbols like “100” is the actual value one hundred or just the representation of it. The reason is that you’ll encounter several different sequences of symbols in a computer program that look like numbers (that is, they look like “100”), and you don’t want to confuse them with actual numeric values. Conversely, there are many different representations for the value one hundred that a computer could use, and it’s important for you to realize that they are equivalent.</p>&#13;
<h3 class="h3" id="sec2_2"><span epub:type="pagebreak" id="page_11"/><strong>2.2 Numbering Systems</strong></h3>&#13;
<p class="noindent">A <em><a href="gloss01.xhtml#gloss01_177">numbering system</a></em> is a mechanism we use to represent numeric values. Today, most people use the <em>decimal</em> (or <em>base-10</em>) numbering system, and most computer systems use the <em>binary</em> (or <em>base-2</em>) numbering system. Confusion between the two can lead to poor coding practices.</p>&#13;
<p class="indent">The Arabs developed the decimal numbering system we commonly use today (this is why the 10 decimal digits are known as <em><a href="gloss01.xhtml#gloss01_13">Arabic numerals</a></em>). The decimal system uses <em><a href="gloss01.xhtml#gloss01_197">positional notation</a></em> to represent values with a small group of different symbols. Positional notation gives meaning not only to the symbol itself, but also to the position of the symbol in the sequence of symbols—a scheme that is far superior to other, nonpositional, representations. To appreciate the difference between a positional system and a nonpositional system, consider the <em>tally-slash</em> representation of the number 25 in <a href="ch02.xhtml#ch02fig01">Figure 2-1</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/02fig01.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig01"/><em>Figure 2-1: Tally-slash representation of 25</em></p>&#13;
<p class="indent">The tally-slash representation uses a sequence of <em>n</em> marks to represent the value <em>n</em>. To make the values easier to read, most people arrange the tally marks in groups of five, as in <a href="ch02.xhtml#ch02fig01">Figure 2-1</a>. The advantage of the tally-slash numbering system is that it’s easy to use for counting objects. However, the notation is bulky, and arithmetic operations are difficult. The biggest problem with the tally-slash representation is the amount of physical space it consumes. To represent the value <em>n</em> requires an amount of space proportional to <em>n</em>. Therefore, for large values of <em>n</em>, this notation becomes unusable.</p>&#13;
<h4 class="h4" id="sec2_2_1"><strong><em>2.2.1 The Decimal Positional Numbering System</em></strong></h4>&#13;
<p class="noindent">The decimal positional numbering system represents numbers using strings of Arabic numerals, optionally including a decimal point to separate whole and fractional portions of the number representation. The position of a digit in the string affects its meaning: each digit to the left of the decimal point represents a value between 0 and 9, multiplied by an increasing power of 10 (see <a href="ch02.xhtml#ch02fig02">Figure 2-2</a>). The symbol immediately to the left of the decimal point in the sequence represents a value between 0 and 9. If there are at least two digits, the second symbol to the left of the decimal point represents a value between 0 and 9 times 10, and so forth. To the right of the decimal point, the values decrease.</p>&#13;
<div class="image"><img alt="image" src="../images/02fig02.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig02"/><em>Figure 2-2: A positional numbering system</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_12"/>The numeric sequence 123.45 represents:</p>&#13;
<p class="equation">(1 × 10<sup>2</sup>) + (2 × 10<sup>1</sup>) + (3 × 10<sup>0</sup>) + (4 × 10<sup>–1</sup>) + (5 × 10<sup>–2</sup>)</p>&#13;
<p class="noindent">or:</p>&#13;
<p class="equation">100 + 20 + 3 + 0.4 + 0.05</p>&#13;
<p class="indent">To understand the power of the base-10 positional numbering system, consider that, compared to the tally-slash system:</p>&#13;
<ul>&#13;
<li class="noindent">It can represent the value 10 in one-third the space.</li>&#13;
<li class="noindent">It can represent the value 100 in about 3 percent of the space.</li>&#13;
<li class="noindent">It can represent the value 1,000 in about 0.3 percent of the space.</li>&#13;
</ul>&#13;
<p class="indent">As the numbers grow larger, the disparity becomes even greater. Because of their compact and easy-to-recognize notation, positional numbering systems are quite popular.</p>&#13;
<h4 class="h4" id="sec2_2_2"><strong><em>2.2.2 Radix (Base) Values</em></strong></h4>&#13;
<p class="noindent">Humans developed the decimal numbering system because it corresponds to the number of fingers (“digits”) on their hands. However, decimal isn’t the only positional numbering system possible; in fact, for most computer-based applications, it isn’t even the best numbering system available. So, let’s take a look at how to represent values in other numbering systems.</p>&#13;
<p class="indent">The decimal positional numbering system uses powers of 10 and 10 unique symbols for each digit position. Because decimal numbers use powers of 10, we call them “base-10” numbers. By substituting a different set of numeric digits and multiplying those digits by powers of some base other than 10, we can devise a different numbering system. The base, or <em><a href="gloss01.xhtml#gloss01_207">radix</a></em>, is the value that we raise to successive powers for each digit to the left of the <em><a href="gloss01.xhtml#gloss01_208">radix point</a></em> (note that the term <em>decimal point</em> applies only to decimal numbers).</p>&#13;
<p class="indent">As an example, we can create a base-8 (<em>octal</em>) numbering system using eight symbols (0–7) and successive powers of 8. Consider the octal number 123<sub>8</sub> (the subscript denotes the base using standard mathematical notation), which is equivalent to 83<sub>10</sub>:</p>&#13;
<p class="equation">1 × 8<sup>2</sup> + 2 × 8<sup>1</sup> + 3 × 8<sup>0</sup></p>&#13;
<p class="noindent">or:</p>&#13;
<p class="equation">64 + 16 + 3</p>&#13;
<p class="indent">To create a base-<em>n</em> numbering system, you need <em>n</em> unique digits. The smallest possible radix is 2 (for this scheme). For bases 2 through 10, the convention is to use the Arabic digits 0 through <em>n</em> – 1 (for a base-<em>n</em> system). For bases greater than 10, the convention is to use the alphabetic digits <em>a</em> through <em>z</em> or <em>A</em> through <em>Z</em> (ignoring case) for digits greater than 9. This scheme supports numbering systems through base 36 (10 numeric digits and 26 alphabetic digits). There’s no agreed-upon convention for symbols beyond the 10 Arabic numeric digits and the 26 alphabetic digits. <span epub:type="pagebreak" id="page_13"/>Throughout this book, we’ll deal with base-2, base-8, and base-16 values because base 2 (binary) is the native representation most computers use, base 8 was popular on older computer systems, and base 16 is more compact than base 2. You’ll find that many programs use these three bases, so it’s important to be familiar with them.</p>&#13;
<h4 class="h4" id="sec2_2_3"><strong><em>2.2.3 The Binary Numbering System</em></strong></h4>&#13;
<p class="noindent">Since you’re reading this book, chances are pretty good that you’re already familiar with the base-2, or binary, numbering system; nevertheless, a quick review is in order. The binary numbering system works just like the decimal numbering system, except binary uses only the digits 0 and 1 (rather than 0–9) and uses powers of 2 (rather than powers of 10).</p>&#13;
<p class="indent">Why even worry about binary? After all, almost every computer language available allows programmers to use decimal notation (automatically converting decimal representation to the internal binary representation). Despite this capability, most modern computer systems talk to I/O devices using binary, and their arithmetic circuitry operates on binary data. Many algorithms depend upon binary representation for correct operation. In order to write great code, then, you’ll need a complete understanding of binary representation.</p>&#13;
<h5 class="h5" id="sec2_2_3_1"><strong>2.2.3.1 Converting Between Decimal and Binary Representation</strong></h5>&#13;
<p class="noindent">To appreciate what the computer does for you, it’s useful to learn how to convert between decimal and binary representations manually.</p>&#13;
<p class="indent">To convert a binary value to decimal, add 2<sup><em>i</em></sup> for each 1 in the binary string, where <em>i</em> is the zero-based position of the binary digit. For example, the binary value 11001010<sub>2</sub> represents:</p>&#13;
<p class="equation">1 × 2<sup>7</sup> + 1 × 2<sup>6</sup> + 0 × 2<sup>5</sup> + 0 × 2<sup>4</sup> + 1 × 2<sup>3</sup> + 0 × 2<sup>2</sup> + 1 × 2<sup>1</sup> + 0 × 2<sup>0</sup></p>&#13;
<p class="noindent">or:</p>&#13;
<p class="equation">128 + 64 + 8 + 2</p>&#13;
<p class="noindent">or:</p>&#13;
<p class="equation">202<sub>10</sub></p>&#13;
<p class="indent">Converting decimal to binary is almost as easy. Here’s an algorithm that converts decimal representation to the corresponding binary representation:</p>&#13;
<ol>&#13;
<li class="noindent">If the number is even, emit a 0. If the number is odd, emit a 1.</li>&#13;
<li class="noindent">Divide the number by 2 and discard any fractional component or remainder.</li>&#13;
<li class="noindent">If the quotient is 0, the algorithm is complete.</li>&#13;
<li class="noindent">If the quotient is not 0 and the number is odd, insert a 1 before the current string. If the quotient is not 0 and the number is even, prefix your binary string with 0.</li>&#13;
<li class="noindent">Go back to step 2 and repeat.</li></ol>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_14"/>This example converts 202 to binary:</p>&#13;
<ol>&#13;
<li class="noindent">202 is even, so emit a 0 and divide by 2 (101): 0</li>&#13;
<li class="noindent">101 is odd, so emit a 1 and divide by 2 (50): 10</li>&#13;
<li class="noindent">50 is even, so emit a 0 and divide by 2 (25): 010</li>&#13;
<li class="noindent">25 is odd, so emit a 1 and divide by 2 (12): 1010</li>&#13;
<li class="noindent">12 is even, so emit a 0 and divide by 2 (6): 01010</li>&#13;
<li class="noindent">6 is even, so emit a 0 and divide by 2 (3): 001010</li>&#13;
<li class="noindent">3 is odd, so emit a 1 and divide by 2 (1): 1001010</li>&#13;
<li class="noindent">1 is odd, so emit a 2 and divide by 2 (0): 11001010</li>&#13;
<li class="noindent">The result is 0, so the algorithm is complete, producing 11001010.</li></ol>&#13;
<h5 class="h5" id="sec2_2_3_2"><strong>2.2.3.2 Making Binary Numbers Easier to Read</strong></h5>&#13;
<p class="noindent">As you can tell by the equivalent representations 202<sub>10</sub> and 11001010<sub>2</sub>, binary representation is not as compact as decimal representation. We need some way to make the digits, or <em><a href="gloss01.xhtml#gloss01_31">bits</a></em>, in binary numbers less bulky and easier to read.</p>&#13;
<p class="indent">In the United States, most people separate every three digits with a comma to make larger numbers easier to read. For example, 1,023,435,208 is much easier to read and comprehend than 1023435208. This book will adopt a similar convention for binary numbers; each group of 4 binary bits will be separated with an underscore. For example, the binary value 1010111110110010<sub>2</sub> will be written as 1010_1111_1011_0010<sub>2</sub>.</p>&#13;
<h5 class="h5" id="sec2_2_3_3"><strong>2.2.3.3 Representing Binary Values in Programming Languages</strong></h5>&#13;
<p class="noindent">Thus far, this chapter has used the subscript notation embraced by mathematicians to denote binary values (the lack of a subscript indicates the decimal base). Subscripts are not generally recognized by program text editors or programming language compilers, however, so we need some other way to represent various bases within a standard ASCII text file.</p>&#13;
<p class="indent">Generally, only assembly language compilers (“assemblers”) allow the use of literal binary constants in a program.<sup><a href="footnotes.xhtml#fn2_1a" id="fn2_1">1</a></sup> Because assemblers vary widely, there are many different ways to represent binary literal constants in an assembly language program. This book presents examples using MASM and HLA, so it makes sense to adopt their conventions.</p>&#13;
<p class="indent">MASM represents binary values as a sequence of binary digits (<code>0</code> and <code>1</code>) ending with a <code>b</code> or <code>B</code>. The binary representation for 9 would be <code>1001b</code> in a MASM source file.</p>&#13;
<p class="indent">HLA prefixes binary values with the percent symbol (<code>%</code>). To make binary numbers more readable, HLA also allows you to insert underscores within binary strings like so:</p>&#13;
<pre>%11_1011_0010_1101</pre>&#13;
<h4 class="h4" id="sec2_2_4"><span epub:type="pagebreak" id="page_15"/><strong><em>2.2.4 The Hexadecimal Numbering System</em></strong></h4>&#13;
<p class="noindent">As noted earlier, binary number representation is verbose. Hexadecimal representation offers two great features: it’s very compact, and it’s easy to convert between binary and hexadecimal. Therefore, software engineers generally use hexadecimal representation rather than binary to make their programs more readable.</p>&#13;
<p class="indent">Because hexadecimal representation is base 16, each digit to the left of the hexadecimal point represents some value times a successive power of 16. For example, the number 1234<sub>16</sub> is equal to:</p>&#13;
<p class="equation">1 × 16<sup>3</sup> + 2 × 16<sup>2</sup> + 3 × 16<sup>1</sup> + 4 × 16<sup>0</sup></p>&#13;
<p class="noindent">or:</p>&#13;
<p class="equation">4096 + 512 + 48 + 4</p>&#13;
<p class="noindent">or:</p>&#13;
<p class="equation">4660<sub>10</sub></p>&#13;
<p class="indent">Hexadecimal representation uses the letters <em>A</em> through <em>F</em> for the additional six digits it requires (above the 10 standard decimal digits, 0–9). The following are all examples of valid hexadecimal numbers:</p>&#13;
<p class="equation">234<sub>16</sub>   DEAD<sub>16</sub>   BEEF<sub>16</sub>   0AFB<sub>16</sub>   FEED<sub>16</sub>   DEAF<sub>16</sub></p>&#13;
<h5 class="h5" id="sec2_2_4_1"><strong>2.2.4.1 Representing Hexadecimal Values in Programming Languages</strong></h5>&#13;
<p class="noindent">One problem with hexadecimal representation is that it’s difficult to differentiate hexadecimal values like “DEAD” from standard program identifiers. Therefore, most programming languages use a special prefix or suffix character to denote hexadecimal values. Here’s how you specify literal hexadecimal constants in several popular languages:</p>&#13;
<ul>&#13;
<li class="noindent">The C, C++, C#, Java, Swift, and other C-derivative programming languages use the prefix <code>0x</code>. You’d use the character sequence <code>0xdead</code> for the hexadecimal value DEAD<sub>16</sub>.</li>&#13;
<li class="noindent">The MASM assembler uses an <code>h</code> or <code>H</code> suffix. Because this doesn’t completely resolve the ambiguity between certain identifiers and literal hexadecimal constants (for example, “deadh” still looks like an identifier to MASM), it also requires that a hexadecimal value begin with a numeric digit. So, you would add <code>0</code> to the beginning of the value (because a prefix of 0 does not alter the value of a numeric representation) to get <code>0deadh</code>, which unambiguously represents DEAD<sub>16</sub>.</li>&#13;
<li class="noindent">Visual Basic uses the <code>&amp;H</code> or <code>&amp;h</code> prefix. Continuing with the current example, you’d use <code>&amp;Hdead</code> to represent DEAD<sub>16</sub> in Visual Basic.</li>&#13;
<li class="noindent">Pascal (Delphi) uses the prefix <code>$</code>. So, you’d use <code>$dead</code> to represent the current example in Delphi/Free Pascal.</li>&#13;
<li class="noindent">HLA also uses the prefix <code>$</code>. As with binary numbers, it also allows you to insert underscores into a hexadecimal number to make it easier to read (for example, <code>$FDEC_A012</code>).</li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_16"/>In general, this book will use the HLA/Delphi/Free Pascal format except in examples specific to other programming languages. Because there are several C/C++ examples in this book, you’ll frequently see the C/C++ notation as well.</p>&#13;
<h5 class="h5" id="sec2_2_4_2"><strong>2.2.4.2 Converting Between Hexadecimal and Binary Representations</strong></h5>&#13;
<p class="noindent">Another reason hexadecimal notation is popular is because it’s easy to convert between the binary and hexadecimal representations. By memorizing the few simple rules shown in <a href="ch02.xhtml#ch02tab01">Table 2-1</a>, you can mentally perform this conversion.</p>&#13;
<p class="tabcap"><a id="ch02tab01"/><strong>Table 2-1:</strong> Binary/Hexadecimal Conversion Chart</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Binary</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Hexadecimal</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%0000</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%0001</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$1</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%0010</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$2</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%0011</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$3</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%0100</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$4</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%0101</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$5</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%0110</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$6</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%0111</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$7</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%1000</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$8</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%1001</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$9</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%1010</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$A</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%1011</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$B</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%1100</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$C</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%1101</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$D</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%1110</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$E</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%1111</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$F</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">To convert the hexadecimal representation of a number into binary, substitute the corresponding 4 bits for each hexadecimal digit. For example, to convert <code>$ABCD</code> into the binary form <code>%1010_1011_1100_1101</code>, convert each hexadecimal digit according to the values in <a href="ch02.xhtml#ch02tab01">Table 2-1</a>:</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>A</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>B</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>C</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>D</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Hexadecimal</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>1010</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>1011</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>1100</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>1101</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Binary</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Converting the binary representation of a number into hexadecimal is almost as easy. First, pad the binary number with 0s to make sure it is a multiple of 4 bits long. For example, given the binary number 1011001010, add two 0 bits to the left of the number to make it 12 bits without changing its value: 001011001010. Next, separate the binary value into groups of 4 bits: 0010_1100_1010. Finally, look up these binary values in <a href="ch02.xhtml#ch02tab01">Table 2-1</a> and <span epub:type="pagebreak" id="page_17"/>substitute the appropriate hexadecimal digits: <code>$2CA</code>. As you can see, this is much simpler than converting between decimal and binary or between decimal and hexadecimal.</p>&#13;
<h4 class="h4" id="sec2_2_5"><strong><em>2.2.5 The Octal Numbering System</em></strong></h4>&#13;
<p class="noindent">Octal (base-8) representation was common in early computer systems, so you might still see it in use now and then. Octal is great for 12-bit and 36-bit computer systems (or any other size that is a multiple of 3), but not particularly for computer systems whose bit size is a power of 2 (8-, 16-, 32-, and 64-bit computer systems). Nevertheless, some programming languages allow you to specify numeric values in octal notation, and you can still find some older Unix applications that use it.</p>&#13;
<h5 class="h5" id="sec2_2_5_1"><strong>2.2.5.1 Representing Octal Values in Programming Languages</strong></h5>&#13;
<p class="noindent">The C programming language (and derivatives like C++ and Java), MASM, Swift, and Visual Basic support octal representation. You should be aware of the notation they use for octal numbers in case you come across it in programs written in these languages.</p>&#13;
<ul>&#13;
<li class="noindent">In C, you specify the octal base by prefixing a numeric string with a <code>0</code> (zero). For example, <code>0123</code> is equivalent to the decimal value 83<sub>10</sub> and definitely <em>not</em> equivalent to the decimal value 123<sub>10</sub>.</li>&#13;
<li class="noindent">MASM uses a <code>Q</code> or <code>q</code> suffix. (Microsoft/Intel probably chose <em>Q</em> because it looks like the letter <em>O</em> but isn’t likely to be confused with a zero.)</li>&#13;
<li class="noindent">Swift uses a <code>0o</code> prefix. For example, <code>0o14</code> represents the decimal value 12<sub>10</sub>.</li>&#13;
<li class="noindent">Visual Basic uses the prefix <code>&amp;O</code> (that’s the letter <em>O</em>, not a zero). For example, you’d use <code>&amp;O123</code> to represent the decimal value 83<sub>10</sub>.</li>&#13;
</ul>&#13;
<h5 class="h5" id="sec2_2_5_2"><strong>2.2.5.2 Converting Between Octal and Binary Representation</strong></h5>&#13;
<p class="noindent">Converting between binary and octal is similar to converting between binary and hexadecimal, except that you work in groups of 3 bits rather than 4. See <a href="ch02.xhtml#ch02tab02">Table 2-2</a> for the list of binary and octal equivalent representations.</p>&#13;
<p class="tabcap"><a id="ch02tab02"/><strong>Table 2-2:</strong> Binary/Octal Conversion Chart</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Binary</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Octal</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%000</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%001</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>1</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%010</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>2</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%011</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>3</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%100</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>4</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%101</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>5</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%110</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>6</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%111</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>7</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_18"/>To convert octal into binary, replace each octal digit in the number with the corresponding 3 bits from <a href="ch02.xhtml#ch02tab02">Table 2-2</a>. For example, when you convert <code>123q</code> into a binary value, the final result is <code>%0_0101_0011</code>:</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>1</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>2</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>3</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>001</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>010</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>011</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">To convert a binary number into octal, you break up the binary string into groups of 3 bits (padding with 0s, as necessary) and then replace each triad with the corresponding octal digit from <a href="ch02.xhtml#ch02tab02">Table 2-2</a>.</p>&#13;
<p class="indent">To convert an octal value to hexadecimal notation, convert the octal number to binary and then convert the binary value to hexadecimal.</p>&#13;
<h3 class="h3" id="sec2_3"><strong>2.3 Numeric/String Conversions</strong></h3>&#13;
<p class="noindent">In this section, we’ll explore conversions from string to numeric form and vice versa. Because most programming languages (or their libraries) perform these conversions automatically, beginning programmers are often unaware that they’re even taking place. For example, consider how easy it is to convert a string to numeric form in various languages:</p>&#13;
<pre>cin &gt;&gt; i;                      // C++<br/>&#13;
readln( i );                   // Pascal<br/>&#13;
let j = Int(readLine() ?? "")! // Swift<br/>&#13;
input i                        // BASIC<br/>&#13;
stdin.get( i );                // HLA</pre>&#13;
<p class="indent">In each of these statements, the variable <code>i</code> can hold some integer number. The input from the user’s console, however, is a string of characters. The programming language’s runtime library is responsible for converting that string of characters to the internal binary form the CPU requires. Note that Swift only allows you to read a string from the standard input; you must explicitly convert that string to an integer using the <code>Int()</code> constructor/type conversion function.</p>&#13;
<p class="indent">Unfortunately, if you have no idea of the cost of these statements, you won’t realize how they can impact your program when performance is critical. It’s important to understand the underlying work involved in the conversion algorithms so you won’t frivolously use statements like these.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For simplicity’s sake, we’ll discuss unsigned integer values and ignore the possibility of illegal characters and numeric overflow. Therefore, the following algorithms slightly understate the actual work involved.</em></p>&#13;
</div>&#13;
<p class="indent">Use this algorithm to convert a string of decimal digits to an integer value:</p>&#13;
<ol>&#13;
<li class="noindent">Initialize a variable with <code>0</code>; this will hold the final value.</li>&#13;
<li class="noindent">If there are no more digits in the string, then the algorithm is complete, and the variable holds the numeric value.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_19"/>Fetch the next digit (moving from left to right) from the string and convert it from ASCII to an integer.</li>&#13;
<li class="noindent">Multiply the variable by 10, and then add in the digit fetched in step 3.</li>&#13;
<li class="noindent">Return to step 2 and repeat.</li></ol>&#13;
<p class="indent">Converting an integer value to a string of characters takes even more effort:</p>&#13;
<ol>&#13;
<li class="noindent">Initialize a string to the empty string.</li>&#13;
<li class="noindent">If the integer value is 0, output a <code>0</code>, and the algorithm is complete.</li>&#13;
<li class="noindent">Divide the current integer value by 10, computing the remainder and quotient.</li>&#13;
<li class="noindent">Convert the remainder (always in the range 0..9<sup><a href="footnotes.xhtml#fn2_2a" id="fn2_2">2</a></sup>) to a character, and insert the character at the beginning of the string.</li>&#13;
<li class="noindent">If the quotient is not 0, make it the new value and repeat steps 3–5.</li>&#13;
<li class="noindent">Output the characters in the string.</li></ol>&#13;
<p class="indent">The particulars of these algorithms are not important. What <em>is</em> important is that these steps execute once for each output character and division is very slow. So, a simple statement like one of the following can hide a fair amount of work from the programmer:</p>&#13;
<pre>printf( "%d", i );    // C<br/>&#13;
cout &lt;&lt; i;            // C++<br/>&#13;
print i               // BASIC<br/>&#13;
write( i );           // Pascal<br/>&#13;
print( i )            // Swift<br/>&#13;
stdout.put( i );      // HLA</pre>&#13;
<p class="indent">To write great code, you don’t need to avoid using numeric/string conversions altogether; however, a great programmer will take care to use them only as necessary.</p>&#13;
<p class="indent">Remember that these algorithms are valid only for unsigned integers. Signed integers require a little more effort to process (though the extra work is almost negligible). Floating-point values, however, are far more difficult to convert between string and numeric form, so keep that in mind when writing code that uses floating-point arithmetic.</p>&#13;
<h3 class="h3" id="sec2_4"><strong>2.4 Internal Numeric Representation</strong></h3>&#13;
<p class="noindent">Most modern computer systems use an internal binary format to represent values and other objects. However, most systems can only efficiently represent binary values of a given size. In order to write great code, you need to make sure that your programs use data objects that the machine <span epub:type="pagebreak" id="page_20"/>can represent efficiently. This section will describe how computers physically represent values so you can design your programs accordingly.</p>&#13;
<h4 class="h4" id="sec2_4_1"><strong><em>2.4.1 Bits</em></strong></h4>&#13;
<p class="noindent">The smallest unit of data on a binary computer is a single bit. Because a bit can represent only two different values (typically <code>0</code> or <code>1</code>), you might assume that you can’t use it for much. But in fact, there’s an infinite number of two-item combinations you can represent with a single bit. Here are some examples (with arbitrary binary encodings I’ve created):</p>&#13;
<ul>&#13;
<li class="noindent">Zero (<code>0</code>) or one (<code>1</code>)</li>&#13;
<li class="noindent">False (<code>0</code>) or true (<code>1</code>)</li>&#13;
<li class="noindent">Off (<code>0</code>) or on (<code>1</code>)</li>&#13;
<li class="noindent">Male (<code>0</code>) or female (<code>1</code>)</li>&#13;
<li class="noindent">Wrong (<code>0</code>) or right (<code>1</code>)</li>&#13;
</ul>&#13;
<p class="indent">You’re not limited to representing binary data types, either (that is, those objects that have only two distinct values). You could also use a single bit to represent any two distinct items:</p>&#13;
<ul>&#13;
<li class="noindent">The numbers 723 (<code>0</code>) and 1,245 (<code>1</code>)</li>&#13;
<li class="noindent">The colors red (<code>0</code>) and blue (<code>1</code>)</li>&#13;
</ul>&#13;
<p class="indent">You could even represent two unrelated objects with a single bit. For example, you could use the bit value <code>0</code> to represent the color red and the bit value <code>1</code> to represent the number 3,256. You can represent <em>any</em> two different values with a single bit—but <em>only</em> two different values. Therefore, individual bits aren’t sufficient for most computational needs. To overcome the limitations of a single bit, we create <em><a href="gloss01.xhtml#gloss01_32">bit strings</a></em> from a sequence of multiple bits.</p>&#13;
<h4 class="h4" id="sec2_4_2"><strong><em>2.4.2 Bit Strings</em></strong></h4>&#13;
<p class="noindent">By combining bits into a sequence, we can form binary representations that are equivalent to other representations of numbers, like hexadecimal and octal. Most computer systems don’t let you combine an arbitrary number of bits, so you have to work with bit strings of certain fixed lengths.</p>&#13;
<p class="indent">A <em><a href="gloss01.xhtml#gloss01_172">nibble</a></em> is a collection of 4 bits. Most computer systems don’t provide efficient access to nibbles in memory. Notably, it takes exactly 1 nibble to represent a single hexadecimal digit.</p>&#13;
<p class="indent">A <em><a href="gloss01.xhtml#gloss01_39">byte</a></em> is 8 bits and is the smallest addressable data item on many CPUs; that is, the CPU can efficiently retrieve data in groups of 8 bits from memory. For this reason, the smallest data type that many languages support consumes 1 byte of memory (regardless of the actual number of bits the data type requires).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_21"/>Because the byte is the smallest unit of storage on most machines, and many languages use bytes to represent objects that require fewer than 8 bits, we need some way of denoting individual bits within a byte. To describe the bits within a byte, we’ll use <em>bit numbers</em>. As <a href="ch02.xhtml#ch02fig03">Figure 2-3</a> shows, bit 0 is the <em><a href="gloss01.xhtml#gloss01_138">low-order (LO)</a></em>, or <em>least significant</em>, bit, and bit 7 is the <em>high-order (HO)</em>, or <em>most significant</em>, bit of the byte. We’ll refer to all other bits by their number.</p>&#13;
<div class="image"><img alt="image" src="../images/02fig03.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig03"/><em>Figure 2-3: Bit numbering in a byte</em></p>&#13;
<p class="indent">A <em>word</em> is defined differently depending on the CPU: it may be a 16-bit, 32-bit, or 64-bit object. This book adopts the 80x86 terminology and defines a word as a collection of 16 bits. As with bytes, we’ll use bit numbers for a word, starting with bit number 0 for the LO bit and working our way up to bit 15, the HO bit (see <a href="ch02.xhtml#ch02fig04">Figure 2-4</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/02fig04.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig04"/><em>Figure 2-4: Bit numbers in a word</em></p>&#13;
<p class="indent">Notice that a word contains exactly 2 bytes. Bits 0 through 7 form the LO byte, and bits 8 through 15 form the HO byte (see <a href="ch02.xhtml#ch02fig05">Figure 2-5</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/02fig05.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig05"/><em>Figure 2-5: The 2 bytes in a word</em></p>&#13;
<p class="indent">A <em><a href="gloss01.xhtml#gloss01_80">double word</a></em> (or <em><a href="gloss01.xhtml#gloss01_83">dword</a></em>) is exactly what its name implies—a pair of words. Therefore, a double-word quantity is 32 bits long, as shown in <a href="ch02.xhtml#ch02fig06">Figure 2-6</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/02fig06.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig06"/><em>Figure 2-6: Bit layout in a double word</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_22"/><a href="ch02.xhtml#ch02fig07">Figure 2-7</a> shows that a double word comprises 2 words or 4 bytes.</p>&#13;
<div class="image"><img alt="image" src="../images/02fig07.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig07"/><em>Figure 2-7: Bytes and words in a double word</em></p>&#13;
<p class="indent">As noted, most CPUs efficiently handle objects up to a certain size (typically 32 or 64 bits on contemporary systems). That doesn’t mean you can’t work with larger objects, only that it’s less efficient to do so. You typically won’t see programs handling numeric objects much larger than about 128 or 256 bits. Some programming languages make 64-bit integers available, and most languages support 64-bit floating-point values, so for these data types we’ll use the term <em><a href="gloss01.xhtml#gloss01_206">quad word</a></em>. Finally, we’ll use <em><a href="gloss01.xhtml#gloss01_139">long word</a></em> to describe 128-bit values; although few languages today support them,<sup><a href="footnotes.xhtml#fn2_3a" id="fn2_3">3</a></sup> this gives us some room to grow.</p>&#13;
<p class="indent">We can break down quad words into 2 double words, 4 words, 8 bytes, or 16 nibbles. Likewise, we can break down long words into 2 quad words, 4 double words, 8 words, or 16 bytes.</p>&#13;
<p class="indent">Intel 80x86 platforms also support an 80-bit type that Intel calls a <em><a href="gloss01.xhtml#gloss01_244">tbyte</a></em> (short for “ten byte”) object. The 80x86 CPU family uses tbyte variables to hold extended precision floating-point values and certain binary-coded decimal (BCD) values.</p>&#13;
<p class="indent">In general, with an <em>n</em>-bit string you can represent up to 2<sup><em>n</em></sup> different values. <a href="ch02.xhtml#ch02tab03">Table 2-3</a> shows the number of possible objects you can represent with nibbles, bytes, words, double words, quad words, and long words.</p>&#13;
<p class="tabcap"><a id="ch02tab03"/><strong>Table 2-3:</strong> Number of Values Representable with Bit Strings</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Size of bit string (in bits)</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Number of possible combinations (2<sup><em>n</em></sup>)</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">4</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">16</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">8</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">256</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">16</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">65,536</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">32</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">4,294,967,296</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">64</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">18,446,744,073,709,551,616</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">128</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">340,282,366,920,938,463,463,374,607,431,768,211,456</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="sec2_5"><span epub:type="pagebreak" id="page_23"/><strong>2.5 Signed and Unsigned Numbers</strong></h3>&#13;
<p class="noindent">The binary number 0…00000<sup><a href="footnotes.xhtml#fn2_4a" id="fn2_4">4</a></sup> represents 0; 0…00001 represents 1; 0…00010 represents 2; and so on toward infinity. But what about negative numbers? To represent signed values, most computer systems use the <em>two’s complement</em> numbering system. The representation of signed numbers places some fundamental restrictions on them, so it’s important that you understand how signed and unsigned numbers are represented differently in a computer system in order to use them efficiently.</p>&#13;
<p class="indent">With <em>n</em> bits, we can represent only 2<sup><em>n</em></sup> different objects. Because negative values are objects in their own right, we’ll have to divide these 2<sup><em>n</em></sup> combinations between negative and non-negative values. So, for example, a byte can represent the negative values –128 through –1 and the non-negative values 0 to 127. With a 16-bit word, we can represent signed values in the range –32,768 to +32,767. With a 32-bit double word, we can represent values in the range –2,147,483,648 to +2,147,483,647. In general, with <em>n</em> bits we can represent the signed values in the range –2<sup><em>n–</em></sup><sup>1</sup> to +2<sup><em>n–</em></sup><sup>1</sup> – 1.</p>&#13;
<p class="indent">The two’s complement system uses the HO bit as a <em>sign bit</em>. If the HO bit is <code>0</code>, the number is non-negative and has the usual binary encoding; if the HO bit is <code>1</code>, the number is negative and uses the two’s complement encoding. Here are some examples using 16-bit numbers:</p>&#13;
<ul>&#13;
<li class="noindent"><code>$8000</code> (<code>%1000_0000_0000_0000</code>) is negative because the HO bit is <code>1</code>.</li>&#13;
<li class="noindent"><code>$100</code> (<code>%0000_0001_0000_0000</code>) is non-negative because the HO bit is <code>0</code>.</li>&#13;
<li class="noindent"><code>$7FFF</code> (<code>%0111_1111_1111_1111</code>) is non-negative.</li>&#13;
<li class="noindent"><code>$FFFF</code> (<code>%1111_1111_1111_1111</code>) is negative.</li>&#13;
<li class="noindent"><code>$FFF</code> (<code>%0000_1111_1111_1111</code>) is non-negative.</li>&#13;
</ul>&#13;
<p class="indent">To negate a number, you can use the two’s complement operation as follows:</p>&#13;
<ol>&#13;
<li class="noindent">Invert all the bits in the number; that is, change all the <code>0</code>s to <code>1</code>s and vice versa.</li>&#13;
<li class="noindent">Add <code>1</code> to the inverted result (ignoring any overflow).</li></ol>&#13;
<p class="indent">If the result is negative (has its HO bit set), then this is the two’s complement form of the non-negative value.</p>&#13;
<p class="indent">For example, these are the steps to compute the 8-bit equivalent of the decimal value –5:</p>&#13;
<ol>&#13;
<li class="noindent"><code>%0000_0101</code>   5 (in binary).</li>&#13;
<li class="noindent"><code>%1111_1010</code>   Invert all the bits.</li>&#13;
<li class="noindent"><code>%1111_1011</code>   Add 1 to obtain –5 (in two’s complement form).</li></ol>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_24"/>If we take –5 and negate it, the result is 5 (<code>%0000_0101</code>), just as we expect:</p>&#13;
<ol>&#13;
<li class="noindent"><code>%1111_1011</code>   Two’s complement for –5.</li>&#13;
<li class="noindent"><code>%0000_0100</code>   Invert all the bits.</li>&#13;
<li class="noindent"><code>%0000_0101</code>   Add 1 to obtain 5 (in binary).</li></ol>&#13;
<p class="indent">Let’s look at some 16-bit examples and their negations.</p>&#13;
<p class="indent">First, negate 32,767 (<code>$7FFF</code>):</p>&#13;
<ol>&#13;
<li class="noindent"><code>%0111_1111_1111_1111</code>   +32,767, the largest 16-bit positive number.</li>&#13;
<li class="noindent"><code>%1000_0000_0000_0000</code>   Invert all the bits (<code>8000h</code>).</li>&#13;
<li class="noindent"><code>%1000_0000_0000_0001</code>   Add 1 (<code>8001h</code>, or –32,767).</li></ol>&#13;
<p class="indent">Now negate 16,384 (<code>$4000</code>):</p>&#13;
<ol>&#13;
<li class="noindent"><code>%0100_0000_0000_0000</code>   16,384.</li>&#13;
<li class="noindent"><code>%1011_1111_1111_1111</code>   Invert all the bits (<code>$BFFF</code>).</li>&#13;
<li class="noindent"><code>%1100_0000_0000_0000</code>   Add 1 (<code>$C000</code> or –16,384).</li></ol>&#13;
<p class="indent">And now negate –32,768 (<code>$8000</code>):</p>&#13;
<ol>&#13;
<li class="noindent"><code>%1000_0000_0000_0000</code>   –32,768, the smallest 16-bit negative number.</li>&#13;
<li class="noindent"><code>%0111_1111_1111_1111</code>   Invert all the bits (<code>$7FFF</code>).</li>&#13;
<li class="noindent"><code>%1000_0000_0000_0000</code>   Add 1 (<code>$8000</code> or –32,768).</li></ol>&#13;
<p class="indent"><code>$8000</code> inverted becomes <code>$7FFF</code>, and after adding 1 we obtain <code>$8000</code>! Wait, what’s going on here: –(–32,768) is –32,768? Of course not. However, the 16-bit two’s complement numbering system cannot represent the value +32,768. In general, you cannot negate the smallest negative value in the two’s complement numbering system.</p>&#13;
<h3 class="h3" id="sec2_6"><strong>2.6 Useful Properties of Binary Numbers</strong></h3>&#13;
<p class="noindent">Here are some properties of binary values that you might find useful in your programs:</p>&#13;
<ul>&#13;
<li class="noindent">If bit position 0 of a binary (integer) value contains <code>1</code>, the number is an odd number; if this bit contains <code>0</code>, then the number is even.</li>&#13;
<li class="noindent">If the LO <em>n</em> bits of a binary number all contain <code>0</code>, then the number is evenly divisible by 2<sup><em>n</em></sup>.</li>&#13;
<li class="noindent">If a binary value contains a <code>1</code> in bit position <em>n</em>, and <code>0</code>s everywhere else, then that number is equal to 2<sup><em>n</em></sup>.</li>&#13;
<li class="noindent">If a binary value contains all <code>1</code>s from bit position 0 up to (but not including) bit position <em>n</em>, and all other bits are <code>0</code>, then that value is equal to 2<sup><em>n</em></sup> – 1.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_25"/>Shifting all the bits in a number to the left by one position multiplies the binary value by 2.</li>&#13;
<li class="noindent">Shifting all the bits of an unsigned binary number to the right by one position effectively divides that number by 2 (this does not apply to signed integer values). Odd numbers are rounded down.</li>&#13;
<li class="noindent">Multiplying two <em>n</em>-bit binary values together may require as many as 2 × <em>n</em> bits to hold the result.</li>&#13;
<li class="noindent">Adding or subtracting two <em>n</em>-bit binary values never requires more than <em>n</em> + 1 bits to hold the result.</li>&#13;
<li class="noindent">Inverting all the bits in a binary number (that is, changing all the <code>0</code>s to <code>1</code>s and vice versa) is the same thing as negating (changing the sign) of the value and then subtracting 1 from the result.</li>&#13;
<li class="noindent"><em>Incrementing</em> (adding 1 to) the largest unsigned binary value for a given number of bits always produces a value of <code>0</code>.</li>&#13;
<li class="noindent"><em>Decrementing</em> (subtracting 1 from) 0 always produces the largest unsigned binary value for a given number of bits.</li>&#13;
<li class="noindent">An <em>n</em>-bit value provides 2<sup><em>n</em></sup> unique combinations of those bits.</li>&#13;
<li class="noindent">The value 2<sup><em>n</em></sup>–1 contains <em>n</em> bits, each containing the value <code>1</code>.</li>&#13;
</ul>&#13;
<p class="indent">It’s a good idea to memorize all the powers of 2 from 2<sup>0</sup> through 2<sup>16</sup> (see <a href="ch02.xhtml#ch02tab04">Table 2-4</a>), as these values come up in programs all the time.</p>&#13;
<p class="tabcap"><a id="ch02tab04"/><strong>Table 2-4:</strong> Powers of 2</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><em>n</em></strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th">2<strong><em>n</em></strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">2</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">3</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">8</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">4</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">16</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">5</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">32</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">6</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">64</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">7</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">128</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">8</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">256</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">9</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">512</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">10</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">1,024</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">11</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">2,048</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">12</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">4,096</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">13</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">8,192</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">14</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">16,384</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">15</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">32,768</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">16</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">65,536</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="sec2_7"><span epub:type="pagebreak" id="page_26"/><strong>2.7 Sign Extension, Zero Extension, and Contraction</strong></h3>&#13;
<p class="noindent">With the two’s complement system, a single negative value is represented differently depending on the size of the representation. An 8-bit signed value must be converted for use in an expression involving a 16-bit number. This conversion and its converse—converting a 16-bit value to 8 bits—are the <em><a href="gloss01.xhtml#gloss01_230">sign extension</a></em> and <em>contraction</em> operations, respectively.</p>&#13;
<p class="indent">Consider the value –64. The 8-bit two’s complement value for this number is <code>$C0</code>. The 16-bit equivalent is <code>$FFC0</code>. Clearly, these are not the same bit pattern. Now consider the value +64. The 8- and 16-bit versions of this value are <code>$40</code> and <code>$0040</code>, respectively. We extend the size of negative values differently than we extend the size of non-negative values.</p>&#13;
<p class="indent">To <em>sign-extend</em> a value, copy the sign bit into the additional HO bits in the new format. For example, to sign-extend an 8-bit number to a 16-bit number, copy bit 7 of the 8-bit number into bits 8 through 15 of the 16-bit number. To sign-extend a 16-bit number to a double word, copy bit 15 into bits 16 through 31 of the double word.</p>&#13;
<p class="indent">When adding a byte quantity to a word quantity, you need to sign-extend the byte to 16 bits before adding the two numbers. Other operations may require a sign extension to 32 bits.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch02tab05">Table 2-5</a> provides several examples of sign extension.</p>&#13;
<p class="tabcap"><a id="ch02tab05"/><strong>Table 2-5:</strong> Sign Extension Examples</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>8 bits</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>16 bits</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>32 bits</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Binary (two’s complement)</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$80</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$FF80</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$FFFF_FF80</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%1111_1111_1111_1111_1111_1111_1000_0000</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$28</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$0028</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$0000_0028</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%0000_0000_0000_0000_0000_0000_0010_1000</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$9A</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$FF9A</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$FFFF_FF9A</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%1111_1111_1111_1111_1111_1111_1001_1010</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$7F</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$007F</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$0000_007F</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%0000_0000_0000_0000_0000_0000_0111_1111</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">n/a</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$1020</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$0000_1020</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%0000_0000_0000_0000_0001_0000_0010_0000</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">n/a</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$8086</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$FFFF_8086</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%1111_1111_1111_1111_1000_0000_1000_0110</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><em><a href="gloss01.xhtml#gloss01_270">Zero extension</a></em> converts small unsigned values to larger unsigned values. Zero extension is very easy—just store <code>0</code>s in the HO byte(s) of the larger operand. For example, to zero-extend the 8-bit value <code>$82</code> to 16 bits, you insert a <code>0</code> for the HO byte, yielding <code>$0082</code>.</p>&#13;
<p class="indent">Further examples are listed in <a href="ch02.xhtml#ch02tab06">Table 2-6</a>.</p>&#13;
<p class="tabcap"><a id="ch02tab06"/><strong>Table 2-6:</strong> Zero Extension Examples</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>8 bits</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>16 bits</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>32 bits</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Binary</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$80</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$0080</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$0000_0080</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%0000_0000_0000_0000_0000_0000_1000_0000</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$28</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$0028</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$0000_0028</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%0000_0000_0000_0000_0000_0000_0010_1000</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$9A</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$009A</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$0000_009A</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%0000_0000_0000_0000_0000_0000_1001_1010</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$7F</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$007F</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$0000_007F</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%0000_0000_0000_0000_0000_0000_0111_1111</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">n/a</p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$1020</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>$0000_1020</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%0000_0000_0000_0000_0001_0000_0010_0000</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">n/a</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$8086</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>$0000_8086</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%0000_0000_0000_0000_1000_0000_1000_0110</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_27"/>Many high-level language compilers automatically handle sign and zero extension. The following examples in C demonstrate how this works:</p>&#13;
<pre>signed char sbyte;   // Chars in C are byte values.<br/>&#13;
short int sword;     // Short integers in C are *usually* 16-bit values.<br/>&#13;
long int sdword;     // Long integers in C are *usually* 32-bit values.<br/>&#13;
 . . .<br/>&#13;
sword = sbyte;       // Automatically sign-extends the 8-bit value to 16 bits.<br/>&#13;
sdword = sbyte;      // Automatically sign-extends the 8-bit value to 32 bits.<br/>&#13;
sdword = sword;      // Automatically sign-extends the 16-bit value to 32 bits.</pre>&#13;
<p class="indent">Some languages (such as Ada or Swift) require an explicit cast from a smaller size to a larger size. Check the reference manual for your particular language to see if this is necessary. The advantage of a language that requires you to provide an explicit conversion is that the compiler never does anything behind your back. If you fail to do the conversion yourself, the compiler emits a diagnostic message.</p>&#13;
<p class="indent">The important thing to realize about sign and zero extension is that they aren’t always free. Assigning a smaller integer to a larger integer may require more machine instructions (taking longer to execute) than moving data between two like-sized integer variables. Therefore, you should be careful about mixing variables of different sizes within the same arithmetic expression or assignment statement.</p>&#13;
<p class="indent">Sign contraction—converting a value with some number of bits to the same value with a fewer number of bits—is a little more troublesome. For example, consider the value –448. As a 16-bit hexadecimal number, its representation is <code>$FE40</code>. The magnitude of this number is too large to fit into 8 bits, so you can’t sign-contract it to 8 bits.</p>&#13;
<p class="indent">To properly sign-contract one value to another, you must look at the HO byte(s) that you want to discard. First, the HO bytes must all contain either <code>0</code> or <code>$FF</code>. Second, the HO bit of your resulting value must match <em>every</em> bit you’ve removed from the number. Here are some examples of converting 16-bit values to 8-bit values (including a couple of failures):</p>&#13;
<ul>&#13;
<li class="noindent"><code>$FF80</code> (<code>%1111_1111_1000_0000</code>) can be sign-contracted to <code>$80</code> (<code>%1000_0000</code>).</li>&#13;
<li class="noindent"><code>$0040</code> (<code>%0000_0000_0100_0000</code>) can be sign-contracted to <code>$40</code> (<code>%0100_0000</code>).</li>&#13;
<li class="noindent"><code>$FE40</code> (<code>%1111_1110_0100_0000</code>) cannot be sign-contracted to 8 bits.</li>&#13;
<li class="noindent"><code>$0100</code> (<code>%0000_0001_0000_0000</code>) cannot be sign-contracted to 8 bits.</li>&#13;
</ul>&#13;
<p class="indent">Some high-level languages, like C, will simply store the LO portion of the expression into a smaller variable and discard the HO component—at best, the C compiler may give you a warning about the loss of precision that may occur. You can often quiet the compiler, but it still doesn’t check for invalid values. Typically, you’d use code like the following to sign-contract a value in C:</p>&#13;
<pre>signed char sbyte;    // Chars in C are byte values.<br/>&#13;
short int sword;      // Short integers in C are *usually* 16-bit values.<br/>&#13;
long int sdword;      // Long integers in C are *usually* 32-bit values.<br/>&#13;
<span epub:type="pagebreak" id="page_28"/> . . .<br/>&#13;
sbyte = (signed char) sword;<br/>&#13;
sbyte = (signed char) sdword;<br/>&#13;
sword = (short int) sdword;</pre>&#13;
<p class="indent">The only safe solution in C is to compare the result of the expression to an upper- and lower-bound value before attempting to store the value into a smaller variable. Here’s the preceding code with these checks in place:</p>&#13;
<pre>if( sword &gt;= -128 &amp;&amp; sword &lt;= 127 )<br/>&#13;
{<br/>&#13;
    sbyte = (signed char) sword;<br/>&#13;
}<br/>&#13;
else<br/>&#13;
{<br/>&#13;
    // Report appropriate error.<br/>&#13;
}<br/><br/>&#13;
// Another way, using assertions:<br/><br/>&#13;
assert( sword &gt;= -128 &amp;&amp; sword &lt;= 127 )<br/>&#13;
sbyte = (signed char) sword;<br/><br/>&#13;
assert( sdword &gt;= -32768 &amp;&amp; sdword &lt;= 32767 )<br/>&#13;
sword = (short int) sdword;</pre>&#13;
<p class="indent">This code gets pretty ugly. In C/C++, you’d probably want to turn this into a macro (<code>#define</code>) or a function so your code would be a bit more readable.</p>&#13;
<p class="indent">Some high-level languages (such as Free Pascal and Delphi) automatically sign-contract values and then check the value to ensure it fits in the destination operand.<sup><a href="footnotes.xhtml#fn2_5a" id="fn2_5">5</a></sup> Such languages raise some sort of exception (or stop the program) if a range violation occurs. To take corrective action, you’ll either need to write some exception-handling code or use an <code>if</code> statement sequence similar to the one in the C example just given.</p>&#13;
<h3 class="h3" id="sec2_8"><strong>2.8 Saturation</strong></h3>&#13;
<p class="noindent">You can also reduce the size of an integer value through <em><a href="gloss01.xhtml#gloss01_220">saturation</a></em>, which is useful when you’re willing to live with a possible loss of precision. To convert a value via saturation, you copy the LO bits of the larger object into the smaller object. If the larger value is outside the smaller object’s range, then you <em>clip</em> the larger value by setting the smaller object to the largest (or smallest) value within the smaller value’s range.</p>&#13;
<p class="indent">For example, when converting a 16-bit signed integer to an 8-bit signed integer, if the 16-bit value is in the range –128 through +127, you simply copy the LO byte into the 8-bit object. If the 16-bit signed value is <span epub:type="pagebreak" id="page_29"/>greater than +127, then you clip the value to +127 and store +127 into the 8-bit object. Likewise, if the value is less than –128, you clip the final 8-bit object to –128. Saturation works the same way when you clip 32-bit values to smaller values.</p>&#13;
<p class="indent">If the larger value is outside the range of the smaller value, there will be a loss of precision during the conversion. While clipping the value is never desirable, sometimes it’s better than raising an exception or otherwise rejecting the calculation. For many applications, such as audio or video, the clipped result is still recognizable to the end user, so this is a reasonable conversion scheme.</p>&#13;
<p class="indent">Many CPUs support saturation arithmetic in their special “multimedia extension” instruction sets—for example, the MMX/SSE/AVX instruction extensions on the Intel 80x86 processor family. Most CPUs’ standard instruction sets, as well as most high-level languages, do not provide direct support for saturation, but the technique is not difficult. Consider the following Free Pascal/Delphi code, which uses saturation to convert a 32-bit integer to a 16-bit integer:</p>&#13;
<pre>var<br/>&#13;
    li  :longint;<br/>&#13;
    si  :smallint;<br/>&#13;
        . . .<br/>&#13;
    if( li &gt; 32767 ) then<br/><br/>&#13;
        si := 32767;<br/><br/>&#13;
    else if( li &lt; -32768 ) then<br/><br/>&#13;
        si := -32768;<br/><br/>&#13;
    else <br/>&#13;
        si := li;</pre>&#13;
<h3 class="h3" id="sec2_9"><strong>2.9 Binary-Coded Decimal Representation</strong></h3>&#13;
<p class="noindent">The <em><a href="gloss01.xhtml#gloss01_28">binary-coded decimal</a> (BCD)</em> format, as its name suggests, encodes decimal values using a binary representation. Common general-purpose high-level languages (like C/C++, Pascal, and Java) rarely support decimal values. However, business-oriented programming languages (like COBOL and many database languages) do. So, if you’re writing code that interfaces with a database or some language that supports decimal arithmetic, you may need to deal with BCD representation.</p>&#13;
<p class="indent">BCD values consist of a sequence of nibbles, with each nibble representing a value in the range 0 to 9. (The BCD format uses only 10 of the possible 16 values represented by a nibble.) With a byte we can represent values containing two decimal digits (0..99), as shown in <a href="ch02.xhtml#ch02fig08">Figure 2-8</a>. With a word, we can represent four decimal digits (0..9999). A double word can represent up to eight decimal digits.</p>&#13;
<div class="image"><img alt="image" src="../images/02fig08.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_30"/><a id="ch02fig08"/><em>Figure 2-8: BCD data representation in a byte</em></p>&#13;
<p class="indent">An 8-bit BCD variable can represent values in the range 0 to 99, while that same 8 bits, holding a binary value, could represent values in the range 0 to 255. Likewise, a 16-bit binary value can represent values in the range 0 to 65,535, while a 16-bit BCD value can represent only about a sixth of those values (0..9999). Inefficient storage isn’t the only problem with BCD, though—BCD calculations also tend to be slower than binary calculations.</p>&#13;
<p class="indent">The BCD format does have two saving graces: it’s very easy to convert BCD values between the internal numeric representation and their decimal string representations, and it’s also very easy to encode multidigit decimal values in hardware when using BCD—for example, when using a set of dials, with each dial representing a single digit. For these reasons, you’re likely to see people using BCD in embedded systems (such as toaster ovens and alarm clocks) but rarely in general-purpose computer software.</p>&#13;
<p class="indent">A few decades ago, people thought that calculations involving BCD (or just decimal) arithmetic were more accurate than binary calculations. Therefore, they would often perform important calculations, like those involving monetary units, using decimal-based arithmetic. Certain calculations can produce more accurate results in BCD, but for most calculations, binary is more accurate. This is why most modern computer programs represent all values (including decimal values) in a binary form. For example, the Intel 80x86 <em>floating-point unit (FPU)</em> supports a pair of instructions for loading and storing BCD values. Internally, the FPU converts these BCD values to binary. It only uses BCD as an external (to the FPU) data format. This approach generally produces more accurate results.</p>&#13;
<h3 class="h3" id="sec2_10"><strong>2.10 Fixed-Point Representation</strong></h3>&#13;
<p class="noindent">There are two ways computer systems commonly represent numbers with fractional components: fixed-point representation and floating-point representation.</p>&#13;
<p class="indent">Back in the days when CPUs didn’t support floating-point arithmetic in hardware, fixed-point arithmetic was very popular with programmers writing high-performance software that dealt with fractional values. There’s less software overhead needed to support fractional values in a fixed-point format than in floating-point. However, CPU manufacturers added FPUs to their CPUs to support floating-point in hardware, and today, it’s fairly rare <span epub:type="pagebreak" id="page_31"/>to see someone attempt fixed-point arithmetic on a general-purpose CPU. It’s usually more cost-effective to use the CPU’s native floating-point format.</p>&#13;
<p class="indent">Although CPU manufacturers have worked hard at optimizing the floating-point arithmetic on their systems, in certain circumstances, carefully written assembly language programs that use fixed-point calculations will run faster than the equivalent floating-point code. Certain 3D gaming applications, for example, may produce faster computations using a 16:16 (16-bit integer, 16-bit fractional) format rather than a 32-bit floating-point format. Because there are some very good uses for fixed-point arithmetic, this section discusses fixed-point representation and fractional values using the fixed-point format.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em><a href="ch04.xhtml#ch04">Chapter 4</a> will discuss the floating-point format.</em></p>&#13;
</div>&#13;
<p class="indent">As you’ve seen, positional numbering systems represent fractional values (values between 0 and 1) by placing digits to the right of the radix point. In the binary numbering system, each bit to the right of the binary point represents the value 0 or 1 multiplied by some successive negative power of 2. We represent that fractional component of a value using sums of binary fractions. For example, the value 5.25 is represented by the binary value 101.01. The conversion to decimal yields:</p>&#13;
<p class="equation">1 × 2<sup>2</sup> + 1 × 2<sup>0</sup> + 1 × 2<sup>–2</sup> = 4 + 1 + 0.25 = 5.25</p>&#13;
<p class="indent">When using a fixed-point binary format, you choose a particular bit in the binary representation and implicitly place the binary point before that bit. You choose the position of the binary point based on the number of significant bits you require in the fractional portion of the number. For example, if your values’ integer components can range from 0 to 999, you’ll need at least 10 bits to the left of the binary point to represent this range of values. If you require signed values, you’ll need an extra bit for the sign. In a 32-bit fixed-point format, this leaves either 21 or 22 bits for the fractional part, depending on whether your value is signed.</p>&#13;
<p class="indent">Fixed-point numbers are a small subset of the real numbers. Because the number of values between any two integer values is infinite, fixed-point values cannot exactly represent every single one (doing so would require an infinite number of bits). With fixed-point representation, we have to approximate most of the real numbers. Consider the 8-bit fixed-point format, which uses 6 bits for the integer portion and 2 bits for the fractional component. The integer component can represent values in the range 0 to 63 (or signed values in the range –32 to +31). The fractional component can represent only four different values: 0.0, 0.25, 0.5, and 0.75. You cannot exactly represent 1.3 with this format; the best you can do is approximate it by choosing the value closest to it (1.25). This introduces error. You can reduce this error by adding further bits to the right of the binary point in your fixed-point format (at the expense of reducing the range of the integer component or adding more bits to your fixed-point format). For example, if you move to a 16-bit fixed-point format using an 8-bit integer <span epub:type="pagebreak" id="page_32"/>and an 8-bit fractional component, then you can approximate 1.3 using the binary value 1.01001101. The decimal equivalent is as follows:</p>&#13;
<p class="equation">1 + 0.25 + 0.03125 + 0.15625 + 0.00390625 = 1.30078125</p>&#13;
<p class="indent">Adding more bits to the fractional component of your fixed-point number will give you a more accurate approximation of this value (the error is only 0.00078125 using this format, compared to 0.05 in the previous format).</p>&#13;
<p class="indent">In a fixed-point binary numbering system, there are certain values you can never accurately represent regardless of how many bits you add to the fractional part of your fixed-point representation (1.3 just happens to be such a value). This is probably the main reason why people (mistakenly) feel that decimal arithmetic is more accurate than binary arithmetic (particularly when working with decimal fractions like 0.1, 0.2, 0.3, and so on).</p>&#13;
<p class="indent">To contrast the comparative accuracy of the two systems, let’s consider a fixed-point decimal system (using BCD representation). If we choose a 16-bit format with 8 bits for the integer portion and 8 bits for the fractional portion, we can represent decimal values in the range 0.0 to 99.99 with two decimal digits of precision to the right of the decimal point. We can exactly represent values like 1.3 in this BCD notation using a hex value like <code>$0130</code> (the implicit decimal point appears between the second and third digits in this number). As long as you use only the fractional values 0.00 to 0.99 in your computations, this BCD representation is more accurate than the binary fixed-point representation (using an 8-bit fractional component).</p>&#13;
<p class="indent">In general, however, the binary format is more accurate. The binary format lets you exactly represent 256 different fractional values, whereas BCD lets you represent only 100. If you pick an arbitrary fractional value, it’s likely the binary fixed-point representation provides a better approximation than the decimal format (because there are over two and a half times as many binary versus decimal fractional values). (You can extend this comparison to larger formats: for example, with a 16-bit fractional component, the decimal/BCD fixed-point format gives you exactly four digits of precision; the binary format, on the other hand, offers over six times the resolution—65,536 rather than 10,000 fractional values.) Decimal fixed-point format has the advantage only when you regularly work with the fractional values that it can exactly represent. In the United States, monetary computations commonly produce these fractional values, so programmers figured the decimal format is better for monetary computations. However, given the accuracy most financial computations require (generally four digits to the right of the decimal point is the minimum precision), it’s usually better to use a binary format.</p>&#13;
<p class="indent">If you absolutely, positively need to exactly represent the fractional values between 0.00 and 0.99 with at least two digits of precision, the binary fixed-point format is not a viable solution. Fortunately, you don’t have to use a decimal format; as you’ll soon see, there are other binary formats that will let you exactly represent these values.</p>&#13;
<h3 class="h3" id="sec2_11"><span epub:type="pagebreak" id="page_33"/><strong>2.11 Scaled Numeric Formats</strong></h3>&#13;
<p class="noindent">Fortunately, there’s a numeric representation that combines the exact representation of certain decimal fractions with the precision of the binary format. Known as the <a href="gloss01.xhtml#gloss01_223"><em>scaled numeric</em> format</a>, this representation is also efficient to use and doesn’t require any special hardware.</p>&#13;
<p class="indent">Another advantage of the scaled numeric format is that you can choose any base, not just decimal, for your format. For example, if you’re working with ternary (base-3) fractions, you can multiply your original input value by 3 (or a power of 3) and exactly represent values like <sup>1</sup>/<sub>3</sub>, <sup>2</sup>/<sub>3</sub>, <sup>4</sup>/<sub>9</sub>, <sup>7</sup>/<sub>27</sub>, and so on—something you can’t do in either the binary or decimal numbering systems.</p>&#13;
<p class="indent">To represent fractional values, you multiply your original value by some value that converts the fractional component to a whole number. For example, if you want to maintain two decimal digits of precision to the right of the decimal point, multiply your values by 100 upon input. This translates values like 1.3 to 130, which we can exactly represent using an integer value. Assuming you do this calculation with all your fractional values (and they have the same two digits of precision to the right of the decimal point), you can manipulate your values using standard integer arithmetic operations. For example, if you have the values 1.5 and 1.3, their integer conversion produces 150 and 130. If you add these two values, you get 280 (which corresponds to 2.8). When you need to output these values, you divide them by 100 and emit the quotient as the integer portion of the value and the remainder (zero-extended to two digits, if necessary) as the fractional component. Other than needing to write specialized input and output routines that handle the multiplication and division by 100 (as well as dealing with the decimal point), you’ll find that this scaled numeric scheme is almost as easy as doing regular integer calculations.</p>&#13;
<p class="indent">If you scale your values as described here, you’ve limited the maximum range of the integer portion of your numbers. For example, if you need two decimal digits of precision to the right of your decimal point (meaning you multiply the original value by 100), then you may only represent (unsigned) values in the range 0 to 42,949,672 rather than the normal range of 0 to 4,294,967,296.</p>&#13;
<p class="indent">When you’re doing addition or subtraction with a scaled format, both operands must have the same scaling factor. If you’ve multiplied the left operand by 100, you must multiply the right operand by 100 as well. For example, if you’ve scaled the variable <code>i10</code> by 10 and you’ve scaled the variable <code>j100</code> by 100, you need to either multiply <code>i10</code> by 10 (to scale it by 100) or divide <code>j100</code> by 10 (to scale it down to 10) before attempting to add or subtract these two numbers. This ensures that both operands have the radix point in the same position (note that this applies to literal constants as well as to variables).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_34"/>In multiplication and division operations, the operands do not require the same scaling factor prior to the operation. However, once the operation is complete, you may need to adjust the result. Suppose you have two values you’ve scaled by 100 to produce two digits of precision after the decimal point, <code>i = 25</code> (0.25) and <code>j = 1</code> (0.01). If you compute <code>k = i * j</code> using standard integer arithmetic, you’ll get 25 (25 × 1 = 25), which is interpreted as 0.25, but the result should be 0.0025. The computation is correct; the problem is understanding how the multiplication operator works. We’re actually computing:</p>&#13;
<p class="equation">(0.25 × (100)) × (0.01 × (100)) = 0.25 × 0.01 × (100 × 100) (commutative laws allow this) = 0.0025 × (10,000) = 25</p>&#13;
<p class="indent">The final result actually gets scaled by 10,000 because both <code>i</code> and <code>j</code> have been multiplied by 100; when you multiply their values, you wind up with a value multiplied by 10,000 (100 × 100) rather than 100. To solve this problem, you should divide the result by the scaling factor once the computation is complete. For example, <code>k = (i * j)/100</code>.</p>&#13;
<p class="indent">The division operation suffers from a similar problem. Suppose we have the values <code>m = 500</code> (5.0) and <code>n = 250</code> (2.5) and we want to compute <code>k = m/n</code>. We would normally expect to get the result 200 (2.0, which is 5.0/2.5). However, here’s what we’re actually computing:</p>&#13;
<p class="equation">(5 × 100) / (2.5 × 100) = 500/250 = 2</p>&#13;
<p class="indent">At first blush this may look correct, but the result is really 0.02 after you factor in the scaling operation. The result we need is 200 (2.0). Division by the scaling factor eliminates the scaling factor in the final result. Therefore, to properly compute the result, we need to compute <code>k = 100 * m/n</code>.</p>&#13;
<p class="indent">Multiplication and division place a limit on the precision you have available. If you have to premultiply the dividend by 100, then the dividend must be at least 100 times smaller than the largest possible integer value, or an overflow will occur (producing an incorrect result). Likewise, when you’re multiplying two scaled values, the final result must be 100 times less than the maximum integer value, or an overflow will occur. Because of these issues, you may need to set aside additional bits or work with small numbers when using scaled numeric representation.</p>&#13;
<h3 class="h3" id="sec2_12"><span epub:type="pagebreak" id="page_35"/><strong>2.12 Rational Representation</strong></h3>&#13;
<p class="noindent">One big problem with the fractional representations we’ve seen is that they provide a close approximation, but not an exact representation, for all rational values.<sup><a href="footnotes.xhtml#fn2_6a" id="fn2_6">6</a></sup> For example, in binary or decimal you cannot exactly represent the value <sup>1</sup>/<sub>3</sub>. You could switch to a ternary (base-3) numbering system and exactly represent <sup>1</sup>/<sub>3</sub><sub/> , but then you wouldn’t be able to exactly represent fractional values like <sup>1</sup>/<sub>2</sub> or <sup>1</sup>/<sub>10</sub>. We need a numbering system that can represent <em>any</em> rational fractional value.</p>&#13;
<p class="indent">Rational representation uses pairs of integers to represent fractional values. One integer represents the numerator (<em>n</em>) of a fraction, and the other represents the denominator (<em>d</em>). The actual value is equal to <em>n</em>/<em>d</em>. As long as <em>n</em> and <em>d</em> are “relatively prime” (that is, not both evenly divisible by the same value), this scheme provides a good representation for fractional values within the bounds of the integer representation you’re using for <em>n</em> and <em>d</em>. Arithmetic is quite easy; you use the same algorithms to add, subtract, multiply, and divide fractional values that you learned in grade school when dealing with fractions. However, certain operations may produce really large numerators or denominators (to the point where you get integer overflow in these values). Other than this problem, you can represent a wide range of fractional values using this scheme.</p>&#13;
<h3 class="h3" id="sec2_13"><strong>2.13 For More Information</strong></h3>&#13;
<p class="ref">Knuth, Donald E. <em>The Art of Computer Programming, Volume 2: Seminumerical Algorithms</em>. 3rd ed. Boston: Addison-Wesley, 1998.<span epub:type="pagebreak" id="page_36"/></p>&#13;
</body></html>