- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 25 STATIC METHODS, PROPERTIES, AND ENUMERATIONS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 25 静态方法、属性和枚举
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, we’ll explore *static members*. Unlike the instance-level properties
    and methods we’ve been using so far, which are accessible through the individual
    objects of a class, static properties and methods are accessed through the class
    as a whole. As such, you don’t have to create an object of a class to use its
    static members.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索 *静态成员*。与我们迄今使用的实例级别的属性和方法不同，静态属性和方法是通过类整体访问的。因此，您不需要创建类的对象就可以使用其静态成员。
- en: We’ll discuss how to work with static members and illustrate their usefulness
    in situations such as storing information about all the instances of a class or
    sharing resources across an entire application. We’ll also touch on enumerations,
    which provide a way to list all possible values for a data type.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论如何使用静态成员，并展示它们在存储类所有实例信息或在整个应用程序中共享资源等情况中的有用性。我们还将简要介绍枚举，它提供了一种列出数据类型所有可能值的方式。
- en: Storing Class-Wide Information
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储类级别信息
- en: One common use of static members is to keep track of information about all instances
    of a class. This is handy when a message needs to be sent to all objects of a
    class, or when a calculation must be based on just the class’s current instances.
    Consider the AudioClip class diagrammed in [Figure 25-1](#fig25-1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 静态成员的一个常见用途是跟踪有关类的所有实例的信息。当需要向类的所有对象发送消息，或者当计算必须基于类的当前实例时，这非常有用。考虑[图 25-1](#fig25-1)中描述的
    AudioClip 类。
- en: '![](../images/figure25-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure25-1.jpg)'
- en: 'Figure 25-1: An AudioClip class with static members'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25-1：带有静态成员的 AudioClip 类
- en: The AudioClip class has instance members for storing details about a given audio
    file. These are the title and durationSeconds properties, with their associated
    getters and setters. The constructor and __toString() method are instance members
    as well, since they pertain to creating or summarizing the contents of a particular
    object. Meanwhile, the class has a maxClipDurationSeconds property that tracks
    the longest duration of any AudioClip objects that have been created. This is
    a good use of a static member (indicated by underlining in the diagram), since
    the property holds information pertaining to all the objects of the class. The
    property’s getter method should also be static.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: AudioClip 类具有实例成员，用于存储有关给定音频文件的详细信息。这些成员包括标题（title）和持续时间（durationSeconds）属性，以及它们相关的
    getter 和 setter 方法。构造函数和 __toString() 方法也是实例成员，因为它们与创建或总结特定对象的内容有关。与此同时，该类有一个
    maxClipDurationSeconds 属性，用于跟踪所有已创建的 AudioClip 对象的最大持续时间。由于该属性包含与类的所有对象相关的信息，因此它是静态成员的良好示例（在图中通过下划线表示）。该属性的
    getter 方法也应该是静态的。
- en: To see how static members are useful for storing class-wide information, we’ll
    declare the AudioClip class and create three instances of it. The diagram shows
    how each instance will have its own values for the title and durationSeconds properties.
    For example, clip1 will have a title of 'Hello World' and a durationSeconds of
    2.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示静态成员如何有助于存储类级别信息，我们将声明 AudioClip 类并创建它的三个实例。该图表显示了每个实例将拥有自己的标题和持续时间属性值。例如，clip1
    的标题为 'Hello World'，持续时间为 2 秒。
- en: Create a new project folder and add the usual *composer.json* file declaring
    that Mattsmithdev namespaced classes are located in the *src* folder. Generate
    the autoloader file by entering composer dump-autoload at the command line. Then
    declare the AudioClip class by creating *src/AudioClip.php* and entering the contents
    of [Listing 25-1](#lis25-1).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目文件夹，并添加常规的 *composer.json* 文件，声明 Mattsmithdev 命名空间类位于 *src* 文件夹中。通过在命令行中输入
    composer dump-autoload 来生成自动加载文件。然后通过创建 *src/AudioClip.php* 文件并输入[清单 25-1](#lis25-1)的内容来声明
    AudioClip 类。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 25-1: The AudioClip class'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 25-1：AudioClip 类
- en: We declare maxClipDurationSeconds by using the static keyword to specify that
    this is a static member that exists independent of any objects of the AudioClip
    class ❶. We initialize it to -1, ensuring that whatever the duration of the first
    AudioClip object to be created, its duration will be greater than -1 and so will
    be stored in this static property. We’ll see how this is done later, as part of
    the setDurationSeconds() setter method.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用static关键字声明maxClipDurationSeconds，以指定这是一个独立于任何AudioClip类对象存在的静态成员❶。我们将其初始化为-1，确保无论第一个被创建的AudioClip对象的持续时间是多少，它的持续时间都大于-1，并将被存储在这个静态属性中。稍后，我们将看到这是如何在setDurationSeconds()设置方法中完成的。
- en: We set maxClipDurationSeconds to be private, but we declare a public getter
    method, getMaxClipDurationSeconds(), which is also static ❷. Making this method
    public allows code inside and outside the class to query the value of the longest
    AudioClip object that’s been created since the program or request has been running.
    We’ll explore what this implies and how this property is used shortly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将maxClipDurationSeconds设置为私有，但声明了一个公共的getter方法getMaxClipDurationSeconds()，它也是静态的❷。将这个方法设为公共方法，允许类内外的代码查询自程序或请求启动以来创建的最长AudioClip对象的值。稍后我们会探讨这意味着什么，以及这个属性是如何被使用的。
- en: We next declare two instance-level properties for each AudioClip object, title
    and durationSeconds ❸, with a default value of 0 for the latter to ensure that
    it’s set even if an invalid argument is provided at construction. The class’s
    constructor method ❹ takes in initial values for these two properties and sets
    them in the object by invoking the appropriate setters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为每个AudioClip对象声明两个实例级别的属性，title和durationSeconds❸，其中后者的默认值为0，以确保即使在构造时提供无效参数，它也会被设置。类的构造方法❹接受这两个属性的初始值，并通过调用相应的setter方法将它们设置到对象中。
- en: The instance-level accessor methods are all straightforward, save for setDurationSeconds(),
    which has custom validation logic ❺. A clip’s duration should never be negative,
    so we first test for this and use return to halt execution of the method with
    no further action if a negative value is provided. If we make it past that point,
    we know the provided argument is 0 or positive, so we store it in the object’s
    durationSeconds property.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实例级别的访问器方法都很直接，除了setDurationSeconds()，它有自定义的验证逻辑❺。一个片段的持续时间不应该是负数，因此我们首先测试这一点，如果提供了负值，则使用return停止方法的执行，不再进行其他操作。如果我们通过了这个检查，我们知道提供的参数是0或正值，因此我们将其存储在对象的durationSeconds属性中。
- en: Then we check whether the object’s new duration is greater than the value stored
    in the maxClipDurationSeconds static property. If it is, we update this property
    to equal the new duration. Since maxClipDurationSeconds starts off with a sentinel
    value of -1, and because of our validation at the beginning of the method, we
    know that no AudioClip objects will ever have a negative duration. Therefore,
    as soon as the first clip has been created with a valid duration, this static
    property will be set accordingly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查对象的新持续时间是否大于存储在maxClipDurationSeconds静态属性中的值。如果是，我们更新这个属性，使其等于新的持续时间。由于maxClipDurationSeconds初始时的哨兵值为-1，并且由于我们在方法开始时进行的验证，我们知道不会有任何AudioClip对象的持续时间为负数。因此，一旦第一个有效持续时间的片段被创建，这个静态属性将被相应地设置。
- en: 'Notice that we have to use self:: to access the maxClipDurationSeconds property.
    This *scope resolution operator* (::) is the syntax for accessing a static member
    from within the same class.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须使用self::来访问maxClipDurationSeconds属性。这个*作用域解析运算符*（::）是访问同一类内静态成员的语法。
- en: We complete the declaration of the class with the __toString() method ❻. It
    returns a string summarizing an AudioClip object’s contents, in the form (AudioClip)
    title (durationSeconds seconds).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过__toString()方法❻完成了类的声明。它返回一个字符串，概述了一个AudioClip对象的内容，格式为 (AudioClip) title
    (durationSeconds 秒)。
- en: Now let’s put our class to work through an index script that creates AudioClip
    objects and outputs the changing value of the static maxClip DurationSeconds property.
    Create *public/index.php* as shown in [Listing 25-2](#lis25-2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个索引脚本来使用我们的类，创建AudioClip对象并输出静态maxClipDurationSeconds属性的变化值。创建*public/index.php*，如[Listing
    25-2](#lis25-2)所示。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 25-2: The index.php script'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 25-2：index.php脚本
- en: 'First, we print a message displaying the value of maxClipDurationSeconds, accessed
    via the public static getMaxClipDurationSeconds() method. Since we haven’t yet
    instantiated any AudioClip objects, the property should still have its initial
    value of -1. Notice that we have to prefix the static member’s name with AudioClip::
    rather than self::, since we’re writing this code from the index script and not
    from within the static members’ class. We then create three AudioClip objects,
    $clip1, $clip2, and $clip3, printing each one and then displaying the value of
    maxClipDurationSeconds again.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们打印一条信息，显示通过公共静态方法getMaxClipDurationSeconds()访问的maxClipDurationSeconds的值。由于我们还没有实例化任何AudioClip对象，该属性的初始值应为-1。注意，我们必须使用AudioClip::前缀来引用静态成员，而不是self::，因为我们是在索引脚本中编写代码，而不是在静态成员的类内部。然后，我们创建三个AudioClip对象，$clip1、$clip2和$clip3，打印每个对象并再次显示maxClipDurationSeconds的值。
- en: 'Here’s the output of running the index script:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 运行索引脚本的输出如下：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The max duration starts with a value of -1, but each time an AudioClip object
    with a nonnegative duration is created, this value is updated if the new clip
    is the longest, through the logic in the setDurationSeconds() method. After creating
    the hello world object, the max duration goes from -1 to 2. The value doesn’t
    change after the bad duration object is created with an invalid duration of -10.
    (Notice from the object’s printout that its duration is stored as 0, the default
    value, rather than -10, thanks to our initial validation logic in the setDurationSeconds()
    method.) Finally, after creating the My Way object, the max duration is updated
    to 275.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最大时长的初始值为-1，但每当创建一个时长非负的AudioClip对象时，如果新剪辑的时长更长，这个值就会通过setDurationSeconds()方法中的逻辑更新。在创建hello
    world对象后，最大时长从-1变为2。创建具有无效时长-10的bad duration对象后，值没有变化。（从对象的打印输出中可以看到，它的时长被存储为0，即默认值，而不是-10，这得益于我们在setDurationSeconds()方法中的初始验证逻辑。）最后，在创建My
    Way对象后，最大时长更新为275。
- en: 'Our logic for updating maxClipDurationSeconds has worked well for demonstration
    purposes, but it isn’t actually a good way to keep track of the longest AudioClip
    object, since it assumes that all the objects exist for the entire run of the
    application. Say we decide that we no longer want one of the audio clips (the
    user might choose to delete it from a list). Our current logic provides no way
    to roll back the maximum clip duration if that clip is deleted. A better approach
    might be to have an array of active AudioClip objects. Each time a clip is removed,
    we could then loop through the array and recalculate the duration of the longest
    active clip.  ### Static Properties vs. Class Constants'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新maxClipDurationSeconds的逻辑对于演示目的来说效果不错，但实际上这不是跟踪最长AudioClip对象的好方法，因为它假设所有对象在整个应用程序运行期间都存在。假设我们决定不再需要其中一个音频剪辑（用户可能选择将其从列表中删除）。目前的逻辑没有提供回滚最大剪辑时长的方式，如果该剪辑被删除的话。一种更好的方法可能是维护一个活动AudioClip对象的数组。每次删除一个剪辑时，我们可以遍历数组并重新计算最长活动剪辑的时长。###
    静态属性与类常量
- en: Static properties aren’t to be confused with class constants. In both cases,
    only one copy of the static property or class constant exists on the class itself,
    rather than a separate copy on each instance of the class. However, class constants
    are immutable, so their value never changes. By contrast, the value of a static
    property can change (as you saw with maxClipDurationSeconds), just like the value
    of an ordinary property of an object. In this sense, the term *static* can be
    a bit misleading. All PHP object-oriented properties, whether they’re per-object
    instance properties or per-class static properties, begin with a dollar sign,
    which distinguishes them from constants.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 静态属性不应与类常量混淆。在这两种情况下，静态属性或类常量只有一个副本存在于类本身，而不是每个类实例有一个独立的副本。然而，类常量是不可变的，因此其值永远不会改变。相比之下，静态属性的值是可以变化的（正如你在maxClipDurationSeconds中看到的那样），就像对象的普通属性值一样。从这个角度来看，*静态*这个术语可能会有点误导。所有PHP面向对象的属性，无论是每个对象实例的属性还是每个类的静态属性，都会以美元符号开头，这使得它们与常量区分开来。
- en: Use a class constant when you have a value that should apply to all objects
    of a class and should never change. We’ve met class constants previously; one
    example is the PATH_TO_TEMPLATES constant used to create the Twig\Environment
    object for templating. In this case, the filepath to the templates folder should
    never change and would apply equally to any and all Twig\Environment objects.
    Other uses of a class constant include defining special values, like setting the
    maximum score for a school grade point average (GPA) to 4.0 or the neutral value
    for the pH acidity scale to 7.0.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个值应该适用于类的所有对象并且永远不会改变时，请使用类常量。我们之前已经遇到过类常量；一个例子是用于创建 Twig\Environment 对象进行模板渲染的
    PATH_TO_TEMPLATES 常量。在这种情况下，模板文件夹的文件路径永远不应更改，并且应适用于所有的 Twig\Environment 对象。类常量的其他使用场景包括定义特殊值，比如将学校成绩点平均值（GPA）的最高分设置为
    4.0，或者将 pH 酸碱度尺度的中性值设置为 7.0。
- en: In the case of our AudioClip class, we might have class constants defining details
    like the number of channels or the sampling rate of the audio files, on the assumption
    that these will be standard across all audio clips. To explore the difference
    between class constants and static properties, we’ll add some class constants
    to our AudioClip project now. [Figure 25-2](#fig25-2) shows an updated diagram
    of the AudioClip class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 AudioClip 类的情况下，我们可能会有类常量来定义诸如音频文件的通道数或采样率等细节，假设这些参数在所有音频剪辑中都是标准的。为了探索类常量和静态属性之间的区别，我们现在将在
    AudioClip 项目中添加一些类常量。[图 25-2](#fig25-2) 展示了更新后的 AudioClip 类的图示。
- en: '![](../images/figure25-2.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure25-2.jpg)'
- en: 'Figure 25-2: Adding class constants and an extra method to the AudioClip class'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25-2：向 AudioClip 类添加类常量和额外方法
- en: 'The diagram shows that the AudioClip class will now offer four public class
    constants, which are indicated as {read-only} in class diagrams. For our project,
    we’ll make some assumptions about the audio clips that the class represents: they’ll
    all be stereo (two channels) and store 16 bits per sample (CD-quality digital
    audio). The number of samples per second will always be 44,100, which is a common
    audio sampling rate. These values are indicated by the AudioClip class constants
    NUM_CHANNELS, BITS_PER_SAMPLE, and SAMPLES_PER _SECOND, and together they’re used
    to calculate the BITS_PER_SECOND constant.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图示显示，AudioClip 类现在将提供四个公共类常量，这些常量在类图中标记为 {只读}。对于我们的项目，我们将对类所表示的音频剪辑做出一些假设：它们都是立体声（两个通道），每个样本存储
    16 位（CD 质量的数字音频）。每秒的样本数将始终为 44,100，这是一个常见的音频采样率。这些值由 AudioClip 类常量 NUM_CHANNELS、BITS_PER_SAMPLE
    和 SAMPLES_PER_SECOND 表示，并一起用于计算 BITS_PER_SECOND 常量。
- en: NOTE
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*For a more realistic example, these constants could be replaced by instance
    properties, since not all audio clips may conform to the standard laid out by
    the constants.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于更现实的示例，这些常量可以被实例属性替代，因为并非所有音频剪辑都可能符合常量所设定的标准。*'
- en: We’ll also add a new getSizeBits() method that uses the class constants to calculate
    the number of bits required to store the audio clip in memory or on disk. Additionally,
    we’ll include the value from this new method as part of the object summary returned
    by the __toString() method.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个新的 getSizeBits() 方法，该方法使用类常量来计算存储音频剪辑所需的内存或磁盘上的位数。此外，我们还将把这个新方法的值作为对象摘要的一部分，通过
    __toString() 方法返回。
- en: To implement all these changes, edit the *src/AudioClip.php* file as shown in
    [Listing 25-3](#lis25-3).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这些更改，请按照 [清单 25-3](#lis25-3) 中所示编辑 *src/AudioClip.php* 文件。
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 25-3: Adding constants and the getSizeBits() method to the AudioClip
    class'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 25-3：向 AudioClip 类添加常量和 getSizeBits() 方法
- en: 'It’s common to list constants first when declaring a class, before any properties
    and methods, so we begin the AudioClip class by declaring the constants NUM_CHANNELS,
    BITS_PER_SAMPLE, and SAMPLES_PER_SECOND, with the values described previously.
    Then we declare BITS_PER_SECOND, which is an example of a *calculated constant*
    since its value is determined based on the values of the other constants rather
    than being set directly. By precalculating this value and storing it as a constant,
    we avoid having to repeat the calculation every time we need to convert from seconds
    of audio to bits of data. Notice the use of self:: to access the other constants
    in the BITS_PER_SECOND calculation. This syntax applies to accessing class constants
    from within the class, just as it does to accessing static members.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '在声明类时，通常会先列出常量，再列出任何属性和方法，因此我们通过声明常量 NUM_CHANNELS、BITS_PER_SAMPLE 和 SAMPLES_PER_SECOND
    来开始 AudioClip 类的定义，其值如前所述。然后我们声明了 BITS_PER_SECOND，它是一个 *计算常量* 的例子，因为其值是根据其他常量的值确定的，而不是直接设置的。通过预先计算这个值并将其存储为常量，我们避免了每次需要将音频的秒数转换为数据的位数时都要重复计算。请注意，在
    BITS_PER_SECOND 计算中使用了 self:: 来访问其他常量。这种语法用于在类内部访问类常量，就像访问静态成员一样。'
- en: Next, we declare getSizeBits(), a useful extra getter method for each AudioClip
    object. It returns an integer representing the number of bits required to store
    the audio clip, found by multiplying the precalculated BITS _PER_SECOND constant
    by the object’s durationSeconds property. We also update the __toString() method
    ❶, summarizing an AudioClip object’s contents including its size in bits, thanks
    to our new method. Notice that we use the built-in number_format() function to
    create a temporary $numBitsFormatted string variable. With the function’s default
    settings, this creates a more readable representation of the number with a comma
    separator every three digits.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明了 getSizeBits()，这是每个 AudioClip 对象的一个有用的额外获取器方法。它返回一个整数，表示存储音频片段所需的位数，通过将预先计算的
    BITS _PER_SECOND 常量乘以对象的 durationSeconds 属性来获得。我们还更新了 __toString() 方法 ❶，总结了 AudioClip
    对象的内容，包括其位数大小，感谢我们新方法的加入。请注意，我们使用了内置的 number_format() 函数来创建一个临时的 $numBitsFormatted
    字符串变量。使用函数的默认设置，它会在每三位数字之间创建逗号分隔符，从而使数字的表示更加易读。
- en: 'Here’s the terminal output of running the index script again (no changes to
    the index script are needed):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是重新运行索引脚本后的终端输出（索引脚本无需更改）：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each AudioClip object printout now ends with the integer number of bits the
    clip data occupies, thanks to our class constants. Even for a two-second clip,
    over 2 million bits are needed (which is why we’ve formatted the number of bits
    with comma separators).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 AudioClip 对象的输出现在都会以该音频片段数据占用的位数的整数形式结束，感谢我们使用的类常量。即使是一个两秒钟的片段，也需要超过 200
    万位（这就是为什么我们将位数格式化为每三位用逗号分隔的原因）。
- en: Utility Classes with Static Members
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有静态成员的工具类
- en: Static members may also be created as part of *utility classes*; these exist
    to help other classes do their work and aren’t used to create objects. A utility
    class’s static members might store helpful information or perform basic, general-purpose
    calculations that might have uses in other projects or other parts of the current
    project.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 静态成员也可以作为 *工具类* 的一部分来创建；这些工具类旨在帮助其他类完成工作，并不用于创建对象。工具类的静态成员可能会存储有用的信息或执行基本的、通用的计算，这些计算在其他项目或当前项目的其他部分可能会用到。
- en: Continuing with our AudioClip example, let’s say we want to display the size
    of each audio clip in megabytes rather than bits. We’ll need a way to convert
    from bits to megabytes. We could refactor the AudioClip class’s getSizeBits()
    method to make the necessary calculation. This calculation, along with supporting
    pieces of information such as the number of bits in a byte, is general enough
    that it might be useful to other, non-audio parts of the project or to other projects
    entirely. Therefore, locating the necessary code in a utility class makes sense.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 继续以我们的 AudioClip 示例为例，假设我们想要以兆字节而不是位的形式显示每个音频片段的大小。我们需要一种从位转换为兆字节的方法。我们可以重构
    AudioClip 类的 getSizeBits() 方法来进行必要的计算。这个计算，以及支持性的信息，比如一个字节中包含的位数，足够通用，可能对项目中的其他非音频部分或者完全不同的项目也有用。因此，将必要的代码放在工具类中是有意义的。
- en: We’ll create a utility class called SizeUtilities to help the AudioClip class
    calculate memory size. Often, utility classes aren’t used to create objects, and
    this will be the case for SizeUtilities. Since an object of this class will never
    be instantiated, we’ll declare SizeUtilities as abstract. By extension, since
    there will never be a SizeUtilities object, all the class’s members need to be
    accessible through the class as a whole. That is, SizeUtilities must consist of
    class-level constants and static members. [Figure 25-3](#fig25-3) shows a diagram
    of the modified AudioClip class and the new SizeUtilities utility class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 SizeUtilities 的工具类，帮助 AudioClip 类计算内存大小。通常，工具类不用于创建对象，而 SizeUtilities
    也不例外。由于这个类的对象永远不会被实例化，我们将把 SizeUtilities 声明为抽象类。因此，由于不会有 SizeUtilities 对象，所有类的成员需要通过类本身访问。也就是说，SizeUtilities
    必须由类级常量和静态成员组成。[图 25-3](#fig25-3) 显示了修改后的 AudioClip 类和新的 SizeUtilities 工具类的图示。
- en: '![](../images/figure25-3.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure25-3.jpg)'
- en: 'Figure 25-3: A class diagram of AudioClip and SizeUtilities demonstrating static
    methods and properties'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25-3：展示静态方法和属性的 AudioClip 和 SizeUtilities 类图
- en: 'The SizeUtilities class offers three public class constants indicated as {read-only}
    in the diagram: BITS_PER_BYTE, BYTES_PER_KILOBYTE, and BITS_PER _MEGABYTE. These
    will be useful for calculating file sizes. The class also offers a public static
    method called bitsToMegaBytes() that takes in a number of bits as a parameter
    and returns the corresponding number of megabytes to a given number of decimal
    places (or two by default). Meanwhile, the AudioClip class declares a new getSizeMegaBytes()
    method that returns a float representing the memory required for the clip in megabytes,
    with the help of the SizeUtilities class. Notice that the AudioClip class also
    has a modified __toString() method that includes the file size in megabytes in
    the object summary.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: SizeUtilities 类提供了三个公共类常量，图示中标明为{只读}：BITS_PER_BYTE、BYTES_PER_KILOBYTE 和 BITS_PER_MEGABYTE。这些常量将在计算文件大小时非常有用。该类还提供了一个名为
    bitsToMegaBytes() 的公共静态方法，该方法接收一个比特数作为参数，并返回相应的以兆字节为单位的数字（默认精确到两位小数）。同时，AudioClip
    类声明了一个新的 getSizeMegaBytes() 方法，借助 SizeUtilities 类返回一个表示该音频剪辑所需内存大小（以兆字节为单位）的浮动值。请注意，AudioClip
    类还修改了 __toString() 方法，该方法在对象摘要中包含了文件大小（以兆字节为单位）。
- en: Let’s declare the SizeUtilities class. Create *src/SizeUtilities.php* containing
    the code in [Listing 25-4](#lis25-4).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明 SizeUtilities 类。创建 *src/SizeUtilities.php* 文件，包含[清单 25-4](#lis25-4) 中的代码。
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 25-4: The SizeUtilities class with constants and a static method'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 25-4：包含常量和静态方法的 SizeUtilities 类
- en: We declare SizeUtilities as abstract, since all members of this class are either
    constants or static. Its BITS_PER_BYTE and BYTES_PER_KILOBYTE constants have values
    of 8 and 1024, respectively, and the BITS_PER_MEGABYTE constant is calculated
    based on them. The class’s bitsToMegaBytes() static method takes in a number of
    bits and divides it by the BITS_PER_MEGABYTE constant to return the equivalent
    number of megabytes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 SizeUtilities 声明为抽象类，因为该类的所有成员都是常量或静态成员。它的 BITS_PER_BYTE 和 BYTES_PER_KILOBYTE
    常量分别为 8 和 1024，而 BITS_PER_MEGABYTE 常量是基于这两个常量计算得出的。该类的 bitsToMegaBytes() 静态方法接受一个比特数，并将其除以
    BITS_PER_MEGABYTE 常量，以返回相应的兆字节数。
- en: Next, update *src/AudioClip.php* as shown in [Listing 25-5](#lis25-5).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，按照[清单 25-5](#lis25-5) 中的内容更新 *src/AudioClip.php* 文件。
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 25-5: Updating the AudioClip class to use SizeUtilities'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 25-5：更新 AudioClip 类以使用 SizeUtilities
- en: 'We add the getSizeMegaBytes() method, which returns a float representing the
    size of the AudioClip object in megabytes. The method gets the size in bits and
    passes it to the public static bitsToMegaBytes() method declared in our SizeUtilities
    class ❶. This is a good example of how to use public static methods in other classes:
    we don’t have to create an object of the SizeUtilities class in order to use its
    public static method. Instead, we simply write SizeUtilities:: followed by the
    name of the method.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '我们添加了 getSizeMegaBytes() 方法，该方法返回一个浮动值，表示 AudioClip 对象的大小（以兆字节为单位）。该方法获取比特数，并将其传递给我们在
    SizeUtilities 类中声明的公共静态方法 bitsToMegaBytes() ❶。这是一个很好的例子，展示了如何在其他类中使用公共静态方法：我们无需创建
    SizeUtilities 类的对象即可使用其公共静态方法，而是简单地写 SizeUtilities:: 后跟方法名。'
- en: 'In the new __toString() method, we create a temporary $numMegaBytesFormatted
    variable holding the clip size in megabytes, formatted as a string with two decimal
    places. We then include the value of this variable as part of the string returned
    by the method. Once again, we don’t need to make any changes to the index script
    to test our updates, since we’re still using __toString() to output information.
    Here’s the terminal output of the updates:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 __toString() 方法中，我们创建了一个临时的 $numMegaBytesFormatted 变量，保存了以兆字节为单位的剪辑大小，并将其格式化为带有两位小数的字符串。然后，我们将这个变量的值作为字符串的一部分返回。再一次，我们不需要对索引脚本做任何更改来测试我们的更新，因为我们仍然使用
    __toString() 来输出信息。以下是更新后的终端输出：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The size of each AudioClip object is now given in megabytes. Our new utility
    class has successfully helped the AudioClip class make the necessary bits-to-megabytes
    conversions through its static method and class constants.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 AudioClip 对象的大小现在以兆字节为单位给出。我们新的实用类成功地帮助 AudioClip 类通过其静态方法和类常量完成了位到兆字节的转换。
- en: Sharing Resources Across an Application
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在应用程序中共享资源
- en: Another use of static methods is to offer a functionality (such as reading from
    or writing to a database, or appending messages to a logfile) to all parts of
    a software system, without each part of the system needing to duplicate the required
    setup code. The idea is to create an abstract class with static methods that do
    the necessary legwork, like establishing a database connection or setting up a
    logger and log handler. Then you can call those static methods from anywhere in
    your code whenever you need that functionality. This makes processes like logging
    or working with a database connection quite straightforward.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法的另一种用途是为软件系统的所有部分提供功能（例如从数据库读取或写入，或将消息附加到日志文件），而无需每个部分都重复所需的设置代码。其思路是创建一个包含静态方法的抽象类，这些方法负责执行必要的工作，比如建立数据库连接或设置日志记录器及日志处理器。然后，您可以在代码中的任何地方调用这些静态方法，每当您需要该功能时。这样，像日志记录或与数据库连接的操作就变得非常简单。
- en: 'To illustrate how this works, let’s create a project that allows logging from
    anywhere in the system just by writing something like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这如何工作，我们来创建一个项目，允许在系统中的任何地方进行日志记录，只需像这样写：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For this to work, we’ll need a Logger class with a public static debug() method
    that can be invoked from anywhere in the system. This method will handle the mechanics
    of the logging process so that the other parts of the system don’t have to.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个功能工作，我们需要一个具有公共静态 debug() 方法的 Logger 类，该方法可以在系统中的任何地方调用。这个方法将处理日志记录过程的细节，这样系统的其他部分就不需要处理这些。
- en: 'Start a new project folder and create the usual *composer.json* file to autoload
    the Mattsmithdev namespaced classes. Then enter this command at the command line
    to add the Monolog library to the project:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目文件夹并创建通常的 *composer.json* 文件来自动加载 Mattsmithdev 命名空间的类。然后在命令行中输入此命令将
    Monolog 库添加到项目中：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since we have a *composer.json* file, Composer will also generate the autoloader
    scripts at this step, in addition to loading the Monolog library. All the relevant
    files will be in your project’s *vendor* directory.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个 *composer.json* 文件，Composer 在这一步也会生成自动加载脚本，除了加载 Monolog 库外，所有相关文件都会放在您的项目的
    *vendor* 目录中。
- en: Next, create a custom Logger class in *src/Logger.php* as shown in [Listing
    25-6](#lis25-6).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个自定义的 Logger 类，文件位置为 *src/Logger.php*，如[示例 25-6](#lis25-6)所示。
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 25-6: The Logger class with a public static logging method'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 25-6：具有公共静态日志记录方法的 Logger 类
- en: We declare our Logger class in the Mattsmithdev namespace to avoid a naming
    collision with the Monolog library’s Logger class and designate it as abstract
    since we won’t ever need to instantiate it. The use statements allow us to refer
    to the necessary Monolog classes in our code without having to write fully qualified
    namespaces. Notice that we alias Monolog’s Logger class as MonologLogger to better
    differentiate it from our own class ❶.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Mattsmithdev 命名空间中声明 Logger 类，以避免与 Monolog 库的 Logger 类发生命名冲突，并将其指定为抽象类，因为我们永远不需要实例化它。use
    语句允许我们在代码中引用 Monolog 类，而无需编写完整的命名空间。请注意，我们将 Monolog 的 Logger 类别名为 MonologLogger，以便与我们自己的类更好地区分
    ❶。
- en: Inside the class, we create a constant for the filepath to *logs/debug.log*.
    Then we declare debug() as a public static method that takes a $message string
    parameter ❷. The method creates a new MonologLogger object for channel1 and assigns
    it a log handler for writing to the debug logfile, then uses the Monolog class’s
    debug() method to log $message to the logfile.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在类内，我们为*logs/debug.log*的文件路径创建一个常量。然后我们将debug()声明为一个公共静态方法，它接受一个$message字符串参数❷。该方法为channel1创建一个新的MonologLogger对象，并为其分配一个日志处理器，用于将信息写入调试日志文件，然后使用Monolog类的debug()方法将$message记录到日志文件中。
- en: Now create an index script in *public/index.php* containing the code in [Listing
    25-7](#lis25-7).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在*public/index.php*中创建一个索引脚本，包含[清单 25-7](#lis25-7)中的代码。
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 25-7: Creating an Application object in index.php'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 25-7：在index.php中创建Application对象
- en: We read in and execute the Composer-generated autoloader, create an object of
    the Application class, and invoke its run() method. This is the same basic pattern
    for the index script of an object-oriented web application that we discussed in
    [Chapter 21](chapter21.xhtml).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取并执行Composer生成的自动加载器，创建一个Application类的对象，并调用它的run()方法。这是我们在[第21章](chapter21.xhtml)中讨论的面向对象的Web应用程序索引脚本的基本模式。
- en: Finally, declare the Application class in *src/Application.php* as shown in
    [Listing 25-8](#lis25-8). The class includes code for logging messages via our
    Logger class’s static method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*src/Application.php*中声明Application类，如[清单 25-8](#lis25-8)所示。该类包括通过我们Logger类的静态方法记录消息的代码。
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 25-8: The Application class'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 25-8：应用程序类
- en: 'In the Application class’s run() method, we print out a ''Hello, world!'' message.
    Then we invoke the static debug() method of our Logger class to log messages to
    the debug logfile. Notice that we don’t need to create a Logger object or include
    any setup code (such as declaring a path to the logfile or creating a log handler)
    in the Application class itself; everything is handled by the static method we
    defined on the Logger class. If the Application and Logger classes were in different
    namespaces, all we’d need to do is add a use statement or fully qualify the class
    when using it, like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Application类的run()方法中，我们打印出一个“Hello, world!”消息。然后我们调用Logger类的静态debug()方法，将消息记录到调试日志文件中。请注意，我们不需要在Application类中创建Logger对象或包含任何设置代码（例如声明日志文件路径或创建日志处理器）；所有这些都由我们在Logger类中定义的静态方法处理。如果Application类和Logger类位于不同的命名空间，我们只需在使用时添加use语句或完全限定类名，像这样：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can confirm that the two messages have been appended to the logfile by viewing
    the contents of *logs/debug.log* after running the index script. Remember to use
    the cat command (macOS and Unix) or type (Windows), as discussed in [Chapter 24](chapter24.xhtml).
    You should see something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行索引脚本后查看*logs/debug.log*的内容来确认这两条消息已经被附加到日志文件中。记得使用cat命令（macOS和Unix）或type命令（Windows），如[第24章](chapter24.xhtml)所讨论的那样。你应该能看到类似这样的内容：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We’ve successfully used our static method to append messages to the logfile.
    If we wanted, we could add optional arguments to this method to change the name
    and location of the logfile, log to different channels, or provide a context array
    such as an Exception object. This basic example has illustrated generally how
    a class can offer a single static method to make it easy for any part of a software
    system to utilize its functionality.  ### Saving Resources with the Singleton
    Pattern'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '我们成功地使用我们的静态方法将消息附加到日志文件。如果我们愿意，可以向此方法添加可选参数，以更改日志文件的名称和位置，记录到不同的频道，或提供一个上下文数组，例如异常对象。这个基本示例一般说明了一个类如何提供一个静态方法，使得软件系统中的任何部分都可以轻松利用它的功能。
    ### 使用单例模式节省资源'
- en: The approach we used in the preceding section to share resources across an application
    can work in many situations, but in some cases, such as creating a connection
    to a database or setting up a mailing or file-writing object, the static method’s
    task takes up enough time and memory to impair the application’s performance.
    In cases like these, an object-oriented design technique called the *singleton
    pattern* can help conserve computing resources while still making an operation
    available throughout an application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一部分中使用的共享资源的方法可以在许多情况下工作，但在某些情况下，比如创建数据库连接或设置邮件或文件写入对象，静态方法的任务会占用足够的时间和内存，影响应用程序的性能。在这些情况下，一种叫做*单例模式*的面向对象设计技术可以帮助节省计算资源，同时仍然使得操作在整个应用程序中可用。
- en: Take a look back the last section of [Listing 25-6](#lis25-6), where we declared
    our Logger class. According to our definition of the static debug() method, a
    new MonologLogger object and a new StreamHandler object will be created each time
    the method is invoked to log a debug message. In our application’s run() method
    in [Listing 25-8](#lis25-8), we invoked this method twice, so four objects were
    created to log the two messages, which is a bit wasteful. When operations are
    resource expensive, a more efficient approach is to perform them once and then
    *cache* (store) the created resources for future use. The singleton pattern is
    one way of doing this.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下上一节的[Listing 25-6](#lis25-6)，我们在其中声明了Logger类。根据我们对静态debug()方法的定义，每次调用该方法记录调试信息时，都会创建一个新的MonologLogger对象和一个新的StreamHandler对象。在我们应用程序的run()方法中（见[Listing
    25-8](#lis25-8)），我们调用了该方法两次，因此为了记录两条信息，创建了四个对象，这有点浪费。当操作消耗资源时，更高效的做法是只执行一次，然后*缓存*（存储）这些创建的资源以供以后使用。单例模式就是一种实现方式。
- en: The singleton pattern declares a class with a private constructor, along with
    logic to ensure that, at most, we create only one object of the class. The class
    offers a public static method named getInstance() that returns a reference to
    the single instance of the class. If no instance exists, one is created the first
    time the getInstance() method is invoked. Otherwise, the class caches, or keeps
    a record of, the single instance, so it can be returned again the next time getInstance()
    is called.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式声明了一个具有私有构造函数的类，并添加了逻辑来确保最多只创建一个类的对象。该类提供了一个名为getInstance()的公共静态方法，用于返回类的唯一实例的引用。如果没有实例存在，则在第一次调用getInstance()方法时创建一个实例。否则，类会缓存或记录该唯一实例，以便下次调用getInstance()时返回同一个实例。
- en: 'Anytime you need to use the singleton class, you’d write something like this
    from anywhere in your code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你需要使用单例类时，可以在代码中的任何地方写类似如下的代码：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This stores a reference to the sole instance of the singleton class in the $myObject
    variable. You can then use the Singleton class’s resources through the $myObject
    reference. [Listing 25-9](#lis25-9) shows the typical skeleton for singleton-style
    classes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把对单例类唯一实例的引用存储在$myObject变量中。然后，你可以通过$myObject引用使用Singleton类的资源。[Listing 25-9](#lis25-9)展示了单例风格类的典型骨架。
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 25-9: The Singleton class'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 25-9：Singleton类
- en: We declare a private static property called instance, initializing it to NULL.
    Ultimately, this property will hold a reference to the only object of the singleton
    class. Then we declare a private constructor method where any resource-hungry
    work can be completed. Since the constructor has been declared as private, it
    can’t be invoked with the new keyword from anywhere outside the class itself.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个名为instance的私有静态属性，并将其初始化为NULL。最终，这个属性将保存对单例类唯一对象的引用。然后，我们声明了一个私有构造方法，在这里可以完成任何资源密集型的工作。由于构造方法被声明为私有的，它不能在类外部通过new关键字调用。
- en: Next, we declare the only public member of this class, the static getInstance()
    method. This method first tests whether the instance is NULL ❶. If so, this must
    be the first time that this method has been invoked, so a new Singleton object
    is created (which calls the constructor, triggering the resource-heavy work),
    and the reference to the new object is stored in the static instance property
    ❷. Then the method returns the object reference in instance, making the object
    available for use elsewhere in the application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明该类唯一的公共成员：静态的getInstance()方法。该方法首先测试instance是否为NULL ❶。如果是，这必定是第一次调用该方法，因此会创建一个新的Singleton对象（这会调用构造函数，触发资源密集型的工作），并将新对象的引用存储在静态instance属性中
    ❷。然后，方法返回instance中的对象引用，使得该对象可以在应用程序的其他地方使用。
- en: Let’s modify the previous section’s project to save computing resources by using
    the singleton pattern. This way, we’ll have to create the Logger object and log
    handler only once, no matter how many messages we log. We’ll also make our application
    more flexible by making our custom Logger class a subclass of Monolog’s Logger
    class so that we can use any of the latter’s methods and optional arguments (for
    example, to provide context data and to log at different severity levels through
    the inherited methods).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改前一节的项目，使用单例模式来节省计算资源。这样，无论我们记录多少条消息，我们都只需要创建一次Logger对象和日志处理器。通过将自定义的Logger类设置为Monolog的Logger类的子类，我们还可以使应用程序更加灵活，这样我们就能使用后者的任何方法和可选参数（例如，提供上下文数据以及通过继承的方法记录不同严重程度的日志）。
- en: First, update the declaration of the Logger class in *src/Logger.php* to match
    [Listing 25-10](#lis25-10). This redesigned class is closely modeled on the skeletal
    Singleton class demonstrated in [Listing 25-9](#lis25-9).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更新*src/Logger.php*中Logger类的声明，使其与[列表25-10](#lis25-10)一致。这个重新设计的类 closely
    modeled on [列表25-9](#lis25-9)中演示的骨架单例类。
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 25-10: Implementing the Logger class with the singleton pattern'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表25-10：实现使用单例模式的Logger类
- en: 'We declare our Logger class as a subclass of the Monolog Logger class (aliased
    as MonoLogger) ❶. Since we’ll be creating one instance of this class, we no longer
    declare it to be abstract. Next, we initialize the private static instance property
    to NULL and declare a private constructor. The constructor uses parent:: to call
    the Monolog Logger class’s constructor, creating a new object with channel1, then
    assigns it a log handler to the debug logfile. Since all this is encapsulated
    within the private constructor, it will happen only once.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将Logger类声明为Monolog Logger类的子类（别名为MonoLogger）❶。由于我们将只创建此类的一个实例，因此不再将其声明为抽象类。接下来，我们将私有静态实例属性初始化为NULL，并声明一个私有构造函数。构造函数使用parent::调用Monolog
    Logger类的构造函数，创建一个带有channel1的新对象，然后将其分配一个调试日志文件的日志处理程序。由于这一切都封装在私有构造函数内，因此它只会执行一次。
- en: We also declare the public static getInstance() method, typical for singleton
    classes ❷. The method follows the logic described in [Listing 25-9](#lis25-9),
    creating and returning a Logger object if instance is NULL, or simply returning
    the instance if it’s been created already.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了公共静态方法getInstance()，这是典型的单例类方法❷。该方法遵循[列表25-9](#lis25-9)中描述的逻辑，如果实例为NULL，则创建并返回一个Logger对象，或者如果实例已经创建，则直接返回该实例。
- en: Now let’s update the run() method of our Application class. We’ll obtain a reference
    to the single instance of our Logger class, then use that object reference to
    log some entries. Modify *src/Application.php* to match [Listing 25-11](#lis25-11).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新我们应用程序类的run()方法。我们将获取Logger类的单一实例的引用，然后使用该对象引用记录一些条目。修改*src/Application.php*，使其与[列表25-11](#lis25-11)一致。
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 25-11: The Application class updated to use our singleton Logger class'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表25-11：更新后的应用程序类，使用我们的单例Logger类
- en: We get a reference to the singleton instance of Logger by writing Logger::getInstance()
    and use it to log a warning-severity message via the warning() method inherited
    from the Monolog Logger class. Since this is the first attempt to get the singleton
    instance, the instance property of our Logger class will be NULL, and a new Logger
    object will be created and a reference to it saved in instance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过编写Logger::getInstance()获取Logger单例实例的引用，并使用它通过继承自Monolog Logger类的warning()方法记录一个警告级别的消息。由于这是第一次尝试获取单例实例，因此Logger类的实例属性为NULL，将创建一个新的Logger对象并将其引用保存在实例中。
- en: Then we again get a reference to the singleton instance of Logger and log an
    error-severity message, creating and passing a second parameter of a new Exception
    object as the context. This time, the instance property of Logger isn’t NULL,
    so the reference to the existing object is returned. In this way, both logs have
    been created by a single instance of the Logger class, saving time and resources
    while still making the logging functionality available anywhere in the application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次获取Logger单例实例的引用并记录一个错误级别的消息，创建并传递一个新的Exception对象作为上下文的第二个参数。这次，Logger的实例属性不是NULL，因此返回现有对象的引用。通过这种方式，两个日志条目都是由Logger类的单一实例创建的，从而节省了时间和资源，同时在应用程序的任何地方仍然可以使用日志功能。
- en: 'Use the cat or type command to view the contents of *logs/debug.log* after
    running the index script. You should see something like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运行index脚本后，使用cat或type命令查看*logs/debug.log*的内容。你应该能看到如下内容：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Both messages were successfully appended to the logfile, including the Exception
    object context data added to the error-level log entry.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 两条消息已成功附加到日志文件中，包括添加到错误级别日志条目的异常对象上下文数据。
- en: You’ve seen how the singleton pattern can be useful. However, many programmers
    consider it an *antipattern*, a solution to a common problem that ends up being
    worse than the problem it’s attempting to solve. Critics of the singleton pattern
    object to it being a form of global program state, which makes testing code more
    difficult since code using the singleton can’t be tested separately from the singleton
    itself. Also, the singleton has *global visibility*, meaning that any code in
    an application might be dependent on it. More complex code analysis is therefore
    needed to determine which parts of an application are or aren’t dependent on the
    globally visible singleton. On the other hand, proponents argue that the reduction
    in resource usage is enough to outweigh some overhead in testing or the design
    of other parts of the application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了单例模式的有用之处。然而，许多程序员认为它是一个*反模式*，即解决常见问题的方案，结果却比它试图解决的问题更糟。单例模式的批评者反对它作为一种全局程序状态，这使得代码测试变得更加困难，因为使用单例的代码不能与单例本身分开测试。此外，单例具有*全局可见性*，意味着应用程序中的任何代码都可能依赖于它。因此，需要更复杂的代码分析来确定应用程序中哪些部分依赖于或不依赖于全局可见的单例。另一方面，支持者认为，资源使用的减少足以抵消一些测试或其他部分设计上的开销。
- en: Enumerations
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举
- en: To *enumerate* is to list out every possibility, one by one, and in computer
    programming, an *enumeration* is a list of all the possible values for a data
    type. A good example of an enumerated data type is bool, which lists its only
    two possible values as true and false. Booleans are built into the language, but
    since version 8.1, PHP allows you to create and use your own custom enumerations,
    also known as *enum classes*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*枚举*是逐一列举每一个可能性，在计算机编程中，*枚举*是数据类型所有可能值的列表。一个很好的枚举数据类型例子是 bool，它列出了唯一的两个可能值：true
    和 false。布尔值是语言内建的，但从 8.1 版本开始，PHP 允许你创建并使用自己的自定义枚举类型，也被称为*枚举类*。'
- en: Enum classes are useful when you have data items that can take only one of a
    closed set of values. For example, a pizza order can be designated as being for
    delivery or pickup, an employee’s work status can be full-time or part-time, and
    a playing card’s suit can be hearts, diamonds, clubs, or spades. While you could
    use a Boolean property when you have only two potential values (for example, $fullTime
    = false), enum classes are more appropriate when you have more than two possibilities.
    Even for just two possible values, defining them through an enum class makes the
    choice more explicit.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有的数据项只能取闭合集合中的一个值时，枚举类非常有用。例如，一张披萨订单可以指定为外送或自取，员工的工作状态可以是全职或兼职，扑克牌的花色可以是红桃、方块、梅花或黑桃。虽然当你只有两个可能值时可以使用布尔属性（例如，$fullTime
    = false），但当有超过两个可能值时，枚举类更为合适。即使只有两个可能值，通过枚举类来定义它们也能使选择更加明确。
- en: Inside an enum class, you declare each of the possible cases for that class,
    where each case is an object of the class. For example, you might have a playing
    card Suit enum class with possible cases HEARTS, DIAMONDS, CLUBS, and SPADES.
    To reference the cases of an enum class, you use the same double-colon syntax
    (the scope resolution operator) as when using a static member or class constant
    (for example, $card1Suit = Suit::SPADES).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个枚举类内部，你声明该类的每个可能案例，每个案例都是该类的一个对象。例如，你可能有一个扑克牌花色的枚举类，其中的可能案例包括 HEARTS、DIAMONDS、CLUBS
    和 SPADES。要引用枚举类的案例，你使用与使用静态成员或类常量时相同的双冒号语法（作用域解析运算符）（例如，$card1Suit = Suit::SPADES）。
- en: Because of this shared syntax, enum classes bear some relationship to static
    members and class constants. The key difference is that each case of an enum class
    is a proper *object* of that class, whereas class constants and static properties
    and methods are *members* of a class. Crucially, this means that enum classes
    can serve as the data types for properties of other classes, and for function
    parameters and return values.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种共享的语法，枚举类与静态成员和类常量有一定的关系。主要的区别在于，枚举类的每个案例都是该类的一个真正的*对象*，而类常量和静态属性、方法是类的*成员*。关键是，这意味着枚举类可以作为其他类的属性的数据类型，以及函数的参数和返回值。
- en: As a simple example, [Listing 25-12](#lis25-12) shows the declaration of an
    enum class for the suits of a deck of playing cards. Declare this enum class in
    a file called *Suit.php*, just like an ordinary class declaration file.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个简单的例子，[Listing 25-12](#lis25-12) 显示了扑克牌花色的枚举类声明。像普通的类声明文件一样，在名为 *Suit.php*
    的文件中声明此枚举类。
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 25-12: The Suit enum class'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 25-12: Suit 枚举类'
- en: After the namespace, we use the enum keyword followed by the class name Suit.
    Then we declare four cases for this enum class, representing the four playing
    card suits. Because the enumeration cases serve a similar function as class constants
    (that is, defining fixed values), I tend to write them in all capital letters,
    although many programmers capitalize only the first letter of each case.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名空间之后，我们使用 enum 关键字，后跟类名 Suit。然后我们为这个枚举类声明了四个案例，代表四种扑克牌花色。因为枚举案例的作用类似于类常量（即定义固定值），我倾向于将它们写成全大写，尽管许多程序员只将每个案例的第一个字母大写。
- en: We can now assign an object of the Suit enum class to a variable. To illustrate,
    [Listing 25-13](#lis25-13) shows a simple Card class that harnesses the Suit enum.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将 Suit 枚举类的对象分配给一个变量。为了说明，[Listing 25-13](#lis25-13) 展示了一个简单的 Card 类，利用了
    Suit 枚举。
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 25-13: The Card class with a suit property that uses the Suit enum
    class'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 25-13: 带有使用 Suit 枚举类的 suit 属性的 Card 类'
- en: We first declare suit as a property of the Suit data type ❶. Again, since enums
    are considered classes, they can be used as valid data types. We also give the
    class a number property, and we provide simple getters and setters for both suit
    and number. Then we declare a __toString() method to output the details of the
    Card object’s properties ❷. In it, we get a string version of the enum object’s
    name from its name property, accessed with the expression $this->suit->name.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将 suit 声明为 Suit 数据类型的属性 ❶。再次强调，由于枚举被视为类，它们可以用作有效的数据类型。我们还为类添加了一个数字属性，并为
    suit 和 number 提供了简单的 getter 和 setter。然后我们声明一个 __toString() 方法来输出 Card 对象属性的详细信息
    ❷。在其中，我们从其 name 属性获取枚举对象名称的字符串版本，通过表达式 $this->suit->name 访问。
- en: Listing 25-14 shows a simple index script to demonstrate the use of the Suit
    and Card classes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 25-14 展示了一个简单的索引脚本，演示了 Suit 和 Card 类的使用。
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 25-14: Using Card and Suit in an index script'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 25-14: 使用 Card 和 Suit 在索引脚本中'
- en: 'After providing use statements for the two classes, we create a new Card object
    and set its suit property to be a reference to the SPADES case of the Suit enum
    class, using the double-colon Suit::SPADES syntax to reference the case ❶. We
    also set the number of this Card object to 1 (representing an ace). Then we print
    the details of the $card1 variable, which will invoke its __toString() method.
    Here’s the output of running this index script:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在为这两个类提供使用语句后，我们创建一个新的 Card 对象，并将其 suit 属性设置为 Suit 枚举类的 SPADES 案例的引用，使用双冒号 Suit::SPADES
    语法引用案例 ❶。我们还将此 Card 对象的 number 设置为 1（代表一张 Ace）。然后我们打印 $card1 变量的详细信息，这将调用其 __toString()
    方法。运行此索引脚本的输出如下：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The output shows the number property of 1 and the string SPADES, the name of
    the Suit enum class referenced in the object’s suit property.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了数字属性为 1 和字符串 SPADES，这是对象的 suit 属性中引用的 Suit 枚举类的名称。
- en: Backed Enums
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 支持的枚举
- en: Besides giving enum cases names like SPADES and HEARTS, you can also associate
    an integer or string value with each case. When you give the cases values, the
    class is called a *value-backed enum*, or *backed enum* for short. The type of
    int or string must be declared after the enum class name, and every case must
    be assigned a value; otherwise, an error will occur.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了给枚举案例命名如 SPADES 和 HEARTS 外，你还可以将整数或字符串值与每个案例关联起来。当你给案例赋值时，该类被称为*值支持的枚举*，或简称*支持的枚举*。必须在枚举类名后声明
    int 或 string 类型，并且必须为每个案例分配一个值；否则将会出现错误。
- en: Let’s turn Suit into a backed enum by assigning a string value for each case.
    We could choose strings that exactly match the case names ('HEARTS', 'CLUBS',
    and so on), or we could have a bit of fun and assign strings with the corresponding
    card suit symbols. See [Listing 25-15](#lis25-15) for the updated Suit declaration.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过为每个案例分配一个字符串值将 Suit 转换为支持的枚举。我们可以选择与案例名称完全匹配的字符串（'HEARTS'、'CLUBS' 等），或者我们可以玩得开心一点，分配具有相应扑克牌花色符号的字符串。请参见
    [Listing 25-15](#lis25-15) 中更新后的 Suit 声明。
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 25-15: Turning Suit into a backed enum class'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 25-15: 将 Suit 转换为支持的枚举类'
- en: We declare Suit as a string-backed enum by adding a colon and the string type
    after the class name. Then we assign the string '♣' as the value for the CLUBS
    case, as well as the corresponding symbols for the other three suits. To retrieve
    the value of a backed enum, use its public value property. For example, if the
    $card1Suit variable were a reference to a Suit enum object, we’d get its string
    value with the expression $card1Suit->value. These values are read-only; once
    they’re set in the enum class declaration, they can’t be changed from elsewhere
    in the code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在类名后添加冒号和字符串类型来声明 Suit 为一个字符串类型的枚举类型。然后，我们将字符串 '♣' 作为 CLUBS 的值，并为其他三个花色分配相应的符号。要获取一个枚举类型的值，可以使用其公开的
    value 属性。例如，如果 $card1Suit 变量是指向 Suit 枚举对象的引用，我们可以通过表达式 $card1Suit->value 来获取它的字符串值。这些值是只读的；一旦在枚举类声明中设置，它们就不能在代码的其他地方被更改。
- en: An Array of All Cases
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 所有情况的数组
- en: All enum classes have a built-in static method called cases() that returns an
    array of all the case objects for the enumeration. We can use this to build an
    array of the values associated with the cases. For example, [Listing 25-16](#lis25-16)
    shows an index script that does just this by looping through each Suit case object
    and appending its string value to an array for printout.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所有枚举类都有一个内置的静态方法 cases()，它返回一个包含所有枚举案例对象的数组。我们可以利用这个方法来构建一个包含案例关联值的数组。例如，[列表
    25-16](#lis25-16) 显示了一个索引脚本，利用循环遍历每个 Suit 枚举对象，并将其字符串值附加到一个数组中进行打印。
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 25-16: Creating an array of all Suit enum case values'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 25-16：创建所有 Suit 枚举案例值的数组
- en: 'We call the Suit::cases() static method to obtain a $cases array holding an
    instance of each possible Suit case. Then we initialize $caseStrings as an empty
    array. Next, we loop through the Suit case objects in $cases and append their
    string values to the $caseStrings array. Finally, we print out the array of strings
    as a single string by using the built-in implode() function. Here’s the output
    of running this index script at the command line:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 Suit::cases() 静态方法来获取一个包含每个可能 Suit 枚举值的实例的 $cases 数组。然后我们将 $caseStrings
    初始化为空数组。接下来，我们遍历 $cases 中的 Suit 枚举对象，并将它们的字符串值附加到 $caseStrings 数组中。最后，我们使用内置的
    implode() 函数将字符串数组打印为一个单一的字符串。以下是运行此索引脚本时在命令行上的输出：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: All four suit characters have been printed out on the same line. Here we’ve
    simply printed out the case values, but we could use a similar looping technique
    to, for example, create a drop-down menu of all the case values from an enum class
    so that a user can select one of the options.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有四个花色的字符都已经在同一行打印出来。在这里，我们仅仅打印了案例值，但我们也可以使用类似的循环技术，例如，从枚举类中创建一个包含所有案例值的下拉菜单，用户可以选择其中一个选项。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小结
- en: 'In this chapter, we explored static members of classes: properties and methods
    that aren’t related directly to individual objects but belong to the class as
    a whole. You saw how static members can be accessed within the class via self::
    and outside the class via ClassName:: (assuming the static member is public).
    You learned about uses of static members, including to record class-wide information,
    provide common methods through utility classes, and share functionality across
    an application, through either an abstract class or the singleton design pattern.
    We also discussed the related concepts of class constants and enumeration classes.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '本章中，我们探讨了类的静态成员：这些成员与个别对象无关，而是属于整个类。你已经看到了如何通过 self:: 在类内访问静态成员，以及如何通过 ClassName::
    在类外访问静态成员（假设静态成员是 public）。你了解了静态成员的使用，包括记录类范围的信息、通过工具类提供公共方法、以及通过抽象类或单例设计模式在应用程序中共享功能。我们还讨论了与类常量和枚举类相关的概念。'
- en: Exercises
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 1.   Create a new project to implement a Car class representing various cars.
    As shown in [Figure 25-4](#fig25-4), this class should have instance properties
    for make, model, and price, and a constructor taking in values for each instance
    property when a new object is created. You should also have private static properties
    for totalPrice and numInstances.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   创建一个新的项目来实现一个 Car 类，表示不同的汽车。如图 [25-4](#fig25-4) 所示，该类应该具有表示品牌、型号和价格的实例属性，并且在创建新对象时，通过构造函数传入每个实例属性的值。你还应该有
    private 静态属性用于 totalPrice 和 numInstances。
- en: '![](../images/figure25-4.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure25-4.jpg)'
- en: 'Figure 25-4: The Car class'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25-4：Car 类
- en: Each time a new Car object is created, the constructor method should increment
    numInstances and add the price of the new Car object to totalPrice.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建一个新的 Car 对象时，构造函数方法应该增加 numInstances，并将新创建的 Car 对象的价格加到 totalPrice 上。
- en: 2.   Add a public static averagePrice() method to the Car class from Exercise
    1 that uses the static numInstances and totalPrice properties to calculate and
    return the average price of all Car objects that have been created.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   在练习1中的Car类中添加一个公共静态方法averagePrice()，该方法使用静态的numInstances和totalPrice属性来计算并返回所有已创建的Car对象的平均价格。
- en: '3.   Create a new project featuring an enum class called DietType with three
    cases: VEGAN, VEGETARIAN, and CARNIVORE. Also create a Dessert class that has
    a name property (a string) and a diet property (a DietType enum case), as well
    as a __toString() method that summarizes the Dessert object in the form ''(DESSERT)
    Dessert Name (DietType dish)''. Write an index script that creates a Dessert object
    and prints its details. The output should be something like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   创建一个新项目，包含一个名为DietType的枚举类，其中有三个值：VEGAN（纯素）、VEGETARIAN（素食）、CARNIVORE（食肉）。同时创建一个Dessert类，具有name属性（一个字符串）和diet属性（一个DietType枚举值），并且包含一个__toString()方法，用于以'(DESSERT)
    甜点名称 (DietType 菜肴)'的形式总结Dessert对象。编写一个索引脚本，创建一个Dessert对象并打印其详细信息。输出应类似于以下内容：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
