- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 25 STATIC METHODS, PROPERTIES, AND ENUMERATIONS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll explore *static members*. Unlike the instance-level properties
    and methods we’ve been using so far, which are accessible through the individual
    objects of a class, static properties and methods are accessed through the class
    as a whole. As such, you don’t have to create an object of a class to use its
    static members.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss how to work with static members and illustrate their usefulness
    in situations such as storing information about all the instances of a class or
    sharing resources across an entire application. We’ll also touch on enumerations,
    which provide a way to list all possible values for a data type.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Class-Wide Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One common use of static members is to keep track of information about all instances
    of a class. This is handy when a message needs to be sent to all objects of a
    class, or when a calculation must be based on just the class’s current instances.
    Consider the AudioClip class diagrammed in [Figure 25-1](#fig25-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure25-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 25-1: An AudioClip class with static members'
  prefs: []
  type: TYPE_NORMAL
- en: The AudioClip class has instance members for storing details about a given audio
    file. These are the title and durationSeconds properties, with their associated
    getters and setters. The constructor and __toString() method are instance members
    as well, since they pertain to creating or summarizing the contents of a particular
    object. Meanwhile, the class has a maxClipDurationSeconds property that tracks
    the longest duration of any AudioClip objects that have been created. This is
    a good use of a static member (indicated by underlining in the diagram), since
    the property holds information pertaining to all the objects of the class. The
    property’s getter method should also be static.
  prefs: []
  type: TYPE_NORMAL
- en: To see how static members are useful for storing class-wide information, we’ll
    declare the AudioClip class and create three instances of it. The diagram shows
    how each instance will have its own values for the title and durationSeconds properties.
    For example, clip1 will have a title of 'Hello World' and a durationSeconds of
    2.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project folder and add the usual *composer.json* file declaring
    that Mattsmithdev namespaced classes are located in the *src* folder. Generate
    the autoloader file by entering composer dump-autoload at the command line. Then
    declare the AudioClip class by creating *src/AudioClip.php* and entering the contents
    of [Listing 25-1](#lis25-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-1: The AudioClip class'
  prefs: []
  type: TYPE_NORMAL
- en: We declare maxClipDurationSeconds by using the static keyword to specify that
    this is a static member that exists independent of any objects of the AudioClip
    class ❶. We initialize it to -1, ensuring that whatever the duration of the first
    AudioClip object to be created, its duration will be greater than -1 and so will
    be stored in this static property. We’ll see how this is done later, as part of
    the setDurationSeconds() setter method.
  prefs: []
  type: TYPE_NORMAL
- en: We set maxClipDurationSeconds to be private, but we declare a public getter
    method, getMaxClipDurationSeconds(), which is also static ❷. Making this method
    public allows code inside and outside the class to query the value of the longest
    AudioClip object that’s been created since the program or request has been running.
    We’ll explore what this implies and how this property is used shortly.
  prefs: []
  type: TYPE_NORMAL
- en: We next declare two instance-level properties for each AudioClip object, title
    and durationSeconds ❸, with a default value of 0 for the latter to ensure that
    it’s set even if an invalid argument is provided at construction. The class’s
    constructor method ❹ takes in initial values for these two properties and sets
    them in the object by invoking the appropriate setters.
  prefs: []
  type: TYPE_NORMAL
- en: The instance-level accessor methods are all straightforward, save for setDurationSeconds(),
    which has custom validation logic ❺. A clip’s duration should never be negative,
    so we first test for this and use return to halt execution of the method with
    no further action if a negative value is provided. If we make it past that point,
    we know the provided argument is 0 or positive, so we store it in the object’s
    durationSeconds property.
  prefs: []
  type: TYPE_NORMAL
- en: Then we check whether the object’s new duration is greater than the value stored
    in the maxClipDurationSeconds static property. If it is, we update this property
    to equal the new duration. Since maxClipDurationSeconds starts off with a sentinel
    value of -1, and because of our validation at the beginning of the method, we
    know that no AudioClip objects will ever have a negative duration. Therefore,
    as soon as the first clip has been created with a valid duration, this static
    property will be set accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we have to use self:: to access the maxClipDurationSeconds property.
    This *scope resolution operator* (::) is the syntax for accessing a static member
    from within the same class.'
  prefs: []
  type: TYPE_NORMAL
- en: We complete the declaration of the class with the __toString() method ❻. It
    returns a string summarizing an AudioClip object’s contents, in the form (AudioClip)
    title (durationSeconds seconds).
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s put our class to work through an index script that creates AudioClip
    objects and outputs the changing value of the static maxClip DurationSeconds property.
    Create *public/index.php* as shown in [Listing 25-2](#lis25-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-2: The index.php script'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we print a message displaying the value of maxClipDurationSeconds, accessed
    via the public static getMaxClipDurationSeconds() method. Since we haven’t yet
    instantiated any AudioClip objects, the property should still have its initial
    value of -1. Notice that we have to prefix the static member’s name with AudioClip::
    rather than self::, since we’re writing this code from the index script and not
    from within the static members’ class. We then create three AudioClip objects,
    $clip1, $clip2, and $clip3, printing each one and then displaying the value of
    maxClipDurationSeconds again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output of running the index script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The max duration starts with a value of -1, but each time an AudioClip object
    with a nonnegative duration is created, this value is updated if the new clip
    is the longest, through the logic in the setDurationSeconds() method. After creating
    the hello world object, the max duration goes from -1 to 2. The value doesn’t
    change after the bad duration object is created with an invalid duration of -10.
    (Notice from the object’s printout that its duration is stored as 0, the default
    value, rather than -10, thanks to our initial validation logic in the setDurationSeconds()
    method.) Finally, after creating the My Way object, the max duration is updated
    to 275.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our logic for updating maxClipDurationSeconds has worked well for demonstration
    purposes, but it isn’t actually a good way to keep track of the longest AudioClip
    object, since it assumes that all the objects exist for the entire run of the
    application. Say we decide that we no longer want one of the audio clips (the
    user might choose to delete it from a list). Our current logic provides no way
    to roll back the maximum clip duration if that clip is deleted. A better approach
    might be to have an array of active AudioClip objects. Each time a clip is removed,
    we could then loop through the array and recalculate the duration of the longest
    active clip.  ### Static Properties vs. Class Constants'
  prefs: []
  type: TYPE_NORMAL
- en: Static properties aren’t to be confused with class constants. In both cases,
    only one copy of the static property or class constant exists on the class itself,
    rather than a separate copy on each instance of the class. However, class constants
    are immutable, so their value never changes. By contrast, the value of a static
    property can change (as you saw with maxClipDurationSeconds), just like the value
    of an ordinary property of an object. In this sense, the term *static* can be
    a bit misleading. All PHP object-oriented properties, whether they’re per-object
    instance properties or per-class static properties, begin with a dollar sign,
    which distinguishes them from constants.
  prefs: []
  type: TYPE_NORMAL
- en: Use a class constant when you have a value that should apply to all objects
    of a class and should never change. We’ve met class constants previously; one
    example is the PATH_TO_TEMPLATES constant used to create the Twig\Environment
    object for templating. In this case, the filepath to the templates folder should
    never change and would apply equally to any and all Twig\Environment objects.
    Other uses of a class constant include defining special values, like setting the
    maximum score for a school grade point average (GPA) to 4.0 or the neutral value
    for the pH acidity scale to 7.0.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of our AudioClip class, we might have class constants defining details
    like the number of channels or the sampling rate of the audio files, on the assumption
    that these will be standard across all audio clips. To explore the difference
    between class constants and static properties, we’ll add some class constants
    to our AudioClip project now. [Figure 25-2](#fig25-2) shows an updated diagram
    of the AudioClip class.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure25-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 25-2: Adding class constants and an extra method to the AudioClip class'
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram shows that the AudioClip class will now offer four public class
    constants, which are indicated as {read-only} in class diagrams. For our project,
    we’ll make some assumptions about the audio clips that the class represents: they’ll
    all be stereo (two channels) and store 16 bits per sample (CD-quality digital
    audio). The number of samples per second will always be 44,100, which is a common
    audio sampling rate. These values are indicated by the AudioClip class constants
    NUM_CHANNELS, BITS_PER_SAMPLE, and SAMPLES_PER _SECOND, and together they’re used
    to calculate the BITS_PER_SECOND constant.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For a more realistic example, these constants could be replaced by instance
    properties, since not all audio clips may conform to the standard laid out by
    the constants.*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also add a new getSizeBits() method that uses the class constants to calculate
    the number of bits required to store the audio clip in memory or on disk. Additionally,
    we’ll include the value from this new method as part of the object summary returned
    by the __toString() method.
  prefs: []
  type: TYPE_NORMAL
- en: To implement all these changes, edit the *src/AudioClip.php* file as shown in
    [Listing 25-3](#lis25-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-3: Adding constants and the getSizeBits() method to the AudioClip
    class'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common to list constants first when declaring a class, before any properties
    and methods, so we begin the AudioClip class by declaring the constants NUM_CHANNELS,
    BITS_PER_SAMPLE, and SAMPLES_PER_SECOND, with the values described previously.
    Then we declare BITS_PER_SECOND, which is an example of a *calculated constant*
    since its value is determined based on the values of the other constants rather
    than being set directly. By precalculating this value and storing it as a constant,
    we avoid having to repeat the calculation every time we need to convert from seconds
    of audio to bits of data. Notice the use of self:: to access the other constants
    in the BITS_PER_SECOND calculation. This syntax applies to accessing class constants
    from within the class, just as it does to accessing static members.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare getSizeBits(), a useful extra getter method for each AudioClip
    object. It returns an integer representing the number of bits required to store
    the audio clip, found by multiplying the precalculated BITS _PER_SECOND constant
    by the object’s durationSeconds property. We also update the __toString() method
    ❶, summarizing an AudioClip object’s contents including its size in bits, thanks
    to our new method. Notice that we use the built-in number_format() function to
    create a temporary $numBitsFormatted string variable. With the function’s default
    settings, this creates a more readable representation of the number with a comma
    separator every three digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the terminal output of running the index script again (no changes to
    the index script are needed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each AudioClip object printout now ends with the integer number of bits the
    clip data occupies, thanks to our class constants. Even for a two-second clip,
    over 2 million bits are needed (which is why we’ve formatted the number of bits
    with comma separators).
  prefs: []
  type: TYPE_NORMAL
- en: Utility Classes with Static Members
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Static members may also be created as part of *utility classes*; these exist
    to help other classes do their work and aren’t used to create objects. A utility
    class’s static members might store helpful information or perform basic, general-purpose
    calculations that might have uses in other projects or other parts of the current
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with our AudioClip example, let’s say we want to display the size
    of each audio clip in megabytes rather than bits. We’ll need a way to convert
    from bits to megabytes. We could refactor the AudioClip class’s getSizeBits()
    method to make the necessary calculation. This calculation, along with supporting
    pieces of information such as the number of bits in a byte, is general enough
    that it might be useful to other, non-audio parts of the project or to other projects
    entirely. Therefore, locating the necessary code in a utility class makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a utility class called SizeUtilities to help the AudioClip class
    calculate memory size. Often, utility classes aren’t used to create objects, and
    this will be the case for SizeUtilities. Since an object of this class will never
    be instantiated, we’ll declare SizeUtilities as abstract. By extension, since
    there will never be a SizeUtilities object, all the class’s members need to be
    accessible through the class as a whole. That is, SizeUtilities must consist of
    class-level constants and static members. [Figure 25-3](#fig25-3) shows a diagram
    of the modified AudioClip class and the new SizeUtilities utility class.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure25-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 25-3: A class diagram of AudioClip and SizeUtilities demonstrating static
    methods and properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SizeUtilities class offers three public class constants indicated as {read-only}
    in the diagram: BITS_PER_BYTE, BYTES_PER_KILOBYTE, and BITS_PER _MEGABYTE. These
    will be useful for calculating file sizes. The class also offers a public static
    method called bitsToMegaBytes() that takes in a number of bits as a parameter
    and returns the corresponding number of megabytes to a given number of decimal
    places (or two by default). Meanwhile, the AudioClip class declares a new getSizeMegaBytes()
    method that returns a float representing the memory required for the clip in megabytes,
    with the help of the SizeUtilities class. Notice that the AudioClip class also
    has a modified __toString() method that includes the file size in megabytes in
    the object summary.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s declare the SizeUtilities class. Create *src/SizeUtilities.php* containing
    the code in [Listing 25-4](#lis25-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-4: The SizeUtilities class with constants and a static method'
  prefs: []
  type: TYPE_NORMAL
- en: We declare SizeUtilities as abstract, since all members of this class are either
    constants or static. Its BITS_PER_BYTE and BYTES_PER_KILOBYTE constants have values
    of 8 and 1024, respectively, and the BITS_PER_MEGABYTE constant is calculated
    based on them. The class’s bitsToMegaBytes() static method takes in a number of
    bits and divides it by the BITS_PER_MEGABYTE constant to return the equivalent
    number of megabytes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, update *src/AudioClip.php* as shown in [Listing 25-5](#lis25-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-5: Updating the AudioClip class to use SizeUtilities'
  prefs: []
  type: TYPE_NORMAL
- en: 'We add the getSizeMegaBytes() method, which returns a float representing the
    size of the AudioClip object in megabytes. The method gets the size in bits and
    passes it to the public static bitsToMegaBytes() method declared in our SizeUtilities
    class ❶. This is a good example of how to use public static methods in other classes:
    we don’t have to create an object of the SizeUtilities class in order to use its
    public static method. Instead, we simply write SizeUtilities:: followed by the
    name of the method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the new __toString() method, we create a temporary $numMegaBytesFormatted
    variable holding the clip size in megabytes, formatted as a string with two decimal
    places. We then include the value of this variable as part of the string returned
    by the method. Once again, we don’t need to make any changes to the index script
    to test our updates, since we’re still using __toString() to output information.
    Here’s the terminal output of the updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The size of each AudioClip object is now given in megabytes. Our new utility
    class has successfully helped the AudioClip class make the necessary bits-to-megabytes
    conversions through its static method and class constants.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing Resources Across an Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another use of static methods is to offer a functionality (such as reading from
    or writing to a database, or appending messages to a logfile) to all parts of
    a software system, without each part of the system needing to duplicate the required
    setup code. The idea is to create an abstract class with static methods that do
    the necessary legwork, like establishing a database connection or setting up a
    logger and log handler. Then you can call those static methods from anywhere in
    your code whenever you need that functionality. This makes processes like logging
    or working with a database connection quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how this works, let’s create a project that allows logging from
    anywhere in the system just by writing something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For this to work, we’ll need a Logger class with a public static debug() method
    that can be invoked from anywhere in the system. This method will handle the mechanics
    of the logging process so that the other parts of the system don’t have to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new project folder and create the usual *composer.json* file to autoload
    the Mattsmithdev namespaced classes. Then enter this command at the command line
    to add the Monolog library to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since we have a *composer.json* file, Composer will also generate the autoloader
    scripts at this step, in addition to loading the Monolog library. All the relevant
    files will be in your project’s *vendor* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Next, create a custom Logger class in *src/Logger.php* as shown in [Listing
    25-6](#lis25-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-6: The Logger class with a public static logging method'
  prefs: []
  type: TYPE_NORMAL
- en: We declare our Logger class in the Mattsmithdev namespace to avoid a naming
    collision with the Monolog library’s Logger class and designate it as abstract
    since we won’t ever need to instantiate it. The use statements allow us to refer
    to the necessary Monolog classes in our code without having to write fully qualified
    namespaces. Notice that we alias Monolog’s Logger class as MonologLogger to better
    differentiate it from our own class ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the class, we create a constant for the filepath to *logs/debug.log*.
    Then we declare debug() as a public static method that takes a $message string
    parameter ❷. The method creates a new MonologLogger object for channel1 and assigns
    it a log handler for writing to the debug logfile, then uses the Monolog class’s
    debug() method to log $message to the logfile.
  prefs: []
  type: TYPE_NORMAL
- en: Now create an index script in *public/index.php* containing the code in [Listing
    25-7](#lis25-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-7: Creating an Application object in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: We read in and execute the Composer-generated autoloader, create an object of
    the Application class, and invoke its run() method. This is the same basic pattern
    for the index script of an object-oriented web application that we discussed in
    [Chapter 21](chapter21.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, declare the Application class in *src/Application.php* as shown in
    [Listing 25-8](#lis25-8). The class includes code for logging messages via our
    Logger class’s static method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-8: The Application class'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Application class’s run() method, we print out a ''Hello, world!'' message.
    Then we invoke the static debug() method of our Logger class to log messages to
    the debug logfile. Notice that we don’t need to create a Logger object or include
    any setup code (such as declaring a path to the logfile or creating a log handler)
    in the Application class itself; everything is handled by the static method we
    defined on the Logger class. If the Application and Logger classes were in different
    namespaces, all we’d need to do is add a use statement or fully qualify the class
    when using it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can confirm that the two messages have been appended to the logfile by viewing
    the contents of *logs/debug.log* after running the index script. Remember to use
    the cat command (macOS and Unix) or type (Windows), as discussed in [Chapter 24](chapter24.xhtml).
    You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve successfully used our static method to append messages to the logfile.
    If we wanted, we could add optional arguments to this method to change the name
    and location of the logfile, log to different channels, or provide a context array
    such as an Exception object. This basic example has illustrated generally how
    a class can offer a single static method to make it easy for any part of a software
    system to utilize its functionality.  ### Saving Resources with the Singleton
    Pattern'
  prefs: []
  type: TYPE_NORMAL
- en: The approach we used in the preceding section to share resources across an application
    can work in many situations, but in some cases, such as creating a connection
    to a database or setting up a mailing or file-writing object, the static method’s
    task takes up enough time and memory to impair the application’s performance.
    In cases like these, an object-oriented design technique called the *singleton
    pattern* can help conserve computing resources while still making an operation
    available throughout an application.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look back the last section of [Listing 25-6](#lis25-6), where we declared
    our Logger class. According to our definition of the static debug() method, a
    new MonologLogger object and a new StreamHandler object will be created each time
    the method is invoked to log a debug message. In our application’s run() method
    in [Listing 25-8](#lis25-8), we invoked this method twice, so four objects were
    created to log the two messages, which is a bit wasteful. When operations are
    resource expensive, a more efficient approach is to perform them once and then
    *cache* (store) the created resources for future use. The singleton pattern is
    one way of doing this.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern declares a class with a private constructor, along with
    logic to ensure that, at most, we create only one object of the class. The class
    offers a public static method named getInstance() that returns a reference to
    the single instance of the class. If no instance exists, one is created the first
    time the getInstance() method is invoked. Otherwise, the class caches, or keeps
    a record of, the single instance, so it can be returned again the next time getInstance()
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anytime you need to use the singleton class, you’d write something like this
    from anywhere in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This stores a reference to the sole instance of the singleton class in the $myObject
    variable. You can then use the Singleton class’s resources through the $myObject
    reference. [Listing 25-9](#lis25-9) shows the typical skeleton for singleton-style
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-9: The Singleton class'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a private static property called instance, initializing it to NULL.
    Ultimately, this property will hold a reference to the only object of the singleton
    class. Then we declare a private constructor method where any resource-hungry
    work can be completed. Since the constructor has been declared as private, it
    can’t be invoked with the new keyword from anywhere outside the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare the only public member of this class, the static getInstance()
    method. This method first tests whether the instance is NULL ❶. If so, this must
    be the first time that this method has been invoked, so a new Singleton object
    is created (which calls the constructor, triggering the resource-heavy work),
    and the reference to the new object is stored in the static instance property
    ❷. Then the method returns the object reference in instance, making the object
    available for use elsewhere in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s modify the previous section’s project to save computing resources by using
    the singleton pattern. This way, we’ll have to create the Logger object and log
    handler only once, no matter how many messages we log. We’ll also make our application
    more flexible by making our custom Logger class a subclass of Monolog’s Logger
    class so that we can use any of the latter’s methods and optional arguments (for
    example, to provide context data and to log at different severity levels through
    the inherited methods).
  prefs: []
  type: TYPE_NORMAL
- en: First, update the declaration of the Logger class in *src/Logger.php* to match
    [Listing 25-10](#lis25-10). This redesigned class is closely modeled on the skeletal
    Singleton class demonstrated in [Listing 25-9](#lis25-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-10: Implementing the Logger class with the singleton pattern'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare our Logger class as a subclass of the Monolog Logger class (aliased
    as MonoLogger) ❶. Since we’ll be creating one instance of this class, we no longer
    declare it to be abstract. Next, we initialize the private static instance property
    to NULL and declare a private constructor. The constructor uses parent:: to call
    the Monolog Logger class’s constructor, creating a new object with channel1, then
    assigns it a log handler to the debug logfile. Since all this is encapsulated
    within the private constructor, it will happen only once.'
  prefs: []
  type: TYPE_NORMAL
- en: We also declare the public static getInstance() method, typical for singleton
    classes ❷. The method follows the logic described in [Listing 25-9](#lis25-9),
    creating and returning a Logger object if instance is NULL, or simply returning
    the instance if it’s been created already.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s update the run() method of our Application class. We’ll obtain a reference
    to the single instance of our Logger class, then use that object reference to
    log some entries. Modify *src/Application.php* to match [Listing 25-11](#lis25-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-11: The Application class updated to use our singleton Logger class'
  prefs: []
  type: TYPE_NORMAL
- en: We get a reference to the singleton instance of Logger by writing Logger::getInstance()
    and use it to log a warning-severity message via the warning() method inherited
    from the Monolog Logger class. Since this is the first attempt to get the singleton
    instance, the instance property of our Logger class will be NULL, and a new Logger
    object will be created and a reference to it saved in instance.
  prefs: []
  type: TYPE_NORMAL
- en: Then we again get a reference to the singleton instance of Logger and log an
    error-severity message, creating and passing a second parameter of a new Exception
    object as the context. This time, the instance property of Logger isn’t NULL,
    so the reference to the existing object is returned. In this way, both logs have
    been created by a single instance of the Logger class, saving time and resources
    while still making the logging functionality available anywhere in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the cat or type command to view the contents of *logs/debug.log* after
    running the index script. You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Both messages were successfully appended to the logfile, including the Exception
    object context data added to the error-level log entry.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen how the singleton pattern can be useful. However, many programmers
    consider it an *antipattern*, a solution to a common problem that ends up being
    worse than the problem it’s attempting to solve. Critics of the singleton pattern
    object to it being a form of global program state, which makes testing code more
    difficult since code using the singleton can’t be tested separately from the singleton
    itself. Also, the singleton has *global visibility*, meaning that any code in
    an application might be dependent on it. More complex code analysis is therefore
    needed to determine which parts of an application are or aren’t dependent on the
    globally visible singleton. On the other hand, proponents argue that the reduction
    in resource usage is enough to outweigh some overhead in testing or the design
    of other parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To *enumerate* is to list out every possibility, one by one, and in computer
    programming, an *enumeration* is a list of all the possible values for a data
    type. A good example of an enumerated data type is bool, which lists its only
    two possible values as true and false. Booleans are built into the language, but
    since version 8.1, PHP allows you to create and use your own custom enumerations,
    also known as *enum classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Enum classes are useful when you have data items that can take only one of a
    closed set of values. For example, a pizza order can be designated as being for
    delivery or pickup, an employee’s work status can be full-time or part-time, and
    a playing card’s suit can be hearts, diamonds, clubs, or spades. While you could
    use a Boolean property when you have only two potential values (for example, $fullTime
    = false), enum classes are more appropriate when you have more than two possibilities.
    Even for just two possible values, defining them through an enum class makes the
    choice more explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Inside an enum class, you declare each of the possible cases for that class,
    where each case is an object of the class. For example, you might have a playing
    card Suit enum class with possible cases HEARTS, DIAMONDS, CLUBS, and SPADES.
    To reference the cases of an enum class, you use the same double-colon syntax
    (the scope resolution operator) as when using a static member or class constant
    (for example, $card1Suit = Suit::SPADES).
  prefs: []
  type: TYPE_NORMAL
- en: Because of this shared syntax, enum classes bear some relationship to static
    members and class constants. The key difference is that each case of an enum class
    is a proper *object* of that class, whereas class constants and static properties
    and methods are *members* of a class. Crucially, this means that enum classes
    can serve as the data types for properties of other classes, and for function
    parameters and return values.
  prefs: []
  type: TYPE_NORMAL
- en: As a simple example, [Listing 25-12](#lis25-12) shows the declaration of an
    enum class for the suits of a deck of playing cards. Declare this enum class in
    a file called *Suit.php*, just like an ordinary class declaration file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-12: The Suit enum class'
  prefs: []
  type: TYPE_NORMAL
- en: After the namespace, we use the enum keyword followed by the class name Suit.
    Then we declare four cases for this enum class, representing the four playing
    card suits. Because the enumeration cases serve a similar function as class constants
    (that is, defining fixed values), I tend to write them in all capital letters,
    although many programmers capitalize only the first letter of each case.
  prefs: []
  type: TYPE_NORMAL
- en: We can now assign an object of the Suit enum class to a variable. To illustrate,
    [Listing 25-13](#lis25-13) shows a simple Card class that harnesses the Suit enum.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-13: The Card class with a suit property that uses the Suit enum
    class'
  prefs: []
  type: TYPE_NORMAL
- en: We first declare suit as a property of the Suit data type ❶. Again, since enums
    are considered classes, they can be used as valid data types. We also give the
    class a number property, and we provide simple getters and setters for both suit
    and number. Then we declare a __toString() method to output the details of the
    Card object’s properties ❷. In it, we get a string version of the enum object’s
    name from its name property, accessed with the expression $this->suit->name.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 25-14 shows a simple index script to demonstrate the use of the Suit
    and Card classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-14: Using Card and Suit in an index script'
  prefs: []
  type: TYPE_NORMAL
- en: 'After providing use statements for the two classes, we create a new Card object
    and set its suit property to be a reference to the SPADES case of the Suit enum
    class, using the double-colon Suit::SPADES syntax to reference the case ❶. We
    also set the number of this Card object to 1 (representing an ace). Then we print
    the details of the $card1 variable, which will invoke its __toString() method.
    Here’s the output of running this index script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The output shows the number property of 1 and the string SPADES, the name of
    the Suit enum class referenced in the object’s suit property.
  prefs: []
  type: TYPE_NORMAL
- en: Backed Enums
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Besides giving enum cases names like SPADES and HEARTS, you can also associate
    an integer or string value with each case. When you give the cases values, the
    class is called a *value-backed enum*, or *backed enum* for short. The type of
    int or string must be declared after the enum class name, and every case must
    be assigned a value; otherwise, an error will occur.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s turn Suit into a backed enum by assigning a string value for each case.
    We could choose strings that exactly match the case names ('HEARTS', 'CLUBS',
    and so on), or we could have a bit of fun and assign strings with the corresponding
    card suit symbols. See [Listing 25-15](#lis25-15) for the updated Suit declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-15: Turning Suit into a backed enum class'
  prefs: []
  type: TYPE_NORMAL
- en: We declare Suit as a string-backed enum by adding a colon and the string type
    after the class name. Then we assign the string '♣' as the value for the CLUBS
    case, as well as the corresponding symbols for the other three suits. To retrieve
    the value of a backed enum, use its public value property. For example, if the
    $card1Suit variable were a reference to a Suit enum object, we’d get its string
    value with the expression $card1Suit->value. These values are read-only; once
    they’re set in the enum class declaration, they can’t be changed from elsewhere
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: An Array of All Cases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All enum classes have a built-in static method called cases() that returns an
    array of all the case objects for the enumeration. We can use this to build an
    array of the values associated with the cases. For example, [Listing 25-16](#lis25-16)
    shows an index script that does just this by looping through each Suit case object
    and appending its string value to an array for printout.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-16: Creating an array of all Suit enum case values'
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the Suit::cases() static method to obtain a $cases array holding an
    instance of each possible Suit case. Then we initialize $caseStrings as an empty
    array. Next, we loop through the Suit case objects in $cases and append their
    string values to the $caseStrings array. Finally, we print out the array of strings
    as a single string by using the built-in implode() function. Here’s the output
    of running this index script at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: All four suit characters have been printed out on the same line. Here we’ve
    simply printed out the case values, but we could use a similar looping technique
    to, for example, create a drop-down menu of all the case values from an enum class
    so that a user can select one of the options.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we explored static members of classes: properties and methods
    that aren’t related directly to individual objects but belong to the class as
    a whole. You saw how static members can be accessed within the class via self::
    and outside the class via ClassName:: (assuming the static member is public).
    You learned about uses of static members, including to record class-wide information,
    provide common methods through utility classes, and share functionality across
    an application, through either an abstract class or the singleton design pattern.
    We also discussed the related concepts of class constants and enumeration classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Create a new project to implement a Car class representing various cars.
    As shown in [Figure 25-4](#fig25-4), this class should have instance properties
    for make, model, and price, and a constructor taking in values for each instance
    property when a new object is created. You should also have private static properties
    for totalPrice and numInstances.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure25-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 25-4: The Car class'
  prefs: []
  type: TYPE_NORMAL
- en: Each time a new Car object is created, the constructor method should increment
    numInstances and add the price of the new Car object to totalPrice.
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Add a public static averagePrice() method to the Car class from Exercise
    1 that uses the static numInstances and totalPrice properties to calculate and
    return the average price of all Car objects that have been created.
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Create a new project featuring an enum class called DietType with three
    cases: VEGAN, VEGETARIAN, and CARNIVORE. Also create a Dessert class that has
    a name property (a string) and a diet property (a DietType enum case), as well
    as a __toString() method that summarizes the Dessert object in the form ''(DESSERT)
    Dessert Name (DietType dish)''. Write an index script that creates a Dessert object
    and prints its details. The output should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
