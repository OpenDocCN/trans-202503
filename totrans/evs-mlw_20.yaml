- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">16</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ENCODING
    AND ENCRYPTION</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Encoding* is the act of converting data into a new format. It’s used for tasks
    such as efficiently transporting data, ensuring interoperability between protocols
    or applications, and compressing and storing data. Malware authors also use encoding
    to obfuscate data and code that shouldn’t be seen by analysts or host and network
    defenses. *Encryption*, which shares similarities with encoding, is a way to protect
    sensitive data in transit or at rest. Malware can use encryption for many reasons,
    including obfuscating sensitive data in memory such as command and control (C2)
    information. In addition to defense evasion, malware often uses encoding and encryption
    to impede analysis, especially static code analysis or analysis of network traffic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, malware utilizes encoding and encryption algorithms for the following
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: To protect code and data in its files that reside on disk, in order to evade
    endpoint defenses such as anti-malware software. This often involves a technique
    called packing that will be discussed at length in [Chapter 17](chapter17.xhtml).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To protect code and data in memory (such as C2 addresses, keys, or sensitive
    strings) from endpoint defense software and analysts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To protect its data on the network layer while in transit, for example, by encrypting
    data before transferring it to a C2 infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To hamper reverse engineering and analysis efforts. If a malware analyst must
    first decode or decrypt parts of the malware’s code, it can slow and frustrate
    the analysis process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, you’ll see some encoding and encryption techniques used by
    malware and learn a few practical tips to overcome them when analyzing it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Basic Encoding</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most widely used forms of encoding is *Base64*, which was originally
    designed for data transfer and interoperability between various protocols. When
    a string is run through a Base64 encoding algorithm, the string is fed into the
    algorithm as binary data and broken down into 6-bit blocks. Each block is then
    translated (encoded) to ASCII format, using a total of 64 different characters
    (26 lowercase characters, 26 uppercase characters, 10 digits, and the / and +
    characters). This 64-character set, shown in [Table 16-1](chapter16.xhtml#tab16-1),
    is where Base64 gets its name. The table shows the character (Char), decimal value
    (Dec), and binary value (Bin) of each of the Base64 characters.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-1:</samp> <samp class="SANS_Futura_Std_Book_11">The
    Base64 Character Set</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Char</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Dec</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Bin</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Char</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Dec</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Bin</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Char</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Dec</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Bin</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">A</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">L</samp>
    | <samp class="SANS_Futura_Std_Book_11">11</samp> | <samp class="SANS_Futura_Std_Book_11">1011</samp>
    | <samp class="SANS_Futura_Std_Book_11">W</samp> | <samp class="SANS_Futura_Std_Book_11">22</samp>
    | <samp class="SANS_Futura_Std_Book_11">10110</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">B</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">M</samp>
    | <samp class="SANS_Futura_Std_Book_11">12</samp> | <samp class="SANS_Futura_Std_Book_11">1100</samp>
    | <samp class="SANS_Futura_Std_Book_11">X</samp> | <samp class="SANS_Futura_Std_Book_11">23</samp>
    | <samp class="SANS_Futura_Std_Book_11">10111</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">C</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    | <samp class="SANS_Futura_Std_Book_11">10</samp> | <samp class="SANS_Futura_Std_Book_11">N</samp>
    | <samp class="SANS_Futura_Std_Book_11">13</samp> | <samp class="SANS_Futura_Std_Book_11">1101</samp>
    | <samp class="SANS_Futura_Std_Book_11">Y</samp> | <samp class="SANS_Futura_Std_Book_11">24</samp>
    | <samp class="SANS_Futura_Std_Book_11">11000</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">D</samp> | <samp class="SANS_Futura_Std_Book_11">3</samp>
    | <samp class="SANS_Futura_Std_Book_11">11</samp> | <samp class="SANS_Futura_Std_Book_11">O</samp>
    | <samp class="SANS_Futura_Std_Book_11">14</samp> | <samp class="SANS_Futura_Std_Book_11">1110</samp>
    | <samp class="SANS_Futura_Std_Book_11">Z</samp> | <samp class="SANS_Futura_Std_Book_11">25</samp>
    | <samp class="SANS_Futura_Std_Book_11">11001</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">E</samp> | <samp class="SANS_Futura_Std_Book_11">4</samp>
    | <samp class="SANS_Futura_Std_Book_11">100</samp> | <samp class="SANS_Futura_Std_Book_11">P</samp>
    | <samp class="SANS_Futura_Std_Book_11">15</samp> | <samp class="SANS_Futura_Std_Book_11">1111</samp>
    | <samp class="SANS_Futura_Std_Book_11">a</samp> | <samp class="SANS_Futura_Std_Book_11">26</samp>
    | <samp class="SANS_Futura_Std_Book_11">11010</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">F</samp> | <samp class="SANS_Futura_Std_Book_11">5</samp>
    | <samp class="SANS_Futura_Std_Book_11">101</samp> | <samp class="SANS_Futura_Std_Book_11">Q</samp>
    | <samp class="SANS_Futura_Std_Book_11">16</samp> | <samp class="SANS_Futura_Std_Book_11">10000</samp>
    | <samp class="SANS_Futura_Std_Book_11">b</samp> | <samp class="SANS_Futura_Std_Book_11">27</samp>
    | <samp class="SANS_Futura_Std_Book_11">11011</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">G</samp> | <samp class="SANS_Futura_Std_Book_11">6</samp>
    | <samp class="SANS_Futura_Std_Book_11">110</samp> | <samp class="SANS_Futura_Std_Book_11">R</samp>
    | <samp class="SANS_Futura_Std_Book_11">17</samp> | <samp class="SANS_Futura_Std_Book_11">10001</samp>
    | <samp class="SANS_Futura_Std_Book_11">c</samp> | <samp class="SANS_Futura_Std_Book_11">28</samp>
    | <samp class="SANS_Futura_Std_Book_11">11100</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">H</samp> | <samp class="SANS_Futura_Std_Book_11">7</samp>
    | <samp class="SANS_Futura_Std_Book_11">111</samp> | <samp class="SANS_Futura_Std_Book_11">S</samp>
    | <samp class="SANS_Futura_Std_Book_11">18</samp> | <samp class="SANS_Futura_Std_Book_11">10010</samp>
    | <samp class="SANS_Futura_Std_Book_11">d</samp> | <samp class="SANS_Futura_Std_Book_11">29</samp>
    | <samp class="SANS_Futura_Std_Book_11">11101</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">I</samp> | <samp class="SANS_Futura_Std_Book_11">8</samp>
    | <samp class="SANS_Futura_Std_Book_11">1000</samp> | <samp class="SANS_Futura_Std_Book_11">T</samp>
    | <samp class="SANS_Futura_Std_Book_11">19</samp> | <samp class="SANS_Futura_Std_Book_11">10011</samp>
    | <samp class="SANS_Futura_Std_Book_11">e</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    | <samp class="SANS_Futura_Std_Book_11">11110</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">J</samp> | <samp class="SANS_Futura_Std_Book_11">9</samp>
    | <samp class="SANS_Futura_Std_Book_11">1001</samp> | <samp class="SANS_Futura_Std_Book_11">U</samp>
    | <samp class="SANS_Futura_Std_Book_11">20</samp> | <samp class="SANS_Futura_Std_Book_11">10100</samp>
    | <samp class="SANS_Futura_Std_Book_11">f</samp> | <samp class="SANS_Futura_Std_Book_11">31</samp>
    | <samp class="SANS_Futura_Std_Book_11">11111</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">K</samp> | <samp class="SANS_Futura_Std_Book_11">10</samp>
    | <samp class="SANS_Futura_Std_Book_11">1010</samp> | <samp class="SANS_Futura_Std_Book_11">V</samp>
    | <samp class="SANS_Futura_Std_Book_11">21</samp> | <samp class="SANS_Futura_Std_Book_11">10101</samp>
    | <samp class="SANS_Futura_Std_Book_11">g</samp> | <samp class="SANS_Futura_Std_Book_11">32</samp>
    | <samp class="SANS_Futura_Std_Book_11">100000</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">h</samp> | <samp class="SANS_Futura_Std_Book_11">33</samp>
    | <samp class="SANS_Futura_Std_Book_11">100001</samp> | <samp class="SANS_Futura_Std_Book_11">s</samp>
    | <samp class="SANS_Futura_Std_Book_11">44</samp> | <samp class="SANS_Futura_Std_Book_11">101100</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">55</samp>
    | <samp class="SANS_Futura_Std_Book_11">110111</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">i</samp> | <samp class="SANS_Futura_Std_Book_11">34</samp>
    | <samp class="SANS_Futura_Std_Book_11">100010</samp> | <samp class="SANS_Futura_Std_Book_11">t</samp>
    | <samp class="SANS_Futura_Std_Book_11">45</samp> | <samp class="SANS_Futura_Std_Book_11">101101</samp>
    | <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">56</samp>
    | <samp class="SANS_Futura_Std_Book_11">111000</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">j</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    | <samp class="SANS_Futura_Std_Book_11">100011</samp> | <samp class="SANS_Futura_Std_Book_11">u</samp>
    | <samp class="SANS_Futura_Std_Book_11">46</samp> | <samp class="SANS_Futura_Std_Book_11">101110</samp>
    | <samp class="SANS_Futura_Std_Book_11">5</samp> | <samp class="SANS_Futura_Std_Book_11">57</samp>
    | <samp class="SANS_Futura_Std_Book_11">111001</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">k</samp> | <samp class="SANS_Futura_Std_Book_11">36</samp>
    | <samp class="SANS_Futura_Std_Book_11">100100</samp> | <samp class="SANS_Futura_Std_Book_11">v</samp>
    | <samp class="SANS_Futura_Std_Book_11">47</samp> | <samp class="SANS_Futura_Std_Book_11">101111</samp>
    | <samp class="SANS_Futura_Std_Book_11">6</samp> | <samp class="SANS_Futura_Std_Book_11">58</samp>
    | <samp class="SANS_Futura_Std_Book_11">111010</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">l</samp> | <samp class="SANS_Futura_Std_Book_11">37</samp>
    | <samp class="SANS_Futura_Std_Book_11">100101</samp> | <samp class="SANS_Futura_Std_Book_11">w</samp>
    | <samp class="SANS_Futura_Std_Book_11">48</samp> | <samp class="SANS_Futura_Std_Book_11">110000</samp>
    | <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">59</samp>
    | <samp class="SANS_Futura_Std_Book_11">111011</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">m</samp> | <samp class="SANS_Futura_Std_Book_11">38</samp>
    | <samp class="SANS_Futura_Std_Book_11">100110</samp> | <samp class="SANS_Futura_Std_Book_11">x</samp>
    | <samp class="SANS_Futura_Std_Book_11">49</samp> | <samp class="SANS_Futura_Std_Book_11">110001</samp>
    | <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_Futura_Std_Book_11">60</samp>
    | <samp class="SANS_Futura_Std_Book_11">111100</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">n</samp> | <samp class="SANS_Futura_Std_Book_11">39</samp>
    | <samp class="SANS_Futura_Std_Book_11">100111</samp> | <samp class="SANS_Futura_Std_Book_11">y</samp>
    | <samp class="SANS_Futura_Std_Book_11">50</samp> | <samp class="SANS_Futura_Std_Book_11">110010</samp>
    | <samp class="SANS_Futura_Std_Book_11">9</samp> | <samp class="SANS_Futura_Std_Book_11">61</samp>
    | <samp class="SANS_Futura_Std_Book_11">111101</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">o</samp> | <samp class="SANS_Futura_Std_Book_11">40</samp>
    | <samp class="SANS_Futura_Std_Book_11">101000</samp> | <samp class="SANS_Futura_Std_Book_11">z</samp>
    | <samp class="SANS_Futura_Std_Book_11">51</samp> | <samp class="SANS_Futura_Std_Book_11">110011</samp>
    | <samp class="SANS_Futura_Std_Book_11">+</samp> | <samp class="SANS_Futura_Std_Book_11">62</samp>
    | <samp class="SANS_Futura_Std_Book_11">111110</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">p</samp> | <samp class="SANS_Futura_Std_Book_11">41</samp>
    | <samp class="SANS_Futura_Std_Book_11">101001</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">52</samp> | <samp class="SANS_Futura_Std_Book_11">110100</samp>
    | <samp class="SANS_Futura_Std_Book_11">/</samp> | <samp class="SANS_Futura_Std_Book_11">63</samp>
    | <samp class="SANS_Futura_Std_Book_11">111111</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">q</samp> | <samp class="SANS_Futura_Std_Book_11">42</samp>
    | <samp class="SANS_Futura_Std_Book_11">101010</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">53</samp> | <samp class="SANS_Futura_Std_Book_11">110101</samp>
    |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">r</samp> | <samp class="SANS_Futura_Std_Book_11">43</samp>
    | <samp class="SANS_Futura_Std_Book_11">101011</samp> | <samp class="SANS_Futura_Std_Book_11">2</samp>
    | <samp class="SANS_Futura_Std_Book_11">54</samp> | <samp class="SANS_Futura_Std_Book_11">110110</samp>
    | <samp class="SANS_Futura_Std_Book_11">=</samp> | <samp class="SANS_Futura_Std_Book_11">(padding)</samp>
    |  |'
  prefs: []
  type: TYPE_TB
- en: Notice the equal sign (=), which is used as padding and thus doesn’t count as
    one of the 64 characters. When analyzing malware code, if you spot a string of
    characters followed by one or more equal signs, an alert should sound in your
    head that you might be dealing with some variation of Base64-encoded data. Note
    that this padding character isn’t always present.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Base64 character set is often hardcoded in malware, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you spot something in code that looks like this index string, you may assume
    the malware is using a variation of Base64 encoding. We’ll return to this in a
    moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand what Base64 encoding looks like in practice, let’s look
    at an example, using the string <samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp>
    as input. The ASCII string <samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp>,
    when converted to binary, reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">e</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">v</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">i</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">l</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">01100101</samp> | <samp class="SANS_Futura_Std_Book_11">01110110</samp>
    | <samp class="SANS_Futura_Std_Book_11">01101001</samp> | <samp class="SANS_Futura_Std_Book_11">01101100</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: 'If we run the <samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp> ASCII
    string through a Base64 encoding algorithm, the ASCII is converted to binary,
    this binary string is broken into 6-bit blocks, and each block is matched against
    one of the characters in the Base64 character set. For the <samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp>
    string, these blocks and values would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Block 1</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Block
    2</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Block 3</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Block
    4</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Block 5</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Block
    6</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">011001</samp> | <samp class="SANS_Futura_Std_Book_11">010111</samp>
    | <samp class="SANS_Futura_Std_Book_11">011001</samp> | <samp class="SANS_Futura_Std_Book_11">101001</samp>
    | <samp class="SANS_Futura_Std_Book_11">011011</samp> | <samp class="SANS_Futura_Std_Book_11">00</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Z</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">X</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Z</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: The Base64 string output here is <samp class="SANS_TheSansMonoCd_W5Regular_11">ZXZpbA</samp>.
    However, most implementations of Base64 group output in sets of six characters
    and, if there’s an odd number of characters at the end of the encoded string,
    add padding as needed. In this case, Block 6 isn’t complete, so <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    is added as padding and the end result is <samp class="SANS_TheSansMonoCd_W5Regular_11">ZXZpbA==</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: A full discussion of Base64 encoding is outside the scope of this book. For
    a more complete explanation of the technical details of this algorithm, see [*https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Base64*](https://en.wikipedia.org/wiki/Base64).
  prefs: []
  type: TYPE_NORMAL
- en: 'While Base64 has plenty of legitimate use cases, malware can also use it as
    a quick-and-dirty way to achieve a more evil purpose: obfuscating data. Base64
    (and other encoding algorithms like it) can be used to hide malicious behaviors
    or strings in the file itself or in memory. The advantage of using encoding algorithms
    like Base64 is that they’re incredibly simple to implement. The disadvantage is
    that they’re also incredibly easy to “break”; you can simply decode the target
    data in the same way it was encoded. Base64 can be decoded using many different
    methods and tools, one of which is CyberChef ([*https://<wbr>github<wbr>.com<wbr>/gchq<wbr>/CyberChef*](https://github.com/gchq/CyberChef)),
    which we’ll touch on in a moment.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many great tools that can help you identify Base64 usage in malware.
    For example, *base64dump.py* ([*https://<wbr>github<wbr>.com<wbr>/DidierStevens<wbr>/DidierStevensSuite<wbr>/blob<wbr>/master<wbr>/base64dump<wbr>.py*](https://github.com/DidierStevens/DidierStevensSuite/blob/master/base64dump.py))
    is a Python script by Didier Stevens that scans an input file and attempts to
    find encoded data within it. It will list any encoded strings it finds and display
    their decoded value, allowing the analyst to quickly identify suspicious encoded
    data. [Figure 16-1](chapter16.xhtml#fig16-1) shows the output of this tool.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-1: Viewing Base64-encoded
    strings from a binary in</samp> <samp class="SANS_Futura_Std_Book_11">base64dump.py</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the possible decoded string in line 4 (<samp class="SANS_TheSansMonoCd_W5Regular_11">homesshealth.inf</samp>).
    You can see part of the encoded value as well. To fully assess this decoded string,
    you can *dump* it (extract it and save to disk) by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">-d</samp>
    (dump) and <samp class="SANS_TheSansMonoCd_W5Regular_11">-s</samp> (section) switches
    in *base64dump.py*, specifying the section number of interest (in this case, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4</samp>):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that malware authors can easily modify standard Base64 encoding to inhibit
    reversing of their data. Simply modifying the Base64 character set will drastically
    change its output. Consider, for example, the following modified index string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare this with the original Base64 character set mentioned previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice the difference? In the first set, the characters <samp class="SANS_TheSansMonoCd_W5Regular_11">abcd</samp>
    were moved to the beginning of the character set, before <samp class="SANS_TheSansMonoCd_W5Regular_11">ABCD</samp>.
    Simply moving <samp class="SANS_TheSansMonoCd_W5Regular_11">abcd</samp> to the
    beginning of this index will drastically change the output of Base64 encoding,
    and this is a very easy change to make. To detect these types of changes, you
    can look for the index string in code, as mentioned previously. Quite often, this
    Base64 index will be clearly visible in a malware executable’s code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, keep in mind that there are other encodings you might encounter when
    analyzing malware (such as Base32, Base85, uuencode, and yEnc), but these are
    not as prevalent. Spending time learning how to identify and decode Base64 encoding
    will help you in the large majority of cases involving simple malware data encoding.
    It’s quite common for malware authors to encode PE files in Base64\. Since PE
    files contain the ASCII characters <samp class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp>
    as part of the header, be on the lookout for the encoded version of <samp class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp>,
    which begins with <samp class="SANS_TheSansMonoCd_W5Regular_11">TV</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Data Hashing</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Hashing* is essentially one-way data encoding, meaning that, theoretically,
    it can’t be reversed. When data is run through a hashing algorithm, the resulting
    hash will always be the same length. For example, the MD5 hashing algorithm always
    produces a fixed-length hash value of 128 bits, or 32 characters. SHA-1 produces
    a hash value of 160 bits, or 40 characters. And finally, SHA256 produces a hash
    value of 256 bits, or 64 characters.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use CyberChef, mentioned earlier, to see what data hashing looks like
    in practice. In [Figure 16-2](chapter16.xhtml#fig16-2), I’ve used CyberChef and
    MD5 to hash a simple URL, generating the 32-character hash value shown in the
    Output box.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-2: MD5 hashing with
    CyberChef</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 16-3](chapter16.xhtml#fig16-3), I’ve modified one character in the
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-3: Altering the input
    URL in CyberChef</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You may be able to spot that I simply added an <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">http</samp> string. Notice
    that the hash output completely changed. This effect, in which a drastically different
    hash value is produced for different input data (even if the input data is 99
    percent identical), is known as *cascading*. Cascading divides the input data
    into groups of characters and then subdivides those groups.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We’ll be using CyberChef in various examples throughout the rest of this chapter.
    It’s a great all-purpose tool for data manipulation tasks, and it has many uses
    outside of hashing data. It’s a good idea to familiarize yourself with its features.*'
  prefs: []
  type: TYPE_NORMAL
- en: Malware can also take advantage of the power of hashing for obfuscation purposes,
    and there are a couple of different ways it can implement these hashing algorithms
    within its code. One method is using the native CryptoAPI in Windows. This service
    provides a simple-to-use API for software (malware, in our case) to encode, decode,
    encrypt, and decrypt data. I’ll cover CryptoAPI later in this chapter, along with
    an example of how it’s used in malware. A second method that malware authors might
    use is creating their own custom hashing algorithms. The article “Windows API
    Hashing in Malware,” from the blog site *Red Team Experiments* ([*https://<wbr>www<wbr>.ired<wbr>.team<wbr>/offensive<wbr>-security<wbr>/defense<wbr>-evasion<wbr>/windows<wbr>-api<wbr>-hashing<wbr>-in<wbr>-malware*](https://www.ired.team/offensive-security/defense-evasion/windows-api-hashing-in-malware)),
    describes a small piece of custom code that can be used to hash API function imports
    to hide these function names from reversers and host defenses.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the algorithm in use, hashing can be difficult to deal with when
    you are reversing malware. You can try using a hash-cracking tool to brute-force
    the input by comparing the output of a hash function to a precomputed dictionary
    of known inputs and their corresponding outputs. If it’s a well-known algorithm,
    there are several tools and resources that have prehashed common strings seen
    in malware. For example, OALabs wrote a tool called hashdb ([*https://<wbr>github<wbr>.com<wbr>/OALabs<wbr>/hashdb*](https://github.com/OALabs/hashdb)),
    along with its companion IDA Pro plug-in, hashdb-ida ([*https://<wbr>github<wbr>.com<wbr>/OALabs<wbr>/hashdb<wbr>-ida*](https://github.com/OALabs/hashdb-ida)),
    which is a database of common malware strings. This is a great tool for querying
    an unknown hash value referenced in malware and obtaining the “unhashed” string.
    The tool supports common hashes such as CRC-32 and ROR-13, as well as custom hash
    implementations seen in specific malware families such as GuLoader and Lockbit.
  prefs: []
  type: TYPE_NORMAL
- en: If the malware is using an unknown, custom hashing algorithm, the process is
    trickier. To understand what data the malware has hashed, you need to first understand
    the context around that data. You may need to make educated guesses about what
    the cleartext strings could be, based on surrounding data. For example, if you
    spot cleartext function strings such as <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>, the surrounding
    obfuscated strings could be related to process injection functions such as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>.
    Another approach is to reverse engineer the hashing algorithm itself to obtain
    the original input. You would first have to locate the algorithm in the code and
    then analyze this code statically, using a disassembler or dynamically using a
    debugger. We’ll touch on locating such code in the context of encryption next.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Encryption and Decryption</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to encoding its data, malware will often encrypt it. As opposed
    to hashing, encryption is not a one-way procedure. Any data that has been encrypted
    can later be decrypted using a decryption key. As with hashing, malware often
    encrypts parts of its code or data in order to obfuscate its intentions, evade
    defenses, and protect itself from the reverse engineer.
  prefs: []
  type: TYPE_NORMAL
- en: This section will outline some encryption algorithms malware might use. However,
    because malware authors can even obfuscate their own encryption methods, making
    it that much more difficult to determine the exact encryption algorithm being
    used, we’ll focus more on methodology than on specific implementations of encryption
    algorithms. Then, we’ll go over some tips for identifying encryption and decryption
    routines in malware, as well as guidance for how to overcome these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Symmetric and Asymmetric
    Encryption</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two primary forms of encryption: symmetric and asymmetric. *Symmetric
    encryption* involves the use of a shared (symmetric) key between two clients.
    If Client 1 wishes to send data to Client 2, each client must have the encryption
    key since it’s used to both encrypt and decrypt the data. When malware uses symmetric
    encryption, its encryption key is either embedded inside the malware’s code or
    generated on the fly (using standard Windows libraries, for example). Common forms
    of symmetric encryption include AES, DES, Blowfish, and RC4\. [Figure 16-4](chapter16.xhtml#fig16-4)
    illustrates how symmetric encryption and decryption work at a high level.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-4: How symmetric
    key cryptography works</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, plaintext data is run through an encryption algorithm and encrypted with
    a symmetric encryption key. Once the encrypted data is ready to be decrypted,
    it is run through the decryption algorithm and provided the same symmetric key,
    which produces the original plaintext data.
  prefs: []
  type: TYPE_NORMAL
- en: There are two primary forms of symmetric encryption algorithms. *Stream ciphers*
    encrypt data one bit at a time and are often very fast. They’re used in protocols
    such as SSL/TLS to encrypt web traffic. *Block ciphers* encrypt data in chunks
    (blocks) and typically provide stronger encryption than stream ciphers. They’re
    also the more commonly used of the two, especially for tasks in which speed isn’t
    a primary concern.
  prefs: []
  type: TYPE_NORMAL
- en: 'As opposed to symmetric encryption, *asymmetric encryption* uses two keys rather
    than one: a *public key* for encryption and a *private key* for decryption. If
    Client 1 wishes to encrypt and send data to Client 2, Client 2 must first share
    their public key with Client 1, which uses that key to encrypt the data. Client
    2 then uses their own private key to decrypt the data. Conversely, when Client
    2 wishes to encrypt data for Client 1, they encrypt the data with Client 1’s public
    key, and Client 1 decrypts the data with their own private key. This negates the
    need for secure key exchange, as public keys are meant to be shared and exchanged,
    while private keys remain secret.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-5](chapter16.xhtml#fig16-5) illustrates asymmetric encryption and
    decryption.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-5: How asymmetric
    key cryptography works</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As in [Figure 16-4](chapter16.xhtml#fig16-4), plaintext data is run through
    an encryption algorithm, but this time it’s an asymmetric one. The public key
    is used to encrypt the data, and the private key is responsible for decrypting
    the data back into the original plaintext version.
  prefs: []
  type: TYPE_NORMAL
- en: Malware can encrypt its code or data in order to hide it from reverse engineers
    or network- and host-based defenses. Encryption is also used in ransomware, a
    type of malware that infects its victim, encrypts selected files on the host system,
    and then holds those files for ransom. Upon payment, the threat actor sends the
    decryption key to the victim to decrypt the files. Modern ransomware uses both
    symmetric and asymmetric encryption methods or a hybrid approach.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 16-2](chapter16.xhtml#tab16-2) lists some of the common encryption algorithms
    used in malware.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-2:</samp> <samp class="SANS_Futura_Std_Book_11">Cryptographic
    Algorithms Seen in Malware</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Type</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Advanced Encryption Standard (AES)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Symmetric (block cipher)</samp> | <samp
    class="SANS_Futura_Std_Book_11">AES is considered one of the strongest forms of
    symmetric encryption. It is often used in ransomware.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Rivest Cipher 4 (RC4)</samp> | <samp
    class="SANS_Futura_Std_Book_11">Symmetric (stream cipher)</samp> | <samp class="SANS_Futura_Std_Book_11">RC4
    is a fast and easy-to-implement algorithm, but it’s not especially strong. It’s
    used by various malware families for quick and simple data encryption and decryption.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Rivest, Shamir, and Adleman (RSA)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Asymmetric</samp> | <samp class="SANS_Futura_Std_Book_11">Named
    after its creators, RSA is a popular algorithm that has been used by various ransomware
    families. It is known for its relatively high speed and efficiency.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Elliptical Curve Cryptography (ECC)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Asymmetric</samp> | <samp class="SANS_Futura_Std_Book_11">ECC
    is a newer algorithm and has an advantage over RSA in that it is more secure for
    a given key size and thus more efficient. ECC is seeing increased use in malware.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: 'Before we go into detail on a few of the most common applications of encryption
    algorithms in malware, we need to go over an important component of encryption:
    XOR.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Exclusive Or</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Many encryption algorithms revolve around the *exclusive or (XOR)* operation,
    so it’s important to understand how it works. In an XOR operation, the input data
    is compared bit by bit to a provided key. [Table 16-3](chapter16.xhtml#tab16-3)
    shows an example where the bits in Input A and Input B are compared to produce
    an output value.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-3:</samp> <samp class="SANS_Futura_Std_Book_11">XOR
    Binary Output</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Input
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">XOR output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: As you can see, if the bits in Input A and Input B are equal, the resulting
    output value is 0\. If the bits are not equal, the output is 1.
  prefs: []
  type: TYPE_NORMAL
- en: Data is XOR’d based on a key, which is sometimes 1 byte long (but this can be
    adjusted, as you’ll see soon). Take a look at the XOR operation in [Table 16-4](chapter16.xhtml#tab16-4),
    which uses the 1-byte XOR key 0x35.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-4:</samp> <samp class="SANS_Futura_Std_Book_11">XOR
    Output with the Key 0x35</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input text</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">h</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">t</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">t</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">p</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">s</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Medium_11">Input (in binary)</samp> | <samp
    class="SANS_Futura_Std_Book_11">01101000</samp> | <samp class="SANS_Futura_Std_Book_11">01110100</samp>
    | <samp class="SANS_Futura_Std_Book_11">01110100</samp> | <samp class="SANS_Futura_Std_Book_11">01110000</samp>
    | <samp class="SANS_Futura_Std_Book_11">01110011</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Medium_11">XOR key (35)</samp> | <samp class="SANS_Futura_Std_Book_11">00110101</samp>
    | <samp class="SANS_Futura_Std_Book_11">00110101</samp> | <samp class="SANS_Futura_Std_Book_11">00110101</samp>
    | <samp class="SANS_Futura_Std_Book_11">00110101</samp> | <samp class="SANS_Futura_Std_Book_11">00110101</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Medium_11">Output (in binary)</samp> | <samp
    class="SANS_Futura_Std_Book_11">01011101</samp> | <samp class="SANS_Futura_Std_Book_11">01000001</samp>
    | <samp class="SANS_Futura_Std_Book_11">01000001</samp> | <samp class="SANS_Futura_Std_Book_11">01000101</samp>
    | <samp class="SANS_Futura_Std_Book_11">01000110</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Medium_11">Output text</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">F</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: In the Input Text row, the ASCII text string <samp class="SANS_TheSansMonoCd_W5Regular_11">https</samp>
    is being XOR’d using the key 0x35\. The Input (in Binary) row shows the binary
    equivalent of this <samp class="SANS_TheSansMonoCd_W5Regular_11">https</samp>
    string. The XOR Key (35) row shows the XOR key (0x35) in binary (00110101). The
    Output (in Binary) row is the XOR’d binary data, that is, the data after the XOR
    operation completes. And finally, the Output Text row shows the ASCII representation
    of the output. Note that XOR is reversible, meaning that to decrypt the output
    text, you simply need to XOR it again using the same key of 0x35, which will produce
    a result of <samp class="SANS_TheSansMonoCd_W5Regular_11">https</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: This is just a simple example using a 1-byte XOR key, but in reality, malware
    often complicates the encryption process by using a longer key. If, for example,
    malware uses a 5-byte key such as 0x356C2DA155, as shown in [Table 16-5](chapter16.xhtml#tab16-5),
    each byte in the key is XOR’d against each byte in the input data, starting with
    the first byte and repeating.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-5:</samp> <samp class="SANS_Futura_Std_Book_11">XOR
    Output with the Key 0x356C2DA155</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input text</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">h</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">t</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">t</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">p</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">s</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Medium_11">Input (in binary)</samp> | <samp
    class="SANS_Futura_Std_Book_11">01101000</samp> | <samp class="SANS_Futura_Std_Book_11">01110100</samp>
    | <samp class="SANS_Futura_Std_Book_11">01110100</samp> | <samp class="SANS_Futura_Std_Book_11">01110000</samp>
    | <samp class="SANS_Futura_Std_Book_11">01110011</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Medium_11">XOR key</samp> | <samp class="SANS_Futura_Std_Book_11">00110101
    (35)</samp> | <samp class="SANS_Futura_Std_Book_11">11011000 (6C)</samp> | <samp
    class="SANS_Futura_Std_Book_11">10110100 (2D)</samp> | <samp class="SANS_Futura_Std_Book_11">10100001
    (A1)</samp> | <samp class="SANS_Futura_Std_Book_11">10101010 (55)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Medium_11">Output (in binary)</samp> | <samp
    class="SANS_Futura_Std_Book_11">01011101</samp> | <samp class="SANS_Futura_Std_Book_11">10101100</samp>
    | <samp class="SANS_Futura_Std_Book_11">11000000</samp> | <samp class="SANS_Futura_Std_Book_11">11010001</samp>
    | <samp class="SANS_Futura_Std_Book_11">11011001</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Medium_11">Output text</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">]</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Y</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Ñ</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Now the <samp class="SANS_TheSansMonoCd_W5Regular_11">https</samp> ASCII text
    string is XOR’d with a key of 0x356C2DA155, which is broken down into multiple
    columns for simplicity. Each byte of the key will be XOR’d against one of the
    text bytes. The output in binary is shown in the fourth row, followed by the text
    representation of the XOR’d output. For a more complete explanation of the technical
    intricacies of XOR operations, see [*https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Exclusive<wbr>_or*](https://en.wikipedia.org/wiki/Exclusive_or).
  prefs: []
  type: TYPE_NORMAL
- en: XOR can be quite useful for malware authors; it is fast, efficient, and simple
    to implement. It does have its drawbacks, however. As I mentioned previously,
    you can decrypt XOR’d data by simply providing it with the same key used to encrypt
    it. For XOR to work properly, the XOR key must be hardcoded in the malware’s code,
    and an experienced reverse engineer may be able to locate it. Additionally, due
    to the fact that XOR keys are sometimes only a byte or a few bytes long, you can
    often brute-force the XOR’d data by running it through all combinations of XOR
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: There are several tools that do this. For example, XORSearch by Didier Stevens
    ([*https://<wbr>blog<wbr>.didierstevens<wbr>.com<wbr>/programs<wbr>/xorsearch<wbr>/*](https://blog.didierstevens.com/programs/xorsearch/))
    will search for strings in the input file, try different XOR keys (as well as
    other encodings), and print the results. I ran an executable through XORSearch
    and received the result shown in [Figure 16-6](chapter16.xhtml#fig16-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-6: Output from the
    XORSearch tool</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command in the first line includes a couple of parameters: <samp class="SANS_TheSansMonoCd_W5Regular_11">-p</samp>
    tells XORSearch to search specifically for encoded PE files, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">-s</samp>
    switch tells XORSearch to dump the executable if it finds one. This executable
    has five additional executables embedded inside it, four of which are encoded
    with XOR (the first result can be ignored, as it simply contains the PE header
    of the input file). XORSearch shows the XOR key (highlighted in column 1) and
    the offset address where the embedded file sits (highlighted in column 2).'
  prefs: []
  type: TYPE_NORMAL
- en: You can easily spot XOR in malware using a disassembler or debugger; the instruction
    is simply <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp>. In IDA Pro,
    once your malware sample is loaded in, navigate to **Search****Text**, type <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">xor</samp> as the search string, and click
    **Find All Occurrences**. [Figure 16-7](chapter16.xhtml#fig16-7) shows some example
    output.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-7: Viewing xor instructions
    in IDA Pro</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first XOR operation in this figure isn’t of interest to us. XORing a register
    with itself simply clears the register, setting it to 0\. This is the most common
    use of XOR in executable files, and it’s not specifically relevant to encryption.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom three <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> operations
    are the ones we care about. In these examples, a CPU register is being XOR’d with
    a memory address. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">xor al,
    [edx]</samp> instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">al</samp>
    is the register and <samp class="SANS_TheSansMonoCd_W5Regular_11">[edx]</samp>
    is the memory address. In a case like this, the register often contains the XOR
    key, which is being XOR’d with data stored in memory. The opposite can also be
    true.
  prefs: []
  type: TYPE_NORMAL
- en: If you spot XORing in code, you can decrypt that data by locating the target
    encrypted data and the XOR key in code. In the case of <samp class="SANS_TheSansMonoCd_W5Regular_11">xor
    al, [edx]</samp>, you can inspect the <samp class="SANS_TheSansMonoCd_W5Regular_11">al</samp>
    register to look for the XOR key. Additionally, inspecting the memory pointer
    in EDX will likely lead you to the data that is being XOR’d. Analyzing the malware
    dynamically inside a debugger can help with this.
  prefs: []
  type: TYPE_NORMAL
- en: Once you locate the data and XOR key, you can copy the data from the file and
    XOR it using the key. Any number of tools will work for this, but we’ll use CyberChef
    again. [Figure 16-8](chapter16.xhtml#fig16-8) demonstrates its use with an XOR
    key of 1A2D3F.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-8: XOR decoding in
    CyberChef</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Malware often decrypts XOR’d data and code in memory prior to executing this
    code. One reverse engineering tactic is to let the malware decrypt this data for
    you and then obtain it. You can do so using a debugger, which I’ll discuss in
    “Decrypting Encrypted Malware Data” on [page 339](chapter16.xhtml#pg_339).
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, in addition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp>
    instruction, there are a few other basic methods that some malware uses to obfuscate
    code and data, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ror</samp>
    (rotate right) and <samp class="SANS_TheSansMonoCd_W5Regular_11">rol</samp> (rotate
    left), which simply rotate the bytes a specific number of spaces in either direction.
    Consider, for example, the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">ror
    eax, 5</samp>. If EAX contains the value <samp class="SANS_TheSansMonoCd_W5Regular_11">12345678</samp>,
    when you rotate all digits five places to the right, the new value is <samp class="SANS_TheSansMonoCd_W5Regular_11">45678123</samp>.
    All digits have shifted five spaces to the right so that the digits that were
    “pushed off” the end (4, 5, 6, 7, and 8) are now at the beginning of the string.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">rol</samp> instruction reverses
    this operation.
  prefs: []
  type: TYPE_NORMAL
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Rivest Cipher 4</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Rivest Cipher 4, or RC4, is one of the most common stream encryption algorithms
    used by malware because it is simple to implement and relatively strong (compared
    with basic encoding like Base64 or even XOR). The basic steps of how it works
    are illustrated in [Figure 16-9](chapter16.xhtml#fig16-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-9: An overview of
    how RC4 works</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, the algorithm creates an array of values, called an *Sbox*, of 256 bytes
    (or 0x100 in hex). This is Sbox 1\. Another Sbox (Sbox 2) is initialized and contains
    the encryption key. The RC4 key length can be between 1 and 256 bytes. This key
    can be hardcoded in the malware’s executable file or generated dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Sbox 1 and Sbox 2 then combine, and their data is scrambled multiple times to
    create a semi-random byte stream. The plaintext (the data being encrypted) is
    then XOR’d with this byte stream, which is essentially an XOR key. When this encrypted
    data needs to be decrypted, the data is XOR’d again with the same key stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with encryption and decryption routines in code, you may be able
    to easily spot certain algorithms in use. The 256-byte array is a telltale sign
    that RC4 is in use. You’ll likely see <samp class="SANS_TheSansMonoCd_W5Regular_11">0x100</samp>
    referenced multiple times in the code, followed by loops, as in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This example shows what RC4 might look like in a malware sample. The first block
    of code shows the Sbox 1 array being initialized and a comparison operation to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x100</samp> ❶. Notice the jump
    back to the beginning of the function ❷, signifying a loop. In the second block,
    there is another reference to <samp class="SANS_TheSansMonoCd_W5Regular_11">0x100</samp>
    (Sbox 2) and the subsequent comparison operation ❸, as well as a loop ❹. These
    two function loops in code can often reveal that RC4 is being used.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Windows CryptoAPI</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Windows provides its own implementation of many common encryption algorithms,
    called the *Microsoft Cryptography API (CryptoAPI)*. This API includes support
    for many common symmetric and asymmetric encryption algorithms, along with other
    services such as digital certificates and hashing. The CryptoAPI also includes
    an update that appeared in Windows Vista called the *Cryptography API: Next Generation
    (CNG)*. CNG contains the latest cryptographic libraries provided in Windows, adding
    support for modern algorithms as well as for custom cryptography APIs. CNG largely
    replaces the CryptoAPI in newer versions of Windows. Although the CryptoAPI is
    deprecated, it’s important to discuss it, as it’s still heavily used by malware
    because it has a long history and is well understood.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">CryptoAPI Functions</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When initializing the CryptoAPI, one of the key functions that applications
    are required to call is <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptAcquireContext</samp>.
    This function is responsible for returning a handle to a *cryptographic service
    provider (CSP)*, a module that performs encryption and decryption functions and
    stores associated encryption keys. Since CSPs are integral to some Windows programs,
    they are tightly controlled. Applications don’t have direct access to the internals
    of the CSP; everything is handled indirectly via API function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 16-6](chapter16.xhtml#tab16-6) describes <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptAcquireContext</samp>
    and some of the other important functions exposed in the CryptoAPI.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-6:</samp> <samp class="SANS_Futura_Std_Book_11">Important
    CryptoAPI Functions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptAcquireContext</samp>
    | <samp class="SANS_Futura_Std_Book_11">Gets a handle to a specific key container
    that is a precur</samp><samp class="SANS_Futura_Std_Book_11">sor for nearly all
    cryptographic operations.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptGenKey</samp> | <samp
    class="SANS_Futura_Std_Book_11">Generates a public and private key pair for asymmetric
    cryptography or generates a random session key.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptGenRandom</samp> | <samp
    class="SANS_Futura_Std_Book_11">Fills a buffer with random bytes and is sometimes
    used to generate keys.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp> | <samp
    class="SANS_Futura_Std_Book_11">Encrypts data from a plaintext buffer.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp> | <samp
    class="SANS_Futura_Std_Book_11">Decrypts data that was encrypted using</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp><samp class="SANS_Futura_Std_Book_11">.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDestroyKey</samp> | <samp
    class="SANS_Futura_Std_Book_11">Destroys a handle to a key. This is a common cleanup
    function.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptReleaseContext</samp>
    | <samp class="SANS_Futura_Std_Book_11">Releases the handle to a CSP and associated
    key containers. This is a common cleanup function.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptCreateHash</samp> | <samp
    class="SANS_Futura_Std_Book_11">Starts the hashing process for a stream of data
    and initializes a hash object that will be used to store hash data.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDestroyHash</samp> | <samp
    class="SANS_Futura_Std_Book_11">Destroys a hash object. This is a common cleanup
    function.</samp> |'
  prefs: []
  type: TYPE_TB
- en: The most interesting functions in this table are <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp>. <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp>
    takes many parameters, such as a handle to an encryption key (created with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CryptGenKey</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptImportKey</samp>)
    and a pointer to the buffer containing the plaintext data to be encrypted. If
    you’re analyzing a malware sample that uses cryptographic operations and calls
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp> to encrypt data,
    you can set a breakpoint on this function in a debugger and inspect the plaintext
    buffer, which will expose the data being encrypted! You’ll see an example of this
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Oftentimes, developers add wrappers around these cryptographic functions to
    simplify implementation so that the software developer doesn’t have to call each
    of these functions directly, which reduces programming errors. This is noteworthy
    because some malware authors invoke the crypto libraries directly in their code,
    rather than using the many wrappers that are available. Since malware developers
    are, in fact, human and prone to making mistakes, invoking these Windows crypto
    functions directly can be problematic for inexperienced malware developers. One
    ransomware malware family, CryptoLocker, had a flaw in its implementation of the
    RSA encryption algorithm, making it easy to decrypt its encrypted ransomed files.
    Researchers from Emsisoft discovered that CryptoLocker was implementing <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CryptAcquireContext</samp> incorrectly.
    One of this function’s parameters accepts flag values that enable additional features.
    One flag, <samp class="SANS_TheSansMonoCd_W5Regular_11">CRYPT_VERIFYCONTEXT</samp>,
    must be set, or the generated private encryption key will be stored on the local
    host. This flaw was quite problematic for CryptoLocker. If the decryption key
    is stored locally on the host, a victim can easily recover their files if they
    know where to look. This is exactly what Emsisoft did, and it recovered many victims’
    files. See the post “CryptoDefense: The Story of Insecure Ransomware Keys and
    Self-Serving Bloggers” on the Emsisoft blog ([*https://<wbr>www<wbr>.emsisoft<wbr>.com<wbr>/en<wbr>/blog<wbr>/6032<wbr>/cryptodefense<wbr>-the<wbr>-story<wbr>-of<wbr>-insecure<wbr>-ransomware<wbr>-keys<wbr>-and<wbr>-self<wbr>-serving<wbr>-bloggers<wbr>/*](https://www.emsisoft.com/en/blog/6032/cryptodefense-the-story-of-insecure-ransomware-keys-and-self-serving-bloggers/))
    for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: The Windows CryptoAPI is fairly complex and features many different functions.
    For much more detailed information on these functionalities, refer to Microsoft’s
    excellent article “CryptoAPI System Architecture” on MSDN ([*https://<wbr>learn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/windows<wbr>/win32<wbr>/seccrypto<wbr>/cryptoapi<wbr>-system<wbr>-architecture*](https://learn.microsoft.com/en-us/windows/win32/seccrypto/cryptoapi-system-architecture)).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">CryptoAPI Analysis in Practice</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now let’s see how the Windows CryptoAPI looks in practice; specifically, let’s
    examine how a hashing algorithm is implemented. This malware sample will get the
    DNS domain name that the victim system is part of, hash it, and compare the hash
    to a hardcoded hash: the domain name that the malware is targeting. If the hashes
    don’t match (meaning the victim domain doesn’t match the target domain), the malware
    won’t infect the victim system. Additionally, storing the hardcoded domain name
    in a hashed state makes it a lot more difficult (if not impossible) for a reverse
    engineer to discover which domain name the malware is actually looking for. Let’s
    take a closer look in practice with the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the malware first defines its target domain name, *victimcompany.com*.
    The SHA256 hash of this string is <samp class="SANS_TheSansMonoCd_W5Regular_11">4b557a3281181193f1b1fae7228314e77d174fa13b59f606c5400409f13875a2</samp>,
    which is stored in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">hashedTargetDomain</samp>
    ❶. Next, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetComputerNameExA</samp>
    with the parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">ComputerNameDnsDomain</samp>
    to get the infected victim’s domain, which will be stored in the memory buffer
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">domainName</samp> ❷. Then,
    it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptAquireContextA</samp>
    ❸ with the following parameters: a pointer to the location in memory where the
    CSP handle will be stored, the key container name (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>),
    the CSP to be used (<samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>
    signifies that the default Windows provider will be used), the provider type (0x18,
    or the Microsoft Enhanced RSA and AES Cryptographic Provider), and the flags parameter.
    Most of these parameters are inconsequential here. The most important one to mention
    is the cryptographic provider type: in this case, the Microsoft Enhanced RSA and
    AES Cryptographic Provider, which supports a variety of hashing and encryption
    formats.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For the complete list of types Microsoft supports, see “Cryptographic Provider
    Types” at* [https://learn.microsoft.com/en-us/windows/win32/seccrypto/cryptographic-provider-types](https://learn.microsoft.com/en-us/windows/win32/seccrypto/cryptographic-provider-types).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the malware gets a handle to the key container, it then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptCreateHash</samp>
    to create a handle to a hash object ❹. This hash object must be created prior
    to generating a hash. This function takes the following parameters: a handle to
    the newly created cryptographic service provider (<samp class="SANS_TheSansMonoCd_W5Regular_11">hCSP</samp>),
    the algorithm ID (<samp class="SANS_TheSansMonoCd_W5Regular_11">x800C</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">CALG_SHA_256</samp>), the hash
    key, an optional flags value, and a pointer to the handle of the new hash object
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">hHash</samp>). Since the malware
    is passing in the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">CALG_SHA_256</samp>
    for the algorithm ID parameter, we can assume that the malware is using the SHA256
    hashing algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To finally obtain the hash of the victim’s domain, the malware calls <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CryptHashData</samp> to create a hash
    from the domain string ❺. When the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptHashData</samp>
    function, it passes in the following parameters: the handle to the hash object
    created previously (<samp class="SANS_TheSansMonoCd_W5Regular_11">hHash</samp>),
    a pointer to the buffer that contains the data to be hashed (<samp class="SANS_TheSansMonoCd_W5Regular_11">domainName</samp>),
    the data length of the hash, and an optional flags value. After this function
    is called, the hashed value of the domain name will be stored in the hash object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve the hashed data, the malware must call <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptGetHashParam</samp>
    ❻. The parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptGetHashParam</samp>
    are as follows: a handle to the hash object (<samp class="SANS_TheSansMonoCd_W5Regular_11">hHash</samp>),
    the query type (the type of data being requested, such as the hash size or the
    hash value), a pointer to the buffer that will receive the requested data, the
    size of the returned data, and an optional flags value. This malware calls <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CryptGetHashParam</samp> twice: once to
    get the size of the hashed data, and once to get the actual hashed data (the hash
    of the victim’s domain name). Toward the end of this function, the malware calls
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDestroyHash</samp> to destroy
    the hash object ❼ and <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptReleaseContext</samp>
    to release the handle of the key container and CSP ❽. These are standard cleanup
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the malware must compare the hardcoded hashed value with the hashed
    value of the victim’s domain name to determine if the victim is its correct target.
    To do this, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">memcmp</samp>,
    or memory compare, a function that compares two values in memory ❾. The values
    being compared are <samp class="SANS_TheSansMonoCd_W5Regular_11">hashedDomainName</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">hashedTargetDomain</samp>. If
    these values match (meaning that the host is part of the malware’s target domain),
    the malware continues to infect the host. If they do not match, the malware will
    terminate itself.
  prefs: []
  type: TYPE_NORMAL
- en: This malware code example uses a *guardrail*, a safety measure put in place
    by the malware author to avoid infecting unintended victims. This type of guardrail
    can also be used as a sandbox evasion technique, as the malware won’t execute
    properly in a sandbox environment that doesn’t have the domain name the malware
    is looking for.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Windows Cryptographic
    API: Next Generation</samp>'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given that it’s simply an update to the CryptoAPI, CNG is functionally very
    similar. However, nearly all CNG functions are prefixed with a <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>,
    which helps differentiate the two APIs. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp>
    is part of the CryptoAPI, while <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptEncrypt</samp>
    is part of the CNG. [Table 16-7](chapter16.xhtml#tab16-7) outlines some of the
    common CNG functions you may spot in malware.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 16-7:</samp> <samp class="SANS_Futura_Std_Book_11">Important
    CNG Functions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Function</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptOpenAlgorithmProvider</samp>
    | <samp class="SANS_Futura_Std_Book_11">Initializes a cryptographic provider.
    This is very similar to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptAcquireContext</samp>
    <samp class="SANS_Futura_Std_Book_11">from the CryptoAPI.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptGenerateKeyPair</samp>
    | <samp class="SANS_Futura_Std_Book_11">Initializes a public/private key pair
    for asymmetric cryptography.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptGenerateSymmetricKey</samp>
    | <samp class="SANS_Futura_Std_Book_11">Generates a key for symmetric cryptography.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptEncrypt</samp> | <samp
    class="SANS_Futura_Std_Book_11">Encrypts plaintext data.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptDecrypt</samp> | <samp
    class="SANS_Futura_Std_Book_11">Decrypts data.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptDestroyKey</samp> | <samp
    class="SANS_Futura_Std_Book_11">Destroys a key object. This is a common cleanup
    function.</samp> |'
  prefs: []
  type: TYPE_TB
- en: 'Because of its similarities to the CryptoAPI, I won’t cover the CNG in more
    detail in this book. For more information, see the “Cryptography API: Next Generation”
    page in Microsoft’s knowledge database ([*https://<wbr>learn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/windows<wbr>/win32<wbr>/seccng<wbr>/cng<wbr>-portal*](https://learn.microsoft.com/en-us/windows/win32/seccng/cng-portal)).'
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll turn to some tips you can apply to overcome encryption in malware.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Practical Tips for Overcoming Encryption
    in Malware</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When faced with a malware sample that is using cryptography to obfuscate its
    strings, code, or network communications, you often need to identify where these
    cryptographic operations are occurring in order to reveal the malware’s intentions.
    This section will provide some general and practical advice on how to locate and
    identify cryptographic functions in malware code and perhaps uncover data that
    the malware author doesn’t want you to see.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Locating and Identifying
    Cryptographic Routines</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Generally, there are a few ways to locate and identify encryption algorithms
    in malware. First, you can find behaviors in the code that match a particular
    algorithm. For example, in RC4, as noted previously, the two 256-byte (0x100)
    arrays and their associated loops are often a dead giveaway. You can also inspect
    the malware’s code for common instructions used in crypto algorithms, such as
    <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">rol</samp>.
    This is a more generic approach, but it’s useful for locating many types of algorithms
    or even custom implementations. Lastly, looking for calls to CryptoAPI or CNG
    functions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp>,
    can be revealing as well.
  prefs: []
  type: TYPE_NORMAL
- en: There are several tools that can help you immensely with locating and identifying
    crypto routines. CAPA, which was introduced in [Chapter 3](chapter3.xhtml), can
    perform basic code analysis of a binary file and provide a lot of useful information
    that can help guide your manual code analysis of a malware sample. CAPA can also
    locate crypto algorithms in use in malware, as shown in [Figure 16-10](chapter16.xhtml#fig16-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-10: Viewing RSA usage
    in CAPA</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here you can see that this sample, which happens to be a variant of the Ryuk
    ransomware family, is using RSA asymmetric encryption. CAPA even shows us where
    this data is located in the code (function 0x13F4E6018).
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, in [Figure 16-11](chapter16.xhtml#fig16-11), CAPA located RC4 encryption
    in a different sample.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-11: Viewing RC4 usage
    in CAPA</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this extract, CAPA has identified encryption code in the malware sample.
    Specifically, it has discovered code possibly related to RC4, as well as several
    associated CryptoAPI calls (<samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDeriveKey</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptAcquireContext</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: IDA Pro and Ghidra disassemblers both have plug-ins available for locating and
    identifying crypto routines. While CAPA is a more agnostic tool that doesn’t require
    a disassembler, the advantage of using disassembler plug-ins is that you can quickly
    examine the code that contains the interesting crypto functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two plug-ins for IDA Pro:'
  prefs: []
  type: TYPE_NORMAL
- en: FindCrypt2 ([*https://<wbr>hex<wbr>-rays<wbr>.com<wbr>/blog<wbr>/findcrypt2<wbr>/*](https://hex-rays.com/blog/findcrypt2/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDA Signsrch ([*https://<wbr>github<wbr>.com<wbr>/nihilus<wbr>/IDA<wbr>_Signsrch*](https://github.com/nihilus/IDA_Signsrch))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here are two for Ghidra:'
  prefs: []
  type: TYPE_NORMAL
- en: FindCrypt ([*https://<wbr>github<wbr>.com<wbr>/d3v1l401<wbr>/FindCrypt<wbr>-Ghidra*](https://github.com/d3v1l401/FindCrypt-Ghidra))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FindCrypt (a more recent, updated version; [*https://<wbr>github<wbr>.com<wbr>/TorgoTorgo<wbr>/ghidra<wbr>-findcrypt*](https://github.com/TorgoTorgo/ghidra-findcrypt))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 16-12](chapter16.xhtml#fig16-12) shows the first Ghidra FindCrypt plug-in
    in action.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-12: Locating encryption
    code with the FindCrypt Ghidra plug-in</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: FindCrypt has found two possible hashing algorithms in use (SHA_1 and MD4) and
    prints the offset to the code where the data might reside. Keep in mind that open
    source tools like these are always in flux; developers may stop maintaining them
    at any time. It’s best to continually look for new tools and plug-ins to aid you
    in your malware analysis efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes a malware sample may be using a custom crypto algorithm or an otherwise
    heavily modified, obfuscated, or uncommon algorithm. This is where generic identification
    of encryption/decryption routines is more helpful. These cryptographic routines
    typically follow a similar pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the data to be encrypted or decrypted will be loaded, usually in the
    form of a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> operation.
    The following malware code shows data (<samp class="SANS_TheSansMonoCd_W5Regular_11">ebp+encrypted_data</samp>)
    being moved into a register (<samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp>):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, computations are performed on the data. This almost always involves loops
    in the code, possibly mathematical instructions (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">mul</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>),
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> or shift instructions
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>,
    and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the manipulated data is stored for later use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the malware is moving the newly decrypted data to the stack ❶.
    There will also likely be one or more loops and a loop counter ❷, which will jump
    back to the data read instruction and load more data for decryption ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what do you do when you’ve found the encrypted data?  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Decrypting
    Encrypted Malware Data</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you’ve located and possibly identified a crypto algorithm in a malware
    sample; the malware contains encrypted data that will be decrypted using this
    algorithm at runtime. There are two methods to approach this: static and dynamic.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Static Decryption</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Static decryption* allows you to decrypt the target data in the malware executable
    file itself, without running the malware. Static decryption has the advantage
    that you can run decryption tools on malware files at scale, saving you a lot
    of effort if you’re investigating many samples at a time. The challenge of static
    decryption is that you must reverse engineer the crypto routines in the malware,
    a process that can range from easy to very difficult depending on the encryption
    algorithm being used and the way it is implemented. Malware authors also can change
    encryption keys or algorithms across different samples of the malware, which may
    negate the “at scale” advantage just mentioned.'
  prefs: []
  type: TYPE_NORMAL
- en: To conduct static decryption, you must first identify the encryption algorithm
    in place and the encryption keys required, which are often hardcoded in the malware
    or residing in memory. The Python API PyCrypto ([*https://<wbr>pypi<wbr>.org<wbr>/project<wbr>/pycrypto<wbr>/*](https://pypi.org/project/pycrypto/))
    can be used to automate tasks like this. Alternatively, CyberChef is a great tool
    for decoding many different data types and can help you quickly decrypt the data
    you find in malware.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dynamic Decryption</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Dynamic decryption* involves running the malware (or emulating the code in
    the malware), allowing the malware to decrypt its secrets, and “catching” the
    decrypted data using the help of a tool like a debugger. The advantage of dynamic
    decryption is that it is often less time-consuming than static decryption methods
    and a great way to quickly get to the data you want. The downsides are that dynamic
    decryption is more difficult to do at scale and that malware often guards its
    encrypted data with anti-analysis traps.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through two analysis scenarios that will teach you some tricks for
    quickly decrypting malware’s secrets dynamically. These are general tricks that
    work independently of the encryption algorithm employed by the malware.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Decrypted Code and Data Capture</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Malware may contain encrypted code that is dynamically decrypted in memory at
    runtime. This helps the malware evade host-based defenses and makes reverse engineering
    difficult. When malware employs these techniques, the most efficient way to identify
    the data being decrypted is to catch it in its decrypted state! In the next example,
    this malware sample decrypts shellcode in memory and executes it. Let’s see if
    we can capture this shellcode after it is decrypted.
  prefs: []
  type: TYPE_NORMAL
- en: '> <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '*This example uses a malware executable that you can download from VirusTotal
    or MalShare, using the following file hash:*'
  prefs: []
  type: TYPE_NORMAL
- en: 'SHA256: db136799d9e0854fdb99b453a0ebc4c2a83f3fc823c3095574832b6ee5f96708'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: First, load the sample into your disassembler of choice. I’ve used IDA Pro.
    To identify the encryption algorithm used in this sample and locate the decryption
    code, you can use a tool such as CAPA, or you can simply search for <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp>
    operations using the disassembler’s search functionalities. [Figure 16-13](chapter16.xhtml#fig16-13)
    shows part of the output of this XOR search in IDA Pro.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-13: Viewing xor instructions
    in IDA Pro</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: There are many instances of the <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp>
    instruction in this executable, most of them benign. Remember, XORing a register
    with the same register essentially clears that register. So, <samp class="SANS_TheSansMonoCd_W5Regular_11">xor
    eax, eax</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">xor ecx, ecx</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">xor edx, edx</samp> aren’t noteworthy
    to us. Let’s check out the instructions <samp class="SANS_TheSansMonoCd_W5Regular_11">xor
    [esi], al</samp> by double-clicking the entry. [Figure 16-14](chapter16.xhtml#fig16-14)
    shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-14: Viewing the encryption
    routine in IDA Pro</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code block contains several mathematical instructions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>. There are also several
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions that appear
    to be shifting data around, as well as <samp class="SANS_TheSansMonoCd_W5Regular_11">inc</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dec</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">jnz</samp>,
    indicating a loop. At first glance, this appears to be a crypto function!
  prefs: []
  type: TYPE_NORMAL
- en: If you inspect the code blocks above the function we’re currently in, you may
    spot some additional indicators of cryptography in use. There’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp
    ebx, 100h</samp> instruction and what appears to be another loop, as shown in
    [Figure 16-15](chapter16.xhtml#fig16-15).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-15: Viewing an RC4
    loop in IDA Pro</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, at offset <samp class="SANS_TheSansMonoCd_W5Regular_11">0x0045B684</samp>,
    there’s another loop and <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp ebx,
    100h</samp> instruction, shown in [Figure 16-16](chapter16.xhtml#fig16-16).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-16: Another RC4 loop
    in IDA Pro</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This is looking like RC4\. Now that we’ve likely found the encryption routine
    in use, we can identify where in the code the data will be fully decrypted, set
    a breakpoint on this address in a debugger, and wait for the data to be decrypted
    for us! First, we should identify where to set our breakpoint. The function we’re
    currently in is <samp class="SANS_TheSansMonoCd_W5Regular_11">sub_45B794</samp>.
    If you select this function in the IDA Pro disassembler or graph view and press
    X, you’ll find a list of cross-references to it (that is, other functions that
    are calling <samp class="SANS_TheSansMonoCd_W5Regular_11">sub_45B794</samp>).
    Double-click the function that appears in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">lea
    ebx, [ebp+var_BEEP]</samp>, as indicated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> instruction is
    loading an address into the EDX register. This is interesting because it comes
    directly after the RC4 decryption function we were just investigating (<samp class="SANS_TheSansMonoCd_W5Regular_11">sub_45B5AC</samp>).
    The address of this <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> instruction
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">0045B850</samp>. This is a good
    target for our debugger breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: For the debugging, I’ll use x64dbg. You could also use the built-in debugger
    in IDA Pro or another debugger of your choice. Load the sample into the debugger
    and select **Run to User Code** (to jump to the start of the malware’s code),
    set a breakpoint on the code of interest (**bp 0045B850**), and then run it (press
    F9 on your keyboard). This particular sample will sleep for 10 seconds or so before
    executing the code of interest (see [Figure 16-17](chapter16.xhtml#fig16-17)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-17: Setting a breakpoint
    on the decrypted code in x64dbg</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the breakpoint is hit, right-click <samp class="SANS_TheSansMonoCd_W7Bold_B_11">[ebp-BEEP]</samp>
    and select **Follow in Dump****Address: EBP-BEEP**. As [Figure 16-18](chapter16.xhtml#fig16-18)
    shows, we should now see our decrypted data in the Dump window!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-18: Viewing the decrypted
    code dumped in x64dbg</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This data is unfortunately not easily human readable. Let’s inspect it further.
    Extract this data by right-clicking the Dump window and selecting **Follow in
    Memory Map**. Then, right-click the highlighted memory region (it will be highlighted
    in gray in the Memory Map window) and select **Dump Memory to File**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the <samp class="SANS_TheSansMonoCd_W5Regular_11">strings</samp>
    command on the file or use a PE strings utility like PEStudio, you’ll see a few
    strings, but not much of interest. However, by using the strings deobfuscator
    tool FLOSS (which you might remember from [Chapter 2](chapter2.xhtml)), we can
    deobfuscate some of the data. You can run the FLOSS tool like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are telling FLOSS to treat this file as 32-bit shellcode. You can see
    output from FLOSS, which has recovered 52 stack strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It appears that this malware is building strings dynamically on the stack to
    obfuscate its data. You might be able to spot several suspicious strings in this
    output; note the references to sandboxes and virtual machines. This code is actually
    shellcode that the malware decrypts and then runs to conduct some basic sandbox
    checks. We won’t get into these details, however; this example is intended only
    to show the value of dynamic decryption. This trick not only works for RC4 but
    also for many other algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Capturing Code and Data Before
    Encryption</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Malware often employs encryption techniques to obfuscate network traffic, such
    as communication with a C2 server. The malware sample shown in [Figure 16-19](chapter16.xhtml#fig16-19)
    calls <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptEncrypt</samp> to encrypt
    its C2 information before sending the data to its control infrastructure. To capture
    the data in cleartext, I simply set a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptEncrypt</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-19: Setting a breakpoint
    on BCryptEncrypt in x64dbg</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can find this sample on MalShare or VirusTotal with the following hash:*'
  prefs: []
  type: TYPE_NORMAL
- en: 'SHA256: b2562b0805dd701621f661a43986f9ab207503d4788b655a659b61b2aa095fce'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the case of <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptEncrypt</samp>,
    the second value on the stack is the pointer to the buffer containing the plaintext
    data to be encrypted. This data appears to be my VM’s hostname (see [Figure 16-20](chapter16.xhtml#fig16-20)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig16-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-20: Viewing the data
    to be encrypted in x64dbg</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptEncrypt</samp> functions
    are used to encrypt data, and <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptDecrypt</samp> decrypt
    data. These functions are very useful for malware analysts to know. Simply place
    a breakpoint on these functions in a debugger, let the function run, inspect the
    buffer containing the data, and you’ve saved yourself a lot of analysis effort!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter discussed encoding, hashing, and encryption techniques that malware
    might use to obfuscate its code and data, adding one more layer of protection
    against analysis and reverse engineering and one more evasion technique to counter
    defenses. I hope you’ve picked up some useful tips you can use when investigating
    malware that employs these tactics. In the next chapter, we’ll look at another
    form of malware obfuscation: packers.'
  prefs: []
  type: TYPE_NORMAL
