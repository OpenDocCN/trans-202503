- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 18 DECLARING CLASSES AND CREATING OBJECTS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18 声明类并创建对象
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, you’ll learn how to define the structure of a class by using
    a class-declaration file, and you’ll practice creating individual objects of that
    class. You’ll see that classes with public properties let you directly change
    an object’s data, while classes with private properties mean you can change an
    object’s data only via its methods, some of which can perform validation. You’ll
    also learn about PHP “magic” methods that make it easier to write object-oriented
    code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何通过使用类声明文件来定义类的结构，并练习创建该类的各个对象。您将看到，具有公共属性的类允许您直接更改对象的数据，而具有私有属性的类则意味着您只能通过其方法来更改对象的数据，其中一些方法可以执行验证。您还将学习PHP的“魔术”方法，这些方法使编写面向对象的代码变得更容易。
- en: Declaring a Class
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明类
- en: 'A *class declaration* defines a class: it lays out the properties (variables)
    each object of that class will have, as well as the methods (functions) that can
    act upon those properties. A class declaration also establishes any relationship
    that class has with other classes (such as inheritance, which you’ll learn about
    in [Chapter 19](chapter19.xhtml)).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*类声明*定义了一个类：它列出了该类的每个对象将拥有的属性（变量），以及可以作用于这些属性的方法（函数）。类声明还建立了该类与其他类的任何关系（例如继承，您将在[第19章](chapter19.xhtml)中学习到）。'
- en: Like function declarations, class declarations are stored in PHP files in the
    *src* directory of a project. For all the projects in this book, each class will
    be declared in its own file; if a project has five classes, it will have five
    class-declaration files, and so on.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 像函数声明一样，类声明存储在项目的*src*目录中的PHP文件中。对于本书中的所有项目，每个类将声明在其自己的文件中；如果一个项目有五个类，那么它将有五个类声明文件，依此类推。
- en: NOTE
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*In this book, we won’t explore the advanced topic of* anonymous classes*,
    which is one of the few cases where more than one class may be declared in a single
    file. You can learn more at* [https://www.php.net/manual/en/language.oop5.anonymous.php](https://www.php.net/manual/en/language.oop5.anonymous.php)*.*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本书中，我们不会探讨*匿名类*这一高级主题，它是少数几个可以在一个文件中声明多个类的情况之一。您可以在[https://www.php.net/manual/en/language.oop5.anonymous.php](https://www.php.net/manual/en/language.oop5.anonymous.php)了解更多信息。*'
- en: By a well-established convention in OOP, both class names and class-declaration
    filenames always start with a capital letter. If the name includes multiple words,
    each word should start with a capital letter, with no spaces between the words.
    This is known as *upper camel case*, or sometimes *Pascal case*. Examples of valid
    class names include Product, NetworkSupplier, DesktopComputer, ReferenceBook,
    and InventoryItem.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据面向对象编程（OOP）中的约定，类名和类声明文件名始终以大写字母开头。如果名称包含多个单词，每个单词应以大写字母开头，且单词之间不应有空格。这被称为*大驼峰命名法*，有时也称为*Pascal命名法*。有效的类名示例包括Product、NetworkSupplier、DesktopComputer、ReferenceBook和InventoryItem。
- en: Throughout this chapter, we’ll work with a class called Product that can represent
    various items for sale through an e-commerce site. Let’s declare it now. Create
    a new directory for a new project, and in it create a *src* directory. In this
    *src* directory, create a *Product.php* file and enter the contents of [Listing
    18-1](#lis18-1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一个名为Product的类，它可以表示通过电子商务网站销售的各种商品。现在让我们来声明它。创建一个新目录用于新项目，并在其中创建一个*src*目录。在此*src*目录中，创建一个*Product.php*文件并输入[列表18-1](#lis18-1)的内容。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 18-1: The Product.php file to declare the Product class'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18-1：声明Product类的Product.php文件
- en: 'We start with the standard PHP beginning code tag, since we use PHP code to
    declare classes. Then we use the class keyword to state that we’re declaring a
    new class named Product. After the class name, enclosed in curly brackets, we
    define any properties or methods that will be associated with objects of that
    class. In this example, we declare two properties for each object of the Product
    class: name, which will be a string, and price, which will be a float. We declare
    both properties as public, meaning any part of our program with access to a Product
    object can read and change the values of its properties. We’ll explore the implications
    of public properties later in the chapter.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从标准的 PHP 起始代码标签开始，因为我们使用 PHP 代码来声明类。接着我们使用 class 关键字来声明一个名为 Product 的新类。类名后面跟着大括号，我们在其中定义与该类对象相关的任何属性或方法。在这个例子中，我们为每个
    Product 类的对象声明了两个属性：name，类型为字符串，以及 price，类型为浮点数。我们将两个属性声明为 public，这意味着程序的任何部分，只要能够访问
    Product 对象，都可以读取和修改其属性值。我们将在本章后面探讨 public 属性的含义。
- en: If we want all objects to have a *default value* for a property, we can assign
    a property a value in the class declaration. For example, if our system set an
    initial –1 price for every new Product object, we could have written public float
    $price = -1.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望所有对象在某个属性上都有一个*默认值*，我们可以在类声明中为该属性赋值。例如，如果我们的系统为每个新的 Product 对象设置一个初始的
    -1 价格，我们可以这样写：`public float $price = -1`。
- en: '[Figure 18-1](#fig18-1) shows a *Unified Modeling Language (UML)* class diagram
    visualizing the class we’ve just written. UML is a common tool for representing
    classes, objects, and their interactions through diagrams and text.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-1](#fig18-1) 显示了一个*统一建模语言（UML）*类图，直观地展示了我们刚刚编写的类。UML 是一种常用的工具，用于通过图表和文本表示类、对象及其交互。'
- en: '![](../images/figure18-1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure18-1.jpg)'
- en: 'Figure 18-1: The Product class'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18-1：Product 类
- en: The top row of the diagram indicates the class name (Product), and the second
    row lists the properties associated with that class, along with the data type
    expected for each property. The plus sign before each property name indicates
    that the properties have public visibility.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的第一行表示类名（Product），第二行列出了与该类相关的属性，并显示了每个属性预期的数据类型。每个属性名前的加号表示这些属性具有公共可见性。
- en: Creating an Object
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建对象
- en: You use the PHP keyword new to create an object of a class. The new keyword
    is followed by the name of the class for which an object is to be created, then
    a set of parentheses. Inside the parentheses, you may pass arguments for initialization,
    as we’ll discuss in “Initializing Values with a Constructor Method” on [page 346](#pg_346).
    The general form of a statement to create an object is thus new ClassName(). Creating
    an object is also called *instantiation*, since the object is an *instance* of
    the class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 PHP 关键字 new 来创建类的对象。new 关键字后跟类的名称，然后是一对圆括号。在圆括号内，你可以传递初始化参数，正如我们在《使用构造方法初始化值》一节中讨论的那样，参见
    [第 346 页](#pg_346)。创建对象的语句的一般形式是 `new ClassName()`。创建对象也叫做*实例化*，因为该对象是该类的*实例*。
- en: By writing the new keyword and a class name, you’re asking PHP to create a new
    object of the named class. When an object is created in the computer’s memory
    with the new keyword, the PHP engine automatically returns a reference to the
    new object. In most cases, you’ll want to store the reference to that newly created
    object in a variable—for example, $myObject = new ClassName(). It’s important
    to understand that with such statements, the variable $myObject doesn’t actually
    contain the object itself, but rather a *reference to* the object. It’s possible
    for several variables, or none, to refer to a particular object in memory.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过写下新关键字和类名，你是在要求 PHP 创建一个指定类的新对象。当一个对象在计算机内存中使用 new 关键字创建时，PHP 引擎会自动返回对新对象的引用。在大多数情况下，你会希望将对该新创建对象的引用存储在一个变量中——例如，`$myObject
    = new ClassName()`。重要的是要理解，对于这样的语句，变量 `$myObject` 实际上并不包含对象本身，而是包含了*对*该对象的引用。多个变量，甚至没有变量，都有可能引用内存中的同一个对象。
- en: Once you have a reference to an object, use the *object operator* (->) to access
    properties and methods of that object. For example, you could write $myObject->description
    to access the description property of the object referred to by $myObject. Likewise,
    you could invoke a setDescription() method of an object by writing something like
    $myObject->setDescription('small carpet'). The parentheses or lack thereof are
    important, since they tell the PHP engine (and people reading the code) whether
    a statement is attempting to access a property (no parentheses present) or a method
    (parentheses present).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你引用了一个对象，使用*对象操作符*（->）来访问该对象的属性和方法。例如，你可以写 $myObject->description 来访问由 $myObject
    引用的对象的 description 属性。同样，你可以通过写类似 $myObject->setDescription('small carpet') 的代码来调用对象的
    setDescription() 方法。括号的有无很重要，因为它们告诉 PHP 引擎（以及阅读代码的人）一条语句是在访问属性（没有括号）还是在调用方法（有括号）。
- en: 'With all this in mind, let’s create an object. We’ll write an *index.php* script
    to read in the *Product.php* class-declaration file, create a Product object,
    and set the values of its properties. [Figure 18-2](#fig18-2) shows our goal:
    a $product1 variable that stores a reference to a Product object whose properties
    have the values ''hammer'' and 9.99.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些，我们来创建一个对象。我们将编写一个 *index.php* 脚本，读取 *Product.php* 类声明文件，创建一个 Product 对象，并设置它的属性值。[图18-2](#fig18-2)展示了我们的目标：一个
    $product1 变量，存储了对一个 Product 对象的引用，该对象的属性值为 'hammer' 和 9.99。
- en: '![](../images/figure18-2.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure18-2.jpg)'
- en: 'Figure 18-2: The $product1 variable references an object of the Product class.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-2：$product1 变量引用了一个 Product 类的对象。
- en: For simplicity, we’ll start by creating a Product object and setting only its
    name property. To make sure our code is working, we’ll also print the value of
    the object’s name property to the project’s home page. In your project directory,
    create a *public* folder, and in that folder create an *index.php* file containing
    the code in [Listing 18-2](#lis18-2).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我们将从创建一个 Product 对象并仅设置它的 name 属性开始。为了确保我们的代码正常工作，我们还将打印该对象的 name 属性值到项目的主页。在你的项目目录中，创建一个
    *public* 文件夹，并在该文件夹中创建一个包含[清单18-2](#lis18-2)中代码的 *index.php* 文件。
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 18-2: An index.php script to create and manipulate a Product object'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 清单18-2：一个创建和操作 Product 对象的 index.php 脚本
- en: We read in the declaration for the Product class, using the __DIR__ magic constant
    to create a path from the location of this *index.php* file (in *public*) to the
    location of the *Product.php* file (in *src*). Then we use the new keyword to
    create a new object of the Product class. Since this class doesn’t require any
    initial values or options when creating objects, we don’t pass any arguments in
    the parentheses after the class name.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在声明 Product 类时，使用 __DIR__ 魔术常量从 *index.php* 文件所在位置（位于 *public* 文件夹内）创建路径到
    *Product.php* 文件所在位置（位于 *src* 文件夹内）。然后我们使用 new 关键字来创建一个 Product 类的新对象。由于该类在创建对象时不需要任何初始值或选项，我们在类名后面不传递任何参数。
- en: If you aren’t passing any arguments when you create a new object, PHP (unlike
    most object-oriented languages) allows you to omit the parentheses after the class
    name. Writing new Product() is the same as writing new Product. However, there
    are several good reasons to always include the parentheses, and so this is the
    style you’ll see throughout this book. Perhaps the most important reason to always
    use parentheses after the keyword new is to remind ourselves that a constructor
    method may be executed as the new object is created; we’ll look at such methods
    in “Initializing Values with a Constructor Method” on [page 346](#pg_346).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在创建新对象时没有传递任何参数，PHP（与大多数面向对象语言不同）允许你省略类名后面的括号。写 new Product() 和写 new Product
    是等价的。然而，有几个很好的理由总是包含括号，因此你将在本书中看到这种风格。也许最重要的理由是，始终在 new 关键字后使用括号可以提醒我们，构造方法可能会在新对象创建时执行；我们将在“使用构造方法初始化值”章节中讨论这类方法，详见[第346页](#pg_346)。
- en: The new Product() expression creates the new object and returns a reference
    to it, which we store in the $product1 variable. To reiterate, $product1 doesn’t
    contain the object itself, nor does it contain a copy of the object. It contains
    just a *reference to* the object created in the computer system’s memory. In “Object
    Variables as References” on [page 351](#pg_351), we’ll have two variables refer
    to the same object to help illustrate this concept.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the value of the object’s name property to the string 'hammer';
    we can do this because the property was declared as public. We use the object
    operator (->) after the $product1 variable to refer to the name property of that
    object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '> WARNING'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '*Do* not *write a dollar sign after the* -> *characters:* $product->name *is
    correct, and* $product->$name *is wrong. The PHP engine won’t create a warning
    or error if you write the latter, but it will interpret the code as meaning there’s
    a variable called* $name *whose value is the name of a property you want to access
    on the* $product *object. This is very different from accessing the value of the*
    $product *object’s* name *property. If your code is behaving strangely, check
    for this possible programming mistake.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the script ends by printing a message featuring the value retrieved
    from the $product object’s name property. If you run the web server and visit
    the project’s home page, you should see this line of text displayed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The -> operator lets you manipulate any of an object’s public properties by
    name. Let’s update our script to set and display the price of the object as well
    as its name. Modify the *index.php* file as shown in [Listing 18-3](#lis18-3).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 18-3: Setting and displaying the product price in index.php'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: We set the object’s price property to 9.99 following the same format we used
    in [Listing 18-2](#lis18-2) to set the name property. Then we display the value
    of the property. Notice that this time we use a double-quoted string to combine
    the message and property value. This illustrates that in double-quoted strings,
    a reference to a public property of an object, such as $product1->price, will
    be parsed and the resulting value will be output, just as with a simple variable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Visiting the home page again, you should see both the product name and price
    displayed:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’ve now created an object of the Product class, and since the class’s properties
    are public, we were able to set and retrieve the properties’ values directly.
    In practice, however, most classes are written with private rather than public
    properties.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Private Properties with Public Accessor Methods
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When properties are declared as private, they can’t be accessed by code outside
    the class declaration itself. Instead, they’re available through public *accessor
    methods*, functions that allow object property values to be retrieved (*getter
    methods*) or updated (*setter methods*). This mechanism of private properties
    with public accessor methods reduces the risk of invalid property values; when
    changes to a property must take place through a setter method, you can implement
    validation logic as part of the method (for example, preventing negative values
    or out-of-range values). Also, related properties or other objects might need
    to be updated together, such as the balance of one bank account being reduced
    by the same value that another account is increased. With setter methods and private
    properties, you can easily enforce such rules so that the data in the application
    stays correct and internally consistent.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性声明为private时，它们不能被类声明外的代码访问。相反，它们可以通过公共的*访问器方法*来访问，这些方法允许检索（*getter方法*）或更新（*setter方法*）对象属性值。使用私有属性和公共访问器方法的机制可以减少无效属性值的风险；当必须通过setter方法修改属性时，可以在方法中实现验证逻辑（例如，防止负值或超出范围的值）。此外，相关属性或其他对象可能需要一起更新，比如一个银行账户的余额减少与另一个账户的余额增加相同的数值。通过setter方法和私有属性，可以轻松强制执行这些规则，以确保应用程序中的数据保持正确且内部一致。
- en: The default visibility for class members is public, so if no access modifier
    is provided for a property, the PHP engine will automatically declare it as having
    public visibility. Even with this default behavior, it’s still good practice to
    explicitly use the public access modifier in the class declaration when you want
    a class member to have public visibility. Otherwise, use the private access modifier
    to make the member private.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 类成员的默认可见性是public，因此如果没有为属性提供访问修饰符，PHP引擎会自动将其声明为具有public可见性。即使有默认行为，当你希望类成员具有public可见性时，最好在类声明中明确使用public访问修饰符。否则，使用private访问修饰符将成员声明为私有。
- en: NOTE
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*In addition to* public *and* private*, a third access modifier,* protected*,
    can be used in conjunction with inheritance. We’ll explore this topic in [Chapter
    19](chapter19.xhtml).*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*public*和*private*，还有第三种访问修饰符，*protected*，可以与继承一起使用。我们将在[第19章](chapter19.xhtml)中探讨这个话题。
- en: For PHP and almost all OOP languages, a getter or setter method’s name usually
    starts with the word *get* or *set*, followed by the property name the method
    affects, with its first letter capitalized. According to this convention, the
    getter method for the name property of our Product class should be getName(),
    and its setter method should be setName(). For the price property, the methods
    should be getPrice() and setPrice(). An exception to this convention is made when
    a property contains a Boolean true/false value. In this case, naming the getter
    method isPropertyName rather than getPropertyName is customary. For example, if
    the Product class had a dangerousItem property that contained true or false, its
    getter would be named isDangerousItem().
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PHP和几乎所有的OOP语言，getter或setter方法的名称通常以*get*或*set*开头，后跟该方法影响的属性名称，并且首字母大写。根据这一惯例，我们的Product类的name属性的getter方法应为getName()，setter方法应为setName()。对于price属性，方法应为getPrice()和setPrice()。这个惯例的例外情况是当属性包含一个布尔值（true/false）时。在这种情况下，getter方法通常命名为isPropertyName，而不是getPropertyName。例如，如果Product类有一个名为dangerousItem的属性，其值为true或false，那么getter方法应命名为isDangerousItem()。
- en: A getter method usually returns a value of the same data type as the property
    it’s paired with (although sometimes we have multiple getter methods for different
    representations of an object’s property, such as methods to return both rounded-up
    integer and float values of a float property). A setter method usually takes in
    a parameter of the same type and stores its value in the property, perhaps conducting
    validation checks in the process. Usually, setter methods don’t return any value
    and so are declared to return void.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: getter方法通常返回与它所配对的属性相同数据类型的值（尽管有时我们会为对象属性的不同表示形式编写多个getter方法，例如返回浮动属性的四舍五入整数和浮动值的方法）。setter方法通常接收一个相同类型的参数，并将其值存储在属性中，可能在过程中进行验证检查。通常，setter方法不会返回任何值，因此它们声明为返回void。
- en: Let’s revise the declaration for the Product class, making its name and price
    properties private and adding four public accessor methods, two for each property.
    Update the *src/Product.php* file as shown in [Listing 18-4](#lis18-4).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改Product类的声明，将其name和price属性设为私有，并添加四个公共访问器方法，每个属性各两个。请按照[列表18-4](#lis18-4)所示更新*src/Product.php*文件。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 18-4: Modifying the Product class to use getter and setter methods'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18-4：修改Product类以使用getter和setter方法
- en: First, we change the declaration of the two properties to private. Then we declare
    getName(), the public getter method for the name property ❶. Methods in classes
    can use the special pseudo-variable $this to reference the calling object; that
    is, $this is a stand-in for the object whose properties and methods we’re working
    with. Our getName() method thus returns the value in the name property of whichever
    Product object the method is currently being called on. The method has a string
    return type, since the name property is a string.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将两个属性的声明修改为私有。然后，我们声明getName()，这是name属性的公共getter方法❶。类中的方法可以使用特殊的伪变量$`this`来引用调用对象；也就是说，$this代表我们正在操作的对象的属性和方法。因此，我们的getName()方法返回当前调用该方法的Product对象的name属性值。该方法的返回类型是字符串，因为name属性是一个字符串。
- en: We next declare setName(), the public setter method for the name property ❷.
    This method takes in a new string name value through the $name parameter and stores
    this value in the name property for the current object, again using $this to reference
    the object. This setter method returns void. The getter and setter methods for
    price follow the same pattern.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明setName()，这是name属性的公共setter方法❷。该方法通过$name参数接收一个新的字符串name值，并将该值存储到当前对象的name属性中，再次使用$`this`来引用该对象。此setter方法没有返回值。price的getter和setter方法遵循相同的模式。
- en: Notice in the body of setName() how PHP distinguishes between the $name parameter
    and the name property for the current object ❸. The former is prefixed by a dollar
    sign, while the latter is attached to $this-> and doesn’t have a dollar sign to
    indicate it’s a property of the current object. In other words, $name in the setName()
    method unambiguously refers to the value of the argument passed to the method,
    while the private name property of the object that has been sent the setName()
    message is unambiguously referred to by $this->name. The same goes for the float
    $price parameter of the setPrice() method versus the price property of the object
    the method is being called on.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在setName()方法体内，PHP如何区分$name参数和当前对象的name属性❸。前者以美元符号$开头，而后者附加在$`this->`后面，并且没有美元符号，表示它是当前对象的属性。换句话说，setName()方法中的$name明确指的是传递给该方法的参数值，而通过setName()方法接收到消息的对象的私有name属性则通过$`this->name`明确指代。同样的情况适用于setPrice()方法中的float
    $price参数和调用该方法的对象的price属性。
- en: When you write methods in a class-declaration file, you must always keep in
    mind that the same methods may be executed on zero, one, or thousands of objects,
    in response to objects receiving a message with the name of the method (and any
    required arguments). Although you may plan to create and use only one instance
    (object) of a class when you first write the declaration, a well-written class
    encapsulates the data (properties) and behavior (methods) for *any* object of
    that class. When you keep the general use in mind while programming, you can often
    use a class in other parts of the same project, or different projects altogether,
    with few or no changes required to the class declaration. Well-written class declarations
    lend themselves to reuse.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在类声明文件中编写方法时，必须时刻记住，同样的方法可能会在零个、一个或成千上万个对象上执行，这取决于对象收到带有方法名称（及任何必要参数）的消息。尽管你可能在编写声明时只打算创建并使用类的一个实例（对象），但一个编写良好的类封装了该类的*任何*对象的数据（属性）和行为（方法）。当你在编程时考虑到通用使用时，通常可以在同一个项目的其他部分，甚至是完全不同的项目中使用该类，而无需或几乎无需更改类声明。编写良好的类声明有助于复用。
- en: NOTE
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*While you can type out accessor methods yourself, many code editors, including
    PhpStorm, offer an automated feature to generate simple getter and setter methods
    for you. Autogenerating code is faster than typing it out by hand, and it ensures
    error-free scripts that follow PHP programming conventions.*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然你可以手动编写访问器方法，但许多代码编辑器，包括PhpStorm，提供了自动化功能来为你生成简单的getter和setter方法。自动生成代码比手动输入更快，并且可以确保生成遵循PHP编程规范的无错误脚本。*'
- en: Getting and Setting Private Properties
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取和设置私有属性
- en: Since the two properties of any Product object are now declared private, we
    can’t access them directly, such as by writing $product1->name or $product1->price.
    If you run the existing *index.php* script, you’ll get a fatal error about not
    being able to access the private name property. Instead, we have to read and modify
    these private properties by using their public accessor methods. [Listing 18-5](#lis18-5)
    shows how to update *index.php* to make use of these new methods.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任何 Product 对象的两个属性现在被声明为私有，我们无法直接访问它们，比如通过写 `$product1->name` 或 `$product1->price`。如果你运行现有的
    *index.php* 脚本，你会遇到一个关于无法访问私有 name 属性的致命错误。相反，我们必须通过使用它们的公共访问器方法来读取和修改这些私有属性。[列表
    18-5](#lis18-5) 显示了如何更新 *index.php* 来使用这些新方法。
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 18-5: Using accessor methods in index.php'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18-5：在 index.php 中使用访问器方法
- en: As in [Listing 18-3](#lis18-3), we create the $product1 object, set its properties,
    and print out those properties. This time, however, we rely entirely on accessor
    methods. We use setter methods to update the values of the object properties,
    such as $product1->setName('hammer'). Likewise, we use getter methods to retrieve
    values from the object, such as $product1->getName(). Thanks to these methods,
    the data in the $product1 object is safely encapsulated but still accessible.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在 [列表 18-3](#lis18-3) 中一样，我们创建了 $product1 对象，设置了它的属性，并打印出了这些属性。然而这次，我们完全依赖于访问器方法。我们使用
    setter 方法来更新对象属性的值，比如 `$product1->setName('hammer')`。同样，我们使用 getter 方法来从对象中获取值，比如
    `$product1->getName()`。得益于这些方法，$product1 对象中的数据被安全地封装，但仍然可以访问。
- en: Screening for Invalid Data
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 筛选无效数据
- en: One of the advantages of protecting the data properties of objects is that you
    can add validation logic to the setter methods to prevent invalid values from
    being stored in the properties. For example, most businesses probably wouldn’t
    want to set a negative price for a product (although something might be a free
    gift, so we’ll allow for a price of 0). We should therefore add an if statement
    to the setPrice() method that updates the stored price only if the new value is
    greater than or equal to 0\. [Listing 18-6](#lis18-6) shows how to update the
    method in *src/Product.php*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 保护对象数据属性的一个优点是，你可以向 setter 方法中添加验证逻辑，以防止无效值存储在属性中。例如，大多数企业可能不希望为产品设置负数价格（尽管某些东西可能是免费的赠品，因此我们会允许价格为
    0）。因此，我们应该在 setPrice() 方法中添加一个 if 语句，只有当新值大于或等于 0 时才更新存储的价格。[列表 18-6](#lis18-6)
    显示了如何更新 *src/Product.php* 中的方法。
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 18-6: Adding validation logic to the setPrice() method of the Product
    class'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18-6：向 Product 类的 setPrice() 方法添加验证逻辑
- en: In our validation logic, we confirm that the new $price argument is greater
    than or equal to 0 before setting the value of the object’s price property. To
    make sure the validation check works, we can update our *index.php* script to
    attempt to set an invalid, negative price value. We should see that the invalid
    values aren’t stored in the object. [Listing 18-7](#lis18-7) adds extra statements
    to *index.php* for two tests of the validation logic.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的验证逻辑中，我们确认新传入的 $price 参数大于或等于 0，然后再设置对象的价格属性。为了确保验证检查有效，我们可以更新 *index.php*
    脚本，尝试设置一个无效的负价格值。我们应该看到无效值不会被存储在对象中。[列表 18-7](#lis18-7) 为 *index.php* 添加了额外的语句，用于验证逻辑的两次测试。
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 18-7: Testing the setter validation logic in index.php'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18-7：在 index.php 中测试 setter 验证逻辑
- en: 'As before, we create a new Product object and set its price to 9.99. Then we
    try to set the price to an invalid negative value, and then a valid positive value
    that’s different from its initial value, printing the product price each time.
    Here’s the output of this script in the browser:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们创建一个新的 Product 对象并将其价格设置为 9.99。然后我们尝试将价格设置为无效的负数值，再设置一个有效的正数值，这个值与初始值不同，并且每次都打印出产品价格。以下是该脚本在浏览器中的输出：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For test 1 (a negative price of -0.5), the stored price remains unchanged at
    9.99. For test 2 (a nonnegative value of 22), the stored price is updated. Our
    validation logic has worked. In this example, we simply ignored the invalid value,
    but it’s generally better to somehow indicate that there was a problem. One option
    is for setters to return a Boolean false value when no value was set. Another
    option is to throw an Exception object, as we’ll explore in [Chapter 23](chapter23.xhtml).  ###
    Overriding Default Class Behavior with Magic Methods'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试 1（负价格 -0.5），存储的价格保持不变，仍为 9.99。对于测试 2（非负值 22），存储的价格被更新。我们的验证逻辑已经起作用。在这个例子中，我们只是忽略了无效值，但通常最好以某种方式表明存在问题。一种选择是，当没有设置值时，setters返回布尔值false。另一种选择是抛出一个异常对象，我们将在[第23章](chapter23.xhtml)中讨论。
- en: PHP offers several *magic methods* that override default behavior of an object.
    For example, the __construct() magic method overrides the default way objects
    of a class are created, and the __toString() magic method overrides the way objects
    are handled in print statements and other contexts requiring a string. We’ll explore
    each of these magic methods in this section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: PHP提供了多个*魔术方法*，用于重写对象的默认行为。例如，__construct()魔术方法重写了创建类的对象的默认方式，而__toString()魔术方法重写了在打印语句和其他需要字符串的上下文中处理对象的方式。在本节中，我们将逐一探讨这些魔术方法。
- en: Despite their name, magic methods are unrelated to PHP magic constants. Magic
    methods are a feature of object-oriented PHP, allowing the default behavior of
    an object to be changed. All magic methods have names beginning with double underscore
    characters (__); therefore, you should name methods with such a prefix only when
    declaring a magic method for a class. You can find a list of all the PHP magic
    methods at *[https://www.php.net/manual/en/language.oop5.magic.php](https://www.php.net/manual/en/language.oop5.magic.php)*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名称中有“魔术”二字，魔术方法与PHP的魔术常量无关。魔术方法是面向对象PHP的一个特性，它允许更改对象的默认行为。所有魔术方法的名称都以双下划线（__）开头；因此，当你为类声明一个魔术方法时，应以此前缀命名方法。你可以在*[https://www.php.net/manual/en/language.oop5.magic.php](https://www.php.net/manual/en/language.oop5.magic.php)*中找到所有PHP魔术方法的列表。
- en: Initializing Values with a Constructor Method
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用构造方法初始化值
- en: It’s common to want to set some (or all) of an object’s properties as soon as
    that object has been created. As shown in [Listing 18-5](#lis18-5), you can do
    this by first creating an object and then having a sequence of statements invoking
    setter methods to set values for each property. However, initializing object properties
    immediately after creating an object is such a common requirement that PHP enables
    you to combine these actions into a single step by writing a magic method called
    a *constructor* as part of the class declaration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望在创建对象后立即设置该对象的一些（或所有）属性。如[清单 18-5](#lis18-5)所示，你可以通过首先创建对象，然后依次调用setter方法来设置每个属性的值。然而，立即在创建对象后初始化对象属性是一个非常常见的需求，因此PHP允许你通过编写一个名为*构造函数*的魔术方法，将这些操作合并为一步，并将其作为类声明的一部分。
- en: 'Every class-declaration file either declares no constructor method (as you’ve
    seen so far in this chapter) or declares a single constructor magic method named
    __construct(). It’s magic in the sense that it overrides the default way of creating
    an object: creating it without setting any of its properties. The __construct()
    method takes in a series of parameters and assigns them as initial values of the
    newly created object’s properties. Using a constructor method in an *index.php*
    file is as simple as providing the initial values as arguments in the parentheses
    after the class name: $myObject = new ClassName($value1, $value2), for example.
    Thanks to the use of the new keyword, PHP automatically links the arguments with
    the constructor, even though __construct() isn’t called explicitly.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类声明文件要么不声明构造方法（如本章前面所述），要么声明一个名为__construct()的单一构造魔术方法。它被称为“魔术”是因为它重写了创建对象的默认方式：在不设置任何属性的情况下创建对象。__construct()方法接收一系列参数，并将它们作为新创建的对象属性的初始值。例如，在*index.php*文件中使用构造方法，只需在类名后的小括号内提供初始值作为参数：$myObject
    = new ClassName($value1, $value2)。得益于new关键字的使用，PHP会自动将参数与构造方法关联，即使__construct()没有显式调用。
- en: NOTE
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*PHP is quite unusual as an object-oriented language in that the constructor
    method doesn’t have the same name as the class. In most other object-oriented
    languages, a* Product() *method in the* Product *class would be a constructor
    method, but in PHP, there’s nothing special about a method that has the same name
    as the class in which it’s declared.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Setting properties as part of the constructor method can save some code when
    it comes to creating new objects. For example, if we know we’ll want to set the
    name and price properties upon creation of a Product object, we can add a constructor
    method to the Product class that takes in $name and $price arguments to set these
    properties automatically. That way, when we create our $product1 object in *index.php*,
    we can replace these three statements
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'with just a single statement:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Update *Product.php* as shown in [Listing 18-8](#lis18-8) to add a constructor
    method that sets the name and price properties.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 18-8: Adding a constructor method to the Product class'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a new __construct() method. It replaces the default no-parameter
    creation of an object via new Product() with a method requiring two parameters:
    the initial string name and float price values for the new Product object. Note
    that constructor methods don’t specify any return type. Within the __construct()
    method definition, we call the setName() and setPrice() methods, which we’ve already
    defined elsewhere in the Product class declaration, feeding them the $name and
    $price parameters. This may not seem easier than calling those methods in the
    *index.php* script, but as you start creating more instances of the same object,
    setting properties through the constructor quickly becomes much more efficient.
    This approach also ensures that exactly the same validation is applied when values
    are set at the time of object construction as when values are changed at a later
    time with a direct call to a setter method.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Many IDEs (such as PhpStorm) offer an interactive constructor method generator
    that enables you to add selected properties as parameters and have their values
    set by the generated constructor method code.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Listing 18-9 shows how to simplify *index.php* to take advantage of the new
    constructor method.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 18-9: The simpler index.php script, using the constructor method'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create the $product1 object, we pass the desired initial values for
    the name and price properties as arguments for the constructor. As noted previously,
    this collapses three lines of code (creating the object and setting each of its
    two properties) into a single line.  #### Converting Objects to Strings'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: It’s common to want to summarize the contents of an object as a string, sometimes
    to display details about the object, or sometimes for debugging and logging purposes.
    One common reason to convert objects to strings is to generate a list of objects
    for a web interface, such as a drop-down menu. [Figure 18-3](#fig18-3) shows an
    example drop-down menu with a list of some of the courses I teach.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure18-3.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-3: A list of courses summarized as strings'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine that each of these courses is represented in PHP by a Course
    object, which has properties like courseNumber and courseName. To generate the
    drop-down menu, PHP converts each Course object to a string in the form courseNumber
    - courseName, such as COMP H2029 - Web Development Server-Side. These strings
    can then be fed into the HTML code for displaying the menu.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'How does that conversion to a string happen? Most object-oriented languages,
    including PHP, offer a way to implement a special method to return a string when
    an object is used in an expression that requires a string (for example, something
    like print $course1, where $course1 is a reference to a Course object). In PHP,
    this functionality comes from another magic method prefixed with two underscore
    characters: __toString().'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: You don’t *have* to implement a __toString() method for every class, but if
    you know you’ll need a string summary of an object (such as for a drop-down HTML
    menu), or if you want to log details about objects to a report, then __toString()
    methods are useful. If a class has no __toString() method and you try to reference
    an object of that class in an expression requiring a string, you’ll get a could
    not be converted to string fatal error. Let’s see this happen by replacing the
    print statements at the end of our *index.php* script with print $product1. Update
    *index.php* to match [Listing 18-10](#lis18-10).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 18-10: Trying to output details of an object via print in index.php'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: We pass the expression $product1 to a print statement. Because print statements
    expect a string expression and $product1 isn’t a string, PHP will try to convert
    it to one. Since the PHP engine can’t convert an object reference to a string
    without a __toString() method, a fatal error occurs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now implement a __toString() method for our Product class, both to explore
    this common feature of OOP and to allow us to use the simplified *index.php* script
    in [Listing 18-10](#lis18-10). [Listing 18-11](#lis18-11) shows the new __toString()
    method added to the *src/Product.php* file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 18-11: Adding a __toString() method to the Product class'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: We add a new __toString() method to the class. It contains a single statement
    that builds and returns a string summarizing the object property values. Note
    that we generalized the string message to start with '(Product) ' rather than
    'product 1 ' ❶. Since this is a method of a class and therefore will potentially
    be used by many objects, we shouldn’t hardcode the name of the variable referring
    to a particular object into the general class declaration file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the *index.php* script as it was updated in [Listing 18-10](#lis18-10),
    and you should see that the print $product1 statement works correctly, thanks
    to the new __toString() method.  ### Object Variables as References'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, the $product1 variable used throughout this chapter is a reference
    to a Product object in memory, not a Product object itself. One implication of
    this distinction is that more than one variable can reference the same object
    in memory. This can occur in lots of ways. For example, it would happen when you
    need to loop through a collection of objects and perform actions on each. In this
    case, a temporary local variable would reference the current object being worked
    on, but the collection would also still have a separate reference to that object.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: To see how object variables are just references to locations in memory, update
    *index.php* as shown in [Listing 18-12](#lis18-12). In this code, we create $variable2,
    make it a reference to the same object as $product1, and change one of the object’s
    properties through $variable2. As you’ll see, this change impacts the object referenced
    by $product1 as well, proving both variables are referencing the same object.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 18-12: Updating index.php to illustrate how object variables are references'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'We make $variable2 a reference to the same object as $product1 ❶. Then we call
    setPrice() to the object that $variable2 refers to, changing the value of the
    object’s price property to 20.00. We then print $product1 a second time. Since
    $product1 is a reference to an object, its __toString() method will be invoked.
    This produces the following output in the browser:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The object referenced by $product1 has had its price changed to 20, even though
    we made the price change through $variable2. Therefore, the two variables must
    be referencing the same object.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Handling Missing Objects
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes code is written in such a way that you expect a variable to refer
    to an object, but no such object is found. That variable would be NULL, so it’s
    often important to include checks for NULL when you’re writing object-oriented
    code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider an example. Imagine you’re writing code for a blog. To display
    a particular blog post, the code expects a valid ID of a blog post from an HTTP
    request, then uses that ID to retrieve data from a database and construct a Blog
    object. If no ID is found in the request, if the ID is invalid, or if the ID doesn’t
    match any item in the database, then the application can’t create a Blog object,
    and so the code would return NULL instead of an object reference.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: To account for this situation, other code expecting to work with a Blog object
    would first test for NULL and then decide whether to deal with an invalid ID (say
    0 or negative) or with a successfully retrieved Blog object. [Listing 18-13](#lis18-13)
    shows an example method that might come from a database-driven blog website to
    illustrate this point.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 18-13: Using a nullable return type'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: This blogFromId() method takes in a value for an $id and returns either a reference
    to a Blog object or NULL, using the nullable return type ?Blog. (We could also
    have written this as union return type Blog|NULL.) The method tests whether $id
    is numeric and greater than 0 ❶. If so, it passes the valid $id to the find()
    method of the blogRepository property and returns the value from this method (either
    NULL or the Blog object found for this ID in the database). If the $id isn’t valid,
    NULL is returned.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'This example is making lots of assumptions, but the point is that the variable
    set to the result of calling the blogFromId() method will either have a reference
    to an object or be NULL. Code like this is quite common in OOP (as you’ll see
    in [Part VI](part6.xhtml)), which is why you often test for a NULL value of a
    variable you expect to be a reference to an object, to identify whether any object
    is being referred to. This compares to working with non-object-oriented PHP variables,
    where NULL can mean, for example, that a variable hasn’t been initialized or that
    no string value was received for a URL-encoded variable in an HTTP form submission.  ###
    Custom Methods and Virtual Attributes'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: You can write all sorts of custom methods for a class, beyond the standard getters
    and setters and the __construct() and __toString() magic methods. Remember, methods
    are simply functions attached to a class of objects, so *custom methods* are functions
    to implement logic and calculations relating to objects of the class. For example,
    our Product class might come with a method for calculating the total price of
    a product, including tax. The tax rate will be a float value, such as 0.5 (for
    50 percent). Such a method would still be functioning as a getter, but instead
    of simply returning a stored property value, it would be dynamically calculating
    a value each time it’s invoked.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: To see how it works, we’ll add a getPriceIncludingTax() method to our Product
    class declaration. The method will retrieve the tax rate and the pretax price
    of a product from the appropriate object properties, perform the necessary calculation,
    and return the total price with tax. For a tax rate of 0.1 (10 percent) and a
    price of 5.00, for instance, the method should return 1.1 * 5.00 = 5.50. To create
    the method, we also need to add a private taxRate property to the class, along
    with accessor methods for setting and getting the tax rate for a product.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Listing 18-14 shows an updated *Product.php* class-declaration file. In addition
    to adding the taxRate property, its accessors, and the custom method, we also
    modify the __toString() method to display the results of the tax calculation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 18-14: Adding the taxRate property and associated methods to the Product
    class'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: We declare the taxRate property ❶ along with its simple getter and setter methods
    ❷. Then we declare the getPriceIncludingTax() method ❸. It returns the price with
    the tax rate factored in.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, our getPriceIncludingTax() custom method is simply a function
    that performs a useful calculation for our class. In this case, it’s essentially
    an extra getter method that provides a variation on one of the class’s stored
    properties, price. In fact, it’s quite common in OOP to see what amounts to multiple
    getter methods for the same property of an object: methods that return pre- and
    post-tax prices of a product, methods that return the same property with different
    levels of precision (rounded to the nearest whole number versus including up to
    two decimal places), methods that retrieve the same property converted to different
    currencies or units (dollars versus euros, feet versus meters), and so on.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'In other cases, custom methods can act as *virtual attributes*: rather than
    provide a variation on an existing property, such methods perform calculations
    to arrive at a completely new piece of information. An example of a virtual attribute
    might be a method to calculate the age of a product. If products had a dateReceived
    property, the age of a product could be dynamically calculated as part of a getProductAge()
    method. The method would subtract dateReceived from the current date. In this
    case, the product’s age isn’t actually stored as a property of the object, but
    thanks to the getProductAge() method, the information is available as if it were
    a property.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Custom methods highlight some of the power of OOP: the person writing code
    that uses a public getProductAge() method of a Product object doesn’t need to
    worry about how that method is implemented. All that counts is that the method
    works. If the implementation of the method is changed (perhaps changing the data
    type of the dateReceived property from stored MySQL datetime values to Linux timestamps)
    but its behavior remains correct and unchanged, it makes no difference to the
    parts of the system that are sending messages to Product objects and using the
    values returned by those methods.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter covered how to declare classes, how to read those declarations
    into an *index.php* file and use them to create objects, and how to invoke methods
    of objects to set and retrieve their property values. You saw how to protect an
    object’s data properties by declaring them as private, and how to use getter and
    setter methods declared as public to manage access to the object’s properties
    and perform validation where relevant. We also discussed how to perform common
    useful actions with PHP “magic” methods, such as creating new objects with some
    properties initialized via a constructor method and generating a string message
    representing an object’s properties by declaring a __toString() method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Write a PHP class declaration for a Cat class, with public properties
    of name, breed, and age. Then write an *index.php* file to read in the class declaration
    and create a Cat object. Store a reference to the new object in a variable named
    $cat1 and set its properties as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: name = 'Mr. Fluffy'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: breed = 'long-haired mix'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: age = 2
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Finally, add statements to print the data values for each property of $cat1.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Write a PHP class declaration for a Pet class, with a private name property
    and public get and set accessor methods for this name variable. Then write an
    *index.php* file to read in the class declaration and create a Pet object referenced
    by a variable named $pet1. Use the setter to set its name to 'Fifi', and add a
    statement to print the name stored in this object.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Add a constructor method to your Pet class so you can create new Pet objects
    with an initial value of the name variable by using a statement like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Update your *index.php* file to use this constructor method rather than setting
    the name with the setter method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '4.   For the following properties and types, write their corresponding accessor
    (getter/setter) method names:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: age // integer
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: houseNumber // integer
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: color // string
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: length // float
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: heavy // bool
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
