- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 18 DECLARING CLASSES AND CREATING OBJECTS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll learn how to define the structure of a class by using
    a class-declaration file, and you’ll practice creating individual objects of that
    class. You’ll see that classes with public properties let you directly change
    an object’s data, while classes with private properties mean you can change an
    object’s data only via its methods, some of which can perform validation. You’ll
    also learn about PHP “magic” methods that make it easier to write object-oriented
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *class declaration* defines a class: it lays out the properties (variables)
    each object of that class will have, as well as the methods (functions) that can
    act upon those properties. A class declaration also establishes any relationship
    that class has with other classes (such as inheritance, which you’ll learn about
    in [Chapter 19](chapter19.xhtml)).'
  prefs: []
  type: TYPE_NORMAL
- en: Like function declarations, class declarations are stored in PHP files in the
    *src* directory of a project. For all the projects in this book, each class will
    be declared in its own file; if a project has five classes, it will have five
    class-declaration files, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In this book, we won’t explore the advanced topic of* anonymous classes*,
    which is one of the few cases where more than one class may be declared in a single
    file. You can learn more at* [https://www.php.net/manual/en/language.oop5.anonymous.php](https://www.php.net/manual/en/language.oop5.anonymous.php)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: By a well-established convention in OOP, both class names and class-declaration
    filenames always start with a capital letter. If the name includes multiple words,
    each word should start with a capital letter, with no spaces between the words.
    This is known as *upper camel case*, or sometimes *Pascal case*. Examples of valid
    class names include Product, NetworkSupplier, DesktopComputer, ReferenceBook,
    and InventoryItem.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ll work with a class called Product that can represent
    various items for sale through an e-commerce site. Let’s declare it now. Create
    a new directory for a new project, and in it create a *src* directory. In this
    *src* directory, create a *Product.php* file and enter the contents of [Listing
    18-1](#lis18-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 18-1: The Product.php file to declare the Product class'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the standard PHP beginning code tag, since we use PHP code to
    declare classes. Then we use the class keyword to state that we’re declaring a
    new class named Product. After the class name, enclosed in curly brackets, we
    define any properties or methods that will be associated with objects of that
    class. In this example, we declare two properties for each object of the Product
    class: name, which will be a string, and price, which will be a float. We declare
    both properties as public, meaning any part of our program with access to a Product
    object can read and change the values of its properties. We’ll explore the implications
    of public properties later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: If we want all objects to have a *default value* for a property, we can assign
    a property a value in the class declaration. For example, if our system set an
    initial –1 price for every new Product object, we could have written public float
    $price = -1.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-1](#fig18-1) shows a *Unified Modeling Language (UML)* class diagram
    visualizing the class we’ve just written. UML is a common tool for representing
    classes, objects, and their interactions through diagrams and text.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure18-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-1: The Product class'
  prefs: []
  type: TYPE_NORMAL
- en: The top row of the diagram indicates the class name (Product), and the second
    row lists the properties associated with that class, along with the data type
    expected for each property. The plus sign before each property name indicates
    that the properties have public visibility.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You use the PHP keyword new to create an object of a class. The new keyword
    is followed by the name of the class for which an object is to be created, then
    a set of parentheses. Inside the parentheses, you may pass arguments for initialization,
    as we’ll discuss in “Initializing Values with a Constructor Method” on [page 346](#pg_346).
    The general form of a statement to create an object is thus new ClassName(). Creating
    an object is also called *instantiation*, since the object is an *instance* of
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: By writing the new keyword and a class name, you’re asking PHP to create a new
    object of the named class. When an object is created in the computer’s memory
    with the new keyword, the PHP engine automatically returns a reference to the
    new object. In most cases, you’ll want to store the reference to that newly created
    object in a variable—for example, $myObject = new ClassName(). It’s important
    to understand that with such statements, the variable $myObject doesn’t actually
    contain the object itself, but rather a *reference to* the object. It’s possible
    for several variables, or none, to refer to a particular object in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a reference to an object, use the *object operator* (->) to access
    properties and methods of that object. For example, you could write $myObject->description
    to access the description property of the object referred to by $myObject. Likewise,
    you could invoke a setDescription() method of an object by writing something like
    $myObject->setDescription('small carpet'). The parentheses or lack thereof are
    important, since they tell the PHP engine (and people reading the code) whether
    a statement is attempting to access a property (no parentheses present) or a method
    (parentheses present).
  prefs: []
  type: TYPE_NORMAL
- en: 'With all this in mind, let’s create an object. We’ll write an *index.php* script
    to read in the *Product.php* class-declaration file, create a Product object,
    and set the values of its properties. [Figure 18-2](#fig18-2) shows our goal:
    a $product1 variable that stores a reference to a Product object whose properties
    have the values ''hammer'' and 9.99.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure18-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-2: The $product1 variable references an object of the Product class.'
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, we’ll start by creating a Product object and setting only its
    name property. To make sure our code is working, we’ll also print the value of
    the object’s name property to the project’s home page. In your project directory,
    create a *public* folder, and in that folder create an *index.php* file containing
    the code in [Listing 18-2](#lis18-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 18-2: An index.php script to create and manipulate a Product object'
  prefs: []
  type: TYPE_NORMAL
- en: We read in the declaration for the Product class, using the __DIR__ magic constant
    to create a path from the location of this *index.php* file (in *public*) to the
    location of the *Product.php* file (in *src*). Then we use the new keyword to
    create a new object of the Product class. Since this class doesn’t require any
    initial values or options when creating objects, we don’t pass any arguments in
    the parentheses after the class name.
  prefs: []
  type: TYPE_NORMAL
- en: If you aren’t passing any arguments when you create a new object, PHP (unlike
    most object-oriented languages) allows you to omit the parentheses after the class
    name. Writing new Product() is the same as writing new Product. However, there
    are several good reasons to always include the parentheses, and so this is the
    style you’ll see throughout this book. Perhaps the most important reason to always
    use parentheses after the keyword new is to remind ourselves that a constructor
    method may be executed as the new object is created; we’ll look at such methods
    in “Initializing Values with a Constructor Method” on [page 346](#pg_346).
  prefs: []
  type: TYPE_NORMAL
- en: The new Product() expression creates the new object and returns a reference
    to it, which we store in the $product1 variable. To reiterate, $product1 doesn’t
    contain the object itself, nor does it contain a copy of the object. It contains
    just a *reference to* the object created in the computer system’s memory. In “Object
    Variables as References” on [page 351](#pg_351), we’ll have two variables refer
    to the same object to help illustrate this concept.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the value of the object’s name property to the string 'hammer';
    we can do this because the property was declared as public. We use the object
    operator (->) after the $product1 variable to refer to the name property of that
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '> WARNING'
  prefs: []
  type: TYPE_NORMAL
- en: '*Do* not *write a dollar sign after the* -> *characters:* $product->name *is
    correct, and* $product->$name *is wrong. The PHP engine won’t create a warning
    or error if you write the latter, but it will interpret the code as meaning there’s
    a variable called* $name *whose value is the name of a property you want to access
    on the* $product *object. This is very different from accessing the value of the*
    $product *object’s* name *property. If your code is behaving strangely, check
    for this possible programming mistake.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the script ends by printing a message featuring the value retrieved
    from the $product object’s name property. If you run the web server and visit
    the project’s home page, you should see this line of text displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The -> operator lets you manipulate any of an object’s public properties by
    name. Let’s update our script to set and display the price of the object as well
    as its name. Modify the *index.php* file as shown in [Listing 18-3](#lis18-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 18-3: Setting and displaying the product price in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: We set the object’s price property to 9.99 following the same format we used
    in [Listing 18-2](#lis18-2) to set the name property. Then we display the value
    of the property. Notice that this time we use a double-quoted string to combine
    the message and property value. This illustrates that in double-quoted strings,
    a reference to a public property of an object, such as $product1->price, will
    be parsed and the resulting value will be output, just as with a simple variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visiting the home page again, you should see both the product name and price
    displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now created an object of the Product class, and since the class’s properties
    are public, we were able to set and retrieve the properties’ values directly.
    In practice, however, most classes are written with private rather than public
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Private Properties with Public Accessor Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When properties are declared as private, they can’t be accessed by code outside
    the class declaration itself. Instead, they’re available through public *accessor
    methods*, functions that allow object property values to be retrieved (*getter
    methods*) or updated (*setter methods*). This mechanism of private properties
    with public accessor methods reduces the risk of invalid property values; when
    changes to a property must take place through a setter method, you can implement
    validation logic as part of the method (for example, preventing negative values
    or out-of-range values). Also, related properties or other objects might need
    to be updated together, such as the balance of one bank account being reduced
    by the same value that another account is increased. With setter methods and private
    properties, you can easily enforce such rules so that the data in the application
    stays correct and internally consistent.
  prefs: []
  type: TYPE_NORMAL
- en: The default visibility for class members is public, so if no access modifier
    is provided for a property, the PHP engine will automatically declare it as having
    public visibility. Even with this default behavior, it’s still good practice to
    explicitly use the public access modifier in the class declaration when you want
    a class member to have public visibility. Otherwise, use the private access modifier
    to make the member private.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In addition to* public *and* private*, a third access modifier,* protected*,
    can be used in conjunction with inheritance. We’ll explore this topic in [Chapter
    19](chapter19.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: For PHP and almost all OOP languages, a getter or setter method’s name usually
    starts with the word *get* or *set*, followed by the property name the method
    affects, with its first letter capitalized. According to this convention, the
    getter method for the name property of our Product class should be getName(),
    and its setter method should be setName(). For the price property, the methods
    should be getPrice() and setPrice(). An exception to this convention is made when
    a property contains a Boolean true/false value. In this case, naming the getter
    method isPropertyName rather than getPropertyName is customary. For example, if
    the Product class had a dangerousItem property that contained true or false, its
    getter would be named isDangerousItem().
  prefs: []
  type: TYPE_NORMAL
- en: A getter method usually returns a value of the same data type as the property
    it’s paired with (although sometimes we have multiple getter methods for different
    representations of an object’s property, such as methods to return both rounded-up
    integer and float values of a float property). A setter method usually takes in
    a parameter of the same type and stores its value in the property, perhaps conducting
    validation checks in the process. Usually, setter methods don’t return any value
    and so are declared to return void.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s revise the declaration for the Product class, making its name and price
    properties private and adding four public accessor methods, two for each property.
    Update the *src/Product.php* file as shown in [Listing 18-4](#lis18-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 18-4: Modifying the Product class to use getter and setter methods'
  prefs: []
  type: TYPE_NORMAL
- en: First, we change the declaration of the two properties to private. Then we declare
    getName(), the public getter method for the name property ❶. Methods in classes
    can use the special pseudo-variable $this to reference the calling object; that
    is, $this is a stand-in for the object whose properties and methods we’re working
    with. Our getName() method thus returns the value in the name property of whichever
    Product object the method is currently being called on. The method has a string
    return type, since the name property is a string.
  prefs: []
  type: TYPE_NORMAL
- en: We next declare setName(), the public setter method for the name property ❷.
    This method takes in a new string name value through the $name parameter and stores
    this value in the name property for the current object, again using $this to reference
    the object. This setter method returns void. The getter and setter methods for
    price follow the same pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Notice in the body of setName() how PHP distinguishes between the $name parameter
    and the name property for the current object ❸. The former is prefixed by a dollar
    sign, while the latter is attached to $this-> and doesn’t have a dollar sign to
    indicate it’s a property of the current object. In other words, $name in the setName()
    method unambiguously refers to the value of the argument passed to the method,
    while the private name property of the object that has been sent the setName()
    message is unambiguously referred to by $this->name. The same goes for the float
    $price parameter of the setPrice() method versus the price property of the object
    the method is being called on.
  prefs: []
  type: TYPE_NORMAL
- en: When you write methods in a class-declaration file, you must always keep in
    mind that the same methods may be executed on zero, one, or thousands of objects,
    in response to objects receiving a message with the name of the method (and any
    required arguments). Although you may plan to create and use only one instance
    (object) of a class when you first write the declaration, a well-written class
    encapsulates the data (properties) and behavior (methods) for *any* object of
    that class. When you keep the general use in mind while programming, you can often
    use a class in other parts of the same project, or different projects altogether,
    with few or no changes required to the class declaration. Well-written class declarations
    lend themselves to reuse.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*While you can type out accessor methods yourself, many code editors, including
    PhpStorm, offer an automated feature to generate simple getter and setter methods
    for you. Autogenerating code is faster than typing it out by hand, and it ensures
    error-free scripts that follow PHP programming conventions.*'
  prefs: []
  type: TYPE_NORMAL
- en: Getting and Setting Private Properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since the two properties of any Product object are now declared private, we
    can’t access them directly, such as by writing $product1->name or $product1->price.
    If you run the existing *index.php* script, you’ll get a fatal error about not
    being able to access the private name property. Instead, we have to read and modify
    these private properties by using their public accessor methods. [Listing 18-5](#lis18-5)
    shows how to update *index.php* to make use of these new methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 18-5: Using accessor methods in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: As in [Listing 18-3](#lis18-3), we create the $product1 object, set its properties,
    and print out those properties. This time, however, we rely entirely on accessor
    methods. We use setter methods to update the values of the object properties,
    such as $product1->setName('hammer'). Likewise, we use getter methods to retrieve
    values from the object, such as $product1->getName(). Thanks to these methods,
    the data in the $product1 object is safely encapsulated but still accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Screening for Invalid Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the advantages of protecting the data properties of objects is that you
    can add validation logic to the setter methods to prevent invalid values from
    being stored in the properties. For example, most businesses probably wouldn’t
    want to set a negative price for a product (although something might be a free
    gift, so we’ll allow for a price of 0). We should therefore add an if statement
    to the setPrice() method that updates the stored price only if the new value is
    greater than or equal to 0\. [Listing 18-6](#lis18-6) shows how to update the
    method in *src/Product.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 18-6: Adding validation logic to the setPrice() method of the Product
    class'
  prefs: []
  type: TYPE_NORMAL
- en: In our validation logic, we confirm that the new $price argument is greater
    than or equal to 0 before setting the value of the object’s price property. To
    make sure the validation check works, we can update our *index.php* script to
    attempt to set an invalid, negative price value. We should see that the invalid
    values aren’t stored in the object. [Listing 18-7](#lis18-7) adds extra statements
    to *index.php* for two tests of the validation logic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 18-7: Testing the setter validation logic in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, we create a new Product object and set its price to 9.99. Then we
    try to set the price to an invalid negative value, and then a valid positive value
    that’s different from its initial value, printing the product price each time.
    Here’s the output of this script in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For test 1 (a negative price of -0.5), the stored price remains unchanged at
    9.99. For test 2 (a nonnegative value of 22), the stored price is updated. Our
    validation logic has worked. In this example, we simply ignored the invalid value,
    but it’s generally better to somehow indicate that there was a problem. One option
    is for setters to return a Boolean false value when no value was set. Another
    option is to throw an Exception object, as we’ll explore in [Chapter 23](chapter23.xhtml).  ###
    Overriding Default Class Behavior with Magic Methods'
  prefs: []
  type: TYPE_NORMAL
- en: PHP offers several *magic methods* that override default behavior of an object.
    For example, the __construct() magic method overrides the default way objects
    of a class are created, and the __toString() magic method overrides the way objects
    are handled in print statements and other contexts requiring a string. We’ll explore
    each of these magic methods in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Despite their name, magic methods are unrelated to PHP magic constants. Magic
    methods are a feature of object-oriented PHP, allowing the default behavior of
    an object to be changed. All magic methods have names beginning with double underscore
    characters (__); therefore, you should name methods with such a prefix only when
    declaring a magic method for a class. You can find a list of all the PHP magic
    methods at *[https://www.php.net/manual/en/language.oop5.magic.php](https://www.php.net/manual/en/language.oop5.magic.php)*.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Values with a Constructor Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s common to want to set some (or all) of an object’s properties as soon as
    that object has been created. As shown in [Listing 18-5](#lis18-5), you can do
    this by first creating an object and then having a sequence of statements invoking
    setter methods to set values for each property. However, initializing object properties
    immediately after creating an object is such a common requirement that PHP enables
    you to combine these actions into a single step by writing a magic method called
    a *constructor* as part of the class declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every class-declaration file either declares no constructor method (as you’ve
    seen so far in this chapter) or declares a single constructor magic method named
    __construct(). It’s magic in the sense that it overrides the default way of creating
    an object: creating it without setting any of its properties. The __construct()
    method takes in a series of parameters and assigns them as initial values of the
    newly created object’s properties. Using a constructor method in an *index.php*
    file is as simple as providing the initial values as arguments in the parentheses
    after the class name: $myObject = new ClassName($value1, $value2), for example.
    Thanks to the use of the new keyword, PHP automatically links the arguments with
    the constructor, even though __construct() isn’t called explicitly.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*PHP is quite unusual as an object-oriented language in that the constructor
    method doesn’t have the same name as the class. In most other object-oriented
    languages, a* Product() *method in the* Product *class would be a constructor
    method, but in PHP, there’s nothing special about a method that has the same name
    as the class in which it’s declared.*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting properties as part of the constructor method can save some code when
    it comes to creating new objects. For example, if we know we’ll want to set the
    name and price properties upon creation of a Product object, we can add a constructor
    method to the Product class that takes in $name and $price arguments to set these
    properties automatically. That way, when we create our $product1 object in *index.php*,
    we can replace these three statements
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'with just a single statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Update *Product.php* as shown in [Listing 18-8](#lis18-8) to add a constructor
    method that sets the name and price properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 18-8: Adding a constructor method to the Product class'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a new __construct() method. It replaces the default no-parameter
    creation of an object via new Product() with a method requiring two parameters:
    the initial string name and float price values for the new Product object. Note
    that constructor methods don’t specify any return type. Within the __construct()
    method definition, we call the setName() and setPrice() methods, which we’ve already
    defined elsewhere in the Product class declaration, feeding them the $name and
    $price parameters. This may not seem easier than calling those methods in the
    *index.php* script, but as you start creating more instances of the same object,
    setting properties through the constructor quickly becomes much more efficient.
    This approach also ensures that exactly the same validation is applied when values
    are set at the time of object construction as when values are changed at a later
    time with a direct call to a setter method.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Many IDEs (such as PhpStorm) offer an interactive constructor method generator
    that enables you to add selected properties as parameters and have their values
    set by the generated constructor method code.*'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 18-9 shows how to simplify *index.php* to take advantage of the new
    constructor method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 18-9: The simpler index.php script, using the constructor method'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create the $product1 object, we pass the desired initial values for
    the name and price properties as arguments for the constructor. As noted previously,
    this collapses three lines of code (creating the object and setting each of its
    two properties) into a single line.  #### Converting Objects to Strings'
  prefs: []
  type: TYPE_NORMAL
- en: It’s common to want to summarize the contents of an object as a string, sometimes
    to display details about the object, or sometimes for debugging and logging purposes.
    One common reason to convert objects to strings is to generate a list of objects
    for a web interface, such as a drop-down menu. [Figure 18-3](#fig18-3) shows an
    example drop-down menu with a list of some of the courses I teach.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure18-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-3: A list of courses summarized as strings'
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine that each of these courses is represented in PHP by a Course
    object, which has properties like courseNumber and courseName. To generate the
    drop-down menu, PHP converts each Course object to a string in the form courseNumber
    - courseName, such as COMP H2029 - Web Development Server-Side. These strings
    can then be fed into the HTML code for displaying the menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does that conversion to a string happen? Most object-oriented languages,
    including PHP, offer a way to implement a special method to return a string when
    an object is used in an expression that requires a string (for example, something
    like print $course1, where $course1 is a reference to a Course object). In PHP,
    this functionality comes from another magic method prefixed with two underscore
    characters: __toString().'
  prefs: []
  type: TYPE_NORMAL
- en: You don’t *have* to implement a __toString() method for every class, but if
    you know you’ll need a string summary of an object (such as for a drop-down HTML
    menu), or if you want to log details about objects to a report, then __toString()
    methods are useful. If a class has no __toString() method and you try to reference
    an object of that class in an expression requiring a string, you’ll get a could
    not be converted to string fatal error. Let’s see this happen by replacing the
    print statements at the end of our *index.php* script with print $product1. Update
    *index.php* to match [Listing 18-10](#lis18-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 18-10: Trying to output details of an object via print in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: We pass the expression $product1 to a print statement. Because print statements
    expect a string expression and $product1 isn’t a string, PHP will try to convert
    it to one. Since the PHP engine can’t convert an object reference to a string
    without a __toString() method, a fatal error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now implement a __toString() method for our Product class, both to explore
    this common feature of OOP and to allow us to use the simplified *index.php* script
    in [Listing 18-10](#lis18-10). [Listing 18-11](#lis18-11) shows the new __toString()
    method added to the *src/Product.php* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 18-11: Adding a __toString() method to the Product class'
  prefs: []
  type: TYPE_NORMAL
- en: We add a new __toString() method to the class. It contains a single statement
    that builds and returns a string summarizing the object property values. Note
    that we generalized the string message to start with '(Product) ' rather than
    'product 1 ' ❶. Since this is a method of a class and therefore will potentially
    be used by many objects, we shouldn’t hardcode the name of the variable referring
    to a particular object into the general class declaration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the *index.php* script as it was updated in [Listing 18-10](#lis18-10),
    and you should see that the print $product1 statement works correctly, thanks
    to the new __toString() method.  ### Object Variables as References'
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, the $product1 variable used throughout this chapter is a reference
    to a Product object in memory, not a Product object itself. One implication of
    this distinction is that more than one variable can reference the same object
    in memory. This can occur in lots of ways. For example, it would happen when you
    need to loop through a collection of objects and perform actions on each. In this
    case, a temporary local variable would reference the current object being worked
    on, but the collection would also still have a separate reference to that object.
  prefs: []
  type: TYPE_NORMAL
- en: To see how object variables are just references to locations in memory, update
    *index.php* as shown in [Listing 18-12](#lis18-12). In this code, we create $variable2,
    make it a reference to the same object as $product1, and change one of the object’s
    properties through $variable2. As you’ll see, this change impacts the object referenced
    by $product1 as well, proving both variables are referencing the same object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 18-12: Updating index.php to illustrate how object variables are references'
  prefs: []
  type: TYPE_NORMAL
- en: 'We make $variable2 a reference to the same object as $product1 ❶. Then we call
    setPrice() to the object that $variable2 refers to, changing the value of the
    object’s price property to 20.00. We then print $product1 a second time. Since
    $product1 is a reference to an object, its __toString() method will be invoked.
    This produces the following output in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The object referenced by $product1 has had its price changed to 20, even though
    we made the price change through $variable2. Therefore, the two variables must
    be referencing the same object.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Missing Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes code is written in such a way that you expect a variable to refer
    to an object, but no such object is found. That variable would be NULL, so it’s
    often important to include checks for NULL when you’re writing object-oriented
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider an example. Imagine you’re writing code for a blog. To display
    a particular blog post, the code expects a valid ID of a blog post from an HTTP
    request, then uses that ID to retrieve data from a database and construct a Blog
    object. If no ID is found in the request, if the ID is invalid, or if the ID doesn’t
    match any item in the database, then the application can’t create a Blog object,
    and so the code would return NULL instead of an object reference.
  prefs: []
  type: TYPE_NORMAL
- en: To account for this situation, other code expecting to work with a Blog object
    would first test for NULL and then decide whether to deal with an invalid ID (say
    0 or negative) or with a successfully retrieved Blog object. [Listing 18-13](#lis18-13)
    shows an example method that might come from a database-driven blog website to
    illustrate this point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 18-13: Using a nullable return type'
  prefs: []
  type: TYPE_NORMAL
- en: This blogFromId() method takes in a value for an $id and returns either a reference
    to a Blog object or NULL, using the nullable return type ?Blog. (We could also
    have written this as union return type Blog|NULL.) The method tests whether $id
    is numeric and greater than 0 ❶. If so, it passes the valid $id to the find()
    method of the blogRepository property and returns the value from this method (either
    NULL or the Blog object found for this ID in the database). If the $id isn’t valid,
    NULL is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example is making lots of assumptions, but the point is that the variable
    set to the result of calling the blogFromId() method will either have a reference
    to an object or be NULL. Code like this is quite common in OOP (as you’ll see
    in [Part VI](part6.xhtml)), which is why you often test for a NULL value of a
    variable you expect to be a reference to an object, to identify whether any object
    is being referred to. This compares to working with non-object-oriented PHP variables,
    where NULL can mean, for example, that a variable hasn’t been initialized or that
    no string value was received for a URL-encoded variable in an HTTP form submission.  ###
    Custom Methods and Virtual Attributes'
  prefs: []
  type: TYPE_NORMAL
- en: You can write all sorts of custom methods for a class, beyond the standard getters
    and setters and the __construct() and __toString() magic methods. Remember, methods
    are simply functions attached to a class of objects, so *custom methods* are functions
    to implement logic and calculations relating to objects of the class. For example,
    our Product class might come with a method for calculating the total price of
    a product, including tax. The tax rate will be a float value, such as 0.5 (for
    50 percent). Such a method would still be functioning as a getter, but instead
    of simply returning a stored property value, it would be dynamically calculating
    a value each time it’s invoked.
  prefs: []
  type: TYPE_NORMAL
- en: To see how it works, we’ll add a getPriceIncludingTax() method to our Product
    class declaration. The method will retrieve the tax rate and the pretax price
    of a product from the appropriate object properties, perform the necessary calculation,
    and return the total price with tax. For a tax rate of 0.1 (10 percent) and a
    price of 5.00, for instance, the method should return 1.1 * 5.00 = 5.50. To create
    the method, we also need to add a private taxRate property to the class, along
    with accessor methods for setting and getting the tax rate for a product.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 18-14 shows an updated *Product.php* class-declaration file. In addition
    to adding the taxRate property, its accessors, and the custom method, we also
    modify the __toString() method to display the results of the tax calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 18-14: Adding the taxRate property and associated methods to the Product
    class'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the taxRate property ❶ along with its simple getter and setter methods
    ❷. Then we declare the getPriceIncludingTax() method ❸. It returns the price with
    the tax rate factored in.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, our getPriceIncludingTax() custom method is simply a function
    that performs a useful calculation for our class. In this case, it’s essentially
    an extra getter method that provides a variation on one of the class’s stored
    properties, price. In fact, it’s quite common in OOP to see what amounts to multiple
    getter methods for the same property of an object: methods that return pre- and
    post-tax prices of a product, methods that return the same property with different
    levels of precision (rounded to the nearest whole number versus including up to
    two decimal places), methods that retrieve the same property converted to different
    currencies or units (dollars versus euros, feet versus meters), and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In other cases, custom methods can act as *virtual attributes*: rather than
    provide a variation on an existing property, such methods perform calculations
    to arrive at a completely new piece of information. An example of a virtual attribute
    might be a method to calculate the age of a product. If products had a dateReceived
    property, the age of a product could be dynamically calculated as part of a getProductAge()
    method. The method would subtract dateReceived from the current date. In this
    case, the product’s age isn’t actually stored as a property of the object, but
    thanks to the getProductAge() method, the information is available as if it were
    a property.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Custom methods highlight some of the power of OOP: the person writing code
    that uses a public getProductAge() method of a Product object doesn’t need to
    worry about how that method is implemented. All that counts is that the method
    works. If the implementation of the method is changed (perhaps changing the data
    type of the dateReceived property from stored MySQL datetime values to Linux timestamps)
    but its behavior remains correct and unchanged, it makes no difference to the
    parts of the system that are sending messages to Product objects and using the
    values returned by those methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter covered how to declare classes, how to read those declarations
    into an *index.php* file and use them to create objects, and how to invoke methods
    of objects to set and retrieve their property values. You saw how to protect an
    object’s data properties by declaring them as private, and how to use getter and
    setter methods declared as public to manage access to the object’s properties
    and perform validation where relevant. We also discussed how to perform common
    useful actions with PHP “magic” methods, such as creating new objects with some
    properties initialized via a constructor method and generating a string message
    representing an object’s properties by declaring a __toString() method.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '1.   Write a PHP class declaration for a Cat class, with public properties
    of name, breed, and age. Then write an *index.php* file to read in the class declaration
    and create a Cat object. Store a reference to the new object in a variable named
    $cat1 and set its properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: name = 'Mr. Fluffy'
  prefs: []
  type: TYPE_NORMAL
- en: breed = 'long-haired mix'
  prefs: []
  type: TYPE_NORMAL
- en: age = 2
  prefs: []
  type: TYPE_NORMAL
- en: Finally, add statements to print the data values for each property of $cat1.
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Write a PHP class declaration for a Pet class, with a private name property
    and public get and set accessor methods for this name variable. Then write an
    *index.php* file to read in the class declaration and create a Pet object referenced
    by a variable named $pet1. Use the setter to set its name to 'Fifi', and add a
    statement to print the name stored in this object.
  prefs: []
  type: TYPE_NORMAL
- en: '3.   Add a constructor method to your Pet class so you can create new Pet objects
    with an initial value of the name variable by using a statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Update your *index.php* file to use this constructor method rather than setting
    the name with the setter method.
  prefs: []
  type: TYPE_NORMAL
- en: '4.   For the following properties and types, write their corresponding accessor
    (getter/setter) method names:'
  prefs: []
  type: TYPE_NORMAL
- en: age // integer
  prefs: []
  type: TYPE_NORMAL
- en: houseNumber // integer
  prefs: []
  type: TYPE_NORMAL
- en: color // string
  prefs: []
  type: TYPE_NORMAL
- en: length // float
  prefs: []
  type: TYPE_NORMAL
- en: heavy // bool
  prefs: []
  type: TYPE_NORMAL
