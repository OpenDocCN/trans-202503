- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EXPLORING
    MACHINE LEARNING</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter explains how you can use Dash to visually explore and present the
    internals of machine learning models and classification algorithms. For instance,
    say you create a machine learning model for self-driving cars that classifies
    objects into humans, plants, and other cars, and you need to be able to explain
    to other programmers and non-technical management how and why your model works.
    Dashboard apps can help you do this in a quick, convincing, and visually appealing
    way.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, this chapter starts with a conceptual introduction to the *support
    vector machine (SVM)*, the popular machine learning classification algorithm.
    SVMs provide a way to categorize data by telling us how to accurately split the
    data so that it is placed in the correct category. We’ll visualize the functioning
    of SVMs in a dashboard app using various kinds of plots and graphs.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll then use the powerful NumPy library for numerical computations and the
    easy-to-use machine learning algorithms from scikit-learn. Most importantly, you’ll
    experience the great benefit of being able to use the gallery as a basis for diving
    deeper into more advanced dashboard applications written by the pros.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also introduces *wrapper functions*, a new Dash concept for creating
    custom, reusable components to give you more options than just the predefined
    Dash and HTML components. You’ll also learn about some new Dash standard components
    such as contour plots and graphs, and we’ll cover the Dash *load spinner*, which
    gives the user visual feedback when a specific dashboard component is loading.
    Load spinners are useful for more complicated dashboard applications that build
    slowly, often due to heavy computational load.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*The purpose of this chapter is to provide you with an overview of what is
    possible with Dash and to help you develop further skills. We don’t go too far
    into the weeds on any one topic. Our intention is to be informative rather than
    comprehensive, so if anything is particularly interesting to you, we recommend
    you check out the supplementary material on the Charming Data YouTube channel
    and on the companion website to this book:* [https://learnplotlydash.com](https://learnplotlydash.com).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Dashboard Apps to Make Machine Learning
    Models</samp> <samp class="SANS_Futura_Std_Bold_B_11">More Intuitive</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As machine learning becomes more prevalent in computer science and in our everyday
    lives, it’s increasingly important to understand how computers reach the conclusions
    they reach. Machines can beat human grandmasters in chess and Go, reduce accident
    rates in many traffic scenarios, and produce more goods than human workers in
    a factory environment. When it comes to measurable performance, machines can often
    prove their superiority, convincing even the fiercest critics that their power
    can free up human labor.
  prefs: []
  type: TYPE_NORMAL
- en: However, it can be dangerous to observe the effectiveness of machines only through
    their performance metrics. We can’t know how machines will perform in extreme
    situations that couldn’t have been learned from datasets; data-driven approaches
    will always be biased toward past experiences. If a machine has not observed a
    stock market crash of 95 percent in 100 years of stock market history, it will
    unlikely consider this scenario in its models, but this scenario will likely occur
    someday in the future.
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate this danger, organizations must better understand where the “intelligence”
    of machines comes from. What are their assumptions? On what basis do they reach
    their conclusions? How does their behavior change when presented with extreme
    inputs? A machine learning model from the 1960s would undoubtedly consider negative
    interest rates as “extreme” or even “impossible.” Today we know better.
  prefs: []
  type: TYPE_NORMAL
- en: This leads us to the motivation of machine learning dashboards. A dashboard
    is a powerful tool for visualizing what is going on *inside* a machine. You can
    train a model and observe how it performs when given changing inputs. You can
    test extreme cases. You can see the internals and assess potential risks by overfitting
    the learning to past data.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing machine learning models allows you to *show* your models to your
    clients, enabling them to play with the input parameters and reach a level of
    trust in the models that would never have been possible in command line models.
    Dashboards help make the intelligence of your machines tangible.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Classification: A
    Short Guide</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to have an in-depth understanding of classification or SVMs to
    follow the app in this chapter. We’ll go into some detail to facilitate understanding
    for those who are interested, but if you want to skip this section and the SVM
    section after it, feel free to do so and treat the SVM algorithm as a black box
    as you read through the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Still here? Okay, let’s dive into the very basics of the classification problem
    in machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, the classification problem attempts to assign a category (that is,
    a class) to input data based on the learnings from a set of provided labeled (classified)
    training data. For example, if we want to predict what major students will likely
    study at college based on training data, we might measure aptitude for creative
    and logical thinking for each student in a school. The goal is to create a classification
    algorithm that predicts a label—the students’ predicted majors—from the features:
    aptitude for creative versus logical thinking.'
  prefs: []
  type: TYPE_NORMAL
- en: SVMs, such as the one visualized in this dashboard app, are *classification*
    algorithms. Classification algorithms take a set of data and assign to each data
    point a label corresponding to a particular category, based on model learnings
    from training data. More specifically, a classification algorithm will search
    for a *decision boundary* that divides the data into two or more classes. A linear
    SVM models the decision boundary in an *n*-dimensional space as an *(n – 1)*-dimensional
    plane that divides the data points into two classes. All data points on one side
    of the decision boundary belong to one class and all data points on the other
    side belong to another class. Thus, assuming you can represent all data points
    in an *n*-dimensional space and you have an *(n – 1)*-dimensional decision boundary,
    you can use the decision boundary to classify new data, because any new data point
    falls on exactly one side of the boundary. Roughly speaking, the goal of classification,
    then, is to identify the decision boundary that separates the training and test
    data well.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-1](chapter7.xhtml#fig7-1) gives an example inspired by but slightly
    modified from *Python One-Liners* by Christian Mayer (No Starch Press, 2020).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: Example classification
    problem: different decision boundaries would lead to different classifications
    of the new data point (either “computer science” or “art”)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This classification scenario creates a classification model that helps aspiring
    university students find a field of study that may fit their strengths. We have
    training data from previous students from two fields: computer science and art.
    Fortunately, the students already provided us with an estimation of their own
    logical and creative thinking skills. When mapped into a two-dimensional space
    that models logical and creative thinking as separate axes, the data seems to
    be clustered so that the computer science students tend to be strong in logical
    thinking whereas the artists tend to be strong in creative thinking. We use the
    data to find a decision boundary that maximizes the classification accuracy for
    the training data. Technically, the obtained classification model will only give
    aspiring students a hint about what they are likely to pick based on their strengths.
    It doesn’t necessarily help them decide what they should be picking (for example,
    to maximize their happiness). That is a much harder problem.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the decision boundary to classify new users for whom we only have
    data on their logic and creativity. The figure shows two linear classifiers (depicted
    with lines) that perfectly separate the data when used as decision boundaries.
    They have 100 percent accuracy when classifying the test data, so both lines seem
    to be equally good. For a machine learning algorithm to perform well, it must
    choose the decision boundary wisely. But how do we find the best one?
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Support Vector Machines</samp>
  prefs: []
  type: TYPE_NORMAL
- en: SVMs attempt to maximize the distance between the closest data points from both
    classes and the decision boundary; this distance between the closest points and
    the decision boundary line is known as the *margin of safety*, *safety margin*,
    or just *margin*. These closest data points are called *support vectors*. By maximizing
    the margin of safety, SVMs aim to minimize the error when classifying new points
    that are close to the decision boundary.
  prefs: []
  type: TYPE_NORMAL
- en: As a visual example, take a look at [Figure 7-2](chapter7.xhtml#fig7-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: Example SVM classification
    with decision boundary and support vectors</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The SVM classifier finds the support vectors for each class and places the line
    at the greatest distance from each (halfway between) so that the zone between
    the different support vectors is as thick as possible. This line is the decision
    boundary. In [Figure 7-2](chapter7.xhtml#fig7-2) a new data point is added that
    needs classifying; however, because the point to be classified falls in the margin
    zone, the model cannot confidently decide whether it belongs to the art class
    or the computer science class. This nicely demonstrates that SVMs come with a
    built-in mechanism to explicitly tell us whether the model performs a borderline
    classification. For example, the SVM may tell us that a student ranking high on
    creativity belongs to the art class and a student ranking high in logical thinking
    belongs to the computer science class, but a student ranking high in creativity
    *and* logic cannot be confidently assigned to either class.
  prefs: []
  type: TYPE_NORMAL
- en: Note that SVM models can also be trained in a way that allows for *outliers*
    in the training data; these are points that fall on one side of the decision boundary
    but belong to the other side. This is the most common case for real-world data.
    However, instead of exploring these SVM optimizations further, we suggest you
    check out the excellent SVM classification tutorials listed at the end of this
    chapter so that we can dive into the exciting dashboard app right away.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The SVM Explorer App</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 7-3](chapter7.xhtml#fig7-3) shows how we can visualize SVMs using the
    SVM Explorer app, a Python dashboard app from the gallery that uses various kinds
    of plots and graphs. Feel free to play with the live project at [*https://<wbr>dash<wbr>-gallery<wbr>.plotly<wbr>.host<wbr>/dash<wbr>-svm*](https://dash-gallery.plotly.host/dash-svm).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: The SVM Explorer
    app from the gallery</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll give you an overview of the SVM Explorer app first so that you can gain
    a rough understanding. The app showcases how a given SVM model classifies a given
    training dataset. You control the model using the dashboard controls, such as
    sliders, dropdowns, and radio buttons. Based on your selections, the output graphs
    and plots change to reflect the changing instantiation of the SVM model.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the authors of this app, Xing Han, has kindly provided us with a quick
    overview of the SVM Explorer app:'
  prefs: []
  type: TYPE_NORMAL
- en: This app is fully written in Dash and scikit-learn. All the components are used
    as input parameters for scikit-learn functions, which then generate a model with
    respect to the parameters the user changes. The model then performs predictions
    that are displayed on a contour plot, and its predictions are evaluated to create
    the ROC [receiver operating characteristic] curve and confusion matrix. In addition
    to creating models, it uses scikit-learn to generate the datasets you see, as
    well as the data needed for the metrics plots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly examine each visible component. There are multiple input components
    in the left column of the dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Select Dataset* dropdown menu allows you to choose the synthetic dataset
    to use for training and testing. The default selection is Moon, named for its
    moon-shaped dataset. This input dropdown allows you to explore how the SVM model
    works on data with different inherent properties. For example, you can select
    the Circles dataset (not shown in the figure), which is nonlinear, so that the
    two datasets to be classified are shaped like an inner circle and an outer ring
    around that circle. The SVM model can classify those types of data too!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sample Size* slider allows you to control the number of data points used
    to test and train the model. A higher sample size usually leads to a more accurate
    model, which is why machine learning companies never stop collecting more data!
    In our toy dashboard, however, a higher sample size may result in a more crowded
    visualization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Noise Level* slider allows you to control the standard deviation of Gaussian
    noise added to the data. A higher noise level yields a less accurate model because
    noise reduces the clarity of patterns in the data and makes it harder to find
    a separating decision boundary during the training phase. You can, however, use
    the Noise Level slider to check how robust the SVM model will be in practice,
    because real-world data tends to be noisy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Threshold* slider allows you to add a bias toward one class or the other.
    Roughly speaking, by increasing the threshold value you shift the decision boundary
    from class A more toward class B (or vice versa by decreasing the threshold) so
    that for a given input, the likelihood of being classified as A increases. For
    example, if the threshold is 0.4, any score greater than 0.4 is considered a positive
    prediction and any score less than 0.4 is considered a negative prediction on
    whether the point belongs to a certain class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Reset Threshold* button resets the threshold to a default value without
    a customized threshold or bias.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Kernel* dropdown menu, the *Costs* sliders, and other controls such as
    the *Gamma* slider and the *Shrinking* radio buttons allow you to further control
    other SVM parameters and their effect on classification accuracy. Discussing these
    parameters would need more than just one or two sentences in this quick overview,
    so we’ll skip it. If you’re interested in learning the theory behind these controls,
    feel free to consult Chapter 15 of *Introduction to Information Retrieval* (Cambridge
    University Press, 2008). You can read the chapter for free at [*https://<wbr>nlp<wbr>.stanford<wbr>.edu<wbr>/IR<wbr>-book<wbr>/pdf<wbr>/15svm<wbr>.pdf*](https://nlp.stanford.edu/IR-book/pdf/15svm.pdf).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Three output components change as the model changes:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Dash Graph component* is a contour plot that visualizes the training and
    testing data, as well as the model classification confidence levels, in a heat
    map overlay. The dots represent the training data and the triangles represent
    the test data. Red data points belong to one class and blue to another. First
    we train the SVM model based on a subset of the sample data. Then we classify
    the test data using the trained model and plot the predicted class in the visualization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *ROC curve plot* is a measure of quality of the SVM model on the given dataset.
    It measures the *true positive rate*, which is the proportion of data points that
    are correctly classified, against the *false positive rate,* which is the proportion
    of data points that are incorrectly classified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *confusion matrix* refers to the predicted versus actual classes. Specifically,
    it’s a bar chart that shows the number of true positive, true negative, false
    positive, and false negative classifications of the test data. You can think of
    this as yet another measure of how well the SVM model performs the training and
    classification task on the given dataset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve provided links to more detailed explanations of the Dash <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>,
    the ROC curve plot, and the confusion matrix at the end of this chapter. However,
    a great way to get a better understanding is to play around with the SVM Explorer
    app. We recommend spending 10 to 20 minutes playing with the app to fully grasp
    the idea of each component.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for the app in the GitHub repository at [*https://<wbr>github<wbr>.com<wbr>/DashBookProject<wbr>/Plotly<wbr>-Dash<wbr>/tree<wbr>/master<wbr>/Chapter<wbr>-7*](https://github.com/DashBookProject/Plotly-Dash/tree/master/Chapter-7).
    The complete code has more than 650 lines, but don’t worry, we will focus only
    on the most important aspects. Note that well-maintained code seldom stays the
    same forever. Since this chapter’s writing, the authors have already updated the
    original code base by adding new styles to the app, among other things. But because
    the core of the app didn’t change, we have provided the original code on the specified
    GitHub repository so you can download it and reproduce the exact app explained
    in this chapter. We highly recommend that you download the code to accelerate
    your learning.
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, let’s dive into the code!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Python Libraries</samp>
  prefs: []
  type: TYPE_NORMAL
- en: We’ll stand on the shoulders of giants and rely on several Python libraries
    to create our SVM dashboard app. [Listing 7-1](chapter7.xhtml#List7-1) shows the
    libraries used in this project.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">import time</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">import importlib</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">from dash import Dash, dcc, html,
    Input, Output, State</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">import numpy as np</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">from dash.dependencies import
    Input, Output, State</samp>
  prefs: []
  type: TYPE_NORMAL
- en: ❶ <samp class="SANS_TheSansMonoCd_W5Regular_11">from sklearn.model_selection
    import train_test_split</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">from sklearn.preprocessing import
    StandardScaler</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">from sklearn import datasets</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">from sklearn.svm import SVC</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: Dependencies for
    the SVM app</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve already seen the Dash library statements that import the core and HTML
    components, as well as the overall Dash app functionality. The core code in this
    chapter consists of the computations for the SVM. We won’t implement our own SVM
    from scratch, but we will rely on the excellent implementations provided by the
    scikit-learn library. We therefore import some modules from this library, which
    we’ll look at in more detail as they come up ❶. If you’re interested in machine
    learning, scikit-learn is your best friend!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Data Management</samp>
  prefs: []
  type: TYPE_NORMAL
- en: scikit-learn provides some great synthetic datasets for testing all kinds of
    classification and prediction algorithms. In [Listing 7-2](chapter7.xhtml#List7-2)
    we show how the function <samp class="SANS_TheSansMonoCd_W5Regular_11">generate_data()</samp>
    dynamically creates the dataset using the number of sample points, the type of
    the dataset, and the noise level, all specified in the left column of the SVM
    Explorer app shown in [Figure 7-3](chapter7.xhtml#fig7-3). We’ll use the functions
    <samp class="SANS_TheSansMonoCd_W5Regular_11">datasets.make_moons()</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">datasets.make_circles()</samp>, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">datasets.make_classification()</samp>
    to generate different datasets (<samp class="SANS_TheSansMonoCd_W5Regular_11">"moons"</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"circles"</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">"linear"</samp>,
    respectively) according to the value obtained through the input dropdown menu.
    This dataset is used later to train and test our SVM.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def generate_data(n_samples, dataset,
    noise):</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   if dataset == "moons":</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      return datasets.make_moons(n_samples=n_samples,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                                 noise=noise,
    random_state=0)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   elif dataset == "circles":</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      return datasets.make_circles(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         n_samples=n_samples,
    noise=noise, factor=0.5, random_state=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">    )</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   elif dataset == "linear":</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      X, y = datasets.make_classification(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         n_samples=n_samples,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         n_features=2,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         n_redundant=0,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         n_informative=2,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         random_state=2,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         n_clusters_per_class=1,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      )</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      rng = np.random.RandomState(2)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      X +=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">noise
    * rng.uniform(size=X.shape)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      linearly_separable = (X,
    y)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      return linearly_separable</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   else:</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      raise ValueError(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        "Data type incorrectly
    specified. Choose an existing dataset."</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      )</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: Data management
    for the SVM app</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, the code consists of <samp class="SANS_TheSansMonoCd_W5Regular_11">if…elif…elif…else</samp>
    statements that differentiate user inputs. This allows the user to choose among
    three datasets: <samp class="SANS_TheSansMonoCd_W5Regular_11">"moons"</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"circles"</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">"linear"</samp>.
    In each case, a new dataset is created with scikit-learn’s <samp class="SANS_TheSansMonoCd_W5Regular_11">dataset.make_X()</samp>
    function, which takes different input arguments (such as the number of sample
    points) and returns the data as a NumPy array. Interested readers can learn more
    about the input arguments we used here at [*https://<wbr>scikit<wbr>-learn<wbr>.org<wbr>/stable<wbr>/modules<wbr>/classes<wbr>.xhtml#module<wbr>-sklearn<wbr>.datasets*](https://scikit-learn.org/stable/modules/classes.xhtml#module-sklearn.datasets).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Layout and Styling</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The layout and styling sections give you an idea of the structure of the SVM
    Explorer app and the basic Dash components from which it is built. Let’s start
    with the overall layout of the project.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Layout</samp>
  prefs: []
  type: TYPE_NORMAL
- en: As you start working on larger apps, the number of lines of code in the *app.py*
    file quickly becomes harder to manage. To help manage the code, the SVM Explorer
    app includes a *utils* folder with two helper modules, *dash_resuable_components.py*
    and *figures.py*, which contain the definitions of some customized Dash components
    that we’ll explore in more detail later in this chapter, as well as some plotting
    and styling functionality. This approach of pulling out utility functionality
    from the *app.py* file into some imported external modules is good practice for
    your own larger dashboard projects, to make sure the main *app.py* remains clean
    and focused.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of the SVM Explorer app looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- app.py</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- utils/</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   |--dash_reusable_components.py</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   |--figures.py</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The layout of the app is a hierarchically nested structure of HTML elements,
    as shown in [Listing 7-3](chapter7.xhtml#List7-3).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">app.layout = html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   children=[html.Div(…), # Heading
    etc.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">      html.Div(…)] # Body</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: Zooming one level
    in the SVM app layout</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first child of the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    contains the app’s heading, logo, and other meta-information. The second child
    contains the body of the app, which is the central part of the app. [Listing 7-4](chapter7.xhtml#List7-4)
    shows the full code for the layout section of our SVM Explorer app. Just skim
    over it and try to understand how the app is structured; we’ll discuss the relevant
    parts afterward.
  prefs: []
  type: TYPE_NORMAL
- en: ❶ <samp class="SANS_TheSansMonoCd_W5Regular_11">app.layout = html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   children=[</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">     # .container class is fixed,
    .container.scalable is scalable</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   </samp>❷ <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        className="banner",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        children=[</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">     </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">      html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">              className="container
    scalable",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">              children=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">[</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                 # Change App
    Name here</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                 html.H2(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                    id="banner-title",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                    children=[</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                       html.A(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                          "Support
    Vector Machine (SVM) Explorer",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                          href=("</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">https://github.com/"</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                            "plotly/dash-svm"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">            </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">              style={</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">                            "text-decoration":
    "none",</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">                            "color":
    "inherit",</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">            </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">              },</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                      )</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                    ],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                 ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                 html.A(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                    id="banner-logo",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                    children=[</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">               html.Img(src=app.get_asset_url(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                      </samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">    "dash-logo-new.png"))</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                    ],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">            </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">        href="</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">https://plot.ly/products/dash/",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                 ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">             ],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">          )</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        ],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">     ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   </samp>❸ <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        id="body",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        className="container scalable",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        children=[</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">           html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">              id="app-container",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">              # className="row",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">              children=[</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                  html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                    # className=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">"three columns",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                    id="left-column",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                    children=[</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># … See Dash Components</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                    ],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                  </samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                  html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                    id="div-graphs",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                    children=dcc.Graph(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                      id="graph-sklearn-svm",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">  </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">                    figure=dict(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                  </samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">       layout=dict(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                            plot_bgcolor=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">"#282b38",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                            paper_bgcolor="#282b38"</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                      </samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">    )</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                      ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">          </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">          ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                  ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">      ],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">            )</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        ],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">    ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">  ]</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-4: Zooming multiple
    levels in the SVM app layout</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code references stylesheets and Dash components that we’ll talk about in
    upcoming sections, so it may not be clear how this section works just yet. But
    it does show you what a nontrivial Dash app looks like: hierarchically nested
    HTML components using dash-html-components. In large apps you’ll use this structure
    to add more components as you modify the app’s look and feel.'
  prefs: []
  type: TYPE_NORMAL
- en: As with the smaller apps we’ve seen in earlier chapters, the app consists of
    an outer <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> ❶ that contains
    two inner <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> elements at
    ❷ and ❸. The first inner <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    contains meta-information, such as the headline and logo. The second inner <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> contains the body of the app.
  prefs: []
  type: TYPE_NORMAL
- en: In “Reusable Components” later in this chapter, we’ll focus on the different
    Dash components to learn how they are working individually.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at the CSS stylesheets we used to style the SVM Explorer app.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Styling</samp>
  prefs: []
  type: TYPE_NORMAL
- en: We know from [Chapters 4](chapter4.xhtml) and [5](chapter5.xhtml) that we can
    style our HTML elements using either a CSS stylesheet or dash-bootstrap-components.
    In this app we opt for the CSS stylesheet, since it allows us to create a more
    customized look and feel with margins, padding, colors, fonts, and borders. Note
    that the main styling is already built into the default Plotly Dash components,
    so using custom stylesheets is a relatively minor design decision by the creators
    of the SVM Explorer app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the stylesheet in the *assets* subfolder, with a structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- app.py</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- assets/</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   |--base-styles.css</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   |--custom-styles.css</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">--snip--</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use two stylesheets: the *base-styles.css* and *custom-styles.css* files
    that were added to the SVM Explorer app by the app creators. The *base-styles.css*
    stylesheet defines how basic HTML elements such as headings and paragraphs should
    be styled. The *custom-styles.css* stylesheet defines how Dash-specific elements
    such as named sliders, graph containers, and cards should be styled. Let’s quickly
    dip into *base-styles.css* to see how we can manipulate the default styling.'
  prefs: []
  type: TYPE_NORMAL
- en: The *base-styles.css* stylesheet consists of the 13 sections shown in [Listing
    7-5](chapter7.xhtml#List7-5), each defining how certain types of HTML elements
    look.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">/* Table of contents</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">—————————————————————————</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- Grid</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- Base Styles</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- Typography</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- Links</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- Buttons</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- Forms</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- Lists</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- Code</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- Tables</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- Spacing</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- Utilities</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- Clearing</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- Media Queries</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">*/</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-5: Overview of</samp>
    <samp class="SANS_Futura_Std_Book_11">base-styles.css</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This stylesheet allows you to define things like the fonts, background colors,
    margins, and padding for these basic elements. For example, in the typography
    section, shown in [Listing 7-6](chapter7.xhtml#List7-6), we define the font size,
    weight, and spacing for the different headings.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">/* Typography</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">—————————————————————————*/</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">h1, h2, h3, h4, h5, h6 {</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   margin-top: 0;</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   margin-bottom: 0;</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   font-weight: 300;}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">h1 {font-size: 4.5rem; line-height:
    1.2; letter-spacing: -.1rem; margin-bottom: 2rem;}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">h2 {font-size: 3.6rem; line-height:
    1.25; letter-spacing: -.1rem; margin-bottom: 1.8rem; margin-top: 1.8rem;}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">h3 {font-size: 3.0rem; line-height:
    1.3; letter-spacing: -.1rem; margin-bottom: 1.5rem; margin-top: 1.5rem;}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">h4 {font-size: 2.6rem; line-height:
    1.35; letter-spacing: -.08rem; margin-bottom: 1.2rem; margin-top: 1.2rem;}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">h5 {font-size: 2.2rem; line-height:
    1.5; letter-spacing: -.05rem; margin-bottom: 0.6rem; margin-top: 0.6rem;}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">h6 {font-size: 2.0rem; line-height:
    1.6; letter-spacing: 0; margin-bottom: 0.75rem; margin-top: 0.75rem;}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">p {</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   margin-top: 0;}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-6: Zooming into the
    typography section of</samp> <samp class="SANS_Futura_Std_Book_11">base-styles.css</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that we set the font size for the top-level heading <samp class="SANS_TheSansMonoCd_W5Regular_11">h1</samp>
    at <samp class="SANS_TheSansMonoCd_W5Regular_11">4.5rem</samp> so that it’s the
    largest.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t go into the specifics of each element in this chapter, though we do
    recommend that you take a quick look at the code to see how we apply custom styles
    to various elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of losing ourselves in minor CSS details (which you could decide to
    ignore in your own dashboard app and default to the Dash standard styling), let’s
    have a look at the heart of the SVM app: the Dash components.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reusable Components</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here we’ll look at a new Dash concept in the form of *reusable components*,
    which allow you to add your own style and functionality to existing components.
    We use several components in our SVM Explorer app that are similar in pattern
    to the built-in components but with slight differences, such as dropdown menus
    with different labels and value ranges. We define the components in the *dash_reusable_components.py*
    file and instantiate the components with their custom features in *app.py*. First
    we’ll add the *dash_reusable_components.py* module to the *utils* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- app.py</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- assets/</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">- utils/</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   |--dash_reusable_components.py</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">--snip--</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Say our goal is to create a custom button we’ll use several times throughout
    the code. The custom button component could be arbitrarily complex; it might just
    contain a button label or it might have something more complex, like a chart showing
    how often the button was clicked over time (yes, Dash can do that!). We want to
    avoid creating the customized button repeatedly in our *app.py* file for clarity
    and conciseness. To accomplish this, we create this customized button as an instance
    of the custom class <samp class="SANS_TheSansMonoCd_W5Regular_11">CustomButton</samp>.
    We define the class in the *dash_reusable_components.py* module once and then
    can instantiate the customized button component as many times as we like in the
    main *app.py* file, each potentially with its own individual features, such as
    different background colors or text.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Defining a Card</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](chapter6.xhtml) we used a Bootstrap <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp>
    to create a small contained area for content. Here we’ll create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp>
    with multiple components: a label, a slider, and a button. You can think of a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp> as a meta component
    consisting of multiple child components, using a specific (relative) width and
    padding and adding a solid gray border at the bottom to group the components visually.
    A <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp> is actually a wrapper
    around the HTML component <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Section</samp>,
    a container that groups different HTML elements or text inside a (possibly) styled
    area. All content in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp>
    belongs together semantically or thematically. [Figure 7-4](chapter7.xhtml#fig7-4)
    gives an example of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp>
    in our SVM Explorer app that uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Section</samp>
    element to group three components: a label, a slider, and a button.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: Example of a custom
    Card</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_11">WHAT IS A WRAPPER?</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Book_11">A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">wrapper</samp>
    <samp class="SANS_Futura_Std_Book_11">is a function whose only purpose is to call
    another function. By doing so, the wrapper shields the caller from unnecessary
    complexity or redundancy. For example, the inner function call may be complicated,
    with many specific arguments the caller doesn’t know about. The wrapper function
    call simplifies access to the inner function by requiring fewer arguments and
    hardcoding the remaining arguments. This improves readability, reduces complexity,
    and improves maintainability of the code.</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-7](chapter7.xhtml#List7-7) shows the actual definition of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Card</samp> wrapper function from *dash_reusable_components.py*.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def Card(children, **kwargs):</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return html.Section(className=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">"card", children=children, **_omit(["style"],
    kwargs))</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-7: Defining the Card
    component</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how the <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp> component
    works in full, let’s dive deeper into these arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W7Bold_B_11">children   </samp>A list of other
    Dash elements that are included in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp>**,**
    and so are displayed grouped together in the dashboard app. You can create all
    kinds of nested and hierarchical HTML trees and pass any iterable of HTML elements
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp>**.** The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Card</samp> will then wrap these elements
    into one common element that resembles a physical card: a 2D box with consistent
    styling that encloses some other design elements.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">**kwargs   </samp>Stands for *arbitrary
    keyword arguments*. The <samp class="SANS_TheSansMonoCd_W5Regular_11">**kwargs</samp>
    argument packs all keyword arguments passed into the function call into a single
    <samp class="SANS_TheSansMonoCd_W5Regular_11">kwargs</samp> dictionary. The keyword
    argument names are the dictionary keys, and the keyword arguments’ values are
    the dictionary values. For example, if somebody called the function <samp class="SANS_TheSansMonoCd_W5Regular_11">Card(children,
    example</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"123")</samp>,
    we could use <samp class="SANS_TheSansMonoCd_W5Regular_11">kwargs['example']</samp>
    within the function to obtain the value <samp class="SANS_TheSansMonoCd_W5Regular_11">"123"</samp>.
    We could use this dictionary later to unpack a potentially large number of arguments
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Section()</samp> constructor,
    including metadata such as the language of the section or the number of times
    this component has been clicked by the user. We don’t really use the opportunity
    to pass arbitrary keyword arguments in our SVM Explorer app, but this is an interesting
    aspect of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp> component.
    You can find a detailed tutorial on the double-asterisk operator at [*https://blog.finxter.com/python-double-asterisk*](https://blog.finxter.com/python-double-asterisk).
  prefs: []
  type: TYPE_NORMAL
- en: 'The other argument is actually a function. Let’s have a closer look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W7Bold_B_11">_omit</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">   </samp>Allows
    us to exclude certain elements if they’re not needed. We might, for example, remove
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">"style"</samp> key from the
    dictionary because it is not needed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Section()</samp>
    constructor, since we already defined the style using the CSS stylesheet. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_omit()</samp> function takes two
    arguments: a list of strings in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">omitted
    _keys</samp> and a dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp>.
    The function returns a new dictionary that consists of the elements in the original
    dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> with all keys
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">omitted_keys</samp> and their
    associated values filtered out. Here is how the authors of the SVM Explorer app
    concisely accomplished this:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def _omit(omitted_keys, d):</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11"> return {k: v for k, v in d.items()
    if k not in omitted_keys}</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In the SVM Explorer app, you call <samp class="SANS_TheSansMonoCd_W5Regular_11">**_omit(["style"],
    kwargs)</samp> to pass the keyword arguments dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">kwargs</samp>
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Card()</samp> call after
    removing the key <samp class="SANS_TheSansMonoCd_W5Regular_11">"style"</samp>
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">_omit()</samp> function.
    The double-asterisk prefix unpacks all those values from the dictionary into the
    argument list of the <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Section()</samp>
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: In *app.py*, we can now use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Card</samp>
    reusable component to create a card containing a named slider and a button, as
    shown in [Listing 7-8](chapter7.xhtml#List7-8).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">.drc.Card(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   id="button-card",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   children=[</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      drc.NamedSlider(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         name="Threshold",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         id="slider-threshold",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         min=0,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         max=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">1,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         value=0.5,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         step=0.01,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      html.Button(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         "Reset Threshold",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         id="button-zero-threshold",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   ],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-8: Combining the
    named slider and button components within the Card definition</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">drc.NamedSlider</samp>
    is a reusable component itself, so we wrap a reusable component <samp class="SANS_TheSansMonoCd_W5Regular_11">drc.Card</samp>
    around another reusable component hierarchically.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-4](chapter7.xhtml#fig7-4) shows how the <samp class="SANS_TheSansMonoCd_W5Regular_11">drc.Card</samp>
    looks in the SVM Explorer app. The named slider consists of two components: an
    HTML component to display the text <samp class="SANS_TheSansMonoCd_W5Regular_11">"Threshold"</samp>
    and a Dash <samp class="SANS_TheSansMonoCd_W5Regular_11">Slider</samp> component
    to set the float value between 0 and 1.'
  prefs: []
  type: TYPE_NORMAL
- en: The threshold is later used as an input value for our SVM model as a means to
    control the bias of the classification model toward one class or the other. While
    this is a specific parameter in a specific classification model, you can use this
    exact strategy to display the performance impact of various model parameters in
    machine learning. Exploring the impact of a critical parameter becomes as simple
    as using a slider on your smartphone! Won’t this make a lasting impression when
    you present your next machine learning model to the public?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you know how to create reusable components using a wrapper function around
    another component. Don’t worry if you didn’t get all the details; we only want
    you to grasp the big picture: how to create reusable components by means of wrapper
    functions. Let’s dive into the next custom-defined component used in our app:
    the formatted slider.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Defining a Formatted
    Slider</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The formatted slider is another custom wrapper that consists of an HTML <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> element and a <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Slider</samp>,
    a Dash Core component introduced in [Chapter 6](chapter6.xhtml). A formatted slider
    is a <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Slider</samp> component
    with some predefined formatting applied, usually pertaining to padding. For simpler
    usage, we’d instead use simple CSS to associate formatting with a slider component,
    but the authors of this app probably considered adding some more advanced components
    or functionality later, so they made this a reusable component that is easily
    extendable.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-9](chapter7.xhtml#List7-9) shows the code of the wrapper function
    we place in *dash_reusable_components.py*.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def FormattedSlider(**kwargs):</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      style=kwargs.get("style",
    {}),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      children=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Slider(**_omit(["style"],
    kwargs))</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   )</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-9: Defining the FormattedSlider
    component</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *app.py* we create a particular instance of a formatted slider, presented
    in [Figure 7-5](chapter7.xhtml#fig7-5), with this slider creation code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">drc.FormattedSlider(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   id="slider-svm-parameter-C-coef",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   min=1,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   max=9,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   value=1,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: This creates a formatted slider with a minimum value of 1, a maximum value of
    9, and a slider granularity of 1 between two consecutive values. We pass four
    keyword arguments into the <samp class="SANS_TheSansMonoCd_W5Regular_11">FormattedSlider()</samp>
    function, which are then packed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">kwargs</samp>
    dictionary. There’s no <samp class="SANS_TheSansMonoCd_W5Regular_11">style</samp>
    key in the dictionary, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">kwargs.get("style",
    {})</samp> call from [Listing 7-9](chapter7.xhtml#List7-9) returns the empty dictionary.
    In this case, the default styling from Dash is used. We pass the remaining key-value
    pairs in the dictionary as keyword arguments into the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Slider()</samp>
    creation routine. These arguments build a new slider with the specified range;
    note that Dash automatically adds the labels 1, 3, 5, 7, and 9 as values of the
    specific formatted slider shown in the SVM Explorer app (see [Figure 7-5](chapter7.xhtml#fig7-5)).
    If you try out the slider yourself, you’ll realize that the slider granularity
    is 1 even though the marks show only every other value. Of course, you can customize
    the marks if needed by adding another <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp>
    argument that maps slider values to text labels in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: Example of a formatted
    slider</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Defining a Named Slider</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The named slider is another wrapper around the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Slider</samp>
    component that adds a custom heading. [Figure 7-6](chapter7.xhtml#fig7-6) shows
    a slider in our SVM Explorer app that we named Degree.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-6: Example of a named
    slider</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The code that defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">NamedSlider</samp>
    in *dash_reusable_components.py* is shown in [Listing 7-10](chapter7.xhtml#List7-10).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def NamedSlider(name, **kwargs):</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">      style={"padding": "20px
    10px 25px 4px"},</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      children=[</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        html.P(f"{name}:"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">        html.Div(style={"margin-left":
    "6px"},</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">          children=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">dcc.Slider(**kwargs)),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">    ],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   )</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-10: Defining the
    NamedSlider component</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create an HTML <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    container that contains two elements: an HTML paragraph element that adds the
    label to the named slider using <samp class="SANS_TheSansMonoCd_W5Regular_11">html.P()</samp>
    and another <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> that contains
    a regular Dash <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Slider()</samp>
    element. Here we hardcode some style elements by setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">padding</samp>
    attribute of the style dictionary of the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>.
    This is a great example of why we might choose to remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">style</samp>
    key from the dictionary using <samp class="SANS_TheSansMonoCd_W5Regular_11">_omit()</samp>,
    as discussed earlier; if we wanted to change the style, we’d use this specific
    style parameter of Dash’s HTML components. In our case, the custom styling extends
    the box width around the named slider component. If we were to change this in
    *dash_reusable_components.py*, every instance we create in *app.py* would change
    to match!'
  prefs: []
  type: TYPE_NORMAL
- en: We use the formatting string <samp class="SANS_TheSansMonoCd_W5Regular_11">f"{name}:"</samp>
    to access the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    argument of the <samp class="SANS_TheSansMonoCd_W5Regular_11">NamedSlider()</samp>
    call from *app.py* and put it into the string that will serve as the label for
    our slider. This is what allows us to give each slider its own label.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">"margin-left"</samp> attribute
    of the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> shifts the
    whole slider slightly to the right to give the appearance of an indentation of
    the slider component.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*The custom function names in* dash_reusable_components.py *start with a capitalized
    letter by convention because Dash components are capitalized too. This way, calling
    a reusable component feels similar to calling a predefined Dash component.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-11](chapter7.xhtml#List7-11) shows the code in *app.py* that instantiates
    the named slider in [Figure 7-6](chapter7.xhtml#fig7-6).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">drc.NamedSlider(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   name="Degree",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   id="slider-svm-parameter-degree",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   min=2,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   max=10,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   value=3,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   step=1,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   marks={</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">      str(i): str(i) for i in
    range(2, 11, 2)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   },</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-11: Instantiating
    the NamedSlider component</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The slider has a minimum value of 2 and a maximum value of 10\. We also set
    the marks of the slider to the integers 2, 4, 6, 8, and 10, created by the generator
    expression <samp class="SANS_TheSansMonoCd_W5Regular_11">str(i) for i in range(2,
    11, 2)</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Defining a Named Dropdown</samp>
  prefs: []
  type: TYPE_NORMAL
- en: As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Slider</samp>, we’ll
    build on <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Dropdown()</samp> to
    create a named dropdown that includes a label. The process here is similar to
    creating a named slider, so we’ll go over it very briefly to show it to you in
    different contexts. [Listing 7-12](chapter7.xhtml#List7-12) shows the definition
    that goes in *dash_reusable_components.py*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def NamedDropdown(name, **kwargs):</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">      style={"margin": "10px
    0px"},</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      children=[</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">        html.P(children=f"{name}:",
    style={"margin-left": "3px"}),</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        dcc.Dropdown(**kwargs),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      ],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   )</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-12: Defining the
    NamedDropdown component</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We pass through the list of keyword arguments using the double-asterisk operator
    to both catch all keyword arguments in the <samp class="SANS_TheSansMonoCd_W5Regular_11">kwargs</samp>
    dictionary and unpack all those keyword arguments into the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Dropdown()</samp>
    creation routine. The function argument <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    that is passed in when creating the <samp class="SANS_TheSansMonoCd_W5Regular_11">NamedDropdown</samp>
    instance serves as the text label in the HTML paragraph element.
  prefs: []
  type: TYPE_NORMAL
- en: The resultant <samp class="SANS_TheSansMonoCd_W5Regular_11">NamedDropdown</samp>
    reusable component will look something like [Figure 7-7](chapter7.xhtml#fig7-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-7: Example of a named
    dropdown</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 7-13](chapter7.xhtml#List7-13) we create this component in *app.py*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">drc.NamedDropdown(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   name="Select Dataset",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   id="dropdown-select-dataset",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   options=[</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">      {"label": "Moons", "value":
    "moons"},</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      {</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">        "label": "Linearly Separable",</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">        "value": "linear",</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      },</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      {</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">        "label": "Circles",</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">        "value": "circles",</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      },</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   ],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   clearable=False,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   searchable=False,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   value="moons",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-13: Instantiating
    the NamedDropdown</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">component</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We call the newly created <samp class="SANS_TheSansMonoCd_W5Regular_11">drc.NamedDropdown()</samp>
    function with the name we want to give the named dropdown component. The remaining
    keyword arguments <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp> (identifier
    of the HTML element), <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp>
    (labels and values of the dropdown), <samp class="SANS_TheSansMonoCd_W5Regular_11">clearable</samp>
    (a Boolean either allowing or disallowing users to clear the current selected
    entry by clicking a small icon), <samp class="SANS_TheSansMonoCd_W5Regular_11">searchable</samp>
    (a Boolean either allowing or disallowing users to search the dropdown for a specific
    value), and <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> (a default
    dropdown value) are packed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">kwargs</samp>
    dictionary and handed downstream to the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Dropdown()</samp>
    creation routine.
  prefs: []
  type: TYPE_NORMAL
- en: This instantiation will create the named dropdown in [Figure 7-8](chapter7.xhtml#fig7-8),
    with the default dataset set to “Moons” and both <samp class="SANS_TheSansMonoCd_W5Regular_11">searchable</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">clearable</samp> disabled.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-8: Named dropdown
    clicked state</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Using reusable components is an extremely efficient way to scale your application
    and create whole new libraries for global use. Just define your own *dash_reusable_components.py*
    file and use the wrapper functions around existing Dash and HTML components in
    your main program file. Reusable components give you easy ways to customize the
    look and feel of your app and make your code easier to understand, more concise,
    and easier to maintain, even if your app requires thousands of lines of code!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll dive into some new Dash components in the SVM Explorer app that
    haven’t been covered yet.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Using a Dash Graph</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The core component of the whole SVM Explorer app is, of course, the graph that
    visualizes the learning and classification performance on the chosen training
    data. [Figure 7-9](chapter7.xhtml#fig7-9) shows the final graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-9: Example Dash graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First we train the model using the input parameters from the different controls
    in the dashboard. Then we test the accuracy of the model for the test dataset.
    The dots visualize the training data. The triangles visualize the test data. Red
    data points belong to one class and blue to another; we’ll call them class X and
    class Y, respectively. For each piece of training data, we already know whether
    it is X or Y; that is, whether it falls on one side of the decision boundary or
    the other. The model then estimates which class each piece of test data belongs
    to, based on the learned decision boundary from the training data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function call accomplishes this powerful visualization (line
    434 in the *app.py* sample project):'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph(id="graph-sklearn-svm",
    figure=prediction_figure)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: We create a <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph</samp> component
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">id "graph-sklearn-svm"</samp>.
    As a <samp class="SANS_TheSansMonoCd_W5Regular_11">figure</samp> argument, we
    pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">prediction_figure</samp>
    variable, which we defined in lines 410 through 421 in *app.py* (see [Listing
    7-14](chapter7.xhtml#List7-14)).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">prediction_figure = figs.serve_prediction_plot(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   model=clf,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   X_train=X_train,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   X_test=X_test,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   y_train=y_train,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   y_test=y_test,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   Z=Z,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   xx=xx,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   yy=yy,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   mesh_step=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">h,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   threshold=threshold,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-14: Defining the
    graph’s attributes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We won’t go into a lot of technical detail here, but notice that the function
    call uses four primary datasets: <samp class="SANS_TheSansMonoCd_W5Regular_11">X_train</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y_train</samp>, as well as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">X_test</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y_test</samp>.
    Like in all supervised learning, we train the model using a training dataset consisting
    of a collection of *(X, y)* tuples for input data *X* and output data *y* to obtain
    the mapping *X* → *y*. We pass all these bits of information into the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">figs.serve_prediction_plot()</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'This function plots the prediction contour of the SVM, the threshold line,
    and the test and training scatter data. Then it returns the resultant figure as
    an object that can be passed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph</samp>
    component, as shown before. We’ll break it down and discuss its composite parts.
    First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">figs</samp> section refers
    to this import statement in the header of *app.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">import utils.figures as figs</samp>
  prefs: []
  type: TYPE_NORMAL
- en: We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">figures</samp> module
    from the *utils* folder and name it <samp class="SANS_TheSansMonoCd_W5Regular_11">figs</samp>.
    The module contains utility functions to create the various plots shown in the
    dashboard, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">serve_prediction_plot()</samp>
    function for the SVM model’s training and testing data visualization.
  prefs: []
  type: TYPE_NORMAL
- en: The function <samp class="SANS_TheSansMonoCd_W5Regular_11">serve_prediction_plot()</samp>
    creates the Plotly graph object used to visualize the training and testing data
    and the contour plot (see [Figure 7-10](chapter7.xhtml#fig7-10)). We define it
    in lines 7 through 96 in the *figures.py* module, shown in [Listing 7-15](chapter7.xhtml#List7-15).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">import plotly.graph_objs as go</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def serve_prediction_plot(...):</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   # Create the plot</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   # Plot the prediction contour
    of the SVM</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   trace0 = go.Contour(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   )</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   # Plot the threshold</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   trace1 = go.Contour(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   )</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   # Plot Training Data</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   trace2 = go.Scatter(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   )</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   trace3 = go.Scatter(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   )</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   layout = go.Layout(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   )</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   data = [trace0, trace1, trace2,
    trace3]</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   figure = go.Figure(data=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">data, layout=layout)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   return figure</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-15: Creating a graph
    object and filling it with data</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code skeleton shows how we create the contour plots shown in [Figure 7-10](chapter7.xhtml#fig7-10)
    that visualize the SVM confidence levels, as well as the two scatter plots for
    the training and test data. We store these plots in four variables: <samp class="SANS_TheSansMonoCd_W5Regular_11">trace0</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">trace1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">trace2</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">trace3</samp>. We then use these
    variables as the data input argument of the <samp class="SANS_TheSansMonoCd_W5Regular_11">go.Figure()</samp>
    constructor that creates a Plotly figure object containing the four datasets.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll take a look at the <samp class="SANS_TheSansMonoCd_W5Regular_11">go.Contour</samp>
    component next.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Creating a Plotly
    Contour Plot</samp>
  prefs: []
  type: TYPE_NORMAL
- en: A *contour line* is a great way to visualize three-dimensional data in a two-dimensional
    plot. Each point *(x,y)* in 2D space has an associated *z* value, which you can
    think of as the “height” of the point (for example, an altitude value for a 2D
    map). All points on a contour line have the same *z* values. [Figure 7-10](chapter7.xhtml#fig7-10)
    shows an example of contour lines.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-10: Example contour
    plot</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To define these contour lines, we define the *z* values in a 2D array where
    cell *(x,y)* defines the *z* value for the respective *x* and *y* points in space.
    Python will then automatically “connect” these points in contour lines. The code
    snippet in [Listing 7-16](chapter7.xhtml#List7-16) produces this plot.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">import plotly.graph_objects as
    go</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">fig = go.Figure(data =</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   go.Contour(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      z = [[1, 2, 3],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">          [2, 3, 4],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">          [3, 4, 5]]</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   ))</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">fig.show()</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-16: Creating a basic
    contour plot</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In the *z* array, which cells *(x,y)* have a *z* value of 3? The three cells
    (0,2), (1,1), and (2,0). Now, investigate the contour plot figure and find those
    points *(x,y)* in 2D space. Is the visualized *z* value the same value of 3?
  prefs: []
  type: TYPE_NORMAL
- en: You can see that by defining a few points with similar *z* values. Plotly does
    all the heavy lifting of visualizing the contour plot and even coloring it! If
    you want to learn more about the contour plot (for example, how to customize the
    *x* and *y* values or the shape of the contour lines), visit [*https://<wbr>plotly<wbr>.com<wbr>/python<wbr>/contour<wbr>-plots*](https://plotly.com/python/contour-plots).
  prefs: []
  type: TYPE_NORMAL
- en: In the contour plot in the SVM model, the contour lines are the points that
    generate the same certainty of a point belonging to a particular class. This “certainty”
    is called a *decision function*, and it associates a value to each point in space.
    It is the heart of the machine learning model. You could argue that the decision
    function *is* the model. For a given input *x*, the sign of the decision function
    *f(x)* defines whether the model *f* predicts that *x* belongs to one class. If
    it is positive, it belongs to class X, and if it is negative, it belongs to class
    Y. The more positive or negative the decision function is, the more certain it
    is that the input point belongs to the class.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Using Dash Loading</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'In “Using a Dash Graph” earlier, you learned about the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph</samp>
    component with the <samp class="SANS_TheSansMonoCd_W5Regular_11">prediction_figure</samp>
    argument. The computations involved are relatively complicated and may take some
    loading or initialization time. The user may have to wait, and it can hurt usability
    and feel clunky to use, so the designers of the SVM Explorer app decided to wrap
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph</samp> in a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dcc.Loading</samp> component. The idea
    is simple: while your Python interpreter crunches the numbers and runs the computation,
    Dash shows you a loading symbol (load spinner). Always keep the user in the loop!'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-11](chapter7.xhtml#fig7-11) shows what such a loading symbol may
    look like at different points in time.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-11.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-11: Example Dash loading
    symbol</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This dynamic loading symbol is then shown to the user for as long as it takes
    to load the Dash component that is wrapped by the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Loading</samp>
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s have a look at how we used the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Loading</samp>
    component in the SVM Explorer app (see [Listing 7-17](chapter7.xhtml#List7-17)).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">children=dcc.Loading(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   className=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">"graph-wrapper",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   children=dcc.Graph(id="graph-sklearn-svm",
    figure=prediction_figure),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">   style={"display": "none"},</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-17: Setting the loading
    behavior</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function call has three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">className   </samp>We associate
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">graph-wrapper</samp> class definition
    from the CSS stylesheet. This simply defines some width and height constraints
    for the component.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">children   </samp>This is the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph</samp> object to be wrapped
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Loading</samp> component.
    While this object loads, the loading symbol is supposed to be shown.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">style</samp>   We add a dictionary
    of style attributes to the element. In particular, we set the <samp class="SANS_TheSansMonoCd_W5Regular_11">"display"</samp>
    attribute to <samp class="SANS_TheSansMonoCd_W5Regular_11">"none"</samp>. This
    essentially hides the whole element. However, in the stylesheet, we overwrite
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">"display"</samp> attribute to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"flex"</samp>, which sets the size
    flexibly according to the available space. Code is never perfect, and this could
    have been written more concisely by the creators of the SVM app.
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, we won’t even see the loading symbol if we run the SVM Explorer
    app because the components load so quickly. We suspect that this app was initially
    implemented for a slower version of Dash. But Dash is improving rapidly in speed
    and usability, so this SVM app can now be computed quickly—and we can simply skip
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Loading</samp> wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete video tutorial on using loading spinners in Dash apps, see the
    video “Dash Bootstrap Spinner & Progress Bar” available at [*https://<wbr>learnplotlydash<wbr>.com*](https://learnplotlydash.com).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Dash Callbacks</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SVM Explorer app is an advanced app with many interacting code pieces. So
    far, we’ve focused on the isolated components you haven’t already seen in another
    app. Now it’s time to look at the bigger picture again, by exploring how the different
    components interact.
  prefs: []
  type: TYPE_NORMAL
- en: To get a quick overview of where to focus, let’s start with the callback graph
    provided by the Dash framework when you run your app with <samp class="SANS_TheSansMonoCd_W5Regular_11">debug=True</samp>
    (see [Listing 7-18](chapter7.xhtml#List7-18)).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11"># Running the server</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">if __name__ == "__main__":</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   app.run_server(debug=True)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-18: Enabling debugging</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can now access the automatically generated callback graph via the button
    menu shown in [Figure 7-12](chapter7.xhtml#fig7-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-12.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-12: Callback graph
    button menu</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This button menu should appear at the lower right of your Dash app in your browser.
    Click **Callback Graph** to obtain what’s shown in [Figure 7-13](chapter7.xhtml#fig7-13).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-13.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-13: The callback graph
    for the SVM Explorer app</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The names above the boxes are the Dash components you defined in your *app.py*
    file. [Listing 7-19](chapter7.xhtml#List7-19) shows an example of the code for
    a named slider.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">drc.NamedSlider(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   name="Cost (C)",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   id="slider-svm-parameter-C-power",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   min=-2,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   max=4,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   value=</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">0,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   marks={</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">      i: "{}".format(10 ** i)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      for i in range(-2, 5)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   },</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-19: NamedSlider component
    definition, showing where the names in the callback graph come from</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the name <samp class="SANS_TheSansMonoCd_W5Regular_11">slider-svm-parameter-C-power</samp>
    in one of the upper four boxes. With the named slider, you feed into the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">slider-svm-parameter-C-coef</samp> component.
    All components feed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">div-graphs</samp>
    component that holds all our SVM graphs.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s focus on the callback function that maps all those inputs into the
    single output component <samp class="SANS_TheSansMonoCd_W5Regular_11">div-graphs</samp>
    in lines 346 through 453 in the *app.py* main file. In particular, we’re going
    to start with the input and output annotations and the function definition, shown
    in [Listing 7-20](chapter7.xhtml#List7-20).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">@app.callback(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   Output("div-graphs", "children"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   [</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("dropdown-svm-parameter-kernel",
    "value"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("slider-svm-parameter-degree",
    "value"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("slider-svm-parameter-C-coef",
    "value"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("slider-svm-parameter-C-power",
    "value"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("slider-svm-parameter-gamma-coef",
    "value"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("slider-svm-parameter-gamma-power",
    "value"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("dropdown-select-dataset",
    "value"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("slider-dataset-noise-level",
    "value"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("radio-svm-parameter-shrinking",
    "value"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("slider-threshold",
    "value"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      Input("slider-dataset-sample-size",
    "value"),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   ],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">def update_svm_graph(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   kernel,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   degree,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   C_coef,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   C_power,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   gamma_coef,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   gamma_power,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   dataset,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   noise,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   shrinking,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   threshold,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   sample_size,</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">):</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-20: Input and output
    annotations of the SVM graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a single input, the function has a list of inputs, as shown graphically
    in the callback graph. All those inputs are needed to calculate the SVM model.
    This SVM model is then used to create all the graphs you see in the SVM Explorer
    app.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-21](chapter7.xhtml#List7-21) shows the code that generates the different
    graphs.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   # … Model Computations Skipped
    for Readability …</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">return
    [</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         id="svm-graph-container",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">         children=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">dcc.Loading(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">            </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">className="graph-wrapper",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">            children=dcc.Graph(id="graph-sklearn-svm",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                               figure=prediction_figure),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">           style={"display":
    "none"},</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">      html.Div(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        id="graphs-container",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        children=[</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">           dcc.Loading(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">              className="graph-wrapper",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">              children=dcc.Graph(id=</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">"graph-line-roc-curve",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                                 figure=roc_figure),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">           ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">           dcc.Loading(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">              className="graph-wrapper",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">              children=dcc.Graph(</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                 id="graph-pie-confusion-matrix",</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">                 figure=confusion_figure</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">              ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">           ),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">        </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">],</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">    </samp><samp class="SANS_TheSansMonoCd_W5Regular_11">),</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">   ]</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-21: Return value
    of the update_svm_graph function that generates the graphs in the SVM Explorer
    app</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The return value is a list of two <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp>
    elements. The first holds the prediction figure discussed in the “Creating a Plotly
    Contour Plot” section earlier in this chapter. The second holds two more <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph</samp> elements: a line graph
    and a pie chart. [Figure 7-14](chapter7.xhtml#fig7-14) shows the three generated
    graphs.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-14.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-14: Three dcc.Graph</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">elements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We covered many advanced Dash concepts in this chapter. You learned about the
    robust SVM classification algorithm and how dashboards can help you visualize
    machine learning models. You learned how to integrate NumPy and scikit-learn into
    your Dashboard apps, and how to create reusable components. You also learned about
    or strengthened your understanding of Dash HTML components such as <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Div</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">html.A</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Section</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">html.P</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">html.Button</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">html.H2</samp>, as well as standard
    Dash components such as <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Graph</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Slider</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">dcc.Dropdown</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: You now possess the skills to go out there and create your own complex dashboard
    apps and dive into the gallery to learn about advanced Dash components and features.
    We didn’t just give you the fish; we told you how and where to get the fish yourself.
    The gallery is an ocean full of fish, and if you ever feel hungry for more, you’ll
    know where to go!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Resources</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To dive deeper into the SVM Explorer app, feel free to check out the following
    resources recommended to us by Xing Han, one of the app’s creators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Classifier comparison: [*https://<wbr>scikit<wbr>-learn<wbr>.org<wbr>/stable<wbr>/auto<wbr>_examples<wbr>/classification<wbr>/plot<wbr>_classifier<wbr>_comparison<wbr>.xhtml*](https://scikit-learn.org/stable/auto_examples/classification/plot_classifier_comparison.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ROC metric: [*https://<wbr>scikit<wbr>-learn<wbr>.org<wbr>/stable<wbr>/auto<wbr>_examples<wbr>/model<wbr>_selection<wbr>/plot<wbr>_roc<wbr>.xhtml*](https://scikit-learn.org/stable/auto_examples/model_selection/plot_roc.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Confusion matrix: [*https://<wbr>scikit<wbr>-learn<wbr>.org<wbr>/stable<wbr>/modules<wbr>/model<wbr>_evaluation<wbr>.xhtml#confusion<wbr>-matrix*](https://scikit-learn.org/stable/modules/model_evaluation.xhtml#confusion-matrix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SVM classifier (SVC): [*https://<wbr>scikit<wbr>-learn<wbr>.org<wbr>/stable<wbr>/modules<wbr>/generated<wbr>/sklearn<wbr>.svm<wbr>.SVC<wbr>.xhtml*](https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“A Practical Guide to Support Vector Classification (SVC)”: [*https://<wbr>www<wbr>.csie<wbr>.ntu<wbr>.edu<wbr>.tw<wbr>/~cjlin<wbr>/papers<wbr>/guide<wbr>/guide<wbr>.pdf*](https://www.csie.ntu.edu.tw/~cjlin/papers/guide/guide.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
