<html><head></head><body>
<div id="sbo-rt-content"><h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_121"/><strong><span class="big">7</span><br/>SECURE COMMUNICATION</strong></h2>
<div class="image1"><img alt="Image" height="252" src="../images/common.jpg" width="252"/></div>
<p class="noindent">In the past, many embedded systems operated in an <em>air-gapped</em> environment, not connected to any wired or wireless network. Although this practice is still present in some industries, it’s slowly vanishing for the simple reason that none of the modern ideas like predictive maintenance, data-driven optimization, and remote access work without proper communication channels.</p>
<p class="indent">Even the first cryptographic methods in the days of Caesar aimed to protect communication, and 2,000 years later, the internet is inconceivable without secure communication. However, a significant number of <em>devices</em> still don’t use secure protocols for data exchange with their administrators and other entities in their environment.</p>
<p class="indent">In this chapter, we’ll first look at the set of requirements that’s imposed on robust communication channels, followed by an introduction to the most common protocol to tackle these challenges and a corresponding practical case study. Afterward, we’ll look at two areas where the standard solution doesn’t help: non-IP communication and the need for redundancy.</p>
<h3 class="h3" id="ch00lev1_57"><span epub:type="pagebreak" id="page_122"/><strong>All the Protection Goals</strong></h3>
<p class="noindent">Communication is inherent to human nature. We exchange thoughts, provide assistance to others, and work together in teams. Every child who whispers something into somebody’s ear is implicitly aware of confidentiality protection.</p>
<p class="indent">For written messages, confidentiality has been a topic for thousands of years, as the example of Caesar shows, and it’s still present in postal privacy laws. For centuries, monarchs have used royal seals to guarantee the integrity and authenticity of documents, while replication of information by letterpress printing clearly targets availability—even if one “information source” fails, still others can be used to acquire that same “communication data.”</p>
<p class="indent">Digital communication at internet scale has been practiced for roughly 30 years, and it’s not surprising that it unites the demands for <em>all the protection goals</em> of previous communication approaches. Considering the specific field of (I)IoT device communication, confidentiality is apparently useful, because either proprietary values corresponding to intellectual property are transferred or personal data about humans is communicated that deserves privacy protection.</p>
<p class="indent">Also, integrity and authenticity are valued in many cases—for example, for control commands in industrial systems. In those scenarios, it’s very important that the origin of communication is a legitimate party and that messages haven’t been altered on the way. As mentioned before, typical (I)IoT devices rely on working communication channels. Disturbances—for example, those introduced by DoS attacks—threaten proper system operation and maybe even related business models.</p>
<h3 class="h3" id="ch00lev1_58"><strong>Transport Layer Security</strong></h3>
<p class="noindent">When we talk about data communication, we usually start by locating it within the <em>Open Systems Interconnection (OSI) model</em>. This model supports us in structuring stacks of communication protocols, as shown in <a href="ch07.xhtml#ch07tab01">Table 7-1</a>.</p>
<p class="tabcap" id="ch07tab01"><strong>Table 7-1:</strong> Communication Layers According to the OSI Model</p>
<table class="table-h">
<colgroup>
<col style="width:15%"/>
<col style="width:30%"/>
<col style="width:55%"/>
</colgroup>
<thead>
<tr>
<th class="tab_th"><strong>Number</strong></th>
<th class="tab_th"><strong>Layer</strong></th>
<th class="tab_th"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="bg1">7</td>
<td class="bg1">Application</td>
<td class="bg1">Application-specific communication data processing</td>
</tr>
<tr>
<td class="bg">6</td>
<td class="bg">Presentation</td>
<td class="bg">Translation between network data and application</td>
</tr>
<tr>
<td class="bg1">5</td>
<td class="bg1">Session</td>
<td class="bg1">Session management for communication between nodes</td>
</tr>
<tr>
<td class="bg">4</td>
<td class="bg">Transport</td>
<td class="bg">Management of data transmissions between network nodes</td>
</tr>
<tr>
<td class="bg1">3</td>
<td class="bg1">Network</td>
<td class="bg1">Management of a multiparticipant network</td>
</tr>
<tr>
<td class="bg">2</td>
<td class="bg">Data link</td>
<td class="bg">Transfer of data frames between two entities</td>
</tr>
<tr>
<td class="bg1">1</td>
<td class="bg1">Physical</td>
<td class="bg1">Wired/wireless transmission over a physical medium</td>
</tr>
</tbody>
</table>
<p class="indent"><span epub:type="pagebreak" id="page_123"/>The Ethernet standard IEEE 802.3 is a typical example that specifies properties for layers 1 and 2. Often, Internet Protocol (IP) handles the network layer, while Transmission Control Protocol (TCP) and User Datagram Protocol (UDP) cover functionalities in layers 4 and 5. Application protocols like the common HyperText Transfer Protocol (HTTP) are represented by layer 7.</p>
<p class="indent">This section focuses on one of the most common protocols for secure communication: Transport Layer Security (TLS). It might seem obvious that it’s located on layer 4 of the OSI model; however, encryption and decryption are usually attributed to layer 6. And since TLS also performs some kind of session management, we could say that it spans across layers 4 to 6 and, thereby, introduces a protection layer between raw packets distributed over a network and the application using the transmitted data in the end.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>TLS is application agnostic. Its payload might carry any application protocol like HTTP or even industrial protocols like Modbus.</em></p>
</div>
<h4 class="h4" id="ch00lev2_75"><strong><em>History</em></strong></h4>
<p class="noindent">In the 1990s, while Netscape was working on a browser application of the same name, the need for secure internet communication became apparent. In 1995, Netscape published the predecessor of TLS, the Secure Sockets Layer (SSL) protocol in version 2.0. SSL 2.0 and SSL 3.0, released the following year, had significant security issues and should never be used in practice.</p>
<p class="indent">Unfortunately, many software applications as well as product marketing brochures use <em>SSL</em> and <em>TLS</em> synonymously. Usually, you can assume it’s “a modern TLS version,” but as a customer, I would have much more confidence if the manufacturer would show its security know-how by not mentioning SSL anymore, anywhere.</p>
<p class="indent">The new protocol name was introduced in 1999 with TLS 1.0 (which was an upgraded version of SSL 3.0), maybe to reduce association with the weaknesses of the previous SSL versions. TLS 1.1 fixed security issues with the CBC operation mode of block ciphers in 2006. However, both TLS 1.0 and TLS 1.1 were officially deprecated in March 2021 and should not be used in modern products.</p>
<p class="indent">Version 1.2 of TLS was specified in August 2008 and is still widely in use. It replaced the use of weak hash functions like MD5 and SHA-1 with their modern counterpart, SHA-256, and extended the support for authenticated encryption ciphers like AES-GCM. However, the complexity of TLS 1.2 became its own enemy, and correct configuration was not trivial. To minimize configuration mistakes and maximize security and performance at the same time, TLS 1.3 was published in 2018. Every new device should use that version by default.</p>
<h4 class="h4" id="ch00lev2_76"><span epub:type="pagebreak" id="page_124"/><strong><em>TLS Basics</em></strong></h4>
<p class="noindentb">TLS is a set of client-server protocols that unite many modern cryptographic primitives introduced in <a href="ch02.xhtml#ch02">Chapter 2</a>. These are the two most important sub-protocols in practice:</p>
<p class="hanga"><strong>Handshake protocol</strong>    In this subprotocol, the cryptographic algorithms used to protect a communication channel are negotiated between client and server. Usually, at least one of them is authenticated to the other, but mutual authentication is also possible. Additionally, the handshake process establishes shared key material for the crypto algorithms used in the following communication. Any errors or tampering attacks at this stage lead to the termination of the connection.</p>
<p class="hanga"><strong>Record protocol</strong>    This subprotocol is responsible for organizing and protecting the bulk of traffic between two endpoints based on the algorithms and parameters negotiated in the handshake protocol.</p>
<p class="indentt">A further general property of TLS is that it uses X.509 certificates for authentication. However, in contrast to the device certificates mentioned in <a href="ch06.xhtml#ch06">Chapter 6</a>, the common name in these certificates usually corresponds to the device’s IP address, its hostname, or its fully qualified domain name (FQDN). This is because the information is used to establish the basic connection to the device on the network layer in the first place, and the device then has to prove that it’s the legitimate entity at this network node.</p>
<p class="indent">Never underestimate the complexity of TLS, and stick to secure defaults whenever you don’t have specific requirements to change them. The following sections shed light on the main properties of the two TLS versions in use today.</p>
<h4 class="h4" id="ch00lev2_77"><strong><em>TLS 1.3</em></strong></h4>
<p class="noindent">TLS 1.3 is specified in RFC 8446 and is <em>the</em> version that product engineers should implement and use. <a href="ch07.xhtml#ch07fig01">Figure 7-1</a> illustrates the handshake process for mutual authentication that could, for example, be part of a machine-to-machine communication scenario.</p>
<div class="image"><span epub:type="pagebreak" id="page_125"/><img alt="Image" height="484" id="ch07fig01" src="../images/07fig01.jpg" width="877"/></div>
<p class="figcap"><em>Figure 7-1: A typical TLS 1.3 handshake with mutual authentication</em></p>
<p class="indent">In the first step, the client initiates the connection establishment by sending the <code>ClientHello</code> <span class="ent">➊</span> message to a server. This message contains the client’s key share for a DHE or ECDHE key agreement scheme, its supported TLS version, and a list of available crypto algorithms and parameters. In response, the server provides its own data for the intended key exchange, its certificate, and a signature proving the possession of the corresponding private key. Further, it requests the client to authenticate itself and concludes the <code>ServerHello</code> <span class="ent">➋</span> of the handshake with a <code>Finished</code> message.</p>
<p class="indent">In the third part of the handshake, the client fulfills the server’s certificate request by sending its certificate and a signature proving its identity <span class="ent">➌</span>. After the client’s <code>Finished</code> message, both parties can be sure about the other’s identity and are prepared to securely exchange application data <span class="ent">➍</span>.</p>
<h5 class="h5" id="ch00lev3_15"><strong>Further Handshake Options</strong></h5>
<p class="noindent">Besides key-agreement schemes like DHE and ECDHE that guarantee perfect forward secrecy but also consume significant performance, TLS 1.3 also provides a <em>pre-shared key (PSK)</em> option, which distributes keys to devices in an earlier process. However, this isn’t the default variant and should be used only in exceptional cases and for solid reasons.</p>
<p class="indent"><span epub:type="pagebreak" id="page_126"/>To reduce the necessity for the execution of a complete handshake, TLS 1.3 allows you to reuse PSKs from previous (EC)DHE handshakes if the client and server agree on it, which means costly asymmetric crypto operations can be spared and efficiency is enhanced.</p>
<p class="indent">If a client and server share a PSK, TLS 1.3 provides a zero round-trip time (0-RTT) mode that allows a client to send PSK-encrypted data with its first message, immediately enabling application data communication. However, this speed improvement comes at a price: perfect forward secrecy can’t be guaranteed anymore, and the 0-RTT messages are not protected against replay of messages obtained earlier.</p>
<h5 class="h5" id="ch00lev3_16"><strong>Selection of Crypto Algorithms</strong></h5>
<p class="noindent">Compared to TLS 1.2, TLS 1.3 has significantly reduced the set of possible crypto algorithms to be used. This is a strong security enhancement, since it prevents <em>downgrade attacks</em> that try to influence crypto parameter negotiation to force the usage of weak algorithms. In the course of this cleanup, the <em>cipher suite</em>, a collection of supported crypto algorithms, was reduced to contain symmetric crypto only.</p>
<p class="indent">For this symmetric cryptography, TLS 1.3 requires the implementation of the <code>TLS_AES_128_GCM_SHA256</code> cipher suite, which means that AES with a 128-bit key has to operate in GCM mode, and the hash function SHA-256 must be available to be used as an HMAC-based extract-and-expand key derivation function (HKDF), which is relevant to derive TLS secrets. The additional <code>TLS_AES_256_GCM_SHA384</code> and <code>TLS_CHACHA20_POLY1305_SHA256</code> cipher suites should also be implemented but aren’t mandatory. Two cipher suites based on the CCM mode complete the five possible options for symmetric crypto in TLS 1.3, and they all belong to the class of modern AEAD algorithms.</p>
<p class="indent">Regarding digital signature algorithms and certificates, TLS 1.3 implementations must support RSA PSS and PKCS1 in combination with SHA-256, but also ECDSA based on the NIST curve <code>secp256r1</code> and SHA-256. The mandatory curve for ECDHE is also <code>secp256r1</code>, but the RFC recommends the additional implementation of X25519. DHE based on finite field groups is also possible.</p>
<h4 class="h4" id="ch00lev2_78"><strong><em>TLS 1.2</em></strong></h4>
<p class="noindent">Although TLS 1.3 is the most recent version, many devices still rely on TLS 1.2 specified in RFC 5246, or at least support its use to maintain compatibility to legacy devices. However, this requires taking precautions to guarantee secure communication.</p>
<h5 class="h5" id="ch00lev3_17"><strong>TLS 1.2 vs. TLS 1.3</strong></h5>
<p class="noindent">A somewhat formal difference between TLS 1.2 and TLS 1.3 is that version 1.2 cipher suites include asymmetric as well as symmetric algorithms and parameters. For example, the <code>TLS_DH_RSA_WITH_AES_256_CBC_SHA384</code> cipher suite specifies that DH (without the <em>E</em> for <em>ephemeral</em>) is used for key exchange; authentication is based on an RSA certificate; AES with a 256-bit key in CBC <span epub:type="pagebreak" id="page_127"/>mode is used for payload encryption, and SHA-384 is the hash function used in the key-derivation scheme.</p>
<p class="indent">In addition to the different cipher suite format, TLS 1.2 supports and allows a much larger set of crypto algorithms, which can have negative consequences in several cases. Besides the possibility of choosing static key-exchange mechanisms based on RSA and DH, it’s even possible to select cipher suites that explicitly allow anonymous DH key exchange, which means without any verification of the communication partner.</p>
<p class="indent">TLS 1.2 also allows you to select legacy ciphers like 3DES and Rivest Cipher 4 (RC4) or even the <code>NULL</code> cipher without payload encryption. Further, operation modes like CBC can be selected that don’t lead to AEAD-compliant security.</p>
<p class="indent">The option to compress data before transmitting it over TLS was well-meant by the designers and is still available in TLS 1.2, but it facilitates vulnerability, as shown by the Compression Ratio Info-Leak Made Easy (CRIME) attack.</p>
<p class="indent">Besides those security-related differences, TLS 1.2 also misses some performance optimizations introduced by TLS 1.3 and the 0-RTT mode.</p>
<h5 class="h5" id="ch00lev3_18"><strong>Secure Usage</strong></h5>
<p class="noindent">The key to the secure configuration of TLS 1.2 lies in the strong restriction of its options. Your implementation must disallow deprecated ciphers like 3DES, RC4, weakened export ciphers, CBC operation mode, and (of course) the <code>NULL</code> cipher. Key exchange based on RSA key transport has to be denied as well as anonymous DH. Further, options like data compression have to be disabled to reduce the attack surface.</p>
<p class="indent">Looking at it the other way around, your configuration should enable only cipher suites that implement DHE and ECDHE key exchange and symmetric AEAD ciphers in combination with hash functions from the SHA-2 family, which means TLS 1.2 can be trimmed to behave similarly to TLS 1.3 and provide secure communication channels.</p>
<h4 class="h4" id="ch00lev2_79"><strong><em>Requirements for Devices and Infrastructure</em></strong></h4>
<p class="noindentb">Assuming you’ve decided that TLS is the way to go for your device and you want to make things happen, you still have some requirements to consider before implementing a semi-secure communication helter-skelter. From a device perspective, you should analyze at least five aspects:</p>
<p class="hanga"><strong>Private-key storage</strong>    If your device has to be able to authenticate itself by signing data with a private key, it needs a secure place to store that secret in a confidential way.</p>
<p class="hanga"><strong>Certificate store</strong>    The verification of communication partners’ identities is possible only if your device is in possession of corresponding public keys and root certificates. These files don’t contain confidential information but need to be stored in an integrity-protected way because they represent your device’s trust base.</p>
<p class="hanga"><span epub:type="pagebreak" id="page_128"/><strong>Trustworthy source of randomness</strong>    Key-generation and key-exchange schemes in TLS require the availability of trustworthy random numbers. If your device generates “random numbers” based on a static value, this might have severe consequences for TLS security.</p>
<p class="hanga"><strong>Reliable time base</strong>    Especially in industrial scenarios, but also in other application domains, devices often don’t need a real-time clock. However, if you want to use TLS, your device has to be able to verify the validity period of certificates, which is clearly not possible if it’s stuck in the 1980s time-wise.</p>
<p class="hanga"><strong>Crypto performance</strong>    The TLS handshake performs several operations based on asymmetric crypto. Low-performance devices might reach their limit, for example, if they have to perform signing with RSA keys. The basic decision of RSA or ECDSA might have a strong impact on this point. It also makes a big difference if your device is meant to act as a client authenticating once a day, or if it has to handle hundreds of connection and authentication requests per minute as a server.</p>
<p class="indentt">Not only does your device itself need to be prepared for TLS, but also your infrastructure and processes need to support it. A common example is the operation of a PKI to manage the generation, updating, and revocation of certificates.</p>
<p class="indent">Further, the real-time clock in your device probably depends on external time synchronization mechanisms like Network Time Protocol (NTP) and Precision Time Protocol (PTP), which require appropriate network services, master clocks, and the like.</p>
<h4 class="h4" id="ch00lev2_80"><strong><em>Application Examples and Software Libraries</em></strong></h4>
<p class="noindent">The most common use case for TLS is HyperText Transfer Protocol Secure (HTTPS), the protocol used throughout the internet. It’s also known as <em>HTTP over TLS</em>, because that’s essentially what’s happening: TLS establishes a secure channel between a client and a web server. Within this channel, plain HTTP requests and responses are exchanged. In the same way, secure communication can be achieved for many other application protocols.</p>
<p class="indent">TLS is based on TCP, but is there a way to protect applications like Voice over IP (VoIP) or online gaming that rely on UDP or other stateless protocols? Yes, you can use a variant called <em>Datagram Transport Layer Security (DTLS)</em>. DTLS 1.2 and DTLS 1.3 are based on TLS 1.2 and TLS 1.3, respectively. They guarantee the same security as their TCP-based counterparts but can handle loss and reordering of packets.</p>
<p class="indent">When it comes to TLS implementations, OpenSSL is probably the most popular one on Linux systems as well as in the field of embedded systems. However, if either source code transparency or small footprint are of interest to your product, Mbed TLS might be worth a look. Further, implementations are available in a multitude of programming languages, such as Rustls for the Rust community.</p>
<h3 class="h3" id="ch00lev1_59"><span epub:type="pagebreak" id="page_129"/><strong>Case Study: Secure MQTT Communication</strong></h3>
<p class="noindent">Over the last few years as a professor, I’ve seen several student projects using the MQTT protocol, because it’s pretty comprehensible and perfectly suits the needs of resource-constrained devices in IoT scenarios. It’s used to transmit sensor values like temperature or pressure as well as to control messages like start and stop commands for actuators in a system.</p>
<p class="indent">However, if I ask for a secure communication channel for the obviously sensitive message content, I usually get responses like “But it’s only a proof of concept!” or “There was no time left to tackle this complex topic.” And, “Why do you always ask such painful questions?”</p>
<p class="indent">In this case study, I’ll set up the Eclipse Mosquitto MQTT broker service on my STM32MP157F-DK2 board and configure it properly for secure communication based on TLS. Further, I’ll dynamically test the implementation for misconfigurations.</p>
<h4 class="h4" id="ch00lev2_81"><strong><em>Mosquitto Installation and Configuration</em></strong></h4>
<p class="noindent">Because the toolchain for my STM32MP157F-DK2 device is based on the Yocto Project, I can simply add the <code>mosquitto</code> recipe from <code>recipes-connectivity</code> of the <code>meta-networking</code> layer to my image to install the broker software on my device. The version I get is <code>2.0.14</code>. Of course, this comes only with a default configuration located at <em>/etc/mosquitto/mosquitto.conf</em>.</p>
<p class="indent">In MQTT, the broker is a central component that receives messages and data published by clients and distributes this information to clients that subscribe to it. For clients, it’s essential to share their data only with legitimate brokers and rely on messages only from brokers they trust. Therefore, MQTT brokers have to cryptographically authenticate to connecting clients.</p>
<p class="indent">As mentioned previously, TLS uses certificates for authentication, so the first step for broker authentication is to generate a corresponding certificate. I used Python and OpenSSL to create a CA and a MQTT broker certificate in a similar way, as described for device identities in <a href="ch06.xhtml#ch06">Chapter 6</a>. An important difference is the chosen common name in the certificate: it corresponds to the hostname <em>http://mqtt.iot-device-corp.com/</em> under which the device can be reached within my network. This is important for hostname verification by the clients, so they can be sure to be connected to the correct host.</p>
<p class="indent">Armed with the CA certificate <code>ca.crt</code>, the broker certificate <code>mqtt_broker.crt</code>, and its corresponding private key <code>mqtt_broker.key</code>, we can configure the basic TLS settings for <code>mosquitto</code> as shown in <a href="ch07.xhtml#ch07list01">Listing 7-1</a>.</p>
<pre class="pre">listener 8883&#13;
cafile /etc/mosquitto/certs/ca.crt&#13;
certfile /etc/mosquitto/certs/mqtt_broker.crt&#13;
keyfile /etc/mosquitto/certs/mqtt_broker.key</pre>
<p class="list-title" id="ch07list01"><em>Listing 7-1: The basic TLS configuration for</em> <span class="codeitalic1">mosquitto</span></p>
<p class="indent"><span epub:type="pagebreak" id="page_130"/>While plain MQTT is usually offered at port 1883, the version using secure communication based on TLS is typically provided at port 8883. Required certificates and keys can, for example, be stored in <em>/etc/mosquitto/ certs/</em>. So far, so good.</p>
<p class="indent">However, up until now, the system is configured only for server-side authentication. Client authentication would have to be managed by maintaining a password file on the device hosting the broker application (for example, at <em>/etc/mosquitto/password_file</em>), which might be tedious, and the associated security level would be medium at best. But since TLS supports mutual certificate-based authentication, and Mosquitto is able to utilize that procedure for application layer usage, it’s worth a look.</p>
<p class="indent"><a href="ch07.xhtml#ch07list02">Listing 7-2</a> shows the two options that have to be added to <em>mosquitto.conf</em>.</p>
<pre class="pre">require_certificate true&#13;
use_identity_as_username true</pre>
<p class="list-title" id="ch07list02"><em>Listing 7-2: Important options for certificate-based authentication of MQTT clients</em></p>
<p class="indent">The first line makes the broker request a certificate for authentication from each connecting client, while the second line enables the use of the common name contained in the provided certificate as the username in the MQTT application.</p>
<p class="indent">It’s important to note that, in this case, the client certificate has to be issued by the CA provided before by the <code>cafile</code> parameter. If you want to provide several trusted CAs to Mosquitto, the <code>capath</code> option is your friend. In my case, I just used the same CA as for the MQTT broker to create a further certificate, this time with the common name <code>mqtt-client123</code>.</p>
<h4 class="h4" id="ch00lev2_82"><strong><em>The First Test Run</em></strong></h4>
<p class="noindent">After starting <code>mosquitto</code> with the new configuration file, a brief <code>nmap</code> scan reveals that the MQTT broker is now available at port 8883, as shown in <a href="ch07.xhtml#ch07list03">Listing 7-3</a>.</p>
<pre class="pre">$ <span class="codestrong1">nmap mqtt.iot-device-corp.com -p 8883</span>&#13;
Starting Nmap 7.80 ( https://nmap.org ) at ...&#13;
Nmap scan report for mqtt.iot-device-corp.com (192.168.1.13)&#13;
Host is up (0.00067s latency).&#13;
&#13;
PORT     STATE SERVICE&#13;
8883/tcp open  secure-mqtt&#13;
&#13;
Nmap done: 1 IP address (1 host up) scanned in 0.03 seconds</pre>
<p class="list-title" id="ch07list03"><em>Listing 7-3: An</em> <span class="codeitalic1">nmap</span> <em>scan showing open port 8883</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_131"/>To test the secure communication, I wrote a little Python script that uses the Eclipse Paho MQTT client library. <a href="ch07.xhtml#ch07list04">Listing 7-4</a> shows the basic settings.</p>
<pre class="pre">broker = "mqtt.iot-device-corp.com"&#13;
port   = 8883&#13;
client = mqtt.Client("mqtt-client123")&#13;
client.tls_set('ca.crt', 'mqtt_client.crt', 'mqtt_client.key')&#13;
client.connect(broker, port)</pre>
<p class="list-title" id="ch07list04"><em>Listing 7-4: The basic Paho MQTT client configuration in Python</em></p>
<p class="indent">Besides obvious necessities like the hostname and the port of the MQTT broker, the client is also able to handle TLS settings like a trusted CA in <em>ca.crt</em>, and the client’s authentication data located in the <em>mqtt_client.crt</em> and <em>mqtt_client.key</em> files.</p>
<p class="indent">In the test application, the client subscribes to the topic <code>foo/bar</code>, publishes some data to the same topic, and receives the information again from the broker, as shown in <a href="ch07.xhtml#ch07list05">Listing 7-5</a>.</p>
<pre class="pre"><span class="ent">➊</span> New connection from 192.168.1.7:46317 on port 8883.&#13;
<span class="ent">➋</span> New client connected from 192.168.1.7:46317 as mqtt-client123&#13;
       (p2, c1, k60, u'mqtt-client123').&#13;
   ...&#13;
<span class="ent">➌</span> Received SUBSCRIBE from mqtt-client123&#13;
       foo/bar (QoS 0)&#13;
   Sending SUBACK to mqtt-client123&#13;
<span class="ent">➍</span> Received PUBLISH from mqtt-client123 (d0, q0, r0, m0, 'foo/bar', ... (2 bytes))&#13;
   Sending PUBLISH to mqtt-client123 (d0, q0, r0, m0, 'foo/bar', ... (2 bytes))&#13;
   ...&#13;
   Received DISCONNECT from mqtt-client123&#13;
   Client mqtt-client123 disconnected.</pre>
<p class="list-title" id="ch07list05"><em>Listing 7-5: The</em> <span class="codeitalic1">mosquitto</span> <em>console output during a test</em></p>
<p class="indent">Clearly, a connection was successfully established on port 8883 <span class="ent">➊</span>. Also, <code>mosquitto</code> directly uses the client certificate’s common name (<code>mqtt-client123</code>) as the associated username <span class="ent">➋</span> for this connection. Both client commands, <code>SUBSCRIBE</code> <span class="ent">➌</span> and <code>PUBLISH</code> <span class="ent">➍</span>, are correctly received and handled on the broker side as well.</p>
<h4 class="h4" id="ch00lev2_83"><strong><em>Communication Security Analysis with Wireshark and SSLyze</em></strong></h4>
<p class="noindent">The application seems to be working properly even though we already activated several TLS security features. That raises hope, but as security engineers, we’d prefer to base our trust on thorough analysis rather than gut feelings.</p>
<p class="indent"><span epub:type="pagebreak" id="page_132"/>One of the tools for such analysis is Wireshark. It allows us to capture network communication traffic and analyze it for security properties. I first configured it to collect all exchanged data between the test station and the STM32MP157F device. Afterward, I filtered for TLS packets. <a href="ch07.xhtml#ch07fig02">Figure 7-2</a> shows a snippet of the result.</p>
<div class="image"><img alt="Image" height="174" id="ch07fig02" src="../images/07fig02.jpg" width="935"/></div>
<p class="figcap"><em>Figure 7-2: The TLS messages exchanged during MQTT communication</em></p>
<p class="indent">You can see that a TLS handshake with its characteristic <code>ClientHello</code> and <code>ServerHello</code> messages took place. Afterward, encrypted <code>Application Data</code> packets were transmitted between client and broker.</p>
<p class="indent">As shown in <a href="ch07.xhtml#ch07fig03">Figure 7-3</a>, Wireshark also provides the details of the TLS negotiation—namely, that the cipher suite <code>TLS_AES_256_GCM_SHA384</code> was selected for bulk data transmissions. This, in turn, tells us that TLS 1.3 is used, because that specific cipher suite belongs to the most recent TLS version.</p>
<div class="image"><img alt="Image" height="378" id="ch07fig03" src="../images/07fig03.jpg" width="935"/></div>
<p class="figcap"><em>Figure 7-3: The details of the TLS handshake</em></p>
<div class="note">
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>
<p class="notep"><em>Be careful when analyzing the TLS version used in network traffic. The legacy</em> <span class="codeitalic">Version</span> <em>field says it’s</em> <span class="codeitalic">TLS 1.2</span><em>, but it’s not.</em></p>
</div>
<p class="indent">At this point, it seems that functionality and security measures work as expected. Let’s use one more tool to finalize our confidence in this work. The SSLyze Python application is able to test TLS servers of all kinds regarding a variety of pitfalls and misconfigurations that would lower your product’s security if they go unnoticed.</p>
<p class="indent">To start the TLS scan, simply enter the hostname and corresponding port: <span class="codestrong">sslyze mqtt.iot-device-corp.com:8883</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_133"/>The comprehensive results shed light on some interesting details. The extract shown in <a href="ch07.xhtml#ch07list06">Listing 7-6</a> deals with certificate verification.</p>
<pre class="pre">...&#13;
 Certificate #0 - Trust&#13;
<span class="ent">➊</span> Hostname Validation:         OK - Certificate matches server hostname&#13;
<span class="ent">➋</span> Android CA Store (...):      FAILED - Certificate is NOT Trusted ...&#13;
   Apple CA Store (...):       FAILED - Certificate is NOT Trusted ...&#13;
   Java CA Store (...):        FAILED - Certificate is NOT Trusted ...&#13;
   Mozilla CA Store (...):     FAILED - Certificate is NOT Trusted ...&#13;
   Windows CA Store (...):     FAILED - Certificate is NOT Trusted ...&#13;
...</pre>
<p class="list-title" id="ch07list06"><em>Listing 7-6: The</em> <span class="codeitalic1">sslyze</span> <em>console output regarding certificate verification</em></p>
<p class="indent">The good news is that I created the certificate correctly, which means that I included the correct server name of my device as the common name in the certificate <span class="ent">➊</span>. However, many <code>FAILED</code> entries <span class="ent">➋</span> also occur. This happens because my certificate is not part of the popular certificate stores from Android, Windows, Mozilla, and the like, which was never the plan, but if you aim for broad trust compatibility of your certificates, this test might be important for you.</p>
<p class="indent">The main part of the results is about the cipher suites and TLS versions that a server accepts. The results in <a href="ch07.xhtml#ch07list07">Listing 7-7</a> indicate that deprecated TLS versions and their corresponding cipher suites are all rejected by the implemented MQTT broker as intended. The default settings of <code>mosquitto</code> already seem to prohibit the use of these old protocols and ciphers.</p>
<pre class="pre">...&#13;
 * SSL 2.0 Cipher Suites:&#13;
     Attempted to connect using 7 cipher suites; the server rejected all ...&#13;
 * SSL 3.0 Cipher Suites:&#13;
     Attempted to connect using 80 cipher suites; the server rejected all ...&#13;
 * TLS 1.0 Cipher Suites:&#13;
     Attempted to connect using 80 cipher suites; the server rejected all ...&#13;
 * TLS 1.1 Cipher Suites:&#13;
     Attempted to connect using 80 cipher suites; the server rejected all ...&#13;
...</pre>
<p class="list-title" id="ch07list07"><em>Listing 7-7: The desired rejection of all deprecated cipher suites</em></p>
<p class="indent">As shown in <a href="ch07.xhtml#ch07list08">Listing 7-8</a>, the standard settings of <code>mosquitto</code> still support TLS 1.2, which is a good thing regarding backward compatibility, because many legacy devices in the field don’t support TLS 1.3, but the list of supported cipher suites as given by <code>sslyze</code> exhibits some weaknesses.</p>
<pre class="pre"><span epub:type="pagebreak" id="page_134"/>...&#13;
 * TLS 1.2 Cipher Suites:&#13;
     Attempted to connect using 156 cipher suites.&#13;
     &#13;
     The server accepted the following 20 cipher suites:&#13;
        TLS_RSA_WITH_AES_256_GCM_SHA384                256&#13;
        TLS_RSA_WITH_AES_256_CBC_SHA256                256&#13;
        TLS_RSA_WITH_AES_256_CBC_SHA                   256&#13;
        ...&#13;
        TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256    256  ECDH: X25519&#13;
        TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384          256  ECDH: prime256v1&#13;
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384          256  ECDH: prime256v1&#13;
        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA             256  ECDH: prime256v1&#13;
        ...&#13;
        TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256      256  DH (4096 bits) &#13;
        TLS_DHE_RSA_WITH_AES_256_GCM_SHA384            256  DH (4096 bits) &#13;
        TLS_DHE_RSA_WITH_AES_256_CBC_SHA256            256  DH (4096 bits) &#13;
        TLS_DHE_RSA_WITH_AES_256_CBC_SHA               256  DH (4096 bits) &#13;
        ...</pre>
<p class="list-title" id="ch07list08"><em>Listing 7-8: The offered TLS 1.2 ciphers</em></p>
<p class="indent">The output shows that the implementation at hand still offers options that allow for RSA-based key exchange (<code>TLS_RSA_WITH_...</code>) and others that still use the CBC operation mode for AES encryption of application data. Both are not supported by TLS 1.3 and are not recommended anymore.</p>
<p class="indent">This insight allows us to adjust the <em>mosquitto.conf</em> file again by specifying the parameter <code>ciphers</code>, as shown in <a href="ch07.xhtml#ch07list09">Listing 7-9</a>.</p>
<pre class="pre">ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:&#13;
        DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:&#13;
        ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-CHACHA20-POLY1305:&#13;
        ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:&#13;
        DHE-RSA-AES128-GCM-SHA256</pre>
<p class="list-title" id="ch07list09"><em>Listing 7-9: The restriction of TLS 1.2 ciphers in</em> mosquitto.conf</p>
<p class="indent">This restricts the TLS 1.2 ciphers of <code>mosquitto</code> to only six modern options for RSA-based authentication and three for ECDSA certificates, which means the security of the MQTT communication at hand is enhanced one step further.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Mosquitto relies on OpenSSL for secure TLS communication. Enter</em> <span class="codestrongitalic">openssl ciphers</span> <em>to list all ciphers offered by OpenSSL on a specific system.</em></p>
</div>
<p class="indent"><span epub:type="pagebreak" id="page_135"/>Regarding TLS 1.3, the recommended cipher suites are supported correctly, as shown in <a href="ch07.xhtml#ch07list010">Listing 7-10</a>.</p>
<pre class="pre">...&#13;
 * TLS 1.3 Cipher Suites:&#13;
     Attempted to connect using 5 cipher suites.&#13;
&#13;
     The server accepted the following 3 cipher suites:&#13;
        TLS_CHACHA20_POLY1305_SHA256                   256  ECDH: X25519&#13;
        TLS_AES_256_GCM_SHA384                         256  ECDH: X25519&#13;
        TLS_AES_128_GCM_SHA256                         128  ECDH: X25519</pre>
<p class="list-title" id="ch07list010"><em>Listing 7-10: TLS 1.3 support is available as intended</em></p>
<p class="indent">This is the base for future-proof device communication.</p>
<h3 class="h3" id="ch00lev1_60"><strong>Secure Communication Without TLS</strong></h3>
<p class="noindent">As mentioned multiple times in this chapter, TLS should be the default solution if your device needs to communicate securely. However, not all application scenarios and communication technologies allow TLS to be used.</p>
<p class="indent">For example, wireless communication for dedicated use cases like sensor or mesh networks might rely on proprietary protocols that don’t include a TCP/IP stack. Further, some wired bus architectures like the controller area network (CAN) bus specify their own message format and data structures without relying on TCP/IP technology, and they might require a certain real-time behavior that can’t be guaranteed with TLS. Also, very power-constrained devices like battery-powered remote control units for alarm systems, garage doors, and industrial cranes often use frequencies of 433 and 868 MHz within the license-free industrial, scientific, and medical (ISM) radio band, and they optimize message content and lengths for energy consumption, which renders a TLS handshake impossible.</p>
<p class="indent">However, it would be naive to conclude that these applications have to live without security measures because TLS doesn’t fit. The issue just requires a different development approach. For those cases, usually no out-of-the-box solution exists, but custom, application-specific security protocols have to be developed. Of course, having extensive experience in cryptography, protocol design, and verification of such systems would be useful, but, in reality, that’s rarely the case.</p>
<p class="indent">A pragmatic approach could be to regard TLS 1.3 and the cryptographic primitives it uses as a self-service store. If you’re looking for specific protection measures (for example, to protect authenticity and integrity of commands sent by your remote control), digital signatures based on RSA or ECDSA would be a reliable solution. Whether you decide to work with certificates, as TLS does, or manage the raw public keys yourself depends on your requirements and possibilities.</p>
<p class="indent"><span epub:type="pagebreak" id="page_136"/>Also, if your CAN bus traffic contains confidential messages, and integrity is also on your wish list, AES-GCM or ChaCha20-Poly1305 might be suitable candidates. If your scenario allows for management and distribution of pre-shared secrets, you can spare the costly key-exchange algorithms. If not, DHE or ECDHE, as used by TLS 1.3, might be the algorithms of your choice.</p>
<p class="indent">This sounds rather shallow and, to some extent it is, because you have to clarify hundreds of details on the way to your specific implementation. However, this information gives you some guidance as to where your journey needs to go.</p>
<h3 class="h3" id="ch00lev1_61"><strong>Redundancy in Secure Communication</strong></h3>
<p class="noindent">If you’ve made it to this point, you’ve read a lot about how secure communication can be achieved by using TLS and its magical crypto features to protect confidentiality and integrity of messages as well as authenticity of communication partners. However, at the beginning of this chapter, I said that communication demands all the protection goals, including availability. But to be clear: TLS and cryptography in general are <em>not able to protect availability</em>.</p>
<p class="indent">Of course, in some use cases, the availability of transmitted data is essential—for example, in domains where technical safety measures protect humans from accidents and injuries, but also in systems where downtime leads to significant financial losses, as in production or transportation. In those applications, if a message is lost, the correct functionality of a device or a whole system is at risk. These threats have to be handled by <em>logical or physical redundancy</em>.</p>
<p class="indent">Approaching this problem on a logical level means sending messages multiple times or adding redundancy data generated by error-detecting codes like CRC checksums or error-correcting algorithms like Hamming codes. This is useful for transmissions over noisy or unreliable channels and to handle disturbance events originating, for example, from electromagnetic interference or cosmic radiation. However, these measures don’t offer adequate protection against deliberate destruction and continuous interruption of a physical communication line.</p>
<p class="indent">The only way to be resilient in such situations is to implement multiple physical communication channels. A common example is a <em>ring topology</em>, used in many industrial infrastructures to connect devices to one another in a ring-like structure. However, that configuration requires devices to have two network interfaces, left and right, and messages always have to be sent in both directions and can be received on two different interfaces.</p>
<p class="indent">This leads to engineering and component efforts on each device, and the system installation as a whole becomes more expensive. In addition, the communication delay depends on the number of devices in the ring, and the bandwidth has to be shared among all network participants. However, this physical redundancy is robust against corrupted messages, broken or cut <span epub:type="pagebreak" id="page_137"/>cables, and even device replacement during system operation. The international standard IEC 62439 describes several ways to achieve high availability in industrial networks, for example, based on a ring or a mesh topology.</p>
<h3 class="h3" id="ch00lev1_62"><strong>Summary</strong></h3>
<p class="noindent">The IoT and its industrial counterpart are not possible without secure communication. A variety of protection goals from confidentiality to integrity to authenticity, and even availability, are demanded for modern communication channels. Besides the necessary cryptographic capabilities, devices need to support state-of-the-art protocols like TLS 1.3 to achieve a high security level. In some use cases, where the loss of messages is critical and redundant physical communication media are required, devices even have to provide multiple communication interfaces.</p>
<p class="indent">This chapter’s case study showed an example implementation of a MQTT-broker with TLS-based communication and the necessary configuration parameters. It showed that thorough security analysis of the final result can help spot misconfigurations and weak cipher suites offered by a service.</p>
<p class="indent">Although TLS is one of the most common and most popular security protocols, many others exist that are meant for dedicated applications. For example, Internet Protocol security (IPsec) can be used to establish a virtual private network (VPN) on OSI layer 3, while the SSH protocol enables remote access to devices for administrators. On OSI layer 2, the idea of Time-Sensitive Networking (TSN) takes care of communication channel separation on a shared physical medium, while IEEE 802.1AE (also known as <em>MACsec</em>) aims for protected communication.</p>
<p class="indent">And even if you don’t find any protocol that directly suits your needs, the conglomeration of modern security protocols can definitely serve as inspiration for solving your specific challenges.<span epub:type="pagebreak" id="page_138"/></p>
</div></body></html>