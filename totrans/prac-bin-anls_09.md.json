["```\n   #include  <stdio.h>\n   #include  <stdlib.h>\n   #include  <string.h>\n   #include  <stdarg.h>\n\n   void\n   die(char const *fmt, ...)\n   {\n     va_list args;\n\n     va_start(args, fmt);\n     vfprintf(stderr, fmt, args);\n     va_end(args);\n\n     exit(1);\n   }\n\n   int\n   main(int argc, char *argv[])\n   {\n     FILE *f;\n     char *infile, *outfile;\n     unsigned char *key, *buf;\n     size_t i, j, n;\n\n     if(argc != 4)\n       die(\"Usage: %s <in file> <out file> <key>\\n\", argv[0]);\n\n     infile  = argv[1];\n     outfile = argv[2];\n     key     = (unsigned char*)argv[3];\n\n➊   f = fopen(infile, \"rb\");\n     if(!f) die(\"Failed to open file '%s'\\n\", infile);\n\n➋   fseek(f, 0, SEEK_END);\n     n = ftell(f);\n     fseek(f, 0, SEEK_SET);\n\n➌   buf = malloc(n);\n     if(!buf) die(\"Out of memory\\n\");\n\n➍   if(fread(buf, 1, n, f) != n)\n       die(\"Failed to read file '%s'\\n\", infile);\n\n➎   fclose(f); j = 0;\n➏   for(i = 0; i < n-1; i++) { /* Oops! An off-by-one error! */\n       buf[i] ^= key[j];\n       j = (j+1) % strlen(key);\n     }\n\n➐   f = fopen(outfile, \"wb\");\n    if(!f) die(\"Failed to open file '%s'\\n\", outfile);\n\n➑   if(fwrite(buf, 1, n, f) != n)\n       die(\"Failed to write file '%s'\\n\", outfile);\n\n➒   fclose(f);\n\n     return 0;\n  }\n```", "```\n➊  $ ./xor_encrypt xor_encrypt.c encrypted foobar\n➋  $ xxd xor_encrypt.c | tail\n   000003c0: 6420 746f 206f 7065 6e20 6669 6c65 2027  d to open file '\n   000003d0: 2573 275c 6e22 2c20 6f75 7466 696c 6529  %s'\\n\", outfile)\n   000003e0: 3b0a 0a20 2069 6628 6677 7269 7465 2862  ;.. if(fwrite(b\n   000003f0: 7566 2c20 312c 206e 2c20 6629 2021 3d20  uf, 1, n, f) !=\n   00000400: 6e29 0a20 2020 2064 6965 2822 4661 696c  n).    die(\"Fail\n 00000410: 6564 2074 6f20 7772 6974 6520 6669 6c65  ed to write file\n   00000420: 2027 2573 275c 6e22 2c20 6f75 7466 696c  '%s'\\n\", outfil\n   00000430: 6529 3b0a 0a20 2066 636c 6f73 6528 6629  e);.. fclose(f)\n   00000440: 3b0a 0a20 2072 6574 7572 6e20 303b 0a7d  ;..   return 0;.}\n   00000450: 0a➌0a                             ..\n➍  $ xxd encrypted | tail\n   000003c0: 024f 1b0d 411d 160a 0142 071b 0a0a 4f45  .O..A....B....OE\n   000003d0: 4401 4133 0140 4d52 091a 1b04 081e 0346  D.A3.@MR.......F\n   000003e0: 5468 6b52 4606 094a 0705 1406 1b07 4910  ThkRF..J......I.\n   000003f0: 1309 4342 505e 4601 4342 075b 464e 5242  ..CBP![image](Images/page_159_inline.jpg).CB.[FNRB\n   00000400: 0f5b 6c4f 4f42 4116 0f0a 4740 2713 0f03  .[lOOBA...G@'...\n   00000410: 0a06 4106 094f 1810 0806 034f 090b 0d17  ..A..O.....O....\n   00000420: 4648 4a11 462e 084d 4342 0e07 1209 060e  FHJ.F..MCB......\n   00000430: 045b 5d65 6542 4114 0503 0011 045a 0046  .[]eeBA......Z.F\n   00000440: 5468 6b52 461d 0a16 1400 084f 5f59 6b0f  ThkRF......O_Yk.\n   00000450: 6c➎0a                                    l.\n```", "```\n  $ objdump -M intel -d xor_encrypt\n  ...\n  4007c2:  49 8d 45 ff             lea         rax,[r13-0x1]\n  4007c6:  31 d2                   xor         edx,edx\n  4007c8:  48 85 c0                test        rax,rax\n  4007cb:  4d 8d 24 06             lea         r12,[r14+rax*1]\n  4007cf:  74 2e                   je          4007ff <main+0xdf>\n  4007d1:  0f 1f 80 00 00 00 00    nop         DWORD PTR [rax+0x0]\n➊ 4007d8: 41 0f b6 04 17           movzx       eax,BYTE PTR [r15+rdx*1]\n  4007dd:  48 8d 6a 01             lea         rbp,[rdx+0x1]\n  4007e1:  4c 89 ff                mov         rdi,r15\n  4007e4:  30 03                   xor         BYTE PTR [rbx],al\n  4007e6:  48 83 c3 01            ➋add         rbx,0x1\n  4007ea:  e8 a1 fe ff ff          call        400690 <strlen@plt>\n  4007ef:  31 d2                   xor         edx,edx\n  4007f1:  48 89 c1                mov         rcx,rax\n  4007f4:  48 89 e8                mov         rax,rbp\n  4007f7:  48 f7 f1                div         rcx\n  4007fa:  49 39 dc               ➌cmp         r12,rbx\n  4007fd:  75 d9                  ➍jne         4007d8 <main+0xb8>\n  4007ff:  48 8b 7c 24 08          mov         rdi,QWORD PTR [rsp+0x8]\n  400804:  be 66 0b 40 00          mov         esi,0x400b66\n...\n```", "```\n$ objdump -M intel -d xor_encrypt.fixed\n...\n4007c2:  49 8d 45 ff              lea         rax,[r13-0x1]\n4007c6:  31 d2                    xor         edx,edx\n4007c8:  48 85 c0                 test        rax,rax\n4007cb:  4d 8d 24 06              lea         r12,[r14+rax*1]\n4007cf:  74 2e                    je          4007ff <main+0xdf>\n4007d1:  0f 1f 80 00 00 00 00     nop         DWORD PTR [rax+0x0]\n4007d8:  41 0f b6 04 17           movzx       eax,BYTE PTR [r15+rdx*1]\n4007dd:  48 8d 6a 01              lea         rbp,[rdx+0x1]\n4007e1:  4c 89 ff                 mov         rdi,r15\n4007e4:  30 03                    xor         BYTE PTR [rbx],al\n4007e6:  48 83 c3 01              add         rbx,0x1\n4007ea:  e8 a1 fe ff ff           call        400690 <strlen@plt>\n4007ef:  31 d2                    xor         edx,edx\n4007f1:  48 89 c1                 mov         rcx,rax\n4007f4:  48 89 e8                 mov         rax,rbp\n4007f7:  48 f7 f1                 div         rcx\n4007fa:  49 39 dc                 cmp         r12,rbx\n4007fd:  73 d9                   ➊jae         4007d8 <main+0xb8>\n4007ff:  48 8b 7c 24 08           mov         rdi,QWORD PTR [rsp+0x8]\n400804:  be 66 0b 40 00           mov         esi,0x400b66\n...\n```", "```\n➊ $ ./xor_encrypt xor_encrypt.c encrypted foobar\n➋ $ xxd encrypted | tail\n  000003c0: 024f 1b0d 411d 160a 0142 071b 0a0a 4f45 .O..A....B....OE\n  000003d0: 4401 4133 0140 4d52 091a 1b04 081e 0346 D.A3.@MR.......F\n  000003e0: 5468 6b52 4606 094a 0705 1406 1b07 4910 ThkRF..J......I.\n  000003f0: 1309 4342 505e 4601 4342 075b 464e 5242 ..CBP.CB.[FNRB\n  00000400: 0f5b 6c4f 4f42 4116 0f0a 4740 2713 0f03 .[lOOBA...G@'...\n  00000410: 0a06 4106 094f 1810 0806 034f 090b 0d17 ..A..O.....O....\n  00000420: 4648 4a11 462e 084d 4342 0e07 1209 060e FHJ.F..MCB......\n  00000430: 045b 5d65 6542 4114 0503 0011 045a 0046 .[]eeBA......Z.F\n  00000440: 5468 6b52 461d 0a16 1400 084f 5f59 6b0f ThkRF......O_Yk.\n  00000450: 6c➌65                                   le\n```", "```\n  #include <stdio.h>\n  #include <stdlib.h>\n  #include <string.h>\n\n  int\n  main(int argc, char *argv[])\n  {\n    char *buf;\n    unsigned long len;\n\n    if(argc != 3) {\n      printf(\"Usage: %s <len> <string>\\n\", argv[0]);\n      return 1;\n    }\n\n➊   len = strtoul(argv[1], NULL, 0);\n    printf(\"Allocating %lu bytes\\n\", len);\n\n➋   buf = malloc(len);\n\n     if(buf && len > 0) {\n       memset(buf, 0, len);\n\n➌     strcpy(buf, argv[2]);\n       printf(\"%s\\n\", buf);\n\n➍     free(buf);\n    }\n\n    return 0;\n  }\n```", "```\n$ ./heapoverflow 13 'Hello world!'\nAllocating 13 bytes\nHello world!\n```", "```\n➊ $ ./heapoverflow 13 `perl -e 'print \"A\"x100'`\n➋ Allocating 13 bytes\n➌ AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...\n➍ *** Error in `./heapoverflow': free(): invalid next size (fast): 0x0000000000a10420 ***\n  ======= Backtrace: =========\n  /lib/x86_64-linux-gnu/libc.so.6(+0x777e5)[0x7f19129587e5]\n  /lib/x86_64-linux-gnu/libc.so.6(+0x8037a)[0x7f191296137a]\n  /lib/x86_64-linux-gnu/libc.so.6(cfree+0x4c)[0x7f191296553c] ./heapoverflow[0x40063e]\n  /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f1912901830]\n  ./heapoverflow[0x400679]\n  ======= Memory map: ========\n  00400000-00401000 r-xp 00000000 fc:03 37226406          /home/binary/code/chapter7/heapoverflow\n  00600000-00601000 r--p 00000000 fc:03 37226406          /home/binary/code/chapter7/heapoverflow\n  00601000-00602000 rw-p 00001000 fc:03 37226406          /home/binary/code/chapter7/heapoverflow\n  00a10000-00a31000 rw-p 00000000 00:00 0                 [heap]\n  7f190c000000-7f190c021000 rw-p 00000000 00:00 0\n  7f190c021000-7f1910000000 ---p 00000000 00:00 0\n  7f19126cb000-7f19126e1000 r-xp 00000000 fc:01 2101767   /lib/x86_64-linux-gnu/libgcc_s.so.1\n  7f19126e1000-7f19128e0000 ---p 00016000 fc:01 2101767   /lib/x86_64-linux-gnu/libgcc_s.so.1\n  7f19128e0000-7f19128e1000 rw-p 00015000 fc:01 2101767   /lib/x86_64-linux-gnu/libgcc_s.so.1\n  7f19128e1000-7f1912aa1000 r-xp 00000000 fc:01 2097475   /lib/x86_64-linux-gnu/libc-2.23.so\n  7f1912aa1000-7f1912ca1000 ---p 001c0000 fc:01 2097475   /lib/x86_64-linux-gnu/libc-2.23.so\n  7f1912ca1000-7f1912ca5000 r--p 001c0000 fc:01 2097475   /lib/x86_64-linux-gnu/libc-2.23.so\n  7f1912ca5000-7f1912ca7000 rw-p 001c4000 fc:01 2097475   /lib/x86_64-linux-gnu/libc-2.23.so\n  7f1912ca7000-7f1912cab000 rw-p 00000000 00:00 0\n  7f1912cab000-7f1912cd1000 r-xp 00000000 fc:01 2097343   /lib/x86_64-linux-gnu/ld-2.23.so\n  7f1912ea5000-7f1912ea8000 rw-p 00000000 00:00 0\n  7f1912ecd000-7f1912ed0000 rw-p 00000000 00:00 0\n  7f1912ed0000-7f1912ed1000 r--p 00025000 fc:01 2097343   /lib/x86_64-linux-gnu/ld-2.23.so\n  7f1912ed1000-7f1912ed2000 rw-p 00026000 fc:01 2097343   /lib/x86_64-linux-gnu/ld-2.23.so\n  7f1912ed2000-7f1912ed3000 rw-p 00000000 00:00 0\n  7ffe66fbb000-7ffe66fdc000 rw-p 00000000 00:00 0         [stack]\n  7ffe66ff3000-7ffe66ff5000 r--p 00000000 00:00 0         [vvar]\n  7ffe66ff5000-7ffe66ff7000 r-xp 00000000 00:00 0         [vdso]\n  ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall]\n➎ Aborted (core dumped)\n```", "```\n   #include  <stdio.h>\n   #include  <stdlib.h>\n   #include  <string.h>\n   #include  <stdint.h>\n➊ #include  <dlfcn.h>\n\n➋ void* (*orig_malloc)(size_t);\n   void (*orig_free)(void*);\n   char* (*orig_strcpy)(char*, const char*);\n\n➌ typedef struct {\n      uintptr_t addr;\n      size_t    size;\n    } alloc_t;\n\n    #define MAX_ALLOCS 1024\n\n➍ alloc_t allocs[MAX_ALLOCS];\n   unsigned alloc_idx = 0;\n\n➎ void*\n   malloc(size_t s)\n   {\n➏   if(!orig_malloc) orig_malloc = dlsym(RTLD_NEXT, \"malloc\");\n\n➐  void *ptr = orig_malloc(s);\n    if(ptr) {\n      allocs[alloc_idx].addr = (uintptr_t)ptr;\n      allocs[alloc_idx].size = s;\n      alloc_idx = (alloc_idx+1) % MAX_ALLOCS;\n    }\n\n    return ptr;\n   }\n\n➑ void\n   free(void *p)\n   {\n     if(!orig_free) orig_free = dlsym(RTLD_NEXT, \"free\");\n\n     orig_free(p);\n     for(unsigned i = 0; i < MAX_ALLOCS; i++) {\n       if(allocs[i].addr == (uintptr_t)p) {\n         allocs[i].addr = 0;\n         allocs[i].size = 0;\n         break;\n       }\n     }\n   }\n\n➒ char*\n   strcpy(char *dst, const char *src)\n   {\n     if(!orig_strcpy) orig_strcpy = dlsym(RTLD_NEXT, \"strcpy\");\n\n     for(unsigned i = 0; i < MAX_ALLOCS; i++) {\n       if(allocs[i].addr == (uintptr_t)dst) {\n➓       if(allocs[i].size <= strlen(src)) {\n           printf(\"Bad idea! Aborting strcpy to prevent heap overflow\\n\");\n           exit(1);\n          }\n          break;\n        }\n      }\n\n      return orig_strcpy(dst, src);\n   }\n```", "```\n   $ ➊LD_PRELOAD=`pwd`/heapcheck.so ./heapoverflow 13 `perl -e 'print \"A\"x100'`\n   Allocating 13 bytes\n➋ Bad idea! Aborting strcpy to prevent heap overflow\n```", "```\n➊ $ ls hello.bin\n   hello.bin\n➋ $ ./elfinject\n   Usage: ./elfinject <elf> <inject> <name> <addr> <entry>\n\n   Inject the file <inject> into the given <elf>, using\n   the given <name> and base <addr>. You can optionally specify\n   an offset to a new <entry> point (-1 if none)\n➌ $ cp /bin/ls .\n➍ $ ./ls\n\n elfinject elfinject.c hello.s     hello.bin   ls   Makefile\n   $ readelf --wide --headers ls\n   ...\n\n   Section Headers:\n     [Nr] Name              Type            Address          Off    Size   ES  Flg Lk Inf Al\n     [ 0]                   NULL            0000000000000000 000000 000000 00       0   0  0\n     [ 1] .interp           PROGBITS        0000000000400238 000238 00001c 00    A  0   0  1\n     [ 2] ➎.note.ABI-tag     NOTE           0000000000400254 000254 000020 00    A  0   0  4\n     [ 3] .note.gnu.build-id NOTE           0000000000400274 000274 000024 00    A  0   0  4\n     [ 4] .gnu.hash         GNU_HASH        0000000000400298 000298 0000c0 00    A  5   0  8\n     [ 5] .dynsym           DYNSYM          0000000000400358 000358 000cd8 18    A  6   1  8\n     [ 6] .dynstr           STRTAB          0000000000401030 001030 0005dc 00    A  0   0  1\n     [ 7] .gnu.version      VERSYM          000000000040160c 00160c 000112 02    A  5   0  2\n     [ 8] .gnu.version_r    VERNEED         0000000000401720 001720 000070 00    A  6   1  8\n     [ 9] .rela.dyn         RELA            0000000000401790 001790 0000a8 18    A  5   0  8\n     [10] .rela.plt         RELA            0000000000401838 001838 000a80 18   AI  5  24  8\n     [11] .init             PROGBITS        00000000004022b8 0022b8 00001a 00   AX  0   0  4\n     [12] .plt              PROGBITS        00000000004022e0 0022e0 000710 10   AX  0   0 16\n     [13] .plt.got          PROGBITS        00000000004029f0 0029f0 000008 00   AX  0   0  8\n     [14] .text             PROGBITS        0000000000402a00 002a00 011259 00   AX  0   0 16\n     [15] .fini             PROGBITS        0000000000413c5c 013c5c 000009 00   AX  0   0  4\n     [16] .rodata           PROGBITS        0000000000413c80 013c80 006974 00    A  0   0 32\n     [17] .eh_frame_hdr     PROGBITS        000000000041a5f4 01a5f4 000804 00    A  0   0  4\n     [18] .eh_frame         PROGBITS        000000000041adf8 01adf8 002c6c 00    A  0   0  8\n     [19] .init_array       INIT_ARRAY      000000000061de00 01de00 000008 00   WA  0   0  8\n     [20] .fini_array       FINI_ARRAY      000000000061de08 01de08 000008 00   WA  0   0  8\n     [21] .jcr              PROGBITS        000000000061de10 01de10 000008 00   WA  0   0  8\n     [22] .dynamic          DYNAMIC         000000000061de18 01de18 0001e0 10   WA  6   0  8\n     [23] .got              PROGBITS        000000000061dff8 01dff8 000008 08   WA  0   0  8\n     [24] .got.plt          PROGBITS        000000000061e000 01e000 000398 08   WA  0   0  8\n     [25] .data             PROGBITS        000000000061e3a0 01e3a0 000260 00   WA  0   0 32\n     [26] .bss              NOBITS          000000000061e600 01e600 000d68 00   WA  0   0 32\n     [27] .gnu_debuglink    PROGBITS        0000000000000000 01e600 000034 00       0   0  1\n     [28] .shstrtab         STRTAB          0000000000000000 01e634 000102 00       0   0  1\n   Key to Flags:\n     W (write), A (alloc), X (execute), M (merge), S (strings), l (large)\n     I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n     O (extra OS processing required) o (OS specific), p (processor specific)\n\n   Program Headers:\n     Type           Offset     VirtAddr             PhysAddr             FileSiz    MemSiz   Flg Align\n     PHDR           0x000040   0x0000000000400040   0x0000000000400040   0x0001f8   0x0001f8 R E 0x8\n     INTERP         0x000238   0x0000000000400238   0x0000000000400238   0x00001c   0x00001c R   0x1\n         [Requesting program   interpreter: /lib64/ld-linux-x86-64.so.2]\n     LOAD           0x000000   0x0000000000400000   0x0000000000400000   0x01da64   0x01da64 R E 0x200000\n     LOAD           0x01de00   0x000000000061de00   0x000000000061de00   0x000800   0x001568 RW  0x200000\n DYNAMIC        0x01de18   0x000000000061de18   0x000000000061de18   0x0001e0   0x0001e0 RW  0x8\n➏   NOTE           0x000254   0x0000000000400254   0x0000000000400254   0x000044   0x000044  R   0x4\n     GNU_EH_FRAME   0x01a5f4   0x000000000041a5f4   0x000000000041a5f4   0x000804   0x000804  R   0x4\n     GNU_STACK      0x000000   0x0000000000000000   0x0000000000000000   0x000000   0x000000  RW  0x10\n     GNU_RELRO      0x01de00   0x000000000061de00   0x000000000061de00   0x000200   0x000200  R   0x1\n\n   Section to Segment mapping:\n    Segment Sections...\n      00\n      01    .interp\n      02    .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version\n            .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got .text .fini .rodata\n             .eh_frame_hdr .eh_frame\n      03    .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss\n      04    .dynamic\n      05    .note.ABI-tag .note.gnu.build-id\n      06    .eh_frame_hdr\n      07\n      08    .init_array .fini_array .jcr .dynamic .got\n➐  $ ./elfinject ls hello.bin \".injected\" 0x800000 0\n    $ readelf --wide --headers ls\n    ...\n\n    Section Headers:\n      [Nr] Name              Type             Address          Off    Size   ES Flg Lk Inf Al\n      [ 0]                   NULL             0000000000000000 000000 000000 00      0   0   0\n      [ 1] .interp           PROGBITS         0000000000400238 000238 00001c 00   A  0   0   1\n      [ 2] .init             PROGBITS         00000000004022b8 0022b8 00001a 00  AX  0   0   4\n      [ 3] .note.gnu.build-id NOTE             0000000000400274 000274 000024 00   A  0   0   4\n      [ 4] .gnu.hash         GNU_HASH         0000000000400298 000298 0000c0 00   A  5   0   8\n      [ 5] .dynsym           DYNSYM           0000000000400358 000358 000cd8 18   A  6   1   8\n      [ 6] .dynstr           STRTAB           0000000000401030 001030 0005dc 00   A  0   0   1\n      [ 7] .gnu.version      VERSYM           000000000040160c 00160c 000112 02   A  5   0   2\n      [ 8] .gnu.version_r    VERNEED          0000000000401720 001720 000070 00   A  6   1   8\n      [ 9] .rela.dyn         RELA             0000000000401790 001790 0000a8 18   A  5   0   8\n      [10] .rela.plt         RELA             0000000000401838 001838 000a80 18  AI  5  24   8\n      [11] .plt              PROGBITS         00000000004022e0 0022e0 000710 10  AX  0   0   16\n      [12] .plt.got          PROGBITS         00000000004029f0 0029f0 000008 00  AX  0   0   8\n      [13] .text             PROGBITS         0000000000402a00 002a00 011259 00  AX  0   0   16\n      [14] .fini             PROGBITS         0000000000413c5c 013c5c 000009 00  AX  0   0   4\n      [15] .rodata           PROGBITS         0000000000413c80 013c80 006974 00   A  0   0   32\n      [16] .eh_frame_hdr     PROGBITS         000000000041a5f4 01a5f4 000804 00   A  0   0   4\n      [17] .eh_frame         PROGBITS         000000000041adf8 01adf8 002c6c 00   A  0   0   8\n      [18] .jcr              PROGBITS         000000000061de10 01de10 000008 00  WA  0   0   8\n      [19] .init_array       INIT_ARRAY       000000000061de00 01de00 000008 00  WA  0   0   8\n      [20] .fini_array       FINI_ARRAY       000000000061de08 01de08 000008 00  WA  0   0   8\n      [21] .got              PROGBITS         000000000061dff8 01dff8 000008 08  WA  0   0   8\n [22] .dynamic          DYNAMIC          000000000061de18 01de18 0001e0 10  WA  6   0   8\n      [23] .got.plt          PROGBITS         000000000061e000 01e000 000398 08  WA  0   0   8\n      [24] .data             PROGBITS         000000000061e3a0 01e3a0 000260 00  WA  0   0  32\n      [25] .gnu_debuglink    PROGBITS         0000000000000000 01e600 000034 00      0   0   1\n      [26] .bss              NOBITS           000000000061e600 01e600 000d68 00  WA  0   0  32\n      [27] ➑.injected        PROGBITS         0000000000800e78 01f000 00003f 00  AX  0   0  16\n      [28] .shstrtab         STRTAB           0000000000000000 01e634 000102 00      0   0   1\n   Key to Flags:\n     W (write), A (alloc), X (execute), M (merge), S (strings), l (large)\n     I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n     O (extra OS processing required) o (OS specific), p (processor specific)\n\n   Program Headers:\n   Type           Offset      VirtAddr           PhysAddr           FileSiz    MemSiz     Flg   Align\n   PHDR           0x000040    0x0000000000400040 0x0000000000400040 0x0001f8   0x0001f8   R E   0x8\n   INTERP         0x000238    0x0000000000400238 0x0000000000400238 0x00001c   0x00001c   R     0x1\n       [Requesting program    interpreter: /lib64/ld-linux-x86-64.so.2]\n   LOAD           0x000000    0x0000000000400000 0x0000000000400000 0x01da64   0x01da64   R E   0x200000\n   LOAD           0x01de00    0x000000000061de00 0x000000000061de00 0x000800   0x001568   RW    0x200000\n   DYNAMIC        0x01de18    0x000000000061de18 0x000000000061de18 0x0001e0   0x0001e0   RW    0x8\n➒ LOAD            0x01ee78   0x0000000000800e78 0x0000000000800e78 0x00003f   0x00003f   R E   0x1000\n   GNU_EH_FRAME   0x01a5f4    0x000000000041a5f4 0x000000000041a5f4 0x000804   0x000804   R     0x4\n   GNU_STACK      0x000000    0x0000000000000000 0x0000000000000000 0x000000   0x000000   RW    0x10\n   GNU_RELRO      0x01de00    0x000000000061de00 0x000000000061de00 0x000200   0x000200   R     0x1\n\n   Section to Segment mapping:\n    Segment Sections...\n     00\n     01     .interp\n     02     .interp .init .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version\n            .gnu.version_r .rela.dyn .rela.plt .plt .plt.got .text .fini .rodata\n            .eh_frame_hdr .eh_frame\n     03     .jcr .init_array .fini_array .got .dynamic .got.plt .data .bss\n     04     .dynamic\n     05     .injected\n     06     .eh_frame_hdr\n     07\n     08     .jcr .init_array .fini_array .got .dynamic\n➓  $ ./ls\n   hello world!\n   elfinject elfinject.c hello.s hello.bin ls Makefile\n```", "```\n➊ BITS 64\n\n  SECTION .text\n  global main\n\n  main:\n➋   push   rax                 ; save all clobbered registers\n     push   rcx                ; (rcx and r11 destroyed by kernel)\n     push   rdx\n     push   rsi\n     push   rdi\n     push   r11\n\n➌    mov rax,1                 ;   sys_write\n     mov rdi,1                 ;   stdout\n     lea rsi,[rel $+hello-$]   ;   hello\n     mov rdx,[rel $+len-$]     ;   len\n➍   syscall\n\n➎   pop   r11\n     pop   rdi\n     pop   rsi\n     pop   rdx\n     pop   rcx\n     pop   rax\n\n➏    push 0x4049a0             ; jump to original entry point\n     ret\n\n➐ hello: db \"hello world\",33,10\n➑ len  : dd 13\n```", "```\n$ nasm -f bin -o hello.bin hello.s\n```", "```\n➊ $ cp /bin/ls ls.entry\n➋ $ ./elfinject ls.entry hello.bin \".injected\" 0x800000 -1\n   $ readelf -h ./ls.entry\n   ELF Header:\n     Magic:    7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n     Class:                              ELF64\n     Data:                               2's complement, little endian\n     Version:                            1 (current)\n     OS/ABI:                             UNIX - System V\n     ABI Version:                        0\n     Type:                               EXEC (Executable file)\n     Machine:                            Advanced Micro Devices X86-64\n     Version:                            0x1\n     Entry point address:                ➌0x4049a0\n     Start of program headers:           64 (bytes into file)\n     Start of section headers:           124728 (bytes into file)\n     Flags:                              0x0\n     Size of this header:                64 (bytes)\n     Size of program headers:            56 (bytes)\n     Number of program headers:          9\n     Size of section headers:            64 (bytes)\n     Number of section headers:          29\n     Section header string table index:  28\n   $ readelf --wide -S code/chapter7/ls.entry\n   There are 29 section headers, starting at offset 0x1e738:\n\n   Section Headers:\n     [Nr] Name               Type            Address          Off   Size ES Flg Lk Inf Al\n     ...\n     [27] .injected          PROGBITS        ➍0000000000800e78 01ee78 00003f 00 AX 0 0 16\n     ...\n➎ $ ./ls.entry\n   elfinject elfinject.c hello.s hello.bin ls Makefile\n➏ $ hexedit ./ls.entry\n   $ readelf -h ./ls.entry\n   ELF Header:\n     Magic:    7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n     Class:                              ELF64\n     Data:                               2's complement, little endian\n     Version:                            1 (current)\n     OS/ABI:                             UNIX - System V\n     ABI Version:                        0\n     Type:                               EXEC (Executable file)\n     Machine:                            Advanced Micro Devices X86-64\n     Version:                            0x1\n     Entry point address:                ➐0x800e78\n     Start of program headers:           64 (bytes into file)\n     Start of section headers:           124728 (bytes into file)\n     Flags:                              0x0\n     Size of this header:                64 (bytes)\n     Size of program headers:            56 (bytes)\n     Number of program headers:          9\n     Size of section headers:            64 (bytes)\n     Number of section headers:          29\n     Section header string table index:  28\n➑ $ ./ls.entry\n   hello world!\n   elfinject elfinject.c hello.s hello.bin ls Makefile\n```", "```\n   BITS 64\n\n   SECTION .text\n   global main\n\n   main:\n     push   rax                 ; save all clobbered registers\n     push   rcx                 ; (rcx and r11 destroyed by kernel)\n     push   rdx\n     push   rsi\n     push   rdi\n     push   r11\n\n     mov rax,1                  ; sys_write\n     mov rdi,1                  ; stdout\n     lea rsi,[rel $+hello-$]    ; hello\n     mov rdx,[rel $+len-$]      ; len\n     syscall\n\n     pop   r11\n     pop   rdi\n     pop   rsi\n     pop   rdx\n     pop   rcx\n     pop   rax\n\n➊  push 0x404a70               ; jump to original constructor\n    ret\n\n   hello: db \"hello world\",33,10\n   len : dd 13\n```", "```\n➊   $ cp /bin/ls ls.ctor\n➋   $ ./elfinject ls.ctor hello-ctor.bin \".injected\" 0x800000 -1\n    $ readelf --wide -S ls.ctor\n    There are 29 section headers, starting at offset 0x1e738:\n Section Headers:\n    [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n    [ 0]                   NULL            0000000000000000 000000 000000 00     0   0   0\n    [ 1] .interp           PROGBITS        0000000000400238 000238 00001c 00   A 0   0   1\n    [ 2] .init             PROGBITS        00000000004022b8 0022b8 00001a 00  AX 0   0   4\n    [ 3] .note.gnu.build-id NOTE           0000000000400274 000274 000024 00   A 0   0   4\n    [ 4] .gnu.hash         GNU_HASH        0000000000400298 000298 0000c0 00   A 5   0   8\n    [ 5] .dynsym           DYNSYM          0000000000400358 000358 000cd8 18   A 6   1   8\n    [ 6] .dynstr           STRTAB          0000000000401030 001030 0005dc 00   A 0   0   1\n    [ 7] .gnu.version      VERSYM          000000000040160c 00160c 000112 02   A 5   0   2\n    [ 8] .gnu.version_r    VERNEED         0000000000401720 001720 000070 00   A 6   1   8\n    [ 9] .rela.dyn         RELA            0000000000401790 001790 0000a8 18   A 5   0   8\n    [10] .rela.plt         RELA            0000000000401838 001838 000a80 18  AI 5  24   8\n    [11] .plt              PROGBITS        00000000004022e0 0022e0 000710 10  AX 0   0   16\n    [12] .plt.got          PROGBITS        00000000004029f0 0029f0 000008 00  AX 0   0   8\n    [13] .text             PROGBITS        0000000000402a00 002a00 011259 00  AX 0   0   16\n    [14] .fini             PROGBITS        0000000000413c5c 013c5c 000009 00  AX 0   0   4\n    [15] .rodata           PROGBITS        0000000000413c80 013c80 006974 00   A 0   0   32\n    [16] .eh_frame_hdr     PROGBITS        000000000041a5f4 01a5f4 000804 00   A 0   0   4\n    [17] .eh_frame         PROGBITS        000000000041adf8 01adf8 002c6c 00   A 0   0   8\n    [18] .jcr              PROGBITS        000000000061de10 01de10 000008 00  WA 0   0   8\n➌   [19] .init_array       INIT_ARRAY      000000000061de00 01de00 000008 00  WA 0   0   8\n    [20] .fini_array       FINI_ARRAY      000000000061de08 01de08 000008 00  WA 0   0   8\n    [21] .got              PROGBITS        000000000061dff8 01dff8 000008 08  WA 0   0   8\n    [22] .dynamic          DYNAMIC         000000000061de18 01de18 0001e0 10  WA 6   0   8\n    [23] .got.plt          PROGBITS        000000000061e000 01e000 000398 08  WA 0   0   8\n    [24] .data             PROGBITS        000000000061e3a0 01e3a0 000260 00  WA 0   0   32\n    [25] .gnu_debuglink    PROGBITS        0000000000000000 01e600 000034 00     0   0   1\n    [26] .bss              NOBITS          000000000061e600 01e600 000d68 00  WA 0   0   32\n    [27] .injected         PROGBITS        0000000000800e78 01ee78 00003f 00  AX 0   0   16\n    [28] .shstrtab         STRTAB          0000000000000000 01e634 000102 00     0   0   1\n  Key to Flags:\n    W (write), A (alloc), X (execute), M (merge), S (strings), l (large)\n    I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n    O (extra OS processing required) o (OS specific), p (processor specific)\n  $ objdump ls.ctor -s --section=.init_array\n\n  ls:     file format elf64-x86-64\n\n Contents of section .init_array:\n   61de00 ➍704a4000 00000000                      pJ@.....\n➎ $ hexedit ls.ctor\n  $ objdump ls.ctor -s --section=.init_array\n\n  ls.ctor:     file format elf64-x86-64\n  Contents of section .init_array:\n    61de00 ➏780e8000 00000000                                 x.......\n➐ $ ./ls.ctor\n  hello world!\n  elfinject elfinject.c hello.s hello.bin   ls Makefile\n```", "```\n   BITS 64\n\n   SECTION .text\n   global main\n\n   main:\n     push   rax                ; save all clobbered registers\n     push   rcx                ; (rcx and r11 destroyed by kernel)\n     push   rdx\n     push   rsi\n     push   rdi\n     push   r11\n\n     mov rax,1                 ; sys_write\n     mov rdi,1                 ; stdout\n     lea rsi,[rel $+hello-$]   ; hello\n     mov rdx,[rel $+len-$]     ; len\n     syscall\n\n     pop   r11\n     pop   rdi\n     pop   rsi\n     pop   rdx\n     pop   rcx\n     pop   rax\n\n➊   ret                       ; return\n\n   hello: db \"hello world\",33,10\n   len : dd 13\n```", "```\n➊  $ cp /bin/ls ls.got\n➋  $ ./elfinject ls.got hello-got.bin \".injected\" 0x800000 -1\n   $ objdump -M intel -d ls.got\n   ...\n➌  0000000000402800 <fwrite_unlocked@plt>:\n    402800: ff 25 9a ba 21 00 jmp     QWORD PTR [rip+0x21ba9a] # ➍61e2a0 <_fini@@Base+0x20a644>\n    402806: 68 51 00 00 00      push 0x51\n    40280b: e9 d0 fa ff ff      jmp   4022e0 <_init@@Base+0x28>\n   ...\n   $ objdump ls.got -s --section=.got.plt\n\n   ls.got:           file format elf64-x86-64\n\n   Contents of section .got.plt:\n   ...\n    61e290 e6274000 00000000 f6274000 00000000 .'@......'@.....\n    61e2a0 ➎06284000 00000000 16284000 00000000 .(@......(@.....\n    61e2b0 26284000 00000000 36284000 00000000 &(@.....6(@.....\n   ...\n➏  $ hexedit ls.got\n   $ objdump ls.got -s --section=.got.plt\n\n   ls.got:           file format elf64-x86-64\n\n   Contents of section .got.plt:\n   ...\n   61e290 e6274000 00000000 f6274000 00000000 .'@......'@.....\n   61e2a0 ➐780e8000 00000000 16284000 00000000 x........(@.....\n   61e2b0 26284000 00000000 36284000 00000000 &(@.....6(@.....\n   ...\n➑ $ ./ls.got\n   hello world!\n   hello world!\n   hello world!\n   hello world!\n   hello world!\n   ...\n```", "```\n➊ $ cp /bin/ls ls.plt\n➋ $ ./elfinject ls.plt hello-got.bin \".injected\" 0x800000 -1\n   $ objdump -M intel -d ls.plt\n   ...\n➌ 0000000000402800 <fwrite_unlocked@plt>:\n     402800: ➍ff 25 9a ba 21 00    jmp    QWORD PTR [rip+0x21ba9a] # 61e2a0 <_fini@@Base+0x20a644>\n     402806: 68 51 00 00 00       push  0x51\n     40280b: e9 d0 fa ff ff       jmp   4022e0 <_init@@Base+0x28>\n   ...\n➎ $ hexedit ls.plt\n   $ objdump -M intel -d ls.plt\n   ...\n➏ 0000000000402800 <fwrite_unlocked@plt>:\n     402800: e9 73 e6 3f 00     jmp    800e78 <_end@@Base+0x1e1b10>\n     402805: 00 68 51           add    BYTE PTR [rax+0x51],ch\n     402808: 00 00              add    BYTE PTR [rax],al\n     40280a: 00 e9              add    cl,ch\n     40280c: d0 fa              sar    dl,1\n     40280e: ff                 (bad)\n     40280f: ff                 .byte 0xff\n    ...\n➐ $ ./ls.plt\n   hello world!\n   hello world!\n   hello world!\n   hello world!\n   hello world!\n   ...\n```"]