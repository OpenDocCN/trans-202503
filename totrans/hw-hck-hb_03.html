<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="71" id="Page_71"/>3</span><br/>
<span class="ChapterTitle">Casing the Joint: Identifying Components and Gathering Information</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">Frank Herbert wrote in <em>Dune</em>, “A beginning is a very delicate time.” As you likely know, the way you begin a project sets the tone for its success. Operating on false assumptions or overlooking a small bit of information can derail a project and burn precious time. Thus, with any reverse engineering or research project (hardware being no different), gathering and reviewing as much information as possible in the early phases of your investigation into a target system is critical.</p>
<p>Most hardware-based projects start with a curiosity and fact-gathering stage, and this chapter is meant to assist with that phase. If you’re performing a target system review without design files, specifications, or a bill of materials (BOM), you naturally start by opening the device and seeing what’s inside. That’s the fun part! This chapter outlines techniques for identifying interesting components or interfaces and shares ideas for gathering information and specifications for a device and its components.</p>
<p><span epub:type="pagebreak" title="72" id="Page_72"/>This information-gathering phase isn’t linear. You’ll find a variety of puzzle pieces. In this chapter, we show ways to find the pieces, and it’s up to you to put them together, in whatever order, to make the picture sufficiently complete.</p>
<h2 id="h1-278748c03-0001">Information Gathering</h2>
<p class="BodyFirst"><em>Info gathering</em>, <em>doxing</em>, <em>recon</em>, <em>getting developer Joe to spill the beans</em>—however you express it, this is an important time-saving step. Plenty of information is available if you know where to look. We begin with the least effort, which is at the keyboard, and later we’ll reach for the screwdriver and other tools.</p>
<p>Before delving into the deeper recesses of the internet, you might consider just searching for the given product name along with the keyword <em>teardown</em>. It’s common to have teardowns of popular products posted in numerous sources; the iFixit website<em> </em>(<a href="https://www.ifixit.com/" class="LinkURL">https://www.ifixit.com/</a>), for example, has many popular teardowns, including detailed annotations of the products. For consumer goods, watch for multiple generations of the products. The Nest Protect smart smoke alarm second-generation device is very different internally from the first-generation device, for example. It’s common that companies won’t actually differentiate such generations, as they simply stop selling the older generation devices, so you may need to figure that out from model numbers or similar.</p>
<h3 id="h2-278748c03-0001">Federal Communications Commission Filings</h3>
<p class="BodyFirst">The <em>Federal Communications Commission (FCC)</em> is a US government agency responsible for everything from imposing fines for exposing specific body parts on TV to ensuring that the latest high-speed wireless devices don’t interfere with each other. It sets regulations that manufacturers of any digital device sold in the US must follow. These regulations are designed to ensure that a given device doesn’t generate excessive amounts of interference (for example, your whiz-bang 5000 causing your neighbor’s TV reception to drop out) and continues to operate even in the presence of some level of electromagnetic (EM) interference.</p>
<p>Other countries have similar agencies and rules. The FCC is interesting because the US is such a large market, so most products have been designed and/or tested to meet FCC rules, and the FCC makes the database of filed information publicly available.</p>
<h4 id="h3-278748c03-0001">About FCC Filings</h4>
<p class="BodyFirst">Any digital device that emits radio waves, known as an intentional radiator, requires testing. The FCC requires manufacturers to test their devices’ emissions carefully and provide documentation proving devices meet FCC rules. It’s a very expensive process, and the FCC needs to ensure that it is easy for the public to check compliance. This is why, for instance, the open source flash-drive-sized computer called the <em>USB armory Mk I</em> is labeled as a development platform that “may cause interference to electrical or <span epub:type="pagebreak" title="73" id="Page_73"/>electronic devices in close proximity.” Proving that this label may be unjustified is expensive. </p>
<p>For compliance checking by the public, an intentional radiator must publish something known as its <em>FCC ID</em>, which is printed on the device’s label. You can search for this ID on the FCC website and confirm that the device did indeed pass compliance testing. This also means detecting fake FCC labels is easy because anybody can check the status, not just FCC agents.</p>
<p>A device’s FCC label may be inside a battery cover. <a href="#figure3-1" id="figureanchor3-1">Figure 3-1</a> shows an example of the label on a D-Link router.</p>
<figure>
<img src="image_fi/278748c03/f03001.png" alt="f03001"/>
<figcaption><p><a id="figure3-1">Figure 3-1</a>: D-Link FCC label</p></figcaption>
</figure>
<p>If a device isn’t an intentional radiator, it still must have the FCC compliance logo, but it won’t have an FCC ID. These unintentional radiators have less strict reporting requirements, and the test documentation is often not available.</p>
<h4 id="h3-278748c03-0002">Finding FCC Filings</h4>
<p class="BodyFirst">As an example, the wireless router’s label in <a href="#figure3-1">Figure 3-1</a> shows that the FCC ID is KA2IR818LA1, which you can find on the FCC ID Search website. The search tool separates the ID into two parts: the grantee code and the product code. The FCC assigns the grantee code, and it’s always the same for a given company. This code was previously only the first three characters of the FCC ID, but as of May 1, 2013, it can be either three or five characters. The company assigns the product code, which can be anything from 1 to 14 characters.</p>
<p>Going back to the router, the grantee code is KA2, and the product code is IR818LA1. Entering this information into the search box gives the results shown in . This device has three filings, because it has multiple frequency bands in which it can operate. The Detail link provides reports and letters, including external and internal product photos—normally photos of the board(s) as well as details about the integrated circuits.</p>
<p>Pulling up the internal photos based on the FCC ID KA2IR818LA1, you should easily be able to identify the main processor as an RTL8881AB. You can also see some sort of header, which is most likely serial-based, as <span epub:type="pagebreak" title="74" id="Page_74"/>it has around four pins and a number of test points on the printed circuit board (PCB). You’ve found all of this information without even touching a screwdriver.</p>
<figure>
<img src="image_fi/278748c03/f03002.png" alt="f03002"/>
<figcaption><p><a id="figure3-2">Figure 3-2</a>: FCC ID search results</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	A nice third-party website, <a href="https://FCCID.io/" class="LinkURL">https://FCCID.io/</a>, also provides FCC filings, and it has a better search function and integrated viewer.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-278748c03-0003">FCC Equivalents</h4>
<p class="BodyFirst">The Nest doorbell in <a href="#figure3-3" id="figureanchor3-3">Figure 3-3</a> shows no FCC ID. Why? Colin bought this device, and he’s located in Canada, so the device doesn’t require an FCC ID. Instead, it’s marked only with the Industry Canada (IC) code, which allows you to search the Industry Canada “Radio Equipment List (REL)” database for a matching “certification number.”</p>
<figure>
<img src="image_fi/278748c03/f03003.png" alt="f03003"/>
<figcaption><p><a id="figure3-3">Figure 3-3</a>: Nest doorbell</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="75" id="Page_75"/>Searching the IC REL database for 9754A-NC51 provides more information, but no detailed internal photos are available on the public website. The product code part of the reference (NC51) is shared between the FCC ID and the IC designator, so a quick way to find more information is to do a partial search at <a href="https://FCCID.io/" class="LinkURL">https://FCCID.io/</a> for NC51. We found that the FCC ID is ZQANC51, which allowed us to find the internal photos.</p>
<h3 id="h2-278748c03-0002">Patents</h3>
<p class="BodyFirst">Patents are effectively licenses given to product developers to sue companies who sell a product that copies the well-defined operation of the original product, in a specific geographic area, for a limited period of time. Patents, in theory, are issued only if that well-defined operation is something novel. The goal is to protect inventions, and since this chapter is about information gathering and not politics, we’ll leave it at that.</p>
<p>Most companies like patents since they can use them to stop a competitor from releasing a product using some new technology or design. But there is a catch: patents must explain how that new technology works. The idea is that in exchange for giving away precious details about the new technology, the legal system can stop anyone else from using those details to compete with the inventor for that limited period of time.</p>
<h4 id="h3-278748c03-0004">Finding Patents</h4>
<p class="BodyFirst">When researching a device, you might find that patents provide useful information about how security or other aspects of the design were handled. For example, in researching a password-protected hard drive, we found a patent that describes a method of securing hard drives by scrambling the partition table.</p>
<p>Products or manuals might be stamped with some sort of statement like “Protected by US Patent 7,324,123.” You can easily look up this patent number on the United States Patent and Trademark Office (USPTO) website or on a third-party website, such as Google Patents. We recommend Google Patents, as it searches multiple databases and also contains an easily navigated search tool for general-purpose use.</p>
<p>Often products are labeled “Patent Pending,” or you may find only references to patents in the product literature. This normally means the company has simply applied for a patent; it might not even be publicly viewable yet. In that case, the only reasonable method of searching for those patents is by company name. Determine to whom the patent is likely assigned; for example, a patent might be owned by the manufacturer of a chip inside the device and not the manufacturer of the device itself. Often you can find related patents issued to the company and then search by the company’s law firm or even patents by other related inventors.</p>
<p>If you find a patent (or patent application), the actual published application isn’t all the information you can use. A system called the USPTO Public PAIR allows you to review almost all correspondence between the USPTO and patent applicant. Those documents are not indexed by search engines, so you won’t find them without using the USPTO Public PAIR <span epub:type="pagebreak" title="76" id="Page_76"/>system. You can see, for example, if the USPTO has been fighting against an application in cases where patents are pending, or you can find supporting documentation that applicants may have uploaded. Sometimes you can find earlier versions of a patent or an applicant’s arguments, including additional information you won’t find on Google Patents.</p>
<p>Some examples of interesting uses of patents for reverse engineering include the Thangrycat attack by Red Balloon Security, detailed in a DEF CON presentation titled “100 Seconds of Solitude: Defeating Cisco Trust Anchor with FPGA Bitstream Shenanigans.” In this attack, Red Balloon Security defeated the Cisco root of trust, which used an electronic component called a <em>field-programmable gate array (FPGA)</em>. Details of the architecture were helpfully explained in US Patent 9,830,456, which provided insights that otherwise would have required considerable effort to reverse engineer.</p>
<p>Another example where patents were useful for hardware hackers is a presentation at Black Hat USA titled “GOD MODE UNLOCKED: Hardware Backdoors in x86 CPUs,” by Christopher Domas. Here, US Patent 8,296,528 explained how a separate processor could be connected to the main x86 core and hinted at details that resulted in a complete compromise of the core’s security mechanism.</p>
<p>Patents may even list details about secure devices. For example, a Square credit card reader contains an anti-tamper “mesh” integrated into a plastic cover for the secure section of the microcontroller. <a href="#figure3-4" id="figureanchor3-4">Figure 3-4</a> shows the four large square pads (we’ll talk more about PCB features later in this chapter) with oval sections that will connect to the tamper mesh cover.</p>
<p><a href="#figure3-5" id="figureanchor3-5">Figure 3-5</a> shows the underside of the tamper mesh cover that mates to the PCB shown in <a href="#figure3-4">Figure 3-4</a>.</p>
<figure>
<img src="image_fi/278748c03/f03004.png" alt="f03004"/>
<figcaption><p><a id="figure3-4">Figure 3-4</a>: The Square credit card reader internals with four tamper shield connectors near each corner</p></figcaption>
</figure>
<span epub:type="pagebreak" title="77" id="Page_77"/><figure>
<img src="image_fi/278748c03/f03005.png" alt="f03005"/>
<figcaption><p><a id="figure3-5">Figure 3-5</a>: The Square reader’s tamper shield; the exposed connections will mate with the PCB shown in <a href="#figure3-4">Figure 3-4</a></p></figcaption>
</figure>
<p>When you remove the mesh, the device will stop working, so reverse engineering the device quickly becomes expensive. If you search Google Patents for US10251260B1, however, you’ll find details about how the mesh works. Try that now and see if you can match the photos from Figures 3-4 and 3-5 to patent figures. If you haven’t worked with PCBs before, come back to these figures again after you finish this chapter, as we’ll explain some of the PCB features you can see here.</p>
<h3 id="h2-278748c03-0003">Datasheets and Schematics</h3>
<p class="BodyFirst">Manufacturers publish datasheets (either publicly or under NDA) so designers can learn how to use their components, but they usually don’t publish complete schematics. Instead, you usually can find publicly shared <em>logical</em> designs that show how components are interconnected. For instance, a PCB layout shows the physical design—that is, where all components are placed and how the wires are routed, but it’s usually not publicly available.</p>
<p>Try finding a datasheet online for your favorite device or development board, such as for a Raspberry Pi computer module or an Intel 8086 processor, or a random datasheet for flash or DRAM memory. Or, if you want to go analog, find a level-shifter datasheet. Usually, you just need to do a simple internet search for product IDs or other identifiers, as mentioned earlier. Websites like findchips (<a href="https://www.findchips.com/" class="LinkURL">https://www.findchips.com/</a>) also are helpful for locating current products.</p>
<p><span epub:type="pagebreak" title="78" id="Page_78"/>Datasheets for a specific part may be a bit harder to find. For components, first determine the part number (see the “Identifying ICs on the Board” section on page <span class="xref" itemid="xref_target_86">86</span>). The part number often appears to be a random-looking collection of letters and numbers, but they encode the available various configurations of a part. For instance, the datasheet for the MT29F4G08AAAWP breaks the part number down as follows:</p>
<ul>
<li>MT stands for Micron Technology.</li>
<li>29F is the product family of NAND flash memory.</li>
<li>4G indicates a 4GB storage capacity.</li>
<li>08 indicates an 8-bit device.</li>
<li>First “A” means one die, one command pin, and one device status pin.</li>
<li>Second “A” indicates an operating voltage of 3.3 V.</li>
<li>Third “A” is a listed feature set.</li>
<li>WP indicates that the component is a 48-pin thin small outline package (TSOP).</li>
</ul>
<p>When searching, simply type in any part number you find on the die. If you can’t find the exact number, trim off some of the last characters and search again or allow your search engine to suggest some nearly matching names.</p>
<p>Oftentimes you’ll have too many matches, because on very small parts, a full part number isn’t printed, but only a shorter <em>marking code</em>. Unfortunately, searching the marking code will return hundreds of unrelated matches. For example, a particular part on a board may simply be labeled <em>UP9</em>, which is almost unsearchable. If you search the marking code along with the package type, you will often get more useful hits. In this example, we had identified the package as being an SOT-353 package type (we discuss package types later in this chapter). For marking codes specifically, you can find SMD (surface-mount device) marking code databases, such as <a href="https://smd.yooneed.one/" class="LinkURL">https://smd.yooneed.one/</a> and <a href="http://www.s-manuals.com/smd/" class="LinkURL">http://www.s-manuals.com/smd/</a>, which, combined with your knowledge of the package, can lead you to the device (in this case, a Diodes, Inc., 74LVC1G14SE).</p>
<p>After looking at a few datasheets, you’ll find they have something in common. They seldom contain interesting information from a security viewpoint. We’re mainly concerned with interacting with a device, which means discovering how it works and how to connect to it. The introductory blurb will contain the functionality: it’s a CPU, a flash device, or whatever. To connect to it, we look for the pinout and any parameters describing the pins, such as functionality, protocol, or voltage levels. You’ll almost certainly find some of the interfaces discussed in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>.</p>
<h3 id="h2-278748c03-0004"><span epub:type="pagebreak" title="79" id="Page_79"/>Information Search Example: The USB Armory Device</h3>
<p class="BodyFirst">Let’s look for information on the USB armory Mk I device from Inverse Path (acquired by F-Secure) as an example. It’s an open source piece of hardware, so we’ll be able to access plenty of detail. Before reading all the spoilers here, try researching it yourself. Go find the following:</p>
<ul>
<li>The manufacturer and part number of the main System-on-Chip (SoC), as well as the datasheet for it.</li>
<li>The GPIO and UART on the PCB.</li>
<li>Any JTAG ports exposed on the board.</li>
<li>The power supply wires and voltage on the PCB.</li>
<li>The external clock crystal wires and frequency.</li>
<li>Where the I2C interface from the main SoC connects to another IC, and what the protocol is.</li>
<li>The boot configuration pins on the SoC, where they are connected on the PCB, and what boot mode and configurations this selects.</li>
</ul>
<h4 id="h3-278748c03-0005">Manufacturer, Part Number, and Datasheet</h4>
<p class="BodyFirst">From the USB armory GitHub pages and wiki (<a href="https://inversepath.com/usbarmory_mark-one.html" class="LinkURL">https://inversepath.com/usbarmory_mark-one.html</a>), we can see that the USB armory is based on an NXP i.MX53 ARM Cortex-A8. The datasheet is called <em>IMX53IEC.pdf</em> and is available in several places. When searching for “imx53 vulnerability,” we found a known X.509 vulnerability on the Quarkslab blog. If you dig further, you may be able to find an advisory titled “Security Advisory: High Assurance Boot (HABv4) Bypass,” which notes these vulnerabilities are not present in the Mk II.</p>
<h4 id="h3-278748c03-0006">The GPIO and UART on the PCB</h4>
<p class="BodyFirst">Searching for “USB armory GPIO,” we arrive at its GitHub wiki (<a href="https://github.com/f-secure-foundry/usbarmory/wiki/GPIOs/" class="LinkURL">https://github.com/f-secure-foundry/usbarmory/wiki/GPIOs/</a>), which provides the GPIO detail. In the datasheet sourced in the previous section, we can find all of the i.MX53’s GPIO, UART, I2C, and SPI pins. Any of those communications ports would be interesting to monitor; they will surely transport console or debug output.</p>
<h4 id="h3-278748c03-0007">JTAG Ports</h4>
<p class="BodyFirst">JTAG, if not locked down, should provide low-level access to the chip via ARM’s debugging facilities, so we want information about any JTAG ports exposed on the board. Exploring the GitHub pages a bit more yields the JTAG page specific for the Mk I (<a href="https://github.com/f-secure-foundry/usbarmory/wiki/JTAG-(Mk-I)/" class="LinkURL">https://github.com/f-secure-foundry/usbarmory/wiki/JTAG-(Mk-I)/</a>), which includes a PCB photo (see <a href="#figure3-6" id="figureanchor3-6">Figure 3-6</a>).</p>
<span epub:type="pagebreak" title="80" id="Page_80"/><figure>
<img src="image_fi/278748c03/f03006.png" alt="f03006"/>
<figcaption><p><a id="figure3-6">Figure 3-6</a>: USB armory JTAG connector pins</p></figcaption>
</figure>
<p><a href="#figure3-6">Figure 3-6</a> shows the standard TCK, TMS, TDI, TDO, nTRST, and GND (ground) JTAG connections. The 2v8 pad provides a 2.8 V supply, but what about the MOD pad? The datasheet is not very clear about that. The JTAG_MOD/sjc_MOD is in the i.MX53 pinout list, but there’s no explanation of its meaning. A bit of searching for related products yields an explanation on the i.MX6 computer module datasheet (search for “IMX6DQ6SDLHDG.pdf”; the original NXP site requires a sign-in, but the PDF is mirrored in other places). This datasheet explains that <em>low</em> adds all system test access ports (TAPs) to the chain, whereas <em>high</em> makes it IEEE1149.1- compliant (only useful for boundary scan, which we’ll discuss in the section “Using the JTAG Boundary Scan for Mapping” on page <span class="xref" itemid="xref_target_106">106</span>). Reading the schematic at the bottom of the Mk I JTAG page, you’re advised to tie it to ground via a pulldown resistor; this pulls it <em>low</em> to enable system TAPs. As you can see, sometimes synthesizing different information sources completes the picture.</p>
<h4 id="h3-278748c03-0008">Power Supply and Voltage</h4>
<p class="BodyFirst">For the power supply wires and voltage on the PCB, we go to the datasheet we sourced previously. Search for “power,” “Vcc,” “Vdd,” “Vcore,” “Vfuse,” and “ground/Vss.” You’ll discover that a modern SoC includes many repeated instances of those terms, each one representing a pin. Various subsystems on the power planes have multiple input voltages, which is one reason for this abundance of pins. For example, the flash memory may have a higher voltage than the core voltage. You may also find multiple I/O voltages that support a variety of standards.</p>
<p>A second reason for the many pins is that they are often duplicated, sometimes several times over. This helps keep power and ground pins physically close to each other, reducing inductance to help deliver fast power transients to the chip.</p>
<p>The datasheet certainly includes many power pins, which in this chip are denoted as VCC (peripheral core voltage) and VDDGP (ARM core voltage), among other designations. We look for power pins to find ways to inject faults and do power analysis, which are techniques you’ll learn about in the <span epub:type="pagebreak" title="81" id="Page_81"/>next few chapters. For instance, if you want to listen in on crypto on the ARM core, you’d try to probe VDDGP. If you want to glitch L1 cache (VDDAL1), JTAG access control (NVCC_JTAG), or fuse writes (NVCC_FUSE), you’d try to control those.</p>
<p>A schematic is really helpful to learn how these power pins are connected on the circuit board. We found one in the GitHub hardware repository as <em>armory.pdf </em>(<a href="https://raw.githubusercontent.com/inversepath/usbarmory/b42036e7c3460b6eb515b608b3e8338f408bcb22/hardware/mark-one/armory.pdf" class="LinkURL">https://raw.githubusercontent.com/inversepath/usbarmory/b42036e7c3460b6eb515b608b3e8338f408bcb22/hardware/mark-one/armory.pdf</a>). Page 3 of this PDF lists the power connections to the SoC. If you follow the PCB traces from these power connections, you’ll see a bunch of decoupling capacitors (marked C48, C49, and so on), which are used for de-noising the power supply. You’ll also notice that the connection names end in labels like PMIC_SW1_VDDGP and PMIC_SW2_VCC. <em>PMIC</em> stands for power management IC—a chip dedicated to supplying the right voltages. Page 2 of the PDF shows how the main power source (USB_VBUS) feeds into the main power plane (5V_MAIN) and into the PMIC, which in turn feeds the variety of regulated voltages to the SoC.</p>
<p>This tells us logically how everything is connected, but it doesn’t yet tell us where these wires are on the PCB. For that, we need to open the PCB’s layout files, found in the KiCAD design files.</p>
<p>KiCAD is open source software for designing PCBs. We’re only using one percent of its functionality here to check out the PCB layout. We opened the <em>armory.kicad_pcb</em> design file with KiCAD’s <code>pcbnew</code> command. A PCB might include several layers of conductive tracks/traces, where each of those layers is shown on the right side of the program window, with checkboxes to enable and disable them. Disable them all first to see only the pads on the PCB. You’ll see the “U2” (main SoC’s ball grid) in the center, the “U1”/PMIC to the left, and the “U4”/DRAM chip to the right.</p>
<p>KiCAD has a nice tool to highlight a net, appropriately called <em>highlight net</em>, that allows you to click anywhere and follow the connection. Say we want to play around with the power to JTAG. Zoom in to the SoC until you see the ball names and find the NVCC_JTAG ball, which according to the datasheet is G9. You’ll see what is shown in <a href="#figure3-7" id="figureanchor3-7">Figure 3-7</a>.</p>
<p>Remember the JTAG pads? It seems that NVCC_JTAG is connected to the 2v8 pad used for JTAG power. However, near the PMIC, you’ll also see some wires highlighted. They are part of the same net; we just can’t see that part because we’ve switched off all the layers. Clicking all layers on and off, we find one layer that connects them: GND_POWER_1<em> </em>(see <a href="#figure3-8" id="figureanchor3-8">Figure 3-8</a>).</p>
<p>The white dots are <em>vias</em>, which are small plated holes connecting a trace on one layer to a trace on another layer. One via is on the left connection to the PMIC, and then a power plane connects to the via on the right, which connects to the wire that goes to NVCC_JTAG. If we wanted to control the power on <em>NVCC_JTAG</em> for fault injection or power analysis, we could physically cut the trace to the PMIC and provide our own 2.8 V by soldering a wire to the 2v8 pad.</p>
<span epub:type="pagebreak" title="82" id="Page_82"/><figure>
<img src="image_fi/278748c03/f03007.png" alt="f03007"/>
<figcaption><p><a id="figure3-7">Figure 3-7</a>: Using KiCAD to highlight an interconnection network</p></figcaption>
</figure>
<figure>
<img src="image_fi/278748c03/f03008.png" alt="f03008"/>
<figcaption><p><a id="figure3-8">Figure 3-8</a>: Highlighting the GND_POWER_1 layer</p></figcaption>
</figure>
<h4 id="h3-278748c03-0009">Clock Crystal and Frequency</h4>
<p class="BodyFirst">To identify the external clock crystal wires and the frequency clocks, we again refer to the datasheet we sourced a previously. Search for “clock/CLK/XTAL,” <span epub:type="pagebreak" title="83" id="Page_83"/>and you’ll discover four interesting external oscillator pins: XTAL and CKIL (and their complementary inputs EXTAL and ECKIL), and two general-purpose inputs, CKIH1 and CKIH2. Searching for those inputs, we find the “i.MX53 System Development User’s Guide” as <em>MX53UG.pdf</em>. The section on these inputs, in turn, refers to the “i.MX53 Reference Manual,” which we find as <em>iMX53RM.pdf</em>. According to the reference manual, you program the latter inputs to supply a clock to various peripherals, such as the CAN network and SPDIF port. Looking at the board schematics, we find that (E)XTAL is connected to a 24 MHz oscillator, (E)CKIL is connected to a 32,768 Hz oscillator, and CKIH1 and CKIH2 are pulled to ground. The USB armory schematics show that those pins are connected to two sets of pads, which correspond to two oscillators. Those oscillators are the rather huge components in <a href="#figure3-9" id="figureanchor3-9">Figure 3-9</a>.</p>
<figure>
<img src="image_fi/278748c03/f03009.png" alt="f03009"/>
<figcaption><p><a id="figure3-9">Figure 3-9</a>: Oscillators have a white silkscreen box around them.</p></figcaption>
</figure>
<p>Clock control is significant for two main purposes: synchronizing side-channel measurements to the device clock and facilitating clock fault-injection experiments. In this case, the EXTAL input goes through a frequency multiplier, which then clocks the ARM core. Here, the PLLs (phase-locked loops) that turn the external frequency into an internal clock may eat up any weirdness in your clock, so clock fault injection may be a no-go, but we can still insert our own clock into these pins to provide more precise clock synchronization to count clock cycles. If you are going for clock synchronization, you don’t even need to remove the crystal on the board. You can feed in a clock to the crystal circuit, and it will force the crystal oscillator circuit to run on the clock pulses that you will inject. (See <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> for more on clock fault injection.)</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Crystals and Oscillators</h2>
<p class="BoxBodyFirst">Understanding how most digital devices use crystals is a valuable skill. Fundamentally, a crystal is a filter that passes a specific frequency. <span epub:type="pagebreak" title="84" id="Page_84"/>A 12.0000 MHz crystal acts as a very narrow band filter, passing only 12.0000 MHz. To generate a clock signal, this filter is inserted into a feedback loop in a circuit called a <em>Pierce oscillator</em>, shown here:</p>
<figure class="graphic"><img src="image_fi/278748c03/g03001.png" alt="g03001"/></figure>
<p>The frequency that the crystal operates at will be amplified in this feedback loop, and everything else is suppressed. The crystal forms a filter with the C1 and C2 capacitors, and this filter applies a 180-phase shift (effectively inverting the input). The resistor helps bias the inverter into a linear region where it forms a very high-gain inverting amplifier. The inverter itself is implemented inside the microcontroller (along with resistor R and sometimes even the capacitors).</p>
<p>The way the crystal oscillator circuit operates means there is an <em>output</em> pin and an <em>input</em> pin on your microcontroller. In this example, those are XTAL and EXTAL, respectively. The naming is not standard; those pins may be called XTAL1 and XTAL2, for example, instead. If you drive a signal into the input pin, it may override the crystal frequency and simply allow you to run the microcontroller at another frequency or inject other arbitrary clock signal shapes. This action can yield many hours of fun and games, and it goes by the name of <em>c</em><em>lock fault injection</em>.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-278748c03-0010">The I2C Interface</h4>
<p class="BodyFirst">We need to determine where the I2C interface from the main SoC connects to another integrated circuit (IC) and what the protocol on that interface is. The USB armory schematics show that pins 30 and 31 are I2C, and the i.MX53 datasheet shows three I2C controllers. We can trace the layout to find a connection to V3, which is named EIM_D21 and is one of the GPIOs. EIM_D21 is either SPI or I2C-1. This is an example of a multiplexed pin; the SoC itself can be configured to talk various low-level protocols on the pin.</p>
<p>As for the high-level protocol, we have to dig a little deeper—specifically, into the PMIC datasheet. The PMIC is identified as an LTC3589 in the PCB schematic, and the datasheet is called <em>3589fh.pdf</em>. In the “I2C Operation” section, the datasheet precisely defines the protocol.</p>
<h4 id="h3-278748c03-0011"><span epub:type="pagebreak" title="85" id="Page_85"/>The Boot Configuration Pins</h4>
<p class="BodyFirst">Knowing where the boot configuration pins are, where they are connected on the PCB, and what boot mode and configurations the pins select is really helpful. For now, we’re providing an example of how to find data; don’t worry about understanding the technicalities.</p>
<p>The i.MX53 datasheet (<em>IMX53IEC.pdf</em>) mentions various BOOT_MODE and BOOT_CFG pins, but it does not define what they do. In the schematics for the Mk I, we find that BOOT_MODE pins (C18 and B20) are not connected to power or ground on the PCB.</p>
<p>Let’s first find out what it means that BOOT_MODE is not connected. The i.MX53 datasheet has a table that claims for BOOT_MODE0 and BOOT_MODE1, the “config. value” is 100 kΩ PD. PD stands for <em>pulldown</em>, so if the pin is not connected, it is internally pulled down to ground. This means that the BOOT_MODE0 and BOOT_MODE1 pins are at logical 0 when not connected. The datasheet mentions nothing more, but the i.MX53 reference manual (<em>iMX53RM.pdf</em>, which is 5,100 pages of goodness) gives the high-level boot sequence and shows that BOOT_MODE[1:0]=0b00 means <em>internal boot</em>.</p>
<p>Now, for BOOT_CFG, the i.MX53 datasheet shows that all of these BOOT_CFG pins are connected to pins starting with EIM_, such as EIM_A21. Keep in mind this is a pin name, not a coordinate. If you keep searching the datasheet, you’ll see that EIM_A21 is a name of the pin at location AA4 (this AA4 is a location on the chip, a BGA ball). With that information, we can look at the Mk I schematic to see how these pins are connected.</p>
<p>It turns out that all BOOT_CFG pins are grounded, with the exception of BOOT_CFG2[5]/EIM_DA0/Y8 and BOOT_CFG1[6]/EIM_A21/AA4, which are pulled up to 3.3 V through a resistor. These bits are set to 1, whereas all other BOOT_CFG bits are set to 0. Searching for BOOT_CFG in the reference manual, we find Table 7-8, “Boot Device Selection,” which has a line specifying that BOOT_CFG1[7:4] set to 0100 or 0101 means to boot from the SD card (written in the table as 010X). The effect of setting BOOT_CFG2[5] seems to depend on the boot mode selected. Since we just found out it’s booting from the SD card, Table 7-15, “ESDHC Boot eFUSE Descriptions,” is relevant. It indicates that BOOT_CFG2[5]=1 means we are using a 4-bit bus width on the SD card.</p>
<p>And remember that MOD pin for which we couldn’t find proper information? That reference manual has everything you want to know about it and more, under the sjc_mod pin, which also confirms the information we found before. Don’t despair if you can’t find what you need at first.</p>
<p>Those are just a few examples of the kinds of questions you can answer from various sources of documentation. Datasheets are usually easy to find; schematics and PCB layouts and/or reference designs are rare. However, you can reverse engineer information as well, as you’ll see in the next section, “Opening the Case.”</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="86" id="Page_86"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	If you are looking for schematics, it’s worth pursuing repair databases. Many schematics are published in various forms to help repair houses; for example, you might be surprised to find that many cell phone repair shops have full schematics of relatively recent consumer phones.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-278748c03-0002">Opening the Case</h2>
<p class="BodyFirst">As with any reverse engineering task, your objective is to get into the system designer’s head. Through research, clues, and a little guesswork, the idea is to understand just enough to complete your task. We are not reverse engineering for the purpose of cloning or fully extracting schematics; we just want to know how to modify and/or attach to a PCB in order to reach our goal. If you are lucky, someone has looked at this device (or a similar device) before, and as mentioned earlier, you can try to find teardowns of the products already posted.</p>
<p>What starts out as a collection of IC serial numbers, a handful of external ports, and a seemingly infinite number of resistors and capacitors will turn into an understanding of the system. And with a bit of luck, you can find a test point or debug port that will provide even more access.</p>
<h3 id="h2-278748c03-0005">Identifying ICs on the Board</h3>
<p class="BodyFirst">We don’t use one specific device to demonstrate the technique for identifying ICs, so if you want to follow along, find a cheap IoT (internet of things) or similar device that you won’t mind ripping open.</p>
<p>Most PCBs you’ll encounter in modern electronics are mounted on the PCB’s surface, in contrast with the through-hole mounting of times past. This is called <em>surface-mount technology (SMT)</em>, and any device on it is called a <em>surface-mount device (SMD)</em>.</p>
<p>Once you’ve opened a device, you’ll usually see a single PCB with a bunch of components (check the front and back of the PCB), the largest of which will likely be the main SoC, DRAM, and external flash storage, as shown in <a href="#figure3-10" id="figureanchor3-10">Figure 3-10</a>.</p>
<p>In the top center of <a href="#figure3-10">Figure 3-10</a> is a DSPGroup DVF97187AA2ANC main SoC <span class="CodeAnnotation" aria-label="annotation1">1</span>. To the left of that is an EtronTech EM63A165TS-6G SDRAM in a TSSOP package <span class="CodeAnnotation" aria-label="annotation2">2</span>, and above the SDRAM is Winbond 25Q128JVSQ flash memory in an SOIC-8 package <span class="CodeAnnotation" aria-label="annotation3">3</span>. In addition, there is a Realtek RTL8304MB Ethernet controller <span class="CodeAnnotation" aria-label="annotation4">4</span>. This particular device is a very low-cost IP phone, which might explain why the SoC and SDRAM are brands you’ve likely not heard of before.</p>
<p>The first step is to read the die markings on the chips. You can usually get pretty far with a phone camera. <a href="#figure3-11" id="figureanchor3-11">Figure 3-11</a> shows photos of another device, an HDMI RCA audio splitter, taken with a regular phone camera and microscope app.</p>
<span epub:type="pagebreak" title="87" id="Page_87"/><figure>
<img src="image_fi/278748c03/f03010.png" alt="f03010"/>
<figcaption><p><a id="figure3-10">Figure 3-10</a>: Identifying ICs on the board</p></figcaption>
</figure>
<figure>
<img src="image_fi/278748c03/f03011.png" alt="f03011"/>
<figcaption><p><a id="figure3-11">Figure 3-11</a>: Die markings: on the left, with flash and a good angle; in the middle, with flash and bad angle; on the right, with natural light</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="88" id="Page_88"/>As you can see, playing with different angles and with the flashlight on or off, you should be able to take a suitable photo for reading die markings. Alternatively, cheap USB microscope cameras will do the job; see Appendix A for hardware information. The photos in <a href="#figure3-12" id="figureanchor3-12">Figure 3-12</a> were taken with such a camera.</p>
<figure>
<img src="image_fi/278748c03/f03012.png" alt="f03012"/>
<figcaption><p><a id="figure3-12">Figure 3-12</a>: Photos taken with a USB microscope camera</p></figcaption>
</figure>
<p>Once you have the die markings, employ your reconnaissance skills to dig up information on the part. Especially if you’re doing this for the first time, try to identify all of the ICs and their datasheets. Even though most of the smaller components may be insignificant from a security point of view, you’ll learn a bit about all that’s needed to make a device tick. We’ve learned much about voltage regulators and other funny little ICs this way.</p>
<p>For some chips, it’s a little trickier to get to the main IC because of a heatsink or protective potting. You can remove heatsinks relatively easily, either by unscrewing them or gently pulling them off the IC. If the heatsink is stuck on (typical with small devices), a twisting motion will help remove it instead of trying to pry or pull it up directly.</p>
<p>You’ll encounter protective potting in higher-security systems where the manufacturer wants to avoid access to the IC. Simply chipping away at it may be unsuccessful, but you’ll likely find heating it up with a heat gun nicely softens the epoxy, and you can then remove it with a tool such as a dental pick. If you want to remove the epoxy completely, try a chemical such as Xylene or paint removers (available in hardware stores).</p>
<h3 id="h2-278748c03-0006">Small Leaded Packages: SOIC, SOP, and QFP</h3>
<p class="BodyFirst">In your quest for IC identification, you’ll encounter various types of beasts. Identifying the packages is useful for several reasons for the hardware hacker. First, you can find this information useful when searching for datasheets. Second, the type of package can actually affect what attacks you can perform. Some of the very tiny packages provide almost chip-level access, and probes we’ll discuss in later chapters are easier to use on these tiny packages. <a href="#figure3-13" id="figureanchor3-13">Figure 3-13</a> shows some of the main small leaded packages you’ll find.</p>
<span epub:type="pagebreak" title="89" id="Page_89"/><figure>
<img src="image_fi/278748c03/f03013.png" alt="f03013"/>
<figcaption><p><a id="figure3-13">Figure 3-13</a>: Small leaded packages: SOIC, TSSOP, and TQFP styles</p></figcaption>
</figure>
<p>All of the packages in <a href="#figure3-13">Figure 3-13</a> have leads on them; the difference is the relative size between leads (pitch) and the leads’ locations. Many variants exist within these families that we also won’t go into here, because for our purposes, they are equivalent. For example, you might see references to both <em>thin quad flat pack (TQFP)</em> and <em>plastic quad flat pack (PQFP</em><em>)</em>, which look almost identical and have similar pin pitch, counts, and package sizes.</p>
<p>The largest is the <em>small outline integrated circuit (SOIC)</em>, which has pins on two sides of the package and typically has a pin-to-pin spacing of 1.27 mm. This package is nice because you can fit grabber clips on it. Often SPI flash memory chips are in 8- or 16-pin wide SOIC packages.</p>
<p>A smaller version of the SOIC is the <em>small outline package (SOP</em><em>)</em>, often in the thin SOP (TSOP) or thin-shrink SOP (TSSOP) variant. All of these also have pins only on two edges, but with pin pitches typically in the 0.4 mm to 0.8 mm range. Wide TSOP packages with 48 pins, as shown in <a href="#figure3-14" id="figureanchor3-14">Figure 3-14</a>, are almost certain to be parallel flash memory chips.</p>
<figure>
<img src="image_fi/278748c03/f03014.png" alt="f03014"/>
<figcaption><p><a id="figure3-14">Figure 3-14</a>: A 48-pin TSOP package</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="90" id="Page_90"/>Finally, the <em>quad flat pack (QFP)</em> package has legs on all four edges and is often seen in the <em>thin QFP (TQFP)</em> or <em>plastic QFP (PQFP)</em> package. These have small changes in material or thickness, but the general form factor is the same. Pin pitch typically varies within the 0.4 mm to 0.8 mm range.</p>
<p>The TQFP’s internal construction basically has a small central IC die, which is connected to a <em>leadframe</em>. If you sand off sections of the IC, you can see the relative sizes, as shown in <a href="#figure3-15" id="figureanchor3-15">Figure 3-15</a> for a TQFP-64 package.</p>
<p>If you want to keep things more intact, you can also use acid decapsulation, but sandpaper is something almost everyone can safely use.</p>
<p><a href="#figure3-16" id="figureanchor3-16">Figure 3-16</a> is a simple diagram of the SOIC/SOP/TQFP’s internal construction and shows the bonding wires connecting the chip to the leads. What was clearly removed in <a href="#figure3-15">Figure 3-15</a> was any hint of bonding wires when the chip was sanded from the top down.</p>
<figure>
<img src="image_fi/278748c03/f03015.png" alt="f03015"/>
<figcaption><p><a id="figure3-15">Figure 3-15</a>: QFP package; from left to right: top sanded off, cross-section, and unharmed</p></figcaption>
</figure>
<figure>
<img src="image_fi/278748c03/f03016.png" alt="f03016"/>
<figcaption><p><a id="figure3-16">Figure 3-16</a>: Internal construction of an SOIC/SOP/TQFP package</p></figcaption>
</figure>
<h3 id="h2-278748c03-0007"><span epub:type="pagebreak" title="91" id="Page_91"/>No-Lead Packages: SO and QFN</h3>
<p class="BodyFirst">No-lead packages are similar to the previous SOIC/QFP packages, but instead of leads, a pad underneath the chip is soldered onto the PCB. This pad often (but not always) extends just to the edge of the device, so you’ll normally see a small protruding solder joint on the edge of the chip with those packages. <a href="#figure3-17" id="figureanchor3-17">Figure 3-17</a> is a simple diagram of these no-lead devices.</p>
<figure>
<img src="image_fi/278748c03/f03017.png" alt="f03017"/>
<figcaption><p><a id="figure3-17">Figure 3-17</a>: No-lead package</p></figcaption>
</figure>
<p>The <em>small outline no-lead (SON)</em> package has connections on only two edges. These devices have typical pitches in the 0.4 mm to 0.8 mm range. As in other packages, many variants exist, such as <em>thin SON (TSON)</em>. You may also see various custom pin layouts where pads are missing. The SON package almost always has a central thermal pad underneath it that is also soldered to the PCB, meaning you will likely need hot air to solder or remove this package. Because you can’t reach the large hidden central pad with a soldering iron, you need some method of heating it indirectly, through either the device package or the PCB.</p>
<p>Also, pay attention to the WSON package type, which officially seems to be called both <em>very-very thin SON</em> and <em>wide SON</em>. This package is much wider than normal and often has a 1.27 mm pitch. It’s frequently used for SPI flash memory chips.</p>
<p>The <em>quad flat no-lead (QFN)</em> package has connections on four edges. These devices have typical pitches in the 0.4 mm to 0.8 mm range. Again, you will almost always see a thermal pad in the center of these devices. They are widely used and can be anything from the main microcontroller to a power-switching regulator.</p>
<h3 id="h2-278748c03-0008">Ball Grid Array</h3>
<p class="BodyFirst"><em>Ball grid array (BGA)</em> packages have balls on the bottom of the chip, as shown in <a href="#figure3-18" id="figureanchor3-18">Figure 3-18</a>, and you won’t be able to see them from the top.</p>
<span epub:type="pagebreak" title="92" id="Page_92"/><figure>
<img src="image_fi/278748c03/f03018.png" alt="f03018"/>
<figcaption><p><a id="figure3-18">Figure 3-18</a>: BGA package</p></figcaption>
</figure>
<p>You can see the edge balls if you can get the angle right, as shown in <a href="#figure3-19" id="figureanchor3-19">Figure 3-19</a>, where you can also see that there is actually a smaller <em>carrier PCB</em>. The BGA chip itself is composed of a smaller PCB with the chip mounted onto it.</p>
<figure>
<img src="image_fi/278748c03/f03019.png" alt="f03019"/>
<figcaption><p><a id="figure3-19">Figure 3-19</a>: View of edge balls</p></figcaption>
</figure>
<p>BGA parts are frequently used for the main processor or SoC. Some eMMC and flash devices will also use a BGA package, and smaller BGAs hanging off the side of the main processor are often DRAM chips in more complex systems.</p>
<p>There are actually several variants of BGA devices, which can be important for power analysis and fault injection, so we’ll detail that construction <span epub:type="pagebreak" title="93" id="Page_93"/>difference here. Vendors use slightly different names, but we keep with the Fujitsu naming process here (<em>a810000114e-en.pdf</em>), which typically maps to names other vendors use.</p>
<h4 id="h3-278748c03-0012">Plastic BGA and Fine Pitch BGA</h4>
<p class="BodyFirst"><em>Plastic BGA (PBGA)</em> devices typically have a 0.8 mm to 1.0 mm pitch (see <a href="#figure3-20" id="figureanchor3-20">Figure 3-20</a>). The chip is internally bonded to a carrier board that has the solder balls on it.</p>
<figure>
<img src="image_fi/278748c03/f03020.png" alt="f03020"/>
<figcaption><p><a id="figure3-20">Figure 3-20</a>: Plastic BGA</p></figcaption>
</figure>
<p><em>Fine pitch BGAs (FPBGAs)</em> are similar to PBGAs, but with a finer grid (typically 0.4 mm to 0.8 mm). Again, the device is mounted on a carrier PCB.</p>
<h4 id="h3-278748c03-0013">Thermally Enhanced Ball Grid Array</h4>
<p class="BodyFirst">The <em>thermally enhanced ball grid array (TEBGA)</em> shown in <a href="#figure3-21" id="figureanchor3-21">Figure 3-21</a> has a noticeable metal area on the BGA itself.</p>
<figure>
<img src="image_fi/278748c03/f03021.png" alt="f03021"/>
<figcaption><p><a id="figure3-21">Figure 3-21</a>: Thermally enhanced ball grid array</p></figcaption>
</figure>
<p>This metal area is part of an integrated heat spreader, which helps provide a better thermal connection to both the bottom solder balls and a heatsink mounted on top of the package.</p>
<h4 id="h3-278748c03-0014">Flip-Chip Ball Grid Array</h4>
<p class="BodyFirst"><em>Flip-chip BGAs (FC-BGAs)</em>, as shown in <a href="#figure3-22" id="figureanchor3-22">Figure 3-22</a>, do away with the internal bond wires. Instead, the chip itself is effectively a much smaller BGA (which <span epub:type="pagebreak" title="94" id="Page_94"/>would be difficult to work with) that is soldered on to the carrier PCB. The difference here is that the internal “LSI chip” is <em>upside down</em> compared to the previous BGA devices.</p>
<figure>
<img src="image_fi/278748c03/f03022.png" alt="f03022"/>
<figcaption><p><a id="figure3-22">Figure 3-22</a>: Flip-chip ball grid array</p></figcaption>
</figure>
<p>On other packages, such as PBGA/FBGA/TEBGA, internal bond-wires touch the “top metal” layer of the internal LSI chip. On the FC-BGAs, that top metal layer is on the bottom, with very small solder balls mounted on it. This type of package also may have small integrated passives, such as decoupling capacitors. With FC-BGAs, it may be possible to remove the heat spreader or “lid” to get closer to the actual chip for fault injection or side-channel analysis.</p>
<h3 id="h2-278748c03-0009">Chip Scale Packaging</h3>
<p class="BodyFirst"><em>Chip scale packaging (CSP)</em> is effectively where you are given a piece of the sawed-off chip wafer. In the internal structure shown in <a href="#figure3-23" id="figureanchor3-23">Figure 3-23</a>, there is no encapsulant on the top side.</p>
<figure>
<img src="image_fi/278748c03/f03023.png" alt="f03023"/>
<figcaption><p><a id="figure3-23">Figure 3-23</a>: CSP internal structure</p></figcaption>
</figure>
<p>The provided device is almost no bigger than it physically needs to be, and typically some very fine-pitch balls on the bottom of the CSP provide the connection to the PCB. The name CSP may have modifiers, such as the <em>wafer-level CSP (WLCSP)</em>. Think of CSPs as the LSI chip part of the flip-chip BGA. They have a very small pitch (0.4 mm or finer typically). You can often easily spot these devices, as the surface will look noticeably different from a regular BGA.</p>
<h3 id="h2-278748c03-0010"><span epub:type="pagebreak" title="95" id="Page_95"/>DIP, Through-Hole, and Others</h3>
<p class="BodyFirst">The oldest<em> </em>packages are through-hole, and you aren’t too likely to run into them on real products, especially for ICs. You <em>will </em>encounter the DIP package in hobby or kit products (such as an Arduino).</p>
<p>Another relatively outdated technology is <em>plastic leaded chip carrier (PLCC)</em>, which can be either soldered directly to a PCB or placed in a socket. These devices were often used for microcontrollers, and if you are looking at an old product using an 8051 microcontroller, you may well run into one.</p>
<h2 id="h1-278748c03-0003">Sample IC Packages on PCBs</h2>
<p class="BodyFirst">Rather than provide a bunch of photos of parts by themselves, we thought it would be more useful to show what they look like in-circuit. Let’s look at four sample boards pulled from real products. <a href="#figure3-24" id="figureanchor3-24">Figure 3-24</a> shows a communications daughterboard from a smart lock.</p>
<figure>
<img src="image_fi/278748c03/f03024.png" alt="f03024"/>
<figcaption><p><a id="figure3-24">Figure 3-24</a>: Example IC packages from a smart lock</p></figcaption>
</figure>
<p>The three packages marked in <a href="#figure3-24">Figure 3-24</a> are as follows:</p>
<ol class="decimal">
<li value="1"><b>QFN package</b>: The main microcontroller on this device (EM3587).</li>
<li value="2"><b>WSON package</b>: SPI flash chip (this package size is frequently used for SPI flash).</li>
<li value="3"><b>BGA package</b>: We can’t see any edge connections, so it’s likely a small BGA.</li>
</ol>
<p>Let’s take a different smart lock device and see what we can find (see <a href="#figure3-25" id="figureanchor3-25">Figure 3-25</a>).</p>
<span epub:type="pagebreak" title="96" id="Page_96"/><figure>
<img src="image_fi/278748c03/f03025.png" alt="f03025"/>
<figcaption><p><a id="figure3-25">Figure 3-25</a>: IC package examples from another smart lock</p></figcaption>
</figure>
<p><a href="#figure3-25">Figure 3-25</a> shows the following:</p>
<ol class="decimal">
<li value="1"><b>Eight-pin SOIC</b>: This might be SPI flash based on an eight-pin SOIC (the part number confirms it’s SPI flash).</li>
<li value="2"><b>TQFP package</b>: The main microcontroller for this device.</li>
<li value="3"><b>QFN package</b>: The co-processor chip (in this case, for audio).</li>
<li value="4"><b>Eight-pin wide SOIC package</b>: This is certainly SPI flash due to the wide package.</li>
<li value="5"><b>TSOP/TSSOP package</b>: Unknown IC.</li>
<li value="6"><b>TSON package</b>: Unknown IC.</li>
</ol>
<p>Continuing with our consumer electronics examples, next let’s look at a board from a smart doorbell (see <a href="#figure3-26" id="figureanchor3-26">Figure 3-26</a>).</p>
<figure>
<img src="image_fi/278748c03/f03026.png" alt="f03026"/>
<figcaption><p><a id="figure3-26">Figure 3-26</a>: IC package examples from a smart doorbell</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="97" id="Page_97"/><a href="#figure3-26">Figure 3-26</a> shows the following:</p>
<ol class="decimal">
<li value="1"><b>A very small BGA</b>: Unknown IC.</li>
<li value="2"><b>TSON-style very small device (pins on two sides only)</b>: Unknown IC.</li>
<li value="3"><b>QFN-style very small device (pins on all four sides)</b>: Unknown IC.</li>
<li value="4"><b>CSP package with an almost mirror-like finish</b>: The main microcontroller, BCM4354KKUBG. Underneath this device are 395 balls with 0.2 mm spacing (we told you CSP is small).</li>
</ol>
<p>As a final example, <a href="#figure3-27" id="figureanchor3-27">Figure 3-27</a> shows a board from an automotive electronic control unit (ECU).</p>
<figure>
<img src="image_fi/278748c03/f03027.png" alt="f03027"/>
<figcaption><p><a id="figure3-27">Figure 3-27</a>: IC packages from an automotive ECU</p></figcaption>
</figure>
<p><a href="#figure3-27">Figure 3-27</a> shows the following:</p>
<ol class="decimal">
<li value="1"><b>BGA package</b>: The main processor for this device.</li>
<li value="2"><b>TSSOP package</b>: Digital flip-flop.</li>
<li value="3"><b>QFP package (only the edge is visible here)</b>: Unknown IC.</li>
<li value="4"><b>SOIC package</b>: Digital logic gate.</li>
<li value="5"><b>TSSOP package</b>: Two unknown ICs.</li>
</ol>
<h3 id="h2-278748c03-0011"><span epub:type="pagebreak" title="98" id="Page_98"/>Identifying Other Components on the Board</h3>
<p class="BodyFirst">Now that you’ve looked at the main ICs, let’s explore some other components.</p>
<h4 id="h3-278748c03-0015">Ports</h4>
<p class="BodyFirst">Ports are a good starting point for making connections to a device and understanding the function of the various components they interconnect. The ports for digital I/O are the most interesting, as they may be used for normal device communication or provide debugging interfaces.</p>
<p>Once you identify the port type based on its appearance, you typically find the type of protocol used on the port. (See <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> for a refresher on various port protocols.) If you can’t identify the port based on appearance alone, hook up an oscilloscope to measure voltages and recognize data patterns. Note the high and low voltages, as well as the duration of the shortest pulse you see. The shortest pulse will give you the <em>bitrate</em>, such as an 8.68 microsecond pulse, which translates into an 115,200 bitrate on a UART. The bitrate is typically the rate of toggling of a single bit; the shortest pulse normally indicates a 0 or 1. We get the rate by taking the inverse. In this case, 1 / 0.00000868 = 115,207, and we round it to a standard baud rate of 115,200.</p>
<p>Alternatively, trace the PCB lines from the port to an IC and then use information from the IC’s pinout to identify the port type.</p>
<h4 id="h3-278748c03-0016">Headers</h4>
<p class="BodyFirst"><em>Headers </em>are basically internal ports and therefore are interesting to look at because they may expose some functionality that’s not intended for normal users but instead is included in the design for debugging, manufacturing, or repair. You may find, among others, JTAG, UART, and SPI/I2C ports internally. Sometimes headers are not actually installed on the PCB, but their solder pads are still there, so some easy soldering can provide access. <a href="#figure3-28" id="figureanchor3-28">Figure 3-28</a> shows an example of several surface-mount headers.</p>
<figure>
<img src="image_fi/278748c03/f03028.png" alt="f03028"/>
<figcaption><p><a id="figure3-28">Figure 3-28</a>: PCB headers</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="99" id="Page_99"/>The middle header is marked JTAG. This header wasn’t mounted, but we soldered it onto the pads, which provided JTAG access to the main IC, as the IC did not have any memory read-out protection enabled. This particular header was an Ember Packet Trace Port Connector. See Appendix B for several handy header pinouts.</p>
<p>Through-hole headers are easier to probe, but small devices probably need a surface-mount header. <a href="#figure3-29" id="figureanchor3-29">Figure 3-29</a> shows a classic UART header inside a device.</p>
<figure>
<img src="image_fi/278748c03/f03029.png" alt="f03029"/>
<figcaption><p><a id="figure3-29">Figure 3-29</a>: A UART header in a device</p></figcaption>
</figure>
<p>The header is the four pins in a row marked with “J404” on the board (note that J404 is upside down in the figure). There is no “standard” pinout for this header. You’ll need to perform some reverse engineering of it. The pin on the left can be visually seen to connect to the larger “ground plane,” and you could confirm this with a multimeter. We’ll cover this later in the section “Mapping the PCB” on page <span class="xref" itemid="xref_target_102">102</span>.</p>
<h4 id="h3-278748c03-0017">Analog Electronics</h4>
<p class="BodyFirst">Most of the small components you find are analog electronics (resistors and capacitors), although you can also find inductors, oscillators, transistors, and diodes as SMDs. Capacitors and resistors have specific characteristics pertinent to this book. The PCB shown in <a href="#figure3-30" id="figureanchor3-30">Figure 3-30</a> has many of them.</p>
<p>Capacitors (like C31 in <a href="#figure3-30">Figure 3-30</a>) can store and release little bits of charge, and they’re often used to filter a signal. Capacitors are like very fast and small rechargeable batteries. They can charge and discharge millions of times per second, which means any fast voltage swings are counteracted either by charging or discharging the capacitor. The effect is that of a “low-pass filter.” This is one of the reasons you’ll see a lot of capacitors around <span epub:type="pagebreak" title="100" id="Page_100"/>ICs, connected between the power supply and ground. In this function, they are called <em>decoupling capacitors</em>, and their role is to provide a localized source of power for the IC, which prevents electrical noise from being injected into the power line. They also help keep noise from other areas from reaching the IC. We discuss <em>voltage fault injection (VFI)</em> more in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>, but imagine that if VFI relies on fast changes in supply voltage, decoupling capacitors undo the effects of VFI. Therefore, we first remove as many decoupling capacitors as we can without letting the system become unstable.</p>
<figure>
<img src="image_fi/278748c03/f03030.png" alt="f03030"/>
<figcaption><p><a id="figure3-30">Figure 3-30</a>: Surface-mount resistors and capacitors</p></figcaption>
</figure>
<p>Resistors (like R26 in <a href="#figure3-30">Figure 3-30</a>), as the name implies, resist the flow of current, and for our purposes, the most interesting functions are that of a shunt resistor, a pullup/pulldown resistor (explained in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>), and a zero-ohm resistor. Shunt resistors measure the current through an IC when doing side-channel analysis (see <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span> for more details). Surface-mount resistors typically have a number printed on them that indicates the resistance value; for example, abc refers to ab × 10<sup>c </sup>ohm resistance.</p>
<p>Finally, zero-ohm resistors (like R29 in <a href="#figure3-30">Figure 3-30</a>) may seem a bit mysterious because they offer no resistance; they are basically wires. Their raison d’être is allowing configuration of a board at manufacturing time: zero-ohm resistors can be installed using the same manufacturing <span epub:type="pagebreak" title="101" id="Page_101"/>techniques as other resistors. By placing them, or not placing them, an electrical circuit can be open or closed, which can be used, for instance, as a configuration input to ICs. (As an example, recall the section “The Boot Configuration Pins,” on page <span class="xref" itemid="xref_target_85">85</span>, regarding the BOOT_MODE of the NXP i.MX53.) A manufacturer can choose to have the same PCB design for debug and production boards but then use a zero-ohm resistor on the relevant pins to select between the boot modes of those boards. That’s why zero-ohm resistors are interesting to look for; they can change security-sensitive configurations because they are easily removed or created. A solder blob across nearby pads is sufficient to simulate a zero-ohm resistor.</p>
<p>You also may encounter package size markings, such as <em>0603</em>. This refers to the rough physical size of the resistor or capacitor; for instance, 0603 is about 0.6 × 0.3 mm. SMT components may go down to 0201, although that continues to be pushed smaller as technology improves and consumer devices get smaller.</p>
<h4 id="h3-278748c03-0018">PCB Features</h4>
<p class="BodyFirst">Other interesting features we see on top of PCBs include jumpers and test points. <em>Jumpers</em><em> </em>(sometimes called <em>straps</em>) are used for configuring a PCB by opening or closing them as a particular circuit is open or closed. They perform exactly the same function as zero-ohm resistors, except they’re easily inserted or disconnected. They typically look like headers with two or three pins that have a small removable connector on them, which is used, for example, as an input to configure particular ICs (see BOOT_MODE described earlier for the NXP i.MX53). Jumpers are particularly interesting, as they may provide access to security-sensitive configurations. <a href="#figure3-31" id="figureanchor3-31">Figure 3-31</a> shows the pads where a jumper header labeled JP1 could be installed.</p>
<figure>
<img src="image_fi/278748c03/f03031.png" alt="f03031"/>
<figcaption><p><a id="figure3-31">Figure 3-31</a>: Jumper header pads</p></figcaption>
</figure>
<p><em>Test points</em> are used during manufacturing, repair, or debugging to provide access to particular PCB traces. Test points can be as minimal as a pad on the PCB, which can be connected to using a pogo pin, full-blown header, or connector.</p>
<p><span epub:type="pagebreak" title="102" id="Page_102"/><a href="#figure3-32" id="figureanchor3-32">Figure 3-32</a> shows the exposed traces that can be used for probing.</p>
<p>As you can see in the photo, test points can also be small, exposed metal components that an oscilloscope probe can touch.</p>
<figure>
<img src="image_fi/278748c03/f03032.png" alt="f03032"/>
<figcaption><p><a id="figure3-32">Figure 3-32</a>: Test points</p></figcaption>
</figure>
<h2 id="h1-278748c03-0004">Mapping the PCB</h2>
<p class="BodyFirst">Now let’s look at the PCB itself. The process of sleuthing the circuit design from the PCB is known as <em>reverse engineering</em>. In the section “Datasheets and Schematics” on page <span class="xref" itemid="xref_target_77">77</span>, we introduced schematics and layouts and how to read them. The board layout (encoded in a Gerber file) is sent to manufacturing facilities for production. It’s rare we’d have access to this (we cheated in the earlier example by using an open source product). We’re actually interested in the reverse process: from a physical product, we want to get back to (the security sensitive part of) the schematic.</p>
<p>This exercise is useful, as we often know there are certain signals on an IC we want to access, such as some of those boot mode pins we identified before. Or, we often know there is a debug or serial header on the IC, and we want to figure out the pinout of the header on the PCB.</p>
<p>For the topics of fault injection and power analysis, we often need to target a certain power supply net. In this case, we might have one IC that is the power management IC, and we want to see which other ICs it is powering. For this purpose, we need to follow the power supply traces from one IC to another.</p>
<p>The PCB exists to transport power and signals between its components (such as our IC and header that we just mentioned). It’s basically a sandwich of conductive material, isolating material, and components. The PCB consists of a couple to dozens of layers, each electrically isolated from each other. The <em>traces </em>look like lines on the PCB, and the <em>vias</em><em> </em>look like holes in the PCB at the end of a trace (see <a href="#figure3-33" id="figureanchor3-33">Figure 3-33</a>). The vias connect to further traces on other layers inside or on the PCB. Typically, components are located on the front and back of the PCB.</p>
<span epub:type="pagebreak" title="103" id="Page_103"/><figure>
<img src="image_fi/278748c03/f03033.png" alt="f03033"/>
<figcaption><p><a id="figure3-33">Figure 3-33</a>: Traces and vias; vias may be covered (<em>tented</em>), as in this photo, or exposed (<em>untented</em>)</p></figcaption>
</figure>
<p>A PCB’s outer sides have printed markings that identify components as well as company logos, PCB part numbers, and other artwork. These markings are called the <em>silkscreen</em>, which can be helpful when relating a PCB schematic to an actual PCB. Also, it can be hours of fun trying to find resistor R33 in the sea of other labeled components. All the text and lines on the PCB shown in <a href="#figure3-30">Figure 3-30</a> are part of the silkscreen.</p>
<p>When you’re mapping IC pinouts to a board, it’s good to know that pin 1 of a chip is usually identified on the silkscreen (and on the IC package itself) as a dot.</p>
<p>The following reference designators are helpful to memorize, although you also may find other designators for these components: </p>
<ul>
<li>C = capacitor</li>
<li>R = resistor</li>
<li>JP = jumper</li>
<li>TP = test point</li>
<li>U = IC</li>
<li>VR = voltage regulator</li>
<li>XTAL or Y = oscillator (crystal)</li>
</ul>
<p><span epub:type="pagebreak" title="104" id="Page_104"/>You can try to follow PCB traces visually, but doing so quickly becomes tricky, so the most common way is to grab your favorite multimeter and set it to measure resistance (remember, it’s nice to have a multimeter that beeps, so you don’t need to watch it the entire time). Before you start measuring, it’s important to know that all traces are covered in a <em>solder mask</em>, which is the layer that makes the PCB green, red, black, or other color. The solder mask prevents corrosion and accidental solder bridges during manufacturing. A solder mask is nonconducting, so you can’t use your multimeter to get to the trace. However, you can scrape off the solder mask pretty easily, even with the tip of your multimeter probe, to expose the copper of the trace.</p>
<p>The multimeter measures resistance by applying a small current across the probes and measuring the voltage across the probes for the given test current. This is simply solving Ohm’s law (<em>V</em> = <em>I</em> × <em>R</em>) for resistance. Because of this, you can only use the multimeter on unpowered circuits. Any voltage present in the circuit will at best confuse and at worst damage the multimeter.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">note</span></h2>
<p>	The multimeter should only be used in resistance mode on an unpowered circuit (see text). But with the circuit unpowered, the act of probing random nets is introducing small voltages into the circuit, which could damage extremely sensitive parts. This is unlikely in practice due to the small current used by most multimeters, and we assume you aren’t returning the devices to service (don’t try to reverse engineer your pacemaker before it’s implanted in your body, for example).</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The traces carry I/O signals, like JTAG, I2C, or DRAM bus signals, and they can also form power and ground planes. Signals usually go between two ICs, or between an IC and a port or header. If you’re using a multimeter as we suggest, be aware that certain types of parts can still confuse the multimeter. Large capacitors will often look like shorts, as the small test current is very slowly charging the capacitor, which gives a reading similar to a low resistance. Semiconductor components may also read as a low resistance one way, so if you are seeing a signal that appears to be connected to nonsensical areas, be suspicious about your measurement. Normally, a direct short (0 Ω, where your meter and probe resistance could measure in the 0 to 10 Ω range) is a “real” connection; any higher resistance values may be artifacts of the circuit elements.</p>
<p>From the IC pins, it’s common to see pullup or pulldown resistors connected to the IC pins. These are normally not the “final destination” of the net, so you will want to probe further in most cases. If you see a lot of connections, it may be the ground net; a single ground plane usually goes everywhere on the PCB. Each IC has at least one ground pin. Metal casings of ports are typically ground, and any connector is certain to have ground connected to at least one of its pins. Bigger ICs can have dozens of ground pins in order to divide the current load over multiple pins. ICs may also have separate analog and digital ground pins. The large voltage differentials caused by digital switching on digital lines causes a lot of noise on ground traces, so they can be isolated from analog circuitry by having a <span epub:type="pagebreak" title="105" id="Page_105"/>separate ground. At some point, the PCB connects these digital and analog grounds together. You can usually find ground at metal cases on ports or marked by the text <em>GND</em> on the silkscreen.</p>
<p>Sometimes the metal cases on ports (normally called the shield) don’t connect directly to the digital ground, so always do a quick sanity check between some potential ground points before you dive too far in.</p>
<p>The PCB can have one or many power planes, each typically providing different voltages to components, particularly to the larger ICs. Common voltages that may be identified by text on the silkscreen are 5 V, 3.3 V, 1.8 V, and 1.2 V.</p>
<p>The various voltages are generated by <em>voltage regulators</em> or <em>power management ICs (PMICs)</em>. Voltage regulators are dumb components that convert the basic raw voltage connected to the PCB into a wide range of stable voltages. For instance, the LD1117 takes in a raw voltage of anything between 4 V and 15 V and converts it to 3.3 V. PMICs are found in more complex devices like mobile phones. They provide the various voltages, but they can be externally instructed to switch various voltages on or off. They may communicate with the SoC that they are powering via a protocol such as I2C so that if the OS in the SoC needs to run faster, it can instruct the PMIC to increase the supply voltage. Voltage drops may occur along traces when conducting high currents, so feedback circuitry to the PMICs can verify the voltage arriving at the components, allowing the PMIC to adjust the voltage where necessary.</p>
<p>Sometimes you want to bypass the PMIC and provide your own power source (for instance, for fault injection). At first, it may seem tricky, as the PMIC may go through complex voltage sequencing during boot and operation, but in practice we’ve rarely seen an issue with just supplying a constant voltage. Our guess is that this sequencing is all to save battery power, and the IC’s operation doesn’t seem to suffer if you don’t do this. Further, when providing your own power, you want to keep the feedback loop intact. So, substitute your own independent power supply only to the IC you are investigating. You want the PMIC to stay happy, because it may be holding the main IC in reset until it sees a stable output voltage.</p>
<p>With these basics, you can start determining the answers to the following questions:</p>
<ol class="decimal">
<li value="1">At what voltage level is the IC or I/O channel running? Power on the device and measure the steady voltage between ground and the relevant IC pin or on the PCB trace nearby.</li>
<li value="2">What is the ground plane connected to? The metal casing of any port is going to be ground. You can use that as a reference, and after removing power from the device, identify all other ground points, on IC pins and connectors, by performing the beep test described earlier.</li>
<li value="3">How is power distributed on the PCB? You can either measure voltages on all pins, as before, or use the beep test to identify all points connected to the same power plane.</li>
<li value="4"><span epub:type="pagebreak" title="106" id="Page_106"/>What are the JTAG pins connected to? Let’s say you’ve identified the JTAG pins of the IC, but you want to know to which header or test point they are connected. Use the beep test between a JTAG IC pin and all “suspect” points on the board. If you really want to go pro, take a wire and fray one of the ends into a “fan,” as shown in <a href="#figure3-34" id="figureanchor3-34">Figure 3-34</a>. Connect one of your probe pins to the wire and “sweep” the board, which is much more efficient than having to touch every point manually. If you want to get fancy, you can also buy small metal brushes to accomplish the same goal.</li>
</ol>
<figure>
<img src="image_fi/278748c03/f03034.png" alt="f03034"/>
<figcaption><p><a id="figure3-34">Figure 3-34</a>: Continuity sweeper</p></figcaption>
</figure>
<p>For more information on reverse engineering a PCB, take a look at Joe Grand’s “Printed Circuit Board Deconstruction Techniques” USENIX paper. If you’d like to dig deeper on the design side, the book <em>Printed Circuit Board Designer’s Reference: Basics</em> (Prentice Hall, 2003), by Christopher T. Robertson, explains how PCBs are physically made. For more reverse engineering techniques, see Ng Keng Tiong’s <em>PCB-RE: Tools &amp; Techniques</em> (CreateSpace Independent Publishing, 2017).</p>
<h3 id="h2-278748c03-0012">Using the JTAG Boundary Scan for Mapping</h3>
<p class="BodyFirst">So far, we’ve mostly discussed passive methods of reverse engineering the connections on a PCB. In the previous chapter, we mentioned the existence of the JTAG boundary scan mode. With boundary scan, we can use a chip to drive a signal on the board and use measurement equipment to find out <span epub:type="pagebreak" title="107" id="Page_107"/>where that signal is routed. Boundary scan can also be used to sense signals on a chip’s pin, which means we can drive a signal on the board and figure out to which pin it is routed.</p>
<p>Boundary scan requires us to power up the board as part of the reverse engineering. It also requires a little bit of information first. We need a JTAG header to run this! Typically, using JTAG boundary scan will be a step after we’ve done some basic reverse engineering. It also requires us to have a JTAG Boundary Scan Description Language (BSDL) file for the device in question, and the device itself to have JTAG boundary scan enabled (not everything will).</p>
<p>Let’s take an example of an automotive ECU. The E82 ECU uses an NXP MPC5676R device. We can find a BSDL file for the MPC5676R chip with a simple online search, which means it’s worth trying to get a JTAG interface connected to it. Inspecting the board shows an unmounted 14-pin header that’s suspiciously like the 14-pin JTAG commonly used by these devices. We mount a header to this and connect a JTAG adapter (see <a href="#figure3-35" id="figureanchor3-35">Figure 3-35</a>).</p>
<figure>
<img src="image_fi/278748c03/f03035.png" alt="f03035"/>
<figcaption><p><a id="figure3-35">Figure 3-35</a>: JTAG header and adapter connected to E82 ECU; a 1 kΩ resistor is used to drive a 1 Hz square wave into test points</p></figcaption>
</figure>
<p>Next, we use TopJTAG software to load the BSDL file and put the chip in <em>EXTEST</em> mode. In this mode, we have complete control of the chip I/O pins. Some risk is involved because you may cause havoc by just flipping random pins (for instance, accidentally signaling a power supply to turn on or off). There is also <em>SAMPLE</em> mode, which means the chip is still running; it may be driving outputs high or low, preventing effective mapping. We’ll stick to <em>EXTEST</em>.</p>
<p><span epub:type="pagebreak" title="108" id="Page_108"/>TopJTAG shows JTAG boundary scan connectivity; that’s good news for our ease of reverse engineering. We end up with a screen in the software like <a href="#figure3-36" id="figureanchor3-36">Figure 3-36</a>.</p>
<figure>
<img src="image_fi/278748c03/f03036.png" alt="f03036"/>
<figcaption><p><a id="figure3-36">Figure 3-36</a>: The TopJTAG software uses a BSDL file to show a graphical view of the pin state. </p></figcaption>
</figure>
<p>In <a href="#figure3-36">Figure 3-36</a>, you can see the state of each pin on the device. This is a “live” view, so if the external voltage on the pin changes, we can see the color change in this picture or the I/O value change in the table.</p>
<p>To map a test point to a pin, we can drive a square wave on the test point using a signal generator. You can see this in <a href="#figure3-35">Figure 3-35</a>, where a 1 kΩ resistor is used to drive a low-current square wave onto the board. We should see the associated pin toggling on the TopJTAG screen. If you don’t have a signal generator, you can also connect one end of a 1 kΩ resistor to a VCC point on the board and tap the other end on the test point.</p>
<p>Using the software, you could also do the opposite: by toggling a signal from a particular pin, you can measure in various places on the board to find out where that pin is connected. Unfortunately, there is no feature in the software to generate a waveform, but with the CTRL-T hotkey, you can do this manually (or find some keypress-injection software). We’ll discuss the tools you require to perform this type of work in Appendix A. Joe Grand’s JTAGulator can be used to automatically map test points to boundary scan bits, for example.</p>
<h2 id="h1-278748c03-0005"><span epub:type="pagebreak" title="109" id="Page_109"/>Information Extraction from the Firmware</h2>
<p class="BodyFirst">Firmware images contain most of the code running on a device, so taking a peek at them is usually very interesting in order to find a point of attack. So far, we’ve mostly been discussing information we can see with our eyes or simple electrical tests. We’re now going to take a quantum leap in complexity and detail how you can actually work with firmware. At first glance, this looks like a major departure from the nitty-gritty details of the PCB, but if you think back to our overall goal of information gathering, analyzing the firmware is a critical step (and in many cases, the most important step). In the rest of the book, we discuss many operations that depend on firmware. Understanding how to find cryptographic signatures, for example, is an important part of knowing where you can apply fault injection; seeing code that could be referencing a signature is a good sign that you can find the location of the signature check routine.</p>
<h3 id="h2-278748c03-0013">Obtaining the Firmware Image</h3>
<p class="BodyFirst">With the device physically in front of you, and fresh off a discussion of JTAG, you might assume we’re going to extract the firmware image from the device. But taking the path of least resistance, we first check whether we can obtain the firmware image by downloading it from an update website or, if the device has Linux support, checking the <em>/lib/firmware</em> directory.</p>
<p>The image may be available as a separate file for download or embedded in an installer package. In case of the former, skip to the next section; in case of the latter, use your software reverse engineering skills to find the update file in the installation directory. One trick is to do a plain string search for a known string that the device prints out, although firmware images may often be compressed, and you won’t find the plain string. You can use the binwalk tool to find LZMA files or deflate (zlib/gzip) compressed images inside files. In fact, we’ll use binwalk later to carve up the firmware image itself to analyze further. Alternatively, you can perform the update and then sniff the image off the communication channel during a firmware update with a tool like Wireshark for Ethernet connections or socat for Linux.</p>
<p>Some devices support the USB Direct Firmware Update (DFU) standard, which is used for downloading and uploading firmware images to and from a device. If the target supports it, it will typically be enabled as an alternative boot mode. For instance, a mode could be set through a jumper, or a mode may be automatically chosen if the onboard firmware image is corrupted. You may be able to corrupt the image-loading process by a fault injection, which could be as simple as shorting out a data line, causing corrupted data to be loaded. Once you have DFU mode, you may be able to upload (extract) the firmware image. The dfu-util tool can perform this if it supports the device and if the device supports uploading.</p>
<p>The device may also support its own proprietary protocol that is also called DFU mode, and it may have more than one recovery mode. For example, iPhones and iPads typically have a “recovery mode” that allows you to reflash the device over USB and run firmware that Apple can update. <span epub:type="pagebreak" title="110" id="Page_110"/>In addition, a separate “DFU mode” runs immutable ROM code that allows you to reflash the device over USB. The “DFU Mode” is a proprietary protocol and does not implement the USB standard DFU mode.</p>
<p>If you’ve exhausted the software means of obtaining an image or just are in the mood for a hardware attack, you can attempt to extract the firmware from a flash chip. This is only <em>simply</em> done on an external flash chip. Some SoCs have an internal flash, which is accessible only through chip-level reverse engineering and microprobing after decapping, and therefore is beyond the scope of this book.</p>
<p>To get the flash chip off the board, you need to desolder it, which isn’t as hard as it sounds, but it does require a hot-air working station. The off-the-shelf method for obtaining the image is to purchase a memory reader. If you want minimal fuss, something from the FlashcatUSB series is a good bet. Models from this company support both SPI and parallel flash chips, and they range from low to medium cost.</p>
<p>You’ll see all sorts of other methods of reading SPI flash memory as well. Solutions have been made with Arduino Teensy devices and Raspberry Pis. Jeong Wook (Matt) Oh’s “Reverse Engineering Flash Memory for Fun and Benefit,” from Black Hat 2014, describes a DIY approach to getting the image and is a great way to learn about creating hardware to interface with flash chips and flash chip memory encodings. It walks through the process of attaching a chip and reading it by bit-banging through an FTDI FT2232H.</p>
<p>Speaking of reading flash memory onboard, we should also mention how you can read eMMC chips. These chips are basically SD cards in chip form, as mentioned in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>. Thanks to some nice backward compatibility, you can run them in 1-bit mode (meaning you need only GND, CLK, CMD, and D0). <a href="#figure3-37" id="figureanchor3-37">Figure 3-37</a> shows an example of an SD card interposer connected to read out eMMC memory.</p>
<figure>
<img src="image_fi/278748c03/f03037.png" alt="f03037"/>
<figcaption><p><a id="figure3-37">Figure 3-37</a>: On this board, the eMMC flash connections (on the bottom of the board, not visible) were accessible on several pads onto which we could mount pin headers.</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="111" id="Page_111"/>In this example, we’re holding the target processor in reset by grounding the nRST pin, so we can then plug the SD card into the USB SD card reader. Holding the target processor in reset is needed, as otherwise it would attempt to toggle the I/O lines at the same time. We can then mount the filesystem on the SD card on our computer. In this example, it was a standard filesystem readable in Linux. The talk “Hardware Hacking with a $10 SD Card Reader” by Amir “Zenofex” Etemadieh, CJ “cj_000” Heres, and Khoa “maximus64” Hoang, at Black Hat 2017 and the Exploitee.rs Wiki, is a valuable resource.</p>
<h3 id="h2-278748c03-0014">Analyzing the Firmware Image</h3>
<p class="BodyFirst">The next task is to analyze the firmware image. It will have multiple blocks for different functional components—for example, various stages of the bootloader, digital signatures, key slots, and a filesystem image. The first step is to dissect the image into its components. Each component may be plaintext, compressed, encrypted, and/or signed. Binwalk is a useful tool for finding all components in a firmware image. It recognizes different sections by matching them against the “magic” bytes that encode different file types.</p>
<p>For encrypted data, you first need to figure out the encryption used and the key. Your best bet is to do side-channel analysis (see Chapters 8–12). Common options are AES-128 or AES-256 in CTR or CBC mode, although we’ve also seen ECB and GCM used. Once you have the key, you can decrypt the image for further analysis. For how to deal with digital signatures, see the “Signatures” section on page <span class="xref" itemid="xref_target_116">116</span>.</p>
<p>Once you have an image with plaintext or compressed blocks, binwalk can help with the following:</p>
<ul>
<li>Detecting various files, filesystems, and compression methods within the image, using the <code>--signature</code> option.</li>
<li>Extracting the different components with the <code>--carve</code>, <code>--extract</code>, or <code>--dd</code> option. If you specify <code>--matryoshka</code>, this will be done recursively.</li>
<li>Detecting CPU architecture by analyzing opcodes in a file using <code>--opcode</code> or <code>--disasm</code>.</li>
<li>Searching for a fixed string using <code>--raw</code>.</li>
<li>Analyzing and graphing the Shannon entropy of a file using <code>--entropy</code> or the zlib compression ratio with the <code>--fast</code> option. Use <code>--save</code> to save the entropy plot to a file.</li>
<li>Doing a hexdump and diffing binary files with <code>--hexdump</code>.</li>
<li>Finding compressed data with missing headers by brute force, using <code>--deflate</code> or <code>--lzma</code>.</li>
</ul>
<p>As an example, let’s take a brief look at some device firmware we can easily download (in this case, firmware for the TP-Link TD-W8980 router). We’re looking at version TD-W8980_V1_150514 (found as <em>TD-W8980_V1_150514.zip</em>). Unzip it and then run binwalk like so:</p>
<pre><code><span epub:type="pagebreak" title="112" id="Page_112"/>$ <b>binwalk TD-W8980v1_0.6.0_1.8_up_boot\(150514\)_2015-05-14_11.16.43.bin</b>
DECIMAL       HEXADECIMAL     DESCRIPTION
-----------------------------------------------------------------------------------------------
17524         0x4474          CRC32 polynomial table, little endian
20992         0x5200          uImage header, header size: 64 bytes, header CRC: 0x8930352,
                              created: 2015-05-14 03:01:45, image size: 37648 bytes, Data
                              Address: 0xA0400000, Entry Point:    0xA0400000, data CRC:
                              0x1F36D906, OS: Linux, CPU: MIPS, image type: Firmware Image,
                              compression type: lzma, image name: "u-boot image" <span class="CodeAnnotationCode" aria-label="annotation1">1</span>
21056         0x5240          LZMA compressed data, properties: 0x5D, dictionary size: 8388608
                              bytes, uncompressed size: 101380 bytes
66048         0x10200         uImage header, header size: 64 bytes, header CRC: 0xBEC297,
                              created: 2013-10-25 07:26:06, image size: 41781 bytes, Data
                              Address: 0x0, Entry Point: 0x0, data CRC: 0xBECBCEC2, OS: Linux,
                              CPU: MIPS, image type: Multi-File Image, compression type: lzma,
                              image name: "GPHY Firmware" <span class="CodeAnnotationCode" aria-label="annotation2">2</span>
66120         0x10248         LZMA compressed data, properties: 0x5D, dictionary size: 8388608
                              bytes, uncompressed size: 131200 bytes
132096        0x20400         LZMA compressed data, properties: 0x5D, dictionary size: 8388608
                              bytes, uncompressed size: 3979748 bytes
1442304       0x160200        Squashfs filesystem <span class="CodeAnnotationCode" aria-label="annotation3">3</span>, little endian, version 4.0,
                              compression:lzma, size: 6265036 bytes, 592 inodes, blocksize:
                              131072 bytes, created: 2015-05-14 03:09:10</code></pre>
<p>The output (formatted for readability) reveals some interesting information: a u-boot bootloader image <span class="CodeAnnotation" aria-label="annotation1">1</span>, firmware for GPHY <span class="CodeAnnotation" aria-label="annotation2">2</span>, and a Squashfs filesystem (Linux) <span class="CodeAnnotation" aria-label="annotation3">3</span>. If you run binwalk with <code>--extract</code> and <code>--matryoshka</code>, you’ll get all these blocks as separate files, with compressed and decompressed versions of components, and the Squashfs filesystem unpacked.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	For more information on reverse engineering, take a look at <em>The IDA Pro</em> Book, 2nd edition (No Starch Press, 2011) by Chris Eagle. If you’re interested in embedded systems, check out the free, open source <em>Ghidra</em> tool, which supports many embedded processors and also includes a decompiler that provides a C language view of the binary. See also <em>The Ghidra Book</em> (No Starch Press, 2020) by Chris Eagle and Kara Nance.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>We’re focusing on hardware attacks on embedded systems, but one feature of software reverse engineering you may need is to identify encrypted blocks and signatures. Later chapters assume you have figured that out already, so we’ll walk through a sample analysis. Now, what we’ll find if we modify a file on the Squashfs filesystem (such as <em>/etc/passwd</em> or <em>/etc/vsftpd_passwd</em>) is that the router doesn’t accept the new firmware image. This is because an RSA-1024 signature is used to verify the image’s authenticity. The signature isn’t indicated in the binwalk output, because signatures are often just sequences of random-looking bytes as specific offsets. You can find those offsets through entropy analysis.</p>
<h4 id="h3-278748c03-0019">Entropy Analysis</h4>
<p class="BodyFirst"><em>Entropy</em> is used in computer science as a measure of information density. For our purposes, we use 8-bit entropy. An entropy of 0 means a block of data <span epub:type="pagebreak" title="113" id="Page_113"/>contains a single byte value, and an entropy of 1 means a block contains equal amounts of every byte value from 0 to 255. Entropy close to 1 is indicative of crypto keys, ciphertexts, or compressed data.</p>
<p>Full of hope and excitement, we run binwalk again with the <code>--nplot</code> and <code>--entropy </code>options:</p>
<pre><code>$ <b>binwalk TD-W8980v1_0.6.0_1.8_up_boot\(150514\)_2015-05-14_11.16.43.bin --nplot --entropy</b>

DECIMAL       HEXADECIMAL     ENTROPY
--------------------------------------------------------------------------------
0             0x0             Falling entropy edge (0.660092)
24576         0x6000          Rising entropy edge (0.993507)
57344         0xE000          Falling entropy edge (0.438198)
69632         0x11000         Rising entropy edge (0.994447)
106496        0x1A000         Falling entropy edge (0.447692)
135168        0x21000         Rising entropy edge (0.994445)
1417216       0x15A000        Falling entropy edge (0.000000)
1445888       0x161000        Rising entropy edge (0.993861)
7704576       0x759000        Falling entropy edge (0.779626)</code></pre>
<p>The binwalk tool calculates the entropy for each block and determines block boundaries by looking for large changes in entropy. This usually works by finding contiguous blocks of compressed or encrypted data and sometimes even works for finding key material. In this case, we’re looking for an RSA-1024 signature (which is 128 bytes), and there’s no such block.</p>
<p>If you run binwalk again, omitting the <code>--nplot</code> option, it produces the graph shown in <a href="#figure3-38" id="figureanchor3-38">Figure 3-38</a>.</p>
<figure>
<img src="image_fi/278748c03/f03038.png" alt="f03038"/>
<figcaption><p><a id="figure3-38">Figure 3-38</a>: Entropy output from binwalk using default settings</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="114" id="Page_114"/>The graph doesn’t show the 1,024-bit/128-byte signature we are looking for either. Although this signature may be embedded in one of those blocks, we already shot ourselves in the foot. The way we are using binwalk will never show a 128-byte peak. Remember how entropy is calculated over a block of data? This means binwalk chops the file into blocks of data and calculates the entropy over those blocks. By default, the block size appears to be 0x1000, or 4,096 bytes. If our 128 random bytes are embedded in a 4,096-byte block, the entropy is only marginally affected.</p>
<p>This is why binwalk has the <code>--block</code> option. It’s tempting to use a block size of 128 bytes now, but we’d still not have a nice entropy peak if the signature isn’t stored exactly within a single block. So, to be safe, we tend to use a block size of 16.</p>
<p>Now, we encounter another issue: execution is very slow. The output shows only the following:</p>
<pre><code>$ <b>binwalk TD-W8980v1_0.6.0_1.8_up_boot\(150514\)_2015-05-14_11.16.43.bin --save --entropy \</b>
<b>--block=16</b>

DECIMAL       HEXADECIMAL     ENTROPY
--------------------------------------------------------------------------------
0             0x0             Falling entropy edge (0.384727)</code></pre>
<p>That’s not very useful, as no blocks are identified at all. The output graph in <a href="#figure3-39" id="figureanchor3-39">Figure 3-39</a> also doesn’t show what we want.</p>
<figure>
<img src="image_fi/278748c03/f03039.png" alt="f03039"/>
<figcaption><p><a id="figure3-39">Figure 3-39</a>: Entropy output using 16-byte block size</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="115" id="Page_115"/>The reason is the calculation of entropy. It’s important to understand that for blocks smaller than 256 bytes, by definition, the entropy cannot be 1. Actually, an entropy of 1 is achieved only when each byte value has the same frequency in the block. If a block is smaller than 256 bytes, it’s impossible to have a frequency of 1 or more for each byte value; therefore, the entropy cannot be 1. In fact, the entropy is maximally 0.5 at a block length of 16.</p>
<p>Since binwalk does edge-detection for entropy, we need to tune the thresholds for a rising and falling edge. If the maximum entropy is 0.5, you can set, for example, <code>--high=0.45</code> and <code>--low=0.40</code>. Alternatively, you can find your own entropy “peaks” using the <code>--verbose</code> option, which just outputs the entropy for each block.</p>
<p>Of course, the edge detection doesn’t work. We get more than 2,000 edges. The reason is the calculation of entropy, again. Can you guess what the entropy is of <em>Glib jocks quiz nymph to vex dwarf</em>? With 16-byte blocks, the first block has an entropy of 0.447. This is because the smaller the block size, the higher the likelihood that a nonrandom sequence of bytes accidentally has only unique bytes, and therefore the highest entropy possible (in other words, we get false positives).</p>
<p>Let’s apply a bit of common sense. If we were to store a signature in an image, where would we do that? Likely it would be just before or just after the block we are protecting. Let’s take a look at the first 0x400 bytes:</p>
<pre><code>$ <b>binwalk --entropy --block 16 --high 0.45 --low 0.40 --save --length 0x400</b>

DECIMAL       HEXADECIMAL     ENTROPY
----------------------------------------------------------------------
0             0x0             Falling entropy edge (0.384727)
64          <span class="CodeAnnotationCode" aria-label="annotation1">1</span> 0x40            Rising entropy edge (0.500000)
80            0x50            Falling entropy edge (0.101410)
208         <span class="CodeAnnotationCode" aria-label="annotation2">2</span> 0xD0            Rising entropy edge (0.500000)
336           0x150           Falling entropy edge (0.000000)
608           0x260           Falling entropy edge (0.330848)
640           0x280           Falling entropy edge (0.378050)
688           0x2B0           Falling entropy edge (0.315223)
784           0x310           Falling entropy edge (0.165558)
912           0x390           Falling entropy edge (0.347580)
976           0x3D0           Falling entropy edge (0.362425)</code></pre>
<p>It seems there are two high-entropy sections: 16 bytes at <code>0x40</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and 128 bytes at <code>0xD0</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. The 128-byte block is clearly visible in the entropy plot in <a href="#figure3-40" id="figureanchor3-40">Figure 3-40</a>.</p>
<p>If you employ the skills described earlier in this chapter, you’ll have found the <a href="https://github.com/xdarklight/mktplinkfw3/" class="LinkURL">https://github.com/xdarklight/mktplinkfw3/</a><em> </em>project page, which documents the header format for this particular firmware image. You guessed it: 0xD0 is the RSA signature (and 0x40 is an MD5 sum).</p>
<span epub:type="pagebreak" title="116" id="Page_116"/><figure>
<img src="image_fi/278748c03/f03040.png" alt="f03040"/>
<figcaption><p><a id="figure3-40">Figure 3-40</a>: A more detailed entropy analysis, concentrating on areas of interest</p></figcaption>
</figure>
<h4 id="h3-278748c03-0020">Signatures</h4>
<p class="BodyFirst">For signed data, you’ll need the signing key or a way to bypass signature verification in order to load modified firmware (we discuss ways to bypass signature verification in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>).</p>
<p>Back to our firmware image: to check for data signing, modify a byte in the firmware image that wouldn’t cause execution to fail (for example, in a string constant such as a debugging or error message). If the device fails to boot with this image, it’s likely doing a signature verification or checksum. It’ll take some reverse engineering to find out which, although it may not be trivial. The code verifying at least the first firmware boot stage will be located in ROM, outside your view.</p>
<p>One thing you can look for is an RSA or elliptic curve cryptography (ECC) signature in the image, both of which are sequences of high-entropy bytes. An RSA-2048 signature will be 2,048 bits (256 bytes) long, and an ECDSA signature, for example, on the curve <em>prime256v1</em>, will have 256 × 2 = 512 bits of signature (64 bytes). Entropy spikes at the end or start of a block in the firmware may indicate a signature.</p>
<p>In addition, check the difference between two side-channel traces: one where you boot with a correct signature and one where you boot with a corrupted signature. This test allows you to pinpoint when the execution path <span epub:type="pagebreak" title="117" id="Page_117"/>diverges during the boot, which typically (but not necessarily) happens right after a signature verification. This information is also useful when you want to bypass signature verification using fault injection.</p>
<p>Finally, the image actually may be shipped with the public key used to verify its integrity, because space in ROM (or fuses) is limited and public keys (especially RSA) are rather large. This means you can search the firmware image for high-entropy sections that are a public key. For RSA-2048, the public key is the modulus of 2,048 bits and the public exponent. Very often, this exponent is 65,537 (or 0x10001). Finding 0x10001 next to a high-entropy section indicates an RSA public key. For ECC, public keys are points on the curve. There are a few ways to encode this—for example, in affine (x,y) coordinates, in which case the curve prime256v1 has 256 bits for x and y, or a total of 512 bits. A compressed encoding uses the fact that elliptic curves have only two possible values for y, given the curve and the point’s x coordinate, so a compressed notation for a point on prime256v1 has the full x coordinate (256 bits) and 1 bit of y, for a total of 257 bits. The “Standards for Efficient Cryptography, SEC 1: Elliptic Curve Cryptography” specifies a common encoding: a point is prefixed with 0x04 if it is uncompressed, and if it is compressed, it’s prefixed with 0x02 or 0x03, depending on the 1 bit for y.</p>
<p>You may be thinking, how is embedding a verification key with the object to verify secure? That could be easily forged! And you’d be right. To save space, the public key’s hash is typically stored in fuses. This means during boot, first the public key’s hash is verified against the stored hash and only then is it used to verify the image. This sequence gives attackers a second point for fault injection. They could create an image that embeds their own public key and sign the image with that key. Next, fault injection can be used to skip the key verification.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	You may wonder why the hash is in fuses instead of ROM. It’s because of manufacturing costs. Updating the ROM after a silicon mask is created is very expensive. Updating fuses during manufacturing is a matter of updating the manufacturing scripts, which isn’t expensive. This allows the same design to be used to create chips with different public keys.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Less common ways of signing a firmware image are with hash-based message authentication code (HMAC) or cipher-based message authentication code (CMAC). These authentication codes require distributing a symmetric key, which means either you have a “root key” programmed into each device (capable of verifying and signing arbitrary images) or you’re diversifying the symmetric keys per device but then need to encrypt each firmware image with a device-specific key. The first option is foolish; the second option is costly. The first option is also exactly what happened with the Philips Hue attack (see “IoT Goes Nuclear: Creating a ZigBee Chain Reaction” by Eyal Ronen et al.), so don’t always assume that you can rule something out because <em>surely no serious product would do it that way</em>.</p>
<h2 id="h1-278748c03-0006"><span epub:type="pagebreak" title="118" id="Page_118"/>Summary</h2>
<p class="BodyFirst">In this chapter, we explored how to collect useful information for hardware hacking attacks, which typically will be all you need. Devices often don’t have firmware encryption, for example, and once you have the ability to dump the firmware with JTAG, you can learn enough to exploit the device.</p>
<p>With any luck, we can learn enough to exploit a system directly, and if we are forced to use more advanced attacks, we understand how they might apply to our system. Since this book is about advanced attacks, we’ll assume they’re needed and dive head-first into how they work. We’ll combine the information-discovering techniques described here with the interfacing skills outlined in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> to test a system for fault injection weaknesses in the next chapter. </p>
</section>
</body></html>