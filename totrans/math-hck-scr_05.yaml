- en: '**5**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**From Sequences to Arrays**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you ask, “What value comes next?” you’re making an assumption that the
    values are arranged in one dimension, along a line. One value follows another
    in a sequence, such that there’s only one way to step from one item to the next.
    But we live in a world with more than one dimension, and it’s sometimes helpful
    to use more than one dimension to organize information.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an *array* is a two-dimensional object, a table of values organized
    in rows and columns. We can still look for patterns in an array of numbers, but
    now the patterns might show up as we move from row to row, from column to column,
    or along diagonals. In this chapter, we’ll use Scratch to study some interesting
    arrays. While Scratch makes it easy to explore one-dimensional sequences with
    its `list` data type, it doesn’t have a similar structure for two-dimensional
    arrays. We’ll have to develop some creative workarounds to represent arrays in
    Scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Pascal’s Triangle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Pascal’s triangle* is a two-dimensional array of numbers, rather than a linear
    sequence. Just as a sequence has entries indexed by the positive integers, entries
    in Pascal’s triangle are specified by giving two index numbers, corresponding
    to the row and column numbers for a particular entry. In this case, it’s best
    to think of the index numbers as starting from 0 rather than 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The row numbers in Pascal’s triangle are represented with the letter *n*. For
    the first row, *n* = 0, for the second row, *n* = 1, and so on. Within each row,
    columns are represented with the letter *k*, beginning with *k* = 0 and continuing
    up to *k* = *n*. So the *n*th row always has *n* + 1 entries: row 0 has one entry,
    row 1 has two entries, and so on. Centering the rows when we write them out makes
    it easy to see how the array expands from one row to the next, giving Pascal’s
    triangle its distinctive shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg100_Image_111.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The values of each entry can be determined by adding the two entries immediately
    above it. For example, the 2 in row *n* = 2 (the third row from the top) is the
    sum of the two 1s in the row above it, and each 10 in row *n* = 5 (the bottom
    row shown here) is the sum of the 4 and 6 above it. The entries at the edges of
    the rows, which don’t have two entries above them, are all given a value of 1.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Binomials
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now you know where the values in Pascal’s triangle come from, but what do they
    mean? They relate to the *binomial theorem*. This algebraic rule makes it easier
    to work out the positive integer powers of *binomials*, expressions that are a
    sum of two terms. Taking 1 + *x* as an example binomial, the binomial theorem
    helps us calculate the value of (1 + *x*)⁰, (1 + *x*)¹, (1 + *x*)², (1 + *x*)³,
    and so on. Expanding each of these powers, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg100_Image_112.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Look familiar? The coefficients (the constant multipliers of powers of *x*)
    in these expansions are the same as the values in Pascal’s triangle. The 1 in
    the first row of the triangle (row *n* = 0) corresponds to (1 + *x*)⁰ = 1\. The
    two 1s in the second row (*n* = 1) correspond to (1 + *x*)¹ = 1 + *x*. (Imagine
    an invisible 1 in front of the *x*.) The 1, 2, and 1 in the third row (*n* = 2)
    correspond to (1 + *x*)² = 1 + 2*x* + *x*², and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the *n*th row of Pascal’s triangle shows the coefficients for the
    *n*th power of a binomial—that is, (1 + *x*)^(*n*). What’s more, the *k*th entry
    in that row holds the coefficient of *x*^(*k*) in the binomial’s expansion. To
    see that, it helps to recognize that an expression such as 1 + 2*x* + *x*² is
    equivalent to the expression 1*x*⁰ + 2*x*¹ + 1*x*² and to notice how the exponents
    of *x* count up from 0 to *n*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the values in Pascal’s triangle represent the coefficients in binomial
    expansions, they’re known as *binomial coefficients*. Any given binomial coefficient
    can be written as *C*(*n*, *k*), where again *n* and *k* are the row and column
    numbers in Pascal’s triangle. So we can write Pascal’s triangle symbolically like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg101_Image_113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve represented Pascal’s triangle as a triangular array. But if you look
    at the pattern of index numbers, it makes just as much sense to see it as a square
    array, with the upper-right portion of the square either left off or filled with
    0s, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg101_Image_114.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We could find values for *C*(*n*, *k*) by algebra, multiplying out the polynomials
    (1 + *x*)^(*n*) to see what the coefficients turn out to be. (I’ve already done
    some of that for you, showing you the values up to *n* = 5.) But that would be
    a lot of work. To get a more general formula for *C*(*n*, *k*), it helps to interpret
    the algebra by thinking about a related counting problem.
  prefs: []
  type: TYPE_NORMAL
- en: Making Subsets from Sets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose you have five friends (Albert, Barb, Charley, Deb, and Eve), and you
    can invite only three of them to come over for pizza. How many different sets
    of three people could you invite? Let ABC be *Albert, Barb, Charley*, the first
    possibility. BAC is the same set of people in a different order, so this shouldn’t
    really count as different; you’ll still have the same guests at your pizza party.
    ABD is a different set, though, and so is ABE. You can keep going, one subset
    at a time, and eventually list 10 different pizza party sets, maybe ending with
    CDE.
  prefs: []
  type: TYPE_NORMAL
- en: How can you confirm that number is correct? Let’s see if we can formulate a
    general rule. Suppose you have a set with *n* objects in it (all your friends),
    and you want to build a subset with *k* objects in it (the party guests), for
    some integer *k* where 0 ≤ *k* ≤ *n*. In our example, *n* = 5 and *k* = 3\. First,
    think about the situation where the order of the elements selected for the subset
    *does* matter. In that case, the first element can be any of the *n* elements
    in the set. The second element can be any of the *n* – 1 elements left over after
    the first one is chosen, the third element can be any of the remaining *n* – 2
    elements, and so on, until we arrive at the *k*th element, which can be chosen
    only in *n* – (*k* – 1) = *n* – *k* + 1 ways. In our example, we pick any of our
    five friends (A through E) for the first choice, then any of the four left after
    that for the second choice, and then any of the three remaining people for the
    third choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplying the number of available choices for each spot gives us the total
    number of possible combinations. In the case of *k* = 3 spots for *n* = 5 friends,
    there are 5 ⋅ 4 ⋅ 3 = 60 possibilities. In general, the formula for the number
    of possible combinations is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg102_Image_115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our example, though, the order of the elements selected for the subset doesn’t
    matter, so we have to deal with the fact that different orderings of the *k* choices
    can lead to the same subset (like the ABC and BAC orderings mentioned earlier).
    How can we figure out how many different ways there are to order a subset of *k*
    elements? We can apply the same logic we just used for *n* to find out: there
    are *k* possibilities for what the first element could be, then *k* – 1 possibilities
    for the second element, and so on. So the total number of orderings is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg102_Image_116.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For *k* = 3, for example, there are 3 ⋅ 2 ⋅ 1 = 6 ways to order a particular
    set of three elements. This means that if we want to count only the unique subsets,
    ignoring rearrangements, we should count only one out of every six of the total
    number of combinations. That is, if there are 5 ⋅ 4 ⋅ 3 ways to pick three elements
    from a group of five, and there are 3 ⋅ 2 ⋅ 1 ways to order those three elements,
    there are (5 ⋅ 4 ⋅ 3) / (3 ⋅ 2 ⋅ 1) = 60 / 6 = 10 unique subsets, ignoring order.
    The general formula is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg102_Image_117.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that we’ve been using the same variables here that we were using to
    identify the rows and columns in Pascal’s triangle: *n* and *k*. That’s because
    the two problems are related. The formula to calculate a particular term *C*(*n*,
    *k*) in Pascal’s triangle—and, by extension, the formula to determine a particular
    binomial coefficient—is the same one we just worked out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg103_Image_118.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There’s a special sequence, the *factorial numbers*, that lets us write the
    formula for *C*(*n*, *k*) in a neater way. If *n* is a positive integer, *n* factorial
    (written as *n*!) is the product of every integer from 1 to *n*. For example,
    3! is 1 ⋅ 2 ⋅ 3 = 6, and 5! is 1 ⋅ 2 ⋅ 3 ⋅ 4 ⋅ 5 = 120\. More formally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg103_Image_119.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking at the sequences of terms in the formula for *C*(*n*, *k*), it’s clear
    there’s some kind of factorial logic involved. With a bit of algebra, we can simplify
    the formula to make factorial notation apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg103_Image_120.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Calculating factorials manually gets tedious as *n* and *k* get bigger. With
    Scratch Cat’s help, however, it’s a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 18: Pick a Number from Pascal’s Triangle'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this project, we’ll use the factorial definition we just arrived at for *C*(*n*,
    *k*) to make Scratch calculate the binomial coefficient for any given values of
    *n* and *k*. Put another way, we’ll write a program that calculates the entry
    at the *n*th row and *k*th column of Pascal’s triangle. [Figure 5-1](ch05.xhtml#ch5fig1)
    shows how.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg103_Image_121.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: Calculating binomial coefficients with factorials*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main program is the shortest one in this book: it’s just one line, to call
    the custom block that calculates the binomial coefficient for a given `n` and
    `k`. That block, in turn, calls the `factorial` calculator block, which takes
    in a value and calculates its factorial, using a loop to multiply all the numbers
    from 1 up to that value. The result is held in the `product` variable, which we
    set to `1` at the start of the block.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `factorial` block three times to calculate `n` factorial, `k` factorial,
    and `n - k` factorial, storing the resulting values of `product` in the variables
    `x`, `y`, and `z`. Then, we calculate `x / y * z` to get the binomial coefficient
    ❶. This is the equivalent of our formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg104_Image_122.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This program uses sliders to set the `n` and `k` inputs. Sliders are more efficient
    at receiving input than the `ask and wait` block in previous projects, and they
    let us automatically limit the input values to only integers within a certain
    range, sparing us from having to screen for inappropriate inputs like negative
    integers, strings, or numbers with decimals. To create a slider for a variable,
    right-click the variable on the stage and choose **slider** from the drop-down
    menu, as in [Figure 5-2](ch05.xhtml#ch5fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg104_Image_123.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: Using sliders to calculate* C*(5, 3) = 10*'
  prefs: []
  type: TYPE_NORMAL
- en: Dragging the slider’s circle to the left or right changes the associated variable’s
    value over a range you can specify using the change slider range option from the
    drop-down menu. I set the slider ranges to be 1 to 50 for *n* and 0 to 50 for
    *k*, but as we’ll discuss, even those ranges might cause trouble for some of the
    binomial coefficients we calculate.
  prefs: []
  type: TYPE_NORMAL
- en: To use the program, set the sliders to your chosen *n* and *k* values, then
    click the green flag to see the resulting binomial coefficient.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There’s a problem with this program. I set up the pizza party counting scenario
    with the assumption that *k* (the number of guests allowed) is less than or equal
    to *n* (the total number of people to choose from). But while the sliders limit
    *n* and *k* to integers, there’s nothing stopping us from making *k* greater than
    *n*.
  prefs: []
  type: TYPE_NORMAL
- en: If we set the sliders this way, when it comes time to calculate (*n* – *k*)!,
    we’ll end up passing the `factorial` block a negative number. A `repeat` loop
    can’t repeat a negative number of times, so the loop will exit before the first
    pass and `product` will be stuck with its initial value of `1`. This breaks the
    formula and reports a weird result, as shown in [Figure 5-3](ch05.xhtml#ch5fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg105_Image_124.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3:* C*(5, 6) = ???*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fix is pretty easy: just put a test into the main program to check for
    *k* > *n* and notify the user that the inputs are invalid if this condition is
    met, as shown in [Figure 5-4](ch05.xhtml#ch5fig4).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg105_Image_125.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-4: Adding a check for* k *>* n'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using a variable called `C(n, k)` ❶, while also using a custom
    block called `C` with `n` and `k` inputs ➋ to calculate a value to assign to that
    variable. Scratch’s color coding and block shapes help us keep track of which
    `C(n, k)` is which.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another problem with this program is that factorials get big quickly: 18! is
    the largest factorial Scratch can reliably calculate before reaching flintmax.
    In practice, since *n*! is always divisible by various powers of 2, the reported
    value remains correct for a while even after exceeding flintmax, but by the time
    we get to 171! we’ve exceeded the overall maximum of the IEEE 754 floating-point
    standard. At that point, Scratch gives up, reporting values involving calculations
    of 171! or larger as `Infinity` (see [Figure 5-5](ch05.xhtml#ch5fig5)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg105_Image_126.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-5:* C*(171, 18) = ???*'
  prefs: []
  type: TYPE_NORMAL
- en: Even for smaller values, the rounding in IEEE 754 for integers larger than flintmax
    can spoil the results and yield a non-integer value, as shown in [Figure 5-6](ch05.xhtml#ch5fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg105_Image_127.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-6:* C*(49, 23) = ???*'
  prefs: []
  type: TYPE_NORMAL
- en: In fairness, the true value of *C*(49, 23) is 58,343,356,817,424, so Scratch
    is pretty close, but “pretty close” isn’t good enough. To enable Scratch to keep
    finding the exact binomial coefficients for bigger values of *n* and *k*, we need
    to take a different approach, one that doesn’t involve working with factorials.
    For this, we can take advantage of the fact that even though the factorials in
    the formula for *C*(*n*, *k*) quickly get large, the binomial coefficients themselves
    don’t grow so big so fast. So if we can calculate the binomial coefficients without
    first calculating any factorials, we’ll be able to get a lot further before hitting
    flintmax.
  prefs: []
  type: TYPE_NORMAL
- en: Pascal’s Recurrence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The value at row *n* and column *k* of Pascal’s triangle is the binomial coefficient
    *C*(*n*, *k*). If we can find a recurrence for Pascal’s triangle—a rule for generating
    the next value in the array based on the previous values—we’ll be able to calculate
    binomial coefficients without any need for factorials.
  prefs: []
  type: TYPE_NORMAL
- en: 'With arrays, we have lots of flexibility in deciding which previous elements
    should be used to specify the recurrence. “Previous element” here can mean a value
    in an earlier row or an earlier value in the same row. I hinted at a recurrence
    for Pascal’s triangle in the initial description: each value is the sum of the
    two adjacent values immediately above it. Here’s how to write that as a recurrence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg106_Image_128.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To see why this works, we can interpret each value *C*(*n*, *k*) in Pascal’s
    triangle as the answer to a subset counting problem. Instead of thinking about
    guests at a pizza party, let’s think about counting how many ways there are to
    pick a set of *k* of the (1 + *x*) factors among all of the *n* factors in (1
    + *x*)^(*n*). Every way of picking *k* factors adds another *x*^(*k*) to the total.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we want to expand (1 + *x*)⁴ and see what the coefficient
    should be for *x*³. That would be the binomial coefficient *C*(4, 3). When we
    multiply out (1 + *x*)(1 + *x*)(1 + *x*)(1 + *x*), in each factor of (1 + *x*)
    we can pick either the 1 or the *x* to multiply. To get a term of *x*³, we need
    to pick 1 once and *x* three times. We could pick the first factor’s 1, or the
    second factor’s 1, or the third factor’s 1, or the last factor’s 1, so there are
    four ways that we could get *x*³. That makes *C*(4, 3) = 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider only *n* – 1 repeated (1 + *x*) factors. The binomial coefficients
    for (1 + *x*)^(*n* – 1) are listed in row *n* – 1 of Pascal’s triangle. If we
    want go to from row *n* – 1 to row *n*, we have to multiply by one extra factor
    of (1 + *x*). Again, we need to pick either the 1 or the *x* for the multiplication.
    There are two possibilities: either we already have *k* occurrences of *x* when
    we pick factors in (1 – *x*)^(*k* – 1), in which case we multiply by the 1 of
    the extra factor, or we have *k* – 1 occurrences of *x*, in which case we multiply
    by the *x* of the extra factor to get *k* occurrences. That accounting gives the
    recurrence I just mentioned, which we can use to build the triangle row by row:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg106_Image_129.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again, all this means is that to get an entry in Pascal’s triangle, we just
    need to add the two numbers above it.
  prefs: []
  type: TYPE_NORMAL
- en: This recurrence helps us make sense of the value 4 that we calculated for *C*(4,
    3). First, we step back a row in the triangle, from row 4 to row 3, to the coefficients
    for the expansion of (1 + *x*)³. We can then either take the *x*² terms in that
    row that are counted by *C*(3, 2) and multiply them by *x*, or take the *x*³ terms
    there that are counted by *C*(3, 3) and multiply them by 1\. Those are the only
    ways to build an *x*³ term in row 4\. That means *C*(3, 2) + *C*(3, 3) = *C*(4,
    3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 19: Pascal’s Triangle, Row by Row'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 5-7](ch05.xhtml#ch5fig7) shows a Scratch program to calculate up to
    the *n*th row of Pascal’s triangle using the recurrence we just discussed.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg107_Image_130.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-7: Calculating Pascal’s triangle, row by row*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we ask which row to calculate ❶. Then, we loop that many times to work
    through all the rows up to that one. We use two lists to keep track of the values:
    `row` is the previous row in the array, and `newrow` is the current row being
    calculated. We start each new row with a `1` ➋, then add each adjacent pair of
    values from `row` to get the next value in `newrow` ➌, as specified by our recurrence.
    At the end of each cycle through the loop, the custom `copy newrow to row` block
    copies `newrow` back to `row` to get ready for the next iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Figure 5-8](ch05.xhtml#ch5fig8) shows a sample run of the program, for *n*
    = 8.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg108_Image_131.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-8: Row 8 of Pascal’s triangle*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, since Scratch lists are indexed starting with 1 rather than 0,
    the first element, *C*(8, 0) = 1, isn’t listed in the output. It *was* calculated,
    but we deleted it from the list at the end of the program ➍. This way, Scratch’s
    index numbers match the values of *k* for the given row. Just imagine that there’s
    an extra 1 at the start of the list, at index 0.
  prefs: []
  type: TYPE_NORMAL
- en: With this approach, we can go much further with calculating exact binomial coefficients.
    In fact, we don’t exceed flintmax until we get to row *n* = 56 of Pascal’s triangle.
    There, the value for *k* = 25 is off (but *k* = 26, 27, and 28 are reported correctly).
    We also don’t have any binomial coefficients reported as `Infinity` until we get
    past row 1,000.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 20: Drawing Pascal’s Triangle'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One way to understand Pascal’s triangle is to think about how the values of
    the binomial coefficients are distributed in each row. For example, we can observe
    that the values are symmetric around the center of the row: 1-2-1, 1-3-3-1, 1-4-6-4-1,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Mathematically, we can express each row’s symmetry by noting that the value
    at column *k* in row *n* is the same as the value at column *n* – k in the same
    row. In other words, *C*(*n*, *k*) = *C*(*n*, *n* – *k*). We can verify this observation
    by thinking about the subset counting interpretation of Pascal’s triangle, discussed
    earlier in this chapter. To create a subset of *k* out of *n* elements, we can
    say either which *k* elements should be included or which *n* – *k* elements should
    *not* be included.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting observation is that the sum of the binomial coefficients
    in the *n*th row of Pascal’s triangle is 2^(*n*). In row *n* = 3, for example,
    1 + 3 + 3 + 1 = 8, or 2³, and in row *n* = 4, 1 + 4 + 6 + 4 + 1 = 16, or 2⁴. This
    also connects with the subset counting interpretation: there are a total of 2^(*n*)
    subsets of a set with *n* elements because for each of the *n* elements, there’s
    a choice of two possibilities: to include that element in a subset or not.'
  prefs: []
  type: TYPE_NORMAL
- en: One more feature worth noting is that the values in each row are *unimodal*,
    meaning they start small, increase toward a largest value in the middle, and then
    get small again. We can make observations like these by looking at the numbers
    themselves, but features like the values’ symmetry and their unimodal structure
    are even easier to spot if we visualize rows of Pascal’s triangle as bar graphs.
    Also called a *histogram*, a *bar graph* is a chart where the value of each entry
    is represented by the height of a bar. For example, [Figure 5-9](ch05.xhtml#ch5fig9)
    shows a bar graph representing the values in row *n* = 10 of Pascal’s triangle.
    Notice the symmetry of the bar heights.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg109_Image_132.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-9: Row 10 of Pascal’s triangle*'
  prefs: []
  type: TYPE_NORMAL
- en: To draw bar graphs like these, start with the program in [Project 19](ch05.xhtml#ch05lev7)
    ([Figure 5-7](ch05.xhtml#ch5fig7)) for calculating a row of Pascal’s triangle.
    Then, add the custom `draw histogram` block shown in [Figure 5-10](ch05.xhtml#ch5fig10).
    It uses blocks from the Pen extension to draw a bar for each value in the row.
    Be sure to insert this custom block *before* you delete the `1` at the start of
    the row ([Figure 5-7](ch05.xhtml#ch5fig7) ➍), or the symmetry will be spoiled.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg110_Image_133.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-10: Drawing a bar graph from a row*'
  prefs: []
  type: TYPE_NORMAL
- en: The `draw histogram` block first takes the `row` list from the Pascal’s triangle
    program and finds its maximum entry using the custom `find max of row` block (shown
    in [Figure 5-11](ch05.xhtml#ch5fig11)). Based on this maximum, we calculate `horizontal
    step size` and `vertical step size` to ensure the drawing will fit on the stage
    ❶. Then, we use a loop ➋ to draw the bar graph one bar at a time, moving up based
    on the corresponding value in `row`, across based on the number of bars to draw,
    and then back down to start on the next bar.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg111_Image_134.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-11: Finding the maximum row element*'
  prefs: []
  type: TYPE_NORMAL
- en: The `find max of row` block simply cycles through all the values in `row`, updating
    the `max` variable each time it finds a higher value.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Figure 5-12](ch05.xhtml#ch5fig12) shows the bar graphs for two more rows of
    the triangle.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg111_Image_135.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-12: Rows 20 (left) and 50 (right) of Pascal’s triangle*'
  prefs: []
  type: TYPE_NORMAL
- en: No matter the row, the shape of the bar graph looks similar. In fact, as *n*
    increases, the graph gets closer and closer to the famous bell curve of a normal
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The new `draw histogram` block is general enough to draw bar graphs for other
    datasets besides rows from Pascal’s triangle. For example, the code in [Figure
    5-13](ch05.xhtml#ch5fig13) prompts the user to enter a series of numbers—similar
    to what we did in [Project 17](ch04.xhtml#ch04lev13) ([Figure 4-16](ch04.xhtml#ch4fig16)),
    when we were working with difference tables—and then calls the `draw histogram`
    block to visualize that data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg112_Image_136.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-13: Creating a bar graph from a dataset*'
  prefs: []
  type: TYPE_NORMAL
- en: The `draw histogram` block expects the data to be in a list called `row` with
    a length of `n`. As long as your program has these features, the bar graph code
    will work. If all you have is `row`, you’ll need to supply `n` before drawing
    the bar graph ❶.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  prefs: []
  type: TYPE_NORMAL
- en: '**5.1** You might notice in a table of values of *n*! that for larger values
    of *n*, the value of *n*! will end with several zeros. Write a program to predict
    how many zeros there will be for a given *n*. In particular, can you predict how
    many zeros the value of 25! will end with?'
  prefs: []
  type: TYPE_NORMAL
- en: '**5.2** Write a program to extract sequences from Pascal’s triangle by stepping
    down along a diagonal. Use it to consider the diagonal in Pascal’s triangle consisting
    of values of *C*(*n*, 2). Identify this sequence in terms of the figurate numbers
    we discussed in [Chapter 4](ch04.xhtml#ch04).'
  prefs: []
  type: TYPE_NORMAL
- en: '**5.3** As an integer, the value of a binomial coefficient can be either even
    or odd. Change the row recurrence program for Pascal’s triangle ([Project 19](ch05.xhtml#ch05lev7))
    so it shows only 0 or 1, depending on if the binomial coefficient is even or odd.
    See what kinds of patterns you can find.'
  prefs: []
  type: TYPE_NORMAL
- en: Operation Tables Have All the Answers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *operation table* is a table of values showing the result of a mathematical
    operation, given different combinations of inputs. For example, you probably learned
    basic multiplication using a multiplication table, or times table. This type of
    operation table usually has nine rows and nine columns, and it gives the answer
    to any multiplication problem where the two numbers being multiplied are indicated
    by the row and column. If you wanted to multiply 6 times 7, for instance, you
    would go across the top row (the index row) to find 6 and down the left column
    (the index column) to find 7\. The value where column 6 and row 7 intersect is
    42.
  prefs: []
  type: TYPE_NORMAL
- en: We couldn’t possibly create a complete multiplication table for all the positive
    integers because there are infinitely many of them. However, the usual nine-by-nine
    multiplication table for single-digit numbers has all the information we need
    to calculate products of longer numbers. Compare this situation with the modular
    arithmetic we discussed in [Chapter 2](ch02.xhtml#ch02). Once you pick a modulus,
    say *n*, all that matters is the remainder when a number is divided by *n*. There
    are only *n* possible remainders, 0 through *n* – 1\. That means any operation
    table based on modular arithmetic will have a finite number of entries, and an
    *n*-by-*n* table will include them all.
  prefs: []
  type: TYPE_NORMAL
- en: A finite operation table, with its rows and columns, qualifies as an array.
    In the next project, we’ll use Scratch to generate operation tables for a given
    modulus and then see what kinds of patterns we can find.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 21: Infinite Operation Tables with Modular Arithmetic'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our program will prompt the user for a modulus *n*, then ask them to choose
    an operation: addition or multiplication. It will then build an *n*-by-*n* table
    showing all possible outcomes of the chosen operation, mod *n*. For example, say
    the modulus is 7\. The addition table should show the sum of every possible pair
    of numbers from 0 to 6, interpreted mod 7\. The entry at the intersection of column
    6 and row 2, for instance, should show (6 + 2) mod 7, which is 1\. The multiplication
    table does the same for multiplication: the intersection of column 6 and row 2
    should show (6 ⋅ 2) mod 7, which is 5.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg113_Image_137.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-14: Asking what modulus and what operation*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll build each row of the table as an entry in a Scratch list called `table`.
    First, we need some custom blocks to help us get organized. [Figure 5-14](ch05.xhtml#ch5fig14)
    shows the `setup` block, which is called at the start of the program.
  prefs: []
  type: TYPE_NORMAL
- en: In the `setup` block, we first delete any previous version of `table` ❶. Then,
    we prompt the user for the `modulus` (an integer) and `operation` (`+` or `*`).
    Once we have that information, we call the `Make index row` block ➋, shown in
    [Figure 5-15](ch05.xhtml#ch5fig15).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg114_Image_138.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-15: Building the index row of the operation table*'
  prefs: []
  type: TYPE_NORMAL
- en: The `Make index row` block adds an index row at the top of the table containing
    labels for the columns, from 0 up to but not including the modulus, along with
    a `+` or `*` symbol to indicate whether it’s showing addition or multiplication.
    We build up the contents of the row as a string in the `row` variable, using a
    series of `join` blocks. We also add an extra row consisting of all dashes, to
    help set off the column index labels from the contents of the table itself.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the work in this block goes into making the table look pretty, with
    the columns evenly spaced regardless of whether they contain one-digit or two-digit
    numbers. To help, we use the custom `pad` block ❶ (defined in [Figure 5-16](ch05.xhtml#ch5fig16)),
    which puts either one or two spaces in front of a given string, depending on its
    length, to ensure that all the numbers in each column will be lined up nicely.
    If we know how many spaces we need to make the numbers line up, we can put them
    in directly, as we did in the index row ➋, but otherwise it’s better to let the
    program decide.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The two* set x *commands inside the* pad *block might look the same, but they’re
    actually different. The empty space in the first one, which executes when* x *has
    a length of 1, has two spaces in it, whereas the bottom one, which executes when*
    x *has a length of 2, has only one space.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg115_Image_139.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-16: Padding a string with one or two spaces*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all these helper blocks, we can build the operation table,
    nicely formatted, with the main program code in [Figure 5-17](ch05.xhtml#ch5fig17).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg115_Image_140.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-17: Building the operation table, one row at a time*'
  prefs: []
  type: TYPE_NORMAL
- en: After calling our `setup` block, we use two nested loops to build the operation
    table row by row. The outer loop increments the variable `i`, representing the
    index number of the current row, while the inner loop increments the variable
    `j`, representing the column index number within the row. Each row begins with
    the row index number itself, followed by a colon ❶. This is necessary because
    Scratch indexes lists starting from 1, but for our purposes it’s more natural
    to number the rows and columns from 0.
  prefs: []
  type: TYPE_NORMAL
- en: The real work is done in the `if...else` block inside the inner loop ➋. There,
    depending on the desired operation, we calculate either `i + j` or `i * j` and
    take the `mod` of the result, giving us the current entry in the operation table.
    Once again, we use the `pad` block to add the appropriate number of spaces before
    joining the entry to the row being constructed. At the end of each cycle of the
    outer loop, we have a complete row, which we add to the `table` list.
  prefs: []
  type: TYPE_NORMAL
- en: The Results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Figure 5-18](ch05.xhtml#ch5fig18) shows the resulting addition and multiplication
    tables for the small modulus *n* = 7.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg116_Image_141.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-18: Operation tables mod 7*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that each table starts with an index row showing the labels of the columns,
    from 0 to 6\. There’s also an index column along the left side of the table, showing
    the labels of the rows (again from 0 to 6).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these tables, we can find the sum or product, mod 7, of any two integers.
    For example, say we want to find (152 + 263) mod 7\. First, we need to take mod
    7 of each input: 152 mod 7 is 5, and 263 mod 7 is 4\. Next, we look in the addition
    table for the intersection of column 5 and row 4\. The value there is 2, so that’s
    our answer. In this way, even though the tables have just seven rows and columns,
    they can give us the answer for any of the infinite number of positive integers.
    We just have to take mod 7 of the integers first.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several patterns to observe in these mod 7 operation tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-1.jpg) For the addition table (on the left in [Figure
    5-18](ch05.xhtml#ch5fig18)), the values cycle row by row, shifting one column
    to the left from one row to the next. The value in the leftmost column of one
    row wraps back around, becoming the value in the rightmost column of the next
    row.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-1.jpg) The values in row 0 of the addition table
    match the values in the table’s index row. This indicates that 0 is the *additive
    identity*: adding 0 to a number doesn’t change the number. As far as 0 is concerned,
    modular addition works just like ordinary addition.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-1.jpg) The *additive inverse* of a number *n* is
    the number that needs to be added to *n* to get 0\. In ordinary addition, the
    additive inverse of a number is that number’s negation. For example, the additive
    inverse of 3 is –3\. We don’t need to use negative numbers to have additive inverses
    in modular arithmetic, however. Notice that there’s a 0 in every row of the addition
    table. This means there’s a positive number that we can add to get 0, no matter
    what we start with. That is, every number has an additive inverse for a given
    modulus. For instance, row 3 has a 0 in the column 4, so 3 + 4 = 0 mod 7.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-1.jpg) For the multiplication table (on the right
    in [Figure 5-18](ch05.xhtml#ch5fig18)), the values in row 1 match the values in
    the index row. That means 1 is the *multiplicative identity*: multiplying a number
    by 1 doesn’t change the number. In this sense, modular multiplication is just
    like regular multiplication.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-1.jpg) There’s a 1 in every row and column of the
    multiplication table except for row and column 0\. That means every nonzero number
    can be multiplied by some other number, called the *multiplicative inverse*, to
    produce 1 mod 7.'
  prefs: []
  type: TYPE_NORMAL
- en: These observations don’t just apply to a modulus of 7; they’re true of any modulus.
    Try running the program for some other moduli and you’ll see the same patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When you start making operation tables for larger moduli, you’ll find that the
    entire contents of each row will no longer fit on the Scratch stage. The complete
    table is still there behind the scenes, though. If you want to see the whole table
    at once, you can export the `table` list to a text file and open it in a text
    editor or other program, as discussed in [Chapter 2](ch02.xhtml#ch02). The table
    will look best if you view it using a *monospaced* font like Courier, where every
    character has the same width, so the columns all line up. For example, [Figure
    5-19](ch05.xhtml#ch5fig19) shows the exported table for multiplication mod 12.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg117_Image_142.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-19: A multiplication table mod 12*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that this table has multiple 0s in some rows and columns. The 0s in
    row 0 and column 0 are to be expected: multiplication by 0 always yields 0\. The
    other 0s are more interesting. They occur because 12 isn’t a prime number. Every
    factorization of 12 (in fact, every factorization of any multiple of 12) gives
    two numbers whose product is divisible by 12, and so whose product is 0 mod 12\.
    For instance, in row 4 we have a 0 in columns 0, 3, 6, and 9\. Indeed, 4 ⋅ 3,
    4 ⋅ 6, and 4 ⋅ 9 are all examples of two numbers that multiply to be 0 mod 12,
    even though neither number was 0 mod 12 to begin with. These values are known
    as *zero divisors*, and they don’t occur for arithmetic of real numbers. They
    exist only in modular arithmetic, and only if the modulus isn’t prime.'
  prefs: []
  type: TYPE_NORMAL
- en: If we cross out all the rows and columns that have extra 0s, as in [Figure 5-20](ch05.xhtml#ch5fig20),
    the values that aren’t crossed out form a smaller, reduced multiplication table.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg118_Image_143.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-20: A reduced multiplication table mod 12*'
  prefs: []
  type: TYPE_NORMAL
- en: We’re left with a 4×4 table of values, with row and column indices of 1, 5,
    7, and 11\. Every row and column in this smaller table has a 1 in it, meaning
    the remaining numbers all have a multiplicative inverse.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  prefs: []
  type: TYPE_NORMAL
- en: '**5.4** If two numbers have no factors in common other than 1, they’re said
    to be *relatively prime*. For example, 6 and 35 are relatively prime, but 35 and
    49 are not (they’re both divisible by 7). Rewrite the code for the operation tables
    so that it will produce a reduced multiplication table for a given modulus *n*
    that includes only rows and columns for numbers that are relatively prime to *n*.
    For example, for multiplication mod 12, it should produce a table that includes
    only the four rows and columns that aren’t crossed out in [Figure 5-20](ch05.xhtml#ch5fig20).
    If the modulus that’s supplied is a prime number *p*, it should generate a (*p*
    – 1)*×*(*p* – 1) table, omitting row and column 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '**5.5** The *primitive root* of a prime number *p* is a number whose powers
    mod *p* generate all the integers from 1 to *p* – 1\. For example, 2 is a primitive
    root of 11 because:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-2.jpg) 2^(10) = 1,024, and 1,024 mod 11 = 1'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-2.jpg) 2¹ = 2'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-2.jpg) 2⁸ = 256, and 256 mod 11 = 3'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-2.jpg) 2² = 4'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-2.jpg) 2⁴ = 16, and 16 mod 11 = 5'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-2.jpg) 2⁹ = 512, and 512 mod 11 = 6'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-2.jpg) 2⁷ = 128, and 128 mod 11 = 7'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-2.jpg) 2³ = 8'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-2.jpg) 2⁶ = 64, and 64 mod 11 = 9'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common-2.jpg) 2⁵ = 32, and 32 mod 11 = 10'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, 2 isn’t a primitive root of 7 because the only powers of
    2 mod 7 are 1, 2, and 4\. Write a program that asks for a prime number *p* and
    returns the first primitive root of *p* that it finds.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.6** Spreadsheet programs such as Excel can import text files easily if
    the files are in CSV format. This format expects there to be a comma between each
    entry in each row of the input data. Modify the Scratch code for operation tables
    so that the exported files are formatted in this way.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arrays are two-dimensional tables of numbers, indexed by row and column. The
    position of an entry in the table provides two pieces of information—the row and
    column numbers—that you can sometimes use in a formula to determine the table
    entry. Scratch doesn’t have a built-in `array` type, but you can represent an
    array using a list, with each value containing all the array elements for a given
    row joined together, as we did in building operation tables. Another way to represent
    an array in Scratch is to build a list for each row of the array, as we did for
    Pascal’s triangle (a list of lists). The right way to represent an array depends
    on how you want to use it. Scratch is flexible enough to do whatever you want!
  prefs: []
  type: TYPE_NORMAL
