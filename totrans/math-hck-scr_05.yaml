- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**From Sequences to Arrays**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**从序列到数组**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: When you ask, “What value comes next?” you’re making an assumption that the
    values are arranged in one dimension, along a line. One value follows another
    in a sequence, such that there’s only one way to step from one item to the next.
    But we live in a world with more than one dimension, and it’s sometimes helpful
    to use more than one dimension to organize information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你问“下一个值是什么？”时，你假设这些值是沿着一条线排列的一维序列。一个值跟随另一个值按顺序排列，因此从一个项跳到下一个项只有一种方式。但我们生活在一个多维的世界，有时使用多维来组织信息会更有帮助。
- en: For example, an *array* is a two-dimensional object, a table of values organized
    in rows and columns. We can still look for patterns in an array of numbers, but
    now the patterns might show up as we move from row to row, from column to column,
    or along diagonals. In this chapter, we’ll use Scratch to study some interesting
    arrays. While Scratch makes it easy to explore one-dimensional sequences with
    its `list` data type, it doesn’t have a similar structure for two-dimensional
    arrays. We’ll have to develop some creative workarounds to represent arrays in
    Scratch.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*数组*是一个二维对象，是按行和列组织的值表格。我们仍然可以在一个数字数组中寻找模式，但现在这些模式可能在我们从一行移动到另一行、从一列移动到另一列，或沿对角线移动时显现出来。在本章中，我们将使用
    Scratch 来研究一些有趣的数组。虽然 Scratch 通过其 `list` 数据类型使得探索一维序列变得容易，但它没有类似的结构来处理二维数组。我们将不得不开发一些创造性的方法来在
    Scratch 中表示数组。
- en: Pascal’s Triangle
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pascal 三角形
- en: '*Pascal’s triangle* is a two-dimensional array of numbers, rather than a linear
    sequence. Just as a sequence has entries indexed by the positive integers, entries
    in Pascal’s triangle are specified by giving two index numbers, corresponding
    to the row and column numbers for a particular entry. In this case, it’s best
    to think of the index numbers as starting from 0 rather than 1.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pascal 三角形* 是一个二维数字数组，而不是线性序列。就像序列中的条目是由正整数索引的，Pascal 三角形中的条目是通过给出两个索引数字来指定的，这两个索引分别对应于某个条目的行号和列号。在这种情况下，最好将索引数字从
    0 开始，而不是从 1 开始。'
- en: 'The row numbers in Pascal’s triangle are represented with the letter *n*. For
    the first row, *n* = 0, for the second row, *n* = 1, and so on. Within each row,
    columns are represented with the letter *k*, beginning with *k* = 0 and continuing
    up to *k* = *n*. So the *n*th row always has *n* + 1 entries: row 0 has one entry,
    row 1 has two entries, and so on. Centering the rows when we write them out makes
    it easy to see how the array expands from one row to the next, giving Pascal’s
    triangle its distinctive shape:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal 三角形的行数用字母 *n* 来表示。第一行时，*n* = 0；第二行时，*n* = 1，依此类推。在每一行中，列用字母 *k* 表示，从
    *k* = 0 开始，一直到 *k* = *n*。因此，第 *n* 行总是有 *n* + 1 个条目：第 0 行有一个条目，第 1 行有两个条目，依此类推。当我们写出这些行时，居中排列会使我们容易看出数组从一行到下一行的扩展，从而形成
    Pascal 三角形独特的形状：
- en: '![Image](../images/pg100_Image_111.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg100_Image_111.jpg)'
- en: The values of each entry can be determined by adding the two entries immediately
    above it. For example, the 2 in row *n* = 2 (the third row from the top) is the
    sum of the two 1s in the row above it, and each 10 in row *n* = 5 (the bottom
    row shown here) is the sum of the 4 and 6 above it. The entries at the edges of
    the rows, which don’t have two entries above them, are all given a value of 1.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个条目的值可以通过将其正上方的两个条目相加来确定。例如，第 *n* = 2（从顶部算起的第三行）中的 2 是上方两个 1 相加的结果，第 *n* =
    5（这里显示的底部行）中的每个 10 是其上方 4 和 6 相加的结果。位于行边缘的条目，由于它们正上方没有两个条目，所有的值都为 1。
- en: Working with Binomials
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用二项式
- en: 'Now you know where the values in Pascal’s triangle come from, but what do they
    mean? They relate to the *binomial theorem*. This algebraic rule makes it easier
    to work out the positive integer powers of *binomials*, expressions that are a
    sum of two terms. Taking 1 + *x* as an example binomial, the binomial theorem
    helps us calculate the value of (1 + *x*)⁰, (1 + *x*)¹, (1 + *x*)², (1 + *x*)³,
    and so on. Expanding each of these powers, we get the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了 Pascal 三角形中数值的来源，但它们意味着什么呢？它们与 *二项式定理* 有关。这个代数规则使我们更容易计算出 *二项式* 的正整数次方，二项式是由两项和组成的表达式。以
    1 + *x* 为例，二项式定理帮助我们计算 (1 + *x*)⁰, (1 + *x*)¹, (1 + *x*)², (1 + *x*)³ 等的值。展开每一个次方，我们得到如下结果：
- en: '![Image](../images/pg100_Image_112.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg100_Image_112.jpg)'
- en: Look familiar? The coefficients (the constant multipliers of powers of *x*)
    in these expansions are the same as the values in Pascal’s triangle. The 1 in
    the first row of the triangle (row *n* = 0) corresponds to (1 + *x*)⁰ = 1\. The
    two 1s in the second row (*n* = 1) correspond to (1 + *x*)¹ = 1 + *x*. (Imagine
    an invisible 1 in front of the *x*.) The 1, 2, and 1 in the third row (*n* = 2)
    correspond to (1 + *x*)² = 1 + 2*x* + *x*², and so on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来熟悉吗？这些展开式中的系数（即 *x* 的幂的常数乘数）与帕斯卡三角形中的值是相同的。三角形第一行的 1（行 *n* = 0）对应于 (1 + *x*)⁰
    = 1。第二行中的两个 1（*n* = 1）对应于 (1 + *x*)¹ = 1 + *x*。（想象 *x* 前面有一个隐形的 1。）第三行中的 1、2 和
    1（*n* = 2）对应于 (1 + *x*)² = 1 + 2*x* + *x*²，依此类推。
- en: In general, the *n*th row of Pascal’s triangle shows the coefficients for the
    *n*th power of a binomial—that is, (1 + *x*)^(*n*). What’s more, the *k*th entry
    in that row holds the coefficient of *x*^(*k*) in the binomial’s expansion. To
    see that, it helps to recognize that an expression such as 1 + 2*x* + *x*² is
    equivalent to the expression 1*x*⁰ + 2*x*¹ + 1*x*² and to notice how the exponents
    of *x* count up from 0 to *n*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，帕斯卡三角形的第 *n* 行显示的是二项式 *n* 次方的系数——也就是 (1 + *x*)^(*n*)。更重要的是，该行中的第 *k* 项包含了
    *x*^(*k*) 在二项式展开中的系数。为了看清楚这一点，可以通过将表达式如 1 + 2*x* + *x*² 转换为 1*x*⁰ + 2*x*¹ + 1*x*²，并注意
    *x* 的指数是如何从 0 到 *n* 依次递增的。
- en: 'Since the values in Pascal’s triangle represent the coefficients in binomial
    expansions, they’re known as *binomial coefficients*. Any given binomial coefficient
    can be written as *C*(*n*, *k*), where again *n* and *k* are the row and column
    numbers in Pascal’s triangle. So we can write Pascal’s triangle symbolically like
    this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于帕斯卡三角形中的值代表二项式展开式中的系数，所以它们被称为 *二项式系数*。任何给定的二项式系数都可以写作 *C*(*n*, *k*)，其中 *n*
    和 *k* 分别是帕斯卡三角形中的行号和列号。因此，我们可以将帕斯卡三角形符号化地表示为：
- en: '![Image](../images/pg101_Image_113.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg101_Image_113.jpg)'
- en: 'We’ve represented Pascal’s triangle as a triangular array. But if you look
    at the pattern of index numbers, it makes just as much sense to see it as a square
    array, with the upper-right portion of the square either left off or filled with
    0s, as shown here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将帕斯卡三角形表示为一个三角形数组。但如果你观察索引号的模式，将其看作一个方形数组同样是有意义的，只不过方形的右上部分要么被省略，要么填充为 0，如下所示：
- en: '![Image](../images/pg101_Image_114.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg101_Image_114.jpg)'
- en: We could find values for *C*(*n*, *k*) by algebra, multiplying out the polynomials
    (1 + *x*)^(*n*) to see what the coefficients turn out to be. (I’ve already done
    some of that for you, showing you the values up to *n* = 5.) But that would be
    a lot of work. To get a more general formula for *C*(*n*, *k*), it helps to interpret
    the algebra by thinking about a related counting problem.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过代数运算来求得 *C*(*n*, *k*) 的值，方法是展开多项式 (1 + *x*)^(*n*)，看看系数会变成什么样。（我已经为你做了一些工作，展示了
    *n* = 5 时的值。）但这样做会很繁琐。为了得到 *C*(*n*, *k*) 的更一般的公式，可以通过思考一个相关的计数问题来帮助理解代数。
- en: Making Subsets from Sets
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从集合中创建子集
- en: Suppose you have five friends (Albert, Barb, Charley, Deb, and Eve), and you
    can invite only three of them to come over for pizza. How many different sets
    of three people could you invite? Let ABC be *Albert, Barb, Charley*, the first
    possibility. BAC is the same set of people in a different order, so this shouldn’t
    really count as different; you’ll still have the same guests at your pizza party.
    ABD is a different set, though, and so is ABE. You can keep going, one subset
    at a time, and eventually list 10 different pizza party sets, maybe ending with
    CDE.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有五个朋友（Albert、Barb、Charley、Deb 和 Eve），你只能邀请其中三个人来吃披萨。那么，你能邀请多少组不同的三人组合呢？假设
    ABC 是 *Albert, Barb, Charley*，这是第一种可能。BAC 是同一组人，只是顺序不同，因此不应该算作不同的组合；你仍然会在披萨派对上迎接相同的客人。不过，ABD
    是一个不同的组合，ABE 也是如此。你可以继续下去，一次列出一个子集，最终列出 10 种不同的披萨派对组合，可能最后是 CDE。
- en: How can you confirm that number is correct? Let’s see if we can formulate a
    general rule. Suppose you have a set with *n* objects in it (all your friends),
    and you want to build a subset with *k* objects in it (the party guests), for
    some integer *k* where 0 ≤ *k* ≤ *n*. In our example, *n* = 5 and *k* = 3\. First,
    think about the situation where the order of the elements selected for the subset
    *does* matter. In that case, the first element can be any of the *n* elements
    in the set. The second element can be any of the *n* – 1 elements left over after
    the first one is chosen, the third element can be any of the remaining *n* – 2
    elements, and so on, until we arrive at the *k*th element, which can be chosen
    only in *n* – (*k* – 1) = *n* – *k* + 1 ways. In our example, we pick any of our
    five friends (A through E) for the first choice, then any of the four left after
    that for the second choice, and then any of the three remaining people for the
    third choice.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何确认这个数字是正确的呢？让我们看看能否提出一个通用的规则。假设你有一个包含*n*个元素的集合（所有你的朋友），你想从中选择*k*个元素组成一个子集（派对嘉宾），其中*k*是一个整数，满足0
    ≤ *k* ≤ *n*。在我们的示例中，*n* = 5，*k* = 3。首先，考虑选择子集时顺序重要的情况。在这种情况下，第一个元素可以是集合中的任意*n*个元素之一。第二个元素可以是选择第一个元素后剩下的*n*
    – 1个元素之一，第三个元素可以是剩下的*n* – 2个元素之一，以此类推，直到我们选择第*k*个元素，它只能有*n* – (*k* – 1) = *n*
    – *k* + 1种选择方式。在我们的示例中，我们从五个朋友（A到E）中选择第一个元素，然后从剩下的四个中选择第二个，再从剩下的三个中选择第三个。
- en: 'Multiplying the number of available choices for each spot gives us the total
    number of possible combinations. In the case of *k* = 3 spots for *n* = 5 friends,
    there are 5 ⋅ 4 ⋅ 3 = 60 possibilities. In general, the formula for the number
    of possible combinations is:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个位置的选择数量相乘，得到可能组合的总数。对于*k* = 3和*n* = 5的情况，可能性有5 ⋅ 4 ⋅ 3 = 60种。一般来说，可能组合数的公式是：
- en: '![Image](../images/pg102_Image_115.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg102_Image_115.jpg)'
- en: 'In our example, though, the order of the elements selected for the subset doesn’t
    matter, so we have to deal with the fact that different orderings of the *k* choices
    can lead to the same subset (like the ABC and BAC orderings mentioned earlier).
    How can we figure out how many different ways there are to order a subset of *k*
    elements? We can apply the same logic we just used for *n* to find out: there
    are *k* possibilities for what the first element could be, then *k* – 1 possibilities
    for the second element, and so on. So the total number of orderings is:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，尽管选择子集中的元素顺序并不重要，但我们必须考虑到不同的顺序会导致相同的子集（就像之前提到的ABC和BAC顺序）。我们如何计算有多少种不同的方式来排列一个包含*k*个元素的子集呢？我们可以使用我们刚才用来处理*n*的相同逻辑来找出答案：第一个元素有*k*种可能性，第二个元素有*k*
    – 1种可能性，依此类推。所以，总的排列数是：
- en: '![Image](../images/pg102_Image_116.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg102_Image_116.jpg)'
- en: 'For *k* = 3, for example, there are 3 ⋅ 2 ⋅ 1 = 6 ways to order a particular
    set of three elements. This means that if we want to count only the unique subsets,
    ignoring rearrangements, we should count only one out of every six of the total
    number of combinations. That is, if there are 5 ⋅ 4 ⋅ 3 ways to pick three elements
    from a group of five, and there are 3 ⋅ 2 ⋅ 1 ways to order those three elements,
    there are (5 ⋅ 4 ⋅ 3) / (3 ⋅ 2 ⋅ 1) = 60 / 6 = 10 unique subsets, ignoring order.
    The general formula is:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于*k* = 3，排列三个特定元素的方式有3 ⋅ 2 ⋅ 1 = 6种。这意味着，如果我们只想计算唯一的子集，忽略排列顺序，我们应该每六个组合中只计数一个。也就是说，如果从五个元素中选择三个元素的方式有5
    ⋅ 4 ⋅ 3种，而这三个元素的排列方式有3 ⋅ 2 ⋅ 1种，那么总共有(5 ⋅ 4 ⋅ 3) / (3 ⋅ 2 ⋅ 1) = 60 / 6 = 10个唯一子集，不考虑顺序。一般公式是：
- en: '![Image](../images/pg102_Image_117.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg102_Image_117.jpg)'
- en: 'Notice that we’ve been using the same variables here that we were using to
    identify the rows and columns in Pascal’s triangle: *n* and *k*. That’s because
    the two problems are related. The formula to calculate a particular term *C*(*n*,
    *k*) in Pascal’s triangle—and, by extension, the formula to determine a particular
    binomial coefficient—is the same one we just worked out:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里使用的变量与我们用来表示帕斯卡三角形中行和列的变量相同：*n*和*k*。这是因为这两个问题是相关的。计算帕斯卡三角形中特定项*C*(*n*,
    *k*)的公式——也就是说，计算二项式系数的公式——与我们刚刚算出来的公式是一样的：
- en: '![Image](../images/pg103_Image_118.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg103_Image_118.jpg)'
- en: 'There’s a special sequence, the *factorial numbers*, that lets us write the
    formula for *C*(*n*, *k*) in a neater way. If *n* is a positive integer, *n* factorial
    (written as *n*!) is the product of every integer from 1 to *n*. For example,
    3! is 1 ⋅ 2 ⋅ 3 = 6, and 5! is 1 ⋅ 2 ⋅ 3 ⋅ 4 ⋅ 5 = 120\. More formally:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊的数列，叫做*阶乘数*，它让我们以更简洁的方式写出*C*(*n*, *k*)的公式。如果 *n* 是一个正整数，*n* 的阶乘（写作 *n*!）是从
    1 到 *n* 的每个整数的乘积。例如，3! 是 1 ⋅ 2 ⋅ 3 = 6，5! 是 1 ⋅ 2 ⋅ 3 ⋅ 4 ⋅ 5 = 120。更正式地说：
- en: '![Image](../images/pg103_Image_119.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg103_Image_119.jpg)'
- en: 'Looking at the sequences of terms in the formula for *C*(*n*, *k*), it’s clear
    there’s some kind of factorial logic involved. With a bit of algebra, we can simplify
    the formula to make factorial notation apply:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看 *C*(*n*, *k*) 公式中的项序列，可以明显看出其中涉及了一些阶乘的逻辑。通过一些代数运算，我们可以简化公式，使阶乘符号得以应用：
- en: '![Image](../images/pg103_Image_120.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg103_Image_120.jpg)'
- en: Calculating factorials manually gets tedious as *n* and *k* get bigger. With
    Scratch Cat’s help, however, it’s a breeze.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 *n* 和 *k* 越大，手动计算阶乘变得非常繁琐。然而，有了 Scratch Cat 的帮助，一切变得轻松自如。
- en: 'Project 18: Pick a Number from Pascal’s Triangle'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 18：从帕斯卡三角形中选一个数字
- en: In this project, we’ll use the factorial definition we just arrived at for *C*(*n*,
    *k*) to make Scratch calculate the binomial coefficient for any given values of
    *n* and *k*. Put another way, we’ll write a program that calculates the entry
    at the *n*th row and *k*th column of Pascal’s triangle. [Figure 5-1](ch05.xhtml#ch5fig1)
    shows how.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，我们将使用刚刚得到的阶乘定义来计算 *C*(*n*, *k*)，从而让 Scratch 计算给定 *n* 和 *k* 的二项式系数。换句话说，我们将编写一个程序，计算帕斯卡三角形中
    *n* 行 *k* 列的数字。[图 5-1](ch05.xhtml#ch5fig1)展示了如何实现。
- en: '![Image](../images/pg103_Image_121.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg103_Image_121.jpg)'
- en: '*Figure 5-1: Calculating binomial coefficients with factorials*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：使用阶乘计算二项式系数*'
- en: 'The main program is the shortest one in this book: it’s just one line, to call
    the custom block that calculates the binomial coefficient for a given `n` and
    `k`. That block, in turn, calls the `factorial` calculator block, which takes
    in a value and calculates its factorial, using a loop to multiply all the numbers
    from 1 up to that value. The result is held in the `product` variable, which we
    set to `1` at the start of the block.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序是本书中最简短的一个：它仅包含一行代码，用于调用计算给定 `n` 和 `k` 的二项式系数的自定义块。该块又调用 `factorial` 计算块，后者接收一个值并计算它的阶乘，使用循环将
    1 到该值之间的所有数字相乘。结果存储在 `product` 变量中，我们在块的开始将其设置为 `1`。
- en: 'We use the `factorial` block three times to calculate `n` factorial, `k` factorial,
    and `n - k` factorial, storing the resulting values of `product` in the variables
    `x`, `y`, and `z`. Then, we calculate `x / y * z` to get the binomial coefficient
    ❶. This is the equivalent of our formula:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `factorial` 块三次来计算 `n` 的阶乘、`k` 的阶乘和 `n - k` 的阶乘，将计算得到的 `product` 的值分别存储在变量
    `x`、`y` 和 `z` 中。然后，我们计算 `x / y * z` 得到二项式系数 ❶。这就是我们公式的等价表达：
- en: '![Image](../images/pg104_Image_122.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg104_Image_122.jpg)'
- en: This program uses sliders to set the `n` and `k` inputs. Sliders are more efficient
    at receiving input than the `ask and wait` block in previous projects, and they
    let us automatically limit the input values to only integers within a certain
    range, sparing us from having to screen for inappropriate inputs like negative
    integers, strings, or numbers with decimals. To create a slider for a variable,
    right-click the variable on the stage and choose **slider** from the drop-down
    menu, as in [Figure 5-2](ch05.xhtml#ch5fig2).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序使用滑块来设置 `n` 和 `k` 的输入。滑块比之前项目中的 `ask and wait` 块更高效地接收输入，并且它们能自动将输入值限制在一定范围内的整数，从而避免了我们必须筛选不适当的输入（如负整数、字符串或带小数的数字）。要为变量创建一个滑块，可以右击舞台上的变量，然后从下拉菜单中选择**滑块**，如[图
    5-2](ch05.xhtml#ch5fig2)所示。
- en: '![Image](../images/pg104_Image_123.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg104_Image_123.jpg)'
- en: '*Figure 5-2: Using sliders to calculate* C*(5, 3) = 10*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：使用滑块计算* C*(5, 3) = 10*'
- en: Dragging the slider’s circle to the left or right changes the associated variable’s
    value over a range you can specify using the change slider range option from the
    drop-down menu. I set the slider ranges to be 1 to 50 for *n* and 0 to 50 for
    *k*, but as we’ll discuss, even those ranges might cause trouble for some of the
    binomial coefficients we calculate.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 拖动滑块的圆圈左右移动，会改变相关变量的值，范围可以通过下拉菜单中的更改滑块范围选项来指定。我将滑块范围设置为 *n* 从 1 到 50，*k* 从 0
    到 50，但正如我们将要讨论的那样，这些范围可能会对我们计算的某些二项式系数造成问题。
- en: To use the program, set the sliders to your chosen *n* and *k* values, then
    click the green flag to see the resulting binomial coefficient.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用程序，设置滑块为你选择的 *n* 和 *k* 值，然后点击绿色旗帜查看结果的二项式系数。
- en: Hacking the Code
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: There’s a problem with this program. I set up the pizza party counting scenario
    with the assumption that *k* (the number of guests allowed) is less than or equal
    to *n* (the total number of people to choose from). But while the sliders limit
    *n* and *k* to integers, there’s nothing stopping us from making *k* greater than
    *n*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序有一个问题。我在设置披萨派对计数场景时，假设 *k*（允许的客人数量）小于或等于 *n*（总共可选择的人数）。但是，虽然滑块限制了 *n* 和
    *k* 为整数，但并没有任何限制阻止我们将 *k* 设置为大于 *n*。
- en: If we set the sliders this way, when it comes time to calculate (*n* – *k*)!,
    we’ll end up passing the `factorial` block a negative number. A `repeat` loop
    can’t repeat a negative number of times, so the loop will exit before the first
    pass and `product` will be stuck with its initial value of `1`. This breaks the
    formula and reports a weird result, as shown in [Figure 5-3](ch05.xhtml#ch5fig3).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将滑块设置为这样，当计算(*n* – *k*)!时，我们会传递给`factorial`块一个负数。`repeat`循环不能重复负次数，因此循环会在第一次执行之前退出，而`product`会保持初始值`1`。这会破坏公式，并报告一个奇怪的结果，如[图
    5-3](ch05.xhtml#ch5fig3)所示。
- en: '![Image](../images/pg105_Image_124.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg105_Image_124.jpg)'
- en: '*Figure 5-3:* C*(5, 6) = ???*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3:* C*(5, 6) = ???'
- en: 'The fix is pretty easy: just put a test into the main program to check for
    *k* > *n* and notify the user that the inputs are invalid if this condition is
    met, as shown in [Figure 5-4](ch05.xhtml#ch5fig4).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法很简单：只需要在主程序中加入一个测试，检查 *k* 是否大于 *n*，如果满足该条件，通知用户输入无效，如[图 5-4](ch05.xhtml#ch5fig4)所示。
- en: '![Image](../images/pg105_Image_125.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg105_Image_125.jpg)'
- en: '*Figure 5-4: Adding a check for* k *>* n'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：为* k *>* n 添加检查'
- en: Notice that we’re using a variable called `C(n, k)` ❶, while also using a custom
    block called `C` with `n` and `k` inputs ➋ to calculate a value to assign to that
    variable. Scratch’s color coding and block shapes help us keep track of which
    `C(n, k)` is which.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了一个名为`C(n, k)`的变量❶，同时使用了一个自定义块`C`，该块有`n`和`k`两个输入➋，用来计算一个值并赋给该变量。Scratch的颜色编码和块的形状帮助我们跟踪哪个是`C(n,
    k)`。
- en: 'Another problem with this program is that factorials get big quickly: 18! is
    the largest factorial Scratch can reliably calculate before reaching flintmax.
    In practice, since *n*! is always divisible by various powers of 2, the reported
    value remains correct for a while even after exceeding flintmax, but by the time
    we get to 171! we’ve exceeded the overall maximum of the IEEE 754 floating-point
    standard. At that point, Scratch gives up, reporting values involving calculations
    of 171! or larger as `Infinity` (see [Figure 5-5](ch05.xhtml#ch5fig5)).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的另一个问题是，阶乘增长得非常快：18! 是Scratch能够可靠计算的最大阶乘值，超过flintmax就无法计算了。实际上，由于 *n*! 总是可以被2的不同幂次整除，所以在超过flintmax后，报告的值仍然是正确的，但当我们计算到171!时，已经超过了IEEE
    754浮点标准的总体最大值。此时，Scratch会放弃计算，报告涉及171!或更大阶乘的值为`Infinity`（见[图 5-5](ch05.xhtml#ch5fig5)）。
- en: '![Image](../images/pg105_Image_126.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg105_Image_126.jpg)'
- en: '*Figure 5-5:* C*(171, 18) = ???*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5:* C*(171, 18) = ???'
- en: Even for smaller values, the rounding in IEEE 754 for integers larger than flintmax
    can spoil the results and yield a non-integer value, as shown in [Figure 5-6](ch05.xhtml#ch5fig6).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于较小的值，IEEE 754对大于flintmax的整数进行四舍五入也会破坏结果并产生非整数值，如[图 5-6](ch05.xhtml#ch5fig6)所示。
- en: '![Image](../images/pg105_Image_127.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg105_Image_127.jpg)'
- en: '*Figure 5-6:* C*(49, 23) = ???*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6:* C*(49, 23) = ???'
- en: In fairness, the true value of *C*(49, 23) is 58,343,356,817,424, so Scratch
    is pretty close, but “pretty close” isn’t good enough. To enable Scratch to keep
    finding the exact binomial coefficients for bigger values of *n* and *k*, we need
    to take a different approach, one that doesn’t involve working with factorials.
    For this, we can take advantage of the fact that even though the factorials in
    the formula for *C*(*n*, *k*) quickly get large, the binomial coefficients themselves
    don’t grow so big so fast. So if we can calculate the binomial coefficients without
    first calculating any factorials, we’ll be able to get a lot further before hitting
    flintmax.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，*C*(49, 23) 的真实值是 58,343,356,817,424，所以 Scratch 的结果已经非常接近，但“非常接近”还不够好。为了让
    Scratch 能够继续为更大值的 *n* 和 *k* 找到准确的二项式系数，我们需要采取一种不同的方法，这种方法不涉及阶乘运算。为此，我们可以利用这样的事实：尽管
    *C*(*n*, *k*) 公式中的阶乘很快变得很大，但二项式系数本身并不会这么迅速增长。所以，如果我们能够在不先计算任何阶乘的情况下计算二项式系数，我们就能在达到
    flintmax 之前走得更远。
- en: Pascal’s Recurrence
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pascal 的递归
- en: The value at row *n* and column *k* of Pascal’s triangle is the binomial coefficient
    *C*(*n*, *k*). If we can find a recurrence for Pascal’s triangle—a rule for generating
    the next value in the array based on the previous values—we’ll be able to calculate
    binomial coefficients without any need for factorials.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal 三角形中第 *n* 行和第 *k* 列的值是二项式系数 *C*(*n*, *k*)。如果我们能够找到 Pascal 三角形的递归公式——一种基于前一个值生成数组中下一个值的规则——我们就可以在不需要阶乘的情况下计算二项式系数。
- en: 'With arrays, we have lots of flexibility in deciding which previous elements
    should be used to specify the recurrence. “Previous element” here can mean a value
    in an earlier row or an earlier value in the same row. I hinted at a recurrence
    for Pascal’s triangle in the initial description: each value is the sum of the
    two adjacent values immediately above it. Here’s how to write that as a recurrence:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组，我们在决定应该使用哪些前一个元素来指定递归时有很大的灵活性。这里的“前一个元素”可以是早期行中的值，也可以是同一行中的早期值。我在最初的描述中提到了
    Pascal 三角形的递归：每个值是直接上方两个相邻值的和。以下是如何将其写为递归的方式：
- en: '![Image](../images/pg106_Image_128.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg106_Image_128.jpg)'
- en: To see why this works, we can interpret each value *C*(*n*, *k*) in Pascal’s
    triangle as the answer to a subset counting problem. Instead of thinking about
    guests at a pizza party, let’s think about counting how many ways there are to
    pick a set of *k* of the (1 + *x*) factors among all of the *n* factors in (1
    + *x*)^(*n*). Every way of picking *k* factors adds another *x*^(*k*) to the total.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么这个方法有效，我们可以将 Pascal 三角形中的每个值 *C*(*n*, *k*) 解释为一个子集计数问题的答案。我们不再考虑披萨派对上的客人，而是思考在
    (1 + *x*)^(*n*) 中如何从 *n* 个因子中选择 *k* 个 (1 + *x*) 因子的组合方式。每种选择 *k* 个因子的方式都会将一个 *x*^(*k*)
    加到总和中。
- en: For example, suppose we want to expand (1 + *x*)⁴ and see what the coefficient
    should be for *x*³. That would be the binomial coefficient *C*(4, 3). When we
    multiply out (1 + *x*)(1 + *x*)(1 + *x*)(1 + *x*), in each factor of (1 + *x*)
    we can pick either the 1 or the *x* to multiply. To get a term of *x*³, we need
    to pick 1 once and *x* three times. We could pick the first factor’s 1, or the
    second factor’s 1, or the third factor’s 1, or the last factor’s 1, so there are
    four ways that we could get *x*³. That makes *C*(4, 3) = 4.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想展开 (1 + *x*)⁴ 并查看 *x*³ 的系数应该是多少。这就是二项式系数 *C*(4, 3)。当我们展开 (1 + *x*)(1
    + *x*)(1 + *x*)(1 + *x*) 时，在每个 (1 + *x*) 因子中，我们可以选择 1 或 *x* 来进行相乘。为了得到 *x*³ 项，我们需要选择一次
    1 和三次 *x*。我们可以选择第一个因子的 1，或者第二个因子的 1，或者第三个因子的 1，或者最后一个因子的 1，因此有四种方法可以得到 *x*³。这使得
    *C*(4, 3) = 4。
- en: 'Now consider only *n* – 1 repeated (1 + *x*) factors. The binomial coefficients
    for (1 + *x*)^(*n* – 1) are listed in row *n* – 1 of Pascal’s triangle. If we
    want go to from row *n* – 1 to row *n*, we have to multiply by one extra factor
    of (1 + *x*). Again, we need to pick either the 1 or the *x* for the multiplication.
    There are two possibilities: either we already have *k* occurrences of *x* when
    we pick factors in (1 – *x*)^(*k* – 1), in which case we multiply by the 1 of
    the extra factor, or we have *k* – 1 occurrences of *x*, in which case we multiply
    by the *x* of the extra factor to get *k* occurrences. That accounting gives the
    recurrence I just mentioned, which we can use to build the triangle row by row:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只考虑 *n* – 1 次重复的 (1 + *x*) 因子。对于 (1 + *x*)^(*n* – 1)，二项式系数列在帕斯卡三角形的 *n* –
    1 行。如果我们想从 *n* – 1 行到 *n* 行，我们需要再乘一个 (1 + *x*) 的额外因子。同样，我们需要选择 (1 + *x*) 中的 1
    或 *x* 进行乘法运算。有两种可能性：要么我们在选择 (1 – *x*)^(*k* – 1) 的因子时，已经有了 *k* 次 *x*，此时我们乘上额外因子的
    1，要么我们有 *k* – 1 次 *x*，此时我们乘上额外因子的 *x* 来得到 *k* 次 *x*。这种计算给出了我刚才提到的递归关系，我们可以用它逐行构建三角形：
- en: '![Image](../images/pg106_Image_129.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg106_Image_129.jpg)'
- en: Again, all this means is that to get an entry in Pascal’s triangle, we just
    need to add the two numbers above it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这一切意味着，为了得到帕斯卡三角形中的一个条目，我们只需要将它上面两个数字相加。
- en: This recurrence helps us make sense of the value 4 that we calculated for *C*(4,
    3). First, we step back a row in the triangle, from row 4 to row 3, to the coefficients
    for the expansion of (1 + *x*)³. We can then either take the *x*² terms in that
    row that are counted by *C*(3, 2) and multiply them by *x*, or take the *x*³ terms
    there that are counted by *C*(3, 3) and multiply them by 1\. Those are the only
    ways to build an *x*³ term in row 4\. That means *C*(3, 2) + *C*(3, 3) = *C*(4,
    3).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递归关系帮助我们理解我们为 *C*(4, 3) 计算出的值 4。首先，我们回退到三角形中的一行，从第 4 行回到第 3 行，对应 (1 + *x*)³
    的展开系数。然后，我们可以选择该行中由 *C*(3, 2) 计算的 *x*² 项，并将其乘以 *x*，或者选择该行中由 *C*(3, 3) 计算的 *x*³
    项，并将其乘以 1。只有这两种方式可以在第 4 行生成 *x*³ 项。这意味着 *C*(3, 2) + *C*(3, 3) = *C*(4, 3)。
- en: 'Project 19: Pascal’s Triangle, Row by Row'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 19：帕斯卡三角形，逐行计算
- en: '[Figure 5-7](ch05.xhtml#ch5fig7) shows a Scratch program to calculate up to
    the *n*th row of Pascal’s triangle using the recurrence we just discussed.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-7](ch05.xhtml#ch5fig7) 显示了一个 Scratch 程序，用来计算帕斯卡三角形的第 *n* 行，使用我们刚刚讨论的递归关系。'
- en: '![Image](../images/pg107_Image_130.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg107_Image_130.jpg)'
- en: '*Figure 5-7: Calculating Pascal’s triangle, row by row*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-7：逐行计算帕斯卡三角形*'
- en: 'First, we ask which row to calculate ❶. Then, we loop that many times to work
    through all the rows up to that one. We use two lists to keep track of the values:
    `row` is the previous row in the array, and `newrow` is the current row being
    calculated. We start each new row with a `1` ➋, then add each adjacent pair of
    values from `row` to get the next value in `newrow` ➌, as specified by our recurrence.
    At the end of each cycle through the loop, the custom `copy newrow to row` block
    copies `newrow` back to `row` to get ready for the next iteration.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们询问要计算的行号 ❶。然后，我们进行相应次数的循环，逐行处理到该行。我们使用两个列表来跟踪值：`row` 是数组中的前一行，`newrow`
    是当前正在计算的行。我们从每一行开始时都会放入一个 `1` ➋，然后将 `row` 中每一对相邻的值相加，得到 `newrow` 中的下一个值 ➌，正如我们递归关系所规定的那样。在每次循环结束时，自定义的
    `copy newrow to row` 块会将 `newrow` 复制回 `row`，为下一次迭代做准备。
- en: The Results
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: '[Figure 5-8](ch05.xhtml#ch5fig8) shows a sample run of the program, for *n*
    = 8.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-8](ch05.xhtml#ch5fig8) 显示了该程序的一个示例运行，*n* = 8 时的结果。'
- en: '![Image](../images/pg108_Image_131.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg108_Image_131.jpg)'
- en: '*Figure 5-8: Row 8 of Pascal’s triangle*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-8：帕斯卡三角形的第 8 行*'
- en: Notice that, since Scratch lists are indexed starting with 1 rather than 0,
    the first element, *C*(8, 0) = 1, isn’t listed in the output. It *was* calculated,
    but we deleted it from the list at the end of the program ➍. This way, Scratch’s
    index numbers match the values of *k* for the given row. Just imagine that there’s
    an extra 1 at the start of the list, at index 0.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于 Scratch 列表的索引从 1 开始，而不是从 0 开始，因此输出中没有列出第一个元素 *C*(8, 0) = 1。它*确实*被计算了，但我们在程序结束时删除了它
    ➍。这样，Scratch 的索引号与给定行的 *k* 值相匹配。只需要想象在列表的开头有一个额外的 1，位于索引 0 处。
- en: With this approach, we can go much further with calculating exact binomial coefficients.
    In fact, we don’t exceed flintmax until we get to row *n* = 56 of Pascal’s triangle.
    There, the value for *k* = 25 is off (but *k* = 26, 27, and 28 are reported correctly).
    We also don’t have any binomial coefficients reported as `Infinity` until we get
    past row 1,000.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，我们可以在计算精确的二项式系数时走得更远。事实上，直到到达帕斯卡三角形的第*n* = 56行时，我们才会超过flintmax。在那里，*k*
    = 25的值是错误的（但*k* = 26、27和28的值是正确的）。我们直到超过第1000行时，才会看到任何二项式系数报告为`Infinity`。
- en: 'Project 20: Drawing Pascal’s Triangle'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目20：绘制帕斯卡三角形
- en: 'One way to understand Pascal’s triangle is to think about how the values of
    the binomial coefficients are distributed in each row. For example, we can observe
    that the values are symmetric around the center of the row: 1-2-1, 1-3-3-1, 1-4-6-4-1,
    and so on.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 理解帕斯卡三角形的一种方式是思考每一行的二项式系数如何分布。例如，我们可以观察到，值是围绕行的中心对称分布的：1-2-1，1-3-3-1，1-4-6-4-1，依此类推。
- en: Mathematically, we can express each row’s symmetry by noting that the value
    at column *k* in row *n* is the same as the value at column *n* – k in the same
    row. In other words, *C*(*n*, *k*) = *C*(*n*, *n* – *k*). We can verify this observation
    by thinking about the subset counting interpretation of Pascal’s triangle, discussed
    earlier in this chapter. To create a subset of *k* out of *n* elements, we can
    say either which *k* elements should be included or which *n* – *k* elements should
    *not* be included.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学角度看，我们可以通过注意到帕斯卡三角形第*n*行第*k*列的值与同一行第*n* – *k*列的值相同来表达每一行的对称性。换句话说，*C*(*n*,
    *k*) = *C*(*n*, *n* – *k*)。我们可以通过回顾本章早些时候讨论的帕斯卡三角形的子集计数解释来验证这一观察。要从*n*个元素中创建一个包含*k*个元素的子集，我们可以指定哪些*k*个元素应包含，或者哪些*n*
    – *k*个元素应*不*包含。
- en: 'Another interesting observation is that the sum of the binomial coefficients
    in the *n*th row of Pascal’s triangle is 2^(*n*). In row *n* = 3, for example,
    1 + 3 + 3 + 1 = 8, or 2³, and in row *n* = 4, 1 + 4 + 6 + 4 + 1 = 16, or 2⁴. This
    also connects with the subset counting interpretation: there are a total of 2^(*n*)
    subsets of a set with *n* elements because for each of the *n* elements, there’s
    a choice of two possibilities: to include that element in a subset or not.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的观察是，帕斯卡三角形第*n*行的二项式系数之和为2^(*n*)。例如，在第*n* = 3行时，1 + 3 + 3 + 1 = 8，或者2³，而在第*n*
    = 4行时，1 + 4 + 6 + 4 + 1 = 16，或者2⁴。这也与子集计数的解释相关：一个包含*n*个元素的集合共有2^(*n*)个子集，因为对于每个*n*个元素，存在两个选择：包括该元素或不包括该元素。
- en: One more feature worth noting is that the values in each row are *unimodal*,
    meaning they start small, increase toward a largest value in the middle, and then
    get small again. We can make observations like these by looking at the numbers
    themselves, but features like the values’ symmetry and their unimodal structure
    are even easier to spot if we visualize rows of Pascal’s triangle as bar graphs.
    Also called a *histogram*, a *bar graph* is a chart where the value of each entry
    is represented by the height of a bar. For example, [Figure 5-9](ch05.xhtml#ch5fig9)
    shows a bar graph representing the values in row *n* = 10 of Pascal’s triangle.
    Notice the symmetry of the bar heights.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的特征是，每一行的值都是*单峰的*，这意味着它们先是较小，朝着中间的最大值增加，然后再变小。我们可以通过观察数字本身来发现这些特征，但像值的对称性和单峰结构这样的特征，通过将帕斯卡三角形的行可视化为条形图会更容易观察到。条形图，也称为*直方图*，是一种图表，其中每个条目的值由条形的高度表示。例如，[图5-9](ch05.xhtml#ch5fig9)显示了一个条形图，表示帕斯卡三角形第*n*
    = 10行的值。请注意条形高度的对称性。
- en: '![Image](../images/pg109_Image_132.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg109_Image_132.jpg)'
- en: '*Figure 5-9: Row 10 of Pascal’s triangle*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-9：帕斯卡三角形第10行*'
- en: To draw bar graphs like these, start with the program in [Project 19](ch05.xhtml#ch05lev7)
    ([Figure 5-7](ch05.xhtml#ch5fig7)) for calculating a row of Pascal’s triangle.
    Then, add the custom `draw histogram` block shown in [Figure 5-10](ch05.xhtml#ch5fig10).
    It uses blocks from the Pen extension to draw a bar for each value in the row.
    Be sure to insert this custom block *before* you delete the `1` at the start of
    the row ([Figure 5-7](ch05.xhtml#ch5fig7) ➍), or the symmetry will be spoiled.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制像这样的条形图，从[项目19](ch05.xhtml#ch05lev7)（[图5-7](ch05.xhtml#ch5fig7)）开始，该项目用于计算帕斯卡三角形的一行。然后，添加[图5-10](ch05.xhtml#ch5fig10)中所示的自定义`draw
    histogram`模块。它使用来自Pen扩展的模块为每个行中的值绘制一个条形。务必在删除行开头的`1`之前插入此自定义模块（[图5-7](ch05.xhtml#ch5fig7)
    ➍），否则对称性将被破坏。
- en: '![Image](../images/pg110_Image_133.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg110_Image_133.jpg)'
- en: '*Figure 5-10: Drawing a bar graph from a row*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-10：从一行绘制条形图*'
- en: The `draw histogram` block first takes the `row` list from the Pascal’s triangle
    program and finds its maximum entry using the custom `find max of row` block (shown
    in [Figure 5-11](ch05.xhtml#ch5fig11)). Based on this maximum, we calculate `horizontal
    step size` and `vertical step size` to ensure the drawing will fit on the stage
    ❶. Then, we use a loop ➋ to draw the bar graph one bar at a time, moving up based
    on the corresponding value in `row`, across based on the number of bars to draw,
    and then back down to start on the next bar.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw histogram` 块首先从帕斯卡三角形程序中获取 `row` 列表，并使用自定义的 `find max of row` 块（见[图 5-11](ch05.xhtml#ch5fig11)）找到其中的最大值。根据这个最大值，我们计算
    `horizontal step size` 和 `vertical step size`，确保图形能够适应舞台 ❶。然后，我们使用循环 ➋ 一次画一个条形图，根据
    `row` 中对应的值向上移动，按条形的数量水平移动，然后再回到起始位置开始下一个条形。'
- en: '![Image](../images/pg111_Image_134.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg111_Image_134.jpg)'
- en: '*Figure 5-11: Finding the maximum row element*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-11：寻找最大行元素*'
- en: The `find max of row` block simply cycles through all the values in `row`, updating
    the `max` variable each time it finds a higher value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`find max of row` 块简单地遍历 `row` 中的所有值，每当找到更高的值时，就更新 `max` 变量。'
- en: The Results
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: '[Figure 5-12](ch05.xhtml#ch5fig12) shows the bar graphs for two more rows of
    the triangle.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-12](ch05.xhtml#ch5fig12) 显示了三角形的另外两行条形图。'
- en: '![Image](../images/pg111_Image_135.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg111_Image_135.jpg)'
- en: '*Figure 5-12: Rows 20 (left) and 50 (right) of Pascal’s triangle*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-12：帕斯卡三角形的第 20 行（左）和第 50 行（右）*'
- en: No matter the row, the shape of the bar graph looks similar. In fact, as *n*
    increases, the graph gets closer and closer to the famous bell curve of a normal
    distribution.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是哪一行，条形图的形状看起来都很相似。事实上，随着 *n* 的增加，图形越来越接近著名的正态分布的钟形曲线。
- en: Hacking the Code
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: The new `draw histogram` block is general enough to draw bar graphs for other
    datasets besides rows from Pascal’s triangle. For example, the code in [Figure
    5-13](ch05.xhtml#ch5fig13) prompts the user to enter a series of numbers—similar
    to what we did in [Project 17](ch04.xhtml#ch04lev13) ([Figure 4-16](ch04.xhtml#ch4fig16)),
    when we were working with difference tables—and then calls the `draw histogram`
    block to visualize that data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `draw histogram` 块足够通用，能够为除帕斯卡三角形行之外的其他数据集绘制条形图。例如，[图 5-13](ch05.xhtml#ch5fig13)
    中的代码提示用户输入一系列数字——类似于我们在[项目 17](ch04.xhtml#ch04lev13)中做的那样（[图 4-16](ch04.xhtml#ch4fig16)），当时我们正在使用差分表——然后调用
    `draw histogram` 块来可视化这些数据。
- en: '![Image](../images/pg112_Image_136.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg112_Image_136.jpg)'
- en: '*Figure 5-13: Creating a bar graph from a dataset*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-13：从数据集中创建条形图*'
- en: The `draw histogram` block expects the data to be in a list called `row` with
    a length of `n`. As long as your program has these features, the bar graph code
    will work. If all you have is `row`, you’ll need to supply `n` before drawing
    the bar graph ❶.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw histogram` 块期望数据以一个名为 `row` 的列表的形式存在，且长度为 `n`。只要你的程序具备这些特性，条形图代码就能正常工作。如果你只有
    `row`，那么在绘制条形图之前，你需要提供 `n` ❶。'
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**5.1** You might notice in a table of values of *n*! that for larger values
    of *n*, the value of *n*! will end with several zeros. Write a program to predict
    how many zeros there will be for a given *n*. In particular, can you predict how
    many zeros the value of 25! will end with?'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.1** 你可能会注意到，在 *n*! 的值表中，对于较大的 *n* 值，*n*! 的值将以多个零结尾。编写一个程序来预测给定 *n* 时会有多少个零。特别是，你能预测
    25! 的值将以多少个零结尾吗？'
- en: '**5.2** Write a program to extract sequences from Pascal’s triangle by stepping
    down along a diagonal. Use it to consider the diagonal in Pascal’s triangle consisting
    of values of *C*(*n*, 2). Identify this sequence in terms of the figurate numbers
    we discussed in [Chapter 4](ch04.xhtml#ch04).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.2** 编写一个程序，通过沿对角线向下遍历，从帕斯卡三角形中提取数列。利用它来考虑帕斯卡三角形中的对角线，该对角线包含 *C*(*n*, 2)
    的值。根据我们在[第 4 章](ch04.xhtml#ch04)中讨论的数形数字，识别这一数列。'
- en: '**5.3** As an integer, the value of a binomial coefficient can be either even
    or odd. Change the row recurrence program for Pascal’s triangle ([Project 19](ch05.xhtml#ch05lev7))
    so it shows only 0 or 1, depending on if the binomial coefficient is even or odd.
    See what kinds of patterns you can find.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.3** 作为一个整数，二项式系数的值可以是偶数或奇数。修改帕斯卡三角形的行递推程序（[项目 19](ch05.xhtml#ch05lev7)），使其仅显示
    0 或 1，取决于二项式系数是偶数还是奇数。看看你能找到什么样的模式。'
- en: Operation Tables Have All the Answers
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作表有所有答案
- en: An *operation table* is a table of values showing the result of a mathematical
    operation, given different combinations of inputs. For example, you probably learned
    basic multiplication using a multiplication table, or times table. This type of
    operation table usually has nine rows and nine columns, and it gives the answer
    to any multiplication problem where the two numbers being multiplied are indicated
    by the row and column. If you wanted to multiply 6 times 7, for instance, you
    would go across the top row (the index row) to find 6 and down the left column
    (the index column) to find 7\. The value where column 6 and row 7 intersect is
    42.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作表*是一个值表，显示在不同输入组合下数学运算的结果。例如，你可能通过乘法表（乘法口诀表）学习了基本的乘法。此类操作表通常有九行九列，它提供任何乘法问题的答案，其中被乘数和乘数通过行和列来表示。例如，如果你想计算6乘7，你会在顶部的行（索引行）中找到6，然后在左侧的列（索引列）中找到7。列6和行7交叉处的值是42。'
- en: We couldn’t possibly create a complete multiplication table for all the positive
    integers because there are infinitely many of them. However, the usual nine-by-nine
    multiplication table for single-digit numbers has all the information we need
    to calculate products of longer numbers. Compare this situation with the modular
    arithmetic we discussed in [Chapter 2](ch02.xhtml#ch02). Once you pick a modulus,
    say *n*, all that matters is the remainder when a number is divided by *n*. There
    are only *n* possible remainders, 0 through *n* – 1\. That means any operation
    table based on modular arithmetic will have a finite number of entries, and an
    *n*-by-*n* table will include them all.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不可能为所有正整数创建一个完整的乘法表，因为它们是无限的。然而，通常用于单个数字的九乘九乘法表包含了我们计算更长数字乘积所需的所有信息。将这种情况与我们在[第二章](ch02.xhtml#ch02)中讨论的模运算做比较。一旦你选择了一个模数，比如*n*，那么重要的只是一个数字除以*n*后的余数。余数的可能值只有*n*个，从0到*n*
    - 1。这意味着基于模运算的任何操作表都会有一个有限的条目数，一个*n*乘*n*的表格会包含所有可能的条目。
- en: A finite operation table, with its rows and columns, qualifies as an array.
    In the next project, we’ll use Scratch to generate operation tables for a given
    modulus and then see what kinds of patterns we can find.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有限操作表，包含行和列，符合数组的定义。在下一个项目中，我们将使用Scratch生成给定模数的操作表，然后看看我们能发现哪些模式。
- en: 'Project 21: Infinite Operation Tables with Modular Arithmetic'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目21：使用模运算生成无限操作表
- en: 'Our program will prompt the user for a modulus *n*, then ask them to choose
    an operation: addition or multiplication. It will then build an *n*-by-*n* table
    showing all possible outcomes of the chosen operation, mod *n*. For example, say
    the modulus is 7\. The addition table should show the sum of every possible pair
    of numbers from 0 to 6, interpreted mod 7\. The entry at the intersection of column
    6 and row 2, for instance, should show (6 + 2) mod 7, which is 1\. The multiplication
    table does the same for multiplication: the intersection of column 6 and row 2
    should show (6 ⋅ 2) mod 7, which is 5.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序会提示用户输入一个模数*n*，然后询问他们选择哪种操作：加法还是乘法。接着，它会构建一个*n*乘*n*的表格，展示所选操作下的所有可能结果，模*n*。例如，假设模数是7。加法表应该显示从0到6的每一对数字的和，取模7。例如，列6和行2交汇处的条目应该显示(6
    + 2) mod 7，结果是1。乘法表则对乘法执行相同操作：列6和行2交汇处的条目应该显示(6 ⋅ 2) mod 7，结果是5。
- en: '![Image](../images/pg113_Image_137.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg113_Image_137.jpg)'
- en: '*Figure 5-14: Asking what modulus and what operation*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-14：询问模数和操作类型*'
- en: We’ll build each row of the table as an entry in a Scratch list called `table`.
    First, we need some custom blocks to help us get organized. [Figure 5-14](ch05.xhtml#ch5fig14)
    shows the `setup` block, which is called at the start of the program.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把表格的每一行构建为Scratch列表中的一个条目，列表名为`table`。首先，我们需要一些自定义积木来帮助我们整理。[图5-14](ch05.xhtml#ch5fig14)展示了`setup`积木，它在程序开始时被调用。
- en: In the `setup` block, we first delete any previous version of `table` ❶. Then,
    we prompt the user for the `modulus` (an integer) and `operation` (`+` or `*`).
    Once we have that information, we call the `Make index row` block ➋, shown in
    [Figure 5-15](ch05.xhtml#ch5fig15).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup`积木中，我们首先删除任何先前版本的`table` ❶。然后，我们提示用户输入`modulus`（一个整数）和`operation`（`+`
    或 `*`）。一旦得到这些信息，我们调用`Make index row`积木 ➋，如[图5-15](ch05.xhtml#ch5fig15)所示。
- en: '![Image](../images/pg114_Image_138.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg114_Image_138.jpg)'
- en: '*Figure 5-15: Building the index row of the operation table*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-15：构建操作表的索引行*'
- en: The `Make index row` block adds an index row at the top of the table containing
    labels for the columns, from 0 up to but not including the modulus, along with
    a `+` or `*` symbol to indicate whether it’s showing addition or multiplication.
    We build up the contents of the row as a string in the `row` variable, using a
    series of `join` blocks. We also add an extra row consisting of all dashes, to
    help set off the column index labels from the contents of the table itself.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Make index row`块在表格的顶部添加了一个索引行，包含列的标签，从0到不包括模数，同时附有一个`+`或`*`符号，表示是加法还是乘法。我们通过一系列`join`块将行内容构建为一个字符串，保存在`row`变量中。我们还添加了一行额外的破折号，以帮助区分列索引标签和表格本身的内容。'
- en: Most of the work in this block goes into making the table look pretty, with
    the columns evenly spaced regardless of whether they contain one-digit or two-digit
    numbers. To help, we use the custom `pad` block ❶ (defined in [Figure 5-16](ch05.xhtml#ch5fig16)),
    which puts either one or two spaces in front of a given string, depending on its
    length, to ensure that all the numbers in each column will be lined up nicely.
    If we know how many spaces we need to make the numbers line up, we can put them
    in directly, as we did in the index row ➋, but otherwise it’s better to let the
    program decide.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这块中的大部分工作都集中在使表格看起来整齐，无论列中包含的是一位数还是两位数，都能均匀地间隔。为了帮助排版，我们使用了自定义的`pad`块❶（在[图5-16](ch05.xhtml#ch5fig16)中定义），它根据字符串的长度在给定的字符串前添加一个或两个空格，确保每列中的所有数字能够整齐排列。如果我们知道需要多少空格来使数字对齐，可以直接将它们放进去，就像我们在索引行➋中做的那样；但如果不知道，最好让程序来决定。
- en: '**NOTE**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The two* set x *commands inside the* pad *block might look the same, but they’re
    actually different. The empty space in the first one, which executes when* x *has
    a length of 1, has two spaces in it, whereas the bottom one, which executes when*
    x *has a length of 2, has only one space.*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*这两个* set x *命令位于* pad *块中，看起来相同，但实际上是不同的。第一个命令执行时* x *的长度为1，其中有两个空格，而底部的命令执行时*
    x *的长度为2，其中只有一个空格。*'
- en: '![Image](../images/pg115_Image_139.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg115_Image_139.jpg)'
- en: '*Figure 5-16: Padding a string with one or two spaces*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-16：为字符串填充一个或两个空格*'
- en: Now that we have all these helper blocks, we can build the operation table,
    nicely formatted, with the main program code in [Figure 5-17](ch05.xhtml#ch5fig17).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有这些辅助块，我们可以构建一个格式良好的操作表，主程序代码在[图5-17](ch05.xhtml#ch5fig17)中。
- en: '![Image](../images/pg115_Image_140.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg115_Image_140.jpg)'
- en: '*Figure 5-17: Building the operation table, one row at a time*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-17：一次构建一行的操作表*'
- en: After calling our `setup` block, we use two nested loops to build the operation
    table row by row. The outer loop increments the variable `i`, representing the
    index number of the current row, while the inner loop increments the variable
    `j`, representing the column index number within the row. Each row begins with
    the row index number itself, followed by a colon ❶. This is necessary because
    Scratch indexes lists starting from 1, but for our purposes it’s more natural
    to number the rows and columns from 0.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`setup`块后，我们使用两个嵌套循环按行构建操作表。外循环递增变量`i`，表示当前行的索引号，而内循环递增变量`j`，表示行内列的索引号。每行以该行的索引号开始，后跟一个冒号
    ❶。这是必要的，因为Scratch中的列表索引从1开始，而为了我们的目的，从0开始编号行和列会更自然。
- en: The real work is done in the `if...else` block inside the inner loop ➋. There,
    depending on the desired operation, we calculate either `i + j` or `i * j` and
    take the `mod` of the result, giving us the current entry in the operation table.
    Once again, we use the `pad` block to add the appropriate number of spaces before
    joining the entry to the row being constructed. At the end of each cycle of the
    outer loop, we have a complete row, which we add to the `table` list.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的工作是在内循环的`if...else`块内完成的➋。根据所需的操作，我们计算`i + j`或`i * j`，并对结果取`mod`，从而得到操作表中的当前条目。再次使用`pad`块，在将条目加入正在构建的行之前，添加适当数量的空格。在外循环的每个周期结束时，我们将拥有一行完整的数据，并将其添加到`table`列表中。
- en: The Results
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: '[Figure 5-18](ch05.xhtml#ch5fig18) shows the resulting addition and multiplication
    tables for the small modulus *n* = 7.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-18](ch05.xhtml#ch5fig18)显示了小模数*n* = 7的加法和乘法表。'
- en: '![Image](../images/pg116_Image_141.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg116_Image_141.jpg)'
- en: '*Figure 5-18: Operation tables mod 7*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-18：模7的运算表*'
- en: Notice that each table starts with an index row showing the labels of the columns,
    from 0 to 6\. There’s also an index column along the left side of the table, showing
    the labels of the rows (again from 0 to 6).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个表格从一个索引行开始，显示列的标签，从0到6\. 表格左侧还有一个索引列，显示行的标签（同样是从0到6）。
- en: 'Using these tables, we can find the sum or product, mod 7, of any two integers.
    For example, say we want to find (152 + 263) mod 7\. First, we need to take mod
    7 of each input: 152 mod 7 is 5, and 263 mod 7 is 4\. Next, we look in the addition
    table for the intersection of column 5 and row 4\. The value there is 2, so that’s
    our answer. In this way, even though the tables have just seven rows and columns,
    they can give us the answer for any of the infinite number of positive integers.
    We just have to take mod 7 of the integers first.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些表格，我们可以找到任意两个整数的和或积，模7。例如，假设我们要计算(152 + 263) mod 7\. 首先，我们需要对每个输入数进行模7运算：152
    mod 7是5，263 mod 7是4\. 接下来，我们在加法表中查找列5与行4的交点。交点处的值是2，所以答案就是2。通过这种方式，尽管表格只有七行七列，但它们可以给出任何正整数的答案。我们只需先对整数进行模7运算。
- en: 'There are several patterns to observe in these mod 7 operation tables:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些模7运算表中，有几个模式可以观察到：
- en: '![Image](../images/common-1.jpg) For the addition table (on the left in [Figure
    5-18](ch05.xhtml#ch5fig18)), the values cycle row by row, shifting one column
    to the left from one row to the next. The value in the leftmost column of one
    row wraps back around, becoming the value in the rightmost column of the next
    row.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 对于加法表（见[图 5-18](ch05.xhtml#ch5fig18)左侧），值是逐行循环的，每行的值向左移动一列，从一行到下一行。每一行最左边一列的值会回绕，成为下一行最右边一列的值。'
- en: '![Image](../images/common-1.jpg) The values in row 0 of the addition table
    match the values in the table’s index row. This indicates that 0 is the *additive
    identity*: adding 0 to a number doesn’t change the number. As far as 0 is concerned,
    modular addition works just like ordinary addition.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 加法表中第0行的值与表格的索引行的值相匹配。这表明0是*加法单位元*：将0加到一个数上不会改变这个数。就0而言，模加法与普通加法完全相同。'
- en: '![Image](../images/common-1.jpg) The *additive inverse* of a number *n* is
    the number that needs to be added to *n* to get 0\. In ordinary addition, the
    additive inverse of a number is that number’s negation. For example, the additive
    inverse of 3 is –3\. We don’t need to use negative numbers to have additive inverses
    in modular arithmetic, however. Notice that there’s a 0 in every row of the addition
    table. This means there’s a positive number that we can add to get 0, no matter
    what we start with. That is, every number has an additive inverse for a given
    modulus. For instance, row 3 has a 0 in the column 4, so 3 + 4 = 0 mod 7.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 一个数*n*的*加法逆元*是需要加到*n*上得到0的数。在普通加法中，一个数的加法逆元是该数的相反数。例如，3的加法逆元是-3。
    然而，在模运算中，我们不需要使用负数来表示加法逆元。注意，在加法表的每一行都有一个0。这意味着无论从哪个数开始，我们都能找到一个正数加到它上面得到0。也就是说，每个数都有一个加法逆元，针对一个特定的模数。例如，第3行在第4列有一个0，所以3
    + 4 = 0 mod 7。'
- en: '![Image](../images/common-1.jpg) For the multiplication table (on the right
    in [Figure 5-18](ch05.xhtml#ch5fig18)), the values in row 1 match the values in
    the index row. That means 1 is the *multiplicative identity*: multiplying a number
    by 1 doesn’t change the number. In this sense, modular multiplication is just
    like regular multiplication.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 对于乘法表（见[图 5-18](ch05.xhtml#ch5fig18)右侧），第1行的值与索引行的值相匹配。这意味着1是*乘法单位元*：将一个数乘以1不会改变这个数。从这个意义上说，模乘法就像常规乘法一样。'
- en: '![Image](../images/common-1.jpg) There’s a 1 in every row and column of the
    multiplication table except for row and column 0\. That means every nonzero number
    can be multiplied by some other number, called the *multiplicative inverse*, to
    produce 1 mod 7.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-1.jpg) 在乘法表中，每一行和每一列都有一个1，除了第0行和第0列。也就是说，每个非零数都可以与另一个数相乘，这个数叫做*乘法逆元*，它的乘积是1
    mod 7。'
- en: These observations don’t just apply to a modulus of 7; they’re true of any modulus.
    Try running the program for some other moduli and you’ll see the same patterns.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些观察不仅仅适用于模7；它们对任何模数都适用。试着用其他模数运行程序，你会看到相同的模式。
- en: Hacking the Code
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: When you start making operation tables for larger moduli, you’ll find that the
    entire contents of each row will no longer fit on the Scratch stage. The complete
    table is still there behind the scenes, though. If you want to see the whole table
    at once, you can export the `table` list to a text file and open it in a text
    editor or other program, as discussed in [Chapter 2](ch02.xhtml#ch02). The table
    will look best if you view it using a *monospaced* font like Courier, where every
    character has the same width, so the columns all line up. For example, [Figure
    5-19](ch05.xhtml#ch5fig19) shows the exported table for multiplication mod 12.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始为更大的模数制作运算表时，你会发现每一行的内容将不再适合显示在Scratch舞台上。不过，完整的表格仍然存在于后台。如果你想一次性查看完整表格，你可以将`table`列表导出到文本文件中，并在文本编辑器或其他程序中打开，正如[第2章](ch02.xhtml#ch02)中讨论的那样。表格如果使用*等宽*字体（如Courier）查看会更清晰，其中每个字符的宽度相同，因此所有列都会对齐。例如，[图5-19](ch05.xhtml#ch5fig19)显示了模12下的乘法运算表的导出版本。
- en: '![Image](../images/pg117_Image_142.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg117_Image_142.jpg)'
- en: '*Figure 5-19: A multiplication table mod 12*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-19：模12的乘法表*'
- en: 'Notice that this table has multiple 0s in some rows and columns. The 0s in
    row 0 and column 0 are to be expected: multiplication by 0 always yields 0\. The
    other 0s are more interesting. They occur because 12 isn’t a prime number. Every
    factorization of 12 (in fact, every factorization of any multiple of 12) gives
    two numbers whose product is divisible by 12, and so whose product is 0 mod 12\.
    For instance, in row 4 we have a 0 in columns 0, 3, 6, and 9\. Indeed, 4 ⋅ 3,
    4 ⋅ 6, and 4 ⋅ 9 are all examples of two numbers that multiply to be 0 mod 12,
    even though neither number was 0 mod 12 to begin with. These values are known
    as *zero divisors*, and they don’t occur for arithmetic of real numbers. They
    exist only in modular arithmetic, and only if the modulus isn’t prime.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个表格在某些行和列中包含多个0。第0行和第0列中的0是可以预期的：乘以0总是得到0。其他的0则更有趣。它们的出现是因为12不是一个质数。12的每一种因式分解（事实上，任何12的倍数的因式分解）都会给出两个数，它们的乘积能被12整除，因此它们的乘积对12取模结果为0。例如，在第4行，我们在第0列、第3列、第6列和第9列都有0。实际上，4
    ⋅ 3、4 ⋅ 6和4 ⋅ 9都是两个数相乘得到0 mod 12的例子，尽管最初这两个数都不是0 mod 12。这些值被称为*零因子*，它们在实数的算术中并不存在。它们仅存在于模运算中，并且只有当模数不是质数时才会出现。
- en: If we cross out all the rows and columns that have extra 0s, as in [Figure 5-20](ch05.xhtml#ch5fig20),
    the values that aren’t crossed out form a smaller, reduced multiplication table.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们划掉所有有额外0的行和列，如[图5-20](ch05.xhtml#ch5fig20)所示，剩下的未被划掉的值就形成了一个更小、更简化的乘法表。
- en: '![Image](../images/pg118_Image_143.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg118_Image_143.jpg)'
- en: '*Figure 5-20: A reduced multiplication table mod 12*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-20：模12的简化乘法表*'
- en: We’re left with a 4×4 table of values, with row and column indices of 1, 5,
    7, and 11\. Every row and column in this smaller table has a 1 in it, meaning
    the remaining numbers all have a multiplicative inverse.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剩下一个4×4的值表，行和列的索引分别是1、5、7和11。这个较小的表格中每一行和每一列都有一个1，这意味着剩下的数都有乘法逆元。
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**5.4** If two numbers have no factors in common other than 1, they’re said
    to be *relatively prime*. For example, 6 and 35 are relatively prime, but 35 and
    49 are not (they’re both divisible by 7). Rewrite the code for the operation tables
    so that it will produce a reduced multiplication table for a given modulus *n*
    that includes only rows and columns for numbers that are relatively prime to *n*.
    For example, for multiplication mod 12, it should produce a table that includes
    only the four rows and columns that aren’t crossed out in [Figure 5-20](ch05.xhtml#ch5fig20).
    If the modulus that’s supplied is a prime number *p*, it should generate a (*p*
    – 1)*×*(*p* – 1) table, omitting row and column 0.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.4** 如果两个数除了1以外没有共同因子，则称它们为*互质*。例如，6和35是互质的，但35和49不是（它们都能被7整除）。请重写运算表的代码，使其能够为给定的模数*n*生成一个简化的乘法表，该表仅包括与*n*互质的数对应的行和列。例如，对于模12的乘法运算，它应生成一个只包括[图5-20](ch05.xhtml#ch5fig20)中未被划掉的四行四列的表格。如果给定的模数是一个质数*p*，它应生成一个(*p*
    – 1)*×*(*p* – 1)的表格，省略第0行和第0列。'
- en: '**5.5** The *primitive root* of a prime number *p* is a number whose powers
    mod *p* generate all the integers from 1 to *p* – 1\. For example, 2 is a primitive
    root of 11 because:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.5** 一个质数*p*的*原根*是一个数，它的各次幂对*p*取模时能够生成从1到*p* – 1的所有整数。例如，2是11的原根，因为：'
- en: '![Image](../images/common-2.jpg) 2^(10) = 1,024, and 1,024 mod 11 = 1'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-2.jpg) 2^(10) = 1,024，且 1,024 mod 11 = 1'
- en: '![Image](../images/common-2.jpg) 2¹ = 2'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-2.jpg) 2¹ = 2'
- en: '![Image](../images/common-2.jpg) 2⁸ = 256, and 256 mod 11 = 3'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-2.jpg) 2⁸ = 256，且 256 mod 11 = 3'
- en: '![Image](../images/common-2.jpg) 2² = 4'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-2.jpg) 2² = 4'
- en: '![Image](../images/common-2.jpg) 2⁴ = 16, and 16 mod 11 = 5'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-2.jpg) 2⁴ = 16，且 16 mod 11 = 5'
- en: '![Image](../images/common-2.jpg) 2⁹ = 512, and 512 mod 11 = 6'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-2.jpg) 2⁹ = 512，且 512 mod 11 = 6'
- en: '![Image](../images/common-2.jpg) 2⁷ = 128, and 128 mod 11 = 7'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-2.jpg) 2⁷ = 128，且 128 mod 11 = 7'
- en: '![Image](../images/common-2.jpg) 2³ = 8'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-2.jpg) 2³ = 8'
- en: '![Image](../images/common-2.jpg) 2⁶ = 64, and 64 mod 11 = 9'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-2.jpg) 2⁶ = 64，且 64 mod 11 = 9'
- en: '![Image](../images/common-2.jpg) 2⁵ = 32, and 32 mod 11 = 10'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/common-2.jpg) 2⁵ = 32，且 32 mod 11 = 10'
- en: On the other hand, 2 isn’t a primitive root of 7 because the only powers of
    2 mod 7 are 1, 2, and 4\. Write a program that asks for a prime number *p* and
    returns the first primitive root of *p* that it finds.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，2 不是 7 的原根，因为 2 的模 7 次幂只有 1、2 和 4。编写一个程序，要求输入一个素数 *p*，并返回找到的第一个原根。
- en: '**5.6** Spreadsheet programs such as Excel can import text files easily if
    the files are in CSV format. This format expects there to be a comma between each
    entry in each row of the input data. Modify the Scratch code for operation tables
    so that the exported files are formatted in this way.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.6** 电子表格程序如 Excel 可以轻松导入文本文件，只要文件是 CSV 格式。该格式要求每行输入数据中的每个条目之间用逗号分隔。修改 Scratch
    中运算表的代码，使导出的文件格式符合这种要求。'
- en: Conclusion
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: Arrays are two-dimensional tables of numbers, indexed by row and column. The
    position of an entry in the table provides two pieces of information—the row and
    column numbers—that you can sometimes use in a formula to determine the table
    entry. Scratch doesn’t have a built-in `array` type, but you can represent an
    array using a list, with each value containing all the array elements for a given
    row joined together, as we did in building operation tables. Another way to represent
    an array in Scratch is to build a list for each row of the array, as we did for
    Pascal’s triangle (a list of lists). The right way to represent an array depends
    on how you want to use it. Scratch is flexible enough to do whatever you want!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是二维的数字表格，通过行和列来索引。表格中一个条目的位置提供了两项信息——行号和列号——这些信息有时可以用来在公式中确定该表格条目的值。Scratch
    没有内置的 `array` 类型，但你可以使用列表来表示数组，每个值包含某一行的所有数组元素，正如我们在构建运算表时所做的那样。另一种表示数组的方法是为数组的每一行构建一个列表，就像我们为帕斯卡三角形所做的那样（一个列表的列表）。如何表示数组取决于你想如何使用它。Scratch
    非常灵活，能够满足你想做的任何操作！
