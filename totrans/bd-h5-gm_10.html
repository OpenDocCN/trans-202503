<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Next Steps in HTML5"><div class="titlepage"><div><div><h1 class="title"><a id="next_steps_in_html5"/>Chapter 8. Next Steps in HTML5</h1></div></div></div><p><a id="iddle2018" class="indexterm"/><a id="iddle2417" class="indexterm"/><a id="iddle2434" class="indexterm"/><a id="iddle2473" class="indexterm"/>In addition to graphical advances, HTML5 has a host of other features that make it a powerful game development environment. In this chapter, I’ll discuss a few of them so you’re aware of what features are available, and I’ll point you to some useful resources for further reading. Some of these features, such as WebGL, are subjects worthy of their own books, whereas others will be useful only for certain types of games. For these reasons, I’ll only introduce the concepts here and leave more thorough exploration up to you.</p><div class="sect1" title="Saving and Retrieving Data"><div class="titlepage"><div><div><h1 class="title"><a id="saving_and_retrieving_data"/>Saving and Retrieving Data</h1></div></div></div><p>People play games like <span class="emphasis"><em>Bubble Shooter</em></span> in short sessions with little or no persistent data; in fact, our game saves only the high score from one session to the next. At present, the high score is stored in Web Storage, so it’s unique <a id="iddle1003" class="indexterm"/><a id="iddle1022" class="indexterm"/><a id="iddle1023" class="indexterm"/><a id="iddle1024" class="indexterm"/><a id="iddle1202" class="indexterm"/><a id="iddle1437" class="indexterm"/><a id="iddle1597" class="indexterm"/><a id="iddle1599" class="indexterm"/><a id="iddle2068" class="indexterm"/><a id="iddle2077" class="indexterm"/><a id="iddle2099" class="indexterm"/><a id="iddle2140" class="indexterm"/><a id="iddle2363" class="indexterm"/><a id="iddle2477" class="indexterm"/><a id="iddle2480" class="indexterm"/><a id="iddle2481" class="indexterm"/><a id="iddle2610" class="indexterm"/><a id="iddle2648" class="indexterm"/><a id="iddle2709" class="indexterm"/>to the browser the game is played on. To save a global high score and display a high score table, we’d need to write a server-side component that sends the score to a server and retrieves a list of high scores.</p><p>Games with more complex states should have server-side access, too. When you store state on the server, players can return to the same game from multiple devices. For our purposes, we’ll use two main ways to save and retrieve data on a server: AJAX and WebSockets.</p><div class="sect2" title="AJAX"><div class="titlepage"><div><div><h2 class="title"><a id="ajax"/>AJAX</h2></div></div></div><p><span class="emphasis"><em>AJAX (Asynchronous JavaScript and XML)</em></span> provides a technique for sending a request to a server and receiving a response. AJAX is not a single technology but rather a method by which a number of tried-and-tested browser features are combined to make server-side calls and manage the responses. All of the major browsers have supported AJAX for a number of years.</p><p>Although the <span class="emphasis"><em>X</em></span> stands for XML, you can use AJAX to retrieve HTML data, string data, and JSON strings that can be parsed and interpreted. The code for making AJAX calls is well documented, and multiple libraries are available so you don’t have to handcraft the calls. For example, here’s how you’d send an AJAX request to a server with the <code class="literal">$.ajax</code> call in jQuery:</p><a id="pro_id00178"/><pre class="programlisting">    $.ajax({
➊    url : "save_data.php",
➋    data : "high_score =" + highScore,
➌    type : "POST",
➍    complete : function(data){
        console.log(data);
    }
  });</pre><p>This <code class="literal">$.ajax</code> call makes a <code class="literal">POST</code> request to the relative URL <span class="emphasis"><em>save_data.php</em></span>, sends the value contained in <code class="literal">highScore</code> to the server under the name <code class="literal">high_score</code>, and logs the server’s response to the console. I set the URL target for the request ➊, the data to send ➋, the type of request ➌, and a function to run after the request completes ➍, but you can set many other properties, including functions to run in case of an error, timeout settings, and so on. These are listed in the jQuery documentation at <span class="emphasis"><em><a class="ulink" href="http://api.jquery.com/">http://api.jquery.com/</a></em></span>.</p><div class="note" title="Note"><h3 class="title"><a id="ch08note01"/>Note</h3><p><span class="emphasis"><em>The</em></span> A <span class="emphasis"><em>in AJAX stands for</em></span> asynchronous<span class="emphasis"><em>, because other JavaScript operations will continue while the server deals with the data and sends the response. That means you can’t be sure when the <code class="literal">complete</code> function will run: it’ll happen whenever the response comes back, but the user interface will remain responsive while it happens. It’s possible to make synchronous calls, but because this effectively freezes the entire page until the request is complete, the user experience is generally so poor that doing so is considered bad practice.</em></span></p></div></div><div class="sect2" title="WebSockets"><div class="titlepage"><div><div><h2 class="title"><a id="websockets"/>WebSockets</h2></div></div></div><p><a id="iddle1230" class="indexterm"/><a id="iddle1718" class="indexterm"/><a id="iddle1976" class="indexterm"/><a id="iddle2185" class="indexterm"/><a id="iddle2254" class="indexterm"/><a id="iddle2310" class="indexterm"/><a id="iddle2476" class="indexterm"/><a id="iddle2498" class="indexterm"/><a id="iddle2688" class="indexterm"/><a id="iddle2690" class="indexterm"/>Most modern browsers also have WebSockets available to make client to server calls. WebSockets are a relatively new technology incorporated into the HTML5 specification. If you want to learn how they work at a lower level than I describe here, a good place to start is with the Mozilla Developer Network documentation at <span class="emphasis"><em><a class="ulink" href="https://developer.mozilla.org/en/docs/WebSockets/">https://developer.mozilla.org/en/docs/WebSockets/</a></em></span>.</p><p>WebSockets are similar to AJAX, but whereas AJAX sets up a call-and-response relationship between the client and server, a WebSocket maintains a persistent connection between them. The client deals with responses as they come in, and the JavaScript code can listen continuously for further responses. The server also constantly listens while the socket is open; therefore, WebSockets are much better than AJAX when conversations between the client and server involve lots of small data transactions.</p><p>A persistent connection is especially useful in multiplayer gaming environments. Before WebSockets, the main way to update game state elements shared by multiple clients, such as player avatars within an environment, was to continuously poll the server with AJAX and check for updates. This would be coded to happen every few seconds, which obviously isn’t sufficient for a real-time game. People tried various hacks—such as a technique called <span class="emphasis"><em>long-polling</em></span>, which effectively tricks the client into maintaining a connection to the server—to improve the process, but these were often inefficient in terms of server resources. Now, you can just leave a WebSocket open, and whenever one client updates the game state, the server can immediately update all of the other clients’ information without waiting for the next update cycle.</p><p>Mainstream browsers have ever-improving support for WebSockets, and as with AJAX, I recommend using a library to eliminate some of the nitty-gritty of opening connections, sending and listening for data, and handling errors. Libraries will also often have a fallback to AJAX or other server communication methods for cases in which WebSockets aren’t supported; however, the fallbacks may not replicate the performance features that you’re using WebSockets for in the first place, so be aware that they’re not a magic solution.</p><p>Socket.IO (<span class="emphasis"><em><a class="ulink" href="http://socket.io/">http://socket.io/</a></em></span>) is one of the most popular WebSocket libraries. Here’s how you can use it to make a call:</p><a id="pro_id00179"/><pre class="programlisting">var socket = io.connect("http://localhost");
  socket.emit("new_high_score", {
    high_score : highScore
  });
});</pre><p>This code uses a call to the library with <code class="literal">io.connect</code> to open a new WebSocket and then <code class="literal">socket.emit</code> sends the <code class="literal">highScore</code> value as an event named <code class="literal">new_high_score</code>.</p><p><a id="iddle1089" class="indexterm"/><a id="iddle1231" class="indexterm"/><a id="iddle1723" class="indexterm"/><a id="iddle1783" class="indexterm"/><a id="iddle2065" class="indexterm"/><a id="iddle2095" class="indexterm"/><a id="iddle2098" class="indexterm"/><a id="iddle2267" class="indexterm"/><a id="iddle2274" class="indexterm"/><a id="iddle2308" class="indexterm"/><a id="iddle2376" class="indexterm"/><a id="iddle2440" class="indexterm"/><a id="iddle2461" class="indexterm"/><a id="iddle2495" class="indexterm"/><a id="iddle2496" class="indexterm"/><a id="iddle2583" class="indexterm"/><a id="iddle2654" class="indexterm"/><a id="iddle2692" class="indexterm"/><a id="iddle2706" class="indexterm"/>WebSockets and libraries such as Socket.IO have much greater capabilities than AJAX, but the libraries that make them easy to use often assume a specific server-side environment. If you plan to use WebSockets, check that the library you plan to use has a backend component that matches your server environment. Libraries for most platforms are readily available, whether you’re using Node.js, .NET, or Java.</p><p>Along with sending and receiving data to and from the server, you might also want to process certain data outside your main game program. That’s where Web Workers will come in handy.</p></div><div class="sect2" title="Web Workers"><div class="titlepage"><div><div><h2 class="title"><a id="web_workers"/>Web Workers</h2></div></div></div><p>JavaScript in a browser is generally considered a <span class="emphasis"><em>single-threaded</em></span> environment, meaning that only one script can run at a time. This won’t cause problems most of the time but can be an issue if a particularly large computational process blocks the processor from animating, responding to user input, and performing other important tasks.</p><p>For example, let’s say processing game-level data takes the browser 1 or 2 seconds, and this happens every 30 seconds or so. The overall load may not be high, but you can’t pause the game every 30 seconds! In this situation, consider using a Web Worker.</p><p>Web Workers (<span class="emphasis"><em><a class="ulink" href="https://developer.mozilla.org/en/docs/Web/API/Worker/">https://developer.mozilla.org/en/docs/Web/API/Worker/</a></em></span>) allow you to run code in a separate thread without blocking your main JavaScript operations. They’re called “workers” because you can essentially hand them a task and tell them to report back when they’re finished. The browser will determine how much CPU time to give them so as not to interfere unduly with other processes. Workers can be dedicated or shared, but you’ll generally find dedicated workers most useful, especially while support for Web Workers is being developed across browsers.</p><p>Web Workers follow a couple of rules that differentiate them from regular JavaScript. Most important, they have no access to the DOM, the browser document, or the browser window. Workers also operate within their own scope, so you’ll need to pass data explicitly and then retrieve the result when complete. I’ll illustrate how they work with the following example.</p><p>Workers are initialized by passing the name of a script to load to the <code class="literal">new Worker</code> command:</p><a id="pro_id00180"/><pre class="programlisting">var worker = new Worker("work.js");</pre><p>This will start a new worker, and that worker will run the script inside <span class="emphasis"><em>work.js</em></span>.</p><p>A worker runs when you send it a message via <code class="literal">postMessage</code>:</p><a id="pro_id00181"/><pre class="programlisting">worker.postMessage();</pre><p>The <code class="literal">postMessage</code> command can contain a JavaScript object or be empty.</p><p><a id="iddle1008" class="indexterm"/><a id="iddle1010" class="indexterm"/><a id="iddle1225" class="indexterm"/><a id="iddle1228" class="indexterm"/><a id="iddle1460" class="indexterm"/><a id="iddle1494" class="indexterm"/><a id="iddle1600" class="indexterm"/><a id="iddle1605" class="indexterm"/><a id="iddle1615" class="indexterm"/><a id="iddle1820" class="indexterm"/><a id="iddle1822" class="indexterm"/><a id="iddle1983" class="indexterm"/><a id="iddle2167" class="indexterm"/><a id="iddle2329" class="indexterm"/><a id="iddle2437" class="indexterm"/><a id="iddle2581" class="indexterm"/><a id="iddle2677" class="indexterm"/>You can handle responses—values a worker returns when it completes a task—by adding event listeners to the worker within the calling script:</p><a id="pro_id00182"/><pre class="programlisting">worker.addEventListener("message", function(e) {
  console.log(e.data);
}, false);</pre><p>Here, <code class="literal">e</code> contains the data that <code class="literal">worker</code> sent back. The event to listen to, labeled <code class="literal">"message"</code>, is any valid string. Therefore, a <code class="literal">worker</code> could send back different responses in different circumstances, or it could just keep working and sending messages.</p><p>Inside the worker, the model of event listeners is similar, with the <code class="literal">worker</code> referring to itself as <code class="literal">this</code> or <code class="literal">self</code>. As an example, <span class="emphasis"><em>work.js</em></span> could contain the following to return the message:</p><a id="pro_id00183"/><pre class="programlisting">self.addEventListener("message", function(e) {
  self.postMessage({
    message : "I'm done now"
  });
}, false);</pre><p>This code listens for an event marked <code class="literal">"message"</code>, and on receipt, it immediately posts a response in the form of an object.</p><p>At present, not all the major browsers support Web Workers well enough to make it reliable. Polyfills do exist for Web Workers, but these will often negatively affect your user’s experience if a long-running process that you assumed would be nonblocking suddenly freezes the game for a few seconds. However, the situation is constantly improving, and hopefully, Web Workers will soon be considered a core part of the HTML5 game developer’s arsenal.</p><p>But managing your data more effectively is just a start to making your game more fun. Appearance matters, too, and for a graphics upgrade, you can go 3D with WebGL or even use it to beef up your rendering power for 2D games.</p></div></div><div class="sect1" title="WebGL"><div class="titlepage"><div><div><h1 class="title"><a id="webgl"/>WebGL</h1></div></div></div><p>For the canvas version of <span class="emphasis"><em>Bubble Shooter</em></span>, we used the 2D rendering context, accessed with calls along the lines of</p><a id="pro_id00184"/><pre class="programlisting">var context = canvas.getContext("2d");</pre><p>As I touched upon in <a class="xref" href="ch06.html" title="Chapter 6. Rendering Canvas Sprites">Chapter 6</a>, the specification of <code class="literal">"2d"</code> implies that other options are available, and sometimes, depending on browser support, that’s true. The third dimension is accessed through WebGL, an API that provides a set of 3D manipulation functions for creating scenes, adding lighting and textures, positioning cameras, and so on, taking advantage of the <a id="iddle1011" class="indexterm"/><a id="iddle1012" class="indexterm"/><a id="iddle1017" class="indexterm"/><a id="iddle1115" class="indexterm"/><a id="iddle1116" class="indexterm"/><a id="iddle1458" class="indexterm"/><a id="iddle1505" class="indexterm"/><a id="iddle1835" class="indexterm"/><a id="iddle1995" class="indexterm"/><a id="iddle2100" class="indexterm"/><a id="iddle2141" class="indexterm"/><a id="iddle2213" class="indexterm"/><a id="iddle2264" class="indexterm"/><a id="iddle2302" class="indexterm"/><a id="iddle2318" class="indexterm"/><a id="iddle2320" class="indexterm"/><a id="iddle2494" class="indexterm"/><a id="iddle2575" class="indexterm"/><a id="iddle2679" class="indexterm"/>acceleration that modern graphics cards provide. (Visit <span class="emphasis"><em><a class="ulink" href="https://www.khronos.org/registry/webgl/specs/1.0/">https://www.khronos.org/registry/webgl/specs/1.0/</a></em></span> to learn about WebGL in more detail.) To start using WebGL, we first instantiate a 3D context with the following:</p><a id="pro_id00185"/><pre class="programlisting">var context = canvas.getContext("webgl");</pre><p>This is sometimes retrieved as <code class="literal">"experimental-webgl"</code>, so the most compatible call is this:</p><a id="pro_id00186"/><pre class="programlisting">var context = canvas.getContext("webgl")
  || canvas.getContext("experimental-webgl");</pre><p>Accelerated WebGL is powerful enough to display fully rendered 3D scenes rivaling those of native games. The downside is that working in three dimensions and manipulating and creating scenes requires a lot of math and a lot of low-level code that involves writing programs directly to the graphics processor. The concepts are the same as when creating 3D games in native code, such as C++, and require low-level knowledge of 3D modeling to describe the shape of an object; textures to define surface patterns; and shaders, which describe how to render a surface when light hits it. As such, I highly recommend working with existing libraries to handle model rendering, any physics requirements, and basically any features you can get off the shelf. Babylon.js (<span class="emphasis"><em><a class="ulink" href="http://www.babylonjs.com/">http://www.babylonjs.com/</a></em></span>) and PlayCanvas (<span class="emphasis"><em><a class="ulink" href="https://playcanvas.com/">https://playcanvas.com/</a></em></span>) are two libraries that make working with WebGL in the browser much simpler.</p><p>Using WebGL also brings up the question of how to import objects and textures into 3D scenes. Typically, you create models in modeling software, such as 3D Studio or Maya, and then export to a commonly supported format. WebGL libraries generally won’t work with those formats, so you’ll usually need to convert from the original 3D modeling file format to JSON using another set of tools, such as the 3DS Max-to-Babylon.js exporter (<span class="emphasis"><em><a class="ulink" href="https://github.com/BabylonJS/Babylon.js/tree/master/Exporters/3ds%20Max">https://github.com/BabylonJS/Babylon.js/tree/master/Exporters/3ds%20Max</a></em></span>), which exports from Autodesk’s 3D Studio product into Babylon.js.</p><p>Creating and converting 3D models is a large enough task that WebGL game development quickly becomes a project for teams of developers and designers rather than for a sole developer; however, many very impressive demos have been made entirely solo, and the Babylon.js website has a great set of showcases.</p><p>A secondary advantage of the WebGL context is that you can use it to render 2D scenes, which can then take advantage of the huge speed available through GPU acceleration. Particle effects and rendering large numbers of onscreen elements in accelerated WebGL far outperform the same tasks in the canvas.</p><p>I recommend that you look for off-the-shelf libraries that enable 2D rendering in WebGL. One such library is Pixi.js (<span class="emphasis"><em><a class="ulink" href="http://www.pixijs.com/">http://www.pixijs.com/</a></em></span>), which also provides a fallback to the canvas.</p><p><a id="iddle1222" class="indexterm"/><a id="iddle1229" class="indexterm"/><a id="iddle1540" class="indexterm"/><a id="iddle1746" class="indexterm"/><a id="iddle1819" class="indexterm"/><a id="iddle1865" class="indexterm"/><a id="iddle1890" class="indexterm"/><a id="iddle2035" class="indexterm"/><a id="iddle2060" class="indexterm"/><a id="iddle2256" class="indexterm"/><a id="iddle2259" class="indexterm"/><a id="iddle2413" class="indexterm"/><a id="iddle2683" class="indexterm"/>Browser support for WebGL is growing and includes the latest versions of Chrome, Firefox, and Internet Explorer, although older versions of Internet Explorer are incompatible at the time of this writing. For this reason, WebGL isn’t considered ready for mass-market development, but this situation continues to improve.</p><p>Building a slick game is all well and good, but a game is nothing without players. To reach players, you need to deploy your game somewhere publicly accessible. Depending on where you deploy, you should consider some changes to improve the player’s experience.</p></div><div class="sect1" title="Deploying HTML5 Games"><div class="titlepage"><div><div><h1 class="title"><a id="deploying_html5_games"/>Deploying HTML5 Games</h1></div></div></div><p>In this section, I’ll give a brief overview of the process behind deploying a game running inside desktop and mobile browsers, and I’ll explain how you’d wrap up an HTML5 application as a native mobile application.</p><div class="sect2" title="Running Fullscreen in a Desktop Browser"><div class="titlepage"><div><div><h2 class="title"><a id="running_fullscreen_in_a_desktop_browser"/>Running Fullscreen in a Desktop Browser</h2></div></div></div><p>One way to deploy an HTML5 game is to just create a website and upload it. In fact, just upload <span class="emphasis"><em>Bubble Shooter</em></span> to the Web to make it accessible to anyone who accesses the <span class="emphasis"><em>index.html</em></span> file. Deploying an HTML5 game to the Web is no different from deploying any other website; however, players often complain about a lack of immersion when they are running games in a browser, because it’s easy to become distracted by tabs showing notifications from Facebook, email, instant messages, and so on. The HTML5 arsenal has a trick to fix these interruptions: the Fullscreen API.</p><p>Where supported, the Fullscreen API lets a web page fill the entire width and height of the screen, removing the address bar and other browser frame elements. You can implement fullscreen capabilities by running the following JavaScript code. For security reasons, you need to run this code inside a user-generated event handler; that is, you will usually make a button for the player to click or specify a key for them to press to activate fullscreen mode.</p><a id="pro_id00187"/><pre class="programlisting">if(document.body.requestFullScreen) {
  document.body.requestFullScreen();
} else if(document.body.mozRequestFullScreen) {
  document.body.mozRequestFullScreen();
} else if(document.body.webkitRequestFullScreen) {
  document.body.webkitRequestFullScreen();
} else if(document.body.msRequestFullScreen){
  document.body.msRequestFullScreen();
}</pre><p>Note the use of vendor prefixes while the <code class="literal">requestFullScreen</code> API is being implemented (<code class="literal">mozRequestFullScreen</code> for Firefox, <code class="literal">webkitRequestFullScreen</code> for Chrome, and so on). When you call <code class="literal">requestFullScreen</code>, the user should see a <a id="iddle1657" class="indexterm"/><a id="iddle1837" class="indexterm"/><a id="iddle2145" class="indexterm"/><a id="iddle2209" class="indexterm"/>dialog from the browser asking whether to allow or deny your game’s request to go fullscreen. If the player allows fullscreen, pressing the <span class="smaller">ESC</span> key should return them to the regular view.</p><p>You can also apply fullscreen mode to a single element inside the DOM. You might want to do this if you have a game running within a website with navigation to other pages, for example. Then, players can go into fullscreen mode to remove the distractions of navigation bars and other page clutter. You could even apply fullscreen mode to <span class="emphasis"><em>Bubble Shooter</em></span>. Just add a new toolbar button that runs the following code when a player clicks the button:</p><a id="pro_id00188"/><pre class="programlisting">if(document.body.requestFullScreen) {
  $("#page").get(0).requestFullScreen();
}else if(document.body.mozRequestFullScreen) {
  $("#page").get(0).mozRequestFullScreen();
}else if(document.body.webkitRequestFullScreen) {
  $("#page").get(0).webkitRequestFullScreen();
}else if(document.body.msRequestFullScreen){
  $("#page").get(0).msRequestFullScreen();
}</pre><p>I’ll leave this as an exercise for you to implement, and I suggest you add it to <span class="emphasis"><em>ui.js</em></span> to keep it with the other user interface code. But if you’d rather not deploy to your own website, try a hosting service. You could set up an application on Facebook or upload a game to a dedicated game website, such as Kongregate.</p><p>Of course, the promise of cross-platform development and deployment is one of the biggest attractions of HTML5, and because most desktop browser features have been ported to mobile browsers, <span class="emphasis"><em>Bubble Shooter</em></span> should work just as well on both. However, the behaviors aren’t quite identical between platforms, and I’ll discuss those differences next.</p></div><div class="sect2" title="Running in a Mobile Browser"><div class="titlepage"><div><div><h2 class="title"><a id="running_in_a_mobile_browser"/>Running in a Mobile Browser</h2></div></div></div><p>Even if you’re still running <span class="emphasis"><em>Bubble Shooter</em></span> on a local or development web server, you should be able to load the game in a mobile browser and play it. It should function just as well as it does on a desktop browser. Congratulations, you’ve just made your first mobile game!</p><div class="note" title="Note"><h3 class="title"><a id="ch08note02"/>Note</h3><p><span class="emphasis"><em>In case you haven’t deployed the game yet, you can also play it at</em></span> <a class="ulink" href="http://buildanhtml5game.com/bubbleshooter/">http://buildanhtml5game.com/bubbleshooter/</a><span class="emphasis"><em>.</em></span></p></div><p>When developing games for mobile devices, it’s more likely you’ll need to make usability and interface changes than technical ones, but that’s not to say you can ignore implementation changes completely. You’ll benefit from knowing the subtle differences in behavior and how to optimize the experience for mobile users, so let’s get started.</p><div class="sect3" title="Touch Events"><div class="titlepage"><div><div><h3 class="title"><a id="touch_events"/>Touch Events</h3></div></div></div><p><a id="iddle1020" class="indexterm"/><a id="iddle1136" class="indexterm"/><a id="iddle1553" class="indexterm"/><a id="iddle1561" class="indexterm"/><a id="iddle1785" class="indexterm"/><a id="iddle1830" class="indexterm"/><a id="iddle1831" class="indexterm"/><a id="iddle1832" class="indexterm"/><a id="iddle1833" class="indexterm"/><a id="iddle1834" class="indexterm"/><a id="iddle1926" class="indexterm"/><a id="iddle2144" class="indexterm"/><a id="iddle2250" class="indexterm"/><a id="iddle2251" class="indexterm"/><a id="iddle2597" class="indexterm"/><a id="iddle2598" class="indexterm"/><a id="iddle2599" class="indexterm"/><a id="iddle2600" class="indexterm"/>First, touchscreen-specific events are implemented by browsers on touchscreen devices. Two of those events are <code class="literal">touchstart</code> and <code class="literal">touchend</code>, which are roughly equivalent to <code class="literal">mousedown</code> and <code class="literal">mouseup</code>, respectively. However, the <code class="literal">click</code> event differs slightly in a touchscreen environment. Mobile browsers wait a few hundred milliseconds to determine whether the user double-taps, which is a zoom operation, to make absolutely sure that the user intends a single <code class="literal">click</code>. This won’t make much difference in <span class="emphasis"><em>Bubble Shooter</em></span>, but for rapid-reaction games, those few hundred milliseconds will be noticeable to the player.</p><p>You can use mobile-specific events, and they’ll be ignored on desktop devices without a touchscreen, although for the most part, using <code class="literal">mousedown</code> will have the same effect as <code class="literal">touchstart</code> and <code class="literal">mouseup</code> will be equivalent to <code class="literal">touchend</code>. For example, in <span class="emphasis"><em>Bubble Shooter</em></span>, we could use <code class="literal">mousedown</code> instead of <code class="literal">click</code> to detect when the player wants to fire a bubble, which would turn this line from <span class="emphasis"><em>game.js</em></span>:</p><a id="pro_id00189"/><pre class="programlisting">$("#game").bind("click",clickGameScreen);</pre><p>into this line of code instead:</p><a id="pro_id00190"/><pre class="programlisting">$("#game").bind("mousedown",clickGameScreen);</pre><p>The only effect would be that the bubble will fire when the user clicks the mouse button down or touches the screen rather than waiting for the mouse button to be released or the finger removed from the screen.</p><div class="note" title="Note"><h3 class="title"><a id="ch08note03"/>Note</h3><p><span class="emphasis"><em>Using only the mouse and touch events will remove keyboard accessibility if you have a game that could conceivably be controlled by the keyboard. In some games, you might want to continue using the click event so a player could still, for example, navigate a menu system using the keyboard or other input device.</em></span></p></div><p>If you know that your game will be played only on a mobile device, you could also use <code class="literal">touchstart</code>:</p><a id="pro_id00191"/><pre class="programlisting">$("#game").bind("touchstart",clickGameScreen);</pre><p>This should work the same way as <code class="literal">mousedown</code>.</p><p>You may be wondering, then, why <code class="literal">touchstart</code> and <code class="literal">touchend</code> exist at all if they’re virtually equivalent to <code class="literal">mousedown</code> and <code class="literal">mouseup</code>. The answer is that in most cases you can treat them as conceptually equivalent, but touch events can be useful if you want to detect more than one touch point simultaneously. The user will (usually) have only one mouse pointer, but it’s possible to make contact with a touchscreen in multiple places. If you’re building a game that requires this kind of input, touch events are the ones to use, and you’ll have to find a way to make them work in a mouse environment.</p></div><div class="sect3" title="Scaling"><div class="titlepage"><div><div><h3 class="title"><a id="scaling"/>Scaling</h3></div></div></div><p><a id="iddle1027" class="indexterm"/><a id="iddle1030" class="indexterm"/><a id="iddle1105" class="indexterm"/><a id="iddle1107" class="indexterm"/><a id="iddle1109" class="indexterm"/><a id="iddle1195" class="indexterm"/><a id="iddle1216" class="indexterm"/><a id="iddle1227" class="indexterm"/><a id="iddle1729" class="indexterm"/><a id="iddle1739" class="indexterm"/><a id="iddle1740" class="indexterm"/><a id="iddle2053" class="indexterm"/><a id="iddle2064" class="indexterm"/><a id="iddle2193" class="indexterm"/><a id="iddle2201" class="indexterm"/><a id="iddle2203" class="indexterm"/><a id="iddle2206" class="indexterm"/><a id="iddle2436" class="indexterm"/><a id="iddle2650" class="indexterm"/><a id="iddle2670" class="indexterm"/><a id="iddle2702" class="indexterm"/><a id="iddle2711" class="indexterm"/>Another interaction difference comes into play with zooming. You probably don’t want players zooming into the game area at all, whether they double-tap or not. Fortunately, you can restrict this by adding <code class="literal">&lt;meta&gt;</code> tags to the HTML head:</p><a id="pro_id00192"/><pre class="programlisting">&lt;meta name="viewport" content="user-scalable=no, initial-scale=1,
maximum-scale=1, minimum-scale=1, width=device-width, height=device-height" /&gt;</pre><p>This example tells the browser to render the page at a scale of 1:1 and set the viewport width to the default for the device. The content of the <code class="literal">&lt;meta&gt;</code> tag specifies the size of the display and restricts (or allows) zooming. Apple originally introduced this <code class="literal">&lt;meta&gt;</code> tag, and other browsers use it as a basis for their own behavior. Hence, Apple’s own documentation (<span class="emphasis"><em><a class="ulink" href="https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html">https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html</a></em></span>) is the best place to look for a description of the various options. However, using this tag is very much a case of looking up what’s expected to happen in any particular mobile browser and then testing it to see how it works in practice. Work is underway to standardize viewport sizing using CSS (<span class="emphasis"><em><a class="ulink" href="http://www.w3.org/TR/css-device-adapt/">http://www.w3.org/TR/css-device-adapt/</a></em></span>), although it has minimal browser support at present.</p><p>The most common option you’ll use in the <code class="literal">&lt;meta&gt;</code> tag is <code class="literal">user-scalable=no</code>, which simply prevents the user from zooming. But changing the other values in the <code class="literal">&lt;meta&gt;</code> tag can greatly affect how the browser displays your game, too. The settings in the <code class="literal">&lt;meta&gt;</code> tag are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="user-scalable"><span class="title"><strong><span class="strong"><strong><code class="literal">user-scalable</code></strong></span></strong></span>. Can be yes or no. Allows or disables zooming.</p></li><li class="listitem"><p title="initial-scale"><span class="title"><strong><span class="strong"><strong><code class="literal">initial-scale</code></strong></span></strong></span>. A decimal number specifying the zoom factor at which to draw the viewport.</p></li><li class="listitem"><p title="maximum-scale"><span class="title"><strong><span class="strong"><strong><code class="literal">maximum-scale</code></strong></span></strong></span>. A decimal representing the maximum zoomable scale to allow the user to zoom to.</p></li><li class="listitem"><p title="minimum-scale"><span class="title"><strong><span class="strong"><strong><code class="literal">minimum-scale</code></strong></span></strong></span>. A decimal representing the minimum zoomable scale to allow the user to zoom to.</p></li><li class="listitem"><p title="width"><span class="title"><strong><span class="strong"><strong><code class="literal">width</code></strong></span></strong></span>. Specify this in pixels, or use <code class="literal">device-width</code>.</p></li><li class="listitem"><p title="height"><span class="title"><strong><span class="strong"><strong><code class="literal">height</code></strong></span></strong></span>. Specify this in pixels, or use <code class="literal">device-height</code>.</p></li></ul></div><p>If the game is designed with a width of, say, 760 pixels, you could set <code class="literal">width</code> to 760, and the browser would keep the page at that width and eliminate any extra pixels of spacing on either side. Unfortunately, by scaling the viewport, you’ll almost certainly have to solve problems with image scaling and aspect ratio; trying to draw 760 pixels on a screen that’s made up of 1024 pixels means some aliasing will need to occur.</p><p>Aspect ratios also vary much more between mobile devices than desktop screens. For example, the iPad 1 and 2 have a resolution of 1024×768, the iPad 3 is 2048×1536, the iPhone 6 is 750×1334, the iPhone 6 Plus is 1080×1920, and there are almost as many Android resolutions as there are devices. Unfortunately, no simple solution exists. Be sure to test continually <a id="iddle1018" class="indexterm"/><a id="iddle1019" class="indexterm"/><a id="iddle1127" class="indexterm"/><a id="iddle1590" class="indexterm"/><a id="iddle1675" class="indexterm"/><a id="iddle1717" class="indexterm"/><a id="iddle2006" class="indexterm"/><a id="iddle2034" class="indexterm"/><a id="iddle2052" class="indexterm"/><a id="iddle2056" class="indexterm"/><a id="iddle2066" class="indexterm"/><a id="iddle2211" class="indexterm"/><a id="iddle2260" class="indexterm"/><a id="iddle2265" class="indexterm"/><a id="iddle2278" class="indexterm"/><a id="iddle2322" class="indexterm"/><a id="iddle2380" class="indexterm"/><a id="iddle2470" class="indexterm"/><a id="iddle2562" class="indexterm"/><a id="iddle2707" class="indexterm"/>on a wide range of devices, and experiment with a combination of <code class="literal">&lt;meta&gt;</code> properties and CSS layouts to ensure your game looks good on a variety of screen sizes and aspect ratios.</p><p>Of course, even after you solve the aspect ratio problem, if users are still playing your game through a mobile browser, they may not be able to play while offline. To really get an HTML5 game onto the device, you need to wrap up the code in a native package. When your game is a native application, the user should be able to play it whether online or offline, unless your game requires an Internet connection anyway. Let’s look at using a wrapper service next.</p></div></div><div class="sect2" title="Deploying as a Native Application"><div class="titlepage"><div><div><h2 class="title"><a id="deploying_as_a_native_application"/>Deploying as a Native Application</h2></div></div></div><p>You have two main ways to deploy your HTML5 game as a native web application. You can write a wrapper using Objective-C, Java, or whichever language the target platform requires, or you can use an existing wrapper service. Unless you’re very proficient with native mobile coding, I highly recommend that you look at a wrapper service.</p><p>Wrapper services, such as PhoneGap/Cordova (<span class="emphasis"><em><a class="ulink" href="http://cordova.apache.org/">http://cordova.apache.org/</a></em></span>) and Ludei (<span class="emphasis"><em><a class="ulink" href="https://www.ludei.com/">https://www.ludei.com/</a></em></span>), give you less control, but they often provide access to native features, such as accelerometers and in-app purchases. Sometimes they even offer accelerated graphics capabilities and bespoke APIs. They require less time and effort, too, making them an excellent way to build test deployments so you can quickly see your game running on a device. I’d advise using a service unless you have a very good reason not to.</p><p>Using a third-party wrapper often involves uploading your HTML5 code through an online service and downloading a compiled version for each device. These services effectively do the same work as custom wrappers, but they’ve been optimized over iterations, usually for multiple platforms. They also continue to add support for newer handsets and operating systems, which is very time consuming to keep on top of yourself. In addition, a community is usually writing plug-ins to provide extra functionality, such as offering in-app purchases or accessing the device’s camera.</p><p>Just remember that no matter how you decide to wrap your HTML5 application, the files will all be running in a local environment; that is, your game won’t need to download assets over the Web or from a server. As a result, your game will be playable even when no web connection is available. If you’re developing a multiplayer game, it will need an Internet connection to be active, but even then your game will benefit from faster startup times and (if your game is a hit) it will save on bandwidth costs. As always, perform constant iterative testing to intercept problems before they become major issues.</p><p>That’s the end of my mobile tour, but on a desktop browser, <span class="emphasis"><em>Bubble Shooter</em></span> is simple enough that unless you’re playing on a very low-powered machine, you shouldn’t run into performance problems. But at some point, as you develop more complex games, you’ll find that some piece of code runs slower than intended, and then you’ll want to optimize that code.</p></div></div><div class="sect1" title="Optimization"><div class="titlepage"><div><div><h1 class="title"><a id="optimization"/>Optimization</h1></div></div></div><p><a id="iddle1090" class="indexterm"/><a id="iddle1192" class="indexterm"/><a id="iddle1542" class="indexterm"/><a id="iddle1977" class="indexterm"/><a id="iddle2197" class="indexterm"/><a id="iddle2289" class="indexterm"/><a id="iddle2309" class="indexterm"/>Two main areas to look at when you’re optimizing a game are memory management and speed. In particular, you should ensure your game doesn’t consume increasing amounts of system resources the longer it runs, and you’ll want to make the most of available hardware and coding tricks for speed.</p><p>Whether or not you encounter visible problems, such as slowing animation, continually checking your game’s performance is good practice. You’ll likely only need to optimize for speed as a result of a specific problem, but keeping an eye on memory utilization is good practice in all cases. For example, a game may run fine when you play for five minutes, but if you leave it open in a browser tab for hours on end, you may return to find your nice animation loop eating up tens or hundreds of megabytes of memory because of a leak. For less powerful mobile devices, this can be a real problem.</p><p>Fortunately, browser tools can help identify and diagnose problems, and you can implement coding techniques to fix those problems or minimize the risk of them happening. Good memory management is particularly important, so we’ll look at that before we move on to speed optimization.</p><div class="sect2" title="Memory Management"><div class="titlepage"><div><div><h2 class="title"><a id="memory_management"/>Memory Management</h2></div></div></div><p>You might not expect a small JavaScript game to run into memory issues on systems that happily run massive 3D games, but memory management is actually a pressing concern for HTML5 game developers. The problem is less about running out of memory (although it is possible, with some effort, to use up a vast amount of memory) and more about the way JavaScript allocates memory and frees it up later. Rather than constantly allocating and freeing memory, browsers run through periodic sweeps to clear memory, which can cause jittery animations, unresponsive interfaces, and general interruption of game flow.</p><p>Writing JavaScript in ways that minimize memory usage is a large subject, and browser vendors often publish papers on how to get the best out of their systems. For example, check out Mozilla’s documentation on memory management at <span class="emphasis"><em><a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management/">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management/</a></em></span>. You can also read an excellent introduction to memory-efficient JavaScript, written by one of the Chrome engineers, Addy Osmani, at <span class="emphasis"><em><a class="ulink" href="http://www.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/">http://www.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/</a></em></span>.</p><p>The key to dealing with memory issues is identifying them in the first place. You may suspect you have a problem, but you need to know where it is. The main desktop browsers have tools to help. Those tools are constantly evolving, so I won’t discuss them in depth. But a search through the documentation for each browser should bring up relevant documents and tutorials, such as the one for Chrome at <span class="emphasis"><em><a class="ulink" href="https://developer.chrome.com/devtools/docs/javascript-memory-profiling/">https://developer.chrome.com/devtools/docs/javascript-memory-profiling/</a></em></span>.</p><p><a id="iddle1013" class="indexterm"/><a id="iddle1193" class="indexterm"/><a id="iddle1541" class="indexterm"/><a id="iddle1543" class="indexterm"/><a id="iddle1851" class="indexterm"/><a id="iddle1866" class="indexterm"/><a id="iddle2008" class="indexterm"/><a id="iddle2061" class="indexterm"/><a id="iddle2198" class="indexterm"/>Here’s where to start in the three major browsers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>In Chrome, open Developer Tools and click <span class="strong"><strong>Profiles</strong></span>. Select <span class="strong"><strong>Take Heap Snapshot</strong></span> and click <span class="strong"><strong>Take Snapshot</strong></span> to examine objects in memory, including DOM elements. <a class="xref" href="ch08.html#snapshot_of_bubble_shooter_in_memorycomm" title="Figure 8-1. A snapshot of Bubble Shooter in memory, as displayed by the Chrome browser tools">Figure 8-1</a> shows how this looks for <span class="emphasis"><em>Bubble Shooter</em></span>.</p></li><li class="listitem"><p>In Firefox, you can use Firebug and other plug-ins to examine objects in memory. You can also type <span class="strong"><strong><code class="literal">about:memory</code></strong></span> into the address bar for a snapshot of what’s currently in the browser’s memory.</p></li><li class="listitem"><p>In Internet Explorer 11, open the Developer Tools and select the <span class="strong"><strong>Memory</strong></span> tool.</p></li></ul></div><div class="figure"><a id="snapshot_of_bubble_shooter_in_memorycomm"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00028"/><img src="httpatomoreillycomsourcenostarchimages2184543.png.jpg" alt="A snapshot of Bubble Shooter in memory, as displayed by the Chrome browser tools"/></div></div><p class="title">Figure 8-1. A snapshot of <span class="emphasis"><em>Bubble Shooter</em></span> in memory, as displayed by the Chrome browser tools</p></div><p>Another useful tool is to visualize when garbage collection is occurring. This takes the form of a graph across time, and you can see what range of memory your game is occupying. <a class="xref" href="ch08.html#memory_usage_by_bubble_shooter" title="Figure 8-2. Memory usage by Bubble Shooter">Figure 8-2</a> shows <span class="emphasis"><em>Bubble Shooter</em></span>’s memory usage over time.</p><p>The sawtooth line represents memory used when objects are created. The line rises, and then it sharply drops when garbage collection occurs. Although we’re not creating and destroying many objects, there’s a definite sign that if we saw problems with animations not running smoothly, we could look at using more object pools.</p><p><a id="iddle1720" class="indexterm"/><a id="iddle1758" class="indexterm"/><a id="iddle1775" class="indexterm"/><a id="iddle2080" class="indexterm"/><a id="iddle2199" class="indexterm"/><a id="iddle2377" class="indexterm"/><a id="iddle2388" class="indexterm"/><a id="iddle2410" class="indexterm"/><a id="iddle2678" class="indexterm"/>The key to maintaining fast animations is to test and iterate. This is especially true when developing for mobile devices, where debugging tools are usually slightly harder to access and where memory and processing power are also usually less abundant. If you notice intermittent slowdowns and animation freezes that are difficult to reproduce, it’s likely that you have a memory issue to identify and address.</p><div class="figure"><a id="memory_usage_by_bubble_shooter"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00029"/><img src="httpatomoreillycomsourcenostarchimages2184545.png.jpg" alt="Memory usage by Bubble Shooter"/></div></div><p class="title">Figure 8-2. Memory usage by <span class="emphasis"><em>Bubble Shooter</em></span></p></div></div><div class="sect2" title="Optimizing for Speed"><div class="titlepage"><div><div><h2 class="title"><a id="optimizing_for_speed"/>Optimizing for Speed</h2></div></div></div><p>Memory may or may not be an issue, depending on your game’s needs, and memory fixes occasionally require coding techniques somewhat at odds with writing readable, reusable code. However, optimizing for speed is more achievable as a side effect of following general best practices.</p><p>JavaScript engines are improving in speed all the time and so are browsers’ rendering engines (especially with the addition of WebGL). But, as with garbage collection, you should still be aware of the pain points. The browser vendors won’t solve all your performance problems for you. In reality, JavaScript interpreters are becoming so fast that speed problems are more likely to occur while rendering than anywhere else; however, coding techniques can make the translation between JavaScript and machine code more efficient and speed up operations, such as passing image data to the rendering engine.</p><p>Each time you add or change an element in the DOM, the browser has to work out what to draw and where to draw it. HTML documents were originally designed as flowing, text-based documents, and the browser will assume the content you send it is meant to be laid out like any other web page.</p><p><a id="iddle1196" class="indexterm"/><a id="iddle1197" class="indexterm"/><a id="iddle1479" class="indexterm"/><a id="iddle1529" class="indexterm"/><a id="iddle1544" class="indexterm"/><a id="iddle1760" class="indexterm"/><a id="iddle2298" class="indexterm"/><a id="iddle2299" class="indexterm"/><a id="iddle2584" class="indexterm"/>But actions that cause the browser to repaint the display, such as adding new elements to the screen or changing an element’s coordinates, are very common in games. In <span class="emphasis"><em>Bubble Shooter</em></span>, we can get away with adding and removing elements as we want because relatively few elements are onscreen. Multiply the number of items onscreen by 10 or 100, and you’ll start to see problems. Remember that the garbage collector needs to sweep away any element deleted from the scene, and DOM elements tend to be complex.</p><p>By contrast, the canvas copes with graphical additions without an expensive paint operation because no reflowing occurs inside a <code class="literal">canvas</code> element. The browser considers <code class="literal">canvas</code> elements to be images, which are just streams of pixels that go from memory to screen.</p><div class="note" title="Note"><h3 class="title"><a id="ch08note04"/>Note</h3><p><span class="emphasis"><em>Changing properties of the <code class="literal">canvas</code> element, such as its position or transparency, rather than pixels within it, is just as expensive as changing any other DOM element.</em></span></p></div><p>You can see how much time the browser spends painting a scene by loading <span class="emphasis"><em>Bubble Shooter</em></span> in the Chrome desktop browser, pressing F12 to open Developer Tools, and navigating to the Timeline tab. Click <span class="strong"><strong>Record</strong></span> in the bottom control bar, reload the game, and then click the <span class="strong"><strong>Events</strong></span> bar at the top to see a view like <a class="xref" href="ch08.html#browser_events_involved_in_playing_bubbl" title="Figure 8-3. The browser events involved in playing Bubble Shooter in Chrome">Figure 8-3</a>.</p><div class="figure"><a id="browser_events_involved_in_playing_bubbl"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00030"/><img src="httpatomoreillycomsourcenostarchimages2184547.png.jpg" alt="The browser events involved in playing Bubble Shooter in Chrome"/></div></div><p class="title">Figure 8-3. The browser events involved in playing <span class="emphasis"><em>Bubble Shooter</em></span> in Chrome</p></div><p>All of the paint events ➊, like those in <a class="xref" href="ch08.html#browser_events_involved_in_playing_bubbl" title="Figure 8-3. The browser events involved in playing Bubble Shooter in Chrome">Figure 8-3</a>, should be highlighted in green on your screen. In the canvas version of the game, a few paint calls occur once a level has been loaded, whereas in the CSS version, such calls occur constantly.</p><p><a id="iddle1025" class="indexterm"/><a id="iddle1534" class="indexterm"/><a id="iddle1535" class="indexterm"/><a id="iddle1911" class="indexterm"/><a id="iddle2019" class="indexterm"/><a id="iddle2184" class="indexterm"/><a id="iddle2266" class="indexterm"/><a id="iddle2277" class="indexterm"/><a id="iddle2364" class="indexterm"/><a id="iddle2451" class="indexterm"/><a id="iddle2466" class="indexterm"/><a id="iddle2474" class="indexterm"/><a id="iddle2478" class="indexterm"/><a id="iddle2689" class="indexterm"/>You can use the Timeline tool to identify when paint events happen and minimize them to speed up your game’s rendering. Just remember that different browsers may repaint the scene at different times. As always, use the tools available, but also test on your target platforms and devices as the main guide to performance.</p><p>In general, minimizing DOM manipulation is the key to minimizing paint operations. Search for articles on minimizing browser reflow and browser paint operations for more detailed and up-to-date information on the inner workings of rendering engines.</p></div></div><div class="sect1" title="Security"><div class="titlepage"><div><div><h1 class="title"><a id="security"/>Security</h1></div></div></div><p>If your game has any kind of scoring or progression system, someone will try to cheat it. But the key is to assess the ramifications of having cheats slip through the system and decide whether or not those ramifications are critical. For <span class="emphasis"><em>Bubble Shooter</em></span>, this isn’t an issue: if someone wants to set a high score on their local machine, that’s up to them. However, for games with an online competitive element or where buying power-ups is a revenue stream, you need to ensure that cheating is difficult to impossible.</p><p>We can try to address security in HTML5 games in a few ways.</p><div class="sect2" title="Trust No One"><div class="titlepage"><div><div><h2 class="title"><a id="trust_no_one"/>Trust No One</h2></div></div></div><p>The simplistic approach to security in any games that run on the client, whether they’re built with HTML5, Flash, or even native code, is to not trust anything that the client sends to the server. A POST back to the server with, say, a high score value (as we used in the examples on AJAX and Web-Sockets) is easily forged. The score may be valid, the POST may be forged, or someone may even use a debugging tool to change the high score while the game runs. The server only sees the data as it’s received and can’t differentiate between a genuine and a cheat POST.</p><p>Unfortunately, not trusting the client is often the correct approach: there’s no way to completely guarantee the security of code running on the client. The only way to make a game secure is to have all game logic processed by the server. To completely secure <span class="emphasis"><em>Bubble Shooter</em></span>, we’d pass mouse clicks to the server, have the collision and popping logic run on the server, and then pass the results back to the client to animate. This is more difficult to develop and test, and the user would need a constant (and fast) Internet connection to even play the game.</p></div><div class="sect2" title="Obfuscation"><div class="titlepage"><div><div><h2 class="title"><a id="obfuscation"/>Obfuscation</h2></div></div></div><p>The server-side approach is essential when a game includes financial transactions, but for many games, obfuscation is good enough. The idea behind obfuscation is to make cheating as difficult as possible, essentially making the effort involved greater than the reward. For example, if a high score is posted to the server as an encoded value, passed with a checksum, <a id="iddle1563" class="indexterm"/><a id="iddle1591" class="indexterm"/><a id="iddle1991" class="indexterm"/><a id="iddle2202" class="indexterm"/><a id="iddle2366" class="indexterm"/><a id="iddle2389" class="indexterm"/><a id="iddle2693" class="indexterm"/>and takes hours of reading through code to decipher how it was created, cheaters are unlikely to go through all of that effort just to get to the top of a high score table.</p><p>Of course, obfuscation usually comes at the price of readability for you as well as hackers. But there are a number of ways to make code difficult to read, and you can even apply some as a post-build process.</p><p>The simplest option is running your code through a <span class="emphasis"><em>minifier</em></span> before you package it for a live environment. Minifiers shorten all long variable names in your code and eliminate whitespace. For example, code such as this:</p><a id="pro_id00193"/><pre class="programlisting">var highScore = 0;
highScore += 20;</pre><p>becomes something like this after minifying:</p><a id="pro_id00194"/><pre class="programlisting">var highScore=0;highScore+=20;</pre><p>Effectively, minifying removes the whitespace and puts everything onto one line. Such minified code quickly becomes difficult to read. You can easily un-minify the line breaks. Many minifiers will also rename variables inside functions. For example, this function:</p><a id="pro_id00195"/><pre class="programlisting">var highScore = (function(){
  var highScore = 0;
  highScore += 20;
  return highScore;
});</pre><p>could become much smaller:</p><a id="pro_id00196"/><pre class="programlisting">var highScore=function(){var a=0;return a+=20};</pre><p>The property that you’ve been calling <code class="literal">highScore</code> in your code becomes much harder to find if it’s now called <code class="literal">a</code> instead!</p><div class="note" title="Note"><h3 class="title"><a id="ch08note05"/>Note</h3><p><span class="emphasis"><em>Minifying code also has the added advantage of creating smaller code that should therefore load faster, which is an important consideration when deploying in a web environment. In fact, you should consider minifying your JavaScript code in all web applications.</em></span></p></div><p>Google released a tool called the Closure Compiler, which acts as a minifier along with providing a number of other benefits. It attempts to optimize code, even rewriting it in places, and outputs smaller and sometimes even faster code than the original version. The compiler generates JavaScript, analyzes your code, and raises errors. Declaring variables, keeping track of scope, and maintaining other good practices pay off when you use a minifier such as the Closure Compiler, because the compiler provides greater benefits the clearer and simpler your coding structure is.</p><p><a id="iddle1187" class="indexterm"/><a id="iddle1852" class="indexterm"/><a id="iddle2096" class="indexterm"/><a id="iddle2369" class="indexterm"/><a id="iddle2441" class="indexterm"/><a id="iddle2651" class="indexterm"/><a id="iddle2655" class="indexterm"/>You can use the Closure Compiler online or download and run the Java application from <span class="emphasis"><em><a class="ulink" href="https://developers.google.com/closure/compiler/">https://developers.google.com/closure/compiler/</a></em></span>. Once you have access to it, paste the Closure Compiler in the JavaScript code that you want to compile and then copy the output. It’s recommended that you keep a copy of your original code, because the compiler output is far too difficult to work with if you need to make further changes.</p></div><div class="sect2" title="Using Private Variables"><div class="titlepage"><div><div><h2 class="title"><a id="using_private_variables"/>Using Private Variables</h2></div></div></div><p>Along with post-build processes, you can also code in ways that make it harder for cheaters to follow through code and change it on the fly. For example, private variables make manipulating internal values on the console more difficult. The following has a private variable for <code class="literal">highScore</code>:</p><a id="pro_id00197"/><pre class="programlisting">var Game = function(){
  var highScore = 0;
  var getHighScore = function(){ return highScore;};
  return this;
};</pre><p>The variable is considered private because it only exists inside the scope of a <code class="literal">Game</code> object. We could have made the variable public as follows:</p><a id="pro_id00198"/><pre class="programlisting">var Game = function(){
  this.highScore = 0;
  var getHighScore = function(){ return this.highScore;};
  return this;
};</pre><p>This would allow the value of <code class="literal">highScore</code> to be changed on a <code class="literal">Game</code> object just by changing the value of its <code class="literal">highScore</code> property. However, in the private version, there’s no way to access the value of <code class="literal">highScore</code> from outside the object.</p><p>If <code class="literal">highScore</code> is private, cheaters will have difficulty changing its value without using a program like Firebug to add a breakpoint within the object. They’ll have even more trouble if the code is minified and obfuscated. <code class="literal">highScore</code> is actually labeled <code class="literal">"a"</code>, and it’s difficult to even find where the high score is updated in the first place.</p><p>With a couple of relatively simple steps (making some variables private and minifying our code), we’ve already narrowed down the potential cheaters from those who know a small amount of JavaScript to those who know it quite well and are willing to take the time to reverse engineer our code. Now, let’s look at one more way to prevent cheating.</p></div><div class="sect2" title="Validating with Checksums"><div class="titlepage"><div><div><h2 class="title"><a id="validating_with_checksums"/>Validating with Checksums</h2></div></div></div><p>You can also secure information passed to the server by using checksums to validate the variable passed. The simplest techniques just encode a value so there is at least some check that the number is correct. This won’t eliminate <a id="iddle1201" class="indexterm"/><a id="iddle1647" class="indexterm"/><a id="iddle2007" class="indexterm"/><a id="iddle2195" class="indexterm"/><a id="iddle2365" class="indexterm"/><a id="iddle2479" class="indexterm"/><a id="iddle2493" class="indexterm"/>cheating, and checksums don’t need to be very complicated, but it will ensure that anyone who wants to cheat needs to read and understand your JavaScript code first. For example, if we passed <code class="literal">highScore</code> to the server, we could POST something like this:</p><a id="pro_id00199"/><pre class="programlisting">{
  highScore : 9825,
  check : 21
}</pre><p>The value 21 is 9,825 modulus 129 (or <code class="literal">highScore%129</code> in code), where 129 is a number I chose as being big enough to create a range of check values but also being a factor smaller than likely high scores. This almost trivial check actually increases the level of security because now the barrier to posting a fake high score is not only knowing how to POST but also being able to follow through the code to the point where the <code class="literal">check</code> value is created. A seasoned JavaScript programmer might find those steps simple, but the average meddling game player probably won’t.</p><p>The preceding example may be too trivial for your liking, and you can use any process you like for generating a checksum. Common approaches include using hash functions such as MD5, SHA, or CRC32, although the disadvantage of these is that programmers will often recognize the structure well enough to know they are looking at a standard hashing function.</p><p>In principle, any process you create that can generate a range of check values will significantly slow down, and possibly discourage, a large number of potential cheaters.</p><p>Of course, you may still get a few cheaters whatever you do, because some hackers enjoy the challenge of beating the programmer more than the challenge of beating the game. You can obfuscate as much as you like, and you may end up with code that’s almost impossible to read. But remember that you can never guarantee security in client-side code and never fully trust the information passed from the client to the server.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00015"/>Summary</h1></div></div></div><p>As you may have gathered from this chapter, browser support for HTML5 is an ever-changing landscape. The good news is that browsers are generally converging on the same standard rather than adding their own features. Also, support for HTML5 is improving all the time.</p><p>With the rate of change, it’s important to keep up-to-date on which browser features are ready for mainstream usage as well as what’s on the horizon. Whether in terms of improved performance, memory management, sound, or 3D features, the capabilities of HTML5 games are constantly advancing.</p></div><div class="sect1" title="Further Practice"><div class="titlepage"><div><div><h1 class="title"><a id="further_practice-id00016"/>Further Practice</h1></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Add fullscreen capability to <span class="emphasis"><em>Bubble Shooter</em></span> in a desktop browser. To make the switch as easy as possible, add a button to the top bar that is visible only if fullscreen mode is supported. Also, change the CSS so that when the page is displayed fullscreen, the game is centered.</p></li><li class="listitem"><p>Write a routine to post the player’s score to a fictional server address using jQuery’s <code class="literal">ajax</code> method. Post the score at the end of each level and write a checksum function to add basic security using your method of choice.</p></li><li class="listitem"><p>Find and test some online minifier and obfuscation services. Compare the file size of the output code to the size of the original source.</p></li></ol></div></div></div></body></html>