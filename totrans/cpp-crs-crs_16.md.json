["```\n#include <array>\n\nstd::array<int, 10> static_array{} ➊\n\nTEST_CASE(\"std::array\") {\n  REQUIRE(static_array[0] == 0); ➋\n\n  SECTION(\"uninitialized without braced initializers\") {\n    std::array<int, 10> local_array; ➌\n    REQUIRE(local_array[0] != 0); ➍\n  }\n\n  SECTION(\"initialized with braced initializers\") {\n    std::array<int, 10> local_array{ 1, 1, 2, 3 }; ➎\n    REQUIRE(local_array[0] == 1);\n    REQUIRE(local_array[1] == 1);\n    REQUIRE(local_array[2] == 2);\n    REQUIRE(local_array[3] == 3);\n    REQUIRE(local_array[4] == 0); ➏\n  }\n}\n```", "```\nTEST_CASE(\"std::array access\") {\n   std::array<int, 4> fib{ 1, 1, 0, 3}; ➊\n\n  SECTION(\"operator[] can get and set elements\") {\n    fib[2] = 2; ➋\n    REQUIRE(fib[2] == 2); ➌\n    // fib[4] = 5; ➍\n  }\n\n  SECTION(\"at() can get and set elements\") {\n    fib.at(2) = 2; ➎\n    REQUIRE(fib.at(2) == 2); ➏\n    REQUIRE_THROWS_AS(fib.at(4), std::out_of_range); ➐\n  }\n  SECTION(\"get can get and set elements\") {\n    std::get<2>(fib) = 2; ➑\n    REQUIRE(std::get<2>(fib) == 2); ➒\n    // std::get<4>(fib); ➓\n  }\n}\n```", "```\nTEST_CASE(\"std::array has convenience methods\") {\n  std::array<int, 4> fib{ 0, 1, 2, 0 };\n\n  SECTION(\"front\") {\n    fib.front() = 1; ➊\n    REQUIRE(fib.front() == 1); ➋\n    REQUIRE(fib.front() == fib[0]); ➌\n  }\n\n  SECTION(\"back\") {\n    fib.back() = 3; ➍\n    REQUIRE(fib.back() == 3); ➎\n    REQUIRE(fib.back() == fib[3]); ➏\n  }\n}\n```", "```\nTEST_CASE(\"We can obtain a pointer to the first element using\") {\n  std::array<char, 9> color{ 'o',  'c', 't', 'a', 'r', 'i', 'n', 'e' };\n  const auto* color_ptr = color.data(); ➊\n\n  SECTION(\"data\") {\n    REQUIRE(*color_ptr == 'o'); ➋\n  }\n  SECTION(\"address-of front\") {\n    REQUIRE(&color.front() == color_ptr); ➌\n  }\n  SECTION(\"address-of at(0)\") {\n    REQUIRE(&color.at(0) == color_ptr); ➍\n  }\n  SECTION(\"address-of [0]\") {\n    REQUIRE(&color[0] == color_ptr); ➎\n  }\n}\n```", "```\nTEST_CASE(\"std::array begin/end form a half-open range\") {\n  std::array<int, 0> e{}; ➊\n  REQUIRE(e.begin()➋ == e.end()➌);\n}\n```", "```\nTEST_CASE(\"std::array iterators are pointer-like\") {\n  std::array<int, 3> easy_as{ 1, 2, 3 }; ➊\n  auto iter = easy_as.begin(); ➋\n  REQUIRE(*iter == 1); ➌\n  ++iter; ➍\n  REQUIRE(*iter == 2);\n  ++iter;\n  REQUIRE(*iter == 3); ➎\n  ++iter; ➏\n  REQUIRE(iter == easy_as.end()); ➐\n}\n```", "```\nTEST_CASE(\"std::array can be used as a range expression\") {\n  std::array<int, 5> fib{ 1, 1, 2, 3, 5 }; ➊\n  int sum{}; ➋\n  for (const auto element : fib) ➌\n    sum += element; ➍\n  REQUIRE(sum == 12);\n}\n```", "```\n#include <vector>\nTEST_CASE(\"std::vector supports default construction\") {\n  std::vector<const char*➊> vec; ➋\n  REQUIRE(vec.empty()); ➌\n}\n```", "```\nTEST_CASE(\"std::vector supports braced initialization \") {\n    std::vector<int> fib{ 1, 1, 2, 3, 5 }; ➊\n    REQUIRE(fib[4] == 5); ➋\n}\n```", "```\nTEST_CASE(\"std::vector supports\") {\n  SECTION(\"braced initialization\") {\n    std::vector<int> five_nine{ 5, 9 }; ➊\n REQUIRE(five_nine[0] == 5); ➋\n    REQUIRE(five_nine[1] == 9); ➌\n  }\n  SECTION(\"fill constructor\") {\n    std::vector<int> five_nines(5, 9); ➍\n    REQUIRE(five_nines[0] == 9); ➎\n    REQUIRE(five_nines[4] == 9); ➏\n  }\n}\n```", "```\nTEST_CASE(\"std::vector supports construction from iterators\") {\n  std::array<int, 5> fib_arr{ 1, 1, 2, 3, 5 }; ➊\n  std::vector<int> fib_vec(fib_arr.begin(), fib_arr.end()); ➋\n  REQUIRE(fib_vec[4] == 5); ➌\n  REQUIRE(fib_vec.size() == fib_arr.size()); ➍\n}\n```", "```\nTEST_CASE(\"std::vector assign replaces existing elements\") {\n  std::vector<int> message{ 13, 80, 110, 114, 102, 110, 101 }; ➊\n  REQUIRE(message.size() == 7); ➋\n  message.assign({ 67, 97, 101, 115, 97, 114 }); ➌\n  REQUIRE(message[5] == 114); ➍\n  REQUIRE(message.size() == 6); ➎\n}\n```", "```\nTEST_CASE(\"std::vector insert places new elements\") {\n  std::vector<int> zeros(3, 0); ➊\n  auto third_element = zeros.begin() + 2; ➋\n  zeros.insert(third_element, 10); ➌\n  REQUIRE(zeros[2] == 10); ➍\n  REQUIRE(zeros.size() == 4); ➎\n}\n```", "```\nTEST_CASE(\"std::vector push_back places new elements\") {\n  std::vector<int> zeros(3, 0); ➊\n  zeros.push_back(10); ➋\n  REQUIRE(zeros[3] == 10); ➌\n}\n```", "```\n#include <utility>\n\nTEST_CASE(\"std::vector emplace methods forward arguments\") {\n  std::vector<std::pair<int, int>> factors; ➊\n  factors.emplace_back(2, 30); ➋\n  factors.emplace_back(3, 20); ➌\n  factors.emplace_back(4, 15); ➍\n  factors.emplace(factors.begin()➎, 1, 60);\n  REQUIRE(factors[0].first == 1); ➏\n  REQUIRE(factors[0].second == 60); ➐\n}\n```", "```\n#include <cstdint>\n#include <array>\n\nTEST_CASE(\"std::vector exposes size management methods\") {\n  std::vector<std::array<uint8_t, 1024>> kb_store; ➊\n  REQUIRE(kb_store.max_size() > 0);\n  REQUIRE(kb_store.empty()); ➋\n\n  size_t elements{ 1024 };\n  kb_store.reserve(elements); ➌\n  REQUIRE(kb_store.empty());\n  REQUIRE(kb_store.capacity() == elements); ➍\n\n  kb_store.emplace_back();\n  kb_store.emplace_back();\n  kb_store.emplace_back();\n  REQUIRE(kb_store.size() == 3); ➎\n\n  kb_store.shrink_to_fit();\n  REQUIRE(kb_store.capacity() >= 3); ➏\n\n  kb_store.clear(); ➐\n  REQUIRE(kb_store.empty());\n  REQUIRE(kb_store.capacity() >= 3); ➑\n}\n```", "```\n#include <deque>\n\nTEST_CASE(\"std::deque supports front insertion\") {\n  std::deque<char> deckard;\n  deckard.push_front('a'); ➊ //  a\n  deckard.push_back('i'); ➋ //  ai\n  deckard.push_front('c');   // cai\n  deckard.push_back('n');    // cain\n  REQUIRE(deckard[0] == 'c'); ➌\n  REQUIRE(deckard[1] == 'a');\n  REQUIRE(deckard[2] == 'i');\n  REQUIRE(deckard[3] == 'n');\n}\n```", "```\n#include <list>\n\nTEST_CASE(\"std::list supports front insertion\") {\n  std::list<int> odds{ 11, 22, 33, 44, 55 }; ➊\n  odds.remove_if([](int x) { return x % 2 == 0; }); ➋\n  auto odds_iter = odds.begin(); ➌\n  REQUIRE(*odds_iter == 11); ➍\n  ++odds_iter; ➎\n  REQUIRE(*odds_iter == 33);\n  ++odds_iter;\n  REQUIRE(*odds_iter == 55);\n  ++odds_iter;\n  REQUIRE(odds_iter == odds.end()); ➏\n}\n```", "```\n#include <stack>\n\nTEST_CASE(\"std::stack supports push/pop/top operations\") {\n  std::vector<int> vec{ 1, 3 }; ➊  // 1 3\n std::stack<int, decltype(vec)> easy_as(vec); ➋\n  REQUIRE(easy_as.top() == 3); ➌\n  easy_as.pop(); ➍                 // 1\n  easy_as.push(2); ➎               // 1 2\n  REQUIRE(easy_as.top() == 2); ➏\n  easy_as.pop();                 // 1\n  REQUIRE(easy_as.top() == 1);\n  easy_as.pop();                 //\n  REQUIRE(easy_as.empty()); ➐\n}\n```", "```\n#include <queue>\n\nTEST_CASE(\"std::queue supports push/pop/front/back\") {\n  std::deque<int> deq{ 1, 2 }; ➊\n  std::queue<int> easy_as(deq); ➋ // 1 2\n\n  REQUIRE(easy_as.front() == 1); ➌\n  REQUIRE(easy_as.back() == 2); ➍\n  easy_as.pop(); ➎                // 2\n  easy_as.push(3); ➏              // 2 3\n  REQUIRE(easy_as.front() == 2); ➐\n  REQUIRE(easy_as.back() == 3); ➑\n  easy_as.pop();                   // 3\n  REQUIRE(easy_as.front() == 3);\n  easy_as.pop();                   //\n  REQUIRE(easy_as.empty()); ➒\n}\n```", "```\n#include <queue>\n\nTEST_CASE(\"std::priority_queue supports push/pop\") {\n  std::priority_queue<double> prique; ➊\n  prique.push(1.0); // 1.0\n  prique.push(2.0); // 2.0 1.0\n  prique.push(1.5); // 2.0 1.5 1.0\n REQUIRE(prique.top() == Approx(2.0)); ➋\n  prique.pop();     // 1.5 1.0\n  prique.push(1.0); // 1.5 1.0 1.0\n  REQUIRE(prique.top() == Approx(1.5)); ➌\n  prique.pop();     // 1.0 1.0\n  REQUIRE(prique.top() == Approx(1.0)); ➍\n  prique.pop();     // 1.0\n  REQUIRE(prique.top() == Approx(1.0)); ➎\n  prique.pop();     //\n  REQUIRE(prique.empty()); ➏\n}\n```", "```\n#include <bitset>\n\nTEST_CASE(\"std::bitset supports integer initialization\") {\n  std::bitset<4> bs(0b1010); ➊\n  REQUIRE_FALSE(bs[0]); ➋\n  REQUIRE(bs[1]); ➌\n  REQUIRE_FALSE(bs[2]); ➍\n  REQUIRE(bs[3]); ➎\n}\n```", "```\nTEST_CASE(\"std::bitset supports string initialization\") {\n  std::bitset<4> bs1(0b0110); ➊\n  std::bitset<4> bs2(\"0110\"); ➋\n  REQUIRE(bs1 == bs2); ➌\n}\n```", "```\n#include <set>\n\nTEST_CASE(\"std::set supports\") {\n  std::set<int> emp; ➊\n  std::set<int> fib{ 1, 1, 2, 3, 5 }; ➋\n  SECTION(\"default construction\") {\n    REQUIRE(emp.empty()); ➌\n  }\n  SECTION(\"braced initialization\") {\n    REQUIRE(fib.size() == 4); ➍\n  }\n  SECTION(\"copy construction\") {\n    auto fib_copy(fib);\n    REQUIRE(fib.size() == 4); ➎\n    REQUIRE(fib_copy.size() == 4); ➏\n  }\n  SECTION(\"move construction\") {\n    auto fib_moved(std::move(fib));\n    REQUIRE(fib.empty()); ➐\n    REQUIRE(fib_moved.size() == 4); ➑\n }\n  SECTION(\"range construction\") {\n    std::array<int, 5> fib_array{ 1, 1, 2, 3, 5 };\n    std::set<int> fib_set(fib_array.cbegin(), fib_array.cend());\n    REQUIRE(fib_set.size() == 4); ➒\n  }\n}\n```", "```\nTEST_CASE(\"std::set allows access\") {\n  std::set<int> fib{ 1, 1, 2, 3, 5 }; ➊\n  SECTION(\"with find\") { ➋\n    REQUIRE(*fib.find(3) == 3);\n    REQUIRE(fib.find(100) == fib.end());\n  }\n  SECTION(\"with count\") { ➌\n    REQUIRE(fib.count(3) == 1);\n    REQUIRE(fib.count(100) == 0);\n  }\n  SECTION(\"with lower_bound\") { ➍\n    auto itr = fib.lower_bound(3);\n    REQUIRE(*itr == 3);\n  }\n  SECTION(\"with upper_bound\") { ➎\n    auto itr = fib.upper_bound(3);\n    REQUIRE(*itr == 5);\n  }\n  SECTION(\"with equal_range\") { ➏\n    auto pair_itr = fib.equal_range(3);\n    REQUIRE(*pair_itr.first == 3);\n    REQUIRE(*pair_itr.second == 5);\n  }\n}\n```", "```\nTEST_CASE(\"std::set allows insertion\") {\n  std::set<int> fib{ 1, 1, 2, 3, 5 };\n  SECTION(\"with insert\") { ➊\n    fib.insert(8);\n    REQUIRE(fib.find(8) != fib.end());\n  }\n  SECTION(\"with emplace\") { ➋\n    fib.emplace(8);\n    REQUIRE(fib.find(8) != fib.end());\n  }\n  SECTION(\"with emplace_hint\") { ➌\n    fib.emplace_hint(fib.end(), 8);\n    REQUIRE(fib.find(8) != fib.end());\n  }\n}\n```", "```\nTEST_CASE(\"std::set allows removal\") {\n  std::set<int> fib{ 1, 1, 2, 3, 5 };\n  SECTION(\"with erase\") { ➊\n fib.erase(3);\n    REQUIRE(fib.find(3) == fib.end());\n  }\n  SECTION(\"with clear\") { ➋\n    fib.clear();\n    REQUIRE(fib.empty());\n  }\n}\n```", "```\nTEST_CASE(\"std::multiset handles non-unique elements\") {\n  std::multiset<int> fib{ 1, 1, 2, 3, 5 };\n  SECTION(\"as reflected by size\") {\n    REQUIRE(fib.size() == 5); ➊\n  }\n  SECTION(\"and count returns values greater than 1\") {\n    REQUIRE(fib.count(1) == 2); ➋\n  }\n  SECTION(\"and equal_range returns non-trivial ranges\") {\n    auto [begin, end] = fib.equal_range(1); ➌\n    REQUIRE(*begin == 1); ➍\n    ++begin;\n    REQUIRE(*begin == 1); ➎\n    ++begin;\n    REQUIRE(begin == end); ➏\n  }\n}\n```", "```\n#include <functional>\nTEST_CASE(\"std::hash<long> returns\") {\n  std::hash<long> hasher; ➊\n  auto hash_code_42 = hasher(42); ➋\n  SECTION(\"equal hash codes for equal keys\") {\n    REQUIRE(hash_code_42 == hasher(42)); ➌\n  }\n  SECTION(\"unequal hash codes for unequal keys\") {\n    REQUIRE(hash_code_42 != hasher(43)); ➍\n  }\n}\n```", "```\n#include <functional>\nTEST_CASE(\"std::equal_to<long> returns\") {\n  std::equal_to<long> long_equal_to; ➊\n  SECTION(\"true when arguments equal\") {\n    REQUIRE(long_equal_to(42, 42)); ➋\n  }\n  SECTION(\"false when arguments unequal\") {\n    REQUIRE_FALSE(long_equal_to(42, 43)); ➌\n  }\n}\n```", "```\n#include <unordered_set>\nTEST_CASE(\"std::unordered_set\") {\n  std::unordered_set<unsigned long> sheep(100); ➊\n  SECTION(\"allows bucket count specification on construction\") {\n    REQUIRE(sheep.bucket_count() >= 100); ➋\n    REQUIRE(sheep.bucket_count() <= sheep.max_bucket_count()); ➌\n    REQUIRE(sheep.max_load_factor() == Approx(1.0)); ➍\n  }\n  SECTION(\"allows us to reserve space for elements\") {\n    sheep.reserve(100'000); ➎\n    sheep.insert(0);\n    REQUIRE(sheep.load_factor() <= 0.00001); ➏\n    while(sheep.size() < 100'000)\n      sheep.insert(sheep.size()); ➐\n    REQUIRE(sheep.load_factor() <= 1.0); ➑\n  }\n}\n```", "```\n#include <map>\n\nauto colour_of_magic = \"Colour of Magic\";\nauto the_light_fantastic = \"The Light Fantastic\";\nauto equal_rites = \"Equal Rites\";\nauto mort = \"Mort\";\n\nTEST_CASE(\"std::map supports\") {\n  SECTION(\"default construction\") {\n    std::map<const char*, int> emp; ➊\n    REQUIRE(emp.empty()); ➋\n  }\n  SECTION(\"braced initialization\") {\n    std::map<const char*, int> pub_year { ➌\n      { colour_of_magic, 1983 }, ➍\n      { the_light_fantastic, 1986 },\n      { equal_rites, 1987 },\n      { mort, 1987 },\n    };\n    REQUIRE(pub_year.size() == 4); ➎\n  }\n}\n```", "```\nTEST_CASE(\"std::map is an associative array with\") {\n  std::map<const char*, int> pub_year { ➊\n    { colour_of_magic, 1983 },\n    { the_light_fantastic, 1986 },\n  };\n  SECTION(\"operator[]\") {\n    REQUIRE(pub_year[colour_of_magic] == 1983); ➋\n\n    pub_year[equal_rites] = 1987; ➌\n    REQUIRE(pub_year[equal_rites] == 1987); ➍\n\n    REQUIRE(pub_year[mort] == 0); ➎\n  }\n  SECTION(\"an at method\") {\n    REQUIRE(pub_year.at(colour_of_magic) == 1983); ➏\n\n    REQUIRE_THROWS_AS(pub_year.at(equal_rites), std::out_of_range); ➐\n  }\n}\n```", "```\nTEST_CASE(\"std::map supports insert\") {\n  std::map<const char*, int> pub_year; ➊\n  pub_year.insert({ colour_of_magic, 1983 }); ➋\n  REQUIRE(pub_year.size() == 1); ➌\n\n  std::pair<const char*, int> tlfp{ the_light_fantastic, 1986 }; ➍\n  pub_year.insert(tlfp); ➎\n  REQUIRE(pub_year.size() == 2); ➏\n\n  auto [itr, is_new] = pub_year.insert({ the_light_fantastic, 9999 }); ➐\n  REQUIRE(itr->first == the_light_fantastic);\n  REQUIRE(itr->second == 1986); ➑\n  REQUIRE_FALSE(is_new); ➒\n  REQUIRE(pub_year.size() == 2); ➓\n}\n```", "```\npub_year.insert(std::pair<const char*, int>{ colour_of_magic, 1983 });\n```", "```\nTEST_CASE(\"std::map supports insert_or_assign\") {\n  std::map<const char*, int> pub_year{ ➊\n    { the_light_fantastic, 9999 }\n  };\n  auto [itr, is_new] = pub_year.insert_or_assign(the_light_fantastic, 1986); ➋\n  REQUIRE(itr->second == 1986); ➌\n  REQUIRE_FALSE(is_new); ➍\n}\n```", "```\nTEST_CASE(\"We can remove std::map elements using\") {\n    std::map<const char*, int> pub_year {\n      { colour_of_magic, 1983 },\n      { mort, 1987 },\n    }; ➊\n  SECTION(\"erase\") {\n    pub_year.erase(mort); ➋\n    REQUIRE(pub_year.find(mort) == pub_year.end()); ➌\n  }\n  SECTION(\"clear\") {\n    pub_year.clear(); ➍\n    REQUIRE(pub_year.empty()); ➎\n  }\n}\n```", "```\nTEST_CASE(\"std::multimap supports non-unique keys\") {\n  std::array<char, 64> far_out {\n    \"Far out in the uncharted backwaters of the unfashionable end...\"\n  }; ➊\n  std::multimap<char, size_t> indices; ➋\n  for(size_t index{}; index<far_out.size(); index++)\n    indices.emplace(far_out[index], index); ➌\n\n  REQUIRE(indices.count('a') == 6); ➍\n\n  auto [itr, end] = indices.equal_range('d'); ➎\n  REQUIRE(itr->second == 23); ➏\n  itr++;\n  REQUIRE(itr->second == 59); ➐\n  itr++;\n  REQUIRE(itr == end);\n}\n```", "```\n#include <set>\n#include <boost/graph/adjacency_list.hpp>\n\nTEST_CASE(\"boost::adjacency_list stores graph data\") {\n  boost::adjacency_list<> graph{}; ➊\n  auto vertex_1 = boost::add_vertex(graph);\n  auto vertex_2 = boost::add_vertex(graph);\n  auto vertex_3 = boost::add_vertex(graph);\n  auto vertex_4 = boost::add_vertex(graph); ➋\n  auto edge_12 = boost::add_edge(vertex_1, vertex_2, graph);\n  auto edge_13 = boost::add_edge(vertex_1, vertex_3, graph);\n  auto edge_21 = boost::add_edge(vertex_2, vertex_1, graph);\n  auto edge_24 = boost::add_edge(vertex_2, vertex_4, graph);\n  auto edge_43 = boost::add_edge(vertex_4, vertex_3, graph); ➌\n\n  REQUIRE(boost::num_vertices(graph) == 4); ➍\n  REQUIRE(boost::num_edges(graph) == 5); ➎\n\n  auto [begin, end] = boost::adjacent_vertices(vertex_1, graph); ➏\n  std::set<decltype(vertex_1)> neighboors_1 { begin, end }; ➐\n  REQUIRE(neighboors_1.count(vertex_2) == 1); ➑\n  REQUIRE(neighboors_1.count(vertex_3) == 1); ➒\n  REQUIRE(neighboors_1.count(vertex_4) == 0); ➓\n}\n```", "```\n#include <boost/property_tree/ptree.hpp>\n#include <boost/property_tree/json_parser.hpp>\n\nTEST_CASE(\"boost::property_tree::ptree stores tree data\") {\n  using namespace boost::property_tree;\n  ptree p; ➊\n  p.put(\"name\", \"finfisher\");\n  p.put(\"year\", 2014);\n  p.put(\"features.process\", \"LSASS\");\n  p.put(\"features.driver\", \"mssounddx.sys\");\n  p.put(\"features.arch\", 32); ➋\n REQUIRE(p.get_child(\"year\").get_value<int>() == 2014); ➌\n\n  const auto file_name = \"rootkit.json\";\n  write_json(file_name, p); ➍\n\n  ptree p_copy;\n  read_json(file_name, p_copy); ➎\n  REQUIRE(p_copy == p); ➏\n}\n--------------------------------------------------------------------------\n{\n    \"name\": \"finfisher\",\n    \"year\": \"2014\",\n    \"features\": {\n        \"process\": \"LSASS\",\n        \"driver\": \"mssounddx.sys\",\n        \"arch\": \"32\"\n    }\n} ➍\n```", "```\n#include <cmath>\n#include <stdexcept>\n#include <initializer_list>\n#include <vector>\n\nsize_t square_root(size_t x) { ➊\n  const auto result = static_cast<size_t>(sqrt(x));\n  if (result * result != x) throw std::logic_error{ \"Not a perfect square.\" };\n  return result;\n}\n\ntemplate <typename T>\nstruct SquareMatrix {\n  SquareMatrix(std::initializer_list<T> val) ➋\n    : dim{ square_root(val.size()) }, ➌\n      data(dim, std::vector<T>{}) { ➍\n    auto itr = val.begin(); ➎\n    for(size_t row{}; row<dim; row++){\n      data[row].assign(itr, itr+dim); ➏\n      itr += dim; ➐\n    }\n  }\n  T& at(size_t row, size_t col) {\n    if (row >= dim || col >= dim)\n      throw std::out_of_range{ \"Index invalid.\" }; ➑\n    return data[row][col]; ➒\n  }\n  const size_t dim;\nprivate:\n  std::vector<std::vector<T>> data;\n};\n```", "```\nTEST_CASE(\"SquareMatrix and std::initializer_list\") {\n  SquareMatrix<int> mat { ➊\n     1,  2,  3,  4,\n     5,  0,  7,  8,\n     9, 10, 11, 12,\n    13, 14, 15, 16\n  };\n  REQUIRE(mat.dim == 4); ➋\n  mat.at(1, 1) = 6; ➌\n  REQUIRE(mat.at(1, 1) == 6); ➍\n  REQUIRE(mat.at(0, 2) ==  3); ➎\n}\n```", "```\n#include <chrono>\n#include <cstdio>\n#include <random>\n\nlong fib_sum(size_t n) { ➊\n  // TODO: Adapt code from Exercise 12.1\n  return 0;\n}\n\nlong random() { ➋\n  static std::mt19937_64 mt_engine{ 102787 };\n  static std::uniform_int_distribution<long> int_d{ 1000, 2000 };\n  return int_d(mt_engine);\n}\n\nstruct Stopwatch { ➌\n  Stopwatch(std::chrono::nanoseconds& result)\n    : result{ result },\n    start{ std::chrono::system_clock::now() } { }\n  ~Stopwatch() {\n    result = std::chrono::system_clock::now() - start;\n  }\nprivate:\n  std::chrono::nanoseconds& result;\n  const std::chrono::time_point<std::chrono::system_clock> start;\n};\n\nlong cached_fib_sum(const size_t& n) { ➍\n  static std::map<long, long> cache;\n  // TODO: Implement me\n  return 0;\n}\n\nint main() {\n\n  size_t samples{ 1'000'000 };\n  std::chrono::nanoseconds elapsed;\n {\n    Stopwatch stopwatch{elapsed};\n    volatile double answer;\n    while(samples--) {\n      answer = fib_sum(random()); ➎\n      //answer = cached_fib_sum(random()); ➏\n    }\n  }\n  printf(\"Elapsed: %g s.\\n\", elapsed.count() / 1'000'000'000.); ➐\n}\n```"]