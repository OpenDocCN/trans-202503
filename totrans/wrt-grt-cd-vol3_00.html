<html><head></head><body><div id="sbo-rt-content"><h2 class="h2i" id="intro"><span epub:type="pagebreak" id="page_xix"/><strong>INTRODUCTION</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindent"><span class="big1">In the late 1960s, the need for computer software was outpacing the capability of technical schools, colleges, and universities to produce trained computer professionals to create that software—a phenomenon that became known as the <em>software crisis</em>. Increasing the output of colleges</span> and universities wasn’t a practical approach; too few qualified students were enrolling in computer science programs to satisfy the demand. At the time, researchers determined that a better solution was to increase the productivity of existing computer programmers. Noticing similarities between software development and other engineering activities, these researchers concluded that the procedures and policies that worked for other engineering disciplines could solve the software crisis. Thus, <em>software engineering</em> was born.</p>
<p class="indent">Until the field of software engineering blossomed, software development was a mysterious craft practiced by gurus with varying abilities and accomplishments. Up to that point, a software project’s success depended entirely upon the abilities of one or two key programmers rather than those of the entire team. Software engineering sought to balance the skills of <span epub:type="pagebreak" id="page_xx"/>software teams to make them more productive and less reliant upon those one or two highly talented individuals.</p>
<p class="indent">To a large extent, the practice of software engineering has been successful. Large projects built by teams of programmers could never have been completed with the ad hoc organizational methods of the past. But at the same time, important qualities were lost. Software engineering encourages team productivity at the expense of individual creativity, skill, and growth. Although software engineering techniques have the potential to turn poor programmers into good programmers, they can also restrict great programmers from doing their best work. The world has too few great programmers. The last thing we want to do is to discourage a programmer from reaching their potential; however, this is what the software engineering regimen often does.</p>
<p class="indent">The <em>Write Great Code</em> series is an effort to restore some of that lost individual creativity, skill, and growth. It covers what I call <em>personal software engineering</em>, or how a programmer can improve the quality of their code. Specifically, it describes how you can produce great code—code that’s easy to maintain, enhance, test and debug, document, deploy, and even retire—from mediocre code. Great code is devoid of the kludges and hacks that are often the result of unreasonable pressure or ill planning on the engineer’s or management’s part. Great code is code you can be proud of.</p>
<p class="indent">As I completed <em>Write Great Code, Volume 2:</em> <em>Thinking Low-Level, Writing High-Level</em> <em>(WGC2)</em>, I had intended to incorporate more information in this book. In the last chapter of <em>WGC2</em>, I wrote the following:</p>
<p class="blockquote">[<em>Write Great Code, Volume 3: Engineering Software</em>] begins discussing the <em>personal software engineering</em> aspects of programming. The software engineering field focuses primarily on the management of large software systems. Personal software engineering, on the other hand, covers those topics germane to writing great code at a personal level—craftsmanship, art, and pride in workmanship. So, in <em>Engineering Software</em>, we’ll consider those aspects through discussions on software development metaphors, software developer metaphors, and <em>system documentation</em> [emphasis added], among other topics.</p>
<p class="indent">System documentation (including requirements, test procedures, design documents, and the like) is a huge part of software engineering. Therefore, a book on the subject must provide, at the very least, an overview of these subjects. Well, about seven chapters into this book I realized there wasn’t enough room to cover all this material in a single book. In the end, I wound up splitting this volume, <em>Engineering Software</em>, into four volumes. The first of these four volumes is this one, which is the third volume of the <em>Write Great Code</em> series. It concentrates on software development models and system documentation. The fourth volume of the series will teach software design; the fifth volume will develop the great-coding theme further; and a sixth volume will deal with testing.</p>
<p class="indent">As I write this, it’s been 10 years since I completed Volume 2 of the <em>Write Great Code</em> series. It was time to complete Volume 3, even if it meant splitting the original information across two or more volumes. If you’ve read my <span epub:type="pagebreak" id="page_xxi"/>earlier books, you know I like to cover subjects in depth; I’m not interested in writing books that barely touch on the subject matter. Thus, I was faced with either splitting the work across multiple volumes and getting them out the door or producing a 2,000-page tome that, as history has oft demonstrated, might never be completed. I apologize to those who expected this book to cover additional subjects. Fear not—the information will arrive in future volumes. You’re just getting the first part of it sooner in this book.</p>
<h3 class="h3" id="intro-01"><strong>Assumptions and Prerequisites</strong></h3>
<p class="noindent">In order to concentrate on engineering software, this book has to make certain assumptions. Although I’ve tried to keep those to a minimum, you’ll benefit most from this book if your personal skill set fulfills some prerequisites.</p>
<p class="indent">You should be reasonably competent in at least one imperative (procedural) or object-oriented programming language. This includes C and C++, C#, Swift, Pascal, BASIC, Java, and assembly. You should know how to take a small problem description and work through the design and implementation of its software solution. A typical semester or quarter course at a college or university or several months’ experience on your own should be sufficient for using this book.</p>
<p class="indent">You should also have a basic grasp of machine organization and data representation. For example, you should understand hexadecimal and binary numbering systems, and how computers represent various high-level data types, such as signed integers, characters, and strings in memory. <em>Write Great Code, Volume</em> <em>1: Understanding the Machine (WGC1)</em> fully covers machine organization if you feel your knowledge in this area is weak. Although I might refer to material in <em>WGC1</em>, you should have no problem reading this book independently of that one.</p>
<h3 class="h3" id="intro-02"><strong>What Is Great Code?</strong></h3>
<p class="noindent">Great code is software that follows a set of rules that guide the decisions a programmer makes when implementing an algorithm as source code. Great code is written with other programmers in mind—with documentation that allows others to read, comprehend, and maintain the software. I call this the <em>Golden Rule of Software Development</em>, and it holds the key to software engineering.</p>
<p class="indent">Taking things down a level, great code:</p>
<ul>
<li class="noindent">Is fast and uses the CPU, system resources, and memory efficiently</li>
<li class="noindent">Is well documented and easy to read, maintain, and enhance</li>
<li class="noindent">Follows a consistent set of style guidelines</li>
<li class="noindent">Uses an explicit design that follows established software engineering conventions</li>
<li class="noindent">Is well tested and robust</li>
<li class="noindent">Is produced on time and under budget</li>
</ul>
<p class="indent"><span epub:type="pagebreak" id="page_xxii"/>While Volumes 1 and 2 of the <em>Write Great Code</em> series deal with many of the efficiency aspects associated with great code, the remaining books in the series, starting with this one, focus specifically on creating code that meets the preceding criteria.</p>
<h3 class="h3" id="intro-03"><strong>Programmer Classifications</strong></h3>
<p class="noindent">In order to understand what makes a programmer great, let’s first consider the differences between amateurs, programmers at various levels, and software engineers.</p>
<h4 class="h4" id="intro-04"><strong><em>Amateurs</em></strong></h4>
<p class="noindent">The amateur programmer is self-taught, with only a small amount of experience, and as such is the antithesis of the great programmer. In the early days of computers, these programmers were known as <em>hackers</em>. That term has morphed into several different meanings today that don’t necessarily describe a programmer without sufficient education or experience to do professional-level software engineering.</p>
<p class="indent">The problem with code written by amateur programmers is that typically they write it for themselves or for friends; thus, it doesn’t usually adhere to contemporary standards for software engineering projects. However, amateur programmers can improve their status with a little education (which the <em>WGC</em> series can help provide).</p>
<h4 class="h4" id="intro-05"><strong><em>Programmers</em></strong></h4>
<p class="noindent">Computer programmers have a wide range of experiences and responsibilities, which is often reflected in titles like junior programmer, coder, Programmer I and II, analyst/system analyst, and system architect. Here we explore some of these roles and how they differ.</p>
<h5 class="h5" id="intro-06"><strong>Interns</strong></h5>
<p class="noindent">Typically, interns are students working part-time who are assigned so-called <em>grunt</em> <em>work</em>—tasks such as running a set of canned test procedures on the code or documenting the software.</p>
<h5 class="h5" id="intro-07"><strong>Junior Programmer</strong></h5>
<p class="noindent">Recent graduates typically fill the junior programmer position. Often, they work on testing or maintenance tasks. Rarely do they get the opportunity to work on new projects; instead, most of their programming time is spent reworking existing statements or dealing with legacy code.</p>
<h5 class="h5" id="intro-08"><strong>Coder</strong></h5>
<p class="noindent">A programmer advances to the coder level when they gain sufficient experience for management to trust them with developing new code for projects. <span epub:type="pagebreak" id="page_xxiii"/>A more senior programmer assigns (less complex) subcomponents of a larger project to the coder to help complete the project faster.</p>
<h5 class="h5" id="intro-09"><strong>Programmer I and II</strong></h5>
<p class="noindent">As a programmer gains more experience and is capable of handling complex implementation tasks on their own, they progress from coder to Programmer I and then Programmer II. A system analyst can often provide a Programmer I or II with a general idea of what they want, and the programmer is able to fill in the missing details and produce an application in line with the system analyst’s expectations.</p>
<h5 class="h5" id="intro-10"><strong>System Analyst</strong></h5>
<p class="noindent">A system analyst studies a problem and determines the best way to implement a solution. Often, the system analyst chooses the major algorithms to use and creates the final application’s organization.</p>
<h5 class="h5" id="intro-11"><strong>System Architect</strong></h5>
<p class="noindent">The system architect chooses how the components designed by a system analyst in a large-scale system will work together. Often, the system architect specifies processes, hardware, and other non-software-related items as part of the total solution.</p>
<h5 class="h5" id="intro-12"><strong>The Complete Programmer</strong></h5>
<p class="noindent">A <em>complete</em> <em>programmer</em> is the amalgamation of all these subdivisions. That is, a complete programmer is capable of studying a problem, designing a solution, implementing that solution in a programming language, and testing the result.</p>
<div class="box5">
<p class="sidebart">THE PROBLEM WITH PROGRAMMER CLASSIFICATION</p>
<p class="noindent">In reality, most of these programmer categories are artificial; they exist simply to justify a different pay scale for beginning programmers and experienced programmers. For example, a system analyst designs the algorithms and overall data flow for a particular application, then hands off the design to a coder, who implements that design in a particular programming language. We normally associate both tasks with <em>programming</em>, but junior members of the programming staff don’t have the proper experience to design large systems from scratch, although they’re perfectly capable of taking a design and converting it into an appropriate programming language. The system analysts and architects usually have the experience and ability to handle the entire project. However, management generally finds it more cost-effective to use them on those portions of the project that require their experience rather than having them do the low-level coding that a recent graduate could do (at lower cost).</p>
</div>
<h4 class="h4" id="intro-13"><span epub:type="pagebreak" id="page_xxiv"/><strong><em>Software Engineers</em></strong></h4>
<p class="noindent">In the engineering fields, engineers approach a specified problem by following a prescribed set of rules, building a custom solution from a combination of predetermined solutions. This approach allows even less talented engineers to produce working solutions without having to develop a system from scratch. Software engineering emerged as an effort to maximize the value of the entire programming team by applying traditional engineering concepts to software development. For the most part, the software engineering revolution has been successful. Software engineers with the proper training and leadership can produce high-quality code in less time and for less money than was possible before.</p>
<p class="indent">Pure software engineering discourages divergent thinking, because it risks wasting time and leading the engineer down an unsuccessful path (resulting in higher development costs and longer development times). In general, software engineering is more concerned with developing an application <em>on time and under budget</em> than with writing code the <em>best possible way</em>. But if software engineering practitioners never try anything new, they often miss opportunities to produce a great design, never develop any new practices to incorporate into their rule book, and never become great programmers.</p>
<h4 class="h4" id="intro-14"><strong><em>Great Programmers</em></strong></h4>
<p class="noindent">Great programmers are cognizant of the budgetary issues, but they also realize that exploring new ideas and methodologies is important to advance the field. They know when it’s essential to follow the rules but also when it’s okay to break (or at least bend) them. But most important of all, great programmers use their skill sets to their fullest, achieving results that wouldn’t be possible by simply thinking inside the box. Hackers are born, software engineers are made, and great programmers are a bit of both. They have three main characteristics: a genuine love for the work, ongoing education and training, and the ability to think outside the box when solving problems.</p>
<h5 class="h5" id="intro-15"><strong>Loving What You Do, Doing What You Love</strong></h5>
<p class="noindent">People tend to excel at tasks they love and do poorly on activities they dislike. The bottom line is that if you hate computer programming, you won’t make a very good computer programmer. If you weren’t born with the desire to solve problems and overcome challenges, no amount of education and training will change your disposition. Thus, the most important prerequisite to becoming a great programmer is that you really love to write computer programs.</p>
<h5 class="h5" id="intro-16"><strong>Prioritizing Education and Training</strong></h5>
<p class="noindent">Great programmers enjoy the types of tasks the field demands, but they also need something else—formal education and training. We’ll discuss education and training in greater depth in later chapters, but for now it suffices to say that great programmers are well educated (perhaps possessing a postsecondary degree) and continue their education throughout their careers.</p>
<h5 class="h5" id="intro-17"><span epub:type="pagebreak" id="page_xxv"/><strong>Thinking Outside the Box</strong></h5>
<p class="noindent">As mentioned, following a predetermined set of rules to produce code is the typical expectation of a software engineer. However, as you’ll see in <a href="ch01.xhtml">Chapter 1</a>, to become a great programmer (a “Grand Master Programmer”), you need to be willing and able to devise new programming techniques that come only from divergent thinking rather than blindly following rules. Great programmers have an innate desire to push boundaries and explore new solutions to the problems they face.</p>
<h3 class="h3" id="intro-18"><strong>So You Want to Be a Great Programmer</strong></h3>
<p class="noindent">To summarize, if you want to be a truly great programmer and inspire awe from your peers, you’ll need the following:</p>
<ul>
<li class="noindent">A love of computer programming and problem solving</li>
<li class="noindent">A wide range of computer science knowledge based on a college or university degree<sup><a href="ch19_footnote.xhtml#ch00fn1" id="ch00fn1a">1</a></sup></li>
<li class="noindent">A lifelong commitment to education and training</li>
<li class="noindent">The ability and willingness to think outside the box when exploring solutions</li>
<li class="noindent">The personal desire and motivation to excel at a task and always produce the best possible work</li>
</ul>
<p class="indent">With these attributes, the only thing keeping you from becoming a great programmer is more knowledge. That’s where this book comes in.</p>
<h3 class="h3" id="intro-19"><strong>A Final Note on Ethics and Character</strong></h3>
<p class="noindent">The software engineer’s job is to create the best possible product given conflicting requirements by making appropriate compromises in a system’s design. During this process, the engineer must prioritize requirements and choose the best solution to the problem given the project’s constraints. Ethics and personal character often impact decisions individuals make while working on complex projects, particularly stressful ones. Being intellectually dishonest (for example, fudging project estimates or claiming a piece of software works without fully testing it), pirating software development tools (or other software), introducing undocumented features in software (such as backdoors) without management approval, or adopting an elitist attitude (thinking you’re better than other team members) are all cases of software engineering ethical lapses. Exercising sound moral judgment and practicing good ethics will make you both a better person and a better programmer.</p>
<h3 class="h3" id="intro-20"><span epub:type="pagebreak" id="page_xxvi"/><strong>For More Information</strong></h3>
<p class="ref">Barger, Robert N. <em>Computer Ethics: A Case-Based Approach</em>. Cambridge, UK: Cambridge University Press, 2008.</p>
<p class="ref">Floridi, Luciano, ed. <em>The Cambridge Handbook of Information and Computer Ethics</em>. Cambridge, UK: Cambridge University Press, 2006.</p>
<p class="ref">Forester, Tom, and Perry Morrison. <em>Computer Ethics: Cautionary Tales and Ethical Dilemmas in Computing</em>. 2nd ed. Cambridge, MA: MIT Press, 1993.</p>
<p class="ref">Parker, Donn B. “Rules of Ethics in Information Processing.” <em>Communications of the ACM</em> 11, no. 3 (1968): 198–201. <em><a href="https://dl.acm.org/doi/10.1145/362929.362987">https://dl.acm.org/doi/10.1145/362929.362987</a></em>.</p>
<p class="ref">Wiener, Norbert. <em>The Human Use of Human Beings: Cybernetics and Society</em>. Boston: Houghton Mifflin Harcourt, 1950.</p>
<p class="ref">WikiWikiWeb. “Grand Master Programmer.” Last updated November 23, 2014. <em><a href="http://c2.com/cgi/wiki?GrandMasterProgrammer/">http://c2.com/cgi/wiki?GrandMasterProgrammer/</a></em>.</p>
</div>



  </body></html>