- en: '**8**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8**'
- en: '**FUNCTIONS GIVE YOU SUPERPOWERS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数赋予你超能力**'
- en: '![image](graphics/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common01.jpg)'
- en: Functions are reusable blocks of code that perform specific tasks. Say you want
    to write code that builds a tree in Minecraft. You could rewrite the tree-building
    code every time you need to use it in your program (or copy and paste it); however,
    this would be inefficient, especially if you wanted to change it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是可重用的代码块，执行特定的任务。假设你想写一段代码在 Minecraft 中构建一棵树。你可以在每次需要使用时重新编写构建树的代码（或复制粘贴）；然而，这样做效率低下，尤其是在你需要修改代码时。
- en: 'Instead of copying and pasting, you could write the tree-building code as a
    *function*. Recall that we used some functions in earlier chapters: `str()`, `input()`,
    and `int()`. They’re all functions that are built into Python. You’ve even been
    using Minecraft functions, such as the `getBlocks()` and `setPos()` functions,
    which come with the Minecraft Python API. In this chapter, you’ll create your
    *own* functions.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与其复制粘贴代码，你可以将构建树的代码写成一个*函数*。回想一下，我们在前面的章节中使用了一些函数：`str()`、`input()` 和 `int()`。它们都是
    Python 内置的函数。你甚至已经在使用 Minecraft 函数，比如 `getBlocks()` 和 `setPos()` 函数，它们是随 Minecraft
    Python API 提供的。在本章中，你将创建你*自己的*函数。
- en: 'You create and use functions for the following reasons:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建并使用函数的原因如下：
- en: '**Reusability** Functions save time. Because you don’t have to rewrite the
    same code over and over again, writing a program is faster and easier.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**可重用性** 函数节省时间。因为你不需要一次又一次地重写相同的代码，编写程序变得更快也更容易。'
- en: '**Debugging** By containing tasks in groups of code, it is easier to identify
    where a problem originates and make changes to fix the problem.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试** 通过将任务分组到代码块中，能够更容易地识别问题的来源并进行修改来修复问题。'
- en: '**Modularity** You can develop different functions to use in the same program
    independently of one another. This makes it easier to share code with other people
    and reuse functions in other programs.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块化** 你可以在同一个程序中独立开发不同的功能。这样可以更方便地与他人共享代码，并在其他程序中重用功能。'
- en: '**Scalability** Using functions makes it easier to increase the size of a program
    and the amount of data it processes.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展性** 使用函数可以更容易地增加程序的规模和它处理的数据量。'
- en: '**DEFINING YOUR OWN FUNCTIONS**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**定义你自己的函数**'
- en: 'Let’s look at how you can use functions in your code. In the following example,
    I make a function called `greeting()` that simply prints two lines:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何在代码中使用函数。在下面的例子中，我创建了一个名为 `greeting()` 的函数，它只是简单地打印两行：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `def` keyword, which is an abbreviation for *define*, tells Python you’re
    writing a function. Anytime you want to write a function, you must first write
    `def` followed by the function’s name. In this example, `greeting` is the name
    of the function. Don’t forget to add the parentheses and the colon at the end
    of the first line. The lines that follow the colon are the *body* of the function,
    which is the code that will run when the function is called.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`def` 关键字是 *define* 的缩写，告诉 Python 你正在编写一个函数。每当你想编写一个函数时，必须先写 `def`，然后是函数的名称。在这个例子中，`greeting`
    是函数的名称。不要忘记在第一行末尾加上括号和冒号。冒号后面的代码行是函数的*主体*，也就是在调用函数时执行的代码。'
- en: '**NOTE**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Keep indentation consistent in your code. Always indent the body of the function
    by using four spaces.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*保持代码缩进的一致性。始终使用四个空格缩进函数体。*'
- en: A function can contain as many statements as you want. It can also include `if`
    statements, loops, variables, conditions, math operators, and so on. When you
    reach the end of the function code, stop indenting lines so Python knows which
    statements belong to the function and which statements belong to other parts of
    your code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以包含任意多的语句。它还可以包括 `if` 语句、循环、变量、条件、数学运算符等等。当你到达函数代码的结尾时，停止缩进代码行，这样 Python
    就知道哪些语句属于函数，哪些语句属于代码的其他部分。
- en: You can create as many functions as you want in a program, as long as they have
    different names.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个程序中创建任意多个函数，只要它们的名称不同。
- en: '**CALLING A FUNCTION**'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**调用函数**'
- en: To use, or *call*, a function, you write the name of the function with any arguments
    it might require in parentheses. If your function doesn’t take any arguments,
    just write the function’s name and a set of empty parentheses.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用或*调用*一个函数，你需要在括号中写出函数的名称及其可能需要的任何参数。如果你的函数不需要任何参数，只需写出函数名称和一对空括号。
- en: 'To call the `greeting()` function defined earlier, you would use the following
    code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用之前定义的 `greeting()` 函数，你可以使用以下代码：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can call the function as many times as you want. Let’s call the `greeting()`
    function three times:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要调用这个函数多次。让我们调用`greeting()`函数三次：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you run the program, it should produce the output of the function three
    times, like so:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，它应该会产生函数的输出三次，如下所示：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You must call the function in the body of your code, or the function will not
    do anything. This is a common mistake. If you run a program that defines some
    functions and your code doesn’t do anything, it might be because you forgot to
    call the functions you created.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在代码的主体中调用这个函数，否则函数不会做任何事情。这是一个常见的错误。如果你运行一个定义了函数的程序，但代码没有任何反应，那可能是因为你忘记调用你创建的函数。
- en: You can also call functions from within another function that you’ve created.
    These include built-in Python functions as well as those you’ve created. You’ll
    see this in action in just a moment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在另一个你创建的函数中调用函数。这些函数包括内置的Python函数，以及你自己创建的函数。你稍后会看到这个功能的实际应用。
- en: '**FUNCTIONS TAKE ARGUMENTS**'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**函数接受参数**'
- en: The parentheses in a function contain its arguments, which are values the function
    uses. The values are used for specific variables inside the function when it runs.
    Not every function needs arguments. For example, the `greeting()` function doesn’t
    take arguments.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中的括号包含它的参数，这些是函数在运行时使用的值。这些值会在函数内部用于特定的变量。并不是每个函数都需要参数。例如，`greeting()`函数不接受参数。
- en: 'But let’s say I want to display a greeting to someone using their name. I’ll
    write this as a function so I can reuse the code to greet different people:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想要用某人的名字展示一个问候。我将把它写成一个函数，这样我就可以重用这段代码来向不同的人问好：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this example, function is called twice using different arguments, `"Mario"`
    and `"Steve"`. When you run the program, the output looks like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，函数被使用了两次，传入不同的参数，分别是`"Mario"`和`"Steve"`。当你运行程序时，输出如下所示：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you forget to include an argument when you call a function that needs one,
    you will get an error. Also, if a function needs multiple arguments and you forget
    to include even one of them, you will get an error. For example, let’s try calling
    the `fancyGreeting()` function with no arguments, like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在调用一个需要参数的函数时忘记提供参数，你会得到一个错误。同样，如果一个函数需要多个参数，而你忘记提供其中任何一个，你也会得到错误。例如，让我们尝试调用`fancyGreeting()`函数时没有提供任何参数，像这样：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following error message is displayed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 会显示以下错误信息：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a useful error message because the last line explains what is wrong
    with the code ➊. The `fancyGreeting()` function takes one argument, but because
    it was given no argument, that caused the error.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的错误信息，因为最后一行解释了代码出错的原因 ➊。`fancyGreeting()`函数接受一个参数，但因为没有提供参数，导致了这个错误。
- en: 'You can create a function that takes several arguments. For example, the following
    program contains a function that says hello to someone, waits a number of seconds,
    and then says goodbye. The function uses an argument for the person’s name and
    the number of seconds the program will wait:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个接受多个参数的函数。例如，下面的程序包含一个函数，能够向某人打招呼，等待一段时间，然后说再见。该函数使用一个参数来表示人的名字和程序将等待的秒数：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each argument is separated by a comma when the function is defined ➊. Then,
    when the functions are called, the arguments are passed in the same order in which
    they were defined ➋.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参数在定义函数时由逗号分隔 ➊。然后，当函数被调用时，参数会按定义时的顺序传入 ➋。
- en: '**NOTE**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You might encounter the terms* argument *and* parameter *used almost interchangeably.
    The parameters of a function define the types of arguments it accepts or requires,
    and the arguments are the values that you pass to the function when you call it.
    For simplicity, we’ll just use the term* argument *in this book.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能会遇到*参数 *和*参数值 *这两个术语几乎可以互换使用。函数的参数定义了它接受或需要的参数类型，而参数值是你在调用函数时传递给它的值。为了简便起见，本书中我们将只使用*参数
    *这个术语。*'
- en: '**MISSION #41: BUILD A FOREST**'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #41：建立一个森林**'
- en: Your mission is to create a forest of trees in Minecraft. Because a forest is
    just a bunch of trees, we’ll create the forest by making a function that builds
    one tree and then call that function many times to create a forest.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是创建一个Minecraft中的森林。因为森林其实就是一堆树，所以我们将通过创建一个构建单棵树的函数，然后多次调用这个函数来创建森林。
- en: '[Listing 8-1](ch08.html#ch8ex1) is the basic code you’ll be using.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-1](ch08.html#ch8ex1)是你将使用的基础代码。'
- en: '*forest.py*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*forest.py*'
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 8-1: The structure of a program that uses functions to create a forest
    of trees*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The `growTree()` function ➊ created in this code takes arguments for the coordinates
    where the tree will be built. Your task is to write code in the body of the function
    that creates a tree at the given coordinates. You’ll use the `setBlock()` and
    `setBlocks()` functions to do this.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Copy [Listing 8-1](ch08.html#ch8ex1) into a new file in IDLE and save it as
    *forest.py* in a new folder called *functions*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve created something that resembles a tree and it appears onscreen,
    try writing more calls to the function using different arguments so trees appear
    at different locations. The first one has been done for you ➋. Try creating at
    least nine trees in front of the player each time you run your program. [Figure
    8-1](ch08.html#ch8fig1) shows the trees that my program created.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: I’ve just grown a beautiful row of trees.*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '**BONUS OBJECTIVE: RANDOM FOREST**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Use the `randint()` function in the `random` module to randomize the distance
    between the trees in the forest.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '**REFACTORING A PROGRAM**'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Quite often you’ll write a program that uses the same block of code several
    times. Making changes to the program will become tedious when you want to change
    the same code in different places. You might have done this in programs you’ve
    written in the past, but there’s a much better way.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: You can restructure your programs to use functions. To do this, move the code
    that is repeated several times into a single function that you can then use as
    many times as you want in the rest of the code. Because you’ll only need to make
    changes in one place instead of several, you’ll save space and the program will
    be easier to maintain. The process of restructuring your code in this way is called
    *refactoring*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code asks three people their names and then prints
    a greeting to each of them:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code here repeats the same two statements three times. What if you wanted
    to change the question or the greeting? It’s not much of a problem changing the
    code for 3 people, but what if you were writing code for 100 people?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative is to write the code as a function and call it three times.
    Here is the code after refactoring it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now when the program runs, it will ask for input and then output a string,
    and it will do both tasks three times. Here are the input and output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The second version of the code has the same outcome as the first version, but
    as you can see, it’s much easier to read and much easier to change.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #42: REFACTOR AWAY**'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes you’ll write a program only to realize afterward that you should have
    used functions (I do this all the time). Refactoring code to include functions
    is a very important skill.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: In this mission, you’ll practice refactoring a program to use a function instead
    of repeating the same statements several times.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-2](ch08.html#ch8ex2) places a melon block underneath the player
    every 10 seconds. We’ll rewrite the code to use a function. Currently, the program
    places three blocks by using the same line of code three times. [Figure 8-2](ch08.html#ch8fig2)
    shows the result of the program.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-2](ch08.html#ch8ex2)每10秒在玩家下方放置一个甜瓜方块。我们将重写代码，使用函数。目前，程序通过同一行代码重复三次来放置三个方块。[图
    8-2](ch08.html#ch8fig2)展示了程序的结果。'
- en: '*melonFunction.py*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*melonFunction.py*'
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 8-2: Some code that needs refactoring*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-2：需要重构的代码*'
- en: This code isn’t very pretty, is it? Several lines are repeated, which is always
    a sign that the code needs refactoring with the help of a function definition.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不太好看，是吧？有几行是重复的，这总是表明代码需要通过函数定义来重构。
- en: '**HINT**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '*Identify which parts of the code repeat to get an idea of what your function
    should do.*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*识别出代码中重复的部分，以便了解你的函数应该做什么。*'
- en: '![image](graphics/f08-02.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-02.jpg)'
- en: '*Figure 8-2: Three delicious melons under the ground*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：地下的三颗美味的甜瓜*'
- en: Change the code so it places six blocks in total by calling your function six
    times. Create a new file and save it as *melonFunction.py* in the *functions*
    folder. Copy [Listing 8-2](ch08.html#ch8ex2) into your file and refactor the code
    to use a function. Call the new function `makeMelon()`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 修改代码，使其总共放置六个方块，通过调用你的函数六次来实现。创建一个新文件并将其保存为*melonFunction.py*，放入*functions*文件夹中。将[列表
    8-2](ch08.html#ch8ex2)复制到文件中，并重构代码以使用函数。将新函数命名为`makeMelon()`。
- en: '**BONUS OBJECTIVE: BLOCKS UNDERFOOT**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加目标：脚下的方块**'
- en: Add arguments to your `makeMelon()` function to control the type of block, sleep
    time, or distance below the player.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 向`makeMelon()`函数添加参数，以控制方块的类型、休眠时间或玩家下方的距离。
- en: '**COMMENTING WITH DOCSTRINGS**'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用文档字符串进行注释**'
- en: Using comments in Python code is a way to explain what code does. When Python
    runs a program, it ignores everything in a comment, so comments don’t affect how
    the code runs. The main purpose of comments is to explain what your code is supposed
    to do to others who might look at or use your code. Comments are also useful reminders
    for yourself in the future.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python代码中使用注释是解释代码功能的一种方式。当Python运行程序时，它会忽略注释中的所有内容，因此注释不会影响代码的运行。注释的主要目的是向其他可能查看或使用你代码的人解释你的代码应该做什么。注释也是你自己未来的有用提醒。
- en: Because functions are supposed to be reusable, it makes sense to explain their
    purpose. To write explanations for our functions, we’ll use long explanations
    called *docstrings*. A docstring is a multiline comment that you place at the
    start of a function to explain its use.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数应该是可重用的，因此解释它们的目的非常重要。为了编写我们的函数解释，我们将使用长注释，这就是所谓的*文档字符串*。文档字符串是放置在函数开始处的多行注释，用于解释函数的用途。
- en: 'The `duplicateWord()` function in the following example has a docstring that
    explains its task:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例中的`duplicateWord()`函数有一个文档字符串，解释了它的任务：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The docstring should be on the first line of a function ➊. The docstring begins
    and ends with a set of three quotation marks (`"""`) and can be written across
    as many lines as necessary.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的文档字符串应该位于函数的第一行 ➊。文档字符串以三重引号（`"""`）开始和结束，可以跨多行书写，视需要而定。
- en: '**LINE BREAKS IN ARGUMENTS**'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**参数中的换行符**'
- en: 'To make long lists of arguments easier for programmers to read, Python allows
    you to place arguments across several lines. For example, the function call in
    this program has its arguments split across several lines to increase readability:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让程序员更容易阅读长参数列表，Python允许你将参数拆分成多行。例如，程序中的函数调用将参数拆分成多行，以提高可读性：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Line breaks in arguments are particularly useful when you want to use math operators
    on arguments, when you are using long variable names as arguments, or when you
    have several arguments to provide to a function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数中使用换行符特别有用，当你想在参数上使用数学运算符时，或者当你使用长变量名作为参数，或者当你有多个参数要传递给一个函数时。
- en: '**FUNCTION RETURN VALUES**'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**函数返回值**'
- en: 'There are two types of functions: those that return a value and those that
    don’t. So far, you’ve created functions that don’t return a value. Let’s look
    at those that do return a value.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有两种类型：一种是返回值的，另一种是没有返回值的。到目前为止，你创建的函数都是没有返回值的。现在让我们来看一下返回值的函数。
- en: Returning a value from a function is very useful, because it allows a function
    to work with data and then return a value to the main body of the program. For
    example, imagine you sell cookies. To calculate the price you have to sell each
    cookie at to make enough profit, you add two gold coins to the amount you paid
    to make the cookie and then multiply the sum by 10\. By using a function that
    returns a value, you can write this calculation and reuse it in Python.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数返回一个值非常有用，因为它允许函数处理数据并将值返回给程序的主体。例如，假设你在卖饼干。为了计算每个饼干的售价以赚取足够的利润，你需要在你支付的饼干成本基础上加上两枚金币，然后将总和乘以
    10。通过使用一个返回值的函数，你可以编写这个计算并在 Python 中重用它。
- en: 'When making your own functions, you can use the `return` keyword to return
    a value from the function. For example, here is the code to calculate your selling
    price for a cookie:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写你自己的函数时，你可以使用`return`关键字从函数返回一个值。例如，这里是计算饼干售价的代码：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To return a value, you just write `return` followed by the value you want,
    which in this case is `price`. To use a function that returns a value, you call
    it in a place that would expect a value. For example, to set the `priceOfCookie`
    variable, call the `calculateCookiePrice()` function and enter a cost, such as
    `6`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回一个值，你只需写`return`后跟你想要的值，在这个例子中是`price`。要使用返回值的函数，你需要在期望值的地方调用它。例如，要设置`priceOfCookie`变量，调用`calculateCookiePrice()`函数并输入一个费用，比如`6`：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can use functions that return values to set the values of variables, and
    you can use them anywhere that you are expected to put a value, even as an argument
    for another function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用返回值的函数来设置变量的值，并且可以在任何需要值的地方使用它们，甚至作为另一个函数的参数。
- en: Functions that do not return a value cannot be used to set the values of variables.
    Let’s take a quick look at the difference.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不返回值的函数不能用来设置变量的值。让我们快速看一下它们之间的区别。
- en: 'Because the following function returns a value, it can be used anywhere a value
    can be used, such as to set a variable or even as an argument in another function
    call:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因为下面的函数会返回一个值，它可以在任何可以使用值的地方使用，比如设置变量，甚至作为另一个函数调用的参数：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run this code to see its output. You can treat the result from the function
    like a value and even do math with it. Here I add 4 to the returned value and
    store it in a variable called `extraChickens`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码来查看它的输出。你可以像对待一个值一样处理函数的返回结果，甚至对其进行数学运算。在这里，我将返回的值加上 4，并将其存储在一个名为`extraChickens`的变量中：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However, the following function doesn’t have a `return` statement, which means
    you can’t use it in place of a value. All you can do is call the function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，下面的函数没有`return`语句，这意味着你不能将它用作值。你只能调用该函数：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Writing this code in the text editor and running it prints `"Cluck"`, although
    it can’t be used in other statements because it doesn’t return a value to the
    program. For example, I could try to concatenate the function with a string, like
    so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中编写这段代码并运行它会打印`"Cluck"`，尽管它不能在其他语句中使用，因为它没有返回值给程序。例如，我可以尝试将函数与字符串连接，像这样：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If I ran this program, I would get the following error message:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我运行这个程序，我将得到以下错误信息：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This error means you can’t combine this function with a string, because the
    function doesn’t return a value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误意味着你不能将此函数与字符串组合使用，因为该函数不返回值。
- en: 'However, if I change the code to return a value instead of just printing it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我将代码更改为返回一个值，而不是仅仅打印它：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'the file would run and display the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 文件会运行并显示以下输出：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Keep this difference in mind. Remember to include a `return` statement when
    you need it and exclude it when your function doesn’t need to return a value.
    The more experienced you become with functions, the easier it will be to decide
    whether you want your function to return a value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这个区别。当你需要时，记得包含`return`语句，当你的函数不需要返回值时，省略它。随着你在函数方面经验的积累，决定是否让你的函数返回一个值会变得更加容易。
- en: '**MISSION #43: BLOCK ID REMINDER**'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #43：块 ID 提醒**'
- en: Because Minecraft has so many blocks, it’s difficult to remember all the block
    IDs. I always remember the melon (103) and air (0) values but forget others, so
    I keep having to build houses out of melons!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Minecraft 有这么多块，所以很难记住所有的块 ID。我总是记得西瓜（103）和空气（0）的值，但忘记了其他的，所以我总是不得不用西瓜来建造房子！
- en: To make remembering easier, I want you to create a program for me that returns
    the values of different blocks. Your program should have many functions that help
    me remember block IDs. The name of each function should be the same as the name
    of the block whose value it returns. For example, [Listing 8-3](ch08.html#ch8ex3)
    has a function called `melon()` that returns the value of the melon block (103).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易记住，我希望你为我创建一个程序，返回不同方块的值。你的程序应该有多个函数，帮助我记住方块ID。每个函数的名称应该和它返回的方块的名称相同。例如，[列表8-3](ch08.html#ch8ex3)中有一个名为`melon()`的函数，它返回西瓜方块的值（103）。
- en: '*blockIds.py*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*blockIds.py*'
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 8-3: The start of the program that will help me remember block IDs*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表8-3：帮助我记住方块ID的程序起始部分*'
- en: 'Create a new file in IDLE and save it as *blockIds.py* in the *functions* folder.
    Copy [Listing 8-3](ch08.html#ch8ex3) into the file and add functions to it that
    return the values of the following blocks (see “[Block ID Cheat Sheet](app02.html#app02)”
    on [page 283](app01.html#page_283)):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDLE中创建一个新文件，并将其保存为*blockIds.py*，放在*functions*文件夹中。将[列表8-3](ch08.html#ch8ex3)的代码复制到该文件中，并为它添加返回以下方块值的函数（参见[方块ID备忘单](app02.html#app02)，在[第283页](app01.html#page_283)）：
- en: • Water
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: • 水
- en: • Wool
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: • 羊毛
- en: • Lava
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: • 熔岩
- en: • TNT
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: • TNT
- en: • Flower
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: • 花
- en: • Diamond block
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: • 钻石方块
- en: 'After you’ve added your functions, test them by calling the functions to create
    blocks. Because your new functions return a block’s value, you can use them to
    set the value of a variable to pass into the `setBlock()` function. The following
    code will help you get started:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了你的函数后，通过调用这些函数来创建方块进行测试。由于你的新函数返回方块的值，你可以使用它们来设置变量的值，并将其传递给`setBlock()`函数。以下代码将帮助你开始：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Figure 8-3](ch08.html#ch8fig3) shows the result of the completed program with
    a test for the `melon()` function. Notice that the placement of any block is hardcoded
    into this program; it will always place a block at your current location.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-3](ch08.html#ch8fig3)展示了完整程序的结果，其中包括对`melon()`函数的测试。注意，任何方块的位置都被硬编码到这个程序中；它总是将方块放置在你当前的位置。'
- en: '![image](graphics/f08-03.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-03.jpg)'
- en: '*Figure 8-3: Now I don’t have to remember the block types, all thanks to this
    handy function.*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-3：现在我不需要记住方块类型，这全要归功于这个方便的函数。*'
- en: '**HINT**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '*To place a diamond block, TNT, or any other kind of block, you’ll first need
    to define the function that returns the value of the block you want. Then you’ll
    need to call that function in your code, just like I called the* `melon()` *function
    in this example.*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*要放置一个钻石方块、TNT或任何其他类型的方块，你首先需要定义一个返回所需方块值的函数。然后你需要在代码中调用该函数，就像我在这个例子中调用`melon()`函数一样。*'
- en: '**BONUS OBJECTIVE: MORE BLOCKS**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加目标：更多方块**'
- en: Add extra functions for any other block types that you want.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为你想要的任何其他方块类型添加额外的函数。
- en: '**USING IF STATEMENTS AND WHILE LOOPS IN FUNCTIONS**'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在函数中使用IF语句和WHILE循环**'
- en: In [Chapters 6](ch06.html#ch06) and [7](ch07.html#ch07), you learned about putting
    `if` statements inside of other `if` statements and `while` loops inside of other
    `while` loops. You learned that you can even put `if` statements within `while`
    loops and vice versa! In this section, you’ll learn how to put `if` statements
    and loops inside functions. This makes your functions very flexible, because you
    can use them to make decisions and repeat code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html#ch06)和[第7章](ch07.html#ch07)中，你学到了如何将`if`语句嵌套在其他`if`语句中，以及将`while`循环嵌套在其他`while`循环中。你还学到了如何将`if`语句放入`while`循环中，反之亦然！在本节中，你将学习如何将`if`语句和循环放入函数中。这样可以使你的函数非常灵活，因为你可以用它们做决策并重复代码。
- en: '**IF STATEMENTS**'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**IF语句**'
- en: When you’re writing an `if` statement within a function, the syntax is identical
    to that of a regular `if` statement. You just need to remember to indent the `if`
    statement by an extra four spaces at the start of every line so Python knows it’s
    part of the function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在函数中编写`if`语句时，语法与常规`if`语句相同。你只需要记住，在每行的开始缩进四个额外的空格，以便Python知道它是函数的一部分。
- en: 'The following code takes a number written as a string and returns the number
    as an integer. For example, the argument `"four"` returns the value `4`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将一个以字符串形式书写的数字转换为整数。例如，参数`"four"`将返回值`4`：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s look at another example. The following function checks whether you’ve
    met a person before and uses an appropriate greeting depending on the result:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。以下函数检查你是否曾经遇到过某个人，并根据结果使用适当的问候语：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `chooseGreeting()` function takes one Boolean argument, called `metBefore`
    ➊. The `if` statement inside the function then prints output based on the value
    of the argument. If the value is `True`, the output will be `"Nice to see you
    again"` ➋, and if it is `False` ➌, the output will be `"Nice to meet you"`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`chooseGreeting()`函数接受一个布尔值参数，名为`metBefore`➊。函数中的`if`语句根据该参数的值打印输出。如果值为`True`，输出为`"很高兴再次见到你"`➋；如果值为`False`➌，输出为`"很高兴认识你"`。'
- en: '**MISSION #44: WOOL COLOR HELPER**'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #44：羊毛颜色助手**'
- en: You’ve used the `setBlock()` and `setBlocks()` methods with arguments to set
    block coordinates and block type, but these methods also have an optional extra
    argument that will set the block *state*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用过`setBlock()`和`setBlocks()`方法，带有参数来设置方块坐标和方块类型，但这些方法还可以接受一个可选的额外参数，用来设置方块的*状态*。
- en: Each block in Minecraft has 16 states, 0 to 15\. Wool, for example, has a different
    color for every state. TNT (block ID 46) won’t explode when you smash the block
    in its default state (state 0), but it is explosive when you smash it in block
    state 1\. Although every block has 16 states, not all of them have different behaviors.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Minecraft中的每个方块都有16种状态，从0到15。例如，羊毛每个状态都有不同的颜色。TNT（方块ID 46）在默认状态（状态0）下不会爆炸，但在方块状态1下被击碎时会爆炸。尽管每个方块都有16个状态，但并不是所有的状态都有不同的行为。
- en: 'To set a block’s state, you provide the `setblock()` or `setblocks()` function
    with an extra argument. The following code creates a pink block of wool:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置方块的状态，你需要为`setblock()`或`setblocks()`函数提供一个额外的参数。以下代码创建了一个粉色羊毛方块：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Wool (block ID 35) has many uses in Minecraft due to its different colors, but
    it’s difficult to remember the different block states. Fortunately, you don’t
    need to memorize the different block states when you can use a program to remind
    you.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 羊毛（方块ID 35）在Minecraft中有许多用途，因其不同的颜色而变得非常有用，但记住不同方块状态的颜色却很困难。幸运的是，你不需要记住不同的方块状态，因为你可以使用程序来提醒你。
- en: Let’s make a program that contains the wool block’s states. The program will
    contain a function with an argument that takes the color you want written as a
    string. The function then returns the block state for the wool color as an integer.
    The function will contain the bulk of the code for the program. However, you’ll
    add a couple of code lines to take input from a user and place the block in the
    game, and you’ll use your fancy new function to set the color.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制作一个包含羊毛方块状态的程序。这个程序将包含一个带有参数的函数，参数是你想要的颜色，作为字符串传入。然后，函数返回该羊毛颜色对应的方块状态整数。该函数将包含程序的大部分代码。但是，你需要再添加几行代码来获取用户输入并在游戏中放置方块，同时使用你刚创建的函数来设置颜色。
- en: 'First, you’ll need to find out the block states for the different colors of
    wool. You can find them in the “[Block ID Cheat Sheet](app02.html#app02)” on [page
    283](app01.html#page_283). Here’s some code to get you started (pink is block
    state 6):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要找出不同颜色羊毛的方块状态。你可以在[《方块ID备忘单》](app02.html#app02)的[第283页](app01.html#page_283)找到它们。下面是一些可以帮助你入门的代码（粉色的方块状态是6）：
- en: '*woolColors.py*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*woolColors.py*'
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At the moment, the program has just the beginnings of the `getWoolState()` function.
    It only has an `if` statement for the color pink ➊. Also included is code at the
    end of the program to take user input for the block color ➋ and code to place
    the wool block at the player’s position ➌.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，程序只包含了`getWoolState()`函数的初步代码。它仅包含一个针对粉色的`if`语句➊。程序的结尾还包括了用于接收用户输入方块颜色的代码➋，以及用于在玩家位置放置羊毛方块的代码➌。
- en: Add to the `getWoolState()` function using `elif` statements for other wool
    colors and their corresponding block states. The program should take an argument
    for the color of the block and return the integer value of the block state. For
    example, providing the argument `"pink"` will return the value 6\. You’ll also
    need to add a `return` statement to the program. Use the comments to guide you.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`elif`语句为`getWoolState()`函数添加其他羊毛颜色及其对应的方块状态。程序应接受一个表示方块颜色的参数，并返回该方块状态的整数值。例如，提供参数`"pink"`将返回值6。你还需要在程序中添加一个`return`语句。使用注释来指导你。
- en: Save the file as *woolColors.py* in the *functions* folder.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存为`*woolColors.py*`，并放入`*functions*`文件夹中。
- en: If you want to make the program more user friendly, you can post a message to
    chat if the argument is not a valid color. [Figure 8-4](ch08.html#ch8fig4) shows
    the input in the Python shell and the wool block being placed in the game.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让程序更加友好，你可以在颜色参数无效时向聊天发送消息。[图8-4](ch08.html#ch8fig4)展示了Python Shell中的输入及羊毛方块在游戏中被放置的情况。
- en: '![image](graphics/f08-04.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-04.jpg)'
- en: '*Figure 8-4: Now I can create a wool block in any color by entering the name
    of the color I want.*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：现在我可以通过输入我想要的颜色名称来创建任何颜色的羊毛方块。*'
- en: '**WHILE LOOPS**'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**while 循环**'
- en: Just like `if` statements, loops can be written inside functions. The syntax
    for a loop inside a function is the same as that for a regular loop. You just
    need to remember that the loop should be indented by an extra four spaces on each
    line to indicate that it belongs to the function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`if`语句一样，循环也可以写在函数内部。函数内部的循环语法与常规循环相同。你只需要记住，循环的每一行都应缩进四个空格，以表明它属于函数。
- en: In the following example, the `while` loop within the function will print the
    `toPrint` argument. The number of times the loop repeats is determined by the
    `repeats` argument.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，函数中的`while`循环将打印`toPrint`参数。循环重复的次数由`repeats`参数决定。
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also use `return` statements and `while` loops in the same function.
    In most cases, you’ll want the `return` statement to be outside the loop. (If
    you use the `return` statement inside a loop, it will break the loop and end the
    function.) Let’s look at an example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在同一个函数中使用`return`语句和`while`循环。在大多数情况下，你会希望`return`语句位于循环外部。（如果你在循环内部使用`return`语句，它会终止循环并结束函数。）让我们来看一个例子：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This program doubles a number until it is greater than 100\. It then returns
    the number of times the loop repeated ➊.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将一个数字翻倍，直到它大于100。然后它返回循环重复的次数➊。
- en: You can also put function calls within loops, as you did in previous chapters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以像在前几章中一样将函数调用放入循环中。
- en: '**MISSION #45: BLOCKS, EVERYWHERE**'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #45：方块，无处不在**'
- en: By using loops inside functions, you can use an argument to determine the number
    of times a loop repeats. By using the `setBlock()` function, you can also determine
    the type of block to be placed within the loop.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在函数内部使用循环，你可以通过一个参数来确定循环的重复次数。通过使用`setBlock()`函数，你还可以在循环内确定要放置的方块类型。
- en: '**WARNING**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*The program in this mission could be destructive, so you might want to try
    it in a new world to preserve your precious creations.*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*本任务中的程序可能会具有破坏性，因此你可能想在新世界中尝试它，以保留你宝贵的创作。*'
- en: In this mission, you’ll create a function that places blocks randomly around
    the map. The number of blocks it places and the block type it places are determined
    by function arguments.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本任务中，你将创建一个函数，随机地在地图上放置方块。它放置的方块数量和类型由函数参数决定。
- en: '[Listing 8-4](ch08.html#ch8ex4) generates a melon at a random location on the
    map.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-4](ch08.html#ch8ex4)会在地图上随机位置生成一个西瓜。'
- en: '*blocksEverywhere.py*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*blocksEverywhere.py*'
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 8-4: When called, this function will place a block randomly in the
    game.*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-4：当调用时，此函数将在游戏中随机放置一个方块。*'
- en: Copy [Listing 8-4](ch08.html#ch8ex4) into a new file in IDLE and save it as
    *blocksEverywhere.py* in the *functions* folder. At ➋, add a `while` loop inside
    the function so the code repeats. The `count` variable ➊ makes it easier for you
    to tell how many times the loop has repeated. Compare the `repeats` argument to
    the `count` variable in the loop’s condition to set how many times the loop should
    repeat. Indent all the lines inside the function after ➋ so they are also inside
    the loop. The `getHeight()` function ensures that the block is placed above the
    ground ➌.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将[示例 8-4](ch08.html#ch8ex4)复制到IDLE中的新文件，并将其保存在*functions*文件夹中的*blocksEverywhere.py*文件中。在➋处，在函数内部添加一个`while`循环，以便代码可以重复执行。`count`变量➊可以帮助你知道循环已重复多少次。将`repeats`参数与循环条件中的`count`变量进行比较，设置循环重复的次数。将➋之后函数内部的所有行缩进，使它们也在循环内部。`getHeight()`函数确保方块位于地面之上➌。
- en: Finally, add three function calls to create blocks. The first function should
    create 10 blocks, the second one should create 37 blocks, and the third should
    create 102 blocks. Choose any block types that you want.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加三个函数调用来创建方块。第一个函数应该创建10个方块，第二个创建37个方块，第三个创建102个方块。你可以选择任何你喜欢的方块类型。
- en: Save the program and run it. The program should create blocks randomly around
    the map. [Figure 8-5](ch08.html#ch8fig5) shows an example.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 保存程序并运行它。程序应该会在地图上随机生成方块。[图 8-5](ch08.html#ch8fig5)展示了一个示例。
- en: '![image](graphics/f08-05.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f08-05.jpg)'
- en: '*Figure 8-5: You can see some of the blocks that the program has placed randomly.
    I created a new world to demonstrate this program so it didn’t damage any of my
    buildings.*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-5：你可以看到程序随机放置的一些方块。我创建了一个新世界来演示这个程序，以免破坏我的建筑物。*'
- en: '**GLOBAL AND LOCAL VARIABLES**'
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**全局变量和局部变量**'
- en: 'When you’re defining functions, you have a new challenge to deal with, namely
    the scope of a variable. The *scope* of a variable describes how your program
    can access its data. The best way to learn about scope is to see it in action,
    so let’s look at some code. Let’s say you’re using the following code, which increases
    the number of eggs you have for a party:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Two variables are named `eggs`, one outside the function ➊ and another inside
    the function ➋. Nothing looks terribly wrong, but Python will throw an error.
    Here’s part of the error message:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The problem is that the `eggs` variable is defined outside the function, but
    when you try to add to it inside the function, Python can’t see the variable.
    To Python, the variable inside the function is totally different from the one
    outside the function, even though they have the same name. Python does this on
    purpose to stop variables inside different functions from accidentally sharing
    the same names and causing unexpected bugs.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python code, you have two ways to approach the variables in a file: you
    can either make a variable *global*, which means it affects an entire program
    or file, or make a variable *local*, which means it can be seen only by the code
    in a particular function or loop. In other words, you can use the same variable
    inside and outside a function, or you can make two different variables that affect
    different parts of the code.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'A *global* variable will be treated as the same variable inside and outside
    a function. Any changes to the variable inside the function will affect the variable
    that was defined outside the function and vice versa. To make a global variable,
    use the `global` keyword ➊:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, the value of `eggs` will be 13 when it is printed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'You can treat the variable as a *local* variable instead to produce a different
    effect. In this case, the variables inside and outside the function will be treated
    as different variables. Changes to the variable inside the function will not affect
    the variable outside the function and vice versa. So you could change the code
    to make the variable a local variable ➊, like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When the value of `eggs` in the function is printed ➋, it will be 1 because
    the value of the `eggs` variable outside the function does not affect the local
    variable inside the function. The value of `eggs` inside the `increaseEggs()`
    function is 1, and the global `eggs` variable still has the value of 12 ➌.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #46: A MOVING BLOCK**'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A while ago, I thought it would be cool to make a block move around the Minecraft
    world by itself. Every second it would move forward. If it hit a wall, a tree,
    or something tall, it would turn and make its way in a different direction. If
    it fell in a hole, however, it would get stuck and wouldn’t be able to escape.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-5](ch08.html#ch8ex5) is the start of a program to make a magical
    block that moves on its own.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '*movingBlock.py*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 8-5: Unfortunately, this code won’t work until global variables are
    added.*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: But this code won’t run yet because the variables in the `calculateMove()` function
    aren’t global.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Your mission is to finish the code in [Listing 8-5](ch08.html#ch8ex5). Copy
    it into IDLE and save it as *movingBlock.py* in the *functions* folder. Add code
    to the start of the function to make the `x`, `y`, and `z` variables global. The
    global definitions should be placed at ➊.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve declared some global variables, run the program. Your block should
    move around. [Figure 8-6](ch08.html#ch8fig6) shows the block move up to a wall
    and then start to move around it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '**BONUS OBJECTIVE: A MORE INTELLIGENT MELON BLOCK**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: When you run the *movingBlock.py* program, you might notice that the block moves
    forward along the x-axis the most, sometimes causing it to get stuck in a loop
    between two blocks. The reason is that the code doesn’t take into account the
    directions that the block has already moved in and will always try to move along
    the x-axis first. Can you work out how to store the last direction that the block
    moved in and change the `if` statement to move in that direction first?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-06.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: It was fun watching the melon move forward and then try to move
    around the wall.*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hooray! In this chapter, you learned how to create and call functions. With
    `return` statements you can make functions return values, and you can write loops
    and `if` statements inside functions. In [Chapter 9](ch09.html#ch09), you’ll learn
    about lists, which allow you to store several pieces of data in a single variable.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
