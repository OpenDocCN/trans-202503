- en: '**8**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**FUNCTIONS GIVE YOU SUPERPOWERS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Functions are reusable blocks of code that perform specific tasks. Say you want
    to write code that builds a tree in Minecraft. You could rewrite the tree-building
    code every time you need to use it in your program (or copy and paste it); however,
    this would be inefficient, especially if you wanted to change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of copying and pasting, you could write the tree-building code as a
    *function*. Recall that we used some functions in earlier chapters: `str()`, `input()`,
    and `int()`. They’re all functions that are built into Python. You’ve even been
    using Minecraft functions, such as the `getBlocks()` and `setPos()` functions,
    which come with the Minecraft Python API. In this chapter, you’ll create your
    *own* functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You create and use functions for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reusability** Functions save time. Because you don’t have to rewrite the
    same code over and over again, writing a program is faster and easier.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Debugging** By containing tasks in groups of code, it is easier to identify
    where a problem originates and make changes to fix the problem.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularity** You can develop different functions to use in the same program
    independently of one another. This makes it easier to share code with other people
    and reuse functions in other programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalability** Using functions makes it easier to increase the size of a program
    and the amount of data it processes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFINING YOUR OWN FUNCTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at how you can use functions in your code. In the following example,
    I make a function called `greeting()` that simply prints two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `def` keyword, which is an abbreviation for *define*, tells Python you’re
    writing a function. Anytime you want to write a function, you must first write
    `def` followed by the function’s name. In this example, `greeting` is the name
    of the function. Don’t forget to add the parentheses and the colon at the end
    of the first line. The lines that follow the colon are the *body* of the function,
    which is the code that will run when the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Keep indentation consistent in your code. Always indent the body of the function
    by using four spaces.*'
  prefs: []
  type: TYPE_NORMAL
- en: A function can contain as many statements as you want. It can also include `if`
    statements, loops, variables, conditions, math operators, and so on. When you
    reach the end of the function code, stop indenting lines so Python knows which
    statements belong to the function and which statements belong to other parts of
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: You can create as many functions as you want in a program, as long as they have
    different names.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALLING A FUNCTION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To use, or *call*, a function, you write the name of the function with any arguments
    it might require in parentheses. If your function doesn’t take any arguments,
    just write the function’s name and a set of empty parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call the `greeting()` function defined earlier, you would use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call the function as many times as you want. Let’s call the `greeting()`
    function three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the program, it should produce the output of the function three
    times, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You must call the function in the body of your code, or the function will not
    do anything. This is a common mistake. If you run a program that defines some
    functions and your code doesn’t do anything, it might be because you forgot to
    call the functions you created.
  prefs: []
  type: TYPE_NORMAL
- en: You can also call functions from within another function that you’ve created.
    These include built-in Python functions as well as those you’ve created. You’ll
    see this in action in just a moment.
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS TAKE ARGUMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The parentheses in a function contain its arguments, which are values the function
    uses. The values are used for specific variables inside the function when it runs.
    Not every function needs arguments. For example, the `greeting()` function doesn’t
    take arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let’s say I want to display a greeting to someone using their name. I’ll
    write this as a function so I can reuse the code to greet different people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, function is called twice using different arguments, `"Mario"`
    and `"Steve"`. When you run the program, the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you forget to include an argument when you call a function that needs one,
    you will get an error. Also, if a function needs multiple arguments and you forget
    to include even one of them, you will get an error. For example, let’s try calling
    the `fancyGreeting()` function with no arguments, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following error message is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is a useful error message because the last line explains what is wrong
    with the code ➊. The `fancyGreeting()` function takes one argument, but because
    it was given no argument, that caused the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a function that takes several arguments. For example, the following
    program contains a function that says hello to someone, waits a number of seconds,
    and then says goodbye. The function uses an argument for the person’s name and
    the number of seconds the program will wait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Each argument is separated by a comma when the function is defined ➊. Then,
    when the functions are called, the arguments are passed in the same order in which
    they were defined ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You might encounter the terms* argument *and* parameter *used almost interchangeably.
    The parameters of a function define the types of arguments it accepts or requires,
    and the arguments are the values that you pass to the function when you call it.
    For simplicity, we’ll just use the term* argument *in this book.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #41: BUILD A FOREST**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Your mission is to create a forest of trees in Minecraft. Because a forest is
    just a bunch of trees, we’ll create the forest by making a function that builds
    one tree and then call that function many times to create a forest.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-1](ch08.html#ch8ex1) is the basic code you’ll be using.'
  prefs: []
  type: TYPE_NORMAL
- en: '*forest.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-1: The structure of a program that uses functions to create a forest
    of trees*'
  prefs: []
  type: TYPE_NORMAL
- en: The `growTree()` function ➊ created in this code takes arguments for the coordinates
    where the tree will be built. Your task is to write code in the body of the function
    that creates a tree at the given coordinates. You’ll use the `setBlock()` and
    `setBlocks()` functions to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Copy [Listing 8-1](ch08.html#ch8ex1) into a new file in IDLE and save it as
    *forest.py* in a new folder called *functions*.
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve created something that resembles a tree and it appears onscreen,
    try writing more calls to the function using different arguments so trees appear
    at different locations. The first one has been done for you ➋. Try creating at
    least nine trees in front of the player each time you run your program. [Figure
    8-1](ch08.html#ch8fig1) shows the trees that my program created.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: I’ve just grown a beautiful row of trees.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**BONUS OBJECTIVE: RANDOM FOREST**'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `randint()` function in the `random` module to randomize the distance
    between the trees in the forest.
  prefs: []
  type: TYPE_NORMAL
- en: '**REFACTORING A PROGRAM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Quite often you’ll write a program that uses the same block of code several
    times. Making changes to the program will become tedious when you want to change
    the same code in different places. You might have done this in programs you’ve
    written in the past, but there’s a much better way.
  prefs: []
  type: TYPE_NORMAL
- en: You can restructure your programs to use functions. To do this, move the code
    that is repeated several times into a single function that you can then use as
    many times as you want in the rest of the code. Because you’ll only need to make
    changes in one place instead of several, you’ll save space and the program will
    be easier to maintain. The process of restructuring your code in this way is called
    *refactoring*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code asks three people their names and then prints
    a greeting to each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code here repeats the same two statements three times. What if you wanted
    to change the question or the greeting? It’s not much of a problem changing the
    code for 3 people, but what if you were writing code for 100 people?
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative is to write the code as a function and call it three times.
    Here is the code after refactoring it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the program runs, it will ask for input and then output a string,
    and it will do both tasks three times. Here are the input and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The second version of the code has the same outcome as the first version, but
    as you can see, it’s much easier to read and much easier to change.
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #42: REFACTOR AWAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes you’ll write a program only to realize afterward that you should have
    used functions (I do this all the time). Refactoring code to include functions
    is a very important skill.
  prefs: []
  type: TYPE_NORMAL
- en: In this mission, you’ll practice refactoring a program to use a function instead
    of repeating the same statements several times.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-2](ch08.html#ch8ex2) places a melon block underneath the player
    every 10 seconds. We’ll rewrite the code to use a function. Currently, the program
    places three blocks by using the same line of code three times. [Figure 8-2](ch08.html#ch8fig2)
    shows the result of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: '*melonFunction.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-2: Some code that needs refactoring*'
  prefs: []
  type: TYPE_NORMAL
- en: This code isn’t very pretty, is it? Several lines are repeated, which is always
    a sign that the code needs refactoring with the help of a function definition.
  prefs: []
  type: TYPE_NORMAL
- en: '**HINT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Identify which parts of the code repeat to get an idea of what your function
    should do.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-2: Three delicious melons under the ground*'
  prefs: []
  type: TYPE_NORMAL
- en: Change the code so it places six blocks in total by calling your function six
    times. Create a new file and save it as *melonFunction.py* in the *functions*
    folder. Copy [Listing 8-2](ch08.html#ch8ex2) into your file and refactor the code
    to use a function. Call the new function `makeMelon()`.
  prefs: []
  type: TYPE_NORMAL
- en: '**BONUS OBJECTIVE: BLOCKS UNDERFOOT**'
  prefs: []
  type: TYPE_NORMAL
- en: Add arguments to your `makeMelon()` function to control the type of block, sleep
    time, or distance below the player.
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMENTING WITH DOCSTRINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using comments in Python code is a way to explain what code does. When Python
    runs a program, it ignores everything in a comment, so comments don’t affect how
    the code runs. The main purpose of comments is to explain what your code is supposed
    to do to others who might look at or use your code. Comments are also useful reminders
    for yourself in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Because functions are supposed to be reusable, it makes sense to explain their
    purpose. To write explanations for our functions, we’ll use long explanations
    called *docstrings*. A docstring is a multiline comment that you place at the
    start of a function to explain its use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `duplicateWord()` function in the following example has a docstring that
    explains its task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The docstring should be on the first line of a function ➊. The docstring begins
    and ends with a set of three quotation marks (`"""`) and can be written across
    as many lines as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '**LINE BREAKS IN ARGUMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make long lists of arguments easier for programmers to read, Python allows
    you to place arguments across several lines. For example, the function call in
    this program has its arguments split across several lines to increase readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Line breaks in arguments are particularly useful when you want to use math operators
    on arguments, when you are using long variable names as arguments, or when you
    have several arguments to provide to a function.
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTION RETURN VALUES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two types of functions: those that return a value and those that
    don’t. So far, you’ve created functions that don’t return a value. Let’s look
    at those that do return a value.'
  prefs: []
  type: TYPE_NORMAL
- en: Returning a value from a function is very useful, because it allows a function
    to work with data and then return a value to the main body of the program. For
    example, imagine you sell cookies. To calculate the price you have to sell each
    cookie at to make enough profit, you add two gold coins to the amount you paid
    to make the cookie and then multiply the sum by 10\. By using a function that
    returns a value, you can write this calculation and reuse it in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'When making your own functions, you can use the `return` keyword to return
    a value from the function. For example, here is the code to calculate your selling
    price for a cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To return a value, you just write `return` followed by the value you want,
    which in this case is `price`. To use a function that returns a value, you call
    it in a place that would expect a value. For example, to set the `priceOfCookie`
    variable, call the `calculateCookiePrice()` function and enter a cost, such as
    `6`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can use functions that return values to set the values of variables, and
    you can use them anywhere that you are expected to put a value, even as an argument
    for another function.
  prefs: []
  type: TYPE_NORMAL
- en: Functions that do not return a value cannot be used to set the values of variables.
    Let’s take a quick look at the difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the following function returns a value, it can be used anywhere a value
    can be used, such as to set a variable or even as an argument in another function
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this code to see its output. You can treat the result from the function
    like a value and even do math with it. Here I add 4 to the returned value and
    store it in a variable called `extraChickens`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the following function doesn’t have a `return` statement, which means
    you can’t use it in place of a value. All you can do is call the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing this code in the text editor and running it prints `"Cluck"`, although
    it can’t be used in other statements because it doesn’t return a value to the
    program. For example, I could try to concatenate the function with a string, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If I ran this program, I would get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This error means you can’t combine this function with a string, because the
    function doesn’t return a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if I change the code to return a value instead of just printing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'the file would run and display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Keep this difference in mind. Remember to include a `return` statement when
    you need it and exclude it when your function doesn’t need to return a value.
    The more experienced you become with functions, the easier it will be to decide
    whether you want your function to return a value.
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #43: BLOCK ID REMINDER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because Minecraft has so many blocks, it’s difficult to remember all the block
    IDs. I always remember the melon (103) and air (0) values but forget others, so
    I keep having to build houses out of melons!
  prefs: []
  type: TYPE_NORMAL
- en: To make remembering easier, I want you to create a program for me that returns
    the values of different blocks. Your program should have many functions that help
    me remember block IDs. The name of each function should be the same as the name
    of the block whose value it returns. For example, [Listing 8-3](ch08.html#ch8ex3)
    has a function called `melon()` that returns the value of the melon block (103).
  prefs: []
  type: TYPE_NORMAL
- en: '*blockIds.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-3: The start of the program that will help me remember block IDs*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in IDLE and save it as *blockIds.py* in the *functions* folder.
    Copy [Listing 8-3](ch08.html#ch8ex3) into the file and add functions to it that
    return the values of the following blocks (see “[Block ID Cheat Sheet](app02.html#app02)”
    on [page 283](app01.html#page_283)):'
  prefs: []
  type: TYPE_NORMAL
- en: • Water
  prefs: []
  type: TYPE_NORMAL
- en: • Wool
  prefs: []
  type: TYPE_NORMAL
- en: • Lava
  prefs: []
  type: TYPE_NORMAL
- en: • TNT
  prefs: []
  type: TYPE_NORMAL
- en: • Flower
  prefs: []
  type: TYPE_NORMAL
- en: • Diamond block
  prefs: []
  type: TYPE_NORMAL
- en: 'After you’ve added your functions, test them by calling the functions to create
    blocks. Because your new functions return a block’s value, you can use them to
    set the value of a variable to pass into the `setBlock()` function. The following
    code will help you get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 8-3](ch08.html#ch8fig3) shows the result of the completed program with
    a test for the `melon()` function. Notice that the placement of any block is hardcoded
    into this program; it will always place a block at your current location.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: Now I don’t have to remember the block types, all thanks to this
    handy function.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**HINT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To place a diamond block, TNT, or any other kind of block, you’ll first need
    to define the function that returns the value of the block you want. Then you’ll
    need to call that function in your code, just like I called the* `melon()` *function
    in this example.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**BONUS OBJECTIVE: MORE BLOCKS**'
  prefs: []
  type: TYPE_NORMAL
- en: Add extra functions for any other block types that you want.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING IF STATEMENTS AND WHILE LOOPS IN FUNCTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapters 6](ch06.html#ch06) and [7](ch07.html#ch07), you learned about putting
    `if` statements inside of other `if` statements and `while` loops inside of other
    `while` loops. You learned that you can even put `if` statements within `while`
    loops and vice versa! In this section, you’ll learn how to put `if` statements
    and loops inside functions. This makes your functions very flexible, because you
    can use them to make decisions and repeat code.
  prefs: []
  type: TYPE_NORMAL
- en: '**IF STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you’re writing an `if` statement within a function, the syntax is identical
    to that of a regular `if` statement. You just need to remember to indent the `if`
    statement by an extra four spaces at the start of every line so Python knows it’s
    part of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code takes a number written as a string and returns the number
    as an integer. For example, the argument `"four"` returns the value `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at another example. The following function checks whether you’ve
    met a person before and uses an appropriate greeting depending on the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `chooseGreeting()` function takes one Boolean argument, called `metBefore`
    ➊. The `if` statement inside the function then prints output based on the value
    of the argument. If the value is `True`, the output will be `"Nice to see you
    again"` ➋, and if it is `False` ➌, the output will be `"Nice to meet you"`.
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #44: WOOL COLOR HELPER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ve used the `setBlock()` and `setBlocks()` methods with arguments to set
    block coordinates and block type, but these methods also have an optional extra
    argument that will set the block *state*.
  prefs: []
  type: TYPE_NORMAL
- en: Each block in Minecraft has 16 states, 0 to 15\. Wool, for example, has a different
    color for every state. TNT (block ID 46) won’t explode when you smash the block
    in its default state (state 0), but it is explosive when you smash it in block
    state 1\. Although every block has 16 states, not all of them have different behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set a block’s state, you provide the `setblock()` or `setblocks()` function
    with an extra argument. The following code creates a pink block of wool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Wool (block ID 35) has many uses in Minecraft due to its different colors, but
    it’s difficult to remember the different block states. Fortunately, you don’t
    need to memorize the different block states when you can use a program to remind
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make a program that contains the wool block’s states. The program will
    contain a function with an argument that takes the color you want written as a
    string. The function then returns the block state for the wool color as an integer.
    The function will contain the bulk of the code for the program. However, you’ll
    add a couple of code lines to take input from a user and place the block in the
    game, and you’ll use your fancy new function to set the color.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you’ll need to find out the block states for the different colors of
    wool. You can find them in the “[Block ID Cheat Sheet](app02.html#app02)” on [page
    283](app01.html#page_283). Here’s some code to get you started (pink is block
    state 6):'
  prefs: []
  type: TYPE_NORMAL
- en: '*woolColors.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: At the moment, the program has just the beginnings of the `getWoolState()` function.
    It only has an `if` statement for the color pink ➊. Also included is code at the
    end of the program to take user input for the block color ➋ and code to place
    the wool block at the player’s position ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Add to the `getWoolState()` function using `elif` statements for other wool
    colors and their corresponding block states. The program should take an argument
    for the color of the block and return the integer value of the block state. For
    example, providing the argument `"pink"` will return the value 6\. You’ll also
    need to add a `return` statement to the program. Use the comments to guide you.
  prefs: []
  type: TYPE_NORMAL
- en: Save the file as *woolColors.py* in the *functions* folder.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to make the program more user friendly, you can post a message to
    chat if the argument is not a valid color. [Figure 8-4](ch08.html#ch8fig4) shows
    the input in the Python shell and the wool block being placed in the game.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: Now I can create a wool block in any color by entering the name
    of the color I want.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHILE LOOPS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just like `if` statements, loops can be written inside functions. The syntax
    for a loop inside a function is the same as that for a regular loop. You just
    need to remember that the loop should be indented by an extra four spaces on each
    line to indicate that it belongs to the function.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, the `while` loop within the function will print the
    `toPrint` argument. The number of times the loop repeats is determined by the
    `repeats` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `return` statements and `while` loops in the same function.
    In most cases, you’ll want the `return` statement to be outside the loop. (If
    you use the `return` statement inside a loop, it will break the loop and end the
    function.) Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This program doubles a number until it is greater than 100\. It then returns
    the number of times the loop repeated ➊.
  prefs: []
  type: TYPE_NORMAL
- en: You can also put function calls within loops, as you did in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #45: BLOCKS, EVERYWHERE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By using loops inside functions, you can use an argument to determine the number
    of times a loop repeats. By using the `setBlock()` function, you can also determine
    the type of block to be placed within the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The program in this mission could be destructive, so you might want to try
    it in a new world to preserve your precious creations.*'
  prefs: []
  type: TYPE_NORMAL
- en: In this mission, you’ll create a function that places blocks randomly around
    the map. The number of blocks it places and the block type it places are determined
    by function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-4](ch08.html#ch8ex4) generates a melon at a random location on the
    map.'
  prefs: []
  type: TYPE_NORMAL
- en: '*blocksEverywhere.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-4: When called, this function will place a block randomly in the
    game.*'
  prefs: []
  type: TYPE_NORMAL
- en: Copy [Listing 8-4](ch08.html#ch8ex4) into a new file in IDLE and save it as
    *blocksEverywhere.py* in the *functions* folder. At ➋, add a `while` loop inside
    the function so the code repeats. The `count` variable ➊ makes it easier for you
    to tell how many times the loop has repeated. Compare the `repeats` argument to
    the `count` variable in the loop’s condition to set how many times the loop should
    repeat. Indent all the lines inside the function after ➋ so they are also inside
    the loop. The `getHeight()` function ensures that the block is placed above the
    ground ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, add three function calls to create blocks. The first function should
    create 10 blocks, the second one should create 37 blocks, and the third should
    create 102 blocks. Choose any block types that you want.
  prefs: []
  type: TYPE_NORMAL
- en: Save the program and run it. The program should create blocks randomly around
    the map. [Figure 8-5](ch08.html#ch8fig5) shows an example.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: You can see some of the blocks that the program has placed randomly.
    I created a new world to demonstrate this program so it didn’t damage any of my
    buildings.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**GLOBAL AND LOCAL VARIABLES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you’re defining functions, you have a new challenge to deal with, namely
    the scope of a variable. The *scope* of a variable describes how your program
    can access its data. The best way to learn about scope is to see it in action,
    so let’s look at some code. Let’s say you’re using the following code, which increases
    the number of eggs you have for a party:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Two variables are named `eggs`, one outside the function ➊ and another inside
    the function ➋. Nothing looks terribly wrong, but Python will throw an error.
    Here’s part of the error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that the `eggs` variable is defined outside the function, but
    when you try to add to it inside the function, Python can’t see the variable.
    To Python, the variable inside the function is totally different from the one
    outside the function, even though they have the same name. Python does this on
    purpose to stop variables inside different functions from accidentally sharing
    the same names and causing unexpected bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python code, you have two ways to approach the variables in a file: you
    can either make a variable *global*, which means it affects an entire program
    or file, or make a variable *local*, which means it can be seen only by the code
    in a particular function or loop. In other words, you can use the same variable
    inside and outside a function, or you can make two different variables that affect
    different parts of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *global* variable will be treated as the same variable inside and outside
    a function. Any changes to the variable inside the function will affect the variable
    that was defined outside the function and vice versa. To make a global variable,
    use the `global` keyword ➊:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the value of `eggs` will be 13 when it is printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can treat the variable as a *local* variable instead to produce a different
    effect. In this case, the variables inside and outside the function will be treated
    as different variables. Changes to the variable inside the function will not affect
    the variable outside the function and vice versa. So you could change the code
    to make the variable a local variable ➊, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When the value of `eggs` in the function is printed ➋, it will be 1 because
    the value of the `eggs` variable outside the function does not affect the local
    variable inside the function. The value of `eggs` inside the `increaseEggs()`
    function is 1, and the global `eggs` variable still has the value of 12 ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #46: A MOVING BLOCK**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A while ago, I thought it would be cool to make a block move around the Minecraft
    world by itself. Every second it would move forward. If it hit a wall, a tree,
    or something tall, it would turn and make its way in a different direction. If
    it fell in a hole, however, it would get stuck and wouldn’t be able to escape.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 8-5](ch08.html#ch8ex5) is the start of a program to make a magical
    block that moves on its own.'
  prefs: []
  type: TYPE_NORMAL
- en: '*movingBlock.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-5: Unfortunately, this code won’t work until global variables are
    added.*'
  prefs: []
  type: TYPE_NORMAL
- en: But this code won’t run yet because the variables in the `calculateMove()` function
    aren’t global.
  prefs: []
  type: TYPE_NORMAL
- en: Your mission is to finish the code in [Listing 8-5](ch08.html#ch8ex5). Copy
    it into IDLE and save it as *movingBlock.py* in the *functions* folder. Add code
    to the start of the function to make the `x`, `y`, and `z` variables global. The
    global definitions should be placed at ➊.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve declared some global variables, run the program. Your block should
    move around. [Figure 8-6](ch08.html#ch8fig6) shows the block move up to a wall
    and then start to move around it.
  prefs: []
  type: TYPE_NORMAL
- en: '**BONUS OBJECTIVE: A MORE INTELLIGENT MELON BLOCK**'
  prefs: []
  type: TYPE_NORMAL
- en: When you run the *movingBlock.py* program, you might notice that the block moves
    forward along the x-axis the most, sometimes causing it to get stuck in a loop
    between two blocks. The reason is that the code doesn’t take into account the
    directions that the block has already moved in and will always try to move along
    the x-axis first. Can you work out how to store the last direction that the block
    moved in and change the `if` statement to move in that direction first?
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f08-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: It was fun watching the melon move forward and then try to move
    around the wall.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hooray! In this chapter, you learned how to create and call functions. With
    `return` statements you can make functions return values, and you can write loops
    and `if` statements inside functions. In [Chapter 9](ch09.html#ch09), you’ll learn
    about lists, which allow you to store several pieces of data in a single variable.
  prefs: []
  type: TYPE_NORMAL
