<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_235"/><span class="big">9</span><br/>UNIT AND INTEGRATION TESTING WITH AUTOTEST</h2>&#13;
<p class="quote"><em>. . . to learn is not to know; there are the learners and the learned. Memory makes the one, philosophy the other.<br/>—Alexandre Dumas, The Count of Monte Cristo</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">Testing is important. All developers test their software to one degree or another; otherwise, they don’t know if the product meets the design criteria. On one end of the spectrum, the author compiles and runs the program. If it presents the general interface they envisioned, they call it done. On the other end, the author writes a suite of tests that attempt to exercise as much of the code as possible under varying conditions, validating that the outputs are correct for the specified inputs. Straining to reach the rightmost point on this line, we find the person who literally writes tests first and then adds and modifies code iteratively until all the tests pass.</p>&#13;
<p class="indent">In this chapter, I won’t attempt to expound on the virtues of testing. I assume every developer agrees that <em>some</em> level of testing is important, whether they are a compile-run-and-ship sorta person or a bona-fide test-driven person. I also assume every developer has some level of aversion to <span epub:type="pagebreak" id="page_236"/>testing that lies somewhere along this spectrum. Therefore, our goal here is to let someone else do as much of the work of testing as possible. In this case, “someone else” means the Autotools.</p>&#13;
<p class="indent">Back in <a href="ch03.xhtml">Chapter 3</a>, we added a test to our handcoded makefiles for Jupiter. The output of the test was completely controlled by the <span class="literal">make</span> script we put into <em>src/Makefile</em>:</p>&#13;
<pre>$ <span class="codestrong1">make check</span>&#13;
cd src &amp;&amp; make check&#13;
make[1]: Entering directory '/.../jupiter/src'&#13;
cc -g -O0    -o jupiter main.c&#13;
./jupiter | grep "Hello from .*jupiter!"&#13;
Hello from ./jupiter!&#13;
*** All TESTS PASSED&#13;
make[1]: Leaving directory '/.../jupiter/src'&#13;
$</pre>&#13;
<p class="indent">When we moved on to Autoconf in <a href="ch04.xhtml">Chapters 4</a> and <a href="ch05.xhtml">5</a>, not much changed. The output was still controlled by our handwritten <span class="literal">make</span> script. We just moved it into <em>src/Makefile.in</em>.</p>&#13;
<p class="indent">In <a href="ch06.xhtml">Chapter 6</a>, however, we dropped our handcoded makefiles and templates in favor of Automake’s much more terse <em>Makefile.am</em> files. Then we had to figure out how to shoehorn our handwritten test into <span class="literal">automake</span> script. In doing so, we got a bit of an upgrade on the test output:</p>&#13;
<pre>$ <span class="codestrong1">make check</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
PASS: greptest.sh&#13;
============================================================================&#13;
Testsuite summary for Jupiter 1.0&#13;
============================================================================&#13;
# TOTAL: 1&#13;
# PASS:    1&#13;
# SKIP:    0&#13;
# XFAIL: 0&#13;
# FAIL:    0&#13;
# XPASS: 0&#13;
# ERROR: 0&#13;
============================================================================&#13;
$</pre>&#13;
<p class="indent">If you’re running this code on your terminal with a reasonably late version of Automake, you’ll even see colored test output.</p>&#13;
<p class="indent">Every test added to the <span class="literal">TESTS</span> variable in our <em>src/Makefile.am</em> template generates a <span class="literal">PASS:</span> or <span class="literal">FAIL:</span> line, and the summary values account for all of them. This is because Automake has a nice built-in testing framework driven by the <span class="literal">TESTS</span> variable. If you need to build any of the files specified in <span class="literal">TESTS</span>, you can just create a rule for it as we did for the trivial driver script (<em>greptest.sh</em>) that we created. If your test program needs to be built from sources, you can use a <span class="literal">check_PROGRAM</span> variable. One minor problem with <span epub:type="pagebreak" id="page_237"/>Automake’s testing framework is that if tests are found in multiple directories, you see multiple such displays during <span class="literal">make check</span>, which can be a little annoying, especially when using <span class="literal">make -k</span> (continue in the face of errors), because it may not occur to you to scroll up to see the output of earlier, possibly failed tests.</p>&#13;
<p class="indent">In addition to the <span class="literal">TESTS</span> variable, if you set the <span class="literal">XFAIL_TESTS</span> variable to a subset of the tests listed in <span class="literal">TESTS</span>, you might also see some output in the <span class="literal">XFAIL:</span> and <span class="literal">XPASS:</span> lines. These are tests that are expected to fail. When such tests pass, they’re listed in the <span class="literal">XPASS:</span> line as an <em>unexpected pass</em>. When they fail, they’re listed in the <span class="literal">XFAIL:</span> line as an <em>expected failure</em>.</p>&#13;
<p class="indent">A test returning a shell code of 77 increases the count in the <span class="literal">SKIP:</span> line, and 99 increases the count in the <span class="literal">ERROR:</span> line. I’ll provide more detail about special shell codes returned by tests later in this chapter.</p>&#13;
<p class="indent">As you might have guessed by now, Autoconf also includes a testing framework, called <em>autotest</em>, that provides all of the infrastructure required to allow you to simply and easily specify a test that exercises some portion of your code. The results are displayed in a consistent and easy-to-comprehend manner, and failed tests are easy to reproduce in an isolated fashion, complete with a built-in debugging environment. Almost makes you want to write tests, doesn’t it? The fact is, a well-designed testing framework, like any other well-designed tool, is a joy to use.</p>&#13;
<p class="indent">Additionally, autotest is portable—as long as you write your portion of the tests using portable script or code, the entire test suite will be 100 percent portable to any system on which you can run your <span class="literal">configure</span> script. That’s not as hard as it sounds. Often the shell script you have to write amounts to running a command, and the code behind the command is written using Autotools-provided portability features and is generated using Autotools-provided build processes.</p>&#13;
<p class="indent">For several years, autotest has been documented as being “experimental.” Regardless, its base functionality hasn’t changed much during those years, and Autoconf uses it to test itself, as we saw in <a href="ch01.xhtml">Chapter 1</a>. So, it’s time to stop worrying about whether it’s going to change and just start using it for its intended purpose: to make testing less of a chore for software developers, who—let’s face it—really just want to write code and let someone else worry about testing.</p>&#13;
<p class="indent">Being the rational creatures that we are, we can’t deny that testing is important. What we can do is make use of good tools that allow us to focus on our code, letting frameworks like autotest worry about ancillary issues like result formatting, success/failure semantics, data gathering for user-submitted bug reports, and portability. As we’ll see throughout this chapter, this is the value that autotest provides.</p>&#13;
<p class="indent">In the spirit of transparency, I’ll admit it’s difficult to justify using autotest for small test suites like Jupiter’s. The testing harness built into Automake is more than adequate for most small project needs. Larger projects—such as Autoconf itself, with its 500-plus unit and integration tests, which test functionality spread out over its entire project directory structure, and even installed components—are a different matter entirely.</p>&#13;
<h3 class="h3" id="ch09sec1"><span epub:type="pagebreak" id="page_238"/>Autotest Overview</h3>&#13;
<p class="noindent">There are three phases to the files consumed and generated by autotest. The first phase is what the <em>GNU Autoconf Manual</em> calls the “prep for distribution” phase. The second phase occurs when <span class="literal">configure</span> is executed, and the third phase happens during execution of the test suite. Let’s take each of these phases in turn.</p>&#13;
<p class="indent">The first phase, which happens during building of the distribution archive, is essentially the process of generating the executable test program that can be run by users on their systems. It may seem a bit strange that this process must be done during the building of a distribution archive; however, Autoconf is required to be installed on any system that needs to generate this program, so the <span class="literal">testsuite</span> program must be built when the distribution archive is built so that it may be included in the archive for the user. While the <span class="literal">dist</span> or <span class="literal">distcheck</span> targets are being made, <span class="literal">configure</span> (and <span class="literal">make check</span>, when using <span class="literal">distcheck</span>) is executed; <span class="literal">make check</span> encapsulates rules to rebuild the test program from sources using <span class="literal">autom4te</span>—the Autoconf caching <span class="literal">m4</span> driver. The test program is built during execution of the <span class="literal">dist</span> target by virtue of having it included in the Automake <span class="literal">EXTRA_DIST</span> variable, which I’ll talk about near the end of this chapter.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch09fig1">Figure 9-1</a> shows the flow of data from maintainer-written source files to the <span class="literal">testsuite</span> program during <span class="literal">make dist</span> (or <span class="literal">make distcheck</span>).</p>&#13;
<div class="image"><img src="../images/09fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch09fig1"><em>Figure 9-1: Data flow from maintainer-written input files to the <span class="literal">testsuite</span> program</em></p>&#13;
<p class="indent">The file <em>testsuite.at</em>, found at the top of the second column of the diagram, is the main test file written by a project author. This is actually the only maintainer-written file required by autotest. Exactly like <em>configure.ac</em>, this file contains shell script sprinkled with M4 macro definitions and invocations. This file is passed through the M4 macro processor, with <span class="literal">autom4te</span> acting as the driver for <span class="literal">m4</span>, to generate the <span class="literal">testsuite</span> program at the top of the last column, which is pure shell script. This process occurs during execution of <span class="literal">autom4te</span>, which is driven by <span class="literal">make check</span> reading the makefile generated from a <em>Makefile.in</em> or <em>Makefile.am</em> file that we write. The prep-for-distribution concept comes from the fact that the <span class="literal">check</span> target is executed during <span class="literal">make distcheck</span> (which, of course, builds the distribution archive); the <span class="literal">testsuite</span> program is added to the distribution archive during this process. <span epub:type="pagebreak" id="page_239"/>It’s built during <span class="literal">make dist</span>, which does not execute <span class="literal">make check</span>, because all files listed in <span class="literal">EXTRA_DIST</span> must be built before they can be included in the distribution archive.</p>&#13;
<p class="indent">Details like this are normally hidden from us by the Autotools, but as autotest is still considered experimental—meaning, not fully integrated into the Autotools suite—the responsibility for some of this additional infrastructure is relegated to us, the maintainers. We’ll cover these details shortly.</p>&#13;
<p class="indent">The Autoconf manual suggests that test suite authors may put individual sets of related tests, called <em>test groups</em>, into separate <em>.at</em> files. The <em>testsuite.at</em> file, then, contains only a series of <span class="literal">m4_include</span> directives, including each of these group-specific <em>.at</em> files. Therefore, M4 inclusion is the mechanism by which the optional <em>test-1.at</em> through <em>test-</em><span class="literal">N</span><em>.at</em> are gathered together into <em>testsuite.at</em> for processing by M4.</p>&#13;
<p class="indent">The <em>package.m4</em> and <em>local.at</em> files are optional maintainer-written (or generated) input files that are automatically included by <span class="literal">autom4te</span> when processing <em>testsuite.at</em>, if they’re found. The former contains basic information about the test suite that’s displayed on the console and embedded in bug reports generated by the test suite. The latter, the manual suggests, is an optional mechanism we may choose to use that can help us keep <em>testsuite.at</em> uncluttered with global definitions, non-group-related tests, and helper macro definitions and shell functions that may be used by the actual tests. We’ll discuss the exact contents of these files later in the chapter.</p>&#13;
<p class="indent">When a <span class="literal">configure</span> script is instrumented for autotest, the configuration process generates additional, autotest-related artifacts. <a href="ch09.xhtml#ch09fig2">Figure 9-2</a> shows what happens graphically during the configuration process, relative to autotest.</p>&#13;
<div class="image"><img src="../images/09fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch09fig2"><em>Figure 9-2: The flow of data during <em><span class="literal">configure</span></em> while generating test-related templates</em></p>&#13;
<p class="indent">Recall from <a href="ch02.xhtml">Chapter 2</a> that <span class="literal">config.status</span> drives the file-generation portion of the configuration process. When a <em>configure.ac</em> file is set up for autotest, <span class="literal">config.status</span> generates <em>atconfig</em>—a shell script that’s designed to be sourced by <span class="literal">testsuite</span> when it’s executed.<sup><a id="ch09fn_1" href="footnote.xhtml#ch09fn1">1</a></sup> It contains source- and build-tree <span epub:type="pagebreak" id="page_240"/>variables such as <span class="literal">at_testdir</span>, <span class="literal">abs_builddir</span>, <span class="literal">abs_srcdir</span>, <span class="literal">at_top_srcdir</span>, and so on, in order to facilitate access to files and products in the source and build trees during test suite execution.</p>&#13;
<p class="indent">The test author may also choose to create a template file called <em>atlocal.in</em> that allows them to pass additional Autoconf and project-specific configuration variables through to the test environment, as needed. The product of this template is <em>atlocal</em>—also a shell script that’s designed to be sourced by <span class="literal">testsuite</span>, if it’s present. If you choose to write <em>atlocal.in</em>, you must add it to the list of tags passed to an invocation of <span class="literal">AC_CONFIG_FILES</span> in <em>configure.ac</em>. We’ll see how this is done later as we export Jupiter’s <span class="literal">async_exec</span> flag to our test suite.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Don’t confuse atlocal with local.at from <a href="ch09.xhtml#ch09fig1">Figure 9-1</a>. The atlocal file in <a href="ch09.xhtml#ch09fig2">Figure 9-2</a>, sourced by <em><span class="literal">testsuite</span></em> at runtime, is used to pass configuration variables into the test environment from <em><span class="literal">configure</span></em>, while the local.at file is written directly by the project maintainer and contains additional test code processed by <em><span class="literal">autom4te</span></em> when <em><span class="literal">testsuite</span></em> is generated.</em></p>&#13;
</div>&#13;
<p class="indent"><a href="ch09.xhtml#ch09fig3">Figure 9-3</a> shows the flow of data during the execution of <span class="literal">testsuite</span>.</p>&#13;
<div class="image"><img src="../images/09fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch09fig3"><em>Figure 9-3: The flow of data during execution of the <span class="literal">testsuite</span> script</em></p>&#13;
<p class="indent">As mentioned previously, <span class="literal">testsuite</span> sources <em>atconfig</em> and <em>atlocal</em> (if present) to access source- and build-tree information and other project-related variables, then executes the tests that were generated into it. As it does so, it creates a <em>testsuite.log</em> file containing verbose information on the execution of each test. What you see on the screen is a single line of text per test.<sup><a id="ch09fn_2" href="footnote.xhtml#ch09fn2">2</a></sup></p>&#13;
<p class="indent">The <span class="literal">testsuite</span> program generates a directory called <em>testsuite.dir</em>. A separate subdirectory is created within this directory for each test. The test suite does not delete test-specific subdirectories for failed tests; we can use the contents of this directory structure to obtain details and to debug the problem. We’ll go into detail about what gets added to these directories shortly.</p>&#13;
<p class="indent">The <span class="literal">testsuite</span> program may be executed by hand, of course, but it has to be generated first. The Autoconf manual suggests that the process of generating the <span class="literal">testsuite</span> program is best tied directly into the <span class="literal">check</span> target so that when <span class="literal">make check</span> is executed, <span class="literal">testsuite</span> will be generated (if it’s missing or out-of-date with respect to its dependencies) and then executed.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_241"/>Since <span class="literal">testsuite</span> is added to the distribution archive, end users who run <span class="literal">make check</span> will merely execute the existing <span class="literal">testsuite</span> program, unless they’ve touched one of the files that <span class="literal">testsuite</span> depends on, in which case <span class="literal">make</span> will attempt to regenerate <span class="literal">testsuite</span>. Without Autoconf installed, this process would fail. Fortunately, it’s not generally in the user’s best interest to touch any of <span class="literal">testsuite</span>’s dependencies in the distribution archive.</p>&#13;
<h3 class="h3" id="ch09sec2">Wiring Up Autotest</h3>&#13;
<p class="noindent">Since my goal here is to teach you how to use this framework, the approach I chose to take in configuring Jupiter for autotest was to incorporate the entire set of optional files shown in Figures 9-1 through 9-3. This allows us to explore exactly how everything works together. While this approach is probably unwarranted for a project the size of Jupiter, it does work correctly, and it can always be pared down. I’ll show you at the end of this chapter just what you can delete to reduce the autotest input file set to the bare minimum.</p>&#13;
<p class="indent">Before we can write tests, we need to make <em>configure.ac</em> aware of our desire to use autotest. This is done by adding two macro invocations to <em>configure.ac</em>, as shown in <a href="ch09.xhtml#ch09ex1">Listing 9-1</a>.</p>&#13;
<p class="margin">Git tag 9.0</p>&#13;
<pre><span class="ash">#                                               -*- Autoconf -*-</span>&#13;
<span class="ash"># Process this file with autoconf to produce a configure script.</span>&#13;
&#13;
<span class="ash">AC_PREREQ([2.69])</span>&#13;
<span class="ash">AC_INIT([Jupiter],[1.0],[jupiter-bugs@example.org])</span>&#13;
<span class="ash">AM_INIT_AUTOMAKE</span>&#13;
<span class="ash">LT_PREREQ([2.4.6])</span>&#13;
<span class="ash">LT_INIT([dlopen])</span>&#13;
<span class="ash">AC_CONFIG_SRCDIR([src/main.c])</span>&#13;
<span class="ash">AC_CONFIG_HEADERS([config.h])</span>&#13;
&#13;
AC_CONFIG_TESTDIR([tests])&#13;
AC_CONFIG_FILES([tests/Makefile&#13;
                 tests/atlocal])&#13;
&#13;
<span class="ash"># Checks for programs.</span>&#13;
<span class="ash">AC_PROG_CC</span>&#13;
<span class="ash">AC_PROG_INSTALL</span>&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption" id="ch09ex1"><em>Listing 9-1:</em> configure.ac: <em>Wiring autotest into</em> configure.ac</p>&#13;
<p class="indent">The first of these two macros, <span class="literal">AC_CONFIG_TESTDIR</span>, tells Autoconf to enable autotest and specifies that the testing directory will be called <em>tests</em>. You may use a dot here to represent the current directory if you wish, but the <em>GNU Autoconf Manual</em> recommends that you use a separate directory for ease in managing test output files and directories.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_242"/><em>The addition of <span class="literal">AC_CONFIG_TESTDIR</span> to</em> configure.ac <em>is actually the only change required to enable autotest in a project, though changes to makefiles and additional support files are required to make it useful and more automated. Interestingly, this important tidbit is not found anywhere in the manual, though it is implied rather subtly.</em></p>&#13;
</div>&#13;
<p class="indent">The second line is the standard Autoconf <span class="literal">AC_CONFIG_FILES</span> instantiating macro. I’m using a separate instance of it here to generate the test-related files from templates.</p>&#13;
<p class="indent">Let’s look at what goes into each of these files. The first is a makefile for the <em>tests</em> directory that’s generated from an Autoconf <em>Makefile.in</em> template, which itself is generated from the Automake <em>Makefile.am</em> file that we need to write. In this makefile, we need to get <span class="literal">make check</span> to generate and execute <span class="literal">testsuite</span>. <a href="ch09.xhtml#ch09ex2">Listing 9-2</a> shows how we might write <em>tests/Makefile.am</em> so that Automake and Autoconf will generate such a makefile.</p>&#13;
<pre><span class="ent">➊</span> TESTSUITE = $(srcdir)/testsuite&#13;
<span class="ent">➋</span> TESTSOURCES = $(srcdir)/local.at $(srcdir)/testsuite.at&#13;
<span class="ent">➌</span> AUTOM4TE = $(SHELL) $(top_srcdir)/missing --run autom4te&#13;
<span class="ent">➍</span> AUTOTEST = $(AUTOM4TE) language=autotest&#13;
&#13;
<span class="ent">➎</span> check-local: atconfig atlocal $(TESTSUITE)&#13;
           $(SHELL) '$(TESTSUITE)' $(TESTSUITEFLAGS)&#13;
&#13;
<span class="ent">➏</span> atconfig: $(top_builddir)/config.status&#13;
           cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status tests/$@&#13;
&#13;
<span class="ent">➐</span> $(srcdir)/package.m4: $(top_srcdir)/configure.ac&#13;
           $(AM_V_GEN) :;{ \&#13;
             echo '# Signature of the current package.' &amp;&amp; \&#13;
             echo 'm4_define([AT_PACKAGE_NAME], [$(PACKAGE_NAME)])' &amp;&amp; \&#13;
             echo 'm4_define([AT_PACKAGE_TARNAME], [$(PACKAGE_TARNAME)])' &amp;&amp; \&#13;
             echo 'm4_define([AT_PACKAGE_VERSION], [$(PACKAGE_VERSION)])' &amp;&amp; \&#13;
             echo 'm4_define([AT_PACKAGE_STRING], [$(PACKAGE_STRING)])' &amp;&amp; \&#13;
             echo 'm4_define([AT_PACKAGE_BUGREPORT], [$(PACKAGE_BUGREPORT)])'; \&#13;
             echo 'm4_define([AT_PACKAGE_URL], [$(PACKAGE_URL)])'; \&#13;
           } &gt;'$(srcdir)/package.m4'&#13;
<span class="ent">➑</span> $(TESTSUITE): $(TESTSOURCES) $(srcdir)/package.m4&#13;
           $(AM_V_GEN) $(AUTOTEST) -I '$(srcdir)' -o $@.tmp $@.at; mv $@.tmp $@</pre>&#13;
<p class="caption" id="ch09ex2"><em>Listing 9-2:</em> tests/Makefile.am: <em>Getting</em> <span class="literal">make check</span> <em>to build and run</em> <span class="literal">testsuite</span></p>&#13;
<p class="indent">Before we begin dissecting this file, I should mention that these contents were taken from Section 19.4 of the <em>GNU Autoconf Manual</em>. I’ve tweaked them a bit, but essentially these lines comprise a portion of the recommended way to tie autotest into Automake. We’ll complete this file as we discuss additional features and requirements of autotest-oriented <span class="literal">make</span> script.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_243"/><em>This lack of more complete integration, along with the fact that Autoconf can be configured to use several different test drivers (DejaGNU, for instance), is likely what keeps autotest in experimental mode. While Libtool, for instance, has slowly migrated toward a position of complete integration with Automake, autotest still requires some fiddling to properly integrate into a project build system. Nevertheless, once the requirements are understood, proper integration is pretty simple. Additionally, as we’ve seen, Automake has its own test framework, which gives Automake maintainers little incentive to fully support autotest.</em></p>&#13;
</div>&#13;
<p class="indent">The code in <a href="ch09.xhtml#ch09ex2">Listing 9-2</a> is pretty straightforward when taken a line at a time—four variables and four rules. The variables are not strictly necessary, but they make for shorter command lines and less duplication in rules and commands. The <span class="literal">TESTSUITE</span> variable at <span class="ent">➊</span> simply keeps us from having to prefix <span class="literal">testsuite</span> with <span class="literal">$(srcdir)/</span> everywhere we use it.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The <span class="literal">testsuite</span> program is distributed, so it should be built in the source tree. Files that are destined to end up in the distribution archive should be found in the source directory structure. Additionally, the content of such built and distributed files should be the same, regardless of differences in configuration options used by the original archive creator, or the end user.</em></p>&#13;
</div>&#13;
<p class="indent">The <span class="literal">TESTSOURCES</span> variable at <span class="ent">➋</span> allows us to easily add additional tests to the makefile. Each <em>.at</em> file becomes a dependency of <span class="literal">testsuite</span> so that when one of them is changed, <span class="literal">testsuite</span> is rebuilt.</p>&#13;
<p class="indent">The <span class="literal">AUTOM4TE</span> variable at <span class="ent">➌</span> allows us to wrap execution of <span class="literal">autom4te</span> with the Automake <span class="literal">missing</span> script, which prints a nicer error message if <span class="literal">autom4te</span> is not found. This happens when an end user who doesn’t have the Autotools installed does something that requires <span class="literal">testsuite</span> to be rebuilt—such as modify <em>testsuite.at</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>We can’t use Automake’s <span class="literal">maintainer-rules</span> option to avoid writing these rules into distribution archive Makefiles because we must manually write these rules.</em></p>&#13;
</div>&#13;
<p class="indent">The <span class="literal">AUTOTEST</span> variable at <span class="ent">➍</span> appends the <span class="literal">--language=autotest</span> option to the <span class="literal">autom4te</span> command line. <em>There is actually no program in the Autoconf package called</em> autotest. If we had to pin down the definition of such a tool, it would be the contents of this <span class="literal">AUTOTEST</span> variable.</p>&#13;
<p class="indent">The <span class="literal">check-local</span> rule at <span class="ent">➎</span> ties execution of <span class="literal">testsuite</span> into Automake’s <span class="literal">check</span> target. Automake standard targets like <span class="literal">check</span> have a <span class="literal">-local</span> counterpart that you can use to supplement the functionality generated by Automake for the base target. If Automake sees a rule with the target <span class="literal">check-local</span> in <em>Makefile.am</em>, it generates a command to run <span class="literal">$(MAKE) check-local</span> under the generated <em>Makefile</em>’s <span class="literal">check</span> rule. This gives you a hook into the standard Automake targets. We’ll cover such hooks in greater detail in <a href="ch14.xhtml">Chapters 14</a> and <a href="ch15.xhtml">15</a>, where we’ll use them extensively in our efforts to convert a real-world project to use an Autotools-based build system.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_244"/>The <span class="literal">check-local</span> target depends on <em>atconfig</em>, <em>atlocal</em>, and <span class="literal">$(TESTSUITE)</span>. Recall from <a href="ch09.xhtml#ch09fig3">Figure 9-3</a> that <em>atlocal</em> is a script sourced by <span class="literal">testsuite</span>. It’s generated directly by the invocation of <span class="literal">AC_CONFIG_FILES</span> that we added to <em>configure.ac</em> in <a href="ch09.xhtml#ch09ex1">Listing 9-1</a>, so we’ll cover its contents shortly. The command for this rule executes <span class="literal">'$(TESTSUITE)'</span> with <span class="literal">$(TESTSUITEFLAGS)</span> as a command line argument. The contents of <span class="literal">TESTSUITEFLAGS</span> are user defined, allowing the end user to run <span class="literal">make check TESTSUITEFLAGS=-v</span>, for instance, to enable verbose output from <span class="literal">testsuite</span> while making targets that invoke <span class="literal">testsuite</span>.</p>&#13;
<p class="indent">You can also use <span class="literal">TESTSUITEFLAGS</span> to target specific test groups by number (for instance, <span class="literal">TESTSUITEFLAGS=2 testsuite</span>) or, if you’ve written your tests using the <span class="literal">AT_KEYWORDS</span> macro, by tag name. In addition, several command line options are available for the generated <span class="literal">testsuite</span> program. You can find complete documentation for <span class="literal">testsuite</span> options in Section 19.3 of the <em>GNU Autoconf Manual</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The single quotes around <em><span class="literal">$(TESTSUITE)</span></em> allow the path in <em><span class="literal">TESTSUITE</span></em> to contain spaces, if needed. This technique can and should be used in all makefiles to handle whitespace in paths. I’ve generally ignored the concept of whitespace in paths within this book in order to reduce the noise in the listings, but you should be aware that makefiles can be written to properly handle whitespace in all filenames and paths—those in targets and dependencies, as well as those in the commands associated with rules.</em></p>&#13;
</div>&#13;
<p class="indent">I mentioned previously that the <em>atconfig</em> script, also sourced by <span class="literal">testsuite</span>, is generated automatically beneath the covers by <span class="literal">AC_CONFIG_TESTDIR</span>. The problem is, even though <span class="literal">config.status</span> understands how to build this file, Automake doesn’t know anything about it because it’s not listed directly in any of the instantiating macro invocations in <em>configure.ac</em>, so we need to add an explicit rule to <em>Makefile.am</em> to create or update it. This is where the <span class="literal">atconfig</span> rule at <span class="ent">➏</span> in <a href="ch09.xhtml#ch09ex2">Listing 9-2</a> comes in. The <span class="literal">check-local</span> rule depends on it, so its commands will be executed if <em>atconfig</em> is missing or older than its dependency, <span class="literal">$(top_builddir)/config.status</span>, when <span class="literal">make check</span> is executed.</p>&#13;
<p class="indent">The command in the rule for generating <span class="literal">$(srcdir)/package.m4</span> at <span class="ent">➐</span> (note there is only one command here) merely writes text into the target file if the file is missing or older than <em>configure.ac</em>. This is an optional input file (see <a href="ch09.xhtml#ch09fig1">Figure 9-1</a>), the contents of which are actually required by autotest in some form. Several M4 macros must be defined in the input data that is processed by autotest to create a test suite, including <span class="literal">AT_PACKAGE_NAME</span>, <span class="literal">AT_PACKAGE_TARNAME</span>, <span class="literal">AT_PACKAGE_VERSION</span>, <span class="literal">AT_PACKAGE_STRING</span>, <span class="literal">AT_PACKAGE_BUGREPORT</span>, and <span class="literal">AT_PACKAGE_URL</span>. These variables may be defined directly in <em>testsuite.at</em> (or any of the subfiles included by that file), but it makes more sense to generate this information from values already found in <em>configure.ac</em> so we don’t have to maintain two sets of the same information. This is the very reason why <em>package.m4</em> is included automatically by <span class="literal">autom4te</span> if it’s found while processing <em>testsuite.at</em>.</p>&#13;
<p class="indent">But wait—why not use <span class="literal">AC_CONFIG_FILES</span> to have <span class="literal">configure</span> generate this file? All we’re doing is generating a text file that contains configuration variables, and that sounds like exactly what <span class="literal">AC_CONFIG_FILES</span> is for. The problem is, <span class="literal">AC_CONFIG_FILES</span> and the other instantiating macros always generate <span epub:type="pagebreak" id="page_245"/>files into the build tree, and <em>package.m4</em> must end up in the source tree in order to be added to the distribution archive (not because it’s part of any build or execution process the user may instigate, but because it’s part of the source code for <span class="literal">testsuite</span>). Perhaps the full integration of autotest, at some point in the future, will result in the ability to request the instantiating macros to generate files into the source tree. Until then, this is what we have to work with.</p>&#13;
<p class="indent">The fourth and final rule, <span class="literal">$(TESTSUITE)</span>, at <span class="ent">➑</span>, generates <span class="literal">$(srcdir)/testsuite</span> using the <span class="literal">$(AUTOTEST)</span> command. Because <span class="literal">$(TESTSUITE)</span> is a dependency of <span class="literal">check-local</span>, it’ll get built if it’s not up-to-date. The <span class="literal">autom4te</span> program, when executed in <em>autotest mode</em>, accepts the <span class="literal">-I</span> option for specifying include paths for <em>.at</em> files that may be included by <em>testsuite.at</em> or any of its inclusions. It also accepts the <span class="literal">-o</span> option for specifying the output file, <span class="literal">testsuite</span>.<sup><a id="ch09fn_3" href="footnote.xhtml#ch09fn3">3</a></sup></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>I’ve added <em><span class="literal">$(AM_V_GEN)</span></em> in front of the commands of the last two rules in <a href="ch09.xhtml#ch09ex2">Listing 9-2</a> to allow my custom rules to tie into the Autotools’ silent build rules system. Any command prefixed with <em><span class="literal">$(AM_V_GEN)</span></em> will cause the normal command output to be replaced with <em><span class="literal">GEN</span></em> <span class="literal">target</span> when building with silent rules enabled. See Section 21.3 of the GNU Automake manual for more details on this and other variables that affect build output when building with silent rules.</em></p>&#13;
</div>&#13;
<p class="indent">Taken as a whole, all of this allows us to run <span class="literal">make check</span> at the command prompt to build (if needed) and execute <span class="literal">$(srcdir)/testsuite</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>There’s a bit more we need to do in this</em> Makefile.am <em>file to fully integrate autotest functionality into Automake. We’ll add some additional administrative rules and variables later in this chapter. For clarity at this point, I limited the content to just what we need to build and run the test suite.</em></p>&#13;
</div>&#13;
<p class="indent">Well, we’ve created a new directory and added a new <em>Makefile.am</em>. By now, you should be automatically thinking about how this <em>Makefile.am</em> file is going to be called if we don’t link it into the top-level <em>Makefile.am</em> <span class="literal">SUBDIRS</span> variable. You’re absolutely correct—this must be our next step. <a href="ch09.xhtml#ch09ex3">Listing 9-3</a> shows this modification to the top-level <em>Makefile.am</em> file.</p>&#13;
<pre><span class="ash">SUBDIRS = common include libjup src</span> tests</pre>&#13;
<p class="caption" id="ch09ex3"><em>Listing 9-3:</em> Makefile.am: <em>Adding the tests subdirectory</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>I added tests last. This will almost always be the pattern for a directory such as</em> tests. <em>In order to test the system, most, if not all, of the other directories must be built first.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_246"/>The second file in <a href="ch09.xhtml#ch09ex1">Listing 9-1</a> is the <em>atlocal</em> shell script that’s automatically sourced by <span class="literal">testsuite</span>, if present, which may be used to pass additional configuration variables through to <span class="literal">testsuite</span>’s runtime environment. We’ll use this file in the Jupiter project to pass the <span class="literal">async_exec</span> flag through to <span class="literal">testsuite</span> so it may know if the program it’s testing has been configured with the <em>async-exec</em> feature enabled. <a href="ch09.xhtml#ch09ex4">Listing 9-4</a> shows how this is done in <em>atlocal</em>’s template, <em>atlocal.in</em>.</p>&#13;
<pre>async_exec=@async_exec@</pre>&#13;
<p class="caption" id="ch09ex4"><em>Listing 9-4:</em> tests/atlocal.in: <em>A template for generating</em> atlocal</p>&#13;
<p class="indent">Now, this causes a small problem for us because <span class="literal">configure</span> is not yet exporting a substitution variable called <span class="literal">async_exec</span>. We wrote a shell script that uses a shell variable of this name back in <a href="ch05.xhtml">Chapter 5</a>, but recall we only used it to indicate whether we should invoke <span class="literal">AC_DEFINE</span> to generate the <span class="literal">ASYNC_EXEC</span> preprocessor definition into <em>config.h.in</em>. We now need to use <span class="literal">AC_SUBST</span> on this variable in order to generate an Autoconf substitution variable of the same name. <a href="ch09.xhtml#ch09ex5">Listing 9-5</a> highlights the single-line addition to <em>configure.ac</em> required to make this happen.</p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
  <span class="ash">------------------------------------------</span>&#13;
  <span class="ash">Unable to find pthreads on this system.</span>&#13;
  <span class="ash">Building a single-threaded version.</span>&#13;
  <span class="ash">------------------------------------------])</span>&#13;
       <span class="ash">async_exec=no</span>&#13;
   <span class="ash">fi</span>&#13;
<span class="ash">fi</span>&#13;
&#13;
AC_SUBST([async_exec])&#13;
<span class="ash">if test "x${async_exec}" = xyes; then</span>&#13;
    <span class="ash">AC_DEFINE([ASYNC_EXEC], 1, [async execution enabled])</span>&#13;
<span class="ash">fi</span>&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption" id="ch09ex5"><em>Listing 9-5:</em> configure.ac: <em>Making autoconf generate the <span class="literal">async_exec</span> substitution variable</em></p>&#13;
<p class="indent">One last comment on <a href="ch09.xhtml#ch09ex1">Listing 9-1</a>: we could have simply added these files to the existing invocation of <span class="literal">AC_CONFIG_FILES</span> at the bottom of <em>configure.ac</em>, but using a separate invocation here keeps test-related items together. It also serves to illustrate the fact that <span class="literal">AC_CONFIG_FILES</span> may indeed be invoked multiple times within <em>configure.ac</em>, the results being cumulative.</p>&#13;
<p class="indent">We now need to create a set of source <em>.at</em> files that can be used by <span class="literal">autom4te</span> to generate our test program. This set of files can be as simple as a single <em>testsuite.at</em> file or as complex as the diagram in <a href="ch09.xhtml#ch09fig1">Figure 9-1</a>, including <em>testsuite.at</em>, a set of test-group-specific <em>.at</em> files, and a <em>local.at</em> file. These files will contain autotest macro invocations mixed with simple or complex shell script, as required by your testing needs. We’ll start with a single line of autotest initialization code in a <em>tests/local.at</em> file, as shown in <a href="ch09.xhtml#ch09ex6">Listing 9-6</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_247"/>AT_INIT</pre>&#13;
<p class="caption" id="ch09ex6"><em>Listing 9-6:</em> tests/local.at: <em>Initialization code for <span class="literal">testsuite</span> can be added to a</em> local.at file</p>&#13;
<p class="indent">The <span class="literal">AT_INIT</span> macro is required by <span class="literal">autom4te</span> to be found somewhere within the translation unit presented by <em>testsuite.at</em> and its inclusions. This single macro invocation expands into several hundred lines of shell script that define the basic testing framework and all of the ancillary boilerplate functionality associated with it.</p>&#13;
<p class="indent">We also need to create an empty <em>testsuite.at</em> file in the <em>tests</em> directory. We’ll add items to it as we progress:</p>&#13;
<pre>$ <span class="codestrong1">touch tests/testsuite.at</span></pre>&#13;
<p class="indent">We now have the basis for generation and execution of the autotest framework in Jupiter. Every project that uses autotest will have to be configured in the manner we’ve shown so far. For smaller projects, some of the optional pieces may be omitted, the contents of which would then be combined directly into <em>testsuite.at</em>. We’ll discuss how to simplify when we’ve completed our exploration of autotest. For now, let’s give it a try:</p>&#13;
<pre>$ <span class="codestrong1">autoreconf -i</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">./configure</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
config.status: creating tests/Makefile&#13;
config.status: creating tests/atlocal&#13;
<span class="codeitalic1">--snip--</span>&#13;
config.status: executing tests/atconfig commands&#13;
-------------------------------------------------&#13;
&#13;
Jupiter Version 1.0&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">make check</span>&#13;
<span class="codeitalic1">--</span><span class="codeitalic1">snip--</span>&#13;
Making check in tests&#13;
make[1]: Entering directory '/.../jupiter/tests'&#13;
make    check-local&#13;
make[2]: Entering directory '/.../jupiter/tests'&#13;
:;{ \&#13;
  echo '# Signature of the current package.' &amp;&amp; \&#13;
  echo 'm4_define([AT_PACKAGE_NAME], [Jupiter])' &amp;&amp; \&#13;
  echo 'm4_define([AT_PACKAGE_TARNAME], [jupiter])' &amp;&amp; \&#13;
  echo 'm4_define([AT_PACKAGE_VERSION], [1.0])' &amp;&amp; \&#13;
  echo 'm4_define([AT_PACKAGE_STRING], [Jupiter 1.0])' &amp;&amp; \&#13;
  echo 'm4_define([AT_PACKAGE_BUGREPORT], [jupiter-bugs@example.org])'; \&#13;
  echo 'm4_define([AT_PACKAGE_URL], [])'; \&#13;
} &gt;'tests/package.m4'&#13;
/bin/bash ../missing --run autom4te --language=autotest \&#13;
    -I '.' -o testsuite.tmp testsuite.at&#13;
mv testsuite.tmp testsuite&#13;
/bin/bash './testsuite'&#13;
<span epub:type="pagebreak" id="page_248"/>## ----------------------- ##&#13;
## Jupiter 1.0 test suite. ##&#13;
## ----------------------- ##&#13;
&#13;
## ------------- ##&#13;
## Test results. ##&#13;
## ------------- ##&#13;
&#13;
0 tests were successful.&#13;
<span class="codeitalic1">--snip--</span>&#13;
$</pre>&#13;
<p class="indent">We can see from the output of <span class="literal">configure</span> that our generated files were created in the <em>tests</em> directory, as expected. It also appears that the code generated by <span class="literal">AC_CONFIG_TESTDIR</span> has wired in the generation of the <em>tests/atconfig</em> file as a <em>command</em> tag, rather than as a simple template file, using <span class="literal">AC_CONFIG_COMMANDS</span> internally.</p>&#13;
<p class="indent">We then see from the output of <span class="literal">make check</span> that <span class="literal">testsuite</span> was both built and executed. We can’t yet incorporate <span class="literal">testsuite</span> into a distribution archive from the <span class="literal">dist</span> or <span class="literal">distcheck</span> targets because we haven’t wired our autotest functionality into Automake. However, when we complete our changes at the end of this chapter, you’ll find that running <span class="literal">make check</span> against the contents of a distribution archive will not build <span class="literal">testsuite</span>, as it will have shipped with the archive (assuming we haven’t touched any of <span class="literal">testsuite</span>’s dependencies).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>One interesting item of note near the top of the <em><span class="literal">make check</span></em> output is highlighted by the lines starting with <em><span class="literal">make[1]:</span></em> and <em><span class="literal">make[2]:</span></em>, where <em><span class="literal">make</span></em> indicates it’s entering the jupiter/tests directory twice. This happens because of the <em><span class="literal">check-local</span></em> hook we added, where the <em><span class="literal">check</span></em> target recursively invokes <em><span class="literal">$(MAKE) check-local</span></em> as a command within the same directory.</em></p>&#13;
</div>&#13;
<p class="indent">Great, it works—with <span class="literal">make check</span> anyway. But it doesn’t do anything yet except print a few extra lines of text to the console. To make it do something useful, we need to add some tests. Therefore, our first task will be to move the original Automake-based <span class="literal">jupiter</span> execution test from <em>src/Makefile.am</em> into our autotest test suite.</p>&#13;
<h3 class="h3" id="ch09sec3">Adding a Test</h3>&#13;
<p class="noindent">Autotest tests are bundled into sets called <em>test groups</em>. The purpose of a test group is to allow tests within a group to interact with each other. For example, the first test in a group may generate some data files used by subsequent tests within the same group.</p>&#13;
<p class="indent">Tests that interact with each other are harder to debug, and broken tests are harder to reproduce if they require other tests to run first. Multi-test groups are hard to avoid when striving for full coverage; the ideal is to <span epub:type="pagebreak" id="page_249"/>have only one test per test group as much as possible. Where you just can’t do it, test groups exist to facilitate the required interaction. The crux of this facility is that <em>tests within the same test group are executed within the same temporary directory</em>, allowing initial tests to generate files that subsequent tests can then see and access.</p>&#13;
<p class="indent">Our single test will not suffer from these problems—mainly because we haven’t yet put much effort into testing Jupiter (and, if we’re honest with ourselves, there isn’t much actual code to test). Right now, when you execute <span class="literal">make check</span>, you see two sets of test output on the screen:</p>&#13;
<pre>   $ <span class="codestrong1">make check</span>&#13;
   <span class="codeitalic1">--snip--</span>&#13;
<span class="ent">➊</span> make    check-TESTS&#13;
   make[2]: Entering directory '/.../jupiter/src'&#13;
   make[3]: Entering directory '/.../jupiter/src'&#13;
   PASS: greptest.sh&#13;
   ============================================================================&#13;
   Testsuite summary for Jupiter 1.0&#13;
   ============================================================================&#13;
   # TOTAL: 1&#13;
   # PASS:    1&#13;
   # SKIP:    0&#13;
   # XFAIL: 0&#13;
   # FAIL:    0&#13;
   # XPASS: 0&#13;
   # ERROR: 0&#13;
   <span class="codeitalic1">--snip--</span>&#13;
<span class="ent">➋</span> Making check in tests&#13;
   make[1]: Entering directory '/.../jupiter/tests'&#13;
   make    check-local&#13;
   make[2]: Entering directory '/.../jupiter/tests'&#13;
   /bin/bash './testsuite'&#13;
   ## ----------------------- ##&#13;
   ## Jupiter 1.0 test suite. ##&#13;
   ## ----------------------- ##&#13;
&#13;
   ## ------------- ##&#13;
   ## Test results. ##&#13;
   ## ------------- ##&#13;
&#13;
   0 tests were successful.&#13;
   <span class="codeitalic1">--snip</span><span class="codeitalic1">--</span>&#13;
   $</pre>&#13;
<p class="indent">The first set of tests (beginning at <span class="ent">➊</span>) are executed in the <em>jupiter/src</em> directory. This is our original <span class="literal">grep</span>-based test where we check <span class="literal">jupiter</span>’s output against a pattern. As you can see, the basic test framework built into Automake is not bad. We’re hoping to improve on that framework with autotest. The second set of tests (beginning at <span class="ent">➋</span>) are executed in the <em>jupiter/tests</em> directory and involve autotest.</p>&#13;
<h4 class="h4" id="ch09sec3-1"><span epub:type="pagebreak" id="page_250"/>Defining Tests with AT_CHECK</h4>&#13;
<p class="noindent">The <span class="literal">grep</span>-based test we’ve been using in <em>src/Makefile.am</em> is a perfect example for use in the <span class="literal">AT_CHECK</span> macro provided by the autotest framework. Here are the prototypes for the <span class="literal">AT_CHECK</span> family of macros:</p>&#13;
<pre>AT_CHECK(<span class="codeitalic1">commands</span>, [<span class="codeitalic1">status</span> = '0'], [<span class="codeitalic1">stdout</span>], [<span class="codeitalic1">stderr</span>], [<span class="codeitalic1">run-if-fail</span>], [<span class="codeitalic1">run-if-pass</span>])&#13;
AT_CHECK_UNQUOTED(<span class="codeitalic1">commands</span>, [<span class="codeitalic1">status</span> = '0'], [<span class="codeitalic1">stdout</span>], [<span class="codeitalic1">stderr</span>], [<span class="codeitalic1">run-if-fail</span>], [<span class="codeitalic1">run-if-pass</span>])</pre>&#13;
<p class="indent"><span class="literal">AT_CHECK</span> executes <em><span class="literal">commands</span></em>, checks the returned status against <em><span class="literal">status</span></em>, and compares the output on <span class="literal">stdout</span> and <span class="literal">stderr</span> with the contents of the <em><span class="literal">stdout</span></em> and <em><span class="literal">stderr</span></em> macro arguments. If <em><span class="literal">status</span></em> is omitted, autotest assumes a successful status code of zero. If <em><span class="literal">commands</span></em> returns a status code to the shell that does not match the expected status code specified in <em><span class="literal">status</span></em>, the test fails. In order to ignore the status code of <em><span class="literal">commands</span></em>, you should use the special command <span class="literal">ignore</span> in the <em><span class="literal">status</span></em> parameter.</p>&#13;
<p class="indent">Regardless, there are a couple of status codes that even <span class="literal">ignore</span> will not ignore: a status code of 77 (skip) returned by <em><span class="literal">commands</span></em> will cause autotest to skip the rest of the tests in the current test group, while 99 (hard failure) will cause autotest to fail the entire test group immediately.</p>&#13;
<p class="indent">Like <em><span class="literal">status</span></em>, the <em><span class="literal">stdout</span></em> and <em><span class="literal">stderr</span></em> parameters appear to be optional, but looks can be deceiving. If you pass nothing in these arguments, this merely tells Autoconf that the test’s <span class="literal">stdout</span> and <span class="literal">stderr</span> output streams are expected to be empty. Anything else will fail the test. So how do we tell autotest we don’t want to check the output? As with <em><span class="literal">status</span></em>, we can use special commands in <em><span class="literal">stdout</span></em> or <em><span class="literal">stderr</span></em>, including those shown in <a href="ch09.xhtml#ch09tab1">Table 9-1</a>:</p>&#13;
<p class="tabcap" id="ch09tab1"><strong>Table 9-1:</strong> Special Commands Allowed in <em><span class="literal">stdout</span></em> and <em><span class="literal">stderr</span></em> Arguments.</p>&#13;
<table class="topbot-d1">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Command</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">ignore</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Do not check this output stream, but do log it to the test group’s log file.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">ignore-no-log</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Do not check or log this output stream.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">stdout</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Log and capture the test’s <span class="literal">stdout</span> output to the file <span class="literal">stdout</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">stderr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Log and capture the test’s <span class="literal">stderr</span> output to the file <span class="literal">stderr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">stdout-nolog</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Capture the test’s <span class="literal">stdout</span> output to the file <span class="literal">stdout</span>, but do not log.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">stderr-nolog</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Capture the test’s <span class="literal">stderr</span> output to the file <span class="literal">stderr</span>, but do not log.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">expout</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Compare the test’s <span class="literal">stdout</span> output to the file <span class="literal">expout</span>, created earlier; log the differences.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">experr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Compare the test’s <span class="literal">stderr</span> output to the file <span class="literal">experr</span>, created earlier; log the differences.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The <em><span class="literal">run-if-fail</span></em> and <em><span class="literal">run-if-pass</span></em> arguments allow you to optionally specify shell code that should be executed upon test failure or success, respectively.</p>&#13;
<p class="indent"><span class="literal">AT_CHECK_UNQUOTED</span> does exactly the same thing as <span class="literal">AT_CHECK</span>, except that it performs shell expansion on <em><span class="literal">stdout</span></em> and <em><span class="literal">stderr</span></em> first, before making the comparison with the output of <em><span class="literal">commands</span></em>. Since <span class="literal">AT_CHECK</span> doesn’t do shell expansion on <em><span class="literal">stdout</span></em> and <em><span class="literal">stderr</span></em>, it stands to reason that you need to use <span class="literal">AT_CHECK_UNQUOTED</span> if you reference any shell variables in the text of these parameters.</p>&#13;
<h4 class="h4" id="ch09sec3-2"><span epub:type="pagebreak" id="page_251"/>Defining Test Groups with AT_SETUP and AT_CLEANUP</h4>&#13;
<p class="noindent">The <span class="literal">AT_CHECK</span> macro must be invoked between invocations of <span class="literal">AT_SETUP</span> and <span class="literal">AT_CLEANUP</span>, the pair of which define a test group and, therefore, the temporary directory from which the tests in the group are executed. The prototypes for these macros are defined as follows:</p>&#13;
<pre>AT_SETUP(<span class="codeitalic1">test-group-name</span>)&#13;
AT_CLEANUP</pre>&#13;
<p class="indent">If you’ve got any experience with the <em>xUnit</em> family of unit test frameworks (JUnit, NUnit, CPPUnit, and so on), you’ve probably got a pretty strong notion of what the setup and cleanup (or teardown) functions should be used for. Usually a <em>setup</em> function runs some common code before each test in a test set, and a <em>cleanup</em> or <em>teardown</em> function executes some common code at the end of each test in the set.</p>&#13;
<p class="indent">Autotest is a bit different—there is no formal setup or teardown functionality shared by tests belonging to the same group (although this sort of functionality can be emulated with shell functions defined within the test group in <em>testsuite.at</em>, or in its included subfiles). As with <em>xUnit</em> frameworks, Autotest runs every test in total isolation, because every test runs within its own subshell. The only way a test can affect a subsequent test is by sharing the same test group and leaving filesystem droppings around for subsequent tests to examine and act upon.</p>&#13;
<p class="indent"><span class="literal">AT_SETUP</span> accepts only one argument, <em><span class="literal">test-group-name</span></em>, which is the name of the test group that we’re starting, and this argument is required. <span class="literal">AT_CLEANUP</span> accepts no arguments.</p>&#13;
<p class="indent">We’ll add the group setup and cleanup macro invocations, wrapping a call to <span class="literal">AT_CHECK</span>, to a new file, <em>tests/jupiter.at</em>, as shown in <a href="ch09.xhtml#ch09ex7">Listing 9-7</a>.</p>&#13;
<p class="margin">Git tag 9.1</p>&#13;
<pre>AT_SETUP([jupiter-execution])&#13;
AT_CHECK([../src/jupiter],,[Hello from ../src/.libs/lt-jupiter!])&#13;
AT_CLEANUP</pre>&#13;
<p class="caption" id="ch09ex7"><em>Listing 9-7:</em> tests/jupiter.at: <em>Adding our first test group—attempt #1</em></p>&#13;
<p class="indent">Libtool adds a wrapper script in the <em>src</em> directory for any executables that use Libtool shared libraries. This wrapper script allows <span class="literal">jupiter</span> to find the uninstalled Libtool libraries it’s trying to use. As mentioned in <a href="ch07.xhtml">Chapter 7</a>, it’s a convenience mechanism that Libtool provides so we don’t have to jump through hoops to test programs using Libtool shared libraries before they’re installed.</p>&#13;
<p class="indent">The end result is that the <em>src/jupiter</em> script is executing the real <span class="literal">jupiter</span> program from <em>src/.libs/lt-jupiter</em>. Because <span class="literal">jupiter</span> displays its own location, based on its <span class="literal">argv[0]</span> contents, we need to expect it to print this path.</p>&#13;
<p class="indent">We then need to add an <span class="literal">m4_include</span> statement to our currently empty <em>testsuite.at</em> file in order to include <em>jupiter.at</em>, as shown in <a href="ch09.xhtml#ch09ex8">Listing 9-8</a>.</p>&#13;
<pre>m4_include([jupiter.at])</pre>&#13;
<p class="caption" id="ch09ex8"><em>Listing 9-8:</em> tests/testsuite.at: <em>Including</em> jupiter.at <em>in</em> testsuite.at</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_252"/>We’ll also want to add this new source file to our <em>tests/Makefile.am</em> file’s <span class="literal">TESTSOURCES</span> variable so it becomes a prerequisite of <span class="literal">testsuite</span>, as shown in <a href="ch09.xhtml#ch09ex9">Listing 9-9</a>.</p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">TESTSUITE = $(srcdir)/testsuite</span>&#13;
<span class="ash">TESTSOURCES = $(srcdir)/local.at $(srcdir)/testsuite.at</span> \&#13;
   $(srcdir)/jupiter.at&#13;
<span class="ash">AUTOM4TE = $(SHELL) $(top_srcdir)/missing --run autom4te</span>&#13;
<span class="ash">AUTOTEST = $(AUTOM4TE) --language=autotest</span>&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption" id="ch09ex9"><em>Listing 9-9:</em> tests/Makefile.am: <em>Adding additional sources to <span class="literal">TESTSOURCES</span></em></p>&#13;
<p class="indent">We’ll follow this practice for every test we add to our test suite. In the end, the only thing in <em>testsuite.at</em> will be several invocations of <span class="literal">m4_include</span>, one for each test group. Executing this code renders the following output:</p>&#13;
<pre>$ <span class="codestrong1">autoreconf -i</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">./configure</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">make check</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
/bin/bash './testsuite'&#13;
## ----------------------- ##&#13;
## Jupiter 1.0 test suite. ##&#13;
## ----------------------- ##&#13;
  1: jupiter-execution                                FAILED (jupiter.at:2)&#13;
&#13;
## ------------- ##&#13;
## Test results. ##&#13;
## ------------- ##&#13;
&#13;
ERROR: 1 test was run,&#13;
1 failed unexpectedly.&#13;
## -------------------------- ##&#13;
## testsuite.log was created. ##&#13;
## -------------------------- ##&#13;
&#13;
Please send `tests/testsuite.log' and all information you think might help:&#13;
&#13;
   To: &lt;jupiter-bugs@example.org&gt;&#13;
   Subject: [Jupiter 1.0] testsuite: 1 failed&#13;
&#13;
You may investigate any problem if you feel able to do so, in which&#13;
case the test suite provides a good starting point. Its output may&#13;
be found below `tests/testsuite.dir'.&#13;
<span class="codeitalic1">--snip--</span>&#13;
$</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_253"/><em>Running <span class="literal">autoreconf</span> and <span class="literal">configure</span> was required only because we updated the</em> tests/Makefile.am <em>file. If we’d just touched an existing .at file, which is rebuilt by the <span class="literal">check</span> target in</em> tests/Makefile, <em>then neither <span class="literal">autoreconf</span> nor <span class="literal">configure</span> would have been necessary.</em></p>&#13;
</div>&#13;
<p class="indent">I’ll admit here that our single test failed because I deliberately coded the test incorrectly in order to show you what a failed test looks like.</p>&#13;
<p class="indent">Although not obvious from the output, there is more than one <em>testsuite.log</em> file created by <span class="literal">testsuite</span> when tests fail. The first is a master <em>testsuite.log</em> file in the <em>tests</em> directory, which is always created, even when all tests pass, and is designed to be sent in bug reports to the project maintainer. There is also a log file of the same name in a separate numbered directory within the <em>tests/testsuite.dir</em> directory for failed tests. The name of each of these directories is the number of the test group that failed. The test group number can be seen in the output. While you only need the master <em>testsuite.log</em> file, since it contains the entire contents of all of the individual tests’ <em>testsuite.log</em> files, this file also contains a lot of other information about your project and the test environment that the maintainer would want to see but just gets in the way for our purposes here.</p>&#13;
<p class="indent">To see exactly how our test failed, let’s examine the contents of the <em>testsuite</em><em>.log</em> file left in the <em>tests/testsuite.dir/1</em> directory:</p>&#13;
<pre>$ <span class="codestrong1">cat tests/testsuite.dir/1/testsuite.log</span>&#13;
#                             -*- compilation -*-&#13;
1. jupiter.at:1: testing jupiter-execution ...&#13;
./jupiter.at:2: ../src/jupiter <span class="ent">➊</span>&#13;
--- /dev/null     2018-04-21 17:27:23.475548806 -0600 <span class="ent">➋</span>&#13;
+++ /.../jupiter/tests/testsuite.dir/at-groups/1/stderr 2018-06-01 16:08:04.391926296 -0600&#13;
@@ -0,0 +1 @@&#13;
+/.../jupiter/tests/testsuite.dir/at-groups/1/test-source: line 11: ../src/jupiter: <span class="ent">➌</span>&#13;
    No such file or directory&#13;
--- -     2018-06-01 16:08:04.399436755 -0600 <span class="ent">➍</span>&#13;
+++ /.../jupiter/tests/testsuite.dir/at-groups/1/stdout 2018-06-01 16:08:04.395926314 -0600&#13;
@@ -1 +1 @@&#13;
-Hello from ../src/.libs/lt-jupiter!&#13;
+&#13;
./jupiter.at:2: exit code was 127, expected 0 <span class="ent">➎</span>&#13;
1. jupiter.at:1: 1. jupiter-execution (jupiter.at:1): FAILED (jupiter.at:2)&#13;
$</pre>&#13;
<p class="indent">First note that autotest writes, as often as possible, the related source line into the <em>testsuite.log</em> file. This isn’t a big win for us at this point, but if <em>testsuite.at</em> or its included files were long and complicated, you can see how this information could be very helpful.</p>&#13;
<p class="indent">At <span class="ent">➊</span>, we see the argument we passed to the <em><span class="literal">commands</span></em> parameter of <span class="literal">AT_CHECK</span>, along with the number of the line at which this argument was passed to the macro in <em>jupiter.at</em>.</p>&#13;
<p class="indent">However, now things start to get a bit muddy. The entire point of the <em><span class="literal">stdout</span></em> and <em><span class="literal">stderr</span></em> arguments in <span class="literal">AT_CHECK</span> is to provide some comparison text for what is actually sent by the <em><span class="literal">commands</span></em> to these output streams. In <span epub:type="pagebreak" id="page_254"/>accordance with the general Unix philosophy of not duplicating existing functionality, the autotest authors chose to use the <span class="literal">diff</span> utility to make these comparisons. The log lines from <span class="ent">➋</span> to <span class="ent">➌</span> (inclusive) show the <em>unified</em><sup><a id="ch09fn_4" href="footnote.xhtml#ch09fn4">4</a></sup> output of the <span class="literal">diff</span> utility when comparing the <em>original</em> file (<em>/dev/null</em> since we passed no value in the <em><span class="literal">stderr</span></em> argument) to the <em>modified</em> file—the text sent to the <span class="literal">stderr</span> output stream during the attempt to execute <em>../src/jupiter</em>.</p>&#13;
<p class="indent">If you’re not familiar with unified <span class="literal">diff</span> output, a brief explanation is in order. The two lines starting at <span class="ent">➋</span> indicate the objects being compared. The original, or minus (<span class="literal">---</span>), line indicates the left side of the comparison, while the modified, or plus (<span class="literal">+++</span>), line indicates the right side of the comparison. Here, we’re comparing <em>/dev/null</em> with a temporary file called <em>/.../jupiter/tests/testsuite.dir/at-groups/1/stderr</em> that was used by autotest to capture the <span class="literal">stderr</span> stream during the attempt to execute <em>../src/jupiter</em>.</p>&#13;
<p class="indent">The next line, starting and ending with <span class="literal">@@</span>, is a <em>chunk</em> marker—<span class="literal">diff</span>’s way of telling us about a portion of the two files that does not match. There can be more than one chunk in the output displayed by <span class="literal">diff</span>. In this case, the entire output text is so short that only one chunk was required to show us the differences.</p>&#13;
<p class="indent">The numbers in the chunk marker represent two ranges, separated by a space. The first range starts with a minus (<span class="literal">-</span>) sign, indicating the range associated with the <em>original</em> file, and the second range starts with a plus (<span class="literal">+</span>) sign, indicating the range associated with the <em>modified</em> file. Here’s the line we’re currently discussing:</p>&#13;
<pre>@@ -0,0 +1 @@</pre>&#13;
<p class="indent">A range is made up of two integer values separated by a comma (<span class="literal">,</span>) or a single value with a default second value of 1. In this example, the range being compared starts at zero in the original file and is zero lines long, while the comparison range in the second file starts at line 1 and is one line long. These ranges are 1-based, meaning line 1 is the first line in the file. Therefore, the first range specification, <span class="literal">-0,0</span>, is a special range that means there’s no content in the file.</p>&#13;
<p class="indent">The lines following the range specification contain the full text of these ranges, showing us the actual differences. The original file lines are printed first, each prefixed with a minus sign, and then the modified file lines are printed afterward, each prefixed with a plus sign. When there is enough content around the modified lines to do so, additional unprefixed lines are added before and after these lines, showing some context around the changes. In this case, the entire content of this section is:</p>&#13;
<pre>+/.../jupiter/tests/testsuite.dir/at-groups/1/test-source: line 11: ../src/jupiter:&#13;
  No such file or directory</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_255"/>Since the original file was empty, as indicated by the <span class="literal">-0,0</span> range in the chunk marker, there are no lines starting with minus. All we see is the one modified file line starting with a plus.</p>&#13;
<p class="indent">Well, clearly these files are not the same—we expected nothing on the <span class="literal">stderr</span> stream, but we got some error text instead. The shell experienced an error attempting to execute <em>../src/jupiter</em>—it could not be found. If you try this at the shell prompt, you’ll see the following output:</p>&#13;
<pre>$ <span class="codestrong1">../src/jupiter</span>&#13;
bash: ../src/jupiter: No such file or directory&#13;
$</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Obviously you should not do this from the</em> tests <em>directory, or any other directory that’s a sibling to the</em> src <em>directory, or it’ll actually find</em> jupiter <em>(if it’s been built) rather than print this error.</em></p>&#13;
</div>&#13;
<p class="indent">If you put this line into a shell script called (arbitrarily) <em>abc.sh</em> and execute the script on the <span class="literal">bash</span> command line, you’ll see output that matches the format shown in <em>testsuite.log</em>:</p>&#13;
<pre>$ <span class="codestrong1">bash abc.sh</span>&#13;
abc.sh: line 2: ../src/jupiter: No such file or directory&#13;
$</pre>&#13;
<p class="indent">We can see at <span class="ent">➎</span> in <em>testsuite.log</em> that the shell returned a 127 status code, indicating an error of some sort. The value 127 is used by the shell to indicate execution errors—file not found or file not executable.</p>&#13;
<p class="indent">To be complete, let’s also consider the lines between <span class="ent">➍</span> and <span class="ent">➎</span> for a moment. This is the unified <span class="literal">diff</span> output seen when comparing the text specified in <span class="literal">AT_CHECK</span>’s <em><span class="literal">stdout</span></em> argument with what was actually written to <span class="literal">stdout</span> by <span class="literal">jupiter</span> (actually the shell, since we know <em>../src/jupiter</em> was not found). In this case, we see that the minus text is the original comparison text we specified and the plus text is a single newline character, as this is what the shell sent to <span class="literal">stdout</span>. The chunk marker range specification, fully expanded, would be:</p>&#13;
<pre>@@ -1,1 +1,1 @@</pre>&#13;
<p class="indent">There was one line of text in each of the original and modified sources to be compared, but, as we can see by the output, the text in these sources was completely different.</p>&#13;
<h4 class="h4" id="ch09sec3-3"><em>So What Happened?</em></h4>&#13;
<p class="noindent">This first attempt assumed that the <span class="literal">jupiter</span> program (or, rather, the Libtool wrapper script) is found at <em>../src/jupiter</em>, relative to the <em>tests</em> directory. While this assumption is true, I’ve already alluded to the fact that each test group is executed in its own temporary directory, so it makes perfect sense that this relative path is not going to work from another directory. Even if we <span epub:type="pagebreak" id="page_256"/>figured out, by trial and error, how many parent directory references to use, it would be quite fragile; if we ran <span class="literal">testsuite</span> from a different directory, it would fail because it depends so intimately on running from a specific position relative to the <span class="literal">jupiter</span> program.</p>&#13;
<p class="indent">Let’s try a different tack. We’ll make use of the variables generated by <span class="literal">configure</span> into <em>atconfig</em>. One of them, <span class="literal">abs_top_builddir</span>, contains the absolute path to the top build directory. Therefore, we should be able to successfully reference <span class="literal">jupiter</span> from anywhere using <span class="literal">${abs_top_builddir}</span><em>/src/jupiter</em>.</p>&#13;
<p class="indent">But now we have another problem: <span class="literal">jupiter</span> prints its own path and we’ve just decided to obtain that path using a shell variable, so we’ll also need to change the comparison text to use this variable, as well. This change, however, causes yet another issue—we’ll need to change <span class="literal">AT_CHECK</span> to <span class="literal">AT_CHECK_UNQUOTED</span> if we expect that shell variable in <span class="literal">AT_CHECK</span>’s <em><span class="literal">stdout</span></em> parameter to be expanded before the macro makes the comparison. Let’s make these modifications by changing <em>jupiter.at</em> as shown in <a href="ch09.xhtml#ch09ex10">Listing 9-10</a>.</p>&#13;
<p class="margin">Git tag 9.2</p>&#13;
<pre><span class="ash">AT_SETUP([jupiter-execution])</span>&#13;
<span class="codestrong1">AT_CHECK_UNQUOTED(["${abs_top_builddir}"/src/jupiter],,&#13;
                  [Hello from ${abs_top_builddir}/src/.libs/lt-jupiter!&#13;
])</span>&#13;
<span class="ash">AT_CLEANUP</span></pre>&#13;
<p class="caption" id="ch09ex10"><em>Listing 9-10:</em> tests/jupiter.at: <em>Adding our first test group—attempt #2</em></p>&#13;
<p class="indent">Here, we’ve switched to using <span class="literal">AC_CHECK_UNQUOTED</span>, and we’ve changed both the <span class="literal">jupiter</span> program path in the first argument and the comparison text in the third argument to use the <span class="literal">abs_top_builddir</span> variable we inherit from <em>atconfig</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The newline at the end of the <em><span class="literal">stdout</span></em> argument is intentional and explained shortly.</em></p>&#13;
</div>&#13;
<p class="indent">Let’s try it out:</p>&#13;
<pre>$ <span class="codestrong1">make check</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
/bin/bash './testsuite'&#13;
## ----------------------- ##&#13;
## Jupiter 1.0 test suite. ##&#13;
## ----------------------- ##&#13;
  1: jupiter-execution                               ok&#13;
&#13;
## ------------- ##&#13;
## Test results. ##&#13;
## ------------- ##&#13;
&#13;
1 test was successful.&#13;
<span class="codeitalic1">--snip--</span>&#13;
$</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_257"/>Once again, I only had to run <span class="literal">make</span>. Even though our changes were dramatic, affecting even the macros we called in the test suite, remember that the entire test suite is generated from <span class="literal">make check</span>. The only time we need to execute <span class="literal">autoreconf</span> and <span class="literal">configure</span> is if we make changes to <em>configure.ac</em> or any of the templates from which it generates files used by <span class="literal">make check</span>, or if we make any changes to <em>Makefile.am</em> files.</p>&#13;
<p class="indent">This attempt had much better results, but what’s with that extra newline at the end of our comparison text in <a href="ch09.xhtml#ch09ex10">Listing 9-10</a>? Well, remember what it is that we’re sending to <span class="literal">stdout</span> from <span class="literal">jupiter</span>. <a href="ch09.xhtml#ch09ex11">Listing 9-11</a> provides a reminder.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
    printf("Hello from %s!\n", (const char *)data);&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch09ex11"><em>Listing 9-11:</em> common/print.c: <em>What <span class="literal">jupiter</span> sends to <span class="literal">stdout</span></em></p>&#13;
<p class="indent">The comparison text is an exact duplicate of what we expect to find on <span class="literal">jupiter</span>’s <span class="literal">stdout</span>, so we’d better be sure to include every character we write; the trailing newline is part of that data stream.</p>&#13;
<p class="indent">It’s probably a good idea at this point to remove the <em>src/Makefile.am</em> code that builds and runs the Automake version of the test. Change <em>src/Makefile.am</em> as shown in <a href="ch09.xhtml#ch09ex12">Listing 9-12</a>.</p>&#13;
<pre><span class="ash">SUBDIRS = modules/hithere</span>&#13;
&#13;
<span class="ash">bin_PROGRAMS = jupiter</span>&#13;
<span class="ash">jupiter_SOURCES = main.c module.h</span>&#13;
<span class="ash">jupiter_CPPFLAGS = -I$(top_srcdir)/include</span>&#13;
<span class="ash">jupiter_LDADD = ../libjup/libjupiter.la -dlopen modules/hithere/hithere.la</span></pre>&#13;
<p class="caption" id="ch09ex12"><em>Listing 9-12:</em> src/Makefile.am: <em>The updated full contents of this file after removing tests</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>All we did here was remove the test-related lines from the bottom half of the file.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch09sec4">Unit Testing vs. Integration Testing</h3>&#13;
<p class="noindent">On the whole, the autotest version is not much better than what we had when our test was being executed by Automake’s test framework in <em>src/Makefile.am</em>. Adding new tests is, however, a bit simpler than what we’d have to do in <em>src/Makefile.am</em>’s <span class="literal">TESTS</span> variable. In fact, the only way the Automake version becomes simpler is if we actually write test programs and build them in <span class="literal">check</span> primaries. We might still have to build test programs in <span class="literal">check</span> primaries, but calling them and validating their output is trivial when using autotest.</p>&#13;
<p class="indent">If you’re thinking that it feels like autotest is more attuned to system and integration testing than unit testing, you’re pretty close to the mark. Autotest <span epub:type="pagebreak" id="page_258"/>is designed to test your project from the outside, but it’s not limited to such tests. Anything you can call from the command line can be a test, from autotest’s perspective. What autotest actually offers you is a framework for generating uniform test output, regardless of the kind of tests you’re using.</p>&#13;
<p class="indent">One approach to unit testing that I’ve used for years involves writing test programs where the main source module of my test program literally <span class="literal">#include</span>s the <em>.c</em> file I’m testing. This gives me the option of calling static methods within the module under test and provides direct access to internal structures defined within that module.<sup><a id="ch09fn_5" href="footnote.xhtml#ch09fn5">5</a></sup> This approach is pretty C oriented, but other languages have their own ways of performing the same sort of tricks. The idea is to create a test program that can reach into the private parts of a module and exercise functionality in small chunks. When you put those chunks together, you can feel confident that the individual chunks are working as designed; if there’s a problem, it’s probably in the way you glued them together.</p>&#13;
<p class="indent">Let’s add some unit testing to Jupiter by creating a test module that tests the functions in the <em>common/print.c</em> module. Create a file called <em>test_print.c</em> in the <em>common</em> directory that contains the content in <a href="ch09.xhtml#ch09ex13">Listing 9-13</a>.</p>&#13;
<p class="margin">Git tag 9.3</p>&#13;
<pre>#define printf mock_printf&#13;
#include "print.c"&#13;
&#13;
#include &lt;stdarg.h&gt;&#13;
#include &lt;string.h&gt;&#13;
&#13;
static char printf_buf[512];&#13;
&#13;
int mock_printf(const char * format, ... )&#13;
{&#13;
    int rc;&#13;
    va_list ap;&#13;
    va_start(ap, format);&#13;
    rc = vsnprintf(printf_buf, sizeof printf_buf, format, ap);&#13;
    va_end(ap);&#13;
    return rc;&#13;
}&#13;
&#13;
int main(void)&#13;
{&#13;
    const char *args[] = { "Hello", "test" };&#13;
    int rc = print_it(args);&#13;
    return rc != 0 || strcmp(printf_buf, "Hello from test!\n") != 0;&#13;
}</pre>&#13;
<p class="caption" id="ch09ex13"><em>Listing 9-13:</em> common/test_print.c: <em>A unit test program for the print.c module</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_259"/>The first line uses the preprocessor to rename any calls to <span class="literal">printf</span> to <span class="literal">mock_printf</span>. The second line then uses the preprocessor to <span class="literal">#include</span> <em>print.c</em> directly into <em>test_print.c</em>. Now, any calls to <span class="literal">printf</span> inside of <em>print.c</em> will be redefined to call <span class="literal">mock_printf</span> instead—including any prototypes defined in system header files like <em>stdio.h</em>.<sup><a id="ch09fn_6" href="footnote.xhtml#ch09fn6">6</a></sup></p>&#13;
<p class="indent">The idea here is to verify that the <span class="literal">print_it</span> function actually prints <em>Hello from</em> <span class="literal">argument</span><em>!\n</em> and returns zero to the caller. We don’t need any output—a shell return code is sufficient for this test to indicate to the user that <span class="literal">print_it</span> is working as designed.</p>&#13;
<p class="indent">Neither do we need this module’s <span class="literal">main</span> routine to accept any command line arguments. If we had several tests in here, however, it might be convenient to accept some sort of argument that allows us to tell the code which test we want to run.</p>&#13;
<p class="indent">All we’re really doing here is directly calling <span class="literal">print_it</span> with a short string and then attempting to verify that <span class="literal">print_it</span> returned zero and actually passed what we expected to <span class="literal">printf</span>. Note that <span class="literal">print_it</span> is a static function, which should make it inaccessible to other modules, but because we’re including <em>print.c</em> at the top of <em>test_print.c</em>, we’re effectively combining both source files into a single translation unit.</p>&#13;
<p class="indent">Now, let’s write the build code for this test program. First, we need to add some lines to <em>common/Makefile.am</em> so that a <span class="literal">test_print</span> program gets built when we run <span class="literal">make check</span>. Modify <em>common/Makefile.am</em> as shown in <a href="ch09.xhtml#ch09ex14">Listing 9-14</a>.</p>&#13;
<pre><span class="ash">noinst_LIBRARIES = libjupcommon.la</span>&#13;
<span class="ash">libjupcommon_la_SOURCES = jupcommon.h print.c</span>&#13;
&#13;
check_PROGRAMS = test_print&#13;
test_print_SOURCES = test_print.c</pre>&#13;
<p class="caption" id="ch09ex14"><em>Listing 9-14:</em> common/Makefile.am: <em>Adding <span class="literal">test_print</span> as a <span class="literal">check_PROGRAM</span></em></p>&#13;
<p class="indent">When we make the <span class="literal">check</span> target, we’ll now get a new program, <span class="literal">test_print</span>, in the <em>common</em> directory. Now we need to add a call to this program to our test suite. Create a new file in <em>tests</em> called <em>print.at</em>, as shown in <a href="ch09.xhtml#ch09ex15">Listing 9-15</a>.</p>&#13;
<pre>AT_SETUP([print])&#13;
AT_CHECK(["${abs_top_builddir}/common/test_print"])&#13;
AT_CLEANUP</pre>&#13;
<p class="caption" id="ch09ex15"><em>Listing 9-15:</em> tests/print.at: <em>Adding the <span class="literal">print</span> test</em></p>&#13;
<p class="indent">We also need to add an <span class="literal">m4_include</span> statement for this test to <em>testsuite.at</em>, as in <a href="ch09.xhtml#ch09ex16">Listing 9-16</a>.</p>&#13;
<pre><span class="ash">m4_include([jupiter.at])</span>&#13;
m4_include([print.at])</pre>&#13;
<p class="caption" id="ch09ex16"><em>Listing 9-16:</em> tests/testsuite.at: <em>Adding print.at to testsuite.at</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_260"/>And finally, we need to add this new source file to the <span class="literal">TESTSOURCES</span> variable in <em>tests/Makefile.am</em>, as shown in <a href="ch09.xhtml#ch09ex17">Listing 9-17</a>.</p>&#13;
<pre><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">TESTSUITE = $(srcdir)/testsuite</span>&#13;
<span class="ash">TESTSOURCES = $(srcdir)/local.at $(srcdir)/testsuite.at \</span>&#13;
  <span class="ash">$(srcdir)/jupiter.at</span> $(srcdir)/print.at&#13;
<span class="ash">AUTOM4TE = $(SHELL) $(top_srcdir)/missing --run autom4te</span>&#13;
<span class="ash">AUTOTEST = $(AUTOM4TE) –language=autotest</span>&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption" id="ch09ex17"><em>Listing 9-17:</em> tests/Makefile.am: <em>Adding print.at to <span class="literal">TESTSOURCES</span></em></p>&#13;
<p class="indent">Since the <span class="literal">test_print</span> program only uses the shell status code to indicate an error, using it in <span class="literal">AT_CHECK</span> is as simple as it gets. You only need the first argument—the name of the program itself. If <span class="literal">test_print</span> had more than one test, you might accept a command line argument (within the same parameter) that indicates which test you want to run and then add several invocations of <span class="literal">AC_CHECK</span>, each running <span class="literal">test_print</span> with a different argument.</p>&#13;
<p class="indent">Notice that we’ve started a new test group—as I mentioned earlier, you should try hard to limit your test groups to a single test unless the nature of the tests are such that they work together on the same file-based data set.</p>&#13;
<p class="indent">Let’s give it a shot. Note that in order to run the new test, we really only need to make the <span class="literal">check</span> target to update and execute <span class="literal">testsuite</span>. However, since we added the <em>print.at</em> dependency to <em>tests/Makefile.am</em>, we should probably also run <span class="literal">autoreconf</span> and <span class="literal">configure</span>. Had we enabled maintainer mode, the extra maintainer-mode rules would have done this for us:</p>&#13;
<pre>$ <span class="codestrong1">autoreconf -i</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">./configure</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">make check</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
/bin/bash './testsuite'&#13;
## ----------------------- ##&#13;
## Jupiter 1.0 test suite. ##&#13;
## ----------------------- ##&#13;
  1: jupiter-execution                                                 ok&#13;
  2: print                                                             ok&#13;
&#13;
## ------------- ##&#13;
## Test results. ##&#13;
## ------------- ##&#13;
&#13;
All 2 tests were successful.&#13;
<span class="codeitalic1">--snip--</span>&#13;
$</pre>&#13;
<h3 class="h3" id="ch09sec5"><span epub:type="pagebreak" id="page_261"/>Administrative Details</h3>&#13;
<p class="noindent">I mentioned while describing the contents of <em>tests/Makefile.am</em> back near <a href="ch09.xhtml#ch09ex2">Listing 9-2</a> that we needed to add some additional infrastructure to that file in order to complete the tie-in with Automake. Let’s take care of those details now.</p>&#13;
<p class="indent">We’ve seen that <span class="literal">make</span> (<span class="literal">all</span>) and <span class="literal">make check</span> work just fine, building our products and building and executing our test suite. But we’ve neglected some of the other targets that Automake wires up for us—specifically, <span class="literal">installcheck</span>, <span class="literal">clean</span>, and distribution-related targets like <span class="literal">dist</span> and <span class="literal">distcheck</span>. There’s a general lesson to be considered here: whenever we add custom rules to <em>Makefile.am</em>, we need to consider the impact on the standard targets generated by Automake.</p>&#13;
<h4 class="h4" id="ch09sec5-1">Distributing Test Files</h4>&#13;
<p class="noindent">There are several generated files that need to be distributed. These files are not inherently known by Automake, and, therefore, Automake needs to be told explicitly about them. This is done with the Automake-recognized <span class="literal">EXTRA_DIST</span> variable, which we’ll add to the top of <em>tests/Makefile.am</em>, as shown in <a href="ch09.xhtml#ch09ex18">Listing 9-18</a>.</p>&#13;
<p class="margin">Git tag 9.4</p>&#13;
<pre>EXTRA_DIST = testsuite.at local.at jupiter.at print.at \&#13;
  $(TESTSUITE) atconfig package.m4&#13;
&#13;
<span class="ash">TESTSUITE = $(srcdir)/testsuite</span>&#13;
<span class="ash">TESTSOURCES = $(srcdir)/local.at $(srcdir)/testsuite.at \</span>&#13;
  <span class="ash">$(srcdir)/jupiter.at $(srcdir)/print.at</span>&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption" id="ch09ex18"><em>Listing 9-18:</em> tests/Makefile.am: <em>Ensuring test files get distributed with <span class="literal">EXTRA_DIST</span></em></p>&#13;
<p class="indent">Here, I’ve added all the test suite source files, including <em>testsuite.at</em>, <em>local.at</em>, <em>jupiter.at</em>, and <em>print.at</em>. I’ve also added the <span class="literal">testsuite</span> program and any input files we generated using a non-Automake mechanism. These include <em>atconfig</em>, which is generated by code provided by the <span class="literal">AC_CONFIG_TESTDIR</span> macro internally, and <em>package.m4</em>, which is generated by a custom rule we added earlier to this <em>Makefile.am</em> file. It’s important to understand here that adding files to <span class="literal">EXTRA_DIST</span> causes them to be built, if needed, when <span class="literal">make dist</span> is executed.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>I would have like to have just used <em><span class="literal">$(TESTSOURCES)</span></em> in <em><span class="literal">EXTRA_DIST</span></em>, but the sources in that variable were formatted for rules and commands. <em><span class="literal">EXTRA_DIST</span></em>, as interpreted by Automake, is designed to refer to a list of files relative to the current directory within the source tree.</em></p>&#13;
</div>&#13;
<p class="indent">As a reminder, we distribute <em>.at</em> files because the GNU General Public License says we must distribute the source code for our project and these files are the source code for <span class="literal">testsuite</span>, just as <em>configure.ac</em> is the source code <span epub:type="pagebreak" id="page_262"/>for <span class="literal">configure</span>. However, even if you’re not using the GPL, you should still consider shipping the preferred editing format of all files in your project; it is an open source project, after all.</p>&#13;
<h4 class="h4" id="ch09sec5-2"><em>Checking Installed Products</em></h4>&#13;
<p class="noindent">We wrote a <span class="literal">check</span> target; it’s probably a good idea to support the <em>GCS</em> <span class="literal">installcheck</span> target, which Automake also supports. This is done by adding the <span class="literal">installcheck-local</span> target to this <em>Makefile.am</em> file, as shown in <a href="ch09.xhtml#ch09ex19">Listing 9-19</a>.</p>&#13;
<pre><span class="codeitalic1a">--</span><span class="codeitalic1a">snip</span><span class="codeitalic1a">--</span>&#13;
<span class="ash">check-local: atconfig atlocal $(TESTSUITE)</span>&#13;
        <span class="ash">$(SHELL) '$(TESTSUITE)' $(TESTSUITEFLAGS)</span>&#13;
&#13;
installcheck-local: atconfig atlocal $(TESTSUITE)&#13;
        $(SHELL) '$(TESTSUITE)' AUTOTEST_PATH='$(DESTDIR)$(bindir)' $(TESTSUITEFLAGS)&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch09ex19"><em>Listing 9-19:</em> tests/Makefile.am: <em>Supporting installed-product testing</em></p>&#13;
<p class="indent">The only difference between <span class="literal">check-local</span> and <span class="literal">installcheck-local</span> is the addition of the <span class="literal">AUTOTEST_PATH</span> command line option to <span class="literal">testsuite</span>, pointing <span class="literal">testsuite</span> to the copy of <span class="literal">jupiter</span> found in <span class="literal">$(DESTDIR)$(bindir)</span>, where it was installed. <span class="literal">AUTOTEST_PATH</span> is prepended to the shell <span class="literal">PATH</span> variable before invoking <em><span class="literal">commands</span></em> in <span class="literal">AT_CHECK_UNQUOTED</span>; therefore, you could write test code that assumes <span class="literal">PATH</span> contains the path to an installed copy of <span class="literal">jupiter</span>. However, tests are designed to be executed on either installed or uninstalled programs, so it’s a good idea to continue deriving and using a full path to programs within your test commands.</p>&#13;
<p class="indent">Now we’ll need to make a decision. When the user types <span class="literal">make check</span>, they clearly mean to test the copy of <span class="literal">jupiter</span> in the build tree. But when they type <span class="literal">make installcheck</span>, certainly they want to check the installed version of the program, either in the default install location or wherever the user indicates by using command line <span class="literal">make</span> variables like <span class="literal">DESTDIR</span>, <span class="literal">prefix</span>, and <span class="literal">bindir</span>.</p>&#13;
<p class="indent">This brings up a new issue: when we run tests for uninstalled <span class="literal">jupiter</span>, we’re relying on Libtool’s wrapper script to ensure <span class="literal">jupiter</span> can find <em>libjupiter.so</em>. Once we start testing installed <span class="literal">jupiter</span>, we’ll become responsible for showing <span class="literal">jupiter</span> where <em>libjupiter.so</em> is located. If <span class="literal">jupiter</span> is installed in standard places (such as <em>/usr/lib</em>), the system will naturally find <em>libjupiter.so</em>. Otherwise, we’ll have to set the <span class="literal">LD_LIBRARY_PATH</span> environment variable to point to it.</p>&#13;
<p class="indent">So, how do we write our tests to work correctly in both situations? One interesting (but broken) approach is shown in <a href="ch09.xhtml#ch09ex20">Listing 9-20</a>.</p>&#13;
<pre><span class="ash">AT_SETUP([jupiter-execution])</span>&#13;
&#13;
set -x&#13;
find_jupiter()&#13;
{&#13;
<span epub:type="pagebreak" id="page_263"/>    jupiter="$(type -P jupiter)"&#13;
    LD_LIBRARY_PATH="$(dirname "${jupiter}")/../lib" export LD_LIBRARY_PATH&#13;
    compare="${jupiter}"&#13;
    if test "x${jupiter}" == x; then&#13;
      jupiter="${abs_top_builddir}/src/jupiter"&#13;
      compare="$(dirname “${jupiter}”)/.libs/lt-jupiter"&#13;
    fi&#13;
}&#13;
&#13;
find_jupiter&#13;
<span class="ash">AT_CHECK_UNQUOTED(["</span>${jupiter}<span class="ash">"],,</span>&#13;
                  <span class="ash">[Hello from</span> ${compare}<span class="ash">!</span>&#13;
<span class="ash">])</span>&#13;
<span class="ash">AT_CLEANUP</span></pre>&#13;
<p class="caption" id="ch09ex20"><em>Listing 9-20:</em> tests/jupiter.at: <em>Testing execution for both installed and uninstalled <em><span class="literal">jupiter</span></em>—attempt#1</em></p>&#13;
<p class="indent">The <span class="literal">find_jupiter</span> shell function attempts to locate <span class="literal">jupiter</span> in the <span class="literal">PATH</span> by using the shell’s <span class="literal">type</span> command. If the first result is empty, we revert to using the uninstalled version of <span class="literal">jupiter</span>.</p>&#13;
<p class="indent">The function sets two shell variables, <span class="literal">jupiter</span> and <span class="literal">compare</span>. The <span class="literal">jupiter</span> variable is the full path to <span class="literal">jupiter</span>. The <span class="literal">compare</span> variable is derived from <span class="literal">jupiter</span> and contains either the value of <span class="literal">${jupiter}</span> or the Libtool location and name for uninstalled versions. We can set <span class="literal">LD_LIBRARY_PATH</span> in both cases to the <em>../lib</em> directory, relative to where <span class="literal">jupiter</span> is found because that’s probably<sup><a id="ch09fn_7" href="footnote.xhtml#ch09fn7">7</a></sup> where it’s installed.</p>&#13;
<p class="indent">The problems with this approach are numerous. First, it doesn’t handle, very well, the situation where <span class="literal">jupiter</span> <em>should</em> be installed but isn’t found in the specified or implied install path. In this case, the code quietly reverts to testing the uninstalled version—likely not what you wanted. Another issue is that <span class="literal">find_jupiter</span> will locate <span class="literal">jupiter</span> anywhere in the <span class="literal">PATH</span>, even if the instance is not the one you intended to test. But there’s an even more nefarious bug: if you execute <span class="literal">make check</span>, intending to test the uninstalled version, and an installed version of <span class="literal">jupiter</span> happens to be somewhere in the <span class="literal">PATH</span>, that’s the version that will be tested.</p>&#13;
<p class="indent">It’s unfortunate that <span class="literal">AUTOTEST_PATH</span> defaults to a non-empty value when it’s not specified on the command line, as this would be a good way to differentiate the use of <span class="literal">make check</span> from <span class="literal">make installcheck</span>. However, <span class="literal">AUTOTEST_PATH</span> does default to the name of the directory specified in <span class="literal">AC_CONFIG_TESTDIR</span>, which also happens to be the value of <span class="literal">${at_testdir}</span>—one of the variables generated by <span class="literal">AC_CONFIG_TESTDIR</span> in <em>atconfig</em>. We can use this fact to differentiate between <span class="literal">make check</span> and <span class="literal">make installcheck</span> by comparing <span class="literal">${AUTOTEST_PATH}</span> to <span class="literal">${at_testdir}</span>. Change <em>tests/jupiter.at</em> as shown in <a href="ch09.xhtml#ch09ex21">Listing 9-21</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_264"/><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">set -x</span>&#13;
<span class="ash">find_jupiter()</span>&#13;
<span class="ash">{</span>&#13;
  if test "x${AUTOTEST_PATH}" == "x${at_testdir}"; then&#13;
    jupiter="${abs_top_builddir}/src/jupiter"&#13;
    compare="$(dirname "${jupiter}")/.libs/lt-jupiter"&#13;
  else&#13;
    jupiter="${AUTOTEST_PATH}/jupiter"&#13;
    LD_LIBRARY_PATH="${AUTOTEST_PATH}/../lib" export LD_LIBRARY_PATH&#13;
    compare="${jupiter}"&#13;
  fi&#13;
<span class="ash">}</span>&#13;
<span class="ash">jupiter=$(find_jupiter)</span>&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption" id="ch09ex21"><em>Listing 9-21:</em> tests/jupiter.at: <em>A better way to use <span class="literal">AUTOTEST_PATH</span></em></p>&#13;
<p class="indent">Now, when <span class="literal">make check</span> is executed, the <span class="literal">jupiter</span> variable will always be set directly to the uninstalled version in the build tree (and <span class="literal">compare</span> will be set to <em>.../.libs/lt-jupiter</em>), but when <span class="literal">make installcheck</span> is entered, it will be set to <span class="literal">${AUTOTEST_PATH}</span><em>/jupiter</em> (and <span class="literal">compare</span> will be set to the same value). Additionally, since we’re able to fully distinguish between installed and uninstalled testing, we can set the <span class="literal">LD_LIBRARY_PATH</span> only for installed versions of <span class="literal">jupiter</span>.</p>&#13;
<p class="indent">If <span class="literal">AUTOTEST_PATH</span> has been set incorrectly, which can happen (for example, when the user sets <span class="literal">DESTDIR</span> or <span class="literal">prefix</span> incorrectly on the <span class="literal">make</span> command line), the test will fail because <span class="literal">${jupiter}</span> will not be found.</p>&#13;
<p class="indent">If I were to add additional tests that needed to run the <span class="literal">jupiter</span> program, these lines would be a perfect candidate for <em>local.at</em>. The problem is that a shell script designed to run within tests <em>must</em> be defined and executed between calls to <span class="literal">AT_SETUP</span> and <span class="literal">AT_CLEANUP</span>; otherwise, it’s simply omitted from the <span class="literal">autom4te</span> output stream while generating <span class="literal">testsuite</span>. So, how exactly is <em>local.at</em> useful to us? Well, you can’t write shell code directly in <em>local.at</em>, but you can define M4 macros that can be invoked from within your test modules. Let’s move the <span class="literal">find_jupiter</span> functionality into a macro definition in <em>local.at</em>, as shown in <a href="ch09.xhtml#ch09ex22">Listing 9-22</a>.</p>&#13;
<p class="margin">Git tag 9.5</p>&#13;
<pre><span class="ash">AT_INIT</span>&#13;
&#13;
m4_define([FIND_JUPITER], [[set -x&#13;
if test "x${AUTOTEST_PATH}" == "x${at_testdir}"; then&#13;
  jupiter="${abs_top_builddir}/src/jupiter"&#13;
  compare="$(dirname ${jupiter})/.libs/lt-jupiter"&#13;
else&#13;
 LD_LIBRARY_PATH="${AUTOTEST_PATH}/../lib" export LD_LIBRARY_PATH&#13;
  jupiter="${AUTOTEST_PATH}/jupiter"&#13;
  compare="${jupiter}"&#13;
fi]])</pre>&#13;
<p class="caption" id="ch09ex22"><em>Listing 9-22:</em> tests/local.at: <em>Moving <span class="literal">find_jupiter</span> to an M4 macro</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_265"/>Using a shell function was, perhaps, a good idea when we started, but it’s become a bit extraneous at this point, so I modified the code to just set the <span class="literal">jupiter</span> variable directly. Notice the second (<em><span class="literal">value</span></em>) argument of the call to <span class="literal">m4_define</span> is set verbatim to the shell script we want to have generated when the macro is invoked.</p>&#13;
<p class="indent">The <span class="literal">set -x</span> command in the first line of the <em><span class="literal">value</span></em> argument enables shell diagnostic output so you can see the contents of this macro executing, but only if you set <span class="literal">TESTSUITEFLAGS=-v</span> on the <span class="literal">make</span> command line. This is the default setting for the output generated into <em>testsuite.log</em>, so you’ll be able to see what the code generated by the macro invocation is actually doing.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You may have noticed the code in the second argument of <em><span class="literal">m4_define</span></em> has two sets of square brackets around it. This is not strictly necessary in this example because there are no special characters in the embedded code snippet. However, if there had been, double quoting would have allowed the special characters—embedded square brackets, or even a previously defined M4 macro name—to be generated exactly as is, without interference from the <em><span class="literal">m4</span></em> utility.</em></p>&#13;
</div>&#13;
<p class="indent">Now change <em>tests/jupiter.at</em> as shown in <a href="ch09.xhtml#ch09ex23">Listing 9-23</a>.</p>&#13;
<pre><span class="ash">AT_SETUP([jupiter-execution])</span>&#13;
FIND_JUPITER&#13;
<span class="ash">AT_CHECK_UNQUOTED(["${jupiter}"],,</span>&#13;
                  <span class="ash">[Hello from ${compare}!</span>&#13;
<span class="ash">])</span>&#13;
<span class="ash">AT_CLEANUP</span></pre>&#13;
<p class="caption" id="ch09ex23"><em>Listing 9-23:</em> tests/jupiter.at: <em>Calling the <span class="literal">FIND_JUPITER</span> macro</em></p>&#13;
<p class="indent">With this change in place, all tests that needed to run the <span class="literal">jupiter</span> program may do so merely by invoking the <span class="literal">FIND_JUPITER</span> macro and then executing <span class="literal">${jupiter}</span> within the <em><span class="literal">commands</span></em> argument. As you can see, the options available to you are endless—they’re limited only by your mastery of the shell. Because each test is run in a separate subshell, you can feel free to set any environment variables you want without affecting subsequent tests.</p>&#13;
<p class="indent">Let’s try it out. Note we haven’t changed anything except for <em>.at</em> files, so we need only run <span class="literal">make</span> to see the effects of our changes. First, we’ll install into a local directory using <span class="literal">DESTDIR</span> so that we can see how <span class="literal">make installcheck</span> works:</p>&#13;
<pre>   $ <span class="codestrong1">make install DESTDIR=$PWD/inst</span>&#13;
   <span class="codeitalic1">--snip--</span>&#13;
   $ <span class="codestrong1">make check TESTSUITEFLAGS=-v</span>&#13;
   <span class="codeitalic1">--snip--</span>&#13;
   Making check in tests&#13;
   make[1]: Entering directory '/.../jupiter/tests'&#13;
   make    check-local&#13;
   make[2]: Entering directory&#13;
     '/home/jcalcote/dev/book/autotools2e/book/sandbox/tests'&#13;
   /bin/bash './testsuite' -v&#13;
   ## ----------------------- ##&#13;
   ## Jupiter 1.0 test suite. ##&#13;
   <span epub:type="pagebreak" id="page_266"/>## ----------------------- ##&#13;
   1. jupiter.at:1: testing jupiter-execution ...&#13;
   ++ test xtests == xtests&#13;
<span class="ent">➊</span> ++ jupiter=/.../jupiter/src/jupiter&#13;
   +++ dirname /.../jupiter/src/jupiter&#13;
   ++ compare=/.../jupiter/src/.libs/lt-jupiter&#13;
   ++ set +x&#13;
   ./jupiter.at:3: "${jupiter}"&#13;
   1. jupiter.at:1:    ok&#13;
   <span class="codeitalic1">--snip--</span>&#13;
   $ <span class="codestrong1">make installcheck DESTDIR=$PWD/inst TESTSUITEFLAGS=-v</span>&#13;
   <span class="codeitalic1">--snip--</span>&#13;
   Making installcheck in tests&#13;
   make[1]: Entering directory '/.../jupiter/tests'&#13;
   /bin/bash './testsuite' AUTOTEST_PATH='/.../jupiter/inst/usr/local/bin' -v&#13;
   ## ----------------------- ##&#13;
   ## Jupiter 1.0 test suite. ##&#13;
   ## ----------------------- ##&#13;
   1. jupiter.at:1: testing jupiter-execution ...&#13;
   ++ test x/.../jupiter/inst/usr/local/bin == xtests&#13;
   ++ LD_LIBRARY_PATH=/.../jupiter/inst/usr/local/bin/../lib&#13;
   ++ export LD_LIBRARY_PATH&#13;
<span class="ent">➋</span> ++ jupiter=/.../jupiter/inst/usr/local/bin/jupiter&#13;
   ++ compare=/.../jupiter/inst/usr/local/bin/jupiter&#13;
   ++ set +x&#13;
   ./jupiter.at:3: "${jupiter}"&#13;
   1. jupiter.at:1:    ok&#13;
   <span class="codeitalic1">--snip--</span>&#13;
   $</pre>&#13;
<p class="indent">Here, the execution of <span class="literal">make check TESTSUITEFLAGS=-v</span> shows us at <span class="ent">➊</span> that <span class="literal">jupiter</span> is being picked up from the build tree and <span class="literal">compare</span> is set to the path of the Libtool binary, while <span class="literal">make installcheck DESTDIR=$PWD/inst TESTSUITEFLAGS=-v</span> indicates at <span class="ent">➋</span> that <span class="literal">jupiter</span> being picked up from the installation path we specified and <span class="literal">compare</span> is set to the same location. <span class="literal">LD_LIBRARY</span><span class="literal">_PATH</span> is also being set in this code path.</p>&#13;
<h4 class="h4" id="ch09sec5-3"><em>Cleaning Up</em></h4>&#13;
<p class="noindent">The <span class="literal">testsuite</span> program has a <span class="literal">--clean</span> command line option that cleans up the <em>tests</em> directory of all test droppings. To wire that into the <span class="literal">clean</span> target, we add a <span class="literal">clean-local</span> rule, as shown in <a href="ch09.xhtml#ch09ex24">Listing 9-24</a>.</p>&#13;
<p class="margin">Git tag 9.6</p>&#13;
<pre><span class="ash">installcheck-local: atconfig atlocal $(TESTSUITE)</span>&#13;
        <span class="ash">$(SHELL) '$(TESTSUITE)' AUTOTEST_PATH='$(bindir)' $(TESTSUITEFLAGS)</span>&#13;
&#13;
clean-local:&#13;
        test ! -f '$(TESTSUITE)' || $(SHELL) '$(TESTSUITE)' --clean&#13;
        rm -rf atconfig&#13;
&#13;
<span class="ash">atconfig: $(top_builddir)/config.status</span>&#13;
        <span class="ash">cd $(top_builddir) &amp;&amp; $(SHELL) ./config.status tests/$@</span></pre>&#13;
<p class="caption" id="ch09ex24"><em>Listing 9-24:</em> tests/Makefile.am: <em>Adding support for <span class="literal">make clean</span> in tests</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_267"/>If <span class="literal">testsuite</span> exists, it’s asked to clean up after itself. I’ve also added a command to remove the generated <em>atconfig</em> script, as <span class="literal">make distcheck</span> fails if this file is not removed during execution of the <span class="literal">clean</span> target while checking the distribution directory from which the package is built, and <em>atconfig</em> is not generated by Automake or by any Autoconf code that Automake monitors. At this point, you could try out <span class="literal">make dist</span> or <span class="literal">make distcheck</span> to see whether it now works as it should.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You might think the <em><span class="literal">clean-local</span></em> target is optional, but it’s required so that <em><span class="literal">make distcheck</span></em> won’t fail when building a distribution archive due to extra files being left around after <em><span class="literal">distcheck</span></em> runs <em><span class="literal">make clean</span></em>.</em></p>&#13;
</div>&#13;
<p class="indent">Note also that we don’t need to, nor should we, attempt to clean up files generated into the source tree, such as <em>package.m4</em> and <span class="literal">testsuite</span> itself. Why not? Much like <span class="literal">configure</span>, autotest products like <span class="literal">testsuite</span> sit somewhere between source files we write by hand and product files found in the build tree. They’re built from sources, but stored in the source tree and ultimately distributed in the archive.</p>&#13;
<h3 class="h3" id="ch09sec6">Niceties</h3>&#13;
<p class="noindent">One more thing I like to do is add a call to <span class="literal">AT_COLOR_TESTS</span> to my <em>local.at</em> file, right after the invocation of <span class="literal">AT_INIT</span>. Users can always specify colored test output using a command line argument to <span class="literal">testsuite</span> (<span class="literal">--color</span>), but using this macro allows you to enable colored test output by default. Change your <em>local.at</em> file as shown in <a href="ch09.xhtml#ch09ex25">Listing 9-25</a>.</p>&#13;
<p class="margin">Git tag 9.7</p>&#13;
<pre><span class="ash">AT_INIT</span>&#13;
AT_COLOR_TESTS&#13;
&#13;
<span class="ash">m4_define([FIND_JUPITER], [set -x</span>&#13;
<span class="ash">if test "x${AUTOTEST_PATH}" == "x${at_testdir}"; then</span>&#13;
<span class="codeitalic1a">--snip--</span></pre>&#13;
<p class="caption" id="ch09ex25"><em>Listing 9-25:</em> tests/local.at: <em>Making colored test output the default</em></p>&#13;
<p class="indent">You should notice that the <span class="literal">ok</span> text after each successful test, as well as the summary line <span class="literal">All 2 tests were successful.</span>, is now green. If you had experienced any failed tests, those tests would have shown <span class="literal">FAILED (testsuite</span><span class="literal">.at:</span><em><span class="literal">N</span></em><span class="literal">)</span> in red after the failed tests, with summary lines in red as follows:</p>&#13;
<pre>ERROR: All 2 tests were run,&#13;
1 failed unexpectedly.</pre>&#13;
<h3 class="h3" id="ch09sec7"><span epub:type="pagebreak" id="page_268"/>A Minimal Approach</h3>&#13;
<p class="noindentb">I mentioned at the outset that we’d take a look at cutting this system down to the bare necessities for smaller projects. Here’s what we can do without:</p>&#13;
<p class="bqpara"><strong><em>tests/local.at</em></strong> Copy the contents of this file to the top of <em>testsuite.at</em> and delete the file.</p>&#13;
<p class="bqpara"><strong><em>tests/atlocal.in</em></strong> Assuming you don’t need to pass any configuration variables into your testing environment, remove the reference to the product file, <em>atlocal</em>, from the call to <span class="literal">AC_CONFIG_FILES</span> in <em>configure.ac</em> and delete this template file.</p>&#13;
<p class="bqpara"><strong><em>tests/*.at</em></strong> <strong>(subtest files included by</strong> <em><strong>testsuite.at</strong></em>) Copy the content of these files serially into <em>testsuite.at</em> and delete the files; remove the <span class="literal">m4_include</span> macro invocations that were originally used to include these files.</p>&#13;
<p class="indentt">Edit <em>tests/Makefile.am</em> and remove all references to the preceding files (templates and generated products) from the <span class="literal">EXTRA_DIST</span> and <span class="literal">TESTSOURCES</span> variables, as well as from the <span class="literal">check-local</span> and <span class="literal">installcheck-local</span> rules.</p>&#13;
<p class="indent">I would not remove the <em>package.m4</em> rule, although you may do so if you wish by copying the <span class="literal">m4_define</span> macro invocations generated into this file directly to the top of <em>testsuite.at</em>. Since <span class="literal">make</span> generates this file using variables defined by Autoconf, a generated instance of <em>package.m4</em> already contains the values that replace the variable references in the command in <em>tests/Makefile.am</em>. In my opinion, the value of not having to edit this information in two places far outweighs the overhead of maintaining the file generation rule.</p>&#13;
<h3 class="h3" id="ch09sec8">Summary</h3>&#13;
<p class="noindent">We’ve covered the basics of autotest, but there are a dozen more or less useful <span class="literal">AT_*</span> macros you can use in your <em>testsuite.at</em> file. Section 19.2 of the <em>GNU Autoconf Manual</em> documents them in detail. I’ve shown you how to wire autotest into the Automake infrastructure. If you’ve chosen to use autotest without Automake, there will be some differences between the Automake’s <em>tests/Makefile.am</em> and Autoconf’s <em>tests/Makefile.in</em>, as you can no longer rely on Automake to do some things for you. However, if you’re writing your own <em>Makefile.in</em> templates, these modifications will quickly become obvious to you.</p>&#13;
<p class="indent">I’ve also shown you a technique for creating unit tests in C that allows you full access to the private implementation details of a source module. I’ve attained nearly 100 percent code coverage using this technique in past projects, but I’ll warn you of one caveat now: writing unit tests at this level makes it much more difficult to change the functionality of your application. Fixing a bug is not so bad, but making design changes will generally require you to disable or entirely rewrite the unit tests associated with the code affected by your changes. It’s a good idea to be pretty sure of your design before committing yourself to this level of unit testing. It has been <span epub:type="pagebreak" id="page_269"/>said that one of the primary values of writing unit tests is that you can <em>set them and forget them</em>—that is, you can write the tests once, wire them into your build system, and no longer pay attention to whether the code under test is working. Well, this is mostly true, but if you ever have to modify a well-tested feature in your project, unless you comment your test code well, you’ll find yourself wondering what you were thinking when you wrote that test code.</p>&#13;
<p class="indent">Nevertheless, I sleep better at night knowing that code I just committed to my company repository is fully tested. I’ve also been more confident in discussions with colleagues regarding bugs surrounding my well-tested code. Autotest has helped reduce the effort involved in these projects.</p>&#13;
<p class="indent">With the end of this chapter, we’ve also come to the end of the Jupiter project—and it’s a good thing, because I’ve taken the <em>Hello, world!</em> concept <em>much</em> further than anyone has a right to. From here on out, we’ll be focusing on more isolated topics and real-world examples.<span epub:type="pagebreak" id="page_270"/></p>&#13;
</body></html>