- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 7 LOW-LEVEL CONTROL STRUCTURES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The examples in this book up to this point have created assembly control structures
    in an ad hoc manner. Now it’s time to formalize how to control the operation of
    your assembly language programs. By the time you finish this chapter, you should
    be able to convert HLL control structures into assembly language control statements.
  prefs: []
  type: TYPE_NORMAL
- en: Control structures in assembly language consist of conditional branches and
    indirect jumps. This chapter discusses those instructions and how to emulate HLL
    control structures such as if...else, switch, and loop statements. This chapter
    also discusses labels, the targets of conditional branches and jump statements,
    as well as the scope of labels in an assembly language source file.
  prefs: []
  type: TYPE_NORMAL
- en: '### 7.1 Statement Labels'
  prefs: []
  type: TYPE_NORMAL
- en: Before discussing the jump instructions and how to use them to emulate control
    structures, an in-depth discussion of assembly language statement labels is necessary.
    *Labels* in an assembly language program stand in as symbolic names for addresses.
    Referring to a position in your code by using a name such as LoopEntry is far
    more convenient than using a numeric address such as 0xAF1C002345B7901E. For this
    reason, assembly language low-level control structures make extensive use of labels
    within source code (see section 2.10, “Control-Transfer Instructions,” on [page
    74](chapter2.xhtml#pg_74)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do three operations on code labels: transfer control to a label via
    a conditional or unconditional jump instruction, call a label via the bl instruction,
    and take the address of a label. The last of these is useful when you want to
    indirectly transfer control to that address at a later point in your program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sequence demonstrates how to take the address of a label
    in your program by using the lea macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Because addresses are 64-bit quantities, you’ll typically load an address into
    a 64-bit general-purpose register by using the lea instruction. Also see section
    7.5, “Taking the Address of Symbols in Your Code,” on [page 364](chapter7.xhtml#pg_364)
    for more information about taking the address of a label in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 Initializing Arrays with Statement Labels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gas allows you to initialize double-word objects with the addresses of statement
    labels. The code fragment in Listing 7-1 demonstrates how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You might recall that pointers in the .text section cannot refer to objects
    outside that section; however, it is perfectly legitimate for pointers in other
    sections (such as .data) to refer to symbols in the .text section.
  prefs: []
  type: TYPE_NORMAL
- en: As addresses on the ARM are 64-bit quantities, you will typically use the .dword
    directive, as in the previous examples, to initialize a data object with the address
    of a statement label.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3 Unconditional Transfer of Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The b.al (branch) instruction unconditionally transfers control to another
    point in the program. This instruction has three forms: two PC-relative branches
    and an indirect jump. These instructions take the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first two instructions are *PC-relative branches*, which you’ve seen in
    various sample programs up to this point. For PC-relative branches, you normally
    specify the target address by using a statement label. The label appears either
    on the same line as an executable machine instruction or by itself on a line preceding
    it. The direct jump is completely equivalent to a goto statement in an HLL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a direct jump that transfers control to a label elsewhere
    in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Unlike HLLs, for which your instructors usually forbid you to use goto statements,
    you will find that the use of the b/b.al instruction in assembly language is essential.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Register-Indirect Branches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third form of the br reg64 branch instruction given earlier is a *register-indirect
    jump* instruction that transfers control to the instruction whose address appears
    in the specified 64-bit general-purpose register. To use the br instruction, you
    must load a 64-bit register with the address of a machine instruction prior to
    the execution of br. When several paths, each loading the register with a different
    address, converge on the same br instruction, control transfers to an appropriate
    location determined by the path up to that point.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7-2 reads a string of characters from the user that contain an integer
    value. It uses strtol() to convert that string to a binary integer value. This
    C stdlib function doesn’t do the best job of reporting an error, so this program
    tests the return results to verify a correct input and uses register-indirect
    jumps to transfer control to different code paths based on the result.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of Listing 7-2 contains constants, variables, external declarations,
    and the (usual) getTitle() function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section of Listing 7-2 is the strToInt function, a wrapper around
    the C stdlib strtol() function that does a more thorough job of handling erroneous
    inputs from the user. See the comments for the function’s return values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The strtol() ❶ function expects a pointer to an end-of-string pointer variable.
    The strToInt procedure reserved space for this pointer in the activation record.
    This code computes the address of that pointer variable to pass on to the strtol()
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the C errno variable ❷ is done differently in macOS and Linux (or,
    more likely, in Clang versus GCC). The getErrno macro in the *aoaa.inc* include
    file generates the appropriate code for the two systems. It returns errno in X0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final section of Listing 7-2 is the main program and the most interesting
    part of the code, because it demonstrates how to call the strToInt function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The main function loads the X19 register with the address of code to execute
    based on the strToInt return results. The strToInt function returns one of the
    following states (see the comments in the previous code for an explanation):'
  prefs: []
  type: TYPE_NORMAL
- en: Valid input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Illegal characters at the beginning of the string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Illegal characters at the end of the string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program then transfers control to different sections of asmMain based on
    the value held in X19, which specifies the type of result strToInt returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The readline function returns –1 ❶ if there was an error reading the line of
    text from the user, which typically occurs when the end of the file is detected.
    This is the *only* negative value that readline returns, so rather than test for
    –1, this code just checks to see if readline returned a negative value. The test
    is a little sneaky, but it’s a standard trick; anytime you AND a value with itself,
    you get the original value back. In this case, the code uses the ands instruction,
    which also sets the Z flag if the value was 0 and sets the N flag if the number
    was negative ❷. Therefore, testing the N flag afterward checks for an error condition.
    Note that a cmp x0, #0 instruction would serve this same purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, this code uses the ands instruction ❷ to compare the result against
    0\. This time, it’s actually checking for the value 0 (via the Z flag) by using
    the beq instruction immediately afterward. This is where the program in Listing
    7-2 demonstrates using the br (branch indirect through register) instruction to
    implement the logic ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and a sample run of Listing 7-2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This sample run demonstrates several bad inputs, including nonnumeric inputs,
    out-of-range values, a legitimate value, and entering 0 to exit the program.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5 Taking the Address of Symbols in Your Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Listing 7-2 computed the address of various symbols throughout the .text section
    in order to load those addresses into a register for later use. Obtaining the
    runtime address of a symbol in the program is a common operation in assembly language
    programs, because this is how you access data (and code) indirectly via a register.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers control structures, and this section discusses obtaining
    addresses of statement labels in the program. Much of the information in this
    section is review material from earlier chapters in this book, but I’ve pulled
    it together here for reference purposes and extended the discussion.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.1 Revisiting the lea Macro
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Listing 7-2 used the lea macro to initialize 64-bit registers with the address
    of a location to jump to via the br instruction. This has been the go-to macro
    for obtaining the address of a symbol throughout this book. However, remember
    that lea is a macro and that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'translates into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The two-instruction sequence allows the lea macro to compute the address of
    a PC-relative symbol anywhere in a ±4GB range. The adr instruction can also compute
    the address of a symbol but it supports only a ±1MB range (see section 1.8.1,
    “ldr, str, adr, and adrp,” on [page 23](chapter1.xhtml#pg_23)).
  prefs: []
  type: TYPE_NORMAL
- en: 'When taking the address of nearby statement labels in the .text section, it
    is going to be more efficient to use the adr instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The only time this will fail is if your .text section is very large and the
    symbol is more than 1MB away from the adr instruction. The main reason for using
    the lea macro is to obtain the address of a symbol that is in a different section
    (especially on macOS, whose PIE/ASLR policy will likely locate that section farther
    than ±1MB away).
  prefs: []
  type: TYPE_NORMAL
- en: If the symbol/memory location whose address you wish to compute is farther than
    ±4GB away from the current instruction, you’ll have to use one of the approaches
    in the following sections to obtain its address.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.2 Statically Computing the Address of a Symbol
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since memory addresses are 64 bits, and the .dword directive allows you to initialize
    a dword object with a 64-bit value, shouldn’t it be possible to initialize such
    an object with the 64-bit address of another symbol in the program? The answer
    depends on the OS you’re running under.
  prefs: []
  type: TYPE_NORMAL
- en: Under Linux, it is perfectly legal (even when running PIE code) to do the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'where variable is the name of a symbol appearing in a .data, .bss, .rodata,
    or .text section. When Linux loads the executable program into memory, it will
    automatically patch this dword memory location with the address of that symbol
    in memory (wherever Linux has loaded it). Depending on the section, you might
    be able to directly load the contents of this location in the X0 register by using
    the following instruction, assuming that the symbol is within the PC-relative
    range of the ldr instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Sadly, this scheme may not work under macOS, where you’re not allowed to use
    absolute addresses in your .text section. If you move varPtr to the .data section,
    macOS will accept the pointer initialization but will reject the ldr instruction
    with the same complaint about an illegal absolute address. Of course, you could
    use the lea macro to load the address of varPtr into X0 and then fetch variable’s
    address by using the [X0] addressing mode; however, at that point, you may as
    well use the lea instruction to load the address of variable directly into X0\.
    In any case, you’re back to the ±4GB limitation of the lea macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get around the absolute address limitation of macOS by using a relative
    address rather than an absolute address. A *relative address* is just an offset
    from a fixed point in memory (for example, a PC-relative address is an offset
    from the address held in the PC register). You can create a self-relative 64-bit
    pointer by using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This initializes this 64-bit memory location with the distance (in bytes) from
    the varPtr object to the desired memory location (variable). This is known as
    a *self-relative pointer* because the offset is from the pointer variable itself.
    As it turns out, macOS’s assembler is perfectly happy with this address expression
    (even in the .text section) because it is not an absolute address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you cannot simply load these 64 bits into a register and address
    the memory location at which they point. The value is an offset, not an address.
    However, if you add the address of varPtr to its contents, this will give you
    the address of variable, as demonstrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This sequence solves the problem with addresses under macOS and happens to work
    just fine under Linux as well. Because this sequence will work under both OSes,
    this book adopts this scheme when fetching addresses from variables in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Under macOS, this sequence requires varPtr to be in the same .text section as
    the instructions. Otherwise, macOS will complain that varPtr is an absolute address
    and will reject this code. Because I’ve written this book assuming the code will
    generally work under Linux and macOS, I will keep such labels in the .text section.
  prefs: []
  type: TYPE_NORMAL
- en: A single ldr instruction will also work fine under Linux, so if you’re writing
    Linux-only code, the single ldr is more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.3 Dynamically Computing the Address of a Memory Object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Computing the address of a nonstatic memory object is a bit more involved than
    doing the same for static (.data, .bss, .text, .rodata, and so on) memory objects.
  prefs: []
  type: TYPE_NORMAL
- en: Because every ARM machine instruction is exactly 32 bits in length, you can
    view a .text section containing nothing but machine instructions as an array of
    words, where the value in each word just happens to be the encoding of a machine
    instruction. (This view isn’t 100 percent accurate; if the .text section contains
    data as well as instructions, there are limitations to how far you can go with
    treating the .text section as an array of instructions. However, if you limit
    yourself to those areas that contain only instructions, everything will be fine.)
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, it is possible to manipulate the values in the .text section
    by using the techniques for arrays from section 4.7, “Arrays,” on [page 194](chapter4.xhtml#pg_194).
    This includes techniques such as indexing into arrays and computing the effective
    address of array elements.
  prefs: []
  type: TYPE_NORMAL
- en: '> NOTE'
  prefs: []
  type: TYPE_NORMAL
- en: '*Section 5.6.2, “Passing by Reference,” on [page 256](chapter5.xhtml#pg_256)
    describes a procedure for computing the effective address of an object you reference
    via the ARM’s various addressing modes. For data objects, see that discussion.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following instruction sequence of arbitrary instructions cut from
    Listing 7-2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The label goodInput is the base address of an array of five words containing
    the five instructions in this short sequence. You can, of course, take the base
    address of this array by using the adr instruction (or lea if this sequence is
    too far away). Once you have this base address in a register (such as X0), you
    can use the array-indexing calculation to compute the address of a particular
    entry in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The element_size value is 4, as each instruction is 32 bits. Index 0 specifies
    the mov instruction, index 1 specifies the adr instruction, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an index value in X1, you can transfer control directly to one of these
    five instructions by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The add instruction multiplies the index (X1) by 4 before adding it to the base
    address. This computes the byte address of the specified instruction in the sequence;
    then br transfers control to the instruction.
  prefs: []
  type: TYPE_NORMAL
- en: In many respects, this is similar to a switch or case statement, where a unique
    case is associated with each instruction in the sequence. This chapter considers
    such control structures in section 7.6.7, “switch...case Statements,” on [page
    389](chapter7.xhtml#pg_389). In the meantime, just know that you can dynamically
    compute the address of one of the instructions in this sequence by using normal
    effective address calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.4 Working with Veneers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the rare case you need to branch to a location beyond the range of the conditional
    branch instructions, you can use an instruction sequence such as the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: where bccopposite is the opposite of the branch you want to take. This opposite
    branch skips over the code that transfers control to the target location. This
    provides you with the 4GB range of the lea macro, which should be sufficient if
    you’re branching to code in your program. The opposite conditional branch transfers
    control to the normal *fall-though point* in the code (the code you’d normally
    fall through to if the condition is false). If the condition is true, control
    transfers to a memory-indirect jump that jumps to the original target location
    via a 64-bit pointer.
  prefs: []
  type: TYPE_NORMAL
- en: This sequence is known as a *veneer* (or a *trampoline*), because a program
    jumps to this point to move even further in the program—much like jumping on a
    trampoline lets you jump higher and higher. Veneers are useful for call and unconditional
    jump instructions that use the PC-relative addressing mode (and thus are limited
    to a ±1MB range around the current instruction). You’ll rarely use veneers to
    transfer to another location within your program, since it’s unlikely you’ll write
    assembly language programs that large.
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of the X16 register in this example. The ARM ABI reserves registers
    X16 and X17 for dynamic linking and veneer use. You’re free to use these two as
    volatile registers with the expectation that their contents may be changed upon
    executing a branch instruction (of any kind, though generally a bl instruction).
    Compilers and linkers will typically modify an out-of-range branch instruction
    to transfer code to a nearby veneer, which then transfers control the full distance
    to the actual destination. When creating your own veneers, it makes sense to use
    these registers as temporaries for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Branching to code outside this range generally means you’re transferring control
    to a function in a shared (or dynamically linked) library. See the appropriate
    documentation for your OS for details on such libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 7-1](chapter7.xhtml#tab7-1) lists the opposite conditions; refer to
    [Table 2-11](chapter2.xhtml#tab2-11) on [page 82](chapter2.xhtml#pg_82) for the
    available opposite branch macros in *aoaa.inc*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7-1: Opposite Conditions'
  prefs: []
  type: TYPE_NORMAL
- en: '| Branch condition | Opposite |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| eq | ne |'
  prefs: []
  type: TYPE_TB
- en: '| ne | eq |'
  prefs: []
  type: TYPE_TB
- en: '| hi | ls |'
  prefs: []
  type: TYPE_TB
- en: '| hs | lo |'
  prefs: []
  type: TYPE_TB
- en: '| lo | hs |'
  prefs: []
  type: TYPE_TB
- en: '| ls | hi |'
  prefs: []
  type: TYPE_TB
- en: '| gt | le |'
  prefs: []
  type: TYPE_TB
- en: '| ge | lt |'
  prefs: []
  type: TYPE_TB
- en: '| lt | ge |'
  prefs: []
  type: TYPE_TB
- en: '| le | gt |'
  prefs: []
  type: TYPE_TB
- en: '| cs | cc |'
  prefs: []
  type: TYPE_TB
- en: '| cc | cs |'
  prefs: []
  type: TYPE_TB
- en: '| vs | vc |'
  prefs: []
  type: TYPE_TB
- en: '| vc | vs |'
  prefs: []
  type: TYPE_TB
- en: '| mi | pl |'
  prefs: []
  type: TYPE_TB
- en: '| pl | mi |'
  prefs: []
  type: TYPE_TB
- en: 'If the destination location is beyond the ±4GB range of the lea macro, you’ll
    need to create a 4-byte pointer (offset) to the actual location and use code such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This particular sequence is sufficiently useful that the *aoaa.inc* include
    file provides a macro that expands to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to call a procedure that’s more than ±4GB away, you could emit
    similar code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it’s easier to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With the discussion of veneers out of the way, the next section can discuss
    how to implement HLL-like control structures in assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6 Implementing Common Control Structures in Assembly Language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section shows you how to implement HLL-like control structures such as
    decisions, loops, and other control constructs by using pure assembly language.
    It concludes by showing some ARM instructions designed for creating common loops.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout many of the following examples, this chapter assumes that various
    variables are local variables in the activation record (indexed off of the FP
    register) or static/global variables indexed off the SB (X28) register. We presume
    that appropriate structure declarations have been made for all the variable’s
    identifiers and that the FP/SB registers have been properly initialized to point
    at these structures.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.1 Decisions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In its most basic form, a *decision* is a branch within the code that switches
    between two possible execution paths based on a certain condition. Normally (though
    not always), conditional instruction sequences are implemented with the conditional
    jump instructions. Conditional instructions correspond to the following if...then...endif
    statement in an HLL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To convert this to assembly language, you must write statements that evaluate
    the expression and then branch around the statements if the result is false. For
    example, if you had the C statements
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'you could translate this to assembly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, conditional statements may be broken into three basic categories:
    if statements, switch...case statements, and indirect jumps. Next, you’ll learn
    about these program structures, how to use them, and how to write them in assembly
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.2 if...then...else Sequences
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most common conditional statements are the if...then...endif and if...then...else...endif
    statements. These two statements take the form shown in [Figure 7-1](chapter7.xhtml#fig7-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: The if...then...else...endif and if...then...endif statements'
  prefs: []
  type: TYPE_NORMAL
- en: The if...then...endif statement is just a special case of the if...then...else...endif
    statement (with an empty else block). The basic implementation of an if...then...else...endif
    statement in ARM assembly language looks something like this
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: where bcc represents a conditional branch instruction (typically the opposite
    branch of the condition being tested).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you want to convert the C/C++ statement into assembly
    language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To do so, you could use the following ARM code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For simple expressions like (aa == bb), generating the proper code for an if...then...else...endif
    statement is easy. Should the expression become more complex, the code complexity
    increases as well. Consider the following C/C++ if statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert a complex if statement such as this one, break it into a sequence
    of three if statements as follows (assuming the use of short-circuit evaluation;
    see section 7.6.5, “Short-Circuit vs. Complete Boolean Evaluation,” on [page 382](chapter7.xhtml#pg_382)
    for details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This conversion comes from the following C/C++ equivalences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: is equivalent to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: is equivalent to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In assembly language, the former if statement becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of opposite branches to suggest that falling through is the main
    condition to consider.
  prefs: []
  type: TYPE_NORMAL
- en: 'The biggest problem with complex conditional statements in assembly language
    is trying to figure out what you’ve done after you’ve written the code. HLL expressions
    are much easier to read and comprehend, so well-written comments are essential
    for clear assembly language implementations of if...then...else...endif statements.
    The following code shows an elegant implementation of the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever you’re working in assembly language, don’t forget to step back for
    a moment and see if you can rethink the solution in assembly language rather than
    playing “human C/C++ compiler.” When working with a complex Boolean expression,
    your first thought should be, “Can I use the conditional compare instruction to
    resolve this?” The following example does just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The cmp instruction sets the flags for (x > y). The first ccmp instruction sets
    the flags to simulate a signed ge (not less than) if (x <= y) or based on the
    comparison of (z < t) if (x > y). After executing the first ccmp instruction,
    N ≠ V if (x > y) && (z < t).
  prefs: []
  type: TYPE_NORMAL
- en: Upon executing the second ccmp instruction, if N ≠ V (meaning signed less than),
    the code just sets NZCV to simulate ne and doesn’t bother comparing aa and bb
    (because the left-hand side of the disjunction operator is already true, there
    is no need to evaluate the third parenthetical expression). Setting Z = 0 means
    the csel instruction will copy d to c (based on the ne condition).
  prefs: []
  type: TYPE_NORMAL
- en: If N = V when executing the second ccmp instruction, the ge condition is true,
    which means that the conjunction operation yielded false and you must test to
    see if aa does not equal bb. That will set the flags appropriately for the csel
    instruction. Listing 7-3 demonstrates the execution of this conditional comparison
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the build command and sample output for Listing 7-3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The output shows the truth table for the given expression.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.3 Complex if Statements Using Complete Boolean Evaluation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Many Boolean expressions involve conjunction (AND) or disjunction (OR) operations.
    You can convert such Boolean expressions into assembly language in two ways: using
    *complete Boolean evaluation* or using *short-circuit Boolean evaluation*. This
    section discusses complete Boolean evaluation, and the next discusses short-circuit
    Boolean evaluation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversion via complete Boolean evaluation is almost identical to converting
    arithmetic expressions into assembly language, as covered in section 6.4, “Logical
    Expressions,” on [page 312](chapter6.xhtml#pg_312). However, for Boolean evaluation,
    you do not need to store the result in a variable; once the evaluation of the
    expression is complete, you check whether you have a false (0) or true (1, or
    nonzero) result to take whatever action the Boolean expression dictates. Remember
    that only the ands instruction sets the zero flag; there is no orrs instruction.
    Consider the following if statement and its conversion to assembly language using
    complete Boolean evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This code computes a Boolean result in the W0 register and then, at the end
    of the computation, tests this value to see whether it contains true or false.
    If the result is false, this sequence skips over the code associated with Stmt1.
    The important thing is that the program will execute every instruction that computes
    this Boolean result (up to the beq instruction).
  prefs: []
  type: TYPE_NORMAL
- en: 'By now you should recognize that we can improve this code by using the ccmp
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The code is still a bit longer than usual, but this is the result of using memory
    variables rather than registers for everything in this example. Even though this
    example uses the ccmp instruction, the code still executes each and every instruction
    in the sequence, even if the condition becomes false early on and could never
    become true.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.4 Short-Circuit Boolean Evaluation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you are willing to expend a little more effort (and your Boolean expression
    doesn’t depend on side effects), you can often convert a Boolean expression to
    a faster sequence of assembly language instructions by using *short-circuit Boolean
    evaluation*. This approach attempts to determine whether an expression is true
    or false by executing only some of the instructions that would compute the complete
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the expression aa && bb. Once you determine that aa is false, there
    is no need to evaluate bb because there is no way the expression can be true.
    If bb represents a complex subexpression rather than a single Boolean variable,
    it should be clear that evaluating only aa is more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a concrete example, consider the subexpression ((x < y) && (z > t)). Once
    you determine that x is not less than y, there is no need to check whether z is
    greater than t because the expression will be false regardless of the values of
    z and t. The following code fragment shows how to implement short-circuit Boolean
    evaluation for this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The code skips any further testing once it determines that x is not less than
    y. Of course, if x is less than y, the program has to test z to see if it is greater
    than t; if not, the program skips over the then clause. Only if the program satisfies
    both conditions does the code fall through to the then clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the logical OR operation, the technique is similar. If the first subexpression
    evaluates to true, there is no need to test the second operand. Whatever the second
    operand’s value is at that point, the full expression still evaluates to true.
    The following example demonstrates the use of short-circuit evaluation with disjunction
    (||):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Because the conjunction and disjunction operators are commutative, you can evaluate
    the left or right operand first if it is more convenient to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that some expressions depend on the leftmost subexpression evaluating
    one way in order for the rightmost subexpression to be valid; if(x != NULL &&
    x -> y) is a common test in C/C++, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'As one last example in this section, consider the full Boolean expression from
    the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The code in this example evaluates aa != bb first, because it is shorter and
    faster, and the remaining subexpression last. This is a common technique assembly
    language programmers use to write better code.
  prefs: []
  type: TYPE_NORMAL
- en: This assumes, of course, that all comparisons are equally likely to be true
    or false. If you can predict that the subexpression aa != bb will be false the
    vast majority of the time, it would be best to test that condition last.
  prefs: []
  type: TYPE_NORMAL
- en: '#### 7.6.5 Short-Circuit vs. Complete Boolean Evaluation'
  prefs: []
  type: TYPE_NORMAL
- en: When using complete Boolean evaluation, every statement in the sequence for
    that expression will execute; short-circuit Boolean evaluation, on the other hand,
    may not require the execution of every statement associated with the Boolean expression.
    As you’ve seen in the previous two sections, code based on short-circuit evaluation
    is often shorter and possibly faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, short-circuit Boolean evaluation may not produce the correct result
    in some cases. Given an expression with *side effects* (changes to variables within
    the expression), short-circuit Boolean evaluation will produce a different result
    than complete Boolean evaluation. Consider the following C/C++ example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Using complete Boolean evaluation, you might generate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The ccmp instruction compares the incremented value of z against 0, but only
    if x is equal to y. If x is not equal to y, the ccmp instruction sets the Z flag
    to 1 so that control transfers to SkipStmt with the following beq instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using short-circuit Boolean evaluation, you might generate the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'A subtle but important difference exists between these two conversions: if
    x is equal to y, the first version still *increments* z *and compares it to 0*
    before it executes the code associated with Stmt. The short-circuit version, on
    the other hand, skips the code that increments z if it turns out that x is equal
    to y. Therefore, the behavior of these two code fragments is different if x is
    equal to y.'
  prefs: []
  type: TYPE_NORMAL
- en: Neither implementation is wrong; depending on the circumstances, you may or
    may not want the code to increment z if x is equal to y. However, it is important
    to realize that these two schemes produce different results, so you can choose
    an appropriate implementation if the effect of this code on z matters to your
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many programs take advantage of short-circuit Boolean evaluation and rely on
    the program not evaluating certain components of the expression. The following
    C/C++ code fragment demonstrates perhaps the most common example that requires
    short-circuit Boolean evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If it turns out that pntr is NULL, the expression is false, and there is no
    need to evaluate the remainder of the expression. This statement relies on short-circuit
    Boolean evaluation for correct operation. Were C/C++ to use complete Boolean evaluation,
    the second half of the expression would attempt to dereference a NULL pointer,
    when pntr is NULL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the translation of this statement using complete Boolean evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If pntr contains NULL (0), this program will attempt to access the data at location
    0 in memory via the ldrb w0, [x0] instruction. Under most OSes, this will cause
    a memory access fault (segmentation fault).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the short-circuit Boolean conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the problem with dereferencing the NULL pointer doesn’t exist.
    If pntr contains NULL, this code skips over the statements that attempt to access
    the memory address that pntr contains.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.6 Efficient Implementation of if Statements in Assembly Language
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Encoding if statements efficiently in assembly language takes a little more
    thought than simply choosing short-circuit evaluation over complete Boolean evaluation.
    To write code that executes as quickly as possible in assembly language, you must
    carefully analyze the situation and generate the code appropriately. The following
    paragraphs provide suggestions you can apply to your programs to improve their
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.6.1 Knowing Your Data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Programmers often mistakenly assume that data is random. In reality, data is
    rarely random, and if you know the types of values that your program commonly
    uses, you can write better code. To see how, consider the following C/C++ statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Because C/C++ uses short-circuit evaluation, this code will test whether aa
    is equal to bb. If so, it will test whether c is less than d. If you expect aa
    to be equal to bb most of the time but don’t expect c to be less than d most of
    the time, this statement will execute slower than it should. Consider the following
    Gas implementation of this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, if aa is equal to bb most of the time and c is not less than
    d most of the time, you will have to execute the first eight instructions nearly
    every time in order to determine that the expression is false. Now consider the
    following implementation that takes advantage of this knowledge and the fact that
    the && operator is commutative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The code first checks whether c is less than d. If most of the time c is not
    less than d, this code determines that it has to skip to the label DontIncI after
    executing only three instructions in the typical case, compared with seven instructions
    in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizations like this are much more obvious in assembly language than in an
    HLL, one of the main reasons assembly programs are often faster than their HLL
    counterparts. The key here is to understand the behavior of your data so you can
    make intelligent decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.6.2 Rearranging Expressions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Even if your data is random, or you can’t determine how the input values will
    affect your decisions, rearranging the terms in your expressions may still be
    beneficial. Some calculations take far longer to compute than others. For example,
    computing the remainder is slower than a simple cmp instruction. Therefore, if
    you have a statement like the following, you may want to rearrange the expression
    so that the cmp comes first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Converted directly to assembly code, this if statement becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The remainder computation is expensive (about one-third the speed of most of
    the other instructions in this example). Unless it is three times more likely
    that the remainder is 0 rather than x is equal to y, it would be better to do
    the comparison first and the remainder calculation afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The && and || operators are commutative in the mathematical sense that if you
    evaluate that left or right side first, the logical result is the same. In terms
    of execution, they are not commutative because the order of evaluation may cause
    the code to skip the evaluation of the second subexpression; in particular, these
    operators may not be commutative if side effects occur within the expression.
    This example works fine because there are no side effects or possible exceptions
    being shielded by the reordered evaluation of the && operator.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.6.3 Destructuring Code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Structured code is sometimes less efficient than unstructured code because it
    introduces code duplication or extra branches that might not be present in unstructured
    code. Most of the time, this is tolerable because unstructured code is difficult
    to read and maintain; sacrificing some performance in exchange for maintainable
    code is often acceptable. In certain instances, however, you may need all the
    performance you can get and might choose to compromise the readability of your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In HLLs, you can often get away with writing structured code because the compiler
    will optimize it, producing unstructured machine code. Unfortunately, when writing
    in assembly language, the machine code you get is exactly equivalent to the assembly
    code you write.
  prefs: []
  type: TYPE_NORMAL
- en: Taking previously written structured code and rewriting it in an unstructured
    fashion to improve performance is known is *destructuring code*. The difference
    between unstructured code and destructured code is that unstructured code was
    written that way in the first place; destructured code started out as structured
    code and was purposefully written in an unstructured fashion to make it more efficient.
    Pure unstructured code is usually hard to read and maintain. Destructured code
    isn’t quite as bad because you limit the damage (unstructuring the code) to only
    those sections where it is absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: One classic way to destructure code is to use *code movement*, physically moving
    sections of code elsewhere in the program. You move code that your program rarely
    uses out of the way of code that executes most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: Code movement can improve the efficiency of a program two ways. First, a branch
    that is taken is more expensive (time-consuming) than a branch that is not taken.
    If you move the rarely used code to another spot in the program and branch to
    it on the rare occasion the branch is taken, most of the time you will fall straight
    through to the code that executes most frequently. Second, sequential machine
    instructions consume cache storage. If you move rarely executed statements out
    of the normal code stream to another section of the program that is rarely loaded
    into cache, this will improve the cache performance of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following pseudo C/C++ statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In normal code, you don’t expect errors to be frequent. Therefore, you would
    typically expect the then section of the preceding if to execute far more often
    than the else clause. The preceding code could translate into the following assembly
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If the expression is false, this code falls through to the normal statements
    and then jumps over the error-handling statements. Instructions that transfer
    control from one point in your program to another (for example, b.al instructions)
    tend to be slow. It is much faster to execute a sequential set of instructions
    than to jump all over the place in your program. Unfortunately, the preceding
    code doesn’t allow this.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to rectify this problem is to move the else clause of the code somewhere
    else in your program. You could rewrite the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The program isn’t any shorter. The b.al you removed from the original sequence
    winds up at the end of the else clause. However, because the else clause rarely
    executes, moving the b.al instruction from the then clause (which executes frequently)
    to the else clause is a big performance win, because the then clause executes
    using only straight-line code. This technique is surprisingly effective in many
    time-critical code segments.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.6.4 Calculating Rather than Branching
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: On the ARM processor, branches are expensive compared to many other instructions.
    For this reason, it is sometimes better to execute more instructions in a sequence
    than fewer instructions that involve branching.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the simple assignment w0 = abs(w0). Unfortunately, no
    ARM instruction computes the absolute value of an integer. The obvious way to
    handle this is with an instruction sequence that uses a conditional jump to skip
    over the neg instruction (which creates a positive value in W0 if W0 was negative):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider the following sequence that will also do the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Not only is the instruction set shorter, it also doesn’t involve any branches,
    so it runs faster. This demonstrates why it’s good to know the instruction set!
  prefs: []
  type: TYPE_NORMAL
- en: Another example of calculation versus branching that you’ve seen is using the
    ccmp instruction to handle conjunction and disjunction in a Boolean expression
    (see section 7.6.5, “Short-Circuit vs. Complete Boolean Evaluation,” on [page
    382](chapter7.xhtml#pg_382)). Though they tend to execute more instructions than
    short-circuit evaluation, no branching is involved, and this often equates to
    faster-running code.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes calculation without branching isn’t possible. For certain types of
    branches (in particular, multiway branches), you can combine calculations with
    a single branch to handle complex operations, as discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.7 switch...case Statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The C/C++ switch statement takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: When this statement executes, it checks the value of the expression against
    the constants const1 to constn. If it finds a match, the corresponding statements
    execute.
  prefs: []
  type: TYPE_NORMAL
- en: C/C++ places a few restrictions on the switch statement. First, it allows only
    an integer expression (or something whose underlying type can be an integer).
    Second, all the constants in the case clauses must be unique. The next few subsections
    describe the semantics of the switch statement and various implementations and
    clarify the reasons for the restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.7.1 switch Statement Semantics
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Most introductory programming texts introduce the switch...case statement by
    explaining it as a sequence of if...then...elseif...else...endif statements. They
    might claim that the following two pieces of C/C++ code are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: While semantically these two code segments may be the same, their implementation
    is usually different. Whereas the if...then...elseif...else...endif chain does
    a comparison for each conditional statement in the sequence, the switch statement
    normally uses an indirect jump to transfer control to any one of several statements
    with a single computation.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.7.2 if...else Implementation of switch
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The switch (and if...else...elseif) statements could be written in assembly
    language with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This code takes longer to determine that the last case should execute than it
    does to determine whether the first case executes. This is because the if...else...elseif
    version implements a linear search through the case values, checking them one
    at a time from first to last until it finds a match.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.7.3 Indirect Jump switch Implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A faster implementation of the switch statement is possible by using an *indirect
    jump table* (a table containing target addresses to jump to). This implementation
    uses the switch expression as an index into a table of addresses; each address
    points at the target case’s code to execute. The following example demonstrates
    the use of a jump table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: To use the scaled-indexed addressing mode, this code begins by loading the address
    of the jump table (JmpTbl) into X1 ❶. Because JmpTbl is in the .text section (and
    nearby), the code uses the PC-relative addressing mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code fetches the *i*th entry from JmpTbl ❷. Because each entry in the jump
    table is 8 bytes long, the code must multiply the index (i, which is in X0) by
    8, which the lsl #3 argument handles. The base address (in X1) plus index times
    8 gives the address of the appropriate entry in JmpTbl.'
  prefs: []
  type: TYPE_NORMAL
- en: Because the entries in JmpTbl are offsets rather than absolute addresses (remember,
    macOS doesn’t allow absolute addresses in the .text section), you must convert
    the offset to an absolute address by adding in the base address of the jump table
    ❸ (as each entry in the table is an offset from the base address). The following
    br instruction transfers control to the appropriate case in the switch statement.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, a switch statement requires that you create an array of pointers,
    with each element containing the address of a statement label in your code; those
    labels must be attached to the sequence of instructions to execute for each case
    in the switch statement. As noted in the code annotations, macOS does not allow
    absolute addresses here, so the code uses offsets from the base address of the
    jump table, which also works for Linux. In this example, the JmpTbl array, initialized
    with the offsets of the statement labels Stmt0, Stmt1, and Stmt2, serves this
    purpose. You must place the jump-table array in a location that will never be
    executed as code (such as immediately after a br instruction, as in this example).
  prefs: []
  type: TYPE_NORMAL
- en: The program loads the W0 register with the value of i (assuming i is a 32-bit
    unsigned integer, the ldr instruction zero-extends W0 into X0). It then uses this
    value as an index into the JmpTbl array (W1 holds the base address of the JmpTbl
    array) and transfers control to the 8-byte address found at the specified location.
    For example, if W0 contains 0, the br x0 instruction will fetch the double word
    at address JmpTbl+0 (W0 × 8 = 0). Because the first double word in the table contains
    the offset of Stmt0, the br instruction transfers control to the first instruction
    following the Stmt0 label. Likewise, if i (and therefore, W0) contains 1, then
    the indirect br instruction fetches the double word at offset 8 from the table
    and transfers control to the first instruction following the Stmt1 label (because
    the offset of Stmt1 appears at offset 8 in the table). Finally, if i (W0) contains
    2, then this code fragment transfers control to the statements following the Stmt2
    label because it appears at offset 16 in the JmpTbl table.
  prefs: []
  type: TYPE_NORMAL
- en: As you add more (consecutive) cases, the jump-table implementation becomes more
    efficient (in terms of both space and speed) than the if...elseif form. Except
    for simple cases, the switch statement is almost always faster, and usually by
    a large margin. As long as the case values are consecutive, the switch statement
    version is often smaller as well.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.7.4 Noncontiguous Jump-Table Entries and Range Limiting
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: What happens if you need to include nonconsecutive case labels or can’t be sure
    the switch value doesn’t go out of range? With the C/C++ switch statement, such
    an occurrence will transfer control to the first statement after the switch statement
    (or to a default case, if one is present in the switch).
  prefs: []
  type: TYPE_NORMAL
- en: However, this doesn’t happen in the example in the previous section. If variable
    i does not contain 0, 1, or 2, executing the previous code produces undefined
    results. For example, if i contains 5 when you execute the code, the indirect
    br instruction will fetch the dword at offset 40 (5 × 8) in JmpTbl and transfer
    control to that offset. Unfortunately, JmpTbl doesn’t have six entries, so the
    program will fetch the value of the sixth double word following JmpTbl and use
    that as the target offset, which will often crash your program or transfer control
    to an unexpected location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to place a few instructions before the indirect br to verify
    that the switch selection value is within a reasonable range. In the previous
    example, you’d want to verify that the value of i is in the range 0 to 2 before
    executing the br instruction. If the value of i is outside this range, the program
    should simply jump to the endcase label, which corresponds to dropping down to
    the first statement after the entire switch statement. The following code provides
    this modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this code handles the problem of selection values being outside the
    range 0 to 2, it still suffers from two severe restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: The cases must start with the value 0\. That is, the minimum case constant has
    to be 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The case values must be contiguous.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solving the first problem is easy, and you deal with it in two steps. First,
    you compare the case selection value against a lower and upper bound before determining
    whether the case value is legal, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This code adds a pair of extra instructions, cmp and blo, to test the selection
    value to ensure it is in the range 5 to 7\. If not, control drops down to the
    EndCase label; otherwise, control transfers via the indirect br instruction. Unfortunately,
    as the comments point out, this code is broken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider what happens if variable i contains the value 5: the code will verify
    that 5 is in the range 5 to 7 and then will fetch the dword at offset 40 (5 ×
    8) and jump to that address. As before, however, this loads 8 bytes outside the
    bounds of the table and does not transfer control to a defined location. One solution
    is to subtract the smallest case selection value from W0 before executing the
    br instruction, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: By subtracting 5 from the value in W0, the code forces W0 to take on the value
    0, 1, or 2 prior to the br instruction. Therefore, case-selection value 5 jumps
    to Stmt5, case-selection value 6 transfers control to Stmt6, and case-selection
    value 7 jumps to Stmt7.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code has one piece of trickery: the subs instruction serves double duty.
    It not only adjusts the lower bound of the switch expression down to 0 but also
    serves as the comparison against 5 for the lower bound. Remember, the cmp instruction
    sets the flags the same way as the subs instruction. Therefore, subtracting 5
    is the same as comparing against 5 as far as the flag settings are concerned.
    When comparing the value in W0 against 7, the code must actually compare against
    2 because we’ve subtracted 5 from the original index value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can handle cases that don’t start with 0 in another way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This example subtracts 40 (5 × 8) from the base address of the jump table when
    loading that base address into X1\. The index is still in the range 5 to 7, yielding
    an offset of 40 to 56 into the table; however, because the base address is now
    specified 40 bytes before the actual table, the array-indexing calculation properly
    indexes into the jump-table entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C/C++ switch statement provides a default clause that executes if the case-selection
    value doesn’t match any of the case values. The following switch statement includes
    a default clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementing the equivalent of the default clause in pure assembly language
    is easy: just use a different target label in the blo and bhi instructions at
    the beginning of the code. The following example implements a switch statement
    similar to the preceding one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The second restriction noted earlier, that the case values need to be contiguous,
    is easy to handle by inserting extra entries into the jump table. Consider the
    following C/C++ switch statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The minimum switch value is 1, and the maximum value is 8\. Therefore, the code
    before the indirect br instruction needs to compare the value in i against 1 and
    8\. If the value is from 1 to 8, it’s still possible that i might not contain
    a legal case-selection value. However, because the br instruction indexes into
    a table of double words, the table must have eight double-word entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the values from 1 to 8 that are not case-selection values, simply
    put the statement label of the default clause (or the label specifying the first
    instruction after the end of the switch if there is no default clause) in each
    of the jump-table entries that don’t have a corresponding case clause. The following
    code demonstrates this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This code uses cmp instructions to ensure that the switch value is in the range
    1 to 8 and transfers control to the DefaultCase label if this is the case.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.7.5 Sparse Jump Tables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The current implementation of the switch statement has a problem. If the case
    values contain nonconsecutive entries that are widely spaced, the jump table could
    become exceedingly large. The following switch statement would generate an extremely
    large code file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In this situation, your program will be much smaller if you implement the switch
    statement with a sequence of if statements rather than using an indirect jump
    statement. However, the size of the jump table does not normally affect the execution
    speed of the program. If the jump table contains 2 entries or 2,000, the switch
    statement will execute the multiway branch in a constant amount of time. The if
    statement implementation requires a linearly increasing amount of time for each
    case label appearing in the case statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the biggest advantages to using assembly language over an HLL like Swift
    or C/C++ is that you get to choose the actual implementation of statements like
    switch. In some instances, you can implement a switch statement as a sequence
    of if...then...elseif statements, you can implement it as a jump table, or you
    can use a hybrid of the two. The following code examples demonstrate combining
    if...then...elseif and jump-table implementations for the same control structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'That code could become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Some switch statements have sparse cases, but the cases are often grouped into
    contiguous clusters. Consider the following C/C++ switch statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'You can convert a switch statement that consists of widely separated groups
    of (nearly) contiguous cases to assembly language code using one jump-table implementation
    for each contiguous group, then use comparison instructions to determine which
    jump-table instruction sequence to execute. Here’s one possible implementation
    of the previous C/C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This code sequence combines groups 0 to 2 and 10 to 11 into a single group (requiring
    seven additional jump-table entries) in order to save having to write an additional
    jump-table sequence. For a set of cases this simple, it’s easier to just use compare-and-branch
    sequences, but I’ve simplified this example to demonstrate multiple jump tables.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.7.6 Other switch Statement Alternatives
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'What happens if the cases are too sparse to do anything but compare the expression’s
    value case by case? In this situation, the code is not necessarily doomed to being
    translated into the equivalent of an if...elseif...else...endif sequence. However,
    before considering other alternatives, remember that not all if...elseif...else...endif
    sequences are created equal. Look back at the last example in the previous section
    (the sparse switch statement). A straightforward implementation might have been
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Instead, the former implementation first tests against the value 100 and branches
    based on the comparison being less than (cases 0 to 11) or greater than (cases
    1000 to 1001), effectively creating a small *binary search* that reduces the number
    of comparisons. It’s hard to see the savings in the HLL code, but in assembly
    code you can count the number of instructions that would be executed in the best
    and worst cases and see an improvement over the standard *linear search* approach
    of simply comparing the values in the cases in the order they appear in the switch
    statement. (Of course, if you have many groups in a sparse switch statement, a
    binary search will be much faster, on average, than a linear search.)
  prefs: []
  type: TYPE_NORMAL
- en: If your cases are too sparse (no meaningful groups at all), such as the 1, 10,
    100, 1,000, 10,000 example given in section 7.6.7.5, “Sparse Jump Tables,” on
    [page 399](chapter7.xhtml#pg_399), you can’t reasonably implement the switch statement
    by using a jump table. Rather than devolving into a straight linear search, which
    can be slow, a better solution is to sort your cases and test them by using a
    binary search.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a *binary search*, you first compare the expression value against the
    middle case value. If it’s less than the middle value, you repeat the search on
    the first half of the list of values; if it’s greater than the middle value, you
    repeat the test on the second half of the values; if it’s equal, obviously you
    drop into the code to handle that test. The following code shows the binary search
    version of the 1, 10, 100, ... example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The techniques presented in this section have many possible alternatives. For
    example, one common solution is to create a table containing a set of records,
    with each record entry a two-tuple containing a case value and a jump address.
    Rather than having a long sequence of compare instructions, a short loop can sequence
    through all the table elements, searching for the case value and transferring
    control to the corresponding jump address if a match occurs. This scheme is slower
    than the other techniques in this section, but it can be much shorter than the
    traditional if...elseif...else...endif implementation. With a little effort, you
    could use a binary search if the table is sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.7.7 Jump-Table Size Reductions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'All the switch statement examples up to this point have used double-word arrays
    for the jump table. With a 64-bit offset, these jump tables can transfer control
    to any location in the ARM’s address space. In reality, this range is almost never
    necessary. Most offsets will be relatively small numbers (often less than ±128,
    or ±32,767). This means that the HO bits of the jump-table entries will likely
    be all 0s or all 1s (if the offset is negative). With a slight modification to
    the instructions that transfer control through the jump table, cutting the size
    of the table in half is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This example has three modifications to the other examples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The scaled-indexed addressing mode (ldr instruction) scales the index (in X0)
    by 4 instead of 8 (because we’re accessing elements of a word array rather than
    a dword array).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The add instruction sign-extends W0 to 64 bits before adding the value with
    X1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The jump table contains word entries instead of dword entries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This modification limits the range of the case labels to ±2GB around the jump
    table, rather than the full 64-bit address space—hardly a limitation for most
    programs. In exchange for this limit, the jump table is now half its original
    size.
  prefs: []
  type: TYPE_NORMAL
- en: Before you get the sneaky idea of reducing the size of the table entries to
    16 bits (giving you a ±32K range), be aware that neither macOS’s nor Linux’s object
    code format—Mach-O and the Executable Linkable Format (ELF), respectively—supports
    16-bit relocatable offsets; 32-bit offsets are the best you can do.
  prefs: []
  type: TYPE_NORMAL
- en: 7.7 State Machines and Indirect Jumps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another control structure commonly found in assembly language programs is the
    state machine. In basic terms, a *state machine* is a piece of code that keeps
    track of its execution history by entering and leaving certain states. A state
    machine uses a *state variable* to control program flow. The FORTRAN programming
    language provides this capability with the assigned goto statement. Certain variants
    of C, such as GNU’s GCC from the Free Software Foundation, provide similar features.
    In assembly language, the indirect jump can implement state machines.
  prefs: []
  type: TYPE_NORMAL
- en: In one sense, all programs are state machines. The CPU registers and values
    in memory constitute the state of that machine. However, this chapter uses a much
    more constrained definition. For most purposes, only a single variable (or the
    value in the PC register) will denote the current state.
  prefs: []
  type: TYPE_NORMAL
- en: For a concrete example of a state machine, suppose you have a procedure and
    want to perform one operation the first time you call it, a different operation
    the second time you call it, something else the third time you call it, and then
    something new again on the fourth call. After the fourth call, the code repeats
    these four operations in order. For example, say you want the procedure to add
    W0 and W1 the first time, subtract them on the second call, multiply them on the
    third, and divide them on the fourth. You could implement this procedure as shown
    in Listing 7-4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: This code uses X19 to maintain the state variable ❶. The main program preserves
    X19 (and X20) ❷ and then initializes the state machine to state 0 ❸. The code
    then makes successive calls to the state machine functions and prints the results
    from state 0 ❹, 1 ❺, 2 ❻, and 3 ❼. After executing in state 3, the code returns
    to state 0 and prints the result ❽.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and program output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Technically, the StateMachine procedure is not the state machine. Instead, the
    variable state and the cmp/bne instructions constitute the state machine. The
    procedure is little more than a switch statement implemented via the if...then...elseif
    construct. The only unique thing is that it remembers how many times it has been
    called (or rather, how many times, modulo 4, it has been called) and behaves differently
    depending on the number of calls.
  prefs: []
  type: TYPE_NORMAL
- en: While this is a *correct* implementation of the desired state machine, it is
    not particularly efficient. The astute reader may recognize that this code could
    be made a little faster by using an actual switch statement rather than the if...then...elseif...endif
    implementation. However, an even better solution exists.
  prefs: []
  type: TYPE_NORMAL
- en: It’s common to use an indirect jump to implement a state machine in assembly
    language. Rather than having a state variable that contains a value like 0, 1,
    2, or 3, we could load the state variable with the *address* of the code to execute
    upon entry into the procedure. By simply jumping to that address, the state machine
    could save the tests needed to select the proper code fragment. Consider the implementation
    in Listing 7-5 using the indirect jump.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This code has the same structure as Listing 7-4\. The main difference is that
    this code assumes that the target address of the state machine is in X19 rather
    than a state number.
  prefs: []
  type: TYPE_NORMAL
- en: The br instruction at the beginning of the StateMachine procedure ❶ transfers
    control to the location pointed at by the state variable (X19). The first time
    you call StateMachine, it points at the state0 label. Thereafter, each subsection
    of code sets the state variable to point at the appropriate successor code. Within
    each state of the state machine ❷, the code sets X19 to the address of the next
    entry point of the state machine (rather than setting a state number). The main
    program initializes the state machine with the address of the State0 label ❸ rather
    than the value 0\. Otherwise, this main program is largely the same as in Listing
    7-4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and program output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This output demonstrates that Listing 7-5 behaves in a manner similar to Listing
    7-4.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8 Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Loops represent the final basic control structure (sequences, decisions, and
    loops) that make up a typical program. Most HLLs have implied loop structures
    hidden away. For example, consider the BASIC statement if A$ = B$ then 100. This
    if statement compares two strings and jumps to statement 100 if they are equal.
    In assembly language, you would need to write a loop to compare each character
    in A$ to the corresponding character in B$ and then jump to statement 100 if and
    only if all the characters matched. (The C stdlib provides the strcmp routine
    that compares the strings for you, effectively hiding the loop. However, if you
    were to write this function yourself, the looping nature of the operation would
    be obvious.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Program loops consist of three components: an optional initialization component,
    an optional loop-termination test, and the body of the loop. The order in which
    you assemble these components can dramatically affect the loop’s operation. Three
    permutations of these components appear frequently in programs: while loops, repeat...until
    loops (do...while in C/C++), and infinite loops (for example, for(;;) in C/C++).
    This section covers those three loop types along with C-style for loops (definite
    loops), register usage in loops, and breaking out of loops.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.8.1 while
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The most generic loop is the while loop. In C/C++, it takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In the while loop, the termination test appears at the beginning of the loop.
    As a direct consequence of the position of the termination test, the body of the
    loop may never execute if the Boolean expression is always false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following C/C++ while loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The i = 0; statement is the initialization code for this loop. i is a loop-control
    variable, because it controls the execution of the body of the loop. i < 100 is
    the loop-termination condition: the loop will not terminate as long as i is less
    than 100\. The single statement ++i; (increment i) is the loop body that executes
    on each loop iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A C/C++ while loop can be easily synthesized using if and goto statements.
    For example, you may replace the previous C while loop with the following C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'More generally, you can construct any while loop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, you can use the techniques from earlier in this chapter to convert
    if statements to assembly language and add a single b.al instruction to produce
    a while loop. The example in this section translates to the following pure ARM
    assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: GCC will actually convert most while statements to different ARM code than this
    section presents. The reason for the difference appears in section 7.9.1, “Moving
    the Termination Condition to the End of a Loop,” on [page 428](chapter7.xhtml#pg_428),
    which explores how to write more efficient loop code.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8.2 repeat...until
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The repeat...until loop, also called the do...while loop in C, tests for the
    termination condition at the end of the loop rather than at the beginning. In
    Pascal, the repeat...until loop takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'This is comparable to the following C/C++ do...while loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This sequence executes the initialization code, then executes the loop body,
    and finally tests a condition to see whether the loop should repeat. If the Boolean
    expression evaluates to false, the loop repeats; otherwise, the loop terminates.
    In the repeat...until loop, the termination test appears at the end of the loop
    and, as a direct consequence, the loop body always executes at least once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the while loop, the repeat...until loop can be synthesized with an if
    statement and a b.al (branch). The following is an example of just such an implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the material presented in the previous sections, you can easily synthesize
    repeat...until loops in assembly language, as shown in the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The repeat...until loop has a slightly more efficient implementation because
    it combines the loop termination test and the branch back to the beginning of
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8.3 forever/endfor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If while loops test for termination at the beginning of the loop and repeat...until
    and do...while loops check for termination at the end of the loop, the only place
    left to test for termination is in the middle of the loop. The C/C++ high-level
    for(;;) loop, combined with the break statement, provides this capability. The
    C/C++ infinite loop takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no explicit termination condition. The for(;;) construct forms an
    infinite loop. A break statement usually handles loop termination. Consider the
    following C++ code that employs a for(;;) construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting a for(;;) loop to pure assembly language is easy: all you need is
    a label and a b.al instruction. The break statement in this example is also nothing
    more than a b.al instruction (or conditional jump). The pure assembly language
    version of the preceding code looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the forever loop has a very simple implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8.4 for
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The standard for loop is a special form of the while loop that repeats the
    loop body a specific number of times, which is known as a *definite* loop. In
    C/C++, the for loop takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Traditionally, programs use the for loop to process arrays and other objects
    accessed in sequential order. You normally initialize a loop-control variable
    with the initialization statement, then use the loop-control variable as an index
    into the array (or other data type), as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert this to pure assembly language, begin by translating the for loop
    into an equivalent while loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using the techniques from section 7.8.1, “while,” on [page 415](chapter7.xhtml#pg_415),
    translate the code into pure assembly language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: This is a fairly efficient implementation of a while loop in assembly language,
    though for for loops that execute a fixed number of times, you might consider
    using the cbnz instruction (see section 7.8.6, “ARM Looping Instructions,” on
    [page 425](chapter7.xhtml#pg_425)).
  prefs: []
  type: TYPE_NORMAL
- en: 7.8.5 break and continue
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The C/C++ break and continue statements both translate into a single b.al instruction.
    The break statement exits the loop that immediately contains the break statement;
    the continue statement restarts the loop that contains the continue statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert a break statement to pure assembly language, just emit a goto/b.al
    instruction that transfers control to the first statement following the end of
    the loop to exit. You can do this by placing a label after the loop body and jumping
    to that label. The following code fragments demonstrate this technique for the
    various loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: In pure assembly language, convert the appropriate control structures to assembly
    and replace the goto with a b.al instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The continue statement is slightly more complex than the break statement. The
    implementation is still a single b.al instruction; however, the target label doesn’t
    wind up going in the same spot for each of the loops. [Figures 7-2](chapter7.xhtml#fig7-2)
    through [7-5](chapter7.xhtml#fig7-5) show where the continue statement transfers
    control for each of the loops.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-2](chapter7.xhtml#fig7-2) shows the for(;;) loop with a continue
    statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-2: The continue destination and the for(;;) loop'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-3](chapter7.xhtml#fig7-3) shows the while loop with a continue statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-3: The continue destination and the while loop'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-4](chapter7.xhtml#fig7-4) shows a C/C++ for loop with a continue
    statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-4: The continue destination and the for loop'
  prefs: []
  type: TYPE_NORMAL
- en: Note in [Figure 7-4](chapter7.xhtml#fig7-4) that the continue statement forces
    the execution of incStmt and then transfers control to the test for loop termination.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-5](chapter7.xhtml#fig7-5) shows a repeat...until loop with a continue
    statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure7-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-5: The continue destination and the repeat... until loop'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code fragments demonstrate how to convert the continue statement
    into an appropriate b.al instruction for each of these loop types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: In each case, the b.al instruction transfers control to the point in the loop
    where it will test the loop condition and increment the loop control variable
    (for for loops), or to the beginning of the loop’s body.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8.6 ARM Looping Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ARM CPU provides four machine instructions that are useful for creating
    loops. These instructions violate the RISC principle of “an instruction does only
    one thing,” but they are quite handy even if they are a little “CISCy.”
  prefs: []
  type: TYPE_NORMAL
- en: The first two instructions test a register’s value and branch if that register
    is equal to, or not equal to, 0\. The two instructions are cbz (compare and branch
    if zero) and cbnz (compare and branch if not zero). Their syntax is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: where X*n* and W*n* are the register to compare against 0 and label is a statement
    label within ±1MB of the current instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'These instructions are equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Another useful pair of instructions are tbz (test bit for 0 and branch) and
    tbnz (test bit for not 0 and branch). These instructions test a bit in a register
    and branch based on that bit’s value (0 or nonzero). The syntax for these instructions
    is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: where X*n* and W*n* are the register to test, *imm**[6]* is a bit number in
    the range 0–63 for 64-bit registers and 0–31 for 32-bit registers, and label is
    a statement label within ±32KB of the current instruction. The tbz instruction
    branches to the label if the specified bit in the register is 0, while the tbnz
    instruction branches if the bit is not 0.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8.7 Register Usage and Loops
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given that the ARM accesses registers more efficiently than memory locations,
    registers are the ideal spot to place loop-control variables (especially for small
    loops). However, registers are a limited resource, despite the many registers
    available on the ARM. Unlike with memory, you cannot place much data in the registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loops present a special challenge for registers. Registers are perfect for
    loop-control variables because they’re efficient to manipulate and can serve as
    indexes into arrays and other data structures (a common use for loop-control variables).
    However, the limited availability of registers often creates problems when using
    registers in this fashion. This is especially true if you call other functions/procedures
    within the loops, which limits you to using nonvolatile registers for loop control
    variables. Consider the following code with nested loops that will not work properly
    because it attempts to reuse a register (X19) that is already in use, leading
    to the corruption of the outer loop’s loop-control variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The intent here was to create a set of nested loops, one loop inside another.
    The inner loop (loop2) should repeat four times for each of the eight executions
    of the outer loop (loop1). Unfortunately, both loops use the same register as
    a loop-control variable. Therefore, this will form an infinite loop. Because W19
    is always 0 upon encountering the second subs instruction, control will always
    transfer to the loop1 label (because decrementing 0 produces a nonzero result).
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to save and restore the W19 register or to use a different
    register in place of W19 for the outer loop; the following code demonstrates preserving
    W19 across the execution of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Register corruption is one of the primary sources of bugs in loops in assembly
    language programs, so always keep an eye out for this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Until this point, this chapter has mainly focused on the correct implementation
    of various types of loops in assembly language. The next section begins discussing
    how to write loops efficiently in assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: '### 7.9 Loop Performance Improvements'
  prefs: []
  type: TYPE_NORMAL
- en: Because loops are the primary source of performance problems within a program,
    they are also the place to look when attempting to speed up your software. A treatise
    on how to write efficient programs is beyond the scope of this chapter, but you
    should be aware of the following concepts when designing loops in your programs.
    They’re all aimed at removing unnecessary instructions from your loops in order
    to reduce the time it takes to execute a single iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.1 Moving the Termination Condition to the End of a Loop
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As you may have noticed, the repeat...until loop is slightly more efficient
    than a while loop. This is because repeat...until manages to combine the loop’s
    Boolean test along with the branch back to the beginning of the loop. You can
    improve the other loops to be slightly more efficient. Consider the following
    flow graphs for the three types of loops presented earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The repeat...until loop is the simplest of the bunch. This is reflected in
    the assembly language implementation of these loops. Consider the following semantically
    identical repeat...until and while loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Testing for the termination condition at the end of the loop allows you to remove
    a b.al instruction from the loop, which can be significant if the loop is nested
    inside other loops. Given the definition of the loop, you can easily see that
    the loop will execute exactly 20 times, which suggests that the conversion to
    a repeat...until loop is trivial and always possible. Unfortunately, it’s not
    always quite this easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, you don’t know what W0 contains upon entry into the loop.
    Therefore, you cannot assume that the loop body will execute at least once. This
    means you must test for loop termination before executing the body of the loop.
    The test can be placed at the end of the loop with the inclusion of a single b.al
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Although the code is as long as the original while loop, the b.al instruction
    executes only once rather than on each repetition of the loop. However, the slight
    gain in efficiency is obtained via a slight loss in readability, so be sure to
    comment it. The second code sequence is also closer to spaghetti code than the
    original implementation. Such is often the price of a small performance gain.
    Carefully analyze your code to ensure that such a performance boost is worth the
    loss of clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.2 Executing the Loop Backward
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because of the nature of the flags on the ARM, loops that repeat from a number
    down to (or up to) 0 are more efficient than loops that execute from 0 to another
    value. Compare the following C/C++ for loop and the comparable assembly language
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider another loop that also has eight iterations but runs its loop-control
    variable from 8 down to 1 rather than from 1 up to 8, thereby saving a comparison
    on each repetition of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Saving the execution time of the cmp instruction on each iteration of the loop
    may result in faster code. Unfortunately, you cannot force all loops to run backward.
    However, with a little effort and some coercion, you should be able to write many
    for loops so that they operate backward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example worked out well because the loop ran from 8 down to 1\.
    The loop terminated when the loop-control variable became 0\. What happens if
    you need to execute the loop when the loop-control variable goes to 0? For example,
    suppose that the preceding loop needed to range from 7 down to 0\. As long as
    the lower bound is nonnegative, you can substitute the bpl instruction in place
    of the bne instruction in the earlier code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: This loop will repeat eight times, with W0 (j) taking on the values 7 to 0\.
    When W0 decrements 0 to –1, it sets the sign flag and the loop terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that some values may look positive but are actually negative. If
    the loop-control variable is a word, values in the range 2,147,483,648 to 4,294,967,295
    are negative in the two’s complement system. Therefore, initializing the loop-control
    variable with any 32-bit value in this range (or, of course, 0) terminates the
    loop after a single execution. This can get you into trouble if you’re not careful.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.3 Eliminating Loop-Invariant Calculations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *loop-invariant computation* is a calculation that appears within a loop
    that always yields the same result. You needn’t do such computations inside the
    loop but can instead compute them outside the loop and reference the value of
    the computations inside the loop. The following C code demonstrates an invariant
    computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Because j never changes throughout the execution of this loop, the subexpression
    j - 2 can be computed outside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'This translates to the following assembly code, which moves the invariant calculation
    outside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 7.9.4 Unraveling Loops
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For small loops—those whose bodies are composed of just a few statements—the
    overhead required to process the loop may constitute a significant percentage
    of the total processing time. For example, consider the following Pascal code
    and its associated ARM assembly language code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Three instructions execute on each repetition of the loop. Only one instruction
    is doing the desired operation (moving a 0 into an element of A). The remaining
    two instructions control the loop. Therefore, it takes 12 instructions to do the
    operation logically required by 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we could make many improvements to this loop based on the information
    presented thus far, consider carefully exactly what it is that this loop is doing:
    it’s storing four 0s into A[0] through A[3]. A more efficient approach is to use
    four str instructions to accomplish the same task. For example, if A is an array
    of words, the following code initializes A much faster than the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Although this is a simple example, it shows the benefit of *loop unraveling*
    (also known as *loop unrolling*), which consists of repeating the loop’s body
    as source code for each iteration of the loop. If this simple loop appeared buried
    inside a set of nested loops, the 3:1 instruction reduction could possibly double
    the performance of that section of your program. (It would be criminal not to
    mention at this point that you could cut this down to two instructions by storing
    XZR, a double word, into A + 0 and A + 8, though that is a different optimization.)
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you cannot unravel all loops. Loops that execute a variable number
    of times are difficult to unravel because there is rarely a way to determine at
    assembly time the number of loop iterations. Therefore, unraveling a loop is a
    process best applied to loops that execute a known number of times, with the number
    of times known at assembly time.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you repeat a loop a fixed number of iterations, it may not be a good
    candidate for loop unraveling. Loop unraveling produces impressive performance
    improvements when the number of instructions controlling the loop (and handling
    other overhead operations) represents a significant percentage of the total number
    of instructions in the loop. Had the previous loop contained 36 instructions in
    the body (exclusive of the 3 overhead instructions), the performance improvement
    would be, at best, only 10 percent, compared with the 300 to 400 percent it now
    enjoys.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the costs of unraveling a loop—all the extra code that must be inserted
    into your program—quickly reach a point of diminishing returns as the body of
    the loop grows larger or as the number of iterations increases. Furthermore, entering
    that code into your program can become quite a chore. Therefore, loop unraveling
    is a technique best applied to small loops.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.5 Using Induction Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This section introduces optimizations based on induction variables. An *induction
    variable* is one whose value depends entirely on the value of another variable.
    Consider the following Pascal loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the program is initializing each element of an array of character sets
    to the empty set. The straightforward code to achieve this is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Although unraveling this code will still improve performance, it will take 2,304
    instructions to accomplish this task—too many for all but the most time-critical
    applications. However, you can reduce the execution time of the loop’s body by
    using induction variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the index into the array csetVar tracks the loop-control
    variable; it’s always equal to the value of the loop-control variable times 16\.
    Because i doesn’t appear anywhere else in the loop, there is no sense in performing
    the computations on i. Why not operate directly on the array index value? Furthermore,
    because the scaled-indexed addressing mode doesn’t support an integer offset component,
    the code is constantly adding 8 to or subtracting 8 from X20 to initialize the
    second half of each character set element. This computation can also be worked
    into the induction of the loop control variable. The following code demonstrates
    this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: The induction that takes place in this example occurs when the code initializes
    the loop control variable with the address of the array (moved into X20 for efficiency)
    and then increments it by 16 on each iteration of the loop rather than by 1\.
    This allows the code to use the indirect-plus- offset addressing mode (rather
    than the scaled-indexed addressing mode), as no shift is required. Once the code
    can use the indirect-plus-offset mode, it can drop the addition and subtraction
    of the loop control variable in order to access the second half of each character
    set array element.
  prefs: []
  type: TYPE_NORMAL
- en: 7.10 Moving On
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After mastering the material in this chapter and the chapters up to this point,
    you should be capable of translating many HLL programs into assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covered several concepts concerning the implementation of loops
    in assembly language. It discussed statement labels, including working with their
    addresses, efficiently representing pointers to labels in your programs, using
    unconditional and indirect branches, working with veneers, and transferring control
    to statements beyond the range of the ARM branches. It then covered decisions:
    how to implement if...then...else...elseif, switch statements, state machines
    in assembly language, Boolean expressions, and complete/short-circuit evaluation.
    It also described how to utilize 32-bit PC-relative addresses to reduce jump-table
    (and pointer) sizes. Finally, this chapter described various kinds of loops, improving
    loop performance, and the special ARM machine instructions that support loop construction.'
  prefs: []
  type: TYPE_NORMAL
- en: You’re now prepared to start writing some serious assembly language code. Starting
    with the next chapter, you’ll learn some intermediate assembly language programming
    that enables you to write code that is difficult or impossible to write in HLLs.
  prefs: []
  type: TYPE_NORMAL
- en: 7.11 For More Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: My book *Write Great Code,* Volume 2, 2nd edition (No Starch Press, 2020) provides
    a good discussion of the implementation of various HLL control structures in low-level
    assembly language. It also discusses optimizations such as induction, unrolling,
    strength reduction, and so on that apply to optimizing loops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
