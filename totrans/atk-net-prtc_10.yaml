- en: '**10**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10**'
- en: '**FINDING AND EXPLOITING SECURITY VULNERABILITIES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**寻找和利用安全漏洞**'
- en: Parsing the structure of a complex network protocol can be tricky, especially
    if the protocol parser is written in a memory-unsafe programming language, such
    as C/C++. Any mistake could lead to a serious vulnerability, and the complexity
    of the protocol makes it difficult to analyze for such vulnerabilities. Capturing
    all the possible interactions between the incoming protocol data and the application
    code that processes it can be an impossible task.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 解析复杂网络协议的结构可能是棘手的，特别是当协议解析器是用内存不安全的编程语言（如 C/C++）编写时。任何错误都可能导致严重漏洞，而协议的复杂性使得分析这些漏洞变得困难。捕捉到所有进出协议数据与处理它的应用程序代码之间的可能交互可能是一项不可能完成的任务。
- en: This chapter explores some of the ways you can identify security vulnerabilities
    in a protocol by manipulating the network traffic going to and from an application.
    I’ll cover techniques such as fuzz testing and debugging that allow you to automate
    the process of discovering security issues. I’ll also put together a quick-start
    guide on triaging crashes to determine their root cause and their exploitability.
    Finally, I’ll discuss the exploitation of common security vulnerabilities, what
    modern platforms do to mitigate exploitation, and ways you can bypass these exploit
    mitigations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了一些通过操控进出应用程序的网络流量来识别协议中安全漏洞的方法。我将介绍模糊测试和调试等技术，这些技术可以自动化发现安全问题的过程。我还会提供一个快速入门指南，介绍如何通过快速定位崩溃问题来确定其根本原因及其可利用性。最后，我将讨论常见安全漏洞的利用、现代平台为缓解漏洞利用所做的努力，以及如何绕过这些漏洞缓解措施。
- en: '**Fuzz Testing**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**模糊测试**'
- en: Any software developer knows that testing the code is essential to ensure that
    the software behaves correctly. Testing is especially important when it comes
    to security. Vulnerabilities exist where a software application’s behavior differs
    from its original intent. In theory, a good set of tests ensures that this doesn’t
    happen. However, when working with network protocols, it’s likely you won’t have
    access to any of the application’s tests, especially in proprietary applications.
    Fortunately, you can create your own tests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 任何软件开发人员都知道，测试代码对于确保软件正确运行至关重要。尤其是涉及到安全性时，测试显得尤为重要。漏洞存在于软件应用的行为偏离其原始意图的地方。理论上，良好的测试集可以确保这种情况不会发生。然而，在处理网络协议时，通常无法访问任何应用程序的测试，尤其是专有应用程序。幸运的是，你可以创建自己的测试。
- en: '*Fuzz testing*, commonly referred to as *fuzzing*, is a technique that feeds
    random, and sometimes not-so-random, data into a network protocol to force the
    processing application to crash in order to identify vulnerabilities. This technique
    tends to yield results no matter the complexity of the network. Fuzz testing involves
    producing multiple test cases, essentially modified network protocol structures,
    which are then sent to an application for processing. These test cases can be
    generated automatically using random modifications or under direction from the
    analyst.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*模糊测试*，通常被称为 *fuzzing*，是一种向网络协议中输入随机（有时并非完全随机）数据的技术，目的是强制处理应用程序崩溃，从而识别漏洞。这项技术无论网络复杂性如何，都能得到结果。模糊测试涉及生成多个测试用例，实质上是修改过的网络协议结构，这些测试用例随后被发送到应用程序进行处理。这些测试用例可以通过随机修改或在分析师的指导下自动生成。'
- en: '***The Simplest Fuzz Test***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***最简单的模糊测试***'
- en: Developing a set of fuzz tests for a particular protocol is not necessarily
    a complex task. At its simplest, a fuzz test can just send random garbage to the
    network endpoint and see what happens.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为特定协议开发一套模糊测试并不一定是复杂的任务。在最简单的情况下，模糊测试只需向网络端点发送随机垃圾数据，然后观察发生了什么。
- en: 'For this example, we’ll use a Unix-style system and the Netcat tool. Execute
    the following on a shell to yield a simple fuzzer:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用 Unix 风格的系统和 Netcat 工具。在 shell 中执行以下命令，得到一个简单的模糊测试工具：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This one-line shell command reads data from the system’s random number generator
    device using the `cat` command. The resulting random data is piped into `netcat`,
    which opens a connection to a specified endpoint as instructed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这条一行的 shell 命令使用 `cat` 命令从系统的随机数生成设备读取数据。生成的随机数据被传送到 `netcat`，后者根据指示打开与指定端点的连接。
- en: This simple fuzzer will likely only yield a crash on simple protocols with few
    requirements. It’s unlikely that simple random generation would create data that
    meets the requirements of a more complex protocol, such as valid checksums or
    magic values. That said, you’d be surprised how often a simple fuzz test can give
    you valuable results; because it’s so quick to do, you might as well try it. Just
    don’t use this fuzzer on a live industrial control system managing a nuclear reactor!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的模糊器可能仅会在要求较少的简单协议中引发崩溃。简单的随机生成不太可能创建符合更复杂协议要求的数据，比如有效的校验和或魔法值。不过，你会惊讶于一个简单的模糊测试竟然能给你带来有价值的结果；因为它非常快速，所以你不妨试试。只是千万不要在管理核反应堆的实时工业控制系统上使用这个模糊器！
- en: '***Mutation Fuzzer***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***变异模糊器***'
- en: Often, you’ll need to be more selective about what data you send to a network
    connection to get the most useful information. The simplest technique in this
    case is to use existing protocol data, mutate it in some way, and then send it
    to the receiving application. This mutation fuzzer can work surprisingly well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要更有选择性地决定发送给网络连接的数据，以获得最有用的信息。在这种情况下，最简单的技术是使用现有的协议数据，对其进行某种变异，然后将其发送到接收应用程序。这个变异模糊器可能会出奇地有效。
- en: 'Let’s start with the simplest possible mutation fuzzer: a random bit flipper.
    [Listing 10-1](../Text/ch10.xhtml#ch10list1) shows a basic implementation of this
    type of fuzzer.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的变异模糊器开始：一个随机比特翻转器。[清单 10-1](../Text/ch10.xhtml#ch10list1)展示了这种类型的模糊器的基本实现。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 10-1: A simple random bit flipper mutation fuzzer*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-1：一个简单的随机比特翻转变异模糊器*'
- en: The `SimpleFuzzer()` function takes in the data to fuzz and the length of the
    data, and then generates a random number between 0 and the length of the data
    as the byte of the data to modify. Next, it decides which bit in that byte to
    change by generating a number between 0 and 7\. Then it toggles the bit using
    the XOR operation and sends the mutated data to its network destination.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleFuzzer()`函数接受需要模糊处理的数据和数据的长度，然后生成一个介于0和数据长度之间的随机数，作为要修改的数据字节。接下来，它通过生成一个介于0和7之间的数字来决定要更改字节中的哪个比特位。然后，它使用异或（XOR）操作翻转该比特，并将变异后的数据发送到其网络目的地。'
- en: This function works when, by random chance, the fuzzer modifies a field in the
    protocol that is then used incorrectly by the application. For example, your fuzzer
    might modify a length field set to 0x40 by converting it to a length field of
    0x80000040\. This modification might result in an integer overflow if the application
    multiplies it by 4 (for an array of 32-bit values, for example). This modification
    could also cause the data to be malformed, which would confuse the parsing code
    and introduce other types of vulnerabilities, such as an invalid command identifier
    that results in the parser accessing an incorrect location in memory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当模糊器随机地修改协议中的某个字段，而该字段随后被应用程序错误使用时，这个函数就能发挥作用。例如，模糊器可能会通过将一个长度字段从0x40改为0x80000040来修改长度字段。如果应用程序将该值乘以4（例如，用于一个32位值的数组），这可能导致整数溢出。这个修改还可能导致数据格式错误，从而使解析代码混乱并引入其他类型的漏洞，比如无效的命令标识符，导致解析器访问内存中的错误位置。
- en: You could mutate more than a single bit in the data at a time. However, by mutating
    single bits, you’re more likely to localize the effect of the mutation to a similar
    area of the application’s code. Changing an entire byte could result in many different
    effects, especially if the value is used for a set of flags.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在数据中一次改变多个比特位。然而，通过单比特变异，你更有可能将变异的影响局限在应用程序代码的类似区域。改变一个完整的字节可能会导致许多不同的效果，特别是当该值用于一组标志时。
- en: You’ll also need to recalculate any checksums or critical fields, such as total
    length values after the data has been fuzzed. Otherwise, the resulting parsing
    of the data might fail inside a verification step before it ever gets to the area
    of the application code that processes the mutated value.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据被模糊处理之后，你还需要重新计算任何校验和或关键字段，例如总长度值。否则，数据解析可能会在验证步骤中失败，甚至还没到达处理变异值的应用程序代码区域。
- en: '***Generating Test Cases***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***生成测试用例***'
- en: When performing more complex fuzzing, you’ll need to be smarter with your modifications
    and understand the protocol to target specific data types. The more data that
    passes into an application for parsing, the more complex the application will
    be. In many cases, inadequate checks are made at edge cases of protocol values,
    such as length values; then, if we already know how the protocol is structured,
    we can generate our own test cases from scratch.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行更复杂的模糊测试时，你需要更聪明地修改并理解协议，以便针对特定的数据类型进行测试。传入应用程序进行解析的数据越多，应用程序的复杂性就越高。在许多情况下，协议值的边缘情况（如长度值）检查不足；如果我们已经知道协议的结构，就可以从头开始生成自己的测试用例。
- en: Generating our own test cases gives us precise control over the protocol fields
    used and their sizes. However, test cases are more complex to develop, and careful
    thought must be given to the kinds you want to generate. Generating test cases
    allows you to test for types of protocol values that might never be used when
    you capture traffic to mutate. But the advantage is that you’ll exercise more
    of the application’s code and access areas of code that are likely to be less
    well tested.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 生成自己的测试用例使我们能够精确控制所使用的协议字段及其大小。然而，测试用例的开发更为复杂，需要仔细思考你想生成的类型。生成测试用例允许你测试那些在捕获流量并进行变异时可能永远不会使用的协议值类型。但它的优点是，你将运行更多应用程序的代码，并访问那些可能测试较少的代码区域。
- en: '**Vulnerability Triaging**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**漏洞分类**'
- en: 'After you’ve run a fuzzer against a network protocol and the processing application
    has crashed, you’ve almost certainly found a bug. The next step is to find out
    whether that bug is a vulnerability and what type of vulnerability it might be,
    which depends on how and why the application crashed. To do this analysis, we
    use *vulnerability triaging*: taking a series of steps to search for the root
    cause of a crash. Sometimes the cause of the bug is clear and easy to track down.
    Sometimes a vulnerability causes corruption of an application seconds, if not
    hours, after the corruption occurs. This section describes ways to triage vulnerabilities
    and increase your chances of finding the root cause of a particular crash.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在你对一个网络协议运行模糊测试并且处理该协议的应用程序崩溃后，你几乎可以确定找到了一个bug。下一步是确定这个bug是否是一个漏洞，并且它可能是哪种类型的漏洞，这取决于应用程序崩溃的方式和原因。为了进行这种分析，我们使用*漏洞分类*：采取一系列步骤，寻找崩溃的根本原因。有时，bug的原因非常清晰，容易追踪；有时，漏洞会在几秒钟内，甚至在几小时后，导致应用程序损坏。本节将描述如何分类漏洞，并增加你找到特定崩溃根本原因的机会。
- en: '***Debugging Applications***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调试应用程序***'
- en: Different platforms allow different levels of control over your triaging. For
    an application running on Windows, macOS, or Linux, you can attach a debugger
    to the process. But on an embedded system, you might only have crash reports in
    the system log to go on. For debugging, I use CDB on Windows, GDB on Linux, and
    LLDB on macOS. All these debuggers are used from the command line, and I’ll provide
    some of the most useful commands for debugging your processes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不同平台对漏洞分类的控制程度不同。对于在Windows、macOS或Linux上运行的应用程序，你可以将调试器附加到进程上。但在嵌入式系统中，你可能只能依赖系统日志中的崩溃报告。对于调试，我在Windows上使用CDB，在Linux上使用GDB，在macOS上使用LLDB。所有这些调试器都可以通过命令行使用，我将提供一些调试进程时最有用的命令。
- en: '**Starting Debugging**'
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**开始调试**'
- en: To start debugging, you’ll first need to attach the debugger to the application
    you want to debug. You can either run the application directly under the debugger
    from the command line or attach the debugger to an already-running process based
    on its process ID. [Table 10-1](../Text/ch10.xhtml#ch10tab1) shows the various
    commands you need for running the three debuggers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始调试，首先需要将调试器附加到你要调试的应用程序。你可以从命令行直接在调试器下运行应用程序，或者基于进程ID将调试器附加到一个已经在运行的进程上。[表10-1](../Text/ch10.xhtml#ch10tab1)显示了运行三种调试器所需的各种命令。
- en: '**Table 10-1:** Commands for Running Debuggers on Windows, Linux, and macOS'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**表10-1：** 在Windows、Linux和macOS上运行调试器的命令'
- en: '| **Debugger** | **New process** | **Attach process** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **调试器** | **新进程** | **附加进程** |'
- en: '| --- | --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| CDB | `cdb application.exe [arguments`] | `cdb -p PID` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| CDB | `cdb application.exe [arguments]` | `cdb -p PID` |'
- en: '| GDB | `gdb --args application [arguments`] | `gdb -p PID` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| GDB | `gdb --args application [arguments]` | `gdb -p PID` |'
- en: '| LLDB | `lldb -- application [arguments`] | `lldb -p -PID` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| LLDB | `lldb -- application [arguments]` | `lldb -p -PID` |'
- en: Because the debugger will suspend execution of the process after you’ve created
    or attached the debugger, you’ll need to run the process again. You can issue
    the commands in [Table 10-2](../Text/ch10.xhtml#ch10tab2) in the debugger’s shell
    to start the process execution or resume execution if attaching. The table provides
    some simple names for such commands, separated by commas where applicable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因为调试器会在你创建或附加调试器后暂停进程的执行，所以你需要重新运行进程。你可以在调试器的命令行中发出[表 10-2](../Text/ch10.xhtml#ch10tab2)中的命令来启动进程执行，或者在附加时恢复执行。该表提供了一些简化的命令名称，适用时使用逗号分隔。
- en: '**Table 10-2:** Simplified Application Execution Commands'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-2：** 简化的应用程序执行命令'
- en: '| **Debugger** | **Start execution** | **Resume execution** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **调试器** | **启动执行** | **恢复执行** |'
- en: '| --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| CDB | `g` | `g` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| CDB | `g` | `g` |'
- en: '| GDB | `run, r` | `continue, c` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| GDB | `run, r` | `continue, c` |'
- en: '| LLDB | `process launch, run, r` | `thread continue, c` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| LLDB | `process launch, run, r` | `thread continue, c` |'
- en: When a new process creates a child process, it might be the child process that
    crashes rather than the process you’re debugging. This is especially common on
    Unix-like platforms, because some network servers will fork the current process
    to handle the new connection by creating a copy of the process. In these cases,
    you need to ensure you can follow the child process, not the parent process. You
    can use the commands in [Table 10-3](../Text/ch10.xhtml#ch10tab3) to debug the
    child processes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新进程创建一个子进程时，崩溃的可能是子进程，而不是你正在调试的进程。这在类Unix平台上尤其常见，因为一些网络服务器会通过创建当前进程的副本来处理新连接，即通过fork当前进程。在这种情况下，你需要确保可以跟踪子进程，而不是父进程。你可以使用[表
    10-3](../Text/ch10.xhtml#ch10tab3)中的命令来调试子进程。
- en: '**Table 10-3:** Debugging the Child Processes'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-3：** 调试子进程'
- en: '| **Debugger** | **Enable child process debugging** | **Disable child process
    debugging** |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **调试器** | **启用子进程调试** | **禁用子进程调试** |'
- en: '| --- | --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| CDB | `.childdbg 1` | `.childdbg 0` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| CDB | `.childdbg 1` | `.childdbg 0` |'
- en: '| GDB | `set follow-fork-mode child` | `set follow-fork-mode parent` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| GDB | `set follow-fork-mode child` | `set follow-fork-mode parent` |'
- en: '| LLDB | `process attach --name NAME` --waitfor | `exit debugger` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| LLDB | `process attach --name NAME` --waitfor | `exit debugger` |'
- en: There are some caveats to using these commands. On Windows with CDB, you can
    debug all processes from one debugger. However, with GDB, setting the debugger
    to follow the child will stop the debugging of the parent. You can work around
    this somewhat on Linux by using the `set detach-on-fork off` command. This command
    suspends debugging of the parent process while continuing to debug the child and
    then reattaches to the parent once the child exits. However, if the child runs
    for a long time, the parent might never be able to accept any new connections.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些命令时有一些注意事项。在使用 CDB 的 Windows 上，你可以通过一个调试器调试所有进程。然而，使用 GDB 时，将调试器设置为跟踪子进程将停止对父进程的调试。在
    Linux 上，你可以通过使用`set detach-on-fork off`命令来稍微解决这个问题。该命令在继续调试子进程的同时挂起父进程的调试，并在子进程退出后重新附加到父进程。然而，如果子进程运行时间较长，父进程可能永远无法接受新的连接。
- en: LLDB does not have an option to follow child processes. Instead, you need to
    start a new instance of LLDB and use the attachment syntax shown in [Table 10-3](../Text/ch10.xhtml#ch10tab3)
    to automatically attach to new processes by the process name. You should replace
    the `NAME` in the `process` LLDB command with the process name to follow.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: LLDB 没有跟踪子进程的选项。相反，你需要启动一个新的 LLDB 实例，并使用[表 10-3](../Text/ch10.xhtml#ch10tab3)中显示的附加语法，通过进程名称自动附加到新进程上。你应该将`process`
    LLDB 命令中的`NAME`替换为你要跟踪的进程名称。
- en: '**Analyzing the Crash**'
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**分析崩溃**'
- en: After debugging, you can run the application while fuzzing and wait for the
    program to crash. You should look for crashes that indicate corrupted memory—for
    example, crashes that occur when trying to read or write to invalid addresses,
    or trying to execute code at an invalid address. When you’ve identified an appropriate
    crash, inspect the state of the application to work out the reason for the crash,
    such as a memory corruption or an array-indexing error.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 调试后，你可以在进行模糊测试时运行应用程序，并等待程序崩溃。你应该寻找那些表明内存损坏的崩溃——例如，在尝试读取或写入无效地址时发生的崩溃，或者在尝试执行无效地址上的代码时发生的崩溃。当你识别出合适的崩溃时，检查应用程序的状态，找出崩溃的原因，如内存损坏或数组索引错误。
- en: 'First, determine the type of crash that has occurred from the print out to
    the command window. For example, CDB on Windows typically prints the crash type,
    which will be something like `Access violation`, and the debugger will try to
    print the instruction at the current program location where the application crashed.
    For GDB and LLDB on Unix-like systems, you’ll instead see the signal type: the
    most common type is `SIGSEGV` for segmentation fault, which indicates that the
    application tried to access an invalid memory location.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过命令窗口中的输出确定发生的崩溃类型。例如，Windows 上的 CDB 通常会打印出崩溃类型，类似于 `Access violation`，调试器会尝试打印出应用程序崩溃时当前位置的指令。在类
    Unix 系统上的 GDB 和 LLDB，你将看到信号类型：最常见的类型是 `SIGSEGV`，表示段错误，指示应用程序尝试访问无效的内存位置。
- en: As an example, [Listing 10-2](../Text/ch10.xhtml#ch10list2) shows what you’d
    see in CDB if the application tried to execute an invalid memory address.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，[清单 10-2](../Text/ch10.xhtml#ch10list2)展示了如果应用程序尝试执行无效内存地址时，CDB 会显示的内容。
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 10-2: An example crash in CDB showing invalid memory address*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-2：CDB 中的崩溃示例，显示无效内存地址*'
- en: After you’ve determined the type of crash, the next step is to determine which
    instruction caused the application to crash so you’ll know what in the process
    state you need to look up. Notice in [Listing 10-2](../Text/ch10.xhtml#ch10list2)
    that the debugger tried to print the instruction at which the crash occurred,
    but the memory location was invalid, so it returns a series of question marks.
    When the crash occurs due to reading or writing invalid memory, you’ll get a full
    instruction instead of the question marks. If the debugger shows that you’re executing
    valid instructions, you can disassemble the instructions surrounding the crash
    location using the commands in [Table 10-4](../Text/ch10.xhtml#ch10tab4).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了崩溃类型后，下一步是确定哪个指令导致了应用程序崩溃，这样你就知道需要查看进程状态中的哪些部分。请注意，在[清单 10-2](../Text/ch10.xhtml#ch10list2)中，调试器尝试打印崩溃发生时的指令，但由于内存位置无效，它返回了一系列问号。当崩溃是由于读取或写入无效内存时，你会看到完整的指令，而不是问号。如果调试器显示你正在执行有效的指令，你可以使用[表
    10-4](../Text/ch10.xhtml#ch10tab4)中的命令反汇编崩溃位置周围的指令。
- en: '**Table 10-4:** Instruction Disassembly Commands'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-4：** 指令反汇编命令'
- en: '| **Debugger** | **Disassemble from crash location** | **Disassemble a specific
    location** |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **调试器** | **从崩溃位置反汇编** | **反汇编特定位置** |'
- en: '| --- | --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| CDB | `u` | `u ADDR` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| CDB | `u` | `u ADDR` |'
- en: '| GDB | `disassemble` | `disassemble ADDR` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| GDB | `disassemble` | `disassemble ADDR` |'
- en: '| LLDB | `disassemble –frame` | `disassemble --start-address ADDR` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| LLDB | `disassemble –frame` | `disassemble --start-address ADDR` |'
- en: To display the processor’s register state at the point of the crash, you can
    use the commands in [Table 10-5](../Text/ch10.xhtml#ch10tab5).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示崩溃时的处理器寄存器状态，你可以使用[表 10-5](../Text/ch10.xhtml#ch10tab5)中的命令。
- en: '**Table 10-5:** Displaying and Setting the Processor Register State'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-5：** 显示和设置处理器寄存器状态'
- en: '| **Debugger** | **Show general purpose registers** | **Show specific register**
    | **Set specific register** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **调试器** | **显示通用寄存器** | **显示特定寄存器** | **设置特定寄存器** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| CDB | `r` | `r @rcx` | `r @rcx = NEWVALUE` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| CDB | `r` | `r @rcx` | `r @rcx = NEWVALUE` |'
- en: '| GDB | `info registers` | `info registers rcx` | `set $rcx = NEWVALUE` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| GDB | `info registers` | `info registers rcx` | `set $rcx = NEWVALUE` |'
- en: '| LLDB | `register read` | `register read rcx` | `register write rcx NEWVALUE`
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| LLDB | `register read` | `register read rcx` | `register write rcx NEWVALUE`
    |'
- en: You can also use these commands to set the value of a register, which allows
    you to keep the application running by fixing the immediate crash and restarting
    execution. For example, if the crash occurred because the value of RCX was pointing
    to invalid reference memory, it’s possible to reset RCX to a valid memory location
    and continue execution. However, this might not continue successfully for very
    long if the application is already corrupted.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用这些命令设置寄存器的值，这样可以通过修复即时崩溃并重新启动执行来保持应用程序运行。例如，如果崩溃是因为 RCX 的值指向无效的引用内存，那么可以将
    RCX 重置为有效的内存位置并继续执行。然而，如果应用程序已经损坏，这种继续执行可能不会成功维持太长时间。
- en: 'One important detail to note is how the registers are specified. In CDB, you
    use the syntax `@``NAME` to specify a register in an expression (for example,
    when building up a memory address). For GDB and LLDB, you typically use `$``NAME`
    instead. GDB and LLDB, also have a couple of pseudo registers: `$pc`, which refers
    to the memory location of the instruction currently executing (which would map
    to RIP for x64), and `$sp`, which refers to the current stack pointer.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要细节是寄存器的指定方式。在CDB中，你使用语法`@``NAME`来在表达式中指定一个寄存器（例如，在构建内存地址时）。而在GDB和LLDB中，通常使用`$``NAME`来指定寄存器。GDB和LLDB还具有几个伪寄存器：`$pc`，它指代当前执行指令的内存位置（对于x64来说对应RIP），以及`$sp`，它指代当前的栈指针。
- en: When the application you’re debugging crashes, you’ll want to display how the
    current function in the application was called, because this provides important
    context to determine what part of the application triggered the crash. Using this
    context, you can narrow down which parts of the protocol you need to focus on
    to reproduce the crash.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调试的应用程序崩溃时，你会希望显示当前函数是如何被调用的，因为这为确定是哪个部分的应用程序触发了崩溃提供了重要的上下文。通过这些上下文，你可以缩小需要关注的协议部分，以便重现崩溃。
- en: You can get this context by generating a stack trace, which displays the functions
    that were called prior to the execution of the vulnerable function, including,
    in some cases, local variables and arguments passed to those functions. [Table
    10-6](../Text/ch10.xhtml#ch10tab6) lists commands to create a stack trace.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过生成堆栈跟踪来获取此上下文，堆栈跟踪显示了在执行易受攻击函数之前被调用的函数，包括在某些情况下传递给这些函数的局部变量和参数。[表 10-6](../Text/ch10.xhtml#ch10tab6)列出了创建堆栈跟踪的命令。
- en: '**Table 10-6:** Creating a Stack Trace'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-6：** 创建堆栈跟踪'
- en: '| **Debugger** | **Display stack trace** | **Display stack trace with arguments**
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **调试器** | **显示堆栈跟踪** | **显示带参数的堆栈跟踪** |'
- en: '| --- | --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| CDB | `K` | `Kb` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| CDB | `K` | `Kb` |'
- en: '| GDB | `backtrace` | `backtrace full` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| GDB | `backtrace` | `backtrace full` |'
- en: '| LLDB | `backtrace` |  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| LLDB | `backtrace` |  |'
- en: You can also inspect memory locations to determine what caused the current instruction
    to crash; use the commands in [Table 10-7](../Text/ch10.xhtml#ch10tab7).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以检查内存位置以确定当前指令崩溃的原因；使用[表 10-7](../Text/ch10.xhtml#ch10tab7)中的命令。
- en: '**Table 10-7:** Displaying Memory Values'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-7：** 显示内存值'
- en: '| **Debugger** | **Display bytes/words, dwords, qwords** | **Display ten 1-byte
    values** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **调试器** | **显示字节/字/双字/四字** | **显示十个1字节的值** |'
- en: '| --- | --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| CDB | `db, dw, dd, dq ADDR` | `db ADDR` L10 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| CDB | `db, dw, dd, dq ADDR` | `db ADDR` L10 |'
- en: '| GDB | `x/b, x/h, x/w, x/g ADDR` | `x/10b ADDR` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| GDB | `x/b, x/h, x/w, x/g ADDR` | `x/10b ADDR` |'
- en: '| LLDB | `memory read --size 1,2,4,8` | `memory read --size 1 --count 10` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| LLDB | `memory read --size 1,2,4,8` | `memory read --size 1 --count 10` |'
- en: Each debugger allows you to control how to display the values in memory, such
    as the size of the memory read (like 1 byte to 4 bytes) as well as the amount
    of data to print.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每个调试器都允许你控制如何显示内存中的值，例如读取内存的大小（如从1字节到4字节）以及要打印的数据量。
- en: Another useful command determines what type of memory an address corresponds
    to, such as heap memory, stack memory, or a mapped executable. Knowing the type
    of memory helps narrow down the type of vulnerability. For example, if a memory
    value corruption has occurred, you can distinguish whether you’re dealing with
    a stack memory or heap memory corruption. You can use the commands in [Table 10-8](../Text/ch10.xhtml#ch10tab8)
    to determine the layout of the process memory and then look up what type of memory
    an address corresponds to.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的命令是确定一个地址对应的内存类型，例如堆内存、栈内存或映射的可执行文件。了解内存类型有助于缩小漏洞的类型。例如，如果发生了内存值损坏，你可以区分是栈内存损坏还是堆内存损坏。你可以使用[表
    10-8](../Text/ch10.xhtml#ch10tab8)中的命令来确定进程内存的布局，然后查找一个地址对应的内存类型。
- en: '**Table 10-8:** Commands for Displaying the Process Memory Map'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-8：** 显示进程内存映射的命令'
- en: '| **Debugger** | **Display process memory map** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **调试器** | **显示进程内存映射** |'
- en: '| --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| CDB | `!address` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| CDB | `!address` |'
- en: '| GDB | `info proc mappings` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| GDB | `info proc mappings` |'
- en: '| LLDB | No direct equivalent |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| LLDB | 没有直接对应的命令 |'
- en: Of course, there’s a lot more to the debugger that you might need to use in
    your triage, but the commands provided in this section should cover the basics
    of triaging a crash.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，调试器还有更多的功能可能在你进行故障诊断时需要使用，但本节提供的命令应该涵盖了崩溃诊断的基础知识。
- en: '**Example Crashes**'
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例崩溃**'
- en: Now let’s look at some examples of crashes so you’ll know what they look like
    for different types of vulnerabilities. I’ll just show Linux crashes in GDB, but
    the crash information you’ll see on different platforms and debuggers should be
    fairly similar. [Listing 10-3](../Text/ch10.xhtml#ch10list3) shows an example
    crash from a typical stack buffer overflow.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一些崩溃的例子，以便你了解不同类型的漏洞所引起的崩溃是什么样的。我将展示在GDB中的Linux崩溃，但你在不同平台和调试器上看到的崩溃信息应该是相似的。[列表
    10-3](../Text/ch10.xhtml#ch10list3)展示了一个典型的栈缓冲区溢出引起的崩溃示例。
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 10-3: An example crash from a stack buffer overflow*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-3：来自栈缓冲区溢出的示例崩溃*'
- en: The input data was a series of repeating *A* characters, shown here as the hex
    value 0x41\. At ➊, the program has crashed trying to execute the memory address
    0x41414141\. The fact that the address contains repeated copies of our input data
    is indicative of memory corruption, because the memory values should reflect the
    current execution state (such as pointers into the stack or heap)and are very
    unlikely to be the same value repeated. We double-check that the reason it crashed
    is that there’s no executable code at 0x41414141 by requesting GDB to disassemble
    instructions at the location of the program crash ➋. GDB then indicates that it
    cannot access memory at that location. The crash doesn’t necessarily mean a stack
    overflow has occured, so to confirm we dump the current stack location ➌. By also
    moving the stack pointer back 16 bytes at this point, we can see that our input
    data has definitely corrupted the stack.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数据是一系列重复的*A*字符，在这里显示为十六进制值0x41。 在 ➊ 处，程序在尝试执行内存地址0x41414141时崩溃。地址包含重复的输入数据副本，这是内存损坏的一个标志，因为内存值应该反映当前的执行状态（如指向栈或堆的指针），并且不太可能是相同值的重复。我们再次检查崩溃的原因是否是因为在0x41414141处没有可执行代码，通过请求GDB反汇编程序崩溃位置的指令
    ➋，GDB表示它无法访问该位置的内存。崩溃并不一定意味着发生了栈溢出，所以为了确认我们在 ➌ 处转储当前栈位置。此时通过将栈指针向后移动16字节，我们可以看到我们的输入数据已经彻底破坏了栈。
- en: The problem with this crash is that it’s difficult to determine which part is
    the vulnerable code. We crashed it by calling an invalid location, meaning the
    function that was executing the return instruction is no longer directly referenced
    and the stack is corrupted, making it difficult to extract calling information.
    In this case, you could look at the stack memory below the corruption to search
    for a return address left on the stack by the vulnerable function, which can be
    used to track down the culprit. [Listing 10-4](../Text/ch10.xhtml#ch10list4) shows
    a crash resulting from heap buffer overflow, which is considerably more involved
    than the stack memory corruption.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个崩溃的问题在于，很难确定哪个部分是脆弱的代码。我们通过调用一个无效的位置导致了崩溃，这意味着执行返回指令的函数不再被直接引用，栈被破坏，使得提取调用信息变得困难。在这种情况下，你可以查看栈破坏下方的内存，寻找由脆弱函数在栈上留下的返回地址，这可以用来追踪罪魁祸首。[列表
    10-4](../Text/ch10.xhtml#ch10list4)展示了一个由堆缓冲区溢出引起的崩溃，堆缓冲区溢出比栈内存破坏更加复杂。
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 10-4: An example crash from a heap buffer overflow*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-4：来自堆缓冲区溢出的示例崩溃*'
- en: Again we get a crash, but it’s at a valid instruction that copies a value from
    the memory location pointed to by `EAX` back into `EAX` ➊. It’s likely that the
    crash occurred because `EAX` points to invalid memory. Printing the register ➋
    shows that the value of `EAX` is just our overflow character repeated, which is
    a sign of corruption.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次遇到崩溃，但这次发生在一个有效的指令上，该指令将值从`EAX`指向的内存位置复制回`EAX` ➊。崩溃很可能是因为`EAX`指向了无效的内存。打印寄存器
    ➋ 显示`EAX`的值正是我们溢出的字符重复，这表明发生了内存损坏。
- en: We disassemble a little further and find that the value of `EAX` is being used
    as a memory address of a function that the instruction at ➌ will call. Dereferencing
    a value from another value indicates that the code being executed is a virtual
    function lookup from a *Virtual Function Table (VTable)*. We confirm this by disassembling
    a few instructions prior to the crashing instruction ➍. We see that a value is
    being read from memory, then that value is dereferenced (this would be reading
    the VTable pointer), and finally it is dereferenced again causing the crash.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进一步反汇编，发现`EAX`的值被用作一个函数的内存地址，该函数将在 ➌ 的指令中被调用。从另一个值解引用一个值表明，正在执行的代码是从*虚拟函数表（VTable）*进行虚拟函数查找。我们通过反汇编崩溃指令之前的几条指令
    ➍ 来确认这一点。我们看到一个值从内存中读取，然后该值被解引用（这将是读取VTable指针），最后再次被解引用，导致了崩溃。
- en: Although analysis showing that the crash occurs when dereferencing a VTable
    pointer doesn’t immediately verify the corruption of a heap object, it’s a good
    indicator. To verify a heap corruption, we extract the value from memory and check
    whether it’s corrupted using the 0x41414141 pattern, which was our input value
    during testing ➎. Finally, to check whether the memory is in the heap, we use
    the `info proc mappings` command to dump the process memory map; from that, we
    can see that the value 0x0804a030, which we extracted for ➍, is within the heap
    region ➏. Correlating the memory address with the mappings indicates that the
    memory corruption is isolated to this heap region.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管分析表明崩溃发生在解引用 VTable 指针时并不能立即验证堆对象的损坏，但它是一个很好的指示器。为了验证堆内存的损坏，我们从内存中提取值，并检查它是否被
    0x41414141 模式损坏，这是我们在测试期间的输入值 ➎。最后，为了检查内存是否位于堆中，我们使用 `info proc mappings` 命令来转储进程内存映射；从中我们可以看到，我们为
    ➍ 提取的值 0x0804a030 位于堆区域 ➏ 中。通过将内存地址与映射相关联，可以确认内存损坏仅限于此堆区域。
- en: Finding that the corruption is isolated to the heap doesn’t necessarily point
    to the root cause of the vulnerability, but we can at least find information on
    the stack to determine what functions were called to get to this point. Knowing
    what functions were called would narrow down the range of functions you would
    need to reverse engineer to determine the culprit.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 发现堆内存的损坏并不一定指向漏洞的根本原因，但我们至少可以从栈中找到信息，确定哪些函数被调用以到达此点。知道调用了哪些函数可以缩小你需要逆向工程的函数范围，从而找出罪魁祸首。
- en: '***Improving Your Chances of Finding the Root Cause of a Crash***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***提高找到崩溃根本原因的机会***'
- en: Tracking down the root cause of a crash can be difficult. If the stack memory
    is corrupted, you lose the information on which function was being called at the
    time of the crash. For a number of other types of vulnerabilities, such as heap
    buffer overflows or use-after-free, it’s possible the crash will never occur at
    the location of the vulnerability. It’s also possible that the corrupted memory
    is set to a value that doesn’t cause the application to crash at all, leading
    to a change of application behavior that cannot easily be observed through a debugger.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪崩溃的根本原因可能是困难的。如果栈内存已损坏，你就会失去崩溃时调用的函数的信息。对于其他类型的漏洞，比如堆缓冲区溢出或使用后释放（use-after-free），崩溃可能永远不会发生在漏洞的位置。也有可能损坏的内存被设置为一个值，这个值不会导致应用程序崩溃，从而导致应用程序行为发生变化，而这些变化通过调试器难以观察到。
- en: Ideally, you want to improve your chances of identifying the exact point in
    the application that’s vulnerable without exerting a significant amount of effort.
    I’ll present a few ways of improving your chances of narrowing down the vulnerable
    point.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你希望提高识别应用程序中确切易受攻击点的机会，同时不需要付出过多的努力。我将介绍几种提高缩小易受攻击点范围的方式。
- en: '**Rebuilding Applications with Address Sanitizer**'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 Address Sanitizer 重建应用程序**'
- en: If you’re testing an application on a Unix-like OS, there’s a reasonable chance
    you have the source code for the application. This alone provides you with many
    advantages, such as full debug information, but it also means you can rebuild
    the application and add improved memory error detection to improve your chances
    of discovering vulnerabilities.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在 Unix 类操作系统上测试一个应用程序，那么你有合理的机会获得该应用程序的源代码。仅此一点就为你提供了许多优势，例如完整的调试信息，但它也意味着你可以重建该应用程序并添加改进的内存错误检测，从而提高发现漏洞的机会。
- en: One of the best tools to add this improved functionality when rebuilding is
    Address Sanitizer (ASan), an extension for the CLANG C compiler that detects memory
    corruption bugs. If you specify the `-fsanitize=address` option when running the
    compiler (you can usually specify this option using the `CFLAGS` environment variable),
    the rebuilt application will have additional instrumentation to detect common
    memory errors, such as memory corruption, out-of-bounds writes, use-after-free,
    and double-free.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在重建过程中添加这种增强功能的最佳工具之一是 Address Sanitizer（ASan），这是一个用于 CLANG C 编译器的扩展，用于检测内存损坏的
    bug。如果在运行编译器时指定 `-fsanitize=address` 选项（通常可以通过 `CFLAGS` 环境变量指定此选项），重建后的应用程序将具备额外的检测功能，用于检测常见的内存错误，如内存损坏、越界写入、使用后释放（use-after-free）和双重释放（double-free）。
- en: The main advantage of ASan is that it stops the application as soon as possible
    after the vulnerable condition has occurred. If a heap allocation overflows, ASan
    stops the program and prints the details of the vulnerability to the shell console.
    For example, [Listing 10-5](../Text/ch10.xhtml#ch10list5) shows a part of the
    output from a simple heap overflow.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ASan 的主要优点是，它会在易受攻击的条件发生后尽快停止应用程序。如果堆分配发生溢出，ASan 会停止程序并将漏洞的详细信息打印到 shell 控制台。例如，[清单
    10-5](../Text/ch10.xhtml#ch10list5)展示了一个简单堆溢出的输出部分。
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 10-5: Output from ASan for a heap buffer overflow*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-5：ASan 输出，堆缓冲区溢出*'
- en: Notice that the output contains the type of bug encountered ➊ (in this case
    a heap overflow), the memory address of the overflow write ➋, the location in
    the application that caused the overflow ➌, and the size of the overflow ➍. By
    using the provided information with a debugger, as shown in the previous section,
    you should be able to track down the root cause of the vulnerability.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出中包含了遇到的错误类型➊（在此案例中为堆溢出）、溢出写入的内存地址➋、导致溢出的应用程序位置➌，以及溢出大小 ➍。通过使用调试器和提供的信息，如前一节所示，您应该能够追踪到漏洞的根本原因。
- en: However, notice that the locations inside the application are just memory addresses.
    Source code files and line numbers would be more useful. To retrieve them in the
    stack trace, we need to specify some environment variables to enable symbolization,
    as shown in [Listing 10-6](../Text/ch10.xhtml#ch10list6). The application will
    also need to be built with debugging information, which we can do by passing by
    the compiler flag `–g` to CLANG.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，应用程序中的位置只是内存地址。源代码文件和行号会更有用。为了在堆栈跟踪中获取这些信息，我们需要指定一些环境变量来启用符号化，如[清单 10-6](../Text/ch10.xhtml#ch10list6)所示。应用程序还需要使用调试信息进行构建，我们可以通过将编译器标志
    `–g` 传递给 CLANG 来实现。
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 10-6: Output from ASan for a heap buffer overflow with symbol information*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-6：ASan 输出，包含符号信息的堆缓冲区溢出*'
- en: The majority of [Listing 10-6](../Text/ch10.xhtml#ch10list6) is the same as
    [Listing 10-5](../Text/ch10.xhtml#ch10list5). The big difference is that the crash’s
    location ➊ now reflects the location inside the original source code (in this
    case, starting at line 8, character 3 inside the file *heap_overflow.c*) instead
    of a memory location inside the program. Narrowing down the location of the crash
    to a specific line in the program makes it much easier to inspect the vulnerable
    code and determine the reason for the crash.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-6](../Text/ch10.xhtml#ch10list6)的大部分内容与[清单 10-5](../Text/ch10.xhtml#ch10list5)相同。主要区别在于崩溃的位置➊现在反映的是原始源代码中的位置（在此案例中，从文件*heap_overflow.c*中的第
    8 行，第 3 个字符开始），而不是程序内的内存地址。将崩溃位置缩小到程序中的特定行，能更容易地检查易受攻击的代码并确定崩溃的原因。'
- en: '**Windows Debug and Page Heap**'
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Windows 调试和页面堆**'
- en: On Windows, access to the source code of the application you’re testing is probably
    more restricted. Therefore, you’ll need to improve your chances for existing binaries.
    Windows comes with the Page Heap, which you can enable to improve your chances
    of tracking down a memory corruption.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，访问正在测试的应用程序的源代码可能会受到更多限制。因此，您需要提高对现有二进制文件的跟踪可能性。Windows 附带了页面堆功能，您可以启用它来提高追踪内存损坏的机会。
- en: 'You need to manually enable the Page Heap for the process you want to debug
    by running the following command as an administrator:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要手动为要调试的进程启用页面堆，可以通过以管理员身份运行以下命令来完成：
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `gflags` application comes installed with the CDB debugger. The `–i` parameter
    allows you to specify the image filename to enable the Page Heap on. Replace `appname.exe`
    with the name of the application you’re testing. The `+hpa` parameter is what
    actually enables the Page Heap when the application next executes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`gflags` 应用程序与 CDB 调试器一起安装。`–i` 参数允许您指定图像文件名以启用页面堆。将 `appname.exe` 替换为您正在测试的应用程序的名称。`+hpa`
    参数在应用程序下次执行时实际启用页面堆。'
- en: The Page Heap works by allocating special, OS-defined memory pages (called *guard
    pages*) after every heap allocation. If an application tries to read or write
    these special guard pages, an error will be raised and the debugger will be notified
    immediately, which is useful for detecting a heap buffer overflow. If the overflow
    writes immediately at the end of the buffer, the guard page will be touched by
    the application and an error will be raised instantly. [Figure 10-1](../Text/ch10.xhtml#ch10fig1)
    shows how this process works in practice.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Page Heap 的工作原理是在每次堆分配后分配特殊的、操作系统定义的内存页面（称为*保护页*）。如果应用程序尝试读取或写入这些特殊的保护页，将会触发错误，并立即通知调试器，这有助于检测堆缓冲区溢出。如果溢出立即写入缓冲区的末尾，保护页将会被应用程序触及，错误会立刻被触发。[图
    10-1](../Text/ch10.xhtml#ch10fig1)展示了这个过程如何在实践中工作。
- en: '![image](../Images/f10-01.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f10-01.jpg)'
- en: '*Figure 10-1: The Page Heap detecting an overflow*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-1：Page Heap 检测溢出*'
- en: You might assume that using the Page Heap would be a good way of stopping heap
    memory corruptions from occurring, but the Page Heap wastes a huge amount of memory
    because each allocation needs a separate guard page. Setting up the guard pages
    requires calling a system call, which reduces allocation performance. On the whole,
    enabling the Page Heap for anything other than debugging sessions would not be
    a great idea.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为使用 Page Heap 是防止堆内存破坏的一种好方法，但 Page Heap 会浪费大量内存，因为每次分配都需要一个独立的保护页。设置保护页需要调用系统调用，这会降低分配性能。总体而言，除了调试会话，启用
    Page Heap 并不是一个好主意。
- en: '**Exploiting Common Vulnerabilities**'
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**利用常见漏洞**'
- en: After researching and analyzing a network protocol, you’ve fuzzed it and found
    some vulnerabilities you want to exploit. [Chapter 9](../Text/ch09.xhtml#ch09)
    describes many types of security vulnerabilities but not how to exploit those
    vulnerabilities, which is what I’ll discuss here. I’ll start with how you can
    exploit memory corruptions and then discuss some of the more unusual vulnerability
    types.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究和分析一个网络协议后，你对它进行了模糊测试，并发现了一些你想要利用的漏洞。[第 9 章](../Text/ch09.xhtml#ch09)描述了许多类型的安全漏洞，但没有介绍如何利用这些漏洞，这是我在这里要讨论的内容。我将从如何利用内存破坏漏洞开始，然后讨论一些更为特殊的漏洞类型。
- en: 'The aims of vulnerability exploitation depend on the purpose of your protocol
    analysis. If the analysis is on a commercial product, you might be looking for
    a proof of concept that clearly demonstrates the issue so the vendor can fix it:
    in that case, reliability isn’t as important as a clear demonstration of what
    the vulnerability is. On the other hand, if you’re developing an exploit for use
    in a Red Team exercise and are tasked with compromising some infrastructure, you
    might need an exploit that is reliable, works on many different product versions,
    and executes the next stage of your attack.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞利用的目标取决于你的协议分析目的。如果分析的是商业产品，你可能希望找到一个概念验证，明确展示问题，以便厂商修复：在这种情况下，可靠性不如清晰地展示漏洞本身重要。另一方面，如果你正在开发一个用于红队演习的漏洞利用，任务是攻破某些基础设施，你可能需要一个可靠的漏洞利用，它能够在许多不同版本的产品上运行，并执行攻击的下一阶段。
- en: Working out ahead of time what your exploitation objectives are ensures you
    don’t waste time on irrelevant tasks. Whatever your goals, this section provides
    you with a good overview of the topic and more in-depth references for your specific
    needs. Let’s begin with exploiting memory corruptions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 提前明确你的利用目标，确保你不会在无关的任务上浪费时间。不论你的目标是什么，本节将为你提供一个关于该主题的良好概述，并为你具体需求提供更深入的参考资料。我们从利用内存破坏漏洞开始。
- en: '***Exploiting Memory Corruption Vulnerabilities***'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***利用内存破坏漏洞***'
- en: Memory corruptions, such as stack and heap overflows, are very common in applications
    written in memory-unsafe languages, such as C/C++. It’s difficult to write a complex
    application in such programming languages without introducing at least one memory
    corruption vulnerability. These vulnerabilities are so common that it’s relatively
    easy to find information about how to exploit them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 内存破坏，如栈溢出和堆溢出，在使用不安全内存语言（如 C/C++）编写的应用程序中非常常见。在这些编程语言中编写复杂的应用程序，几乎不可能不引入至少一个内存破坏漏洞。这些漏洞非常普遍，以至于你很容易找到关于如何利用它们的信息。
- en: An exploit needs to trigger the memory corruption vulnerability in such a way
    that the state of the program changes to execute arbitrary code. This might involve
    hijacking the executing state of the processor and redirecting it to some executable
    code provided in the exploit. It might also mean modifying the running state of
    the application in such a way that previously inaccessible functionality becomes
    available.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个利用程序需要触发内存损坏漏洞，以使程序的状态改变，执行任意代码。这可能涉及劫持处理器的执行状态，并将其重定向到利用程序提供的可执行代码。也可能意味着以某种方式修改应用程序的运行状态，使以前无法访问的功能变得可用。
- en: The development of the exploit depends on the corruption type and what parts
    of the running application the corruption affects, as well as the kind of anti-exploit
    mitigations the application uses to make exploitation of a vulnerability more
    difficult to succeed. First, I’ll talk about the general principles of exploitation,
    and then I’ll consider more complex scenarios.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 利用程序的开发取决于损坏类型、损坏影响到应用程序运行的哪些部分，以及应用程序使用的防止利用的缓解措施，这些措施使得成功利用漏洞变得更加困难。首先，我会讲解利用的基本原理，然后考虑更复杂的场景。
- en: '**Stack Buffer Overflows**'
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**栈缓冲区溢出**'
- en: Recall that a stack buffer overflow occurs when code underestimates the length
    of a buffer to copy into a location on the stack, causing overflow that corrupts
    other data on the stack. Most serious of all, on many architectures the return
    address for a function is stored on the stack, and corruption of this return address
    gives the user direct control of execution, which you can use to execute any code
    you like. One of the most common techniques to exploit a stack buffer overflow
    is to corrupt the return address on the stack to point to a buffer containing
    shell code with instructions you want to execute when you achieve control. Successfully
    corrupting the stack in this way results in the application executing code it
    was not expecting.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，当代码低估了要复制到栈上某个位置的缓冲区的长度时，就会发生栈缓冲区溢出，导致溢出并破坏栈上其他数据。最严重的是，在许多架构上，函数的返回地址存储在栈上，破坏该返回地址会让用户直接控制执行，进而可以执行任何想要的代码。利用栈缓冲区溢出的最常见技术之一是破坏栈上的返回地址，使其指向一个包含
    shell 代码的缓冲区，当你获得控制权时，可以执行这些指令。以这种方式成功破坏栈会导致应用程序执行其未预期的代码。
- en: In an ideal stack overflow, you have full control over the contents and length
    of the overflow, ensuring that you have full control over the values you overwrite
    on the stack. [Figure 10-2](../Text/ch10.xhtml#ch10fig2) shows an ideal stack
    overflow vulnerability in operation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的栈溢出中，你可以完全控制溢出的内容和长度，确保你完全控制在栈上覆盖的值。[图 10-2](../Text/ch10.xhtml#ch10fig2)展示了理想栈溢出漏洞的运作。
- en: '![image](../Images/f10-02.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f10-02.jpg)'
- en: '*Figure 10-2: A simple stack overflow exploit*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-2：一个简单的栈溢出利用示例*'
- en: The stack buffer we’ll overflow is below the return address for the function
    ➊. When the overflow occurs, the vulnerable code fills up the buffer and then
    overwrites the return address with the value 0x12345678 ➋. The vulnerable function
    completes its work and tries to return to its caller, but the calling address
    has been replaced with an arbitrary value pointing to the memory location of some
    shell code placed there by the exploit ➌. The return instruction executes, and
    the exploit gains control over code execution.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要溢出的栈缓冲区位于函数的返回地址下方 ➊。当溢出发生时，易受攻击的代码填充缓冲区，并用值0x12345678 ➋覆盖返回地址。易受攻击的函数完成工作并尝试返回调用者，但调用地址已被替换为一个指向由利用代码放置的某些
    shell 代码内存位置的任意值 ➌。返回指令执行，利用代码获得了对代码执行的控制。
- en: 'Writing an exploit for a stack buffer overflow is simple enough in the ideal
    situation: you just need to craft your data into the overflowed buffer to ensure
    the return address points to a memory region you control. In some cases, you can
    even add the shell code to the end of the overflow and set the return address
    to jump to the stack. Of course, to jump into the stack, you’ll need to find the
    memory address of the stack, which might be possible because the stack won’t move
    very frequently.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，编写栈缓冲区溢出利用程序相对简单：你只需要将数据构造到溢出的缓冲区中，确保返回地址指向你控制的内存区域。在某些情况下，你甚至可以将 shell
    代码添加到溢出的末尾，并设置返回地址跳转到栈上。当然，为了跳入栈，你需要找到栈的内存地址，这可能是可行的，因为栈不会频繁移动。
- en: 'However, the properties of the vulnerability you discovered can create issues.
    For example, if the vulnerability is caused by a C-style string copy, you won’t
    be able to use multiple 0 bytes in the overflow because C uses a 0 byte as the
    terminating character for the string: the overflow will stop immediately once
    a 0 byte is encountered in the input data. An alternative is to direct the shell
    code to an address value with no 0 bytes, for example, shell code that forces
    the application to do allocation requests.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你发现的漏洞特性可能会带来问题。例如，如果漏洞是由 C 风格的字符串复制引起的，你将无法在溢出中使用多个 0 字节，因为 C 使用 0 字节作为字符串的终止字符：一旦在输入数据中遇到
    0 字节，溢出就会立即停止。一种替代方法是将 Shell 代码定向到没有 0 字节的地址值，例如，强制应用程序执行分配请求的 Shell 代码。
- en: '**Heap Buffer Overflows**'
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**堆缓冲区溢出**'
- en: Exploiting heap buffer overflows can be more involved than exploiting an overflow
    on the stack because heap buffers are often in a less predictable memory address.
    This means there is no guarantee you’ll find something as easily corruptible as
    the function return address in a known location. Therefore, exploiting a heap
    overflow requires different techniques, such as control of heap allocations and
    accurate placement of useful, corruptible objects.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 利用堆缓冲区溢出可能比利用栈溢出更为复杂，因为堆缓冲区通常位于不太可预测的内存地址。这意味着你无法保证能像在已知位置找到函数返回地址那样轻松找到可以被轻易破坏的内容。因此，利用堆溢出需要不同的技术，比如控制堆分配和准确地放置有用的、可破坏的对象。
- en: The most common technique for gaining control of code execution for a heap overflow
    is to exploit the structure of C++ objects, specifically their use of VTables.
    A VTable is a list of pointers to functions that the object implements. The use
    of virtual functions allows a developer to make new classes derived from existing
    base classes and override some of the functionality, as illustrated in [Figure
    10-3](../Text/ch10.xhtml#ch10fig3).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 获得堆溢出代码执行控制的最常见技术是利用 C++ 对象的结构，特别是它们使用 VTable 的方式。VTable 是指向对象实现的函数的指针列表。虚拟函数的使用使得开发者能够从现有基类派生新类，并重写部分功能，如[图
    10-3](../Text/ch10.xhtml#ch10fig3)所示。
- en: '![image](../Images/f10-03.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f10-03.jpg)'
- en: '*Figure 10-3: VTable implementation*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：VTable 实现*'
- en: To support virtual functions, each allocated instance of a class must contain
    a pointer to the memory location of the function table ➊. When a virtual function
    is called on an object, the compiler generates code that looks up the address
    of the virtual function table, then looks up the virtual function inside the table,
    and finally calls that address ➋. Typically, we can’t corrupt the pointers in
    the table because it’s likely the table is stored in a read-only part of memory.
    But we can corrupt the pointer to the VTable and use that to gain code execution,
    as shown in [Figure 10-4](../Text/ch10.xhtml#ch10fig4).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持虚拟函数，每个分配的类实例必须包含指向函数表内存位置的指针 ➊。当在对象上调用虚拟函数时，编译器生成的代码会查找虚拟函数表的地址，然后查找表内的虚拟函数，最后调用该地址
    ➋。通常，我们无法破坏表中的指针，因为表很可能存储在只读内存部分。但我们可以破坏指向 VTable 的指针，并利用它来获得代码执行权限，如[图 10-4](../Text/ch10.xhtml#ch10fig4)所示。
- en: '![image](../Images/f10-04.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f10-04.jpg)'
- en: '*Figure 10-4: Gaining code execution through VTable address corruption*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4：通过 VTable 地址破坏获得代码执行权限*'
- en: '**Use-After-Free Vulnerability**'
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用后释放漏洞**'
- en: A use-after-free vulnerability is not so much a corruption of memory but a corruption
    of the state of the program. The vulnerability occurs when a memory block is freed
    but a pointer to that block is still stored by some part of the application. Later
    in the application’s execution, the pointer to the freed block is reused, possibly
    because the application code assumes the pointer is still valid. Between the time
    that the memory block is freed and the block pointer is reused, there’s opportunity
    to replace the contents of the memory block with arbitrary values and use that
    to gain code execution.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用后释放漏洞与内存损坏的关系不大，更像是程序状态的破坏。该漏洞发生在一个内存块被释放后，但应用程序的某些部分仍然存储着指向该内存块的指针。在应用程序执行的后续过程中，这个指向已释放内存块的指针被重新使用，可能是因为应用程序代码认为该指针仍然有效。在内存块被释放和块指针被重新使用之间，存在机会将内存块的内容替换为任意值，并利用这一点来获得代码执行权限。
- en: When a memory block is freed, it will typically be given back to the heap to
    be reused for another memory allocation; therefore, as long as you can issue an
    allocation request of the same size as the original allocation, there’s a strong
    possibility that the freed memory block would be reused with your crafted contents.
    We can exploit use-after-free vulnerabilities using a technique similar to abusing
    VTables in heap overflows, as illustrated in [Figure 10-5](../Text/ch10.xhtml#ch10fig5).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当内存块被释放时，通常会将其返回给堆以供重新利用；因此，只要你能发出与原始分配相同大小的分配请求，就有很大可能性释放的内存块会被重新使用，并包含你精心构造的内容。我们可以利用使用后释放漏洞，使用类似于堆溢出中滥用
    VTables 的技术，如[图 10-5](../Text/ch10.xhtml#ch10fig5)所示。
- en: The application first allocates an object *p* on the heap ➊, which contains
    a VTable pointer we want to gain control of. Next, the application calls delete
    on the pointer to free the associated memory ➋. However, the application doesn’t
    reset the value of *p*, so this object is free to be reused in the future.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序首先在堆上分配一个对象*p* ➊，该对象包含我们希望控制的 VTable 指针。接下来，应用程序调用 delete 来释放关联的内存 ➋。然而，应用程序并没有重置*p*的值，因此该对象可以在未来被重新利用。
- en: '![image](../Images/f10-05.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f10-05.jpg)'
- en: '*Figure 10-5: An example of a use-after-free vulnerability*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：使用后释放漏洞的示例*'
- en: Although it’s shown in the figure as being free memory, the original values
    from the first allocation may not actually have been removed. This makes it difficult
    to track down the root cause of a use-after-free vulnerability. The reason is
    that the program might continue to work fine even if the memory is no longer allocated,
    because the contents haven’t changed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管图中显示为已释放内存，但第一次分配的原始值可能实际上并没有被清除。这使得追踪使用后释放漏洞的根本原因变得困难。原因是，即使内存不再分配，程序可能仍然正常工作，因为内容没有发生变化。
- en: Finally, the exploit allocates memory that is an appropriate size and has control
    over the contents of memory that *p* points to, which the heap allocator reuses
    as the allocation for *p* ➌. If the application reuses *p* to call a virtual function,
    we can control the lookup and gain direct code execution.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，利用程序分配了适当大小的内存，并控制了*p*指向的内存内容，堆分配器将其重新用于*p* ➌。如果应用程序重新使用*p*调用虚拟函数，我们可以控制查找过程并获得直接的代码执行权限。
- en: '**Manipulating the Heap Layout**'
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**操控堆布局**'
- en: Most of the time, the key to successfully exploiting a heap-based vulnerability
    is in forcing a suitable allocation to occur at a reliable location, so it’s important
    to manipulate the layout of the heap. Because there is such a large number of
    different heap implementations on various platforms, I’m only able to provide
    general rules for heap manipulation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，成功利用基于堆的漏洞的关键在于强制在可靠的位置进行适当的分配，因此，操控堆的布局非常重要。由于在各种平台上有大量不同的堆实现，我只能提供关于堆操控的通用规则。
- en: 'The heap implementation for an application may be based on the virtual memory
    management features of the platform the application is executing on. For example,
    Windows has the API function *VirtualAlloc*, which allocates a block of virtual
    memory for the current process. However, using the OS virtual memory allocator
    introduces a couple of problems:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的堆实现可能基于应用程序执行的平台的虚拟内存管理特性。例如，Windows 有 API 函数*VirtualAlloc*，它为当前进程分配一块虚拟内存。然而，使用操作系统虚拟内存分配器会引发一些问题：
- en: '**Poor performance** Each allocation and free-up requires the OS to switch
    to kernel mode and back again.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能差** 每次分配和释放都需要操作系统切换到内核模式并再切换回用户模式。'
- en: '**Wasted memory** At a minimum, virtual memory allocations are done at page
    level, which is usually at least 4096 bytes. If you allocate memory smaller than
    the page size, the rest of the page is wasted.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**浪费的内存** 至少，虚拟内存分配是按页面级别进行的，通常至少为 4096 字节。如果你分配的内存小于页面大小，剩余的页面就会浪费。'
- en: Due to these problems, most heap implementations call on the OS services only
    when absolutely necessary. Instead, they allocate a large memory region in one
    go and then implement user-level code to apportion that larger allocation into
    small blocks to service allocation requests.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些问题，大多数堆实现只有在绝对必要时才调用操作系统服务。相反，它们会一次性分配一个较大的内存区域，然后实现用户级代码，将该较大的分配拆分成小块，以满足分配请求。
- en: 'Efficiently dealing with memory freeing is a further challenge. A naive implementation
    might just allocate a large memory region and then increment a pointer in that
    region for every allocation, returning the next available memory location when
    requested. This will work, but it’s virtually impossible to then free that memory:
    the larger allocation could only be freed once all suballocations had been freed.
    This might never happen in a long-running application.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 高效处理内存释放是一个进一步的挑战。一种简单的实现可能只是分配一个大的内存区域，然后每次分配时递增该区域中的指针，在请求时返回下一个可用的内存位置。这样是可行的，但几乎不可能释放那块内存：只有当所有子分配被释放后，较大的分配才能被释放。在一个长期运行的应用程序中，这种情况可能永远不会发生。
- en: An alternative to the simplistic sequential allocation is to use a *free-list*.
    A free-list maintains a list of freed allocations inside a larger allocation.
    When a new heap is created, the OS creates a large allocation in which the free-list
    would consist of a single freed block the size of the allocated memory. When an
    allocation request is made, the heap’s implementation scans the list of free blocks
    looking for a free block of sufficient size to contain the allocation. The implementation
    would then use that free block, allocate the request block at the start, and update
    the free-list to reflect the new free size.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代简单顺序分配的方法是使用*空闲链表*。空闲链表维护一个包含较大分配内部已释放分配的列表。当创建一个新的堆时，操作系统会创建一个大分配，其中空闲链表将包含一个大小与分配内存相同的已释放块。当发出分配请求时，堆的实现扫描空闲块列表，寻找一个足够大的空闲块以容纳该分配。然后实现将使用该空闲块，在起始位置分配请求的块，并更新空闲链表以反映新的空闲大小。
- en: When a block is freed, the implementation can add that block to the free-list.
    It could also check whether the memory before and after the newly freed block
    is also free and attempt to coalesce those free blocks to deal with memory fragmentation,
    which occurs when many small allocated blocks are freed, returning the blocks
    to available memory for reuse. However, free-list entries only record their individual
    sizes, so if an allocation larger than any of the free-list entries is requested,
    the implementation might need to further expand the OS allocated region to satisfy
    the request. An example of a free-list is shown in [Figure 10-6](../Text/ch10.xhtml#ch10fig6).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个块被释放时，实现可以将该块添加到空闲链表中。它还可以检查新释放的块前后是否也为空闲，并尝试将这些空闲块合并，以解决内存碎片问题。内存碎片发生在许多小的已分配块被释放后，将这些块返回可用内存供重用。然而，空闲链表条目仅记录它们各自的大小，因此，如果请求的分配大于空闲链表中的任何条目，实施可能需要进一步扩展操作系统分配的区域以满足请求。一个空闲链表的示例如[图10-6](../Text/ch10.xhtml#ch10fig6)所示。
- en: '![image](../Images/f10-06.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f10-06.jpg)'
- en: '*Figure 10-6: An example of a simple free-list implementation*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-6：简单空闲链表实现示例*'
- en: Using this heap implementation, you should be able to see how you would obtain
    a heap layout appropriate to exploiting a heap-based vulnerability. Say, for example,
    you know that the heap block you’ll overflow is 128 bytes; you can find a C++
    object with a VTable pointer that’s at least the same size as the overflowable
    buffer. If you force the application to allocate a large number of these objects,
    they’ll end up being allocated sequentially in the heap. You can selectively free
    one of these objects (it doesn’t matter which one), and there’s a good chance
    that when you allocate the vulnerable buffer, it will reuse the freed block. Then
    you can execute your heap buffer overflow and corrupt the allocated object’s VTable
    to get code execution, as illustrated in [Figure 10-7](../Text/ch10.xhtml#ch10fig7).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个堆实现，你应该能够看到如何获得一个适合利用基于堆的漏洞的堆布局。例如，假设你知道你将要溢出的堆块是128字节；你可以找到一个C++对象，它的VTable指针至少和溢出的缓冲区大小一样。如果你强制应用程序分配大量这样的对象，它们将会在堆中按顺序分配。你可以选择性地释放其中一个对象（不管是哪个），然后很有可能，当你分配漏洞缓冲区时，它将会重用已释放的块。接着你可以执行堆缓冲区溢出，破坏已分配对象的VTable，从而获得代码执行，如[图10-7](../Text/ch10.xhtml#ch10fig7)所示。
- en: '![image](../Images/f10-07.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f10-07.jpg)'
- en: '*Figure 10-7: Allocating memory buffers to ensure correct layout*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-7：分配内存缓冲区以确保正确布局*'
- en: When manipulating heaps, the biggest challenge in a network attack is the limited
    control over memory allocations. If you’re exploiting a web browser, you can use
    JavaScript to trivially set up the heap layout, but for a network application,
    it’s more difficult. A good place to look for object allocations is in the creation
    of a connection. If each connection is backed by a C++ object, you can control
    allocation by just opening and closing connections. If that method isn’t suitable,
    you’ll almost certainly have to exploit the commands in the network protocol for
    appropriate allocations.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作堆时，网络攻击中最大的挑战是对内存分配的控制有限。如果你在利用一个网页浏览器，你可以利用JavaScript轻松设置堆布局，但对于网络应用程序，这就更难了。一个寻找对象分配的好地方是在连接的创建中。如果每个连接都有一个C++对象支撑，你可以通过简单地打开和关闭连接来控制分配。如果这种方法不适用，你几乎肯定需要利用网络协议中的命令来进行适当的分配。
- en: '**Defined Memory Pool Allocations**'
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义内存池分配**'
- en: As an alternative to using an arbitrary free-list, you might use defined memory
    pools for different allocation sizes to group smaller allocations appropriately.
    For example, you might specify pools for allocations of 16, 64, 256, and 1024
    bytes. When the request is made, the implementation will allocate the buffer based
    on the pool that most closely matches the size requested and is large enough to
    fit the allocation. For example, if you wanted a 50-byte allocation, it would
    go into the 64-byte pool, whereas a 512-byte allocation would go into the 1024-byte
    pool. Anything larger than 1024 bytes would be allocated using an alternative
    approach for large allocations. The use of sized memory pools reduces fragmentation
    caused by small allocations. As long as there’s a free entry for the requested
    memory in the sized pool, it will be satisfied, and larger allocations will not
    be blocked as much.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用任意自由列表的替代方法，你可以为不同的分配大小使用定义好的内存池，将较小的分配适当地分组。例如，你可以为16字节、64字节、256字节和1024字节的分配指定内存池。当请求发出时，系统将根据最接近请求大小且足够容纳分配的内存池来分配缓冲区。例如，如果你需要50字节的分配，它会进入64字节的池，而512字节的分配则会进入1024字节的池。任何大于1024字节的分配将使用另一种方法进行大规模分配。使用大小化的内存池可以减少小块分配导致的碎片问题。只要大小池中有空闲条目满足请求的内存，分配就会被满足，较大的分配也不会受到太多阻塞。
- en: '**Heap Memory Storage**'
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**堆内存存储**'
- en: The final topic to discuss in relation to heap implementations is how information
    like the free-list is stored in memory. There are two methods. In one method,
    metadata, such as block size and whether the state is free or allocated, is stored
    alongside the allocated memory, which is known as *in-band*. In the other, known
    as *out-of-band*, metadata is stored elsewhere in memory. The out-of-band method
    is in many ways easier to exploit because you don’t have to worry about restoring
    important metadata when corrupting contiguous memory blocks, and it’s especially
    useful when you don’t know what values to restore for the metadata to be valid.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 与堆实现相关的最后一个话题是如何存储类似自由列表的信息。存储方法有两种。一种方法是将元数据（如块大小以及状态是空闲还是已分配）与已分配的内存一起存储，这称为*内带*（in-band）。另一种方法叫做*外带*（out-of-band），元数据存储在内存的其他地方。外带方法在许多方面更容易被利用，因为你不必担心在破坏连续内存块时恢复重要的元数据，尤其是当你不知道需要恢复哪些值以使元数据有效时，它特别有用。
- en: '***Arbitrary Memory Write Vulnerability***'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***任意内存写入漏洞***'
- en: Memory corruption vulnerabilities are often the easiest vulnerabilities to find
    through fuzzing, but they’re not the only kind, as mentioned in [Chapter 9](../Text/ch09.xhtml#ch09).
    The most interesting is an arbitrary file write resulting from incorrect resource
    handling. This incorrect handling of resources might be due to a command that
    allows you to directly specify the location of a file write or due to a command
    that has a path canonicalization vulnerability, allowing you to specify the location
    relative to the current directory. However the vulnerability manifests, it’s useful
    to know what you would need to write to the filesystem to get code execution.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 内存损坏漏洞通常是通过模糊测试最容易发现的漏洞，但它们并不是唯一的漏洞类型，正如[第9章](../Text/ch09.xhtml#ch09)所提到的。最有趣的漏洞是由于资源处理不当导致的任意文件写入。这种资源处理不当可能是由于允许你直接指定文件写入位置的命令，或者由于存在路径规范化漏洞的命令，使你能够指定相对于当前目录的位置。不管漏洞是如何表现的，知道需要写入文件系统哪些内容以获取代码执行是非常有用的。
- en: The arbitrary writing of memory, although it might be a direct consequence of
    a mistake in the application’s implementation, could also occur as a by-product
    of another vulnerability, such as a heap buffer overflow. Many old heap memory
    allocators would use a linked list structure to store the list of free blocks;
    if this linked list data were corrupted, any modification of the free-list could
    result in an arbitrary write of a value into an attacker-supplied location.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 内存的任意写入，虽然可能是应用程序实现中的一个直接错误，但也可能是另一个漏洞的副作用，例如堆缓冲区溢出。许多旧的堆内存分配器使用链表结构来存储空闲块列表；如果这个链表数据被破坏，任何对空闲列表的修改都可能导致一个值被写入攻击者提供的位置。
- en: To exploit an arbitrary memory write vulnerability, you need to modify a location
    that can directly control execution. For example, you could target the VTable
    pointer of an object in memory and overwrite it to gain control over execution,
    as in the methods for other corruption vulnerabilities.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用任意内存写入漏洞，你需要修改一个可以直接控制执行的位置。例如，你可以瞄准内存中某个对象的VTable指针，并覆盖它以获得对执行的控制，就像处理其他破坏性漏洞的方法一样。
- en: One advantage of an arbitrary write is that it can lead to subverting the logic
    of an application. As an example, consider the networked application shown in
    Listing 107\. Its logic creates a memory structure to store important information
    about a connection, such as the network socket used and whether the user was authenticated
    as an administrator, when the connection is created.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 任意写入的一个优点是，它可以导致颠覆应用程序的逻辑。例如，考虑清单107中显示的网络应用程序。它的逻辑在创建连接时创建一个内存结构，用于存储有关连接的重要信息，如使用的网络套接字以及用户是否经过身份验证为管理员。
- en: '[PRE8]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 10-7: A simple connection session structure*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-7：一个简单的连接会话结构*'
- en: For this example, we’ll assume that some code checks, whether or not the session
    is an administrator session, will allow only certain tasks to be done, such as
    changing the system’s configuration. There is a direct command to execute a local
    shell command if you’re authenticated as an administrator in the session, as shown
    in [Listing 10-8](../Text/ch10.xhtml#ch10list8).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们假设一些代码检查会判断会话是否为管理员会话，这将只允许执行某些任务，如更改系统配置。如果你在会话中被认证为管理员，系统中会有直接的命令可以执行本地
    shell 命令，如[清单 10-8](../Text/ch10.xhtml#ch10list8)所示。
- en: '[PRE9]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 10-8: Opening the `run` command as an administrator*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-8：以管理员身份打开`run`命令*'
- en: By discovering the location of the session object in memory, you can change
    the `is_admin` value from `0` to `1`, opening the `run` command for the attacker
    to gain control over the target system. We could also change the `socket` value
    to point to another file, causing the application to write data to an arbitrary
    file when writing a response, because in most Unix-like platforms, file descriptors
    and sockets are effectively the same type of resource. You can use the `write`
    system call to write to a file, just as you can to write to the socket.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过发现会话对象在内存中的位置，你可以将`is_admin`值从`0`更改为`1`，从而打开`run`命令，让攻击者获得对目标系统的控制。我们还可以更改`socket`值，使其指向另一个文件，这会导致应用程序在写入响应时将数据写入任意文件，因为在大多数类似Unix的系统中，文件描述符和套接字实际上是同类型的资源。你可以使用`write`系统调用像写入套接字一样写入文件。
- en: Although this is a contrived example, it should help you understand what happens
    in real-world networked applications. For any application that uses some sort
    of authentication to separate user and administrator responsibilities, you could
    typically subvert the security system in this way.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个人为构造的例子，但它应该能帮助你理解在现实世界中的网络应用程序发生了什么。对于任何使用某种身份验证机制来区分用户和管理员职责的应用程序，你通常可以通过这种方式颠覆安全系统。
- en: '**Exploiting High-Privileged File Writes**'
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**利用高权限文件写入**'
- en: If an application is running with elevated privileges, such as root or administrator
    privileges, your options for exploiting an arbitrary file write are expansive.
    One technique is to overwrite executables or libraries that you know will get
    executed, such as the executable running the network service you’re exploiting.
    Many platforms provide other means of executing code, such as scheduled tasks,
    or `cron` jobs on Linux.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序以提升的权限运行，如root或管理员权限，你在利用任意文件写入时的选择将更加广泛。一种技术是覆盖你知道会被执行的可执行文件或库，例如运行你正在利用的网络服务的可执行文件。许多平台提供其他执行代码的方式，例如定时任务或Linux上的`cron`作业。
- en: If you have high privileges, you can write your own `cron` jobs to a directory
    and execute them. On modern Linux systems, there’s usually a number of `cron`
    directories already inside */etc* that you can write to, each with a suffix that
    indicates when the jobs will be executed. However, writing to these directories
    requires you to give the script file executable permissions. If your arbitrary
    file write only provides read and write permissions, you’ll need to write to */etc/cron.d*
    with a Crontab file to execute arbitrary system commands. [Listing 10-9](../Text/ch10.xhtml#ch10list9)
    shows an example of a simple Crontab file that will run once a minute and connect
    a shell process to an arbitrary host and TCP port where you can access system
    commands.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有高权限，你可以将自己的 `cron` 任务写入某个目录并执行它们。在现代 Linux 系统中，通常在 */etc* 目录下已经有多个 `cron`
    目录，你可以将任务写入这些目录，每个目录的后缀表示任务的执行时间。然而，写入这些目录需要你赋予脚本文件可执行权限。如果你的任意文件写入操作仅提供读写权限，你需要将文件写入到
    */etc/cron.d* 目录并使用 Crontab 文件来执行任意系统命令。[Listing 10-9](../Text/ch10.xhtml#ch10list9)
    展示了一个简单的 Crontab 文件示例，它每分钟执行一次并将一个 shell 进程连接到任意主机和 TCP 端口，你可以通过该连接访问系统命令。
- en: '[PRE10]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 10-9: A simple reverse shell Crontab file*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-9：一个简单的反向 shell Crontab 文件*'
- en: This Crontab file must be written to */etc/cron.d/run_shell*. Note that some
    versions of bash don’t support this reverse shell syntax, so you would have to
    use something else, such as a Python script, to achieve the same result. Now let’s
    look at how to exploit write vulnerabilities with low-privileged file writes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Crontab 文件必须写入到 */etc/cron.d/run_shell*。请注意，某些版本的 bash 不支持这种反向 shell 语法，因此你可能需要使用其他方法，比如
    Python 脚本，来实现相同的效果。现在让我们来看看如何利用低权限文件写入漏洞。
- en: '**Exploiting Low-Privileged File Writes**'
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**利用低权限文件写入**'
- en: If you don’t have high privileges when a write occurs, all is not lost; however,
    your options are more limited, and you’ll still need to understand what is available
    on the system to exploit. For example, if you’re trying to exploit a web application
    or there’s a web server install on the machine, it might be possible to drop a
    server-side rendered web page, which you can then access through a web server.
    Many web servers will also have PHP installed, which allows you to execute commands
    as the web server user and return the result of that command by writing the file
    shown in [Listing 10-10](../Text/ch10.xhtml#ch10list10) to the web root (it might
    be in */var/www/html* or one of many other locations) with a *.php* extension.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在写入时没有高权限，情况并非完全无望；然而，你的选择会更有限，你仍然需要了解系统中可以利用的资源。例如，如果你正在尝试利用一个 web 应用程序，或者机器上安装了
    web 服务器，可能有机会放置一个服务器端渲染的网页，然后通过 web 服务器访问它。许多 web 服务器也会安装 PHP，这使你能够作为 web 服务器用户执行命令，并通过将
    [Listing 10-10](../Text/ch10.xhtml#ch10list10) 中显示的文件写入 web 根目录（它可能位于 */var/www/html*
    或其他多个位置）并使用 *.php* 扩展名来返回命令的执行结果。
- en: '[PRE11]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 10-10: A simple PHP shell*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-10：一个简单的 PHP shell*'
- en: 'After you’ve dropped this PHP shell to the web root, you can execute arbitrary
    commands on the system in the context of the web server by requesting a URL in
    the form *http://server/shell.php?exec=CMD*. The URL will result in the PHP code
    being executed on the server: the PHP shell will extract the `exec` parameter
    from the URL and pass it to the system API, with the result of executing the arbitrary
    command `CMD`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将这个 PHP shell 文件放到 web 根目录后，你可以通过请求类似 *http://server/shell.php?exec=CMD* 的
    URL，在 web 服务器的上下文中执行系统上的任意命令。该 URL 会导致 PHP 代码在服务器上执行：PHP shell 会从 URL 中提取 `exec`
    参数并将其传递给系统 API，执行任意命令 `CMD` 并返回结果。
- en: 'Another advantage of PHP is that it doesn’t matter what else is in the file
    when it’s written: the PHP parser will look for the `<?php … ?>` tags and execute
    any PHP code within those tags regardless of whatever else is in the file. This
    is useful when you don’t have full control over what’s written to a file during
    the vulnerability exploitation.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的另一个优点是，当文件被写入时，文件中其他内容并不重要：PHP 解析器会查找 `<?php … ?>` 标签，并执行这些标签内的任何 PHP 代码，而不管文件中还有什么其他内容。当你在利用漏洞时无法完全控制写入文件的内容时，这一特性非常有用。
- en: '**Writing Shell Code**'
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写 Shell 代码**'
- en: Now let’s look at how to start writing your own shell code. Using this shell
    code, you can execute arbitrary commands within the context of the application
    you’re exploiting with your discovered memory corruption vulnerability.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下如何开始编写自己的 shell 代码。使用这些 shell 代码，你可以在利用你发现的内存损坏漏洞的应用程序上下文中执行任意命令。
- en: Writing your own shell code can be complex, and although I can’t do it full
    justice in the remainder of this chapter, I’ll give you some examples you can
    build on as you continue your own research into the subject. I’ll start with some
    basic techniques and challenges of writing x64 code using the Linux platform.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 编写你自己的shell代码可能很复杂，虽然我无法在本章的剩余部分充分讲解它，但我会提供一些示例，供你在继续研究该主题时使用。我将从一些基本技巧和编写x64代码的挑战开始，使用Linux平台进行编写。
- en: '***Getting Started***'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***开始使用***'
- en: 'To start writing shell code, you need the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始编写shell代码，你需要以下工具：
- en: • An installation of Linux x64.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: • 安装Linux x64。
- en: • A compiler; both GCC and CLANG are suitable.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个编译器；GCC和CLANG都适用。
- en: • A copy of the *Netwide Assembler (NASM)*; most Linux distributions have a
    package available for this.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: • *Netwide Assembler (NASM)*的副本；大多数Linux发行版都提供该软件包。
- en: 'On Debian and Ubuntu, the following command should install everything you need:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian和Ubuntu上，以下命令应安装你所需的所有工具：
- en: '[PRE12]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’ll write the shell code in x64 assembly language and assemble it using `nasm`,
    a binary assembler. Assembling your shell code should result in a binary file
    containing just the machine instructions you specified. To test your shell code,
    you can use [Listing 10-11](../Text/ch10.xhtml#ch10list11), written in C, to act
    as a test harness.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用x64汇编语言编写shell代码，并使用`nasm`进行汇编，这是一个二进制汇编器。汇编你的shell代码应该会生成一个仅包含你指定的机器指令的二进制文件。为了测试你的shell代码，你可以使用用C编写的[清单
    10-11](../Text/ch10.xhtml#ch10list11)作为测试工具。
- en: test_shellcode.c
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: test_shellcode.c
- en: '[PRE13]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 10-11: A shell code test harness*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-11：一个shell代码测试工具*'
- en: The code takes a path from the command line ➊ and then maps it into memory as
    a memory-mapped file ➋. We specify that the code is executable with the `PROT_EXEC`
    flag ➌; otherwise, various platform-level exploit mitigations could potentially
    stop the shell code from executing.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从命令行获取一个路径➊，然后将其映射到内存中，作为内存映射文件➋。我们使用`PROT_EXEC`标志指定代码是可执行的➌；否则，各种平台级的漏洞缓解措施可能会阻止shell代码的执行。
- en: Compile the test code using the installed C compiler by executing the following
    command at the shell. You shouldn’t see any warnings during compilation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用已安装的C编译器通过在shell中执行以下命令来编译测试代码。在编译过程中你应该不会看到任何警告。
- en: '[PRE14]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To test the code, put the following assembly code into the file *shellcode.asm*,
    as shown in [Listing 10-12](../Text/ch10.xhtml#ch10list12).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试代码，将以下汇编代码放入文件*shellcode.asm*中，如[清单 10-12](../Text/ch10.xhtml#ch10list12)所示。
- en: '[PRE15]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 10-12: A simple shell code example*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-12：一个简单的shell代码示例*'
- en: The shell code in [Listing 10-12](../Text/ch10.xhtml#ch10list12) simply moves
    the value `100` to the RAX register. The RAX register is used as the return value
    for a function call. The test harness will call this shell code as if it were
    a function, so we would expect the value of the RAX register to be returned to
    the test harness. The shell code then immediately issues the `ret` instruction,
    jumping back to the caller of the shell code, which in this case is our test harness.
    The test harness should then print out the return value of `100`, if successful.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-12](../Text/ch10.xhtml#ch10list12)中的shell代码简单地将值`100`移动到RAX寄存器。RAX寄存器用于函数调用的返回值。测试工具会像调用函数一样调用这段shell代码，因此我们期望RAX寄存器的值被返回给测试工具。然后，shell代码立即发出`ret`指令，跳回到调用者，即本例中的测试工具。如果成功，测试工具应打印返回值`100`。'
- en: 'Let’s try it out. First, we’ll need to assemble the shell code using `nasm`,
    and then we’ll execute it in the harness:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试吧。首先，我们需要使用`nasm`汇编shell代码，然后在测试工具中执行它：
- en: '[PRE16]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output returns `100` to the test harness, verifying that we’re successfully
    loading and executing the shell code. It’s also worth verifying that the assembled
    code in the resulting binary matches what we would expect. We can check this with
    the companion `ndisasm` tool, which disassembles this simple binary file without
    having to use a disassembler, such as IDA Pro. We need to use the `-b 64` switch
    to ensure `ndisasm` uses 64-bit disassembly, as shown here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 输出返回`100`到测试工具，验证我们成功加载并执行了shell代码。还值得验证生成的二进制文件中的汇编代码是否与我们预期的一致。我们可以使用配套的`ndisasm`工具来检查这一点，它能反汇编这个简单的二进制文件，而无需使用如IDA
    Pro这样的反汇编器。我们需要使用`-b 64`开关，以确保`ndisasm`使用64位反汇编，如下所示：
- en: '[PRE17]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output from `ndisasm` should match up with the instructions we specified
    in the original shell code file in [Listing 10-12](../Text/ch10.xhtml#ch10list12).
    Notice that we used the RAX register in the `mov` instruction, but in the disassembler
    output we find the EAX register. The assembler uses this 32-bit register rather
    than a 64-bit register because it realizes that the constant `0x64` fits into
    a 32-bit constant, so it can use a shorter instruction rather than loading an
    entire 64-bit constant. This doesn’t change the behavior of the code because,
    when loading the constant into EAX, the processor will automatically set the upper
    32 bits of the RAX register to zero. The `BITS` directive is also missing, because
    that is a directive for the `nasm` assembler to enable 64-bit support and is not
    needed in the final assembled output.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`ndisasm` 的输出应与我们在原始 Shell 代码文件中指定的指令相匹配，见[清单 10-12](../Text/ch10.xhtml#ch10list12)。注意，我们在
    `mov` 指令中使用了 RAX 寄存器，但在反汇编器输出中看到的是 EAX 寄存器。汇编器使用这个 32 位寄存器而不是 64 位寄存器，因为它意识到常数
    `0x64` 可以适配为 32 位常数，因此可以使用更短的指令，而不必加载完整的 64 位常数。这并不会改变代码的行为，因为当将常数加载到 EAX 中时，处理器会自动将
    RAX 寄存器的上 32 位设置为零。`BITS` 指令也缺失了，因为它是 `nasm` 汇编器的指令，用于启用 64 位支持，而在最终的汇编输出中不需要它。'
- en: '***Simple Debugging Technique***'
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***简单调试技巧***'
- en: Before you start writing more complicated shell code, let’s examine an easy
    debugging method. This is important when testing your full exploit, because it
    might not be easy to stop execution of the shell code at the exact location you
    want. We’ll add a breakpoint to our shell code using the `int3` instruction so
    that when the associated code is called, any attached debugger will be notified.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编写更复杂的 Shell 代码之前，让我们先看一种简单的调试方法。这在测试完整的漏洞利用代码时非常重要，因为可能很难在你想要的精确位置停止 Shell
    代码的执行。我们将使用 `int3` 指令在 Shell 代码中添加一个断点，这样当相关代码被调用时，任何附加的调试器都会收到通知。
- en: Modify the code in [Listing 10-12](../Text/ch10.xhtml#ch10list12) as shown in
    [Listing 10-13](../Text/ch10.xhtml#ch10list13) to add the `int3` breakpoint instruction
    and then rerun the `nasm` assembler.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 修改[清单 10-12](../Text/ch10.xhtml#ch10list12)中的代码，按照[清单 10-13](../Text/ch10.xhtml#ch10list13)所示添加
    `int3` 断点指令，然后重新运行 `nasm` 汇编器。
- en: '[PRE18]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 10-13: A simple shell code example with a breakpoint*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-13：带断点的简单 Shell 代码示例*'
- en: If you execute the test harness in a debugger, such as GDB, the output should
    be similar to [Listing 10-14](../Text/ch10.xhtml#ch10list14).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在调试器中执行测试工具，例如 GDB，输出应与[清单 10-14](../Text/ch10.xhtml#ch10list14)类似。
- en: '[PRE19]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 10-14: Setting a breakpoint on a shell*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-14：在 Shell 上设置断点*'
- en: When we execute the test harness, the debugger stops on a `SIGTRAP` signal ➊.
    The reason is that the processor has executed the `int3` instruction, which acts
    as a breakpoint, resulting in the OS sending the `SIGTRAP` signal to the process
    that the debugger handles. Notice that when we print the instruction the program
    is currently running ➋, it’s not the `int3` instruction but instead the `mov`
    instruction immediately afterward. We don’t see the `int3` instruction because
    the debugger has automatically skipped over it to allow the execution to continue.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行测试工具时，调试器会在 `SIGTRAP` 信号 ➊ 上停下。原因是处理器执行了 `int3` 指令，它充当一个断点，导致操作系统向调试器处理的进程发送了
    `SIGTRAP` 信号。注意，当我们打印程序当前正在执行的指令 ➋ 时，看到的并不是 `int3` 指令，而是紧接着的 `mov` 指令。我们没有看到 `int3`
    指令，因为调试器已经自动跳过了它，以允许程序继续执行。
- en: '***Calling System Calls***'
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调用系统调用***'
- en: The example shell code in [Listing 10-12](../Text/ch10.xhtml#ch10list12) only
    returns the value 100 to the caller, in this case our test harness, which is not
    very useful for exploiting a vulnerability; for that, we need the system to do
    some work for us. The easiest way to do that in shell code is to use the OS’s
    system calls. A system call is specified using a system call number defined by
    the OS. It allows you to call basic system functions, such as opening files and
    executing new processes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-12](../Text/ch10.xhtml#ch10list12) 中的示例 Shell 代码只返回值 100 给调用者，在这个例子中是我们的测试工具，这对于利用漏洞并不是很有用；为此，我们需要让系统为我们做一些工作。在
    Shell 代码中，最简单的方式是使用操作系统的系统调用。系统调用是通过操作系统定义的系统调用编号来指定的。它允许你调用一些基本的系统功能，例如打开文件和执行新进程。'
- en: Using system calls is easier than calling into system libraries because you
    don’t need to know the memory location of other executable code, such as the system
    C library. Not needing to know library locations makes your shell code simpler
    to write and more portable across different versions of the same OS.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用系统调用比调用系统库更简单，因为你不需要知道其他可执行代码（如系统 C 库）的内存位置。无需知道库的位置使得你的 shell 代码更易编写，并且在不同版本的操作系统之间更具可移植性。
- en: 'However, there are downsides to using system calls: they generally implement
    much lower-level functionality than the system libraries, making them more complicated
    to call, as you’ll see. This is especially true on Windows, which has very complicated
    system calls. But for our purposes, a system call will be sufficient for demonstrating
    how to write your own shell code.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用系统调用也有缺点：它们通常实现比系统库更低级的功能，使得调用起来更加复杂，正如你将看到的那样。这在 Windows 上尤其如此，因为 Windows
    的系统调用非常复杂。但就我们的目的而言，系统调用足以演示如何编写你自己的 shell 代码。
- en: 'System calls have their own defined application binary interface (ABI) (see
    “[Application Binary Interface](../Text/ch06.xhtml#ch00lev1sec154)” on [page 123](../Text/ch06.xhtml#page_123)
    for more details). In x64 Linux, you execute a system call using the following
    ABI:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用有其定义的应用程序二进制接口（ABI）（有关更多细节，请参见[“应用程序二进制接口”](../Text/ch06.xhtml#ch00lev1sec154)和[第123页](../Text/ch06.xhtml#page_123)）。在
    x64 Linux 中，使用以下 ABI 执行系统调用：
- en: • The number of the system call is placed in the RAX register.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: • 系统调用的编号放在 RAX 寄存器中。
- en: • Up to six arguments can be passed into the system call in the registers RDI,
    RSI, RDX, R10, R8 and R9.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: • 最多可以通过 RDI、RSI、RDX、R10、R8 和 R9 寄存器向系统调用传递六个参数。
- en: • The system call is issued using the `syscall` instruction.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: • 系统调用通过`syscall`指令发出。
- en: • The result of the system call is stored in RAX after the `syscall` instruction
    returns.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: • 系统调用的结果在`syscall`指令返回后存储在 RAX 中。
- en: For more information about the Linux system call process, run `man 2 syscall`
    on a Linux command line. This page contains a manual that describes the system
    call process and defines the ABI for various different architectures, including
    x86 and ARM. In addition, `man 2 syscalls` lists all the available system calls.
    You can also read the individual pages for a system call by running `man 2 <SYSTEM
    CALL NAME>`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关 Linux 系统调用过程的更多信息，可以在 Linux 命令行中运行`man 2 syscall`。此页面包含描述系统调用过程的手册，并定义了各种不同架构的
    ABI，包括 x86 和 ARM。此外，`man 2 syscalls`列出了所有可用的系统调用。你还可以通过运行`man 2 <系统调用名称>`来阅读每个系统调用的单独页面。
- en: '**The exit System Call**'
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**exit 系统调用**'
- en: To use a system call, we first need the system call number. Let’s use the `exit`
    system call as an example.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用系统调用，我们首先需要知道系统调用的编号。让我们以`exit`系统调用为例。
- en: How do we find the number for a particular system call? Linux comes with header
    files, which define all the system call numbers for the current platform, but
    trying to find the right header file on disk can be like chasing your own tail.
    Instead, we’ll let the C compiler do the work for us. Compile the C code in [Listing
    10-15](../Text/ch10.xhtml#ch10list15) and execute it to print the system call
    number of the `exit` system call.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何找到特定系统调用的编号呢？Linux 附带了头文件，定义了当前平台的所有系统调用编号，但尝试在磁盘上找到正确的头文件就像是在追逐自己的尾巴。相反，我们让
    C 编译器为我们做这件事。编译[列表 10-15](../Text/ch10.xhtml#ch10list15)中的 C 代码并执行它，打印出`exit`系统调用的系统调用编号。
- en: '[PRE20]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 10-15: Getting the system call number*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-15：获取系统调用编号*'
- en: On my system, the system call number for `exit` is 60, which is printed to my
    screen; yours may be different depending on the version of the Linux kernel you’re
    using, although the numbers don’t change very often. The `exit` system call specifically
    takes process exit code as a single argument to return to the OS and indicate
    why the process exited. Therefore, we need to pass the number we want to use for
    the process exit code into RDI. The Linux ABI specifies that the first parameter
    to a system call is specified in the RDI register. The `exit` system call doesn’t
    return anything from the kernel; instead, the process (the shell) is immediately
    terminated. Let’s implement the `exit` call. Assemble [Listing 10-16](../Text/ch10.xhtml#ch10list16)
    with `nasm` and run it inside the test harness.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统上，`exit` 的系统调用号是 60，这会打印到我的屏幕上；根据你使用的 Linux 内核版本，它可能会不同，尽管这些数字变化并不频繁。`exit`
    系统调用特别需要传递一个进程退出代码作为唯一参数，以便返回操作系统并指示进程为何退出。因此，我们需要将用于进程退出代码的数字传递给 RDI 寄存器。Linux
    ABI 规范指定，系统调用的第一个参数应通过 RDI 寄存器传递。`exit` 系统调用不会从内核返回任何内容；相反，进程（即 shell）会立即终止。让我们实现
    `exit` 调用。使用 `nasm` 汇编[列表 10-16](../Text/ch10.xhtml#ch10list16)，并在测试工具中运行它。
- en: '[PRE21]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 10-16: Calling the `exit` system call in shell code*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-16：在 shell 代码中调用 `exit` 系统调用*'
- en: Notice that the first print statement in [Listing 10-16](../Text/ch10.xhtml#ch10list16),
    which shows where the shell code was loaded, is still printed, but the subsequent
    print statement for the return of the shell code is not. This indicates the shell
    code has successfully called the `exit` system call. To double-check this, you
    can display the exit code from the test harness in your shell, for example, by
    using `echo $?` in bash. The exit code should be 42, which is what we passed in
    the `mov rdi` argument.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[列表 10-16](../Text/ch10.xhtml#ch10list16)中的第一个打印语句，显示了 shell 代码加载的位置，仍然会打印出来，但随后用于返回
    shell 代码的打印语句则不会显示。这表明 shell 代码已经成功调用了 `exit` 系统调用。为了再次确认，你可以在 shell 中通过 `echo
    $?` 查看测试工具的退出代码，例如在 bash 中。退出代码应该是 42，这就是我们在 `mov rdi` 参数中传递的值。
- en: '**The write System Call**'
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**write 系统调用**'
- en: 'Now let’s try calling `write`, a slightly more complicated system call that
    writes data to a file. Use the following syntax for the `write` system call:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试调用 `write`，一个稍微复杂一些的系统调用，它将数据写入文件。使用以下语法调用 `write` 系统调用：
- en: '[PRE22]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `fd` argument is the file descriptor to write to. It holds an integer value
    that describes which file you want to access. Then you declare the data to be
    written by pointing the buffer to the location of the data. You can specify how
    many bytes to write using `count`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`fd` 参数是要写入的文件描述符。它包含一个整数值，表示你想要访问的文件。接着你通过将缓冲区指向数据位置来声明要写入的数据。你可以使用 `count`
    来指定写入多少字节。'
- en: Using the code in [Listing 10-17](../Text/ch10.xhtml#ch10list17), we’ll pass
    the value 1 to the `fd` argument, which is the standard output for the console.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[列表 10-17](../Text/ch10.xhtml#ch10list17)中的代码，我们将把值 1 传递给 `fd` 参数，它是控制台的标准输出。
- en: '[PRE23]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 10-17: Calling the `write` system call in shell code*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-17：在 shell 代码中调用 `write` 系统调用*'
- en: By writing to standard output, we’ll print the data specified in `buf` to the
    console so we can see whether it worked. If successful, the string `Hello User!`
    should be printed to the shell console that the test harness is running on. The
    `write` system call should also return the number of bytes written to the file.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通过写入标准输出，我们将把 `buf` 中指定的数据打印到控制台，以便我们能看到是否成功。如果成功，字符串 `Hello User!` 应该会打印到测试工具运行的
    shell 控制台上。`write` 系统调用还应该返回写入文件的字节数。
- en: 'Now assemble [Listing 10-17](../Text/ch10.xhtml#ch10list17) with `nasm` and
    execute the binary in the test harness:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用 `nasm` 汇编[列表 10-17](../Text/ch10.xhtml#ch10list17)，并在测试工具中执行该二进制文件：
- en: '[PRE24]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Instead of printing the `Hello User!` greeting we were expecting, we get a strange
    result, `-14`. Any value returning from the `write` system call that’s less than
    zero indicates an error. On Unix-like systems, including Linux, there’s a set
    of defined error numbers (abbreviated as `errno`). The error code is defined as
    positive in the system but returns as negative to indicate that it’s an error
    condition. You can look up the error code in the system C header files, but the
    short Python script in [Listing 10-18](../Text/ch10.xhtml#ch10list18) will do
    the work for us.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们并没有看到预期中的`Hello User!`问候语，而是得到了一个奇怪的结果，`-14`。任何来自`write`系统调用的返回值小于零都表示发生了错误。在类Unix系统中，包括Linux，定义了一组错误码（缩写为`errno`）。该错误码在系统中是正值，但返回时为负值，以表示这是一个错误状态。你可以在系统C头文件中查找错误码，但[示例10-18](../Text/ch10.xhtml#ch10list18)中的简短Python脚本就能为我们完成这项工作。
- en: '[PRE25]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 10-18: A simple Python script to print error codes*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例10-18：一个简单的Python脚本，用于打印错误码*'
- en: 'Running the script will print the error code name as `EFAULT` and the string
    description as `Bad address`. This error code indicates that the system call tried
    to access some memory that was invalid, resulting in a memory fault. The only
    memory address we’re passing is the pointer to the greeting. Let’s look at the
    disassembly to find out whether the pointer we’re passing is at fault:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本将打印出错误码名称`EFAULT`，并且字符串描述为`Bad address`。这个错误码表示系统调用试图访问一些无效的内存，导致了内存故障。我们传递的唯一内存地址是指向问候语的指针。让我们看看反汇编代码，找出我们传递的指针是否存在问题：
- en: '[PRE26]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we can see the problem with our code: the `lea` instruction, which loads
    the address to the greeting, is loading the absolute address 0x1A. But if you
    look at the test harness executions we’ve done so far, the address at which we
    load the executable code isn’t at 0x1A or anywhere close to it. This mismatch
    between the location where the shell code loads and the absolute addresses causes
    a problem. We can’t always determine in advance where the shell code will be loaded
    in memory, so we need a way of referencing the greeting *relative* to the current
    executing location. Let’s look at how to do this on 32-bit and 64-bit x86 processors.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到代码中的问题：`lea`指令加载问候语的地址时，加载了绝对地址0x1A。但如果你查看我们到目前为止所做的测试执行，加载可执行代码的地址并不在0x1A或其附近。Shell代码加载位置和绝对地址之间的不匹配导致了问题。我们不能总是提前确定Shell代码将在哪个位置加载到内存中，因此我们需要一种方式来相对于当前执行位置引用问候语。让我们来看看如何在32位和64位x86处理器上做到这一点。
- en: '**Accessing the Relative Address on 32- and 64-Bit Systems**'
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在32位和64位系统上访问相对地址**'
- en: 'In 32-bit x86 mode, the simplest way of getting a relative address is to take
    advantage of the fact that the `call` instruction works with relative addresses.
    When a `call` instruction executes, it pushes the absolute address of the subsequent
    instruction onto the stack as a return address. We can use this absolute return
    address value to calculate where the current shell code is executing from and
    adjust the memory address of the greeting to match. For example, replace the `lea`
    instruction in [Listing 10-17](../Text/ch10.xhtml#ch10list17) with the following
    code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在32位x86模式下，获取相对地址的最简单方法是利用`call`指令支持相对地址这一事实。当`call`指令执行时，它将随后的指令的绝对地址压入栈中作为返回地址。我们可以使用这个绝对返回地址值来计算当前Shell代码的执行位置，并调整问候语的内存地址以匹配。例如，将[示例10-17](../Text/ch10.xhtml#ch10list17)中的`lea`指令替换为以下代码：
- en: '[PRE27]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using a relative `call` works well, but it massively complicates the code.
    Fortunately, the 64-bit instruction set introduced relative data addressing. We
    can access this in `nasm` by adding the `rel` keyword in front of an address.
    By changing the `lea` instruction as follows, we can access the address of the
    greeting relative to the current executing instruction:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相对`call`效果很好，但它会大大增加代码的复杂性。幸运的是，64位指令集引入了相对数据寻址。我们可以通过在地址前添加`rel`关键字，在`nasm`中访问这一功能。通过如下更改`lea`指令，我们可以访问相对于当前执行指令的问候地址：
- en: '[PRE28]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we can reassemble our shell code with these changes, and the message should
    print successfully:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过这些更改重新组装我们的Shell代码，并且消息应该能成功打印：
- en: '[PRE29]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***Executing the Other Programs***'
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***执行其他程序***'
- en: 'Let’s wrap up our overview of system calls by executing another binary using
    the `execve` system call. Executing another binary is a common technique for getting
    execution on a target system that doesn’t require long, complicated shell code.
    The `execve` system call takes three parameters: the path to the program to run,
    an array of command line arguments with the array terminated by `NULL`, and an
    array of environment variables terminated by `NULL`. Calling `execve` requires
    a bit more work than calling simple system calls, such as `write`, because we
    need to build the arrays on the stack; however, it’s not that hard. [Listing 10-19](../Text/ch10.xhtml#ch10list19)
    executes the `uname` command by passing it the `-a` argument.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过执行另一个二进制文件来总结一下系统调用的概述，使用 `execve` 系统调用执行另一个二进制文件。这是一种常见的技术，用于在目标系统上获得执行权限，而且不需要长而复杂的
    shell 代码。`execve` 系统调用需要三个参数：要运行的程序的路径，一个以 `NULL` 结束的命令行参数数组，以及一个以 `NULL` 结束的环境变量数组。调用
    `execve` 比调用简单的系统调用（如 `write`）需要做更多的工作，因为我们需要在栈上构建这些数组；但其实并不困难。[清单 10-19](../Text/ch10.xhtml#ch10list19)
    通过传递 `-a` 参数来执行 `uname` 命令。
- en: execve.asm
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: execve.asm
- en: '[PRE30]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 10-19: Executing an arbitrary executable in shell code*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-19：在 shell 代码中执行任意可执行文件*'
- en: 'The shellcode in [Listing 10-19](../Text/ch10.xhtml#ch10list19) is complex,
    so let’s break it down step-by-step. First, the addresses of two strings, `"/bin/uname"`
    and `"-a"`, are loaded into registers ➊. The addresses of the two strings with
    the final NUL (which is represented by a 0) are then pushed onto the stack in
    reverse order ➋. The code copies the current address of the stack to the RSI register,
    which is the second argument to the system call ➌. Next, a single NUL is pushed
    on the stack for the environment array, and the address on the stack is copied
    to the RDX register ➍, which is the third argument to the system call. The RDI
    register already contains the address of the `"/bin/uname"` string so our shell
    code does not need to reload the address before calling the system call. Finally,
    we execute the `execve` system call ➎, which executes the shell equivalent of
    the following C code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-19](../Text/ch10.xhtml#ch10list19) 中的 shell 代码很复杂，我们来一步步解析。首先，`"/bin/uname"`
    和 `"-a"` 两个字符串的地址被加载到寄存器中 ➊。接着，这两个字符串的地址以及最终的 NUL（表示为 0）被反向顺序推入栈中 ➋。代码将当前栈地址复制到
    RSI 寄存器，这是系统调用的第二个参数 ➌。然后，一个 NUL 被推入栈中作为环境变量数组，栈中的地址被复制到 RDX 寄存器 ➍，这是系统调用的第三个参数。RDI
    寄存器已经包含了 `"/bin/uname"` 字符串的地址，因此我们的 shell 代码在调用系统调用之前无需重新加载该地址。最后，我们执行 `execve`
    系统调用 ➎，它执行相当于以下 C 代码的 shell：'
- en: '[PRE31]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you assemble the `execve` shell code, you should see output similar to the
    following, where command line `/bin/uname -a` is executed:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你组装了 `execve` 的 shell 代码，你应该能看到类似以下的输出，其中命令行 `/bin/uname -a` 被执行：
- en: '[PRE32]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***Generating Shell Code with Metasploit***'
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Metasploit 生成 Shell 代码***'
- en: It’s worth practicing writing your own shell code to gain a deeper understanding
    of it. However, because people have been writing shell code for a long time, a
    wide range of shell code to use for different platforms and purposes is already
    available online.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 写自己的 shell 代码是很有价值的，可以帮助你更深入地理解它。然而，由于人们已经写了很长时间的 shell 代码，网上已经有很多可以用于不同平台和用途的
    shell 代码。
- en: 'The Metasploit project is one useful repository of shell code. Metasploit gives
    you the option of generating shell code as a binary blob, which you can easily
    plug into your own exploit. Using Metasploit has many advantages:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit 项目是一个有用的 shell 代码库。Metasploit 允许你将 shell 代码生成成二进制数据块，方便直接插入到自己的漏洞利用中。使用
    Metasploit 有很多优点：
- en: • Handling encoding of the shell code by removing banned characters or formatting
    to avoid detection
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: • 通过移除禁止字符或格式化处理来避免检测，从而处理 shell 代码的编码问题
- en: • Supporting many different methods of gaining execution, including simple reverse
    shell and executing new binaries
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: • 支持多种执行方式，包括简单的反向 shell 和执行新的二进制文件
- en: • Supporting multiple platforms (including Linux, Windows, and macOS) as well
    as multiple architectures (such as x86, x64, and ARM)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: • 支持多平台（包括 Linux、Windows 和 macOS）以及多架构（如 x86、x64 和 ARM）
- en: I won’t explain in great detail how to build Metasploit modules or use their
    staged shell code, which requires the use of the Metasploit console to interact
    with the target. Instead, I’ll use a simple example of a reverse TCP shell to
    show you how to generate shell code using Metasploit. (Recall that a reverse TCP
    shell allows the target machine to communicate with the attacker’s machine via
    a listening port, which the attacker can use to gain execution.)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细解释如何构建 Metasploit 模块或使用它们的分阶段 shell 代码，因为这需要使用 Metasploit 控制台与目标交互。相反，我将使用一个简单的反向
    TCP shell 示例，向你展示如何使用 Metasploit 生成 shell 代码。（回想一下，反向 TCP shell 允许目标机器通过监听端口与攻击者的机器进行通信，攻击者可以利用该端口获得执行权限。）
- en: '**Accessing Metasploit Payloads**'
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**访问 Metasploit 有效载荷**'
- en: 'The `msfvenom` command line utility comes with a Metasploit installation, which
    provides access to the various shell code payloads built into Metasploit. We can
    list the payloads supported for x64 Linux using the `-l` option and filtering
    the output:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`msfvenom` 命令行工具与 Metasploit 一起安装，它提供对 Metasploit 中内置的各种 shell 代码有效载荷的访问。我们可以使用
    `-l` 选项列出支持的 x64 Linux 有效载荷，并筛选输出：'
- en: '[PRE33]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We’ll use two shell codes:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两种 shell 代码：
- en: '`shell_bind_tcp` Binds to a TCP port and opens a local shell when connected
    to it'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`shell_bind_tcp` 绑定到 TCP 端口并在连接时打开本地 shell'
- en: '`shell_reverse_tcp` Attempts to connect back to your machine with a shell attached'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`shell_reverse_tcp` 尝试通过附加 shell 连接回你的机器'
- en: Both of these payloads should work with a simple tool, such as Netcat, by either
    connecting to the target system or listening on the local system.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种有效载荷应该可以与简单工具（如 Netcat）一起使用，通过连接到目标系统或在本地系统上监听来工作。
- en: '**Building a Reverse Shell**'
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**构建反向 Shell**'
- en: 'When generating the shell code, you must specify the listening port (for bind
    and reverse shell) and the listening IP (for reverse shell, this is your machine’s
    IP address). These options are specified by passing `LPORT=port` and `LHOST=IP`,
    respectively. We’ll use the following code to build a reverse TCP shell, which
    will connect to the host 172.21.21.1 on TCP port 4444:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成 shell 代码时，必须指定监听端口（用于绑定和反向 shell）和监听 IP（对于反向 shell，这是你机器的 IP 地址）。这些选项通过分别传递
    `LPORT=port` 和 `LHOST=IP` 来指定。我们将使用以下代码构建一个反向 TCP shell，它将连接到主机 172.21.21.1 的
    TCP 端口 4444：
- en: '[PRE34]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `msfvenom` tool outputs the shell code to standard output by default, so
    you’ll need to pipe it to a file; otherwise, it will just print to the console
    and be lost. We also need to specify the `-f raw` flag to output the shell code
    as a raw binary blob. There are other potential options as well. For example,
    you can output the shell code to a small .*elf* executable, which you can run
    directly for testing. Because we have a test harness, we won’t need to do that.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`msfvenom` 工具默认将 shell 代码输出到标准输出，因此你需要将其管道传输到一个文件中；否则，它只会打印到控制台并丢失。我们还需要指定
    `-f raw` 标志，以将 shell 代码输出为原始二进制 Blob。也有其他潜在选项。例如，你可以将 shell 代码输出到一个小的 .*elf* 可执行文件中，直接运行进行测试。由于我们有测试环境，所以无需这样做。'
- en: '**Executing the Payload**'
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**执行有效载荷**'
- en: 'To execute the payload, we need to set up a listening instance of `netcat`
    listening on port 4444 (for example, `nc -l 4444`). It’s possible that you won’t
    see a prompt when the connection is made. However, typing the `id` command should
    echo back the result:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行有效载荷，我们需要设置一个在端口 4444 上监听的 `netcat` 实例（例如，`nc -l 4444`）。当连接建立时，可能不会看到提示符。然而，输入
    `id` 命令应该会回显结果：
- en: '[PRE35]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The result shows that the shell successfully executed the `id` command on the
    system the shell code is running on and printed the user and group IDs from the
    system. You can use a similar payload on Windows, macOS, and even Solaris. It
    might be worthwhile to explore the various options in `msfvenom` on your own.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示 shell 成功在运行 shell 代码的系统上执行了 `id` 命令，并打印了系统的用户和组 ID。你可以在 Windows、macOS 甚至
    Solaris 上使用类似的有效载荷。自己探索 `msfvenom` 中的各种选项可能会很有价值。
- en: '**Memory Corruption Exploit Mitigations**'
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**内存破坏利用缓解措施**'
- en: In “[Exploiting Memory Corruption Vulnerabilities](../Text/ch10.xhtml#ch00lev1sec285)”
    on [page 246](../Text/ch10.xhtml#page_246), I alluded to exploit mitigations and
    how they make exploiting memory vulnerabilities difficult. The truth is that exploiting
    a memory corruption vulnerability on most modern platforms can be quite complicated
    due to exploit mitigations added to the compilers (and the generated application)
    as well as to the OS.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在《[利用内存破坏漏洞](../Text/ch10.xhtml#ch00lev1sec285)》中的[第246页](../Text/ch10.xhtml#page_246)，我提到了利用防护措施，以及它们如何使利用内存漏洞变得困难。事实是，由于编译器（以及生成的应用程序）和操作系统中添加了利用防护措施，在大多数现代平台上，利用内存破坏漏洞可能变得相当复杂。
- en: Security vulnerabilities seem to be an inevitable part of software development,
    as do significant chunks of source code written in memory-unsafe languages that
    are not updated for long periods of time. Therefore, it’s unlikely that memory
    corruption vulnerabilities will disappear overnight.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 安全漏洞似乎是软件开发中不可避免的一部分，就像大量使用内存不安全语言编写的源代码，这些代码长时间未得到更新。因此，内存破坏漏洞不太可能在一夜之间消失。
- en: Instead of trying to fix all these vulnerabilities, developers have implemented
    clever techniques to mitigate the impact of known security weaknesses. Specifically,
    these techniques aim to make exploitation of memory corruption vulnerabilities
    difficult or, ideally, impossible. In this section, I’ll describe some of the
    exploit mitigation techniques used in contemporary platforms and development tools
    that make it more difficult for attackers to exploit these vulnerabilities.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者没有尝试修复所有这些漏洞，而是实施了巧妙的技术来减轻已知安全漏洞的影响。具体而言，这些技术旨在使内存破坏漏洞的利用变得困难，或者理想情况下使其变得不可能。在本节中，我将描述一些在当代平台和开发工具中使用的利用防护技术，这些技术使攻击者更难利用这些漏洞。
- en: '***Data Execution Prevention***'
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数据执行保护***'
- en: As you saw earlier, one of the main aims when developing an exploit is to gain
    control of the instruction pointer. In my previous explanation, I glossed over
    problems that might occur when placing your shell code in memory and executing
    it. On modern platforms, you’re unlikely to be able to execute arbitrary shell
    code as easily as described earlier due to *Data Execution Prevention (DEP)* or
    *No-Execute (NX)* mitigation.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你之前看到的，开发利用程序的主要目标之一是获得对指令指针的控制。在我之前的解释中，我略过了将 shell 代码放入内存并执行时可能遇到的问题。在现代平台上，由于*数据执行保护（DEP）*或*不执行（NX）*的防护措施，你不太可能像之前那样轻松地执行任意的
    shell 代码。
- en: DEP attempts to mitigate memory corruption exploitation by requiring memory
    with executable instructions to be specially allocated by the OS. This requires
    processor support so that if the process tries to execute memory at an address
    that’s not marked as executable, the processor raises an error. The OS then terminates
    the process in error to prevent further execution.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: DEP（数据执行保护）尝试通过要求操作系统特别分配可执行指令的内存来缓解内存破坏的利用。这需要处理器支持，使得如果进程试图在未标记为可执行的地址处执行内存，处理器会触发错误。操作系统随后会终止该进程以防止进一步执行。
- en: The error resulting from executing nonexecutable memory can be hard to spot
    and look confusing at first. Almost all platforms misreport the error as `Segmentation
    fault` or `Access violation` on what looks like potentially legitimate code. You
    might mistake this error for the instruction’s attempt to access invalid memory.
    Due to this confusion, you might spend time debugging your code to figure out
    why your shell code isn’t executing correctly, believing it to be a bug in your
    code when it’s actually DEP being triggered. For example, Listing 10-20 shows
    an example of a DEP crash.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 执行不可执行内存导致的错误可能很难察觉，并且一开始看起来会让人困惑。几乎所有平台都会将错误错误报告为 `Segmentation fault` 或 `Access
    violation`，即使它看起来是潜在合法的代码。你可能会误以为这个错误是指令试图访问无效内存。由于这种混淆，你可能会花时间调试代码，试图找出为什么 shell
    代码没有正确执行，认为这是代码中的 bug，而实际上是触发了 DEP。例如，清单 10-20 展示了一个 DEP 崩溃的示例。
- en: '[PRE36]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 10-20: An example crash from executing nonexecutable memory*'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-20：执行不可执行内存时的崩溃示例*'
- en: It’s tricky to determine the source of this crash. At first glance, you might
    think it’s due to an invalid stack pointer, because the push instruction at ➊
    would result in the same error. Only by looking at where the instruction is located
    can you discover it was executing nonexecutable memory. You can determine whether
    it’s in executable memory by using the memory map commands described in [Table
    10-8](../Text/ch10.xhtml#ch10tab8).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 确定崩溃的源头是很棘手的。乍一看，你可能认为是因为无效的栈指针，因为在 ➊ 处的 push 指令会导致相同的错误。只有通过查看指令所在的位置，你才能发现它在执行不可执行的内存。你可以通过使用[表
    10-8](../Text/ch10.xhtml#ch10tab8)中描述的内存映射命令来确定它是否在可执行内存中。
- en: DEP is very effective in many cases at preventing easy exploitation of memory
    corruption vulnerabilities, because it’s easy for a platform developer to limit
    executable memory to specific executable modules, leaving areas like the heap
    or stack nonexecutable. However, limiting executable memory in this way does require
    hardware and software support, leaving software vulnerable due to human error.
    For example, when exploiting a simple network-connected device, it might be that
    the developers haven’t bothered to enable DEP or that the hardware they’re using
    doesn’t support it.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，DEP 非常有效地防止了内存破坏漏洞的轻松利用，因为平台开发人员可以轻松地将可执行内存限制为特定的可执行模块，使堆或栈等区域不可执行。然而，以这种方式限制可执行内存确实需要硬件和软件的支持，这使得软件因人为错误而容易受到攻击。例如，在利用一个简单的网络连接设备时，可能是因为开发人员没有启用
    DEP，或者他们使用的硬件不支持 DEP。
- en: If DEP is enabled, you can use the return-oriented programming method as a workaround.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了 DEP，你可以使用面向返回的编程方法作为一种解决方法。
- en: '***Return-Oriented Programming Counter-Exploit***'
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***面向返回的编程反制技术***'
- en: The development of the *return-oriented programming (ROP)* technique was in
    direct response to the increase in platforms equipped with DEP. ROP is a simple
    technique that repurposes existing, already executable instructions rather than
    injecting arbitrary instructions into memory and executing them. Let’s look at
    a simple example of a stack memory corruption exploit using this technique.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '*面向返回的编程（ROP）* 技术的发展是直接回应平台上 DEP 的增加。ROP 是一种简单的技术，它重新利用已经可执行的现有指令，而不是将任意指令注入内存并执行它们。我们来看一个简单的堆栈内存破坏漏洞利用的例子，使用这种技术。'
- en: 'On Unix-like platforms, the C library, which provides the basic API for applications
    such as opening files, also has functions that allow you to start a new process
    by passing the command line in program code. The `system()` function is such a
    function and has the following syntax:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 Unix 平台上，C 库提供了用于应用程序的基本 API，比如打开文件，它还包含允许通过程序代码传递命令行来启动新进程的函数。`system()`
    函数就是这样一个函数，其语法如下：
- en: '[PRE37]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The function takes a simple command string, which represents the program to
    run and the command line arguments. This command string is passed to the command
    interpreter, which we’ll come back to later. For now, know that if you write the
    following in a C application, it executes the `ls` application in the shell:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个简单的命令字符串，表示要运行的程序及其命令行参数。这个命令字符串会传递给命令解释器，我们稍后会详细讲解。现在需要知道的是，如果你在 C 应用程序中写入以下内容，它会在
    shell 中执行`ls`应用程序：
- en: '[PRE38]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If we know the address of the `system` API in memory, we can redirect the instruction
    pointer to the start of the API’s instructions; in addition, if we can influence
    the parameter in memory, we can start a new process under our control. Calling
    the `system` API allows you to bypass DEP because, as far as the processor and
    platform are concerned, you’re executing legitimate instructions in memory marked
    as executable. [Figure 10-8](../Text/ch10.xhtml#ch10fig8) shows this process in
    more detail.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道 `system` API 在内存中的地址，我们可以将指令指针重定向到该 API 指令的起始位置；此外，如果我们能在内存中影响参数，我们就可以启动一个我们控制的新进程。调用
    `system` API 允许你绕过 DEP，因为就处理器和平台而言，你在执行标记为可执行的内存中的合法指令。[图 10-8](../Text/ch10.xhtml#ch10fig8)
    更详细地展示了这个过程。
- en: In this very simple visualization, ROP executes a function provided by the C
    library (libc) to bypass DEP. This technique, specifically called *Ret2Libc*,
    laid the foundation of ROP as we know it today. You can generalize this technique
    to write almost any program using ROP, for example, to implement a full Turing
    complete system entirely by manipulating the stack.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个非常简单的可视化中，ROP 执行一个由 C 库 (libc) 提供的函数来绕过 DEP。这个技术，特别是被称为 *Ret2Libc*，为我们今天所知的
    ROP 打下了基础。你可以将这种技术推广到使用 ROP 编写几乎任何程序，例如，通过操控堆栈实现一个完整的图灵完备系统。
- en: '![image](../Images/f10-08.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f10-08.jpg)'
- en: '*Figure 10-8: A simple ROP to call the `system` API*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-8：一个简单的 ROP 调用 `system` API*'
- en: The key to understanding ROP is to know that a sequence of instructions doesn’t
    have to execute as it was originally compiled into the program’s executable code.
    This means you can take small snippets of code throughout the program or in other
    executable code, such as libraries, and repurpose them to perform actions the
    developers didn’t originally intend to execute. These small sequences of instructions
    that perform some useful function are called *ROP gadgets*. [Figure 10-9](../Text/ch10.xhtml#ch10fig9)
    shows a more complex ROP example that opens a file and then writes a data buffer
    to the file.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 ROP 的关键是要知道，一系列指令不一定要像最初编译成程序的可执行代码那样按顺序执行。这意味着你可以将程序中或其他可执行代码（如库文件）中的小段代码提取出来，重新利用它们来执行开发者最初未打算执行的操作。这些执行某些有用功能的小段指令被称为
    *ROP 小工具*。[图 10-9](../Text/ch10.xhtml#ch10fig9) 展示了一个更复杂的 ROP 示例，它打开一个文件，然后将数据缓冲区写入该文件。
- en: '![image](../Images/f10-09.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f10-09.jpg)'
- en: '*Figure 10-9: A more complex ROP calling `open` and then writing to the file
    by using a couple of gadgets*'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-9：一个更复杂的 ROP 调用 `open` 然后使用几个小工具向文件写入数据*'
- en: Because the value of the file descriptor returning from `open` probably can’t
    be known ahead of time, this task would be more difficult to do using the simpler
    Ret2Libc technique.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 因为从 `open` 返回的文件描述符的值可能无法预先知道，所以使用更简单的 Ret2Libc 技术来完成这个任务会更困难。
- en: Populating the stack with the correct sequence of operations to execute as ROP
    is easy if you have a stack buffer overflow. But what if you only have some other
    method of gaining the initial code execution, such as a heap buffer overflow?
    In this case, you’ll need a stack pivot, which is a ROP gadget that allows you
    to set the current stack pointer to a known value. For example, if after the exploit
    EAX points to a memory buffer you control (perhaps it’s a VTable pointer), you
    can gain control over the stack pointer and execute your ROP chain using a gadget
    that looks like [Listing 10-21](../Text/ch10.xhtml#ch10list21).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有堆栈缓冲区溢出，填充堆栈以执行 ROP 操作序列是很容易的。但如果你只有通过其他方法获得初始代码执行权限，例如堆缓冲区溢出呢？在这种情况下，你将需要一个堆栈枢纽，它是一个
    ROP 小工具，允许你将当前堆栈指针设置为已知的值。例如，如果在利用漏洞后 EAX 指向你控制的内存缓冲区（也许它是一个 VTable 指针），你就可以控制堆栈指针，并通过一个类似于
    [列表 10-21](../Text/ch10.xhtml#ch10list21) 的小工具执行你的 ROP 链。
- en: '[PRE39]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 10-21: Gaining execution using a ROP gadget*'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-21：使用 ROP 小工具获得执行权限*'
- en: The gadget shown in [Listing 10-21](../Text/ch10.xhtml#ch10list21) switches
    the register value EAX with the value ESP, which indexes the stack in memory.
    Because we control the value of EAX, we can pivot the stack location to the set
    of operations (such as in [Figure 10-9](../Text/ch10.xhtml#ch10fig9)), which will
    execute our ROP.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10-21](../Text/ch10.xhtml#ch10list21) 中显示的小工具将寄存器值 EAX 与寄存器值 ESP 交换，后者用于索引内存中的堆栈。因为我们控制
    EAX 的值，所以可以将堆栈位置切换到一组操作（如 [图 10-9](../Text/ch10.xhtml#ch10fig9) 中的操作），这将执行我们的
    ROP。'
- en: Unfortunately, using ROP to get around DEP is not without problems. Let’s look
    at some ROP limitations and how to deal with them.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用 ROP 绕过 DEP 并非没有问题。让我们来看看一些 ROP 的局限性以及如何解决这些问题。
- en: '***Address Space Layout Randomization (ASLR)***'
  id: totrans-349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***地址空间布局随机化 (ASLR)***'
- en: Using ROP to bypass DEP creates a couple of problems. First, you need to know
    the location of the system functions or ROP gadgets you’re trying to execute.
    Second, you need to know the location of the stack or other memory locations to
    use as data. However, finding locations wasn’t always a limiting factor.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ROP 绕过 DEP 会带来一些问题。首先，你需要知道你试图执行的系统函数或 ROP 小工具的位置。其次，你需要知道堆栈或其他内存位置的地址，用作数据。然而，寻找位置并不总是一个限制因素。
- en: When DEP was first introduced into Windows XP SP2, all system binaries and the
    main executable file were mapped in consistent locations, at least for a given
    update revision and language. (This is why earlier Metasploit modules require
    you to specify a language). In addition, the operation of the heap and the locations
    of thread stacks were almost completely predictable. Therefore, on XP SP2 it was
    easy to circumvent DEP, because you could guess the location of all the various
    components you might need to execute your ROP chain.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当DEP首次引入Windows XP SP2时，所有系统二进制文件和主可执行文件都映射在一致的位置，至少对于特定的更新版本和语言是这样。（这就是为什么早期的Metasploit模块需要你指定语言）。此外，堆的操作和线程栈的位置几乎完全是可预测的。因此，在XP
    SP2上绕过DEP非常容易，因为你可以猜测到执行ROP链时可能需要的各个组件的位置。
- en: '**Memory Information Disclosure Vulnerabilities**'
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**内存信息泄露漏洞**'
- en: With the introduction of *Address Space Layout Randomization (ASLR)*, bypassing
    DEP became more difficult. As its name suggests, the goal of this mitigation method
    is to randomize the layout of a process’s address space to make it harder for
    an attacker to predict. Let’s look at a couple of ways that an exploit can bypass
    the protections provided by ASLR.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 随着*地址空间布局随机化（ASLR）*的引入，绕过DEP变得更加困难。顾名思义，这种缓解方法的目标是随机化进程地址空间的布局，以使攻击者更难预测。让我们看看几种攻击利用方式，如何绕过ASLR提供的保护。
- en: 'Before ASLR, information disclosure vulnerabilities were typically useful for
    circumventing an application’s security by allowing access to protected information
    in memory, such as passwords. These types of vulnerabilities have found a new
    use: revealing the layout of the address space to counter randomization by ASLR.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASLR引入之前，信息泄露漏洞通常用于通过允许访问内存中受保护的信息（如密码）来绕过应用程序的安全性。这些类型的漏洞现在找到了新的用途：揭示地址空间的布局，以对抗ASLR的随机化。
- en: 'For this kind of exploit, you don’t always need to find a specific memory information
    disclosure vulnerability; in some cases, you can *create* an information disclosure
    vulnerability from a memory corruption vulnerability. Let’s use an example of
    a heap memory corruption vulnerability. We can reliably overwrite an arbitrary
    number of bytes after a heap allocation, which can in turn be used to disclose
    the contents of memory using a heap overflow like so: one common structure that
    might be allocated on the heap is a buffer containing a length-prefixed string,
    and when the string buffer is allocated, an additional number of bytes is placed
    at the front to accommodate a length field. The string data is then stored after
    the length, as shown in [Figure 10-10](../Text/ch10.xhtml#ch10fig10).'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种类型的漏洞利用，你并不总是需要找到特定的内存信息泄露漏洞；在某些情况下，你可以*创建*一个信息泄露漏洞来利用内存损坏漏洞。我们可以以堆内存损坏漏洞为例。我们可以可靠地覆盖堆分配之后的任意字节数量，这些字节可以用来通过堆溢出泄露内存内容，像这样：一种常见的堆分配结构是包含长度前缀字符串的缓冲区，当分配字符串缓冲区时，额外的字节会被放在前面以容纳长度字段。然后，字符串数据存储在长度字段之后，如[图10-10](../Text/ch10.xhtml#ch10fig10)所示。
- en: '![image](../Images/f10-10.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f10-10.jpg)'
- en: '*Figure 10-10: Converting memory corruption to information disclosure*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-10：将内存损坏转化为信息泄露*'
- en: At the top is the original pattern of heap allocations ➊. If the vulnerable
    allocation is placed prior to the string buffer in memory, we would have the opportunity
    to corrupt the string buffer. Prior to any corruption occurring, we can only read
    the 5 valid bytes from the string buffer.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最上面是原始的堆分配模式 ➊。如果易受攻击的分配位于内存中的字符串缓冲区之前，我们就有机会破坏字符串缓冲区。在任何损坏发生之前，我们只能读取字符串缓冲区中的5个有效字节。
- en: At the bottom, we cause the vulnerable allocation to overflow by just enough
    to modify only the length field of the string ➋. We can set the length to an arbitrary
    value, in this case, 100 bytes. Now when we read back the string, we’ll get back
    100 bytes instead of only the 5 bytes that were originally allocated. Because
    the string buffer’s allocation is not that large, data from other allocations
    would be returned, which could include sensitive memory addresses, such as VTable
    pointers and heap allocation pointers. This disclosure gives you enough information
    to bypass ASLR.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部，我们通过足够的溢出仅修改字符串的长度字段 ➋。我们可以将长度设置为任意值，在这种情况下是 100 字节。现在，当我们重新读取字符串时，我们将得到
    100 字节，而不是最初分配的 5 字节。因为字符串缓冲区的分配并不大，所以会返回来自其他分配的数据，这些数据可能包括敏感的内存地址，如 VTable 指针和堆分配指针。这个泄露提供了足够的信息来绕过
    ASLR。
- en: '**Exploiting ASLR Implementation Flaws**'
  id: totrans-360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**利用 ASLR 实现漏洞**'
- en: The implementation of ASLR is never perfect due to limitations of performance
    and available memory. These shortcomings lead to various implementation-specific
    flaws, which you can also use to disclose the randomized memory locations.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于性能和可用内存的限制，ASLR 的实现从来都不完美。这些缺陷导致了各种实现特定的漏洞，你也可以利用这些漏洞来泄露随机化的内存位置。
- en: Most commonly, the location of an executable in ASLR isn’t always randomized
    between two separate processes, which would result in a vulnerability that could
    disclose the location of memory from one connection to a networked application,
    even if that might cause that particular process to crash. The memory address
    could then be used in a subsequent exploit.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的情况是，ASLR 中可执行文件的位置并不会在两个不同进程之间完全随机化，这可能导致一种漏洞，泄露网络应用程序连接的内存位置，即使这可能导致该特定进程崩溃。然后，内存地址可以在后续的利用中被使用。
- en: On Unix-like systems, such as Linux, this lack of randomization should only
    occur if the process being exploited is forked from an existing master process.
    When a process forks, the OS creates an identical copy of the original process,
    including all loaded executable code. It’s fairly common for servers, such as
    Apache, to use a forking model to service new connections. A master process will
    listen on a server socket waiting for new connections, and when one is made, a
    new copy of the current process is forked and the connected socket gets passed
    to service the connection.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 Unix 系统中，如 Linux，这种缺乏随机化的情况应该仅发生在被利用的进程是从现有主进程中分叉出来时。当一个进程分叉时，操作系统会创建一个原始进程的相同副本，包括所有加载的可执行代码。服务器（如
    Apache）使用分叉模型来服务新的连接是非常常见的。主进程会监听服务器套接字，等待新的连接，一旦连接建立，当前进程的一个新副本会被分叉，连接的套接字会被传递给新进程来处理连接。
- en: On Windows systems, the flaw manifests in a different way. Windows doesn’t really
    support forking processes, although once a specific executable file load address
    has been randomized, it will always be loaded to that same address until the system
    is rebooted. If this wasn’t done, the OS wouldn’t be able to share read-only memory
    between processes, resulting in increased memory usage.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 系统上，漏洞以不同的方式表现出来。Windows 实际上不支持进程分叉，尽管一旦特定的可执行文件加载地址被随机化，它将始终加载到相同的地址，直到系统重启。如果没有进行此操作，操作系统将无法在进程之间共享只读内存，导致内存使用量增加。
- en: From a security perspective, the result is that if you can leak a location of
    an executable once, the memory locations will stay the same until the system is
    rebooted. You can use this to your advantage because you can leak the location
    from one execution (even if it causes the process to crash) and then use that
    address for the final exploit.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，结果是，如果你能泄露一次可执行文件的位置，那么内存位置将保持不变，直到系统重启。你可以利用这一点，因为你可以从一次执行中泄露位置（即使导致进程崩溃），然后用这个地址进行最终的利用。
- en: '**Bypassing ASLR Using Partial Overwrites**'
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绕过 ASLR 使用部分覆盖**'
- en: Another way to circumvent ASLR is to use *partial overwrites*. Because memory
    tends to be split into distinct pages, such as 4096 bytes, operating systems restrict
    how random layout memory and executable code can load. For example, Windows does
    memory allocations on 64KB boundaries. This leads to an interesting weakness in
    that the lower bits of random memory pointers can be predictable even if the upper
    bits are totally random.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过ASLR的另一种方法是使用*部分覆盖*。因为内存通常被划分为不同的页面，例如4096字节，操作系统限制了内存和可执行代码的随机布局方式。例如，Windows会在64KB边界上进行内存分配。这导致了一个有趣的弱点，即使高位是完全随机的，随机内存指针的低位也可能是可预测的。
- en: The lack of randomization in the lower bits might not sound like much of an
    issue, because you would still need to guess the upper bits of the address if
    you’re overwriting a pointer in memory. Actually, it does allow you to selectively
    overwrite part of the pointer value when running on a little endian architecture
    due to the way that pointer values are stored in memory.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 低位缺乏随机化似乎不是什么大问题，因为如果你在内存中覆盖指针，你仍然需要猜测地址的高位。实际上，这正是它的作用：由于小端架构中指针值的存储方式，它使你能够在运行时选择性地覆盖指针值的一部分。
- en: The majority of processor architectures in use today are little endian (I discussed
    endianness in more detail in “[Binary Endian](../Text/ch03.xhtml#ch00lev1sec57)”
    on [page 41](../Text/ch03.xhtml#page_41)). The most important detail to know about
    little endian for partial overwrites is that the lower bits of a value are stored
    at a lower address. Memory corruptions, such as stack or heap overflows, typically
    write from a low to a high address. Therefore, if you can control the length of
    the overwrite, it would be possible to selectively overwrite only the predictable
    lower bits but not the randomized higher bits. You can then use the partial overwrite
    to convert a pointer to address another memory location, such as a ROP gadget.
    [Figure 10-11](../Text/ch10.xhtml#ch10fig11) shows how to change a memory pointer
    using a partial overwrite.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 当前大多数处理器架构使用的是小端（我在“[二进制字节序](../Text/ch03.xhtml#ch00lev1sec57)”中详细讨论了字节序问题，见[第41页](../Text/ch03.xhtml#page_41)）。对于部分覆盖来说，了解小端最重要的一点是，值的低位存储在较低的地址中。内存损坏，比如栈或堆溢出，通常是从低地址写到高地址。因此，如果你能够控制覆盖的长度，就有可能选择性地只覆盖可预测的低位，而不覆盖随机的高位。然后，你可以利用部分覆盖将指针转换为指向另一个内存位置，比如ROP小工具。[图10-11](../Text/ch10.xhtml#ch10fig11)展示了如何使用部分覆盖改变内存指针。
- en: '![image](../Images/f10-11.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f10-11.jpg)'
- en: '*Figure 10-11: An example of a short overwrite*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-11：一个短覆盖的例子*'
- en: We start with an address of 0x07060504\. We know that, due to ASLR, the top
    16 bits (the 0x0706 part) are randomized, but the lower 16 bits are not. If we
    know what memory the pointer is referencing, we can selectively change the lower
    bits and accurately specify a location to control. In this example, we overwrite
    the lower 16 bits to make a new address of 0x0706BBAA.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从地址0x07060504开始。我们知道，由于ASLR，地址的高16位（0x0706部分）是随机的，但低16位不是。如果我们知道指针引用的内存位置，我们可以选择性地更改低位，并准确指定一个可控的位置。在这个例子中，我们覆盖了低16位，将地址改为0x0706BBAA。
- en: '***Detecting Stack Overflows with Memory Canaries***'
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用内存金丝雀检测栈溢出***'
- en: Memory *canaries*, or *cookies*, are used to prevent exploitation of a memory
    corruption vulnerability by detecting the corruption and immediately causing the
    application to terminate. You’ll most commonly encounter them in reference to
    stack memory corruption prevention, but canaries are also used to protect other
    types of data structures, such as heap headers or virtual table pointers.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 内存*金丝雀*，或称*饼干*，用于通过检测内存损坏并立即使应用程序终止，从而防止内存损坏漏洞的利用。你最常见到它们用于栈内存损坏防护，但金丝雀也可以用于保护其他类型的数据结构，例如堆头或虚拟表指针。
- en: A memory canary is a random number generated by an application during startup.
    The random number is stored in a global memory location so it can be accessed
    by all code in the application. This random number is pushed onto the stack when
    entering a function. Then, when the function is exited, the random value is popped
    off the stack and compared to the global value. If the global value doesn’t match
    what was popped off the stack, the application assumes the stack memory has been
    corrupted and terminates the process as quickly as possible. [Figure 10-12](../Text/ch10.xhtml#ch10fig12)
    shows how inserting this random number detects danger, like a canary in a coal
    mine, helping to prevent the attacker from gaining access to the return address.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 内存金丝雀是应用程序在启动时生成的一个随机数。这个随机数存储在全局内存位置，以便应用程序中的所有代码都可以访问。这个随机数在进入函数时被推送到栈上。然后，当函数退出时，随机值会从栈上弹出，并与全局值进行比较。如果全局值与栈上弹出的值不匹配，应用程序会认为栈内存已被破坏，并尽快终止进程。[图
    10-12](../Text/ch10.xhtml#ch10fig12)显示了如何通过插入这个随机数来检测危险，像矿井中的金丝雀一样，帮助防止攻击者获取返回地址。
- en: '![image](../Images/f10-12.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f10-12.jpg)'
- en: '*Figure 10-12: A stack overflow with a stack canary*'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-12: 带栈金丝雀的栈溢出*'
- en: Placing the canary below the return address on the stack ensures that any overflow
    corruption that would modify the return address would also modify the canary.
    As long as the canary value is difficult to guess, the attacker can’t gain control
    over the return address. Before the function returns, it calls code to check whether
    the stack canary matches what it expects. If there’s a mismatch, the program immediately
    crashes.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 将金丝雀放在栈上返回地址的下方，确保任何修改返回地址的溢出破坏也会修改金丝雀。只要金丝雀值难以猜测，攻击者就无法控制返回地址。在函数返回之前，代码会检查栈金丝雀是否与预期的值匹配。如果不匹配，程序会立即崩溃。
- en: '**Bypassing Canaries by Corrupting Local Variables**'
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通过破坏局部变量绕过金丝雀保护**'
- en: Typically, stack canaries protect only the return address of the currently executing
    function on the stack. However, there are more things on the stack that can be
    exploited than just the buffer that’s being overflowed. There might be pointers
    to functions, pointers to class objects that have a virtual function table, or,
    in some cases, an integer variable that can be overwritten that might be enough
    to exploit the stack overflow.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，栈金丝雀仅保护当前执行函数的返回地址。然而，栈上有比正在溢出的缓冲区更多的内容可以被利用。可能存在指向函数的指针、指向具有虚函数表的类对象的指针，或者在某些情况下，可能存在可以被覆盖的整数变量，而这些也足以利用栈溢出。
- en: If the stack buffer overflow has a controlled length, it might be possible to
    overwrite these variables without ever corrupting the stack canary. Even if the
    canary is corrupted, it might not matter as long as the variable is used before
    the canary is checked. [Figure 10-13](../Text/ch10.xhtml#ch10fig13) shows how
    attackers might corrupt local variables without affecting the canary.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果栈缓冲区溢出具有可控的长度，那么可能在不破坏栈金丝雀的情况下覆盖这些变量。即使金丝雀被破坏，只要变量在金丝雀检查之前被使用，也可能不受影响。[图 10-13](../Text/ch10.xhtml#ch10fig13)展示了攻击者如何在不影响金丝雀的情况下破坏局部变量。
- en: In this example, we have a function with a function pointer on the stack. Due
    to how the stack memory is laid out, the buffer we’ll overflow is at a lower address
    than the function pointer `f`, which is also located on the stack ➊.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有一个栈上带有函数指针的函数。由于栈内存的布局，我们将溢出的缓冲区位于低地址处，而函数指针`f`也位于栈上 ➊。
- en: When the overflow executes, it corrupts all memory above the buffer, including
    the return address and the stack canary ➋. However, before the canary checking
    code runs (which would terminate the process), the function pointer `f` is used.
    This means we still get code execution ➌ by calling through `f`, and the corruption
    is never detected.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当溢出执行时，它会破坏缓冲区上方的所有内存，包括返回地址和栈金丝雀 ➋。然而，在金丝雀检查代码运行（会终止进程）之前，函数指针`f`会被使用。这意味着我们仍然可以通过调用`f`来执行代码
    ➌，而破坏永远不会被检测到。
- en: '![image](../Images/f10-13.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f10-13.jpg)'
- en: '*Figure 10-13: Corrupting local variables without setting off the stack canary*'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-13: 破坏局部变量而不触发栈金丝雀*'
- en: There are many ways in which modern compilers can protect against corrupting
    local variables, including reordering variables so buffers are always above any
    single variable, which when corrupted, could be used to exploit the vulnerability.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现代编译器有很多方法可以防止破坏局部变量，包括重新排列变量，使得缓冲区总是在任何单一变量之上，而当变量被破坏时，可能会被用来利用漏洞。
- en: '**Bypassing Canaries with Stack Buffer Underflow**'
  id: totrans-387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绕过堆栈缓冲区下溢的防护**'
- en: 'For performance reasons, not every function will place a canary on the stack.
    If the function doesn’t manipulate a memory buffer on the stack, the compiler
    might consider it safe and not emit the instructions necessary to add the canary.
    In most cases, this is the correct thing to do. However, some vulnerabilities
    overflow a stack buffer in unusual ways: for example, the vulnerability might
    cause an underflow instead of an overflow, corrupting data lower in the stack.
    [Figure 10-14](../Text/ch10.xhtml#ch10fig14) shows an example of this kind of
    vulnerability.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 出于性能原因，并不是每个函数都会在堆栈上放置一个“看门狗”变量（canary）。如果函数没有操作堆栈上的内存缓冲区，编译器可能认为它是安全的，并且不会生成必要的指令来添加看门狗变量。在大多数情况下，这是正确的做法。然而，一些漏洞以非常规的方式溢出堆栈缓冲区：例如，漏洞可能导致下溢，而不是溢出，破坏堆栈下方的数据。[图
    10-14](../Text/ch10.xhtml#ch10fig14)展示了这种类型漏洞的一个示例。
- en: '[Figure 10-14](../Text/ch10.xhtml#ch10fig14) illustrates three steps. First,
    the function `DoSomething()` is called ➊. This function sets up a buffer on the
    stack. The compiler determines that this buffer needs to be protected, so it generates
    a stack canary to prevent an overflow from overwriting the return address of `DoSomething()`.
    Second, the function calls the `Process()` method, passing a pointer to the buffer
    it set up. This is where the memory corruption occurs. However, instead of overflowing
    the buffer, `Process()` writes to a value below, for example, by referencing `p[-1]`
    ➋. This results in corruption of the return address of the `Process()` method’s
    stack frame that has stack canary protection. Third, `Process()` returns to the
    corrupted return address, resulting in shell code execution ➌.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-14](../Text/ch10.xhtml#ch10fig14)展示了三个步骤。首先，调用`DoSomething()`函数 ➊。此函数在堆栈上设置一个缓冲区。编译器确定该缓冲区需要保护，因此它生成一个堆栈看门狗变量，以防止溢出覆盖`DoSomething()`的返回地址。其次，函数调用`Process()`方法，传递一个指向已设置缓冲区的指针。此时发生内存破坏。然而，`Process()`并没有溢出缓冲区，而是写入一个较低的值，例如通过引用`p[-1]`
    ➋。这导致了`Process()`方法的堆栈帧中返回地址的破坏，而该堆栈帧已经有堆栈看门狗变量的保护。第三，`Process()`返回到被破坏的返回地址，导致执行恶意代码
    ➌。'
- en: '![image](../Images/f10-14.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f10-14.jpg)'
- en: '*Figure 10-14: Stack buffer underflow*'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-14：堆栈缓冲区下溢*'
- en: '**Final Words**'
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**最后的总结**'
- en: Finding and exploiting vulnerabilities in a network application can be difficult,
    but this chapter introduced some techniques you can use. I described how to triage
    vulnerabilities to determine the root cause using a debugger; with the knowledge
    of the root cause, you can proceed to exploit the vulnerability. I also provided
    examples of writing simple shell code and then developing a payload using ROP
    to bypass a common exploit mitigation DEP. Finally, I described some other common
    exploit mitigations on modern operating systems, such as ASLR and memory canaries,
    and the techniques to circumvent these mitigations.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用中发现并利用漏洞可能很困难，但本章介绍了一些你可以使用的技术。我描述了如何使用调试器对漏洞进行分类，以确定根本原因；掌握根本原因后，你可以继续利用这个漏洞。我还提供了编写简单的恶意代码并使用ROP（返回导向编程）开发有效载荷，绕过常见的漏洞缓解技术DEP（数据执行保护）的示例。最后，我描述了一些现代操作系统中常见的漏洞缓解技术，如ASLR（地址空间布局随机化）和内存看门狗，以及绕过这些缓解措施的技术。
- en: This is the final chapter in this book. At this point you should be armed with
    the knowledge of how to capture, analyze, reverse engineer, and exploit networked
    applications. The best way to improve your skills is to find as many network applications
    and protocols as you can. With experience, you’ll easily spot common structures
    and identify patterns of protocol behavior where security vulnerabilities are
    typically found.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的最后一章就在这里。在这一点上，你应该已经掌握了如何捕捉、分析、逆向工程和利用网络应用程序的知识。提高技能的最佳方法是尽可能多地找到网络应用和协议。通过经验，你会轻松识别常见结构，并找出协议行为中常见的安全漏洞模式。
