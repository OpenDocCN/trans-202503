["```\n#include <sys/stat.h>\n\nint `stat`(const char **pathname*, struct stat **statbuf*);\nint `lstat`(const char **pathname*, struct stat **statbuf*);\nint `fstat`(int *fd*, struct stat **statbuf*);\n```", "```\nstruct stat {\n    dev_t     st_dev;         /* IDs of device on which file resides */\n    ino_t     st_ino;         /* I-node number of file */\n    mode_t    st_mode;        /* File type and permissions */\n    nlink_t   st_nlink;       /* Number of (hard) links to file */\n    uid_t     st_uid;         /* User ID of file owner */\n    gid_t     st_gid;         /* Group ID of file owner */\n    dev_t     st_rdev;        /* IDs for device special files */\n    off_t     st_size;        /* Total file size (bytes) */\n    blksize_t st_blksize;     /* Optimal block size for I/O (bytes) */\n    blkcnt_t  st_blocks;      /* Number of (512B) blocks allocated */\n    time_t    st_atime;       /* Time of last file access */\n    time_t    st_mtime;       /* Time of last file modification */\n    time_t    st_ctime;       /* Time of last status change */\n};\n```", "```\nif ((statbuf.st_mode & S_IFMT) == S_IFREG)\n    printf(\"regular file\\n\");\n```", "```\nif (S_ISREG(statbuf.st_mode))\n    printf(\"regular file\\n\");\n```", "```\n$ `echo 'All operating systems provide services for programs they run' > apue`\n$ `chmod g+s apue`        *Turn on set-group-ID bit; affects last status change time*\n$ `cat apue`              *Affects last file access time*\nAll operating systems provide services for programs they run\n$ `./t_stat apue`\nFile type:                regular file\nDevice containing i-node: major=3   minor=11\nI-node number:            234363\nMode:                     102644 (rw-r--r--)\n    special bits set:     set-GID\nNumber of (hard) links:   1\nOwnership:                UID=1000   GID=100\nFile size:                61 bytes\nOptimal I/O block size:   4096 bytes\n512B blocks allocated:    8\nLast file access:         Mon Jun  8 09:40:07 2011\nLast file modification:   Mon Jun  8 09:39:25 2011\nLast status change:       Mon Jun  8 09:39:51 2011\n```", "```\n`files/t_stat.c`\n#define _BSD_SOURCE     /* Get major() and minor() from <sys/types.h> */\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <time.h>\n#include \"file_perms.h\"\n#include \"tlpi_hdr.h\"\n\nstatic void\ndisplayStatInfo(const struct stat *sb)\n{\n    printf(\"File type:                \");\n\n    switch (sb->st_mode & S_IFMT) {\n    case S_IFREG:  printf(\"regular file\\n\");            break;\n    case S_IFDIR:  printf(\"directory\\n\");               break;\n    case S_IFCHR:  printf(\"character device\\n\");        break;\n    case S_IFBLK:  printf(\"block device\\n\");            break;\n    case S_IFLNK:  printf(\"symbolic (soft) link\\n\");    break;\n    case S_IFIFO:  printf(\"FIFO or pipe\\n\");            break;\n    case S_IFSOCK: printf(\"socket\\n\");                  break;\n    default:       printf(\"unknown file type?\\n\");      break;\n    }\n\n    printf(\"Device containing i-node: major=%ld   minor=%ld\\n\",\n                (long) major(sb->st_dev), (long) minor(sb->st_dev));\n\n    printf(\"I-node number:            %ld\\n\", (long) sb->st_ino);\n\n    printf(\"Mode:                     %lo (%s)\\n\",\n            (unsigned long) sb->st_mode, filePermStr(sb->st_mode, 0));\n\n    if (sb->st_mode & (S_ISUID | S_ISGID | S_ISVTX))\n        printf(\"    special bits set:     %s%s%s\\n\",\n                (sb->st_mode & S_ISUID) ? \"set-UID \" : \"\",\n                (sb->st_mode & S_ISGID) ? \"set-GID \" : \"\",\n                (sb->st_mode & S_ISVTX) ? \"sticky \" : \"\");\n\n    printf(\"Number of (hard) links:   %ld\\n\", (long) sb->st_nlink);\n\n    printf(\"Ownership:                UID=%ld   GID=%ld\\n\",\n            (long) sb->st_uid, (long) sb->st_gid);\n\n    if (S_ISCHR(sb->st_mode) || S_ISBLK(sb->st_mode))\n        printf(\"Device number (st_rdev):  major=%ld; minor=%ld\\n\",\n                (long) major(sb->st_rdev), (long) minor(sb->st_rdev));\n\n    printf(\"File size:                %lld bytes\\n\", (long long) sb->st_size);\n    printf(\"Optimal I/O block size:   %ld bytes\\n\", (long) sb->st_blksize);\n    printf(\"512B blocks allocated:    %lld\\n\", (long long) sb->st_blocks);\n\n    printf(\"Last file access:         %s\", ctime(&sb->st_atime));\n    printf(\"Last file modification:   %s\", ctime(&sb->st_mtime));\n    printf(\"Last status change:       %s\", ctime(&sb->st_ctime));\n}\n\nint\nmain(int argc, char *argv[])\n{\n    struct stat sb;\n    Boolean statLink;           /* True if \"-l\" specified (i.e., use lstat) */\n    int fname;                  /* Location of filename argument in argv[] */\n\n    statLink = (argc > 1) && strcmp(argv[1], \"-l\") == 0;\n                                /* Simple parsing for \"-l\" */\n    fname = statLink ? 2 : 1;\n\n    if (fname >= argc || (argc > 1 && strcmp(argv[1], \"--help\") == 0))\n        usageErr(\"%s [-l] file\\n\"\n                \"        -l = use lstat() instead of stat()\\n\", argv[0]);\n\n    if (statLink) {\n        if (lstat(argv[fname], &sb) == -1)\n            errExit(\"lstat\");\n    } else {\n        if (stat(argv[fname], &sb) == -1)\n            errExit(\"stat\");\n    }\n\n    displayStatInfo(&sb);\n\n    exit(EXIT_SUCCESS);\n}\n      `files/t_stat.c`\n```", "```\n#include <utime.h>\n\nint `utime`(const char **pathname*, const struct utimbuf **buf*);\n```", "```\nstruct utimbuf {\n    time_t actime;      /* Access time */\n    time_t modtime;     /* Modification time */\n};\n```", "```\nstruct stat sb;\nstruct utimbuf utb;\n\nif (stat(pathname, &sb) == -1)\n    errExit(\"stat\");\nutb.actime = sb.st_atime;       /* Leave access time unchanged */\nutb.modtime = sb.st_atime;\nif (utime(pathname, &utb) == -1)\n    errExit(\"utime\");\n```", "```\n#include <sys/time.h>\n\nint `utimes`(const char **pathname*, const struct timeval *tv[2]*);\n```", "```\n#include <sys/time.h>\n\nint `futimes`(int *fd*, const struct timeval *tv[2]*);\nint `lutimes`(const char **pathname*, const struct timeval *tv[2]*);\n```", "```\n#define _XOPEN_SOURCE 700     /* Or define _POSIX_C_SOURCE >= 200809 */\n#include <sys/stat.h>\n\nint `utimensat`(int *dirfd*, const char **pathname*,\n              const struct timespec *times[2]*, int *flags*);\n```", "```\nstruct timespec {\n    time_t tv_sec;     /* Seconds ('time_t' is an integer type) */\n    long   tv_nsec;    /* Nanoseconds */\n};\n```", "```\nstruct timespec times[2];\n\ntimes[0].tv_sec = 0;\ntimes[0].tv_nsec = UTIME_NOW;\ntimes[1].tv_sec = 0;\ntimes[1].tv_nsec = UTIME_OMIT;\nif (utimensat(AT_FDCWD, \"myfile\", times, 0) == -1)\n    errExit(\"utimensat\");\n```", "```\n#include _GNU_SOURCE\n#include <sys/stat.h>\n\nint `futimens`(int *fd*, const struct timespec *times[2]*);\n```", "```\n#include <unistd.h>\n\nint `chown`(const char **pathname*, uid_t *owner*, gid_t *group*);\nint `lchown`(const char **pathname*, uid_t *owner*, gid_t *group*);\nint `fchown`(int *fd*, uid_t *owner*, gid_t *group*);\n```", "```\n`files/t_chown.c`\n#include <pwd.h>\n#include <grp.h>\n#include \"ugid_functions.h\"             /* Declarations of userIdFromName()\n                                           and groupIdFromName() */\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    uid_t uid;\n    gid_t gid;\n    int j;\n    Boolean errFnd;\n\n    if (argc < 3 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s owner group [file...]\\n\"\n                \"        owner or group can be '-', \"\n                \"meaning leave unchanged\\n\", argv[0]);\n\n    if (strcmp(argv[1], \"-\") == 0) {            /* \"-\" ==> don't change owner */\n        uid = -1;\n    } else {                                    /* Turn user name into UID */\n        uid = userIdFromName(argv[1]);\n        if (uid == -1)\n            fatal(\"No such user (%s)\", argv[1]);\n    }\n\n    if (strcmp(argv[2], \"-\") == 0) {            /* \"-\" ==> don't change group */\n        gid = -1;\n    } else {                                    /* Turn group name into GID */\n        gid = groupIdFromName(argv[2]);\n        if (gid == -1)\n            fatal(\"No group user (%s)\", argv[1]);\n    }\n\n    /* Change ownership of all files named in remaining arguments */\n\n    errFnd = FALSE;\n    for (j = 3; j < argc; j++) {\n        if (chown(argv[j], uid, gid) == -1) {\n            errMsg(\"chown: %s\", argv[j]);\n            errFnd = TRUE;\n        }\n    }\n\n    exit(errFnd ? EXIT_FAILURE : EXIT_SUCCESS);\n}\n     `files/t_chown.c`\n```", "```\n$ `ls -l myscript.sh`\n-`rwxr-x---`    1 mtk      users        1667 Jan 15 09:22 myscript.sh\n```", "```\n`files/file_perms.h`\n#ifndef FILE_PERMS_H\n#define FILE_PERMS_H\n\n#include <sys/types.h>\n\n#define FP_SPECIAL 1            /* Include set-user-ID, set-group-ID, and sticky\n                                   bit information in returned string */\n\nchar *filePermStr(mode_t perm, int flags);\n\n#endif\n      `files/file_perms.h`\n```", "```\n`files/file_perms.c`\n#include <sys/stat.h>\n#include <stdio.h>\n#include \"file_perms.h\"                 /* Interface for this implementation */\n\n#define STR_SIZE sizeof(\"rwxrwxrwx\")\n\nchar *          /* Return ls(1)-style string for file permissions mask */\nfilePermStr(mode_t perm, int flags)\n{\n    static char str[STR_SIZE];\n\n    snprintf(str, STR_SIZE, \"%c%c%c%c%c%c%c%c%c\",\n        (perm & S_IRUSR) ? 'r' : '-', (perm & S_IWUSR) ? 'w' : '-',\n        (perm & S_IXUSR) ?\n            (((perm & S_ISUID) && (flags & FP_SPECIAL)) ? 's' : 'x') :\n            (((perm & S_ISUID) && (flags & FP_SPECIAL)) ? 'S' : '-'),\n        (perm & S_IRGRP) ? 'r' : '-', (perm & S_IWGRP) ? 'w' : '-',\n        (perm & S_IXGRP) ?\n            (((perm & S_ISGID) && (flags & FP_SPECIAL)) ? 's' : 'x') :\n            (((perm & S_ISGID) && (flags & FP_SPECIAL)) ? 'S' : '-'),\n        (perm & S_IROTH) ? 'r' : '-', (perm & S_IWOTH) ? 'w' : '-',\n        (perm & S_IXOTH) ?\n            (((perm & S_ISVTX) && (flags & FP_SPECIAL)) ? 't' : 'x') :\n            (((perm & S_ISVTX) && (flags & FP_SPECIAL)) ? 'T' : '-'));\n\n    return str;\n}\n      `files/file_perms.c`\n```", "```\n$ `echo 'Hello world' > a.txt`\n$ `ls -l a.txt`\n-rw-r--r--   1 mtk    users    12 Jun 18 12:26 a.txt\n$ `chmod u-rw a.txt`               *Remove read and write permission from owner*\n$ `ls -l a.txt`\n----r--r--   1 mtk    users    12 Jun 18 12:26 a.txt\n$ `cat a.txt`\ncat: a.txt: Permission denied    *Owner can no longer read file*\n$ `su avr`                         *Become someone else...*\nPassword:\n$ `groups`                         *who is in the group owning the file...*\nusers staff teach cs\n$ `cat a.txt`                      *and thus can read the file*\nHello world\n```", "```\n#include <unistd.h>\n\nint `access`(const char **pathname*, int *mode*);\n```", "```\n$ `touch tfile`\n$ `ls -l tfile`\n-rw-r--r--   1 mtk    users     0 Jun 23 14:44 tfile\n$ `chmod +t tfile`\n$ `ls -l tfile`\n-rw-r--r-T   1 mtk    users     0 Jun 23 14:44 tfile\n$ `chmod o+x tfile`\n$ `ls -l tfile`\n-rw-r--r-t   1 mtk    users     0 Jun 23 14:44 tfile\n```", "```\n#include <sys/stat.h>\n\nmode_t `umask`(mode_t *mask*);\n```", "```\n$ `./t_umask`\nRequested file perms: rw-rw----             *This is what we asked for*\nProcess umask:        ----wx-wx             *This is what we are denied*\nActual file perms:    rw-r-----             *So this is what we end up with*\n\nRequested dir. perms: rwxrwxrwx\nProcess umask:        ----wx-wx\nActual dir. perms:    rwxr--r--\n```", "```\n`files/t_umask.c`\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"file_perms.h\"\n#include \"tlpi_hdr.h\"\n\n#define MYFILE \"myfile\"\n#define MYDIR  \"mydir\"\n#define FILE_PERMS    (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP)\n#define DIR_PERMS     (S_IRWXU | S_IRWXG | S_IRWXO)\n#define UMASK_SETTING (S_IWGRP | S_IXGRP | S_IWOTH | S_IXOTH)\n\nint\nmain(int argc, char *argv[])\n{\n    int fd;\n    struct stat sb;\n    mode_t u;\n\n    umask(UMASK_SETTING);\n\n    fd = open(MYFILE, O_RDWR | O_CREAT | O_EXCL, FILE_PERMS);\n    if (fd == -1)\n        errExit(\"open-%s\", MYFILE);\n    if (mkdir(MYDIR, DIR_PERMS) == -1)\n        errExit(\"mkdir-%s\", MYDIR);\n\n    u = umask(0);               /* Retrieves (and clears) umask value */\n\n    if (stat(MYFILE, &sb) == -1)\n        errExit(\"stat-%s\", MYFILE);\n    printf(\"Requested file perms: %s\\n\", filePermStr(FILE_PERMS, 0));\n    printf(\"Process umask:        %s\\n\", filePermStr(u, 0));\n    printf(\"Actual file perms:    %s\\n\\n\", filePermStr(sb.st_mode, 0));\n\n    if (stat(MYDIR, &sb) == -1)\n        errExit(\"stat-%s\", MYDIR);\n    printf(\"Requested dir. perms: %s\\n\", filePermStr(DIR_PERMS, 0));\n    printf(\"Process umask:        %s\\n\", filePermStr(u, 0));\n    printf(\"Actual dir. perms:    %s\\n\", filePermStr(sb.st_mode, 0));\n\n    if (unlink(MYFILE) == -1)\n        errMsg(\"unlink-%s\", MYFILE);\n    if (rmdir(MYDIR) == -1)\n        errMsg(\"rmdir-%s\", MYDIR);\n    exit(EXIT_SUCCESS);\n}\n     `files/t_umask.c`\n```", "```\n#include <sys/stat.h>\n\nint `chmod`(const char **pathname*, mode_t *mode*);\nint `fchmod`(int *fd*, mode_t *mode*);\n```", "```\nif (chmod(\"myfile\", S_IRUSR | S_IRGRP | S_IROTH) == -1)\n    errExit(\"chmod\");\n/* Or equivalently: chmod(\"myfile\", 0444); */\n```", "```\nstruct stat sb;\nmode_t mode;\n\nif (stat(\"myfile\", &sb) == -1)\n    errExit(\"stat\");\nmode = (sb.st_mode | S_IWUSR) & ~S_IROTH;\n       /* owner-write on, other-read off, remaining bits unchanged */\nif (chmod(\"myfile\", mode) == -1)\n    errExit(\"chmod\");\n```", "```\n$ `chmod u+w,o-r myfile`\n```", "```\n$ `mount | grep test`                *Hmmm,* /test *is mounted with -o bsdgroups*\n/dev/sda9 on /test type ext3 (rw,bsdgroups)\n$ `ls -ld /test`                     *Directory has GID root, writable by anyone*\ndrwxrwxrwx   3 root   root    4096 Jun 30 20:11 /test\n$ `id`                               *I'm an ordinary user, not part of root group*\nuid=1000(mtk) gid=100(users) groups=100(users),101(staff),104(teach)\n$ `cd /test`\n$ `cp ~/myprog .`                    *Copy some mischievous program here*\n$ `ls -l myprog`                     *Hey! It's in the root group!*\n-rwxr-xr-x   1 mtk    root   19684 Jun 30 20:43 myprog\n$ `chmod g+s myprog`                 *Can I make it set-group-ID to root?*\n$ `ls -l myprog`                     *Hmm, no...*\n-rwxr-xr-x   1 mtk    root   19684 Jun 30 20:43 myprog\n```", "```\n$ `lsattr myfile`\n-------- myfile\n$ `chattr +ai myfile`               *Turn on Append Only and Immutable flags*\n$ `lsattr myfile`\n----ia-- myfile\n```", "```\nint attr;\n\nif (ioctl(fd, FS_IOC_GETFLAGS, &attr) == -1)    /* Fetch current flags */\n    errExit(\"ioctl\");\nattr |= FS_NOATIME_FL;\nif (ioctl(fd, FS_IOC_SETFLAGS, &attr) == -1)    /* Update flags */\n    errExit(\"ioctl\");\n```", "```\n    $ `ls -ld dir file prog`\n    dr--------  2 mtk users    48 May  4 12:28 dir\n    -r--------  1 mtk users 19794 May  4 12:22 file\n    -r-x------  1 mtk users 19336 May  4 12:21 prog\n    $ `chmod a+rX dir file prog`\n    $ `ls -ld dir file prog`\n    dr-xr-xr-x  2 mtk users    48 May  4 12:28 dir\n    -r--r--r--  1 mtk users 19794 May  4 12:22 file\n    -r-xr-xr-x  1 mtk users 19336 May  4 12:21 prog\n    ```"]