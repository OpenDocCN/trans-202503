- en: '**INTRODUCTION**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What do we mean by *great code*? Different programmers will have different
    opinions. Therefore, it is impossible to provide an all-encompassing definition
    that will satisfy everyone. Here is the definition this book will use:'
  prefs: []
  type: TYPE_NORMAL
- en: Great code is software that is written using a consistent and prioritized set
    of good software characteristics. In particular, great code follows a set of rules
    that guide the decisions a programmer makes when implementing an algorithm as
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as I noted in *Write Great Code, Volume 1: Understanding the Machine*
    (hereafter, *WGC1*), there are some attributes of great code that nearly everyone
    can agree on. Specifically, great code:'
  prefs: []
  type: TYPE_NORMAL
- en: Uses the CPU efficiently (that is, it’s fast)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses memory efficiently (that is, it’s small)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses system resources efficiently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is easy to read and maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follows a consistent set of style guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses an explicit design that follows established software engineering conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is easy to enhance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is well tested and robust (that is, it works)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is well documented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could easily add dozens of items to this list. Some programmers, for example,
    may feel that great code must be portable, must follow a given set of programming
    style guidelines, or must be written in a certain language (or *not* be written
    in a certain language). Some may feel that great code must be written as simply
    as possible, while others believe that it must be written quickly. Still others
    may feel that great code is created on time and under budget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that there are so many aspects of great code—too many to describe properly
    in a single book—this second volume of the *Write Great Code* series concentrates
    primarily on one: efficient performance. Although efficiency might not always
    be the primary goal of a software development effort—nor does it have to be for
    code to qualify as great—people generally agree that inefficient code is *not*
    great code. And inefficiency is one of the major problems with modern applications,
    so it’s an important topic to emphasize.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance Characteristics of Great Code**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As computer system performance has increased from megahertz to hundreds of megahertz
    to gigahertz, computer software performance has taken a back seat to other concerns.
    Today, it’s not at all uncommon for software engineers to exclaim, “You should
    never optimize your code!” Funny, you don’t hear too many software *users* making
    such statements.
  prefs: []
  type: TYPE_NORMAL
- en: Although this book describes how to write efficient code, it’s not a book about
    optimization. *Optimization* is a phase near the end of the Software Development
    Life Cycle (SDLC) in which software engineers determine why their code does not
    meet performance specifications and then refine it accordingly. But unfortunately,
    if they don’t put any thought into the application’s performance until the optimization
    phase, it’s unlikely that optimization will prove practical. The time to ensure
    that an application meets reasonable performance benchmarks is at the *beginning*
    of the SDLC, during the design and implementation phases. Optimization can fine-tune
    a system’s performance, but it can rarely deliver a miracle.
  prefs: []
  type: TYPE_NORMAL
- en: Although the quote is often attributed to Donald Knuth, who popularized it,
    it was Tony Hoare who originally said, “Premature optimization is the root of
    all evil.” This statement has long been the rallying cry of software engineers
    who neglect application performance until the very end of the SDLC—at which point
    optimization is typically ignored for economic or time-to-market reasons. However,
    Hoare did not say, “Concern about application performance during the early stages
    of an application’s development is the root of all evil.” He specifically said
    *premature optimization*, which, back then, meant counting cycles and instructions
    in assembly language code—not the type of coding you want to do during initial
    program design, when the code base is fluid. Thus, Hoare’s comments were on the
    mark.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following excerpt from a short essay by Charles Cook (*[https://bit.ly/38NhZkT](https://bit.ly/38NhZkT)*)
    further describes the problem with reading too much into Hoare’s statement:'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve always thought this quote has all too often led software designers into
    serious mistakes because it has been applied to a different problem domain to
    what was intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full version of the quote is “We should forget about small efficiencies,
    say about 97% of the time: premature optimization is the root of all evil.” and
    I agree with this. It’s usually not worth spending a lot of time micro-optimizing
    code before it’s obvious where the performance bottlenecks are. But, conversely,
    when designing software at a system level, performance issues should always be
    considered from the beginning. A good software developer will do this automatically,
    having developed a feel for where performance issues will cause problems. An inexperienced
    developer will not bother, misguidedly believing that a bit of fine tuning at
    a later stage will fix any problems.'
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, Hoare was saying that software engineers should worry about other issues,
    like good algorithm design and implementation, before they worry about traditional
    optimizations, like how many CPU cycles a particular statement requires for execution.
  prefs: []
  type: TYPE_NORMAL
- en: Although you could certainly apply many of this book’s concepts during an optimization
    phase, most of the techniques here really need to be applied during the initial
    coding. An experienced software engineer may argue that doing so produces only
    minor improvements in performance. In some cases, this is true—but keep in mind
    that these minor effects accumulate. If you put off these ideas until you reach
    “code complete,” it’s unlikely that they’ll ever find their way into your software.
    It’s just too much work to implement them after the fact (and too risky to make
    such changes to otherwise working code).
  prefs: []
  type: TYPE_NORMAL
- en: '**The Goal of This Book**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This book (and *WGC1*) attempts to fill the gaps in the education of the current
    generation of programmers so they can write quality code. In particular, it covers
    the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Why it’s important to consider the low-level execution of your high-level programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How compilers generate machine code from high-level language (HLL) statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How compilers represent various data types using low-level, primitive data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write your HLL code to help the compiler produce better machine code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to take advantage of a compiler’s optimization facilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to “think” in assembly language (low-level terms) while writing HLL code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This book will teach you how to choose appropriate HLL statements that translate
    into efficient machine code with a modern optimizing compiler. In most cases,
    different HLL statements provide many ways to achieve a given result, some of
    which, at the machine level, are naturally more efficient than others. Though
    there may be a very good reason for choosing a less efficient statement sequence
    over a more efficient one (for example, readability), the truth is that most software
    engineers have no idea about HLL statement runtime costs and thus are unable to
    make an educated choice. The goal of this book is to change that.
  prefs: []
  type: TYPE_NORMAL
- en: Again, this book is not about choosing the most efficient statement sequence
    no matter what. It is about understanding the cost of various HLL constructs so
    that, when faced with multiple options, you can make an informed decision about
    which sequence is most appropriate to use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter Organization**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Though you don’t need to be an expert assembly language programmer in order
    to write efficient code, you’ll need at least a basic knowledge of it to understand
    the compiler output in this book. [Chapters 1](ch01.xhtml#ch01) and [2](ch02.xhtml#ch02)
    discuss several aspects of learning assembly language, covering common misconceptions,
    considerations around compilers, and available resources. [Chapter 3](ch03.xhtml#ch03)
    provides a quick primer for 80x86 assembly language. Online appendixes (*[http://www.randallhyde.com/](http://www.randallhyde.com/)*)
    provide primers for the PowerPC, ARM, Java bytecode, and Common Intermediate Language
    (CIL) assembly languages.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapters 4](ch04.xhtml#ch04) and [5](ch05.xhtml#ch05), you’ll learn about
    determining the quality of your HLL statements by examining compiler output. These
    chapters describe disassemblers, object code dump tools, debuggers, various HLL
    compiler options for displaying assembly language code, and other useful software
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the book, [Chapters 6](ch06.xhtml#ch06) through [15](ch15.xhtml#ch15),
    describes how compilers generate machine code for different HLL statements and
    data types. Armed with this knowledge, you’ll be able to choose the most appropriate
    data types, constants, variables, and control structures to produce efficient
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Assumptions and Prerequisites**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This book was written with certain assumptions about your prior knowledge.
    You’ll reap the greatest benefit from this material if your personal skill set
    matches the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You should be reasonably competent in at least one imperative (procedural) or
    object-oriented programming language. This includes C and C++, Pascal, Java, Swift,
    BASIC, Python, and assembly, as well as languages like Ada, Modula-2, and FORTRAN.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should be capable of taking a small problem description and working through
    the design and implementation of a software solution for that problem. A typical
    semester or quarter course at a college or university (or several months of experience
    on your own) should be sufficient preparation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should have a basic grasp of machine organization and data representation.
    You should know about the hexadecimal and binary numbering systems. You should
    understand how computers represent various high-level data types such as signed
    integers, characters, and strings in memory. Although the next couple of chapters
    provide a primer on machine language, it would help considerably if you’ve picked
    up this information along the way. *WGC1* fully covers the subject of machine
    organization if you feel your knowledge in this area is a little weak.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Environment for This Book**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although this book presents generic information, parts of the discussion will
    necessarily be system specific. Because the Intel Architecture PCs are, by far,
    the most common in use today, that’s the platform I’ll use when discussing specific
    system-dependent concepts in this book. However, those concepts still apply to
    other systems and CPUs—such as the PowerPC CPU in the older Power Macintosh systems,
    ARM CPUs in mobile phones, tablets and single-board computers (SBCs; like the
    Raspberry Pi or higher-end Arduino boards), and other RISC CPUs in a Unix box—although
    you may need to research the particular solution for an example on your specific
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the examples in this book run under macOS, Windows, and Linux. When
    creating the examples, I tried to stick with standard library interfaces to the
    OS wherever possible and make OS-specific calls only when the alternative was
    to write “less than great” code.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the specific examples in this text will run on a late-model Intel Architecture
    (including AMD) CPU under Windows, macOS, and Linux, with a reasonable amount
    of RAM and other system peripherals normally found on a modern PC. The concepts,
    if not the software itself, will apply to Macs, Unix boxes, SBCs, embedded systems,
    and even mainframes.
  prefs: []
  type: TYPE_NORMAL
- en: '**For More Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mariani, Rico. “Designing for Performance.” December 11, 2003\. *[https://docs.microsoft.com/en-us/archive/blogs/ricom/designing-for-performance/](https://docs.microsoft.com/en-us/archive/blogs/ricom/designing-for-performance/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Wikipedia. “Program Optimization.” *[https://en.wikipedia.org/wiki/Program_optimization/](https://en.wikipedia.org/wiki/Program_optimization/)*.
  prefs: []
  type: TYPE_NORMAL
