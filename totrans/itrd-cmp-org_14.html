<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch14"><span epub:type="pagebreak" id="page_269"/><strong><span class="big">14</span><br/>INSIDE SUBFUNCTIONS</strong></h2>&#13;
<div class="image1"><img src="../images/pg297_Image_276.jpg" alt="Image" width="192" height="195"/></div>&#13;
<p class="noindentz">Good engineering practice generally includes breaking problems down into functionally distinct subproblems. In software, this approach leads to programs with many functions, each of which solves a subproblem.</p>&#13;
<p class="indent">The main advantage of this <em>divide and conquer</em> approach is that it’s usually easier to solve a small subproblem than the overall problem. Another advantage is that previous solutions to subproblems are often reusable, as we have demonstrated by using functions from the C standard library. We can also save development time by having several people work on different parts of the overall problem simultaneously.</p>&#13;
<p class="indent">When breaking down a problem like this, it’s important to coordinate the many partial solutions so that they work together to provide a correct overall solution. In software, this translates to making sure the data interface between a calling function and a called function works correctly. To ensure correct operation of the interface, it must be explicitly specified. In this chapter, I’ll show you how to do that. I’ll first show you how to place data items in a global location so that all the functions in the program can have direct access to them. Then I’ll cover restricting the passage of data items as arguments to a function, which gives us better control over the data the function works with.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_270"/>In the previous chapters, you learned how to pass arguments to a function in registers. In this chapter, you’ll learn how to store these arguments in memory so the registers can be reused inside the called function. You’ll also learn how to pass more arguments to a function than can be done with the eight registers specified in <a href="ch11.xhtml#ch11tab3">Table 11-3</a> in <a href="ch11.xhtml">Chapter 11</a>.</p>&#13;
<p class="indent">Finally, I’ll discuss in more detail the creation of variables within a function. I’ll cover variables that exist only when program flow is in the function, as well as variables that stay in memory for the duration of the program but are accessible only within their defining function.</p>&#13;
<p class="indent">Before we get into the inner workings of functions, however, let’s take a look at some of the rules that govern the use of variable names in C.</p>&#13;
<h3 class="h3" id="ch14lev1sec1"><strong>Scope of Variable Names in C</strong></h3>&#13;
<p class="noindent"><em>Scope</em> refers to the places in our code where a variable’s name is <em>visible</em>, meaning we can use that name. This is not a book on C, so I won’t cover all the rules of where variable names can be used in a program, but I’ll explain enough to help you understand the basic concepts.</p>&#13;
<p class="indent">In C, a <em>declaration</em> of a variable introduces its name and data type into the current scope. A <em>definition</em> of a variable is a declaration that also allocates memory for the variable. A variable can be defined in only one place in a program, but as you’ll see in “Global Variables” on <a href="ch14.xhtml#ch14lev1sec3">page 271</a>, it might be declared in more than one scope.</p>&#13;
<p class="indent">Variables that are defined inside a function definition are called <em>local variables</em>, and names declared in a function’s parameter list are called <em>formal parameters</em>. Both local variables and formal parameters have <em>function scope</em>: their scope extends from the point of declaration to the end of the function.</p>&#13;
<p class="indent">A <em>block</em> in C is a group of C statements enclosed in a matched pair of curly brackets, <span class="literal">{}</span>. The scope of variables defined inside a block extends from the point of definition to the end of that block, including any enclosed blocks. This is <em>block scope</em>.</p>&#13;
<p class="indent">A <em>function prototype</em> is only a declaration of the function, not its definition. It includes the name of the function, the data types of any parameters passed to the function, and the return data type. The parameters don’t need to be named in the prototype, but doing so provides some documentation within the prototype itself. The scope of a parameter name in a prototype declaration is limited to its own prototype. This limit allows us to use the same names in different function prototypes. For example, the C standard library includes functions for computing sine and cosine, whose prototypes are as follows:</p>&#13;
<pre class="pre">double sin(double x);&#13;
double cos(double x);</pre>&#13;
<p class="noindent">We can use both function prototypes in the same function without having to use different names for the parameters.</p>&#13;
<p class="indent">Before looking at the final kind of scope, file scope, I’ll give you a brief overview of the reasons for passing arguments to a function.</p>&#13;
<h3 class="h3" id="ch14lev1sec2"><span epub:type="pagebreak" id="page_271"/><strong>Overview of Passing Arguments</strong></h3>&#13;
<p class="noindent">Input and output are relative to our point of view. As you read through this section, be careful to distinguish between data input from and data output to a calling function and data input from and data output to a user of the program. In this chapter, we’re looking at inputs to a function that come from and outputs that go to other functions in the program. We’ll look at program inputs from and outputs to I/O devices in <a href="ch20.xhtml">Chapter 20</a>.</p>&#13;
<p class="indent">To illustrate the difference, consider this C program statement (from <a href="ch02.xhtml#ch2list1">Listing 2-1</a> in <a href="ch02.xhtml">Chapter 2</a>), which is used to input an integer from the keyboard, an I/O device:</p>&#13;
<pre class="pre">scanf("%x", &amp;an_int);</pre>&#13;
<p class="indent">The <span class="literal">scanf</span> function has one data input from the <span class="literal">main</span> function: the address of the formatting text string, <span class="literal">"%x"</span>. The <span class="literal">scanf</span> function reads user data that is input from the keyboard and outputs data, an unsigned integer, to the <span class="literal">an_int</span> variable in the <span class="literal">main</span> function.</p>&#13;
<p class="indentb">Functions can interact with the data in other parts of the program in four ways:</p>&#13;
<p class="noindentin"><strong>Direct</strong> Data that is global to the program can be directly accessed from any function in the program.</p>&#13;
<p class="noindentin"><strong>Input</strong> The data comes from another part of the program and is used by the function, but the original copy is not modified.</p>&#13;
<p class="noindentin"><strong>Output</strong> The function provides new data to another part of the program.</p>&#13;
<p class="noindentin"><strong>Update</strong> The function modifies a data item that is held by another part of the program. The new value is based on the value before the function was called.</p>&#13;
<p class="indentgt">All four interactions can be performed if the called function also knows the location of the data item, but this exposes the original copy of the data and allows it to be changed even if it’s intended to be used only as input to the called function.</p>&#13;
<p class="indent">We can output data from a function by placing the output in a globally known location, such as a register or a globally known address. We can also pass the called function the address of the place to store the output. Updates require the called function to know the address of the data being updated.</p>&#13;
<p class="indent">To see how this works, we’ll start by looking at how global variables are created and how they are accessed in a subfunction.</p>&#13;
<h3 class="h3" id="ch14lev1sec3"><strong>Global Variables</strong></h3>&#13;
<p class="noindent"><em>Global variables</em> are defined outside any functions and have <em>file scope</em>, which means they can be accessed from the point of their definition to the end of the file. Global variables can also be accessed from another file by declaring <span epub:type="pagebreak" id="page_272"/>them with the <span class="literal">extern</span> modifier. Using <span class="literal">extern</span> only introduces the name and data type of the variable into the scope of the declaration, without allocating memory for it.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14list1">Listing 14-1</a> shows how to define global variables.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>sum_ints_global.c</em></p>&#13;
</div>&#13;
<pre class="pre">  // Add two integers using global variables.&#13;
&#13;
  #include &lt;stdio.h&gt;&#13;
  #include "add_two_global.h"&#13;
&#13;
<span class="ent">➊</span> int x = 123, y = 456, z;    // Define global variables&#13;
&#13;
  int main(void)&#13;
  {&#13;
      add_two();&#13;
      printf("%i + %i = %i\n", x, y, z);&#13;
&#13;
      return 0;&#13;
  }</pre>&#13;
<p class="list" id="ch14list1"><em>Listing 14-1: A</em> <span class="codeitalic">main</span> <em>function that uses three global variables</em></p>&#13;
<p class="indent">Placing the definitions of the variables <span class="literal">x</span>, <span class="literal">y</span>, and <span class="literal">z</span> outside the function body makes them global <span class="ent">❶</span>. The first two variables are initialized, but not the third. I’ll show you how the compiler treats the difference.</p>&#13;
<p class="indent">This <span class="literal">main</span> function calls the <span class="literal">add_two</span> function, which will add <span class="literal">x</span> and <span class="literal">y</span> and store the sum in <span class="literal">z</span>. <a href="ch14.xhtml#ch14list2">Listing 14-2</a> shows the assembly language produced by the compiler for this <span class="literal">main</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>sum_ints_global.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "sum_ints_global.c"&#13;
     <span class="ent">➊</span> .text&#13;
        .global x&#13;
     <span class="ent">➋</span> .data                     /// Data segment&#13;
        .align  2&#13;
        .type   x, %object&#13;
        .size   x, 4&#13;
x:&#13;
     <span class="ent">➌</span> .word   123               /// Initialize&#13;
        .global y&#13;
        .align  2&#13;
        .type   y, %object&#13;
        .size   y, 4&#13;
y:&#13;
        .word   456&#13;
        .global z&#13;
     <span class="ent">➍</span> .bss                      /// .bss section&#13;
        .align  2&#13;
        .type   z, %object&#13;
     <span class="ent">➎</span> .size   z, 4&#13;
z:&#13;
     <span class="ent">➏</span> .zero   4                 /// Could use .skip&#13;
        .section        .rodata&#13;
        .align  3&#13;
.LC0:&#13;
        .string "%i + %i = %i\n"&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
        stp     x29, x30, [sp, -16]!&#13;
        mov     x29, sp&#13;
        bl      add_two&#13;
     <span class="ent">➐</span> adrp    x0, x             /// Address  defined&#13;
        add     x0, x0, :lo12:x   ///   in this file&#13;
        ldr     w1, [x0]&#13;
        adrp    x0, y&#13;
        add     x0, x0, :lo12:y&#13;
        ldr     w2, [x0]&#13;
        adrp    x0, z&#13;
        add     x0, x0, :lo12:z&#13;
        ldr     w0, [x0]&#13;
        mov     w3, w0&#13;
        adrp    x0, .LC0&#13;
        add     x0, x0, :lo12:.LC0&#13;
        bl      printf&#13;
        mov     w0, 0&#13;
        ldp     x29, x30, [sp], 16&#13;
        ret&#13;
        .size   main, .-main&#13;
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_273"/>&#13;
<p class="list" id="ch14list2"><em>Listing 14-2: The compiler-generated assembly language for the function in <a href="ch14.xhtml#ch14list1">Listing 14-1</a></em></p>&#13;
<p class="indent">I don’t know why the compiler added the first <span class="literal">.text</span> directive <span class="ent">❶</span>, but it’s not needed. Its effect is immediately overridden by the <span class="literal">.data</span> assembler directive, which switches us to the data segment <span class="ent">❷</span>.</p>&#13;
<p class="indent">The <span class="literal">.word</span> directive allocates a word (4 bytes) of memory and initializes it to the value of the argument, which is the integer 123 here <span class="ent">❸</span>. The <span class="literal">.bss</span> assembler directive then switches us to a <em>block starting symbol</em> section, which will be located in the data segment when the program is loaded into memory for execution <span class="ent">❹</span>. Each label defined in a <span class="literal">.bss</span> section will name the start of an uninitialized block of memory. Only the size of each labeled block is stored in the program’s executable file, thus making the file smaller.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_274"/>The Linux operating system initializes all the bytes in memory in a <span class="literal">.bss</span> section to 0 when the program is loaded, but your algorithm should not depend on the variables there being 0 unless they are explicitly set to 0 in your source code.</p>&#13;
<p class="indent">The <span class="literal">.size</span> assembler directive associates a label with a number of bytes in its block <span class="ent">❺</span>. The <span class="literal">z</span> label is for a 4-byte variable in this program. Although <span class="literal">z</span> is not initialized in our C code, and the <span class="literal">.bss</span> segment will be set to 0 when the program is loaded, the compiler has used the <span class="literal">.zero</span> assembler directive, which specifies 4 bytes of memory, each set to 0 here <span class="ent">❻</span>. The <span class="literal">.skip</span> directive would have the same effect as a <span class="literal">.zero</span> directive in a <span class="literal">.bss</span> section. Since we are in a <span class="literal">.bss</span> segment, the assembler does not store the 4 zero bytes in the object file.</p>&#13;
<p class="indent">The variables are defined in this file, so the compiler uses the <span class="literal">adrp</span>/<span class="literal">add</span> two-instruction sequence to load their addresses <span class="ent">❼</span>.</p>&#13;
<p class="indent">Next, let’s look at <span class="literal">add_two</span>. First, we need a header file for the function. This is shown in <a href="ch14.xhtml#ch14list3">Listing 14-3</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_two_global.h</em></p>&#13;
</div>&#13;
<pre class="pre">   // Add two global integers.&#13;
&#13;
<span class="ent">➊</span> #ifndef ADD_TWO_GLOBAL_H&#13;
<span class="ent">➋</span> #define ADD_TWO_GLOBAL_H&#13;
<span class="ent">➌</span> void add_two(void);&#13;
   #endif</pre>&#13;
<p class="list" id="ch14list3"><em>Listing 14-3: The header file for the</em> <span class="codeitalic">add_two</span> <em>function using global variables.</em></p>&#13;
<p class="indent">Header files are used to declare a function prototype, which can be declared only once in a C source code file <span class="ent">❸</span>. A header file can include other header files, some of which could include the original header file, leading to a function prototype being declared more than once. To guard against this, we define an identifier that is a stylized version of the header file’s name <span class="ent">❷</span>.</p>&#13;
<p class="indent">We start with an <span class="literal">#ifndef</span> assembler directive to check if this identifier has already been defined <span class="ent">❶</span>. If not, the contents of the file up to the end of the <span class="literal">#endif</span> directive are included, defining the filename identifier and declaring the function prototype. The check for the filename identifier in any subsequent inclusions of this header file will then show that the identifier has been defined, so the preprocessor will skip down to the <span class="literal">#endif</span> and avoid declaring the function prototype again.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14list4">Listing 14-4</a> shows the definition of the <span class="literal">add_two</span> function using global variables.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_two_global.c</em></p></div>&#13;
<pre class="pre">   // Add two global integers.&#13;
&#13;
<span class="ent">➊</span> #include "add_two_global.h"&#13;
&#13;
<span class="ent">➋</span> extern int x, y, z;&#13;
&#13;
   void add_two(void)&#13;
   {&#13;
       z = x + y;&#13;
   }</pre>&#13;
<p class="list" id="ch14list4"><span epub:type="pagebreak" id="page_275"/><em>Listing 14-4: The</em> <span class="codeitalic">add_two</span> <em>function using global variables</em></p>&#13;
<p class="indent">The header file for a function should be included in the file where the function is defined to make sure the function prototype in the header file matches the definition <span class="ent">❶</span>. The global variables are defined in only one place, but they need to be declared in any other file that uses them <span class="ent">❷</span>.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14list5">Listing 14-5</a> shows the assembly language generated by the compiler for the <span class="literal">add_two</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_two_global.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "add_two_global.c"&#13;
        .text&#13;
        .align  2&#13;
        .global add_two&#13;
        .type   add_two, %function&#13;
add_two:&#13;
     <span class="ent">➊</span> adrp    x0, :got:x              /// Global offset table page&#13;
     <span class="ent">➋</span> ldr     x0, [x0, :got_lo12:x]   /// Address of x&#13;
        ldr     w1, [x0]&#13;
        adrp    x0, :got:y&#13;
        ldr     x0, [x0, :got_lo12:y]&#13;
        ldr     w0, [x0]&#13;
        add     w1, w1, w0&#13;
        adrp    x0, :got:z&#13;
        ldr     x0, [x0, :got_lo12:z]&#13;
        str     w1, [x0]&#13;
     <span class="ent">➌</span> nop&#13;
        ret&#13;
        .size   add_two, .-add_two&#13;
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<p class="list" id="ch14list5"><em>Listing 14-5: The compiler-generated assembly language for the function in <a href="ch14.xhtml#ch14list4">Listing 14-4</a></em></p>&#13;
<p class="indent">The <span class="literal">add_two</span> function declares the <span class="literal">x</span>, <span class="literal">y</span>, and <span class="literal">z</span> variables with an <span class="literal">extern</span> storage class specifier so it can access them, but it needs to use a different technique to load the addresses because they are defined in another file. The loader stores the addresses of the global variables in the global offset table (GOT), introduced in “The Linker” on <a href="ch12.xhtml#ch12lev2sec7">page 239</a>, when the program is loaded into memory for execution. The <span class="literal">:got:</span> operand modifier tells the loader to use the GOT containing the address of the variable when filling in the page offset from the <span class="literal">adrp</span> instruction <span class="ent">❶</span>.</p>&#13;
<p class="indent">The <span class="literal">ldr</span> instruction here is using the page address of the GOT, in <span class="literal">x0</span>, for its base address <span class="ent">❷</span>. The <span class="literal">:got_lo12:</span> operand modifier tells the loader to use the low-order 12 bits of the offset to where the variable’s address is stored in the GOT, thus overwriting the page address of the GOT with the variable’s address in <span class="literal">x0</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_276"/><a href="ch14.xhtml#ch14list5">Listing 14-5</a> also contains a new instruction, the <span class="literal">nop</span> (pronounced “no-op”) <span class="ent">❸</span>. It has no effect on the algorithm. The manual says it’s used for instruction alignment purposes:</p>&#13;
<h5 class="h5" id="ch14lev3sec1"><span class="codestrong">nop</span><strong>—No operation</strong></h5>&#13;
<p class="indent"><span class="literal">nop</span> adds 4 to the program counter with no other effect.</p>&#13;
<p class="indentgt">Although global variables are simple to work with in small programs, managing them is unwieldy in large programs. You need to keep track of exactly what each function in the program is doing with the global variables. Managing variables is much easier if you define them within a function and pass only what is needed to each subfunction. In the next section, I’ll show you how to maintain control over what gets passed to and from a subfunction.</p>&#13;
<h3 class="h3" id="ch14lev1sec4"><strong>Explicitly Passing Arguments</strong></h3>&#13;
<p class="noindent">When we restrict each function to using only those variables it needs, it’s much easier to isolate the inner workings of a function from other functions. This is a principle called <em>information hiding</em>. It means that you, the programmer, need to deal with only those variables and constants that a subfunction needs to do its specific job. Of course, most subfunctions will need to interact with some of the variables in their calling functions in one way or another. In this section, we’ll look at how a function uses the arguments explicitly passed to it to accept input, produce output, or update a variable.</p>&#13;
<p class="indent">When a value serves only as input to the called function, we can pass a copy of the value to the called function. This is called <em>passing by value</em>. Passing by value prevents the called function from changing the value in the calling function.</p>&#13;
<p class="indent">Receiving output from the called function is a bit more complex. One way to accomplish this is to use a <em>return value</em>, which in our environment is placed in the <span class="literal">w0</span> register. Using the <span class="literal">w0</span> register assumes the return value is an <span class="literal">int</span>. This technique is used in most of the example programs in this book. The <span class="literal">main</span> function almost always returns a 0 to the function in the operating system that called it. There are other rules for returning larger values, which we won’t go into in this book.</p>&#13;
<p class="indent">The other techniques for the calling function to receive an output from the called function require that the calling function pass the called function the address of the place to store the output. This can be implemented in higher-level languages as either <em>pass by pointer</em> or <em>pass by reference</em>. The difference is that with pass by pointer, the program can change the pointer to point to another object, while with pass by reference, the program cannot change the pointer. C and C++ both support pass by pointer, but only C++ supports pass by reference. These are the same at the assembly language level; the address of the place to store the output is passed to the called function. The difference is enforced by the high-level language.</p>&#13;
<p class="indent">Next, you’ll learn how C controls access to its local variables.</p>&#13;
<h4 class="h4" id="ch14lev2sec1"><span epub:type="pagebreak" id="page_277"/><em><strong>In C</strong></em></h4>&#13;
<p class="noindent">In this section, I’ll write the same program as in <a href="ch14.xhtml#ch14list1">Listings 14-1</a>, <a href="ch14.xhtml#ch14list3">14-3</a>, and <a href="ch14.xhtml#ch14list4">14-4</a>, but this time I’ll define the variables as local variables in the <span class="literal">main</span> function and pass them as arguments to the subfunction. <a href="ch14.xhtml#ch14list6">Listing 14-6</a> shows the new version of the <span class="literal">main</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>sum_ints.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Add two integers using local variables.&#13;
&#13;
#include &lt;stdio.h&gt;&#13;
#include "add_two.h"&#13;
&#13;
int main(void)&#13;
{&#13;
 <span class="ent">➊</span> int x = 123, y = 456, z;&#13;
&#13;
 <span class="ent">➋</span> add_two(&amp;z, x, y);&#13;
    printf("%i + %i = %i\n", x, y, z);&#13;
&#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch14list6"><em>Listing 14-6: A</em> <span class="codeitalic">main</span> <em>function that uses three local variables</em></p>&#13;
<p class="indent">Defining the variables inside the body of the function <span class="ent">❶</span> makes them visible only to this function. The <span class="literal">add_two</span> function will store its result at the address we pass in as the first argument. We use the C address operator, <span class="literal">&amp;</span>, to get the address of the <span class="literal">z</span> variable, giving <span class="literal">&amp;z</span> <span class="ent">❷</span>. The values of the <span class="literal">x</span> and <span class="literal">y</span> variables are inputs to the <span class="literal">add_two</span> function, so we pass copies of these variables.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14list7">Listing 14-7</a> shows the header file for the <span class="literal">add_two</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_two.h</em></p>&#13;
</div>&#13;
<pre class="pre">// Add two integers and output the sum.&#13;
&#13;
#ifndef ADD_TWO_H&#13;
#define ADD_TWO_H&#13;
void add_two(int *a, int b, int c);&#13;
#endif</pre>&#13;
<p class="list" id="ch14list7"><em>Listing 14-7: The header file for the</em> <span class="codeitalic">add_two</span> <em>function using local variables</em></p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14list8">Listing 14-8</a> shows the definition of the <span class="literal">add_two</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_two.c</em></p>&#13;
</div>&#13;
<pre class="pre">//Add two integers and output the sum.&#13;
&#13;
#include "add_two.h"&#13;
&#13;
void add_two(int *a, int b, int c)&#13;
{&#13;
    int sum;&#13;
&#13;
    sum = b + c;&#13;
 <span class="ent">➊</span> *a = sum;&#13;
}</pre>&#13;
<span epub:type="pagebreak" id="page_278"/>&#13;
<p class="list" id="ch14list8"><em>Listing 14-8: The</em> <span class="codeitalic">add_two</span> <em>function using local variables</em></p>&#13;
<p class="indent">The first parameter in the argument list, <span class="literal">a</span>, is a pointer to an <span class="literal">int</span>. This means that <span class="literal">a</span> holds the address where we need to store the value of <span class="literal">sum</span>. To dereference <span class="literal">a</span>, we use the C <em>dereference operator</em>, <span class="literal">*</span>, giving <span class="literal">*a</span> <span class="ent">❶</span>. This stores the result of the computation at the address passed in <span class="literal">a</span>.</p>&#13;
<h4 class="h4" id="ch14lev2sec2"><em><strong>In Assembly Language</strong></em></h4>&#13;
<p class="noindent"><a href="ch14.xhtml#ch14list9">Listing 14-9</a> shows the assembly language generated by the compiler for the <span class="literal">main</span> function in <a href="ch14.xhtml#ch14list6">Listing 14-6</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>sum_ints.s</em></p>&#13;
</div>&#13;
<pre class="pre">         .arch armv8-a&#13;
         .file   "sum_ints.c"&#13;
         .text&#13;
         .section        .rodata&#13;
         .align  3&#13;
         .LC0:&#13;
         .string "%i + %i = %i\n"&#13;
         .text&#13;
         .align  2&#13;
         .global main&#13;
         .type   main, %function&#13;
 main:&#13;
      <span class="ent">❶</span> stp     x29, x30, [sp, -32]!&#13;
         mov     x29, sp&#13;
         mov     w0, 123&#13;
      <span class="ent">❷</span> str     w0, [sp, 28]        /// x = 123;&#13;
         mov     w0, 456&#13;
         str     w0, [sp, 24]        /// y = 456;&#13;
      <span class="ent">❸</span> add     x0, sp, 20          /// Address of z&#13;
      <span class="ent">❹</span> ldr     w2, [sp, 24]        /// Load y and x&#13;
         ldr     w1, [sp, 28]&#13;
         bl      add_two&#13;
         ldr     w0, [sp, 20]&#13;
         mov     w3, w0&#13;
         ldr     w2, [sp, 24]&#13;
         ldr     w1, [sp, 28]&#13;
         adrp    x0, .LC0&#13;
         add     x0, x0, :lo12:.LC0&#13;
         bl      printf&#13;
         mov     w0, 0&#13;
         ldp     x29, x30, [sp], 32&#13;
         ret&#13;
         .size   main, .-main&#13;
         .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
         .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_279"/>&#13;
<p class="list" id="ch14list9"><em>Listing 14-9: The compiler-generated assembly language for the function in <a href="ch14.xhtml#ch14list6">Listing 14-6</a></em></p>&#13;
<p class="indent">All three variables are automatic local variables, so the compiler allocates space for them in the stack frame <span class="ent">❶</span>. Initialized automatic local variables are newly created each time the function is called, so they need to be actively initialized <span class="ent">❷</span>.</p>&#13;
<p class="indent">We pass the address of our <code>z</code> variable to the <code>add_two</code> function so it can store its output there <span class="ent">❸</span>, and we send copies of the values in the <code>x</code> and <code>y</code> variables as inputs to the function <span class="ent">❹</span>.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14list10">Listing 14-10</a> shows the compiler-generated assembly language for the <code>add_two</code> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_two.s</em></p>&#13;
</div>&#13;
<pre class="pre">         .arch armv8-a&#13;
         .file   "add_two.c"&#13;
         .text&#13;
         .align  2&#13;
         .global add_two&#13;
         .type   add_two, %function&#13;
 add_two:&#13;
      <span class="ent">❶</span> sub     sp, sp, #32&#13;
      <span class="ent">❷</span> str     x0, [sp, 8]         /// Address for output&#13;
         str     w1, [sp, 4]         /// Value of first input&#13;
         str     w2, [sp]            /// Value of second input&#13;
         ldr     w1, [sp, 4]&#13;
         ldr     w0, [sp]&#13;
         add     w0, w1, w0&#13;
         str     w0, [sp, 28]        /// Store sum locally&#13;
         ldr     x0, [sp, 8]&#13;
         ldr     w1, [sp, 28]        /// Load sum&#13;
         str     w1, [x0]            /// Store for caller&#13;
         nop&#13;
         add     sp, sp, 32&#13;
         ret&#13;
         .size   add_two, .-add_two&#13;
         .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
         .section        .note.GNU-stack,"",@progbits</pre>&#13;
<p class="list" id="ch14list10"><em>Listing 14-10: The compiler-generated assembly language for the function in <a href="ch14.xhtml#ch14list8">Listing 14-8</a></em></p>&#13;
<p class="indent">The first thing you might notice about this function is that it does not save the contents of the link register, <code>lr</code>, and frame pointer, <code>fp</code> <span class="ent">❶</span>. These two addresses make up the <em>frame record</em>. The address in <code>lr</code> provides the link back to the place where this function was called, while <code>fp</code> provides a link back to the frame record of the calling function. This chain of frame records can be useful in certain error situations, but I won’t get into the details in this book.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_280"/>The AArch64 procedure call standard states that a small function that doesn’t call a function does not need a frame record, which explains why the compiler has omitted it. A function that does not call any functions is often called a <em>leaf function</em>.</p>&#13;
<p class="indent">This function simply allocates a 32-byte stack frame, where it stores the three items that were passed to it <span class="ent">❷</span>. You can probably tell this is not needed in this very simple function, but it might be in more complex functions. <a href="ch14.xhtml#ch14fig1">Figure 14-1</a> gives a pictorial view of <code>add_two</code>’s stack frame.</p>&#13;
<div class="image"><img id="ch14fig1" src="../images/pg308_Image_277.jpg" alt="Image" width="440" height="206"/></div>&#13;
<p class="figcap"><em>Figure 14-1: The stack frame for the</em> <span class="codeitalic">add_two</span> <em>function in <a href="ch14.xhtml#ch14list10">Listing 14-10</a></em></p>&#13;
<p class="indent">The values at <code>c</code> and <code>b</code> are inputs to this function, and <code>a</code> is the address where the output from the function will be stored.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14list11">Listing 14-11</a> shows how I would probably write the <code>add_two</code> function in assembly language.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_two.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Add two integers and output the sum.&#13;
// Calling sequence:&#13;
//    x0 &lt;- address of output&#13;
//    w1  &lt;- integer&#13;
//    w2  &lt;- integer&#13;
//    Returns 0&#13;
        .arch armv8-a&#13;
// Stack frame&#13;
     <span class="ent">❶</span> .equ    save1920, 16&#13;
        .equ    FRAME, 32&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global add_two&#13;
        .type   add_two, %function&#13;
add_two:&#13;
        stp     fp, lr, [sp, -FRAME]!     // Create stack frame&#13;
        mov     fp, sp                    // Set our frame pointer&#13;
     <span class="ent">❷</span> stp     x19, x20, [sp, save1920]  // Save for local vars&#13;
&#13;
        mov     x20, x0                   // For output&#13;
     <span class="ent">❸</span> add     w19, w2, w1               // Compute sum&#13;
        str     w19, [x20]                // Output sum&#13;
&#13;
        mov     w0, wzr                   // Return 0&#13;
     <span class="ent">❹</span> ldp     x19, x20, [sp, save1920]  // Restore reg&#13;
        ldp     fp, lr, [sp], FRAME       // Delete stack frame&#13;
        ret                               // Back to caller</pre>&#13;
<span epub:type="pagebreak" id="page_281"/>&#13;
<p class="list" id="ch14list11"><em>Listing 14-11: The</em> <span class="codeitalic">add_two</span> <em>function written in assembly language</em></p>&#13;
<p class="indent">A stack frame is not required for this small leaf function, but I have created one here to show how to save registers for the calling function so we can use them as local variables. We first need to specify a location in the stack frame <span class="ent">❶</span>. This leads to the stack frame shown in <a href="ch14.xhtml#ch14fig2">Figure 14-2</a>.</p>&#13;
<div class="image"><img id="ch14fig2" src="../images/pg309_Image_278.jpg" alt="Image" width="564" height="205"/></div>&#13;
<p class="figcap"><em>Figure 14-2: The stack frame for the</em> <span class="codeitalic">add_two</span> <em>function in <a href="ch14.xhtml#ch14list11">Listing 14-11</a></em></p>&#13;
<p class="indent">Although the algorithm uses only the low-order word of the <span class="literal">x19</span> register, we need to save the entire 64 bits because our algorithm might change the high-order 32 bits <span class="ent">❷</span>. In fact, the <span class="literal">add</span> instruction here will zero the high-order 32 bits of <span class="literal">x19</span> <span class="ent">❸</span>. Don’t forget that we need to restore the saved registers before undoing our stack frame <span class="ent">❹</span>.</p>&#13;
<p class="indent">Comparing the stack frame for my assembly language version of the <span class="literal">add_two</span> function with the stack frame created by the compiler for the C version in <a href="ch14.xhtml#ch14fig1">Figure 14-1</a>, notice that I’ve created a frame record at the top of my stack frame. I’ve then saved the <span class="literal">x19</span> and <span class="literal">x20</span> registers so I can use them for the computations in the function. If I later change my assembly language <span class="literal">add_two</span> function such that it calls another function, I don’t need to change its stack frame because it already has a frame record, and the standard says that the called function must preserve the values in the <span class="literal">x19</span> and <span class="literal">20</span> registers for the calling function.</p>&#13;
<p class="indent">In the next section, you’ll see how the stack comes to our rescue when we want to pass more than the eight arguments we can pass in registers.</p>&#13;
<h4 class="h4" id="ch14lev2sec3"><em><strong>With More Than Eight Arguments</strong></em></h4>&#13;
<p class="noindent">Most functions take fewer than the eight arguments we can pass in registers, but sometimes a calling function needs to pass more than eight arguments to another function. In these cases, the arguments beyond the first eight are passed on the call stack. They are placed on the stack before the call to the function. I’ll use the program in <a href="ch14.xhtml#ch14list12">Listings 14-12</a>, <a href="ch14.xhtml#ch14list14">14-14</a>, and <a href="ch14.xhtml#ch14list15">14-15</a> to show you how this works.</p>&#13;
<div class="note6">&#13;
<p class="notep"><span epub:type="pagebreak" id="page_282"/><em>sum11ints.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Sum the integers 1 to 11.&#13;
&#13;
#include &lt;stdio.h&gt;&#13;
#include "add_eleven.h"&#13;
&#13;
int main(void)&#13;
{&#13;
    int total;&#13;
    int a = 1;&#13;
    int b = 2;&#13;
    int c = 3;&#13;
    int d = 4;&#13;
    int e = 5;&#13;
    int f = 6;&#13;
    int g = 7;&#13;
    int h = 8;&#13;
    int i = 9;&#13;
    int j = 10;&#13;
    int k = 11;&#13;
 &#13;
    total = add_eleven(a, b, c, d, e, f, g, h, i, j, k);&#13;
    printf("The sum is %i\n", total);&#13;
&#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch14list12"><em>Listing 14-12: A program passing more than eight arguments to a subfunction</em></p>&#13;
<p class="indent">This <span class="literal">main</span> function creates 11 integer variables and initializes them to the values 1 through 11. It then calls the <span class="literal">add_eleven</span> function to compute the sum of the 11 numbers and prints the result.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14list13">Listing 14-13</a> shows the assembly language generated by the compiler for the <span class="literal">main</span> function in <a href="ch14.xhtml#ch14list12">Listing 14-12</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>sum11ints.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "sum11ints.c"&#13;
        .text&#13;
        .section        .rodata&#13;
        .align  3&#13;
.LC0:&#13;
        .string "The sum is %i\n"&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
     <span class="ent">❶</span> sub     sp, sp, #96         /// Local vars and args&#13;
        stp     x29, x30, [sp, 32]  /// Store caller fp and lr&#13;
        add     x29, sp, 32         /// Point fp to caller's fp&#13;
        mov     w0, 1               /// Store values in local vars&#13;
        str     w0, [sp, 92]&#13;
        mov     w0, 2&#13;
        str     w0, [sp, 88]&#13;
        mov     w0, 3&#13;
        str     w0, [sp, 84]&#13;
        mov     w0, 4&#13;
        str     w0, [sp, 80]&#13;
        mov     w0, 5&#13;
        str     w0, [sp, 76]&#13;
        mov     w0, 6&#13;
        str     w0, [sp, 72]&#13;
        mov     w0, 7&#13;
        str     w0, [sp, 68]&#13;
        mov     w0, 8&#13;
        str     w0, [sp, 64]&#13;
        mov     w0, 9&#13;
        str     w0, [sp, 60]&#13;
        mov     w0, 10&#13;
        str     w0, [sp, 56]&#13;
        mov     w0, 11&#13;
        str     w0, [sp, 52]&#13;
        ldr     w0, [sp, 52]        /// Store args on the stack&#13;
     <span class="ent">❷</span> str     w0, [sp, 16]&#13;
        ldr     w0, [sp, 56]&#13;
        str     w0, [sp, 8]&#13;
        ldr     w0, [sp, 60]&#13;
        str     w0, [sp]&#13;
     <span class="ent">❸</span> ldr     w7, [sp, 64]        /// Load args into regs&#13;
        ldr     w6, [sp, 68]&#13;
        ldr     w5, [sp, 72]&#13;
        ldr     w4, [sp, 76]&#13;
        ldr     w3, [sp, 80]&#13;
        ldr     w2, [sp, 84]&#13;
        ldr     w1, [sp, 88]&#13;
        ldr     w0, [sp, 92]&#13;
        bl      add_eleven&#13;
        str     w0, [sp, 48]&#13;
        ldr     w1, [sp, 48]&#13;
        adrp    x0, .LC0&#13;
        add     x0, x0, :lo12:.LC0&#13;
        bl      printf&#13;
        mov     w0, 0&#13;
        ldp     x29, x30, [sp, 32]&#13;
        add     sp, sp, 96&#13;
        ret&#13;
        .size   main, .-main&#13;
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_283"/>&#13;
<span epub:type="pagebreak" id="page_284"/>&#13;
<p class="list" id="ch14list13"><em>Listing 14-13: The compiler-generated assembly language for the function in <a href="ch14.xhtml#ch14list12">Listing 14-12</a></em></p>&#13;
<p class="indent">When this function creates its stack frame, it allocates memory on the stack for the additional arguments it needs to pass on the stack <span class="ent">❶</span>. Before calling the <span class="literal">add_eleven</span> function, it works from right to left in the argument list. Since it can pass only eight arguments in registers, it needs to store the three excess arguments on the stack <span class="ent">❷</span>. These arguments are stored at the top of our stack frame, where the AArch64 procedure call standard specifies the called function should expect them. <a href="ch14.xhtml#ch14fig3">Figure 14-3</a> shows the state of the stack at this point.</p>&#13;
<div class="image"><img id="ch14fig3" src="../images/pg312_Image_279.jpg" alt="Image" width="548" height="471"/></div>&#13;
<p class="figcap"><em>Figure 14-3: The stack frame for the</em> <span class="codeitalic">main</span> <em>function in <a href="ch14.xhtml#ch14list12">Listing 14-12</a>, just before calling</em> <span class="codeitalic">add_eleven</span></p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14fig3">Figure 14-3</a> shows that the stack pointer is pointing to the arguments that are being passed to <span class="literal">add_eleven</span> on the stack. The names in the arguments area in this figure, <span class="literal">nine</span>, <span class="literal">ten</span>, and <span class="literal">eleven</span>, are the corresponding parameter names used by the <span class="literal">add_eleven</span> function. The procedure call standard allows both <span class="literal">main</span> and <span class="literal">add_eleven</span> to access stack memory in the arguments area, but argument passing can only take place from caller to callee—that is, from <span class="literal">main</span> to <span class="literal">add_eleven</span> in this example.</p>&#13;
<p class="indent">Although we’re passing 4-byte <span class="literal">int</span>s, the AArch64 procedure call standard states that we must use 8 bytes for each stack argument, the same number of bytes as a register argument. Following this rule ensures you can use your assembly language functions with C functions. In <a href="ch14.xhtml#ch14fig3">Figure 14-3</a>, the compiler has stored the ninth, tenth, and eleventh arguments in the low-order <span epub:type="pagebreak" id="page_285"/>4 bytes of each argument slot on the stack. (Don’t forget that our memory order is little-endian.)</p>&#13;
<p class="indent">With our stack frame set up for calling the <span class="literal">add_eleven</span> function, we now store the remaining eight arguments in registers <span class="ent">❸</span>.</p>&#13;
<p class="indent">Let’s look at how the <span class="literal">add_eleven</span> function retrieves the arguments from the stack. I’ll start with the header file for the function, in <a href="ch14.xhtml#ch14list14">Listing 14-14</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_eleven.h</em></p>&#13;
</div>&#13;
<pre class="pre">// Add 11 integers and return the sum.&#13;
&#13;
#ifndef ADD_ELEVEN_H&#13;
#define ADD_ELEVEN_H&#13;
int add_eleven(int one, int two, int three, int four, int five, int six,&#13;
               int seven, int eight, int nine, int ten, int eleven);&#13;
#endif</pre>&#13;
<p class="list" id="ch14list14"><em>Listing 14-14: The header file for the</em> <span class="codeitalic">add_eleven</span> <em>function</em></p>&#13;
<p class="indent">The <span class="literal">add_eleven</span> function is defined in <a href="ch14.xhtml#ch14list15">Listing 14-15</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_eleven.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Add 11 integers and return the sum.&#13;
&#13;
#include &lt;stdio.h&gt;&#13;
#include "add_eleven.h"&#13;
&#13;
int add_eleven(int one, int two, int three, int four, int five, int six,&#13;
               int seven, int eight, int nine, int ten, int eleven)&#13;
{&#13;
    int sum = one + two + three + four + five + six&#13;
            + seven + eight + nine + ten + eleven;&#13;
    printf("Added them\n");&#13;
&#13;
    return sum;&#13;
}</pre>&#13;
<p class="list" id="ch14list15"><em>Listing 14-15: A function that receives more than eight arguments from a calling function</em></p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14list16">Listing 14-16</a> shows the assembly language generated by the compiler for the <span class="literal">add_eleven</span> function in <a href="ch14.xhtml#ch14list15">Listing 14-15</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_eleven.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "add_eleven.c"&#13;
        .text&#13;
        .section        .rodata&#13;
        .align  3&#13;
.LC0:&#13;
        .string "Added them"&#13;
        .text&#13;
        .align  2&#13;
        .global add_eleven&#13;
        .type   add_eleven, %function&#13;
add_eleven:&#13;
        stp     x29, x30, [sp, -64]!&#13;
        mov     x29, sp&#13;
     <span class="ent">❶</span> str     w0, [sp, 44]          /// Save register arguments locally&#13;
        str     w1, [sp, 40]&#13;
        str     w2, [sp, 36]&#13;
        str     w3, [sp, 32]&#13;
        str     w4, [sp, 28]&#13;
        str     w5, [sp, 24]&#13;
        str     w6, [sp, 20]&#13;
        str     w7, [sp, 16]&#13;
        ldr     w1, [sp, 44]          /// Add first 8 inputs&#13;
        ldr     w0, [sp, 40]&#13;
        add     w1, w1, w0&#13;
        ldr     w0, [sp, 36]&#13;
        add     w1, w1, w0&#13;
        ldr     w0, [sp, 32]&#13;
        add     w1, w1, w0&#13;
        ldr     w0, [sp, 28]&#13;
        add     w1, w1, w0&#13;
        ldr     w0, [sp, 24]&#13;
        add     w1, w1, w0&#13;
        ldr     w0, [sp, 20]&#13;
        add     w1, w1, w0&#13;
        ldr     w0, [sp, 16]&#13;
        add     w1, w1, w0&#13;
     <span class="ent">❷</span> ldr     w0, [sp, 64]          /// Add inputs 9-11 from the stack&#13;
        add     w1, w1, w0&#13;
        ldr     w0, [sp, 72]&#13;
        add     w0, w1, w0&#13;
        ldr     w1, [sp, 80]&#13;
        add     w0, w1, w0&#13;
        str     w0, [sp, 60]&#13;
        adrp    x0, .LC0&#13;
        add     x0, x0, :lo12:.LC0&#13;
        bl      puts&#13;
        ldr     w0, [sp, 60]&#13;
        ldp     x29, x30, [sp], 64&#13;
        ret&#13;
        .size   add_eleven, .-add_eleven&#13;
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_286"/>&#13;
<p class="list" id="ch14list16"><em>Listing 14-16: The compiler-generated assembly language for the function in <a href="ch14.xhtml#ch14list15">Listing 14-15</a></em></p>&#13;
<p class="indent">After creating a stack frame, the compiler saves the arguments that were passed in registers, because the call to another function might change their contents <span class="ent">❶</span>. It does this near the beginning of the function so it doesn’t have <span epub:type="pagebreak" id="page_287"/>to keep track of which ones have been saved when compiling the C statements in the function.</p>&#13;
<p class="indent">After loading each of these eight arguments from the stack and summing them, the function adds the remaining three arguments that are in the calling function’s stack frame <span class="ent">❷</span>.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14fig4">Figure 14-4</a> shows the stack frames belonging to the <span class="literal">main</span> and <span class="literal">add_eleven</span> functions.</p>&#13;
<div class="image"><img id="ch14fig4" src="../images/pg315_Image_280.jpg" alt="Image" width="525" height="673"/></div>&#13;
<p class="figcap"><em>Figure 14-4: The stack frames after the</em> <span class="codeitalic">add_eleven</span> <em>function has been called and has created its stack frame</em></p>&#13;
<p class="indent">I mentioned on <a href="ch14.xhtml#page_279">page 279</a> that the frame pointer points to the frame record, which points to the calling function’s frame record, and so forth. <a href="ch14.xhtml#ch14fig4">Figure 14-4</a> shows this chain back to <span class="literal">main</span>’s frame record.</p>&#13;
<p class="indent">I’ve shown only the offsets from <span class="literal">sp</span> that should be used by <span class="literal">add_eleven</span>. This function knows that <span class="literal">sp</span> was pointing to three 32-bit arguments before it subtracted 64 from <span class="literal">sp</span>, so the first argument on the stack is now +64 from <span class="literal">sp</span>.</p>&#13;
<p class="indent">The procedure call standard allows the <span class="literal">add_eleven</span> function to store and load items to and from the area labeled “ <span class="literal">add_eleven</span> only” in <a href="ch14.xhtml#ch14fig4">Figure 14-4</a>. It allows the <span class="literal">add_eleven</span> function to use items in the stack area labeled “Both,” but it does not allow a called function to pass items back to the calling function <span epub:type="pagebreak" id="page_288"/>in this area. The <span class="literal">add_eleven</span> function is not allowed to access the stack area labeled “<span class="literal">main</span> only.”</p>&#13;
<p class="indent">The <span class="literal">main</span> function can store and load items to and from the area labeled “<span class="literal">main</span> only” in <a href="ch14.xhtml#ch14fig4">Figure 14-4</a>, but it is allowed only to store items to the stack area labeled “Both.”</p>&#13;
<h4 class="h4" id="ch14lev2sec4"><em><strong>Stack Frame Discipline</strong></em></h4>&#13;
<p class="noindent">It’s essential that you follow the register usage and argument passing disciplines precisely when writing in assembly language. Any deviation can cause errors that are difficult to debug.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14fig5">Figure 14-5</a> shows the overall pattern for a stack frame.</p>&#13;
<div class="image"><img id="ch14fig5" src="../images/pg316_Image_281.jpg" alt="Image" width="542" height="442"/></div>&#13;
<p class="figcap"><em>Figure 14-5: A stack frame</em></p>&#13;
<p class="indent">A stack frame doesn’t always include all the parts in <a href="ch14.xhtml#ch14fig5">Figure 14-5</a>. If the function never passes more than eight arguments to the functions it calls, the top box doesn’t exist. In this case, <span class="literal">sp</span> and <span class="literal">fp</span> both point to the frame record.</p>&#13;
<p class="indent">Some functions may not have any local variables or saved register contents. If it’s a leaf function, we don’t even need a frame record.</p>&#13;
<p class="indent">If no more than eight arguments are passed to the function, then the bottom box in this diagram does not exist. The bottom box is the only area of the stack frame that both the current function and its calling function have access to.</p>&#13;
<p class="indent">Let’s write the <span class="literal">sum11ints</span> program in assembly language. Unless it’s a very simple function, I start my designs by drawing a diagram of the stack frame for each function, similar to <a href="ch14.xhtml#ch14fig3">Figures 14-3</a> and <a href="ch14.xhtml#ch14fig4">14-4</a>. Then I use <span class="literal">.equ</span> directives to give symbolic names to the locations on the stack that I need to access in my code.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_289"/><a href="ch14.xhtml#ch14list17">Listing 14-17</a> shows how we can do this for the <span class="literal">main</span> function in our <span class="literal">sum11ints</span> program.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>sum11ints.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Sum the integers 1 to 11.&#13;
        .arch armv8-a&#13;
// Stack frame&#13;
     <span class="ent">❶</span> .equ    arg9, 0&#13;
        .equ    arg10, 8&#13;
        .equ    arg11, 16&#13;
        .equ    frame_record, 32&#13;
        .equ    total, 48&#13;
        .equ    k, 52&#13;
        .equ    j, 56&#13;
        .equ    i, 60&#13;
        .equ    h, 64&#13;
        .equ    g, 68&#13;
        .equ    f, 72&#13;
        .equ    e, 76&#13;
        .equ    d, 80&#13;
        .equ    c, 84&#13;
        .equ    b, 88&#13;
        .equ    a, 92&#13;
        .equ    FRAME, 96&#13;
// Constant data&#13;
        .section  .rodata&#13;
        .align  3&#13;
format:&#13;
        .string "The sum is %i\n"&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
     <span class="ent">❷</span> sub     sp, sp, FRAME              // Allocate our stack frame&#13;
        stp     fp, lr, [sp, frame_record] // Create frame record&#13;
        add     fp, sp, frame_record       // Set our frame pointer&#13;
        mov     w0, 1                      // Store values in local vars&#13;
     <span class="ent">❸</span> str     w0, [sp, a]&#13;
        mov     w0, 2&#13;
        str     w0, [sp, b]&#13;
        mov     w0, 3&#13;
        str     w0, [sp, c]&#13;
        mov     w0, 4&#13;
        str     w0, [sp, d]&#13;
        mov     w0, 5&#13;
        str     w0, [sp, e]&#13;
        mov     w0, 6&#13;
        str     w0, [sp, f]&#13;
        mov     w0, 7&#13;
        str     w0, [sp, g]&#13;
        mov     w0, 8&#13;
        str     w0, [sp, h]&#13;
        mov     w0, 9&#13;
        str     w0, [sp, i]&#13;
        mov     w0, 10&#13;
        str     w0, [sp, j]&#13;
        mov     w0, 11&#13;
        str     w0, [sp, k]&#13;
        ldr     w0, [sp, k]                // Store args 9-11&#13;
        str     w0, [sp, arg11]            //   on the stack&#13;
        ldr     w0, [sp, j]&#13;
        str     w0, [sp, arg10]&#13;
        ldr     w0, [sp, i]&#13;
        str     w0, [sp, arg9]&#13;
        ldr     w7, [sp, h]                // Load args 1-8&#13;
        ldr     w6, [sp, g]                //   in regs 0-7&#13;
        ldr     w5, [sp, f]&#13;
        ldr     w4, [sp, e]&#13;
        ldr     w3, [sp, d]&#13;
        ldr     w2, [sp, c]&#13;
        ldr     w1, [sp, b]&#13;
        ldr     w0, [sp, a]&#13;
        bl      add_eleven                 // Add all&#13;
        str     w0, [sp, total]            // Store returned sum&#13;
        ldr     w1, [sp, total]            // Argument to printf&#13;
        adr     x0, format                 // Format string &#13;
        bl      printf                     // Print result&#13;
&#13;
        mov     w0, wzr                    // Return 0&#13;
        ldp     fp, lr, [sp, frame_record] // Restore fp and lr&#13;
        add     sp, sp, FRAME              // Delete stack frame&#13;
        ret                                // Back to caller</pre>&#13;
<span epub:type="pagebreak" id="page_290"/>&#13;
<p class="list" id="ch14list17"><em>Listing 14-17: The</em> <span class="codeitalic">sum11ints main</span> <em>function written in assembly language</em></p>&#13;
<p class="indent">The list of <span class="literal">.equ</span> directives gives a good view of what our stack frame looks like <span class="ent">❶</span>. Using the symbolic names for our variables makes it easy to read the assembly language code, because we don’t have to remember the numerical offset of each item on the stack <span class="ent">❸</span>.</p>&#13;
<p class="indent">The algorithm for the function prologue needs to take into account that <span class="literal">main</span> will be passing arguments on the stack. We start by allocating space for our stack frame <span class="ent">❷</span>. Then, we create the frame record after the area for passing arguments on the stack. This is easy once we have created our <span class="literal">.equ</span> view of the stack frame.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_291"/>Next, we’ll write the <span class="literal">add_eleven</span> function in assembly language, using the diagram in <a href="ch14.xhtml#ch14fig4">Figure 14-4</a> to set the values of the <span class="literal">.equ</span> directives. The assembly language is shown in <a href="ch14.xhtml#ch14list18">Listing 14-18</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_eleven.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Add 11 integers and return the sum.&#13;
// Calling sequence:&#13;
//    w0 through w7 &lt;- 8 integers&#13;
//    [sp] &lt;- integer&#13;
//    [sp+8] &lt;- integer&#13;
//    [sp+16] &lt;- integer&#13;
//    Returns sum&#13;
        .arch armv8-a&#13;
// Stack frame&#13;
        .equ    eight, 16&#13;
        .equ    seven, 20&#13;
        .equ    six, 24&#13;
        .equ    five, 28&#13;
        .equ    four, 32&#13;
        .equ    three, 36&#13;
        .equ    two, 40&#13;
        .equ    one, 44&#13;
        .equ    sum, 60&#13;
     <span class="ent">❶</span> .equ    FRAME, 64             // End of our frame&#13;
        .equ    nine, 64              // Stack args&#13;
        .equ    ten, 72&#13;
        .equ    eleven, 80&#13;
// Constant data&#13;
        .section  .rodata&#13;
        .align  3&#13;
msg:&#13;
        .string "Added them"&#13;
        .text&#13;
        .align  2&#13;
        .global add_eleven&#13;
        .type   add_eleven, %function&#13;
add_eleven:&#13;
     <span class="ent">❷</span> stp     fp, lr, [sp, -FRAME]! // Create stack frame&#13;
        mov     fp, sp                // Set our frame pointer&#13;
&#13;
        str     w0, [sp, one]         // Save register args&#13;
        str     w1, [sp, two]&#13;
        str     w2, [sp, three]&#13;
        str     w3, [sp, four]&#13;
        str     w4, [sp, five]&#13;
        str     w5, [sp, six]&#13;
        str     w6, [sp, seven]&#13;
        str     w7, [sp, eight]&#13;
        ldr     w1, [sp, one]         // Load args             &#13;
        ldr     w0, [sp, two]&#13;
        add     w1, w1, w0            //   and sum them&#13;
        ldr     w0, [sp, three]&#13;
        add     w1, w1, w0&#13;
        ldr     w0, [sp, four]&#13;
        add     w1, w1, w0&#13;
        ldr     w0, [sp, five]&#13;
        add     w1, w1, w0&#13;
        ldr     w0, [sp, six]&#13;
        add     w1, w1, w0&#13;
        ldr     w0, [sp, seven]&#13;
        add     w1, w1, w0&#13;
        ldr     w0, [sp, eight]&#13;
        add     w1, w1, w0&#13;
        ldr     w0, [sp, nine]&#13;
        add     w1, w1, w0&#13;
        ldr     w0, [sp, ten]&#13;
        add     w1, w1, w0&#13;
        ldr     w0, [sp, eleven]&#13;
        add     w1, w1, w0&#13;
        str     w1, [sp, sum]         // Store sum&#13;
        adr     x0, msg               // Tell user we're done&#13;
        bl      puts&#13;
&#13;
        ldr     w0, [sp, sum]         // Return the sum&#13;
        ldp     fp, lr, [sp], FRAME   // Delete stack frame&#13;
        ret                           // Back to caller</pre>&#13;
<span epub:type="pagebreak" id="page_292"/>&#13;
<p class="list" id="ch14list18"><em>Listing 14-18: The</em> <span class="codeitalic">add_eleven</span> <em>function written in assembly language</em></p>&#13;
<p class="indent">We need to be careful to distinguish between the part of our stack frame being used only by this function and the arguments that were passed in by the calling function. Naming this boundary with a <span class="literal">.equ</span> directive <span class="ent">❶</span> makes it easy to create our stack frame <span class="ent">❷</span>. As with the <span class="literal">main</span> function in <a href="ch14.xhtml#ch14list17">Listing 14-17</a>, the <span class="literal">.equ</span> directive names also make it easier to read the assembly language.</p>&#13;
<p class="indent">The values in automatic local variables will be lost when exiting a function. There are times when you want the information provided by a local variable to be hidden, but you also want the content of the variable to remain the same between subsequent calls to the function. We’ll look next at how this can be done.</p>&#13;
<div class="box">&#13;
<p class="box-title" id="ch14you1"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch14exe1">14.1     Show that the assembly language <span class="literal">add_eleven</span> function in <a href="ch14.xhtml#ch14list18">Listing 14-18</a> works with the C <span class="literal">main</span> function in <a href="ch14.xhtml#ch14list12">Listing 14-12</a>.</p>&#13;
<p class="box-list1" id="ch14exe2"><span epub:type="pagebreak" id="page_293"/>14.2     Show that initializing the <span class="literal">sum</span> variable in <a href="ch14.xhtml#ch14list15">Listing 14-15</a> is the same as doing the addition separately, like in <a href="ch14.xhtml#ch14list8">Listing 14-8</a>.</p>&#13;
<p class="box-list1" id="ch14exe3">14.3     Write a program in assembly language that sums all the integers between two integers entered by the user.</p>&#13;
<p class="box-list1" id="ch14exe4">14.4     Write the three functions <span class="literal">write_char</span>, <span class="literal">write_str</span>, and <span class="literal">read_str</span> in assembly language. You’ll use these functions in exercises later in the book. Here are the specifications for each:</p>&#13;
<p class="alpha">(a)     <span class="literal">write_char</span> writes one character in the terminal window using the <span class="literal">write</span> system call. It takes one argument and returns 0.</p>&#13;
<p class="alpha">(b)     <span class="literal">write_str</span> writes text in the terminal window using the <span class="literal">write</span> system call. It takes one argument and returns the number of characters written.</p>&#13;
<p class="alpha">(c)     <span class="literal">read_str</span> reads characters from the keyboard using the <span class="literal">read</span> system call and stores them in memory as a C-style text string, without the return character. It takes two arguments: a pointer to the memory location to store the text and the maximum number of characters to store. If the number of characters entered exceeds the maximum, it reads the remaining input but does not store it. It returns the number of characters entered, less the <span class="literal">NUL</span> terminating character.</p>&#13;
<p class="box-listno">Test the functions with the following C <span class="literal">main</span> function. Don’t forget to write the C header files for your assembly language functions.</p>&#13;
<pre class="pre">// Prompt user to enter text and echo it.&#13;
   &#13;
#include "write_char.h"&#13;
#include "write_str.h"&#13;
#include "read_str.h"&#13;
#define MAX 5&#13;
#define BUFF_SZ MAX+1   // Make room for NUL&#13;
   &#13;
int main(void)&#13;
{&#13;
    char text[BUFF_SZ];&#13;
       &#13;
    write_str("Enter some text: ");&#13;
    read_str(text, MAX);&#13;
    write_str("You entered: ");&#13;
    write_str(text);&#13;
    write_char('\n');&#13;
       &#13;
    return 0;&#13;
}</pre>&#13;
<p class="box-listno">Hint: Use a small number for <span class="literal">MAX</span> when testing your <span class="literal">read_str</span> function.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch14lev1sec5"><strong>Static Local Variables</strong></h3>&#13;
<p class="noindent">As discussed in <a href="ch11.xhtml">Chapter 11</a>, automatic local variables are created in a function’s prologue and get deleted in the function’s epilogue. This means the <span epub:type="pagebreak" id="page_294"/>value stored in an automatic local variable will be lost in subsequent calls to the function. But in some cases, we might want to keep the value of a variable between function calls while still providing the information-hiding advantage of a local variable. For example, we might have a function that is called from several other functions and want to maintain a count of how many times it’s called. We could use a global variable, but a global variable doesn’t provide the information-hiding properties of a local variable.</p>&#13;
<p class="indent">Instead, we can use a <em>static local variable</em>. Like an automatic local variable, a static local variable has local scope; however, like a global variable, it remains in memory throughout the lifetime of the entire program.</p>&#13;
<h4 class="h4" id="ch14lev2sec5"><em><strong>In C</strong></em></h4>&#13;
<p class="noindent">I’ll explain where static local variables are created in memory using the program in <a href="ch14.xhtml#ch14list19">Listings 14-19</a>, <a href="ch14.xhtml#ch14list20">14-20</a>, and <a href="ch14.xhtml#ch14list21">14-21</a>. These listings illustrate the differences between the visibility and persistence of an automatic local variable, a static local variable, and a global variable.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>var_life.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Compare the scope and lifetime of automatic, static, and global variables.&#13;
&#13;
#include &lt;stdio.h&gt;&#13;
#include "add_const.h"&#13;
#define INIT_X 12&#13;
#define INIT_Y 34&#13;
#define INIT_Z 56&#13;
&#13;
int z = INIT_Z;&#13;
&#13;
int main(void)&#13;
{&#13;
    int x = INIT_X;&#13;
    int y = INIT_Y;&#13;
&#13;
    printf("           automatic   static   global\n");&#13;
    printf("                   x        y        z\n");&#13;
    printf("In main:%12i %8i %8i\n", x, y, z);&#13;
    add_const();&#13;
    add_const();&#13;
    printf("In main:%12i %8i %8i\n", x, y, z);&#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch14list19"><em>Listing 14-19: A program to compare automatic local, static local, and global variables</em></p>&#13;
<p class="indent">This <span class="literal">main</span> function defines three <span class="literal">int</span> variables: the global variable <span class="literal">z</span> and the automatic local variables <span class="literal">x</span> and <span class="literal">y</span>.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14list20">Listing 14-20</a> shows the header file for the <span class="literal">add_const</span> function, which adds a constant value to an automatic local variable, a static local variable, and the global variable defined in <span class="literal">main</span>.</p>&#13;
<span epub:type="pagebreak" id="page_295"/>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_const.h</em></p>&#13;
</div>&#13;
<pre class="pre">// Add a constant to an automatic local variable, a static local variable, &#13;
// and a global variable.&#13;
&#13;
#ifndef ADD_CONST_H&#13;
#define ADD_CONST_H&#13;
void add_const(void);&#13;
#endif</pre>&#13;
<p class="list" id="ch14list20"><em>Listing 14-20: The header file for the</em> <span class="codeitalic">add_const</span> <em>function</em></p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14list21">Listing 14-21</a> is the definition of the <span class="literal">add_const</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_const.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Add a constant to an automatic local variable, a static local variable, &#13;
// and a global variable.&#13;
&#13;
#include &lt;stdio.h&gt;&#13;
#include "add_const.h"&#13;
#define INIT_X 78&#13;
#define INIT_Y 90&#13;
#define ADDITION 1000&#13;
&#13;
void add_const(void)&#13;
{&#13;
    int x = INIT_X;         // Every call&#13;
  <span class="ent">❶</span> static int y = INIT_Y;  // First call only&#13;
  <span class="ent">❷</span> extern int z;           // Global&#13;
  &#13;
     x += ADDITION;          // Add to each&#13;
     y += ADDITION;&#13;
     z += ADDITION;&#13;
&#13;
     printf("In add_const:%7i %8i %8i\n", x, y, z);&#13;
}</pre>&#13;
<p class="list" id="ch14list21"><em>Listing 14-21: A function to add a constant value to three variables</em></p>&#13;
<p class="indent">The <span class="literal">add_const</span> function defines two local variables, <span class="literal">x</span> and <span class="literal">y</span>. The <span class="literal">y</span> variable is specified to be <span class="literal">static</span> <span class="ent">❶</span>. This means it will be initialized to <span class="literal">INIT_Y</span> only the first time <span class="literal">add_const</span> is called. (If you don’t give an initial value to a static local variable, the compiler will initialize it to 0, but I recommend explicitly initializing it to 0 if that is your intention.) Any changes to <span class="literal">y</span> by <span class="literal">add_const</span> will persist through this call and all subsequent calls to the function. The <span class="literal">z</span> variable is declared with the <span class="literal">extern</span> modifier <span class="ent">❷</span> to show that it’s defined elsewhere in the program.</p>&#13;
<p class="indent">The <span class="literal">add_const</span> function adds a constant value to each of the three variables declared in the function. The <span class="literal">printf</span> statement shows the values of the <span class="literal">x</span> and <span class="literal">y</span> local variables defined in <span class="literal">add_const</span> and the <span class="literal">z</span> global variable defined in <span class="literal">main</span> each time <span class="literal">add_const</span> is called.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_296"/>Executing this program gives the following output:</p>&#13;
<pre class="pre">           automatic   static   global&#13;
                   x        y        z&#13;
In main:          12       34       56&#13;
In add_const:   1078     1090     1056&#13;
In add_const:<span class="ent">❶</span> 1078   <span class="ent">❷</span> 2090     2056&#13;
In main:          12       34   <span class="ent">❸</span> 2056</pre>&#13;
<p class="indent">As you can see, the <span class="literal">x</span> in <span class="literal">main</span> is different from the <span class="literal">x</span> in <span class="literal">add_const</span>. Each time <span class="literal">main</span> calls <span class="literal">add_const</span>, the <span class="literal">x</span> in <span class="literal">add_const</span> is initialized to 78 and the function adds 1,000 to it <span class="ent">❶</span>. This shows that a new <span class="literal">x</span> is automatically created each time <span class="literal">add_const</span> is called.</p>&#13;
<p class="indent">You can also see that the <span class="literal">y</span> in <span class="literal">main</span> is different from the <span class="literal">y</span> in <span class="literal">add_const</span>, but the behavior of the <span class="literal">x</span> and <span class="literal">y</span> variables in <span class="literal">add_const</span> is not the same. The first time <span class="literal">add_const</span> is called, it initializes its <span class="literal">y</span> variable to 90 and adds 1,000 to it. However, the result of this first call to <span class="literal">add_const</span> persists. The second call to <span class="literal">add_const</span> does not cause its <span class="literal">y</span> to be initialized again; the function simply adds 1,000 to the existing value in the static <span class="literal">y</span> <span class="ent">❷</span>.</p>&#13;
<p class="indent">Although there are two <span class="literal">x</span>s and two <span class="literal">y</span>s in this program, there is only one <span class="literal">z</span>, which is defined in <span class="literal">main</span>. The output of the program shows that <span class="literal">main</span> gives <span class="literal">z</span> its initial value, 56, and <span class="literal">add_const</span> adds 1,000 to this each time the function is called <span class="ent">❸</span>.</p>&#13;
<h4 class="h4" id="ch14lev2sec6"><em><strong>In Assembly Language</strong></em></h4>&#13;
<p class="noindent"><a href="ch14.xhtml#ch14list22">Listing 14-22</a> shows the compiler-generated assembly language for the <span class="literal">main</span> function of the <span class="literal">var_life</span> program.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>var_life.s</em></p>&#13;
</div>&#13;
<pre class="pre">         .arch armv8-a&#13;
        .file   "var_life.c"&#13;
        .text&#13;
     <span class="ent">❶</span> .global z&#13;
        .data&#13;
        .align  2&#13;
        .type   z, %object&#13;
        .size   z, 4&#13;
z:&#13;
        .word   56                  /// One instance of z&#13;
        .section        .rodata&#13;
        .align  3&#13;
.LC0:&#13;
        .string "           automatic   static   global"&#13;
        .align  3&#13;
.LC1:&#13;
        .string "                   x        y        z"&#13;
        .align  3&#13;
.LC2:&#13;
        .string "In main:%12i %8i %8i\n"&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
        stp     x29, x30, [sp, -32]!&#13;
        mov     x29, sp&#13;
        mov     w0, 12&#13;
        str     w0, [sp, 28]        /// main's x&#13;
        mov     w0, 34&#13;
     <span class="ent">❷</span> str     w0, [sp, 24]        /// main's y&#13;
        adrp    x0, .LC0&#13;
        add     x0, x0, :lo12:.LC0&#13;
        bl      puts&#13;
        adrp    x0, .LC1&#13;
        add     x0, x0, :lo12:.LC1&#13;
        bl      puts&#13;
        adrp    x0, z&#13;
        add     x0, x0, :lo12:z&#13;
        ldr     w0, [x0]&#13;
        mov     w3, w0&#13;
        ldr     w2, [sp, 24]&#13;
        ldr     w1, [sp, 28]&#13;
        adrp    x0, .LC2&#13;
        add     x0, x0, :lo12:.LC2&#13;
        bl      printf&#13;
        bl      add_const&#13;
        bl      add_const&#13;
        adrp    x0, z&#13;
        add     x0, x0, :lo12:z&#13;
        ldr     w0, [x0]&#13;
        mov     w3, w0&#13;
        ldr     w2, [sp, 24]&#13;
        ldr     w1, [sp, 28]&#13;
        adrp    x0, .LC2&#13;
        add     x0, x0, :lo12:.LC2&#13;
        bl      printf&#13;
        mov     w0, 0&#13;
        ldp     x29, x30, [sp], 32&#13;
        ret&#13;
        .size   main, .-main&#13;
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_297"/>&#13;
<p class="list" id="ch14list22"><em>Listing 14-22: The compiler-generated assembly language for the function in <a href="ch14.xhtml#ch14list19">Listing 14-19</a></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_298"/>Most of this code should look familiar to you. The one instance of <span class="literal">z</span> in this program is defined as a global in <span class="literal">main</span>, and the compiler uses our name to label the variable <span class="ent">❶</span>. <span class="literal">main</span>’s <span class="literal">y</span> is created on the stack <span class="ent">❷</span>.</p>&#13;
<p class="indent">Let’s look at the assembly language the compiler generated for the <span class="literal">add_const</span> function, shown in <a href="ch14.xhtml#ch14list23">Listing 14-23</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_const.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "add_const.c"&#13;
        .text}&#13;
        .section        .rodata&#13;
        .align  3&#13;
.LC0:&#13;
        .string "In add_const:%7i %8i %8i\n"&#13;
        .text&#13;
        .align  2&#13;
        .global add_const&#13;
        .type   add_const, %function&#13;
add_const:&#13;
        stp     x29, x30, [sp, -32]!&#13;
        mov     x29, sp&#13;
        mov     w0, 78&#13;
     <span class="ent">❶</span> str     w0, [sp, 28]&#13;
        ldr     w0, [sp, 28]&#13;
        add     w0, w0, 1000&#13;
        str     w0, [sp, 28]            /// add_const's x&#13;
     <span class="ent">❷</span> adrp    x0, y.0&#13;
        add     x0, x0, :lo12:y.0       /// add_const's y&#13;
        ldr     w0, [x0]&#13;
        add     w1, w0, 1000&#13;
        adrp    x0, y.0&#13;
        add     x0, x0, :lo12:y.0&#13;
        str     w1, [x0]&#13;
     <span class="ent">❸</span> adrp    x0, :got:z              /// Global z&#13;
        ldr     x0, [x0, :got_lo12:z]&#13;
        ldr     w0, [x0]&#13;
        add     w1, w0, 1000&#13;
        adrp    x0, :got:z&#13;
        ldr     x0, [x0, :got_lo12:z]&#13;
        str     w1, [x0]&#13;
        adrp    x0, y.0&#13;
        add     x0, x0, :lo12:y.0&#13;
        ldr     w1, [x0]&#13;
        adrp    x0, :got:z&#13;
        ldr     x0, [x0, :got_lo12:z]&#13;
        ldr     w0, [x0]&#13;
        mov     w3, w0&#13;
        mov     w2, w1&#13;
        ldr     w1, [sp, 28]&#13;
        adrp    x0, .LC0&#13;
        add     x0, x0, :lo12:.LC0&#13;
        bl      printf&#13;
        nop&#13;
        ldp     x29, x30, [sp], 32&#13;
        ret&#13;
        .size   add_const, .-add_const&#13;
     <span class="ent">❹</span> .data&#13;
        .align  2&#13;
        .type   y.0, %object&#13;
        .size   y.0, 4&#13;
y.0:&#13;
     <span class="ent">❺</span> .word   90&#13;
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_299"/>&#13;
<p class="list" id="ch14list23"><em>Listing 14-23: The compiler-generated assembly language for the</em> <span class="codeitalic">add_const</span> <em>function in <a href="ch14.xhtml#ch14list21">Listing 14-21</a></em></p>&#13;
<p class="indent">The compiler allocated the <span class="literal">x</span> variable in the stack frame, so it knows the amount of the offset from the stack pointer <span class="ent">❶</span>. As you learned in “Global Variables” on <a href="ch14.xhtml#ch14lev1sec3">page 271</a>, <span class="literal">add_const</span> needs to retrieve the address of the global variable <span class="literal">z</span> from the GOT <span class="ent">❸</span>.</p>&#13;
<p class="indent">The compiler treats the static local variable <span class="literal">y</span> a little differently than a global variable. It has changed our name to <span class="literal">y.0</span> <span class="ent">❷</span>. This embellishment of our given name for the variable is called <em>name decoration</em> or <em>name mangling</em>. I prefer calling it decoration because it adds to our given name.</p>&#13;
<p class="indent">A static local variable cannot exist in the stack frame. Like the global variable <span class="literal">z</span> defined in the <span class="literal">main</span> function (see <a href="ch14.xhtml#ch14list22">Listing 14-22</a>), the static local variable <span class="literal">y</span> is allocated in the <span class="literal">.data</span> section <span class="ent">❹</span>. It’s labeled with its decorated name and initialized with a <span class="literal">.word</span> assembler directive <span class="ent">❺</span>. We get the address of our <span class="literal">y</span> variable using its decorated name <span class="ent">❷</span>.</p>&#13;
<p class="indent">The compiler needs to decorate names to satisfy the rules of C while also producing a valid assembly language file. As you might recall from the first section of this chapter (<a href="ch14.xhtml#ch14lev1sec1">page 270</a>), the scope of a variable name in C extends only to the end of the block where it’s defined. That means we can use the same name to define another static variable in a different block that is not enclosed within the first one. But both variables result in labels in the assembly language, where they have file scope. The C compiler needs to distinguish between the two labels because the assembler requires that each label be unique within a file. It does this by decorating our static local variable names.</p>&#13;
<p class="indent">When writing in assembly language, we can use more meaningful names to distinguish variables, making the code easier to read. <a href="ch14.xhtml#ch14list24">Listings 14-24</a> and <a href="ch14.xhtml#ch14list25">14-25</a> show how I would write this program in assembly language.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>var_life.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Compare the scope and lifetime of automatic, static, and global variables.&#13;
        .arch armv8-a&#13;
// Useful names&#13;
        .equ    INIT_X, 12&#13;
        .equ    INIT_Y, 34&#13;
        .equ    INIT_Z, 56&#13;
// Stack frame&#13;
        .equ    x, 24&#13;
        .equ    y, 28&#13;
        .equ    FRAME, 32&#13;
// Code&#13;
        .global z&#13;
        .data&#13;
        .align  2&#13;
        .type   z, %object&#13;
        .size   z, 4&#13;
z:&#13;
        .word   INIT_Z&#13;
        .section  .rodata&#13;
heading0:&#13;
        .string "           automatic   static   global"&#13;
heading1:&#13;
        .string "                   x        y        z"&#13;
msg:&#13;
        .string "In main:%12i %8i %8i\n"&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
        stp     fp, lr, [sp, -FRAME]!   // Create stack frame&#13;
        mov     fp, sp                  // Set frame pointer&#13;
&#13;
        mov     w0, INIT_X&#13;
        str     w0, [sp, x]             // x = INIT_X;&#13;
        mov     w0, INIT_Y&#13;
        str     w0, [sp, y]             // y = INIT_Y;&#13;
        adr     x0, heading0            // Print two-line header&#13;
        bl      puts&#13;
        adr     x0, heading1&#13;
        bl      puts&#13;
&#13;
     <span class="ent">❶</span> adr     x0, z &#13;
        ldr     w3, [x0]                // Global z&#13;
        ldr     w2, [sp, y]             // Local y&#13;
        ldr     w1, [sp, x]             // Local x&#13;
        adr     x0, msg                 // Show values&#13;
        bl      printf&#13;
        bl      add_const               // Add constants&#13;
        bl      add_const               //   twice&#13;
&#13;
        adr     x0, z                   // Repeat display&#13;
        ldr     w3, [x0]&#13;
        ldr     w2, [sp, y]&#13;
        ldr     w1, [sp, x]&#13;
        adr     x0, msg&#13;
        bl      printf&#13;
&#13;
        mov     w0, wzr                 // Return 0&#13;
        ldp     fp, lr, [sp], FRAME     // Delete stack frame&#13;
        ret                             // Back to caller</pre>&#13;
<span epub:type="pagebreak" id="page_300"/>&#13;
<span epub:type="pagebreak" id="page_301"/>&#13;
<p class="list" id="ch14list24"><em>Listing 14-24: An assembly language program to compare automatic local, static local, and global variables</em></p>&#13;
<p class="indent">My assembly language <span class="literal">main</span> function is very similar to what the compiler did in <a href="ch14.xhtml#ch14list22">Listing 14-22</a>, but I used more meaningful names. Programs that use only terminal I/O tend to be very small, so I assumed that <span class="literal">z</span> will be within <em>±</em>1MB of the instruction and used the <span class="literal">adr</span> instruction to load its address <span class="ent">❶</span>. The linker should warn us if this is not true, in which case we would need to use the <span class="literal">adrp/add</span> instruction sequence to load the address of <span class="literal">z</span>.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14list25">Listing 14-25</a> shows how I would write <span class="literal">add_const</span> in assembly language.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_const.s</em></p>&#13;
</div>&#13;
<pre class="pre">   // Add a constant to an automatic local variable, a static local variable, &#13;
   // and a global variable.&#13;
           .arch armv8-a&#13;
   // Useful names&#13;
           .equ    INIT_X, 78&#13;
           .equ    INIT_Y, 90&#13;
           .equ    ADDITION, 1000&#13;
   // Stack frame&#13;
           .equ    x, 28&#13;
           .equ    FRAME, 32&#13;
   // Code&#13;
           .data&#13;
           .align  2&#13;
           .type   y, %object&#13;
           .size   y, 4&#13;
<span class="ent">❶</span> y:&#13;
           .word   INIT_Y&#13;
           .section  .rodata&#13;
   msg:&#13;
           .string "In add_const:%7i %8i %8i\n"&#13;
           .text&#13;
           .align  2&#13;
           .global add_const&#13;
           .type   add_const, %function&#13;
   add_const:&#13;
           stp     fp, lr, [sp, -FRAME]!   // Create stack frame&#13;
           mov     fp, sp                  // Set frame pointer&#13;
   &#13;
           mov     w0, INIT_X&#13;
           add     w0, w0, ADDITION        // Add constant&#13;
           str     w0, [sp, x]             // x += ADDITION&#13;
        <span class="ent">❷</span> adr     x0, y&#13;
           ldr     w1, [x0]                // Load our y&#13;
           add     w1, w1, ADDITION        // Add constant&#13;
           str     w1, [x0]                // y += ADDITION;    &#13;
           adrp    x0, :got:z              // z page number&#13;
           ldr     x0, [x0, :got_lo12:z]   // z address&#13;
           ldr     w1, [x0]                // Load z&#13;
           add     w1, w1, ADDITION        // Add constant&#13;
           str     w1, [x0]                // z += ADDITION&#13;
   &#13;
           adrp    x0, :got:z              // z page number&#13;
           ldr     x0, [x0, :got_lo12:z]   // z address&#13;
           ldr     w3, [x0]                // Load global z&#13;
           adr     x0, y&#13;
           ldr     w2, [x0]                // Load our y&#13;
           ldr     w1, [sp, x]             // Load our x&#13;
           adr     x0, msg                 // Show current values&#13;
           bl      printf&#13;
   &#13;
           mov     w0, wzr                 // Return 0&#13;
           ldp     fp, lr, [sp], FRAME     // Delete stack frame&#13;
           ret                             // Back to caller</pre>&#13;
<span epub:type="pagebreak" id="page_302"/>&#13;
<p class="list" id="ch14list25"><em>Listing 14-25: An assembly language function to add a constant value to three variables</em></p>&#13;
<p class="indent">I have not decorated the name of the <span class="literal">y</span> variable <span class="ent">❶</span>. As we saw earlier, the compiler decorates the names of static local variables to prevent a duplication of labels in the compiler-generated assembly language if we use the same static local name in another function in the same C source file. But writing in assembly language gives us more flexibility in choosing our label names. If we use <span class="literal">y</span> to label another memory location in the same file with the <span class="literal">add_const</span> function, the assembler will tell us about the error.</p>&#13;
<p class="indent">As with the <span class="literal">z</span> variable in the <span class="literal">main</span> function, I assume the <span class="literal">y</span> static variable will be close to the instructions that access it <span class="ent">❷</span>.</p>&#13;
<p class="indent">Next, I’ll give a brief summary of program memory characteristics.</p>&#13;
<h3 class="h3" id="ch14lev1sec6"><strong>Program Memory Characteristics</strong></h3>&#13;
<p class="noindent">You learned about the different memory segments when we started programming in assembly language in <a href="ch10.xhtml">Chapter 10</a>. <a href="ch14.xhtml#ch14tab1">Table 14-1</a> summarizes the <span epub:type="pagebreak" id="page_303"/>memory characteristics of some of the most common components of a program, as well as which segment they are placed in.</p>&#13;
<p class="tabcap" id="ch14tab1"><strong>Table 14-1:</strong> The Memory Characteristics of Common Program Components</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Component</strong></th>&#13;
<th class="tab_th"><strong>Memory segment</strong></th>&#13;
<th class="tab_th"><strong>Access</strong></th>&#13;
<th class="tab_th"><strong>Lifetime</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1">Automatic local variable</td>&#13;
<td class="bg1">Stack</td>&#13;
<td class="bg1">Read and write</td>&#13;
<td class="bg1">Function</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">Constant</td>&#13;
<td class="bg">Text</td>&#13;
<td class="bg">Read only</td>&#13;
<td class="bg">Program</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">Instruction</td>&#13;
<td class="bg1">Text</td>&#13;
<td class="bg1">Read only</td>&#13;
<td class="bg1">Program</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">Static local variable</td>&#13;
<td class="bg">Data</td>&#13;
<td class="bg">Read and write</td>&#13;
<td class="bg">Program</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">Global variable</td>&#13;
<td class="bg1">Data</td>&#13;
<td class="bg1">Read and write</td>&#13;
<td class="bg1">Program</td></tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><a href="ch14.xhtml#ch14tab2">Table 14-2</a> summarizes some of the more common assembler directives used to control where program components go in memory.</p>&#13;
<p class="tabcap" id="ch14tab2"><strong>Table 14-2:</strong> Some Common Assembler Memory Directives</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Directive</strong></th>&#13;
<th class="tab_th">Memory segment</th>&#13;
<th class="tab_th">Effect</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">.text</span></td>&#13;
<td class="bg1">Text</td>&#13;
<td class="bg1">Instructions follow</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">.rodata</span></td>&#13;
<td class="bg">Text</td>&#13;
<td class="bg">Constant data follows</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">.string "<em>string</em>", ...</span></td>&#13;
<td class="bg1">Text</td>&#13;
<td class="bg1">Arrays of characters, each terminated by <span class="literal">NUL</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">.ascii "<em>string</em>", ...</span></td>&#13;
<td class="bg">Text</td>&#13;
<td class="bg">Arrays of characters</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">.asciz "<em>string</em>", ...</span></td>&#13;
<td class="bg1">Text</td>&#13;
<td class="bg1">Arrays of characters, each terminated by <span class="literal">NUL</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">.bss</span></td>&#13;
<td class="bg">Data</td>&#13;
<td class="bg">Following data memory is initialized to zero</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">.data</span></td>&#13;
<td class="bg1">Data</td>&#13;
<td class="bg1">Variable data follows</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">.byte <em>expression</em>, ...</span></td>&#13;
<td class="bg">Data</td>&#13;
<td class="bg">Initialize memory, 1 byte for each <em><span class="literal">expression</span></em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">.hword <em>expression</em>, ...</span></td>&#13;
<td class="bg1">Data</td>&#13;
<td class="bg1">Initialize memory, 2 bytes for each <em><span class="literal">expression</span></em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">.word <em>expression</em>, ...</span></td>&#13;
<td class="bg">Data</td>&#13;
<td class="bg">Initialize memory, 4 bytes for each <em><span class="literal">expression</span></em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">.quad <em>expression</em>, ...</span></td>&#13;
<td class="bg1">Data</td>&#13;
<td class="bg1">Initialize memory, 8 bytes for each <em><span class="literal">expression</span></em></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The <span class="literal">.string</span>, <span class="literal">.ascii</span>, and <span class="literal">.asciz</span> directives can allocate more than one text string, each separated by a comma. The <span class="literal">.string</span> and <span class="literal">.asciz</span> directives add a <span class="literal">NUL</span> character to the end of the text string, while <span class="literal">.ascii</span> does not.</p>&#13;
<p class="indent">The <span class="literal">.byte</span>, <span class="literal">.hword</span>, <span class="literal">.word</span>, and <span class="literal">.quad</span> directives can apply to zero or more <span class="codeitalic">expression</span>s, each of which must evaluate to an integral value. Multiple-byte values are stored in little-endian order. If there is no <span class="codeitalic">expression</span>, no memory is allocated.</p>&#13;
<p class="indent">This is only a summary of these directives. For additional details, consult the <span class="literal">info</span> page for <span class="literal">as</span>.</p>&#13;
<div class="box">&#13;
<p class="box-title"><span epub:type="pagebreak" id="page_304"/><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch14exe5">14.5     Modify the program in <a href="ch14.xhtml#ch14list24">Listings 14-24</a> and <a href="ch14.xhtml#ch14list25">14-25</a> so that the <span class="literal">add_const</span> function prints the number of times it has been called.</p>&#13;
<p class="box-list1" id="ch14exe6">14.6     Duplicate the <span class="literal">add_const</span> function in the file in <a href="ch14.xhtml#ch14list21">Listing 14-21</a>, naming the second copy <span class="literal">add_const2</span>. Modify the header file in <a href="ch14.xhtml#ch14list20">Listing 14-20</a> accordingly. Modify the <span class="literal">main</span> function in <a href="ch14.xhtml#ch14list19">Listing 14-19</a> so it calls both functions twice. How does this affect the name decorating in the <span class="literal">add_const</span> and <span class="literal">add_const2</span> functions&#13;
?</p>&#13;
</div>&#13;
<h3 class="h3" id="ch14lev1sec7"><strong>What You’ve Learned</strong></h3>&#13;
<p class="noindentin"><strong>Global variables</strong> Persist throughout the entire life of the program (global scope).</p>&#13;
<p class="noindentin"><strong>Automatic local variables</strong> Created in their function when the function is called and deleted when the function is exited (function scope).</p>&#13;
<p class="noindentin"><strong>Static local variables</strong> Initialized in the first call to their function. Their value, including any changes, persists between subsequent calls to the function (function scope).</p>&#13;
<p class="noindentin"><strong>Passing arguments</strong> The first eight arguments are passed in registers. Any additional arguments are passed on the stack.</p>&#13;
<p class="noindentin"><strong>Pass by value</strong> A copy of the value is passed.</p>&#13;
<p class="noindentin"><strong>Pass by pointer</strong> The address of the variable is passed. The address can be changed in the called function.</p>&#13;
<p class="noindentin"><strong>Pass by reference</strong> The address of the variable is passed. The address cannot be changed in the called function.</p>&#13;
<p class="noindentin"><strong>Stack frame</strong> An area on the stack where a function’s frame record, local variables, saved register contents, and arguments to the function can be stored.</p>&#13;
<p class="noindentin"><strong>Frame pointer</strong> A register containing the address of the frame record in the stack frame.</p>&#13;
<p class="noindentin"><strong>Frame record</strong> Two addresses: the calling function’s frame pointer and the return address to the calling function.</p>&#13;
<p class="indentgt">Now that you’ve learned about the inner workings of functions, I’ll show you a couple of specialized uses of subfunctions in the next chapter.</p>&#13;
</div>
</div>
</body></html>