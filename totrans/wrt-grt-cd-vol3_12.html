<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_169"/><strong><span class="big">9</span><br/>SYSTEM DOCUMENTATION</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindent"><span class="big1">System documentation specifies system requirements, design, test cases, and test procedures. In a large software system, the system documentation is often the most expensive part; the Waterfall software development model, for example, often produces more documentation than code.</span> In addition, typically you must maintain system documentation manually, so if you change a description (such as a requirement) in one document, you’ll need to search through the system documentation and update every other document that references that description for consistency. This is a difficult and costly process.</p>
<p class="indent">In this chapter, we’ll look at the common types of system documents, ways to enforce consistency within them, and documentation strategies to reduce some of the costs associated with development.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>This chapter discusses</em> system <em>documentation, not</em> user <em>documentation. To learn about user documentation in detail, check out “For More Information” on <a href="ch09.xhtml#page_184">page 184</a>.</em></p>
</div>
<h3 class="h3" id="lev-9.1"><span epub:type="pagebreak" id="page_170"/><strong>9.1 System Documentation Types</strong></h3>
<p class="noindent">Traditional software engineering generally uses the following system documentation types:</p>
<p class="listhead1"><strong>System Requirements Specification (SyRS) document</strong></p>
<p class="listbody">The SyRS (see “<a href="ch10.xhtml#lev-10.3">The System Requirements Specification Document</a>” on <a href="ch10.xhtml#page_193">page 193</a>) is a <em>system-level</em> requirements document. In addition to software requirements, it might include hardware, business, procedural, manual, and other non-software-related requirements. The SyRS is a customer/management/stakeholder-level document that eschews detail to present a “big picture” view of the requirements.</p>
<p class="listhead1"><strong>Software Requirements Specification (SRS) document</strong></p>
<p class="listbody">The SRS (see “<a href="ch10.xhtml#lev-10.4">The Software Requirements Specification Document</a>” on <a href="ch10.xhtml#page_194">page 194</a>) extracts the software requirements<sup><a href="ch19_footnote.xhtml#ch09fn1" id="ch09fn1a">1</a></sup> from the SyRS and drills down on the high-level requirements to introduce new requirements at a much finer level of detail (suitable for software engineers).</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The SyRS and SRS are</em> requirements <em>documents whose content may differ in scope and detail. Many organizations produce a single document rather than two separate ones, but this book treats them separately because the SyRS deals with a wider range of requirements (for example, hardware and business requirements) than the SRS.</em></p>
</div>
<p class="listhead1"><strong>Software Design Description (SDD) document</strong></p>
<p class="listbody">The SDD (see <a href="ch11.xhtml">Chapter 11</a>) discusses <em>how</em> the system will be constructed (versus the SyRS and SRS, which describe <em>what</em> the system will do). In theory, any programmer should be able to use the SDD and write the corresponding code to implement the software system.</p>
<p class="listhead1"><strong>Software Test Cases (STC) document</strong></p>
<p class="listbody">The STC (see “<a href="ch12.xhtml#lev-12.4">Software Test Case Documentation</a>” on <a href="ch12.xhtml#page_274">page 274</a>) describes the various test values needed to verify that the system incorporates all the requirements, and functions correctly beyond the requirements list.</p>
<p class="listhead1"><strong>Software Test Procedures (STP) document</strong></p>
<p class="listbody">The STP (see “<a href="ch12.xhtml#lev-12.5">Software Test Procedure Documentation</a>” on <a href="ch12.xhtml#page_288">page 288</a>) describes the procedures to efficiently execute the software test cases (from the STC) to verify correct system operation.</p>
<p class="listhead1"><strong>Requirements (or Reverse) Traceability Matrix (RTM) document</strong></p>
<p class="listbody">The RTM (see “<a href="ch09.xhtml#lev-9.2.3">The Requirements/Reverse Traceability Matrix</a>” on <a href="ch09.xhtml#page_178">page 178</a>) links the requirements against the design, test cases, and <span epub:type="pagebreak" id="page_171"/>code. Using an RTM, a stakeholder can verify that a requirement is implemented in the design and the code, and that the test cases and procedures properly check that requirement’s implementation.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Some organizations might also have a</em> Functional Requirements Specification <em>document; this often refers to the requirements that an external customer provides, or it can simply be a synonym for the SRS or SyRS. This book won’t use this term further.</em></p>
</div>
<p class="indent">There are many additional types of documents, but these are the basic ones you’d expect for any (non-XP, at least) project, and they correspond to the various stages of the Waterfall model (see “<a href="ch03.xhtml#lev-3.2.2">The Waterfall Model</a>” on <a href="ch03.xhtml#page_44">page 44</a>), as shown in <a href="ch09.xhtml#ch9fig1">Figure 9-1</a>.</p>
<div class="image"><a id="ch9fig1"/><img src="Images/fig9-1.jpg" alt="image" width="321" height="109"/></div>
<p class="figcap"><em>Figure 9-1: System documentation dependencies</em></p>
<p class="indent">As you can see, the SRS is constructed from the SyRS. The SDD is constructed from the SRS, as is the STC (which, in some cases, is also influenced by the SDD, as indicated by the gray arrow<sup><a href="ch19_footnote.xhtml#ch09fn2" id="ch09fn2a">2</a></sup>). The STP is constructed from the STC.</p>
<h3 class="h3" id="lev-9.2"><strong>9.2 Traceability</strong></h3>
<p class="noindent">Perhaps the greatest logistical issue with system documentation is consistency. A requirement typically generates some design item and a test case (which is part of a test procedure in the STP). This is an intuitive and natural progression when you’re following a strict Waterfall model—writing the SRS first, followed by the SDD, the STC, and the SDD. However, problems arise when you have to make corrections to documents earlier in this chain. For example, when you change a requirement, you might need to change entries in the SDD, STC, and STP documents. Best practice is therefore to use <em>traceability</em>, which allows you to easily trace items from one document to all the other system documents. If you can trace your requirements to design elements, test cases, and test procedures, you can rapidly locate and change those elements whenever you modify a requirement.</p>
<p class="indent"><em>Reverse traceability</em> allows you to trace a test procedure back to the corresponding test cases, and test cases and design items back to their corresponding requirements. For example, you might encounter problems with a test that require changes to the test procedure, in which case you can locate the corresponding test cases and requirements to ensure that your changes <span epub:type="pagebreak" id="page_172"/>to the test procedure still handle all of them. In this way, reverse traceability also helps you determine whether you need to make changes to the test cases or requirements.</p>
<h4 class="h4" id="lev-9.2.1"><strong><em>9.2.1 Ways to Build Traceability into Your Documentation</em></strong></h4>
<p class="noindent">There are a couple of ways to accomplish traceability and reverse traceability. One approach is to build the traceability into an <em>identifier</em>, or <em>tag</em>, associated with the requirement, design element, test case, or test procedure documentation. This tag could be a paragraph (or item) number, a descriptive word, or some other set of symbols that uniquely identify the text to reference. Software documents that use tags avoid wasting space by directly quoting other documents.</p>
<p class="indent">Often authors use paragraph numbers as tags, which is really easy to do in a word processing system. However, many word processors don’t support cross-referencing across multiple document types. Also, the tagging mechanism or format you want to use might not match what the word processor provides.</p>
<p class="indent">Although it’s possible to write custom software, or use a database application to extract and maintain cross-reference information, the most common solution is to maintain tags manually. This might sound as though it would require considerable effort, but with a little planning, it isn’t very difficult.</p>
<p class="indent">Perhaps the best solution is to create an RTM (see “<a href="ch09.xhtml#lev-9.2.3">The Requirements/Reverse Traceability Matrix</a>” on <a href="ch09.xhtml#page_178">page 178</a>), which tracks the links between the items in your system documentation. Although the RTM is yet another document you’ll have to maintain, it provides a complete and easy-to-use mechanism for tracking all the components in your system.</p>
<p class="indent">We’ll first talk through common tag formats, and then we’ll look into building an RTM.</p>
<h4 class="h4" id="lev-9.2.2"><strong><em>9.2.2 Tag Formats</em></strong></h4>
<p class="noindent">There is no particular standard for tag syntax; tags can take any form you like as long as the syntax is consistent and each tag is unique. For my own purposes (and for this book), I’ve created a syntax that incorporates elements of traceability directly into the tag. The tag formats that follow are organized by document type.</p>
<h5 class="h5" id="lev-9.2.2.1"><strong>9.2.2.1 SyRS Tags</strong></h5>
<p class="noindentb">For the SyRS, a tag takes the form [<em>productID</em>_SYRS_<em>xxx</em>] where:</p>
<p class="uln-indent1"><strong><em>productID</em></strong> Refers to the product or project. For example, for a swimming pool monitor application, <em>productID</em> might be “POOL.” You don’t want to use a long ID (four to five characters should be the maximum length) because it will be typed frequently.</p>
<p class="uln-indent1"><strong>SYRS</strong> States that this is a tag from the SyRS document (this is probably a system requirements tag).</p>
<p class="uln-indent1"><span epub:type="pagebreak" id="page_173"/><strong><em>xxx</em></strong> Represents one or more numbers, separated by periods if more than one integer is used. This numeric sequence uniquely identifies the tag within the SyRS.</p>
<p class="indenta">In a perfect world, all the SyRS requirements (and other items requiring a tag) would be numbered sequentially from 1 with no correlation between the integers and the meanings of the text blocks to which they refer.</p>
<p class="indent">Consider the following two requirements in an SyRS document:</p>
<p class="listhead1"><strong>[POOL_SYRS_001]: Pool temperature monitoring</strong></p>
<p class="listbody">The system shall monitor the pool temperature.</p>
<p class="listhead1"><strong>[POOL_SYRS_002]: Maximum pool temperature</strong></p>
<p class="listbody">The system shall turn on the “High Temp” LED if the pool temperature exceeds 86 degrees Fahrenheit.</p>
<p class="indenta">Let’s say that 150 additional requirements follow [POOL_SYRS_002].</p>
<p class="indent">Now suppose that someone suggests a requirement that the pool heater be turned on if the pool temperature drops below 70 degrees Fahrenheit. You could add the following requirements:</p>
<p class="listhead1"><strong>[POOL_SYRS_153]: Minimum pool temperature</strong></p>
<p class="listbody">The system shall turn on the pool heater if the pool temperature drops below 70 degrees Fahrenheit.</p>
<p class="listhead1"><strong>[POOL_SYRS_154]: Maximum heater on temperature</strong></p>
<p class="listbody">The system shall turn off the pool heater if the pool temperature exceeds 70 degrees Fahrenheit.</p>
<p class="indenta">In the SyRS, it makes sense to arrange related requirements close to one another, so the reader can locate all the pertinent requirements for a given feature at one point in the document. You can see why you wouldn’t want to sort the requirements by their tags—doing so would push the two new requirements for the pool heater to the end of the document, away from the other pool temperature requirements.</p>
<p class="indent">There’s nothing stopping you from moving the requirements together; however, it’s somewhat confusing to see a set of requirements like this:</p>
<p class="listhead1"><strong>[POOL_SYRS_001]: Pool temperature monitoring</strong></p>
<p class="listbody">The system shall monitor the pool temperature.</p>
<p class="listhead1"><strong>[POOL_SYRS_153]: Minimum pool temperature</strong></p>
<p class="listbody">The system shall turn on the pool heater if the pool temperature drops below 70 degrees Fahrenheit.</p>
<p class="listhead1"><strong>[POOL_SYRS_154]: Maximum heater on temperature</strong></p>
<p class="listbody">The system shall turn off the pool heater if the pool temperature exceeds 70 degrees Fahrenheit.</p>
<p class="listhead1"><span epub:type="pagebreak" id="page_174"/><strong>[POOL_SYRS_002]: Maximum pool temperature</strong></p>
<p class="listbody">The system shall turn on the “High Temp” LED if the pool temperature exceeds 86 degrees Fahrenheit.</p>
<p class="indenta">A better solution is to renumber the tags using <em>dotted sequences</em> to expand the tag numbers. A dotted sequence consists of two or more integers separated by a dot. For example:</p>
<p class="listhead1"><strong>[POOL_SYRS_001]: Pool temperature monitoring</strong></p>
<p class="listbody">The system shall monitor the pool temperature.</p>
<p class="listhead1"><strong>[POOL_SYRS_001.1]: Minimum pool temperature</strong></p>
<p class="listbody">The system shall turn on the pool heater if the pool temperature drops below 70 degrees Fahrenheit.</p>
<p class="listhead1"><strong>[POOL_SYRS_001.2]: Maximum heater on temperature</strong></p>
<p class="listbody">The system shall turn off the pool heater if the pool temperature exceeds 70 degrees Fahrenheit.</p>
<p class="listhead1"><strong>[POOL_SYRS_002]: Maximum pool temperature</strong></p>
<p class="listbody">The system shall turn on the “High Temp” LED if the pool temperature exceeds 86 degrees Fahrenheit.</p>
<p class="indenta">This allows you to flow in new requirements or changes anywhere. Note that 001.1 and 001.10 are not the same. These numbers are not floating-point numeric values; they’re two integers separated by a period. The number 001.10 is probably the 10th value in the sequence 001.1 through 001.10. Likewise, 001 is not the same as 001.0.</p>
<p class="indent">If you need to insert a requirement between 001.1 and 001.2, you can simply add another period to the end of the sequence, such as 001.1.1. You can also leave gaps between your tag numbers if you expect to insert additional tags in the future, like so:</p>
<p class="listhead1"><strong>[POOL_SYRS_010]: Pool temperature monitoring</strong></p>
<p class="listbody">The system shall monitor the pool temperature.</p>
<p class="listhead1"><strong>[POOL_SYRS_020]: Maximum pool temperature</strong></p>
<p class="listbody">The system shall turn on the “High Temp” LED if the pool temperature exceeds 86 degrees Fahrenheit.</p>
<p class="indenta">So when you decide to add the other two requirements, you have:</p>
<p class="listhead1"><strong>[POOL_SYRS_010]: Pool temperature monitoring</strong></p>
<p class="listbody">The system shall monitor the pool temperature.</p>
<p class="listhead1"><strong>[POOL_SYRS_013]: Minimum pool temperature</strong></p>
<p class="listbody">The system shall turn on the pool heater if the pool temperature drops below 70 degrees Fahrenheit.</p>
<p class="listhead1"><span epub:type="pagebreak" id="page_175"/><strong>[POOL_SYRS_017]: Maximum heater on temperature</strong></p>
<p class="listbody">The system shall turn off the pool heater if the pool temperature exceeds 70 degrees Fahrenheit.</p>
<p class="listhead1"><strong>[POOL_SYRS_020]: Maximum pool temperature</strong></p>
<p class="listbody">The system shall turn on the “High Temp” LED if the pool temperature exceeds 86 degrees Fahrenheit.</p>
<p class="indenta">Keep in mind that it’s important to make all the tags unique.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Thus far in this section, tags have been part of a paragraph title, which is useful when people want to search for the tags within the document (particularly, if the document is not in electronic form). However, you can also place tags within paragraphs.</em></p>
</div>
<h5 class="h5" id="lev-9.2.2.2"><strong>9.2.2.2 SRS Tags</strong></h5>
<p class="noindent">For system document sets that have only the SRS—not an SyRS—as the requirements document, “SRS” can simply replace “SYRS” in the tag: [POOL_SRS_010]: Pool temperature monitoring.</p>
<p class="indent">However, when a project’s document set includes both an SyRS and an SRS, this book uses a convention that builds reverse traceability from the SRS to the SyRS directly into the SRS tag. Such SRS tags have the format [<em>productID</em>_SRS_<em>xxx_yyy</em>].</p>
<p class="indent">The <em>productID</em> is the same as for the SyRS tag: SRS denotes a Software Requirements Specification tag (versus a System Requirements Specification tag), and <em>xxx</em> and <em>yyy</em> are decimal numbers, where <em>xxx</em> is the number of a corresponding SyRS tag (see “<a href="#lev-9.2.2.1">SyRS Tags</a>” on <a href="ch09.xhtml#page_172">page 172</a>).</p>
<p class="indent">Including the tag number of the parent SyRS requirement embeds reverse traceability information for an SRS requirement directly into its tag. Because almost all SRS requirements are derived from a corresponding SyRS tag, and there is a one-to-many relationship between SyRS requirements and SRS requirements, a single SyRS requirement can generate one or more SRS requirements, but each SRS requirement can be traced back to just one SyRS requirement, as shown in <a href="ch09.xhtml#ch9fig2">Figure 9-2</a>.</p>
<div class="image"><a id="ch9fig2"/><img src="Images/fig9-2.jpg" alt="image" width="171" height="157"/></div>
<p class="figcap"><em>Figure 9-2: An SyRS-to-SRS relationship</em></p>
<p class="indentb"><span epub:type="pagebreak" id="page_176"/>The <em>yyy</em> component is the SRS tag value. As a general rule (and the convention this book follows), <em>yyy</em> doesn’t have to be unique among all the SRS tags, but the combination <em>xxx_yyy</em> must be unique. The following are all valid (and unique) SRS tags:</p>
<p class="uln-indent1">[POOL_SRS_020_001]</p>
<p class="uln-indent1">[POOL_SRS_020_001.5]</p>
<p class="uln-indent1">[POOL_SRS_020_002]</p>
<p class="uln-indent1">[POOL_SRS_030.1_005]</p>
<p class="uln-indent1">[POOL_SRS_031_003]</p>
<p class="indenta">This book also uses the convention of restarting the <em>yyy</em> numbering with each <em>xxx</em> value.</p>
<p class="indent">By constructing SRS tags this way, you build automatic reverse traceability from the SRS to the SyRS directly into the tag identifier. To locate the SyRS requirement associated with an SRS requirement, just extract the <em>xxx</em> value and search for the corresponding tag in your SyRS document. It’s also easy to locate SRS tags associated with an SyRS tag in the SRS document. For example, to find all SRS requirements associated with POOL_SYRS_030, search for all instances of “SRS_030” in your SRS document.</p>
<p class="indent">It’s possible that an SRS document might produce some brand-new requirements that are not based on a specific SyRS requirement. If so, there won’t be an <em>xxx</em> number to use as part of the SRS tag. This book reserves SyRS tag number 000 (that is, there will never be an SyRS tag [<em>productID</em>_SYRS_000]), and any new SRS requirement that isn’t based on an SyRS requirement will take the form [<em>productID</em>_SRS_000_<em>yyy</em>].</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Another convention this book uses is to substitute an asterisk (*) in place of the</em> 000 <em>value.</em></p>
</div>
<p class="indent">It’s a good idea to include all software-related requirements from the SyRS directly in the SRS.<sup><a href="ch19_footnote.xhtml#ch09fn3" id="ch09fn3a">3</a></sup> This allows the SRS to serve as a stand-alone document for software developers to use. When copying SyRS requirements directly into the SRS, we’ll use the syntax [<em>productID</em>_SRS_<em>xxx</em>_000] for the copied requirement tags. That is, a <em>yyy</em> value of 000 denotes a copied tag.</p>
<h5 class="h5" id="lev-9.2.2.3"><strong>9.2.2.3 SDD Tags</strong></h5>
<p class="noindent">Unfortunately, there is not a one-to-many relationship between SRS requirements and SDD design elements.<sup><a href="ch19_footnote.xhtml#ch09fn4" id="ch09fn4a">4</a></sup> That makes it more difficult to build reverse traceability from an SDD tag to the corresponding SRS tag <span epub:type="pagebreak" id="page_177"/>into the SDD tag syntax. You’ll have to rely on an external RTM document to provide the links between the SRS and SDD documents.</p>
<p class="indent">Given that reverse traceability is not practical in the SDD tag, this book uses the simplified SDD tag format [<em>productID</em>_SDD_<em>ddd</em>], where <em>productID</em> has the usual meaning, and <em>ddd</em> is a unique identifier similar to <em>xxx</em> in the SyRS tag.</p>
<h5 class="h5" id="lev-9.2.2.4"><strong>9.2.2.4 STC Tags</strong></h5>
<p class="noindent">There should be a one-to-many relationship between SRS requirements and STC test cases, as shown in <a href="ch09.xhtml#ch9fig3">Figure 9-3</a>.</p>
<div class="image"><a id="ch9fig3"/><img src="Images/fig9-3.jpg" alt="image" width="171" height="157"/></div>
<p class="figcap"><em>Figure 9-3: An SRS-to-STC tag relationship</em></p>
<p class="indent">This means you can build reverse traceability from the STC to the SRS into the tags, just as you did from the SRS to the SyRS. For STC tags, this book uses the syntax [<em>productID</em>_STC_<em>xxx_yyy_zzz</em>]. If all your <em>yyy</em> values were unique (rather than the <em>xxx_yyy</em> combination being unique), you could drop the <em>xxx</em> from the tag, but having both <em>xxx</em> and <em>yyy</em> does provide reverse traceability to both the SRS and SyRS, which can be convenient (at the expense of extra typing for your STC tags).</p>
<p class="indent">Although it rarely occurs, it’s possible to create a unique test case that isn’t based on any SRS requirement.<sup><a href="ch19_footnote.xhtml#ch09fn5" id="ch09fn5a">5</a></sup> For example, the software engineers using the SDD to implement the code might create test cases based on the source code they write. In such situations, this book uses the scheme shown previously for SRS requirements that aren’t based on an SyRS requirement: we reserve the <em>xxx</em>_<em>yyy</em> value of 000_000 or *_*, and any new STC tags that aren’t based on a requirement tag will use 000 as the tag number suffix. An <em>xxx</em>_000 component means that the test case is based on an SyRS requirement but not any underlying SRS requirement (or perhaps it’s based on the SRS tag copied from the SyRS using the syntax shown earlier); this is not a stand-alone test case.</p>
<p class="indent"><span epub:type="pagebreak" id="page_178"/>STC tags that have the numeric form 000_000 don’t contain any traceability information. In such cases, you’ll need to explicitly provide link information to describe the origin of the test case. Here are a few suggestions:</p>
<ul>
<li class="noindent">Use <em>:source</em> after the tag to describe the source of the test case (where <em>source</em> is the name of the file or other document containing the information producing the test case).</li>
<li class="noindent">Use an RTM to provide the source information (see the next section, “The Requirements/Reverse Traceability Matrix,” for more details).</li>
<li class="noindent">Ensure that the document containing the source of the test case contains a comment or other link specifying the STC tag.</li>
</ul>
<h5 class="h5" id="lev-9.2.2.5"><strong>9.2.2.5 STP Tags</strong></h5>
<p class="noindent">STC test cases have a many-to-one relationship with STP test procedures, as shown in <a href="ch09.xhtml#ch9fig4">Figure 9-4</a>.</p>
<div class="image"><a id="ch9fig4"/><img src="Images/fig9-4.jpg" alt="image" width="184" height="157"/></div>
<p class="figcap"><em>Figure 9-4: An STC-to-STP tag relationship</em></p>
<p class="indent">This means, as with the SDD, you can’t encode reverse traceability information into the STP tags. Therefore, for STP tags this book uses the syntax [<em>productID</em>_STP_<em>ppp</em>], where <em>productID</em> has the usual meaning, and <em>ppp</em> is a unique STP tag value.</p>
<h4 class="h4" id="lev-9.2.3"><strong><em>9.2.3 The Requirements/Reverse Traceability Matrix</em></strong></h4>
<p class="noindent">As mentioned, it isn’t possible to build reverse traceability into the SDD and STP tags, so you’ll need the Requirements/Reverse Traceability Matrix (RTM).</p>
<p class="indent">As its name implies, an RTM is a two-dimensional matrix, or table, wherein:</p>
<ul>
<li class="noindent">Each row specifies a link between requirements, design items, test cases, or test procedures.</li>
<li class="noindent">Each column specifies a particular document (SyRS, SRS, SDD, STC, or STP).</li>
<li class="noindent">Each cell contains the tag for the associated document type.</li>
</ul>
<p class="indent">A typical row in the table might contain entries such as the following:</p>
<div class="image"><img src="Images/page_178.jpg" alt="image" width="800" height="31"/></div>
<p class="indent"><span epub:type="pagebreak" id="page_179"/>In general, the SyRS or SRS requirement tags drive the RTM, and you’d usually organize the table by sorting it via these columns.</p>
<p class="indentb">Because there is a one-to-many relationship between SyRS requirements and SRS requirements, you might need to replicate the SyRS requirements across multiple rows, as in this example:</p>
<div class="image"><img src="Images/page_179_1.jpg" alt="image" width="900" height="161"/></div>
<p class="indenta">Rows 1, 2, and 3 share the same SyRS tag with different SRS tags; rows 3 and 4 share the same SRS tags (and SyRS tags) with differing STC tags.</p>
<p class="indentb">Sometimes, it might be cleaner to omit duplicate SyRS and SRS tags when they can be inferred from previous rows, like so:</p>
<div class="image"><img src="Images/page_179_2.jpg" alt="image" width="900" height="164"/></div>
<p class="indenta">Although you could create an RTM using a word processor (for example, Microsoft Word or Apple Pages), a far better solution is to use a spreadsheet program (for example, Microsoft Excel or Apple Numbers) or a database application, which allows you to easily sort the rows in the table based on your current requirements. This book assumes you’re using a spreadsheet program.</p>
<h5 class="h5" id="lev-9.2.3.1"><strong>9.2.3.1 Adding Extra Columns</strong></h5>
<p class="noindent">At a bare minimum, you’ll want one column in the RTM for each system document type—SyRS (if present), SRS, SDD, STC, and STP—but you might want to include other information in the RTM as well. For example, you might consider a “Description” column that can help make sense of all the tags.</p>
<p class="indent">Or, if you have an SyRS document, an “Allocations” column might be useful to specify whether an SyRS item is hardware, software, or other. Note that SRS, SDD, STP, and STC (by definition) are always software related, so the Allocations entry would be either “N/A” (not applicable) or always “software” for such tags.</p>
<p class="indent">Another useful column might be “Verification,” which describes how a particular requirement might be tested (or verified) in the system. Examples of verification types might be test (as part of a software test procedure), by review, by inspection, by design, by analysis, other, or no test possible.</p>
<p class="indent"><span epub:type="pagebreak" id="page_180"/>One last option is an additional column (or columns) containing some row numbers you can use to quickly sort data in different ways. For example, you might add a column numbered 1 through <em>n</em> (where <em>n</em> is the number of rows) that, when sorted, lists the rows in order of requirements (SyRS and SRS); another column numbered 1 through <em>n</em> that could order the rows by SDD tag values; and so on.</p>
<h5 class="h5" id="lev-9.2.3.2"><strong>9.2.3.2 Sorting the RTM</strong></h5>
<p class="noindentb">Of course, if you fill in every cell in the matrix, you can sort by column values (or multiple column values). For example, suppose you’re using Microsoft Excel and the columns are organized as follows:</p>
<p class="uln-indent1">A:	Description</p>
<p class="uln-indent1">B:	SyRS tags</p>
<p class="uln-indent1">C:	Allocations</p>
<p class="uln-indent1">D:	SRS tags</p>
<p class="uln-indent1">E:	Testing method</p>
<p class="uln-indent1">F:	SDD tags</p>
<p class="uln-indent1">G:	STC tags</p>
<p class="uln-indent1">H:	STP tags</p>
<p class="indenta">Sorting by column B, then by D, then by G, will sort the document in requirements order. Sorting by column F, then by B, then by D, will sort the document in design element order. Sorting by column H, then by D, then by G, will sort the document in test procedure order.</p>
<p class="indent">To use the RTM to trace from an SyRS or SRS requirement to an SRS requirement, SDD design item, STC test case, or STP test procedure, simply sort the matrix by requirements order, find the SyRS or SRS tag you’re interested in, and then pick out the corresponding tag(s) for the other document(s) from the same row as the requirement tag. You can use this same scheme to trace from STC tags to the corresponding test procedure (because the requirements sort will also sort the test case tags).</p>
<p class="indentb">Reverse traceability from STC to SRS to SyRS is inherent in the tag syntax, so nothing special is needed for this operation. Reverse traceability from the SDD to the SRS (or SyRS) and from the STP to the STC/SRS/SyRS is a little more involved. First, sort the matrix by SDD tag order or STP tag order. This will give you a list of SDD or STP tags all collected together (and sorted in lexicographical order). Now all the tags on the rows containing a particular SDD or STP tag will be the tags of interest to you. The following example shows the previous RTM examples sorted by test procedure:</p>
<div class="image"><img src="Images/page_180.jpg" alt="image" width="800" height="143"/></div>
<p class="indenta"><span epub:type="pagebreak" id="page_181"/>In this table, you can easily see that test procedure 005 is associated with SyRS tag 020 and SRS tags 020_001 and 020_002. In this simple example, you wouldn’t have to sort the data to determine these links. But with a more complex RTM (with dozens, hundreds, or even thousands of requirements), it would be significantly more work to manually search for these reverse links if the table wasn’t sorted by STP tags.</p>
<h3 class="h3" id="lev-9.3"><strong>9.3 Validation, Verification, and Reviews</strong></h3>
<p class="noindent">Validation (see “<a href="ch03.xhtml#lev-3.2.4">The Iterative Model</a>” on <a href="ch03.xhtml#page_46">page 46</a>) is the process of showing that the product meets the end users’ needs (that is, “Are we building the right product?”), while verification is ensuring that you’ve built it to satisfy the project specifications (that is, “Are we building the product right?”). While validation takes place at the end of the requirements phase(s) and at the end of the entire development cycle (see “<a href="ch09.xhtml#lev-9.4.1">Reducing Costs via Validation</a>” on <a href="ch09.xhtml#page_182">page 182</a>), verification typically occurs at the end of each phase in the software development process to ensure that the phase respects all the input requirements. For example, verification of the SDD would consist of ensuring that it covers all the requirements in the SRS document (the SRS requirements are the input to the SDD stage).</p>
<p class="indentb">The verification steps for each phase are as follows:</p>
<p class="uln-indent"><strong>SyRS/SRS</strong> Ensuring that the requirements in the document fully cover all the requirements provided by the customer—perhaps from UML use cases (see “<a href="ch04.xhtml#lev-4.2">The UML Use Case Model</a>” on <a href="ch04.xhtml#page_74">page 74</a>) or the customer’s functional specification.</p>
<p class="uln-indent"><strong>SDD</strong> Ensuring that the design covers all requirements. The input is the requirements from the SRS.</p>
<p class="uln-indent"><strong>STC</strong> Ensuring that at least one test case exists for each (testable) requirement. The inputs are the requirements from the SRS.</p>
<p class="uln-indent"><strong>STP</strong> Ensuring that all the test cases are covered by the test procedures. The inputs are the test cases from the STC (and, indirectly, the requirements on which the test cases are based).</p>
<p class="indenta">To verify each preceding phase, you’ll need to review the document resulting from it. The RTM will prove useful during these reviews. For example, when reviewing the SDD, you’d search for each requirement in the SRS, look up the corresponding SDD tag, and then verify that the design element implements the specified requirement. You’d use the same process to verify that the STC document covers all the requirements with test cases.</p>
<p class="indent">When you’re reviewing the code, the safest approach is to go through all the inputs to a phase (that is, requirements for the SDD and STC, and test cases for the STP) and physically check each input off after verifying that you properly handled it. This final list becomes part of the review document for that phase.</p>
<p class="indent">In the review process, you should also confirm the correctness of the outputs from the phase. For example, when reviewing the SRS, you should check <span epub:type="pagebreak" id="page_182"/>each requirement to make sure it’s useful (see “<a href="ch10.xhtml#lev-10.4">The Software Requirements Specification Document</a>” on <a href="ch10.xhtml#page_194">page 194</a>); when reviewing the SDD, you should make sure each design item is correct (for example, you’re using suitable algorithms and handling concurrent operations appropriately); when reviewing the STC documentation, you should ensure each test case properly tests the associated requirement; and when reviewing the STP, you should verify that each test procedure properly tests its associated test cases.</p>
<p class="indent">If at all possible, and for the best results, an engineer other than the document author should conduct the final, formal review, or a second engineer should participate in the review process. The document author is more likely to gloss over an omission, because they’re too close to that portion of the project and could mentally fill in missing elements during the review. Of course, they should do their own review of the document prior to submitting it for formal review.</p>
<h3 class="h3" id="lev-9.4"><strong>9.4 Reducing Development Costs Using Documentation</strong></h3>
<p class="noindent">Documentation costs are often a major component of a project’s overall cost. Part of the reason is that there is so <em>much</em> documentation. But another reason is that the documents are interdependent, which makes them difficult to update and maintain. In <em>Code Complete</em> (Microsoft Press, 2004), Steve McConnell reports that, compared to the requirements phase, correcting errors is 3 times more expensive during the design (architectural) phase, 5 to 10 times more expensive during coding, and 10 times more expensive during system testing. There a couple of reasons for this:</p>
<ul>
<li class="noindent">If you fix a defect early in the development process, you don’t waste time writing additional documentation, coding, and testing defective designs. For example, it takes time to write the SDD documentation for a requirement, to write code to implement that requirement, to write test cases and test procedures for the requirement, and to run those tests. If the requirement was wrong to begin with, you’ve wasted all that effort.</li>
<li class="noindent">If you discover a defective item in one phase of the system, you have to locate and edit anything associated with that defect throughout the rest of the system. This can be laborious work, and it’s easy to miss changes, which creates inconsistencies and other problems down the line.</li>
</ul>
<h4 class="h4" id="lev-9.4.1"><strong><em>9.4.1 Reducing Costs via Validation</em></strong></h4>
<p class="noindent">Nowhere is the validation activity more important than in the requirements phase (SyRS and SRS development). If you insist that the customer understands and approves all requirements before moving on to later phases, you can ensure there are no unwanted requirements and that you’re solving the customer’s problems. Few things are worse than spending several months documenting, coding, and testing a program’s feature only to have the customer say, “This isn’t what we were asking for.” A good validation process can help reduce the likelihood of this scenario.</p>
<p class="indent"><span epub:type="pagebreak" id="page_183"/>Validation, which should take place at the end of the requirements phase(s) and at the end of the development cycle, involves asking the following questions:</p>
<p class="uln-indent"><strong>SyRS (if present)</strong></p>
<ol>
<li class="noindent">Is each existing requirement important? Does the requirement describe some feature that the customer wants?</li>
<li class="noindent">Is each requirement correct? Does it precisely state (without ambiguity) exactly what the customer wants?</li>
<li class="noindent">Are there any missing requirements?</li>
</ol>
<p class="uln-indent1"><strong>SRS</strong></p>
<ol>
<li class="noindent">Are all software requirements listed in the SyRS (if present) also listed in the SRS?</li>
<li class="noindent">Is each existing requirement important? Is this feature important to the system architect and agreed upon by the customer?</li>
<li class="noindent">Is each requirement correct? Does it precisely state (without ambiguity) exactly what the software must do to be effective?</li>
<li class="noindent">Are there any missing requirements?</li>
</ol>
<p class="indent">During final acceptance testing, the test engineer(s) should have a list of all the requirements in the SRS in a checkbox form. They should check off each requirement as it’s tested (perhaps when following the test procedures in the STP) to ensure that the software implements it correctly.</p>
<h4 class="h4" id="lev-9.4.2"><strong><em>9.4.2 Reducing Costs via Verification</em></strong></h4>
<p class="noindent">As mentioned in “Validation, Verification, and Reviews” on <a href="ch09.xhtml#page_181">page 181</a>, verification should occur after each phase of the software development process. In particular, there should be a verification step associated with each of the system documents after the SRS. Here are some questions you might ask after completing each document:</p>
<p class="uln-indent"><strong>SDD</strong></p>
<ol>
<li class="noindent">Do the design components completely cover all the requirements in the SRS?</li>
<li class="noindent">Is there a many-to-one (or one-to-one) relationship between requirements (many) and software design elements (one)? Although a design item might satisfy multiple requirements, it should not take multiple design elements to satisfy a single requirement.</li>
<li class="noindent">Does a software design element provide an accurate design that will implement the given requirement(s)?</li>
</ol>
<p class="uln-indent"><span epub:type="pagebreak" id="page_184"/><strong>STC</strong></p>
<ol>
<li class="noindent">Is there a one-to-many (or one-to-one) relationship between requirements and test cases? (That is, a requirement can have multiple associated test cases, but you shouldn’t have multiple requirements sharing the same test case.<sup><a href="ch19_footnote.xhtml#ch09fn6" id="ch09fn6a">6</a></sup>)</li>
<li class="noindent">Does a particular test case accurately test the associated requirement?</li>
<li class="noindent">Do all the test cases associated with a requirement completely test the correct implementation of that requirement?</li>
</ol>
<p class="uln-indent"><strong>STP</strong></p>
<ol>
<li class="noindent">Is there a many-to-one relationship between test cases in the STC and test procedures in the STP? That is, does a test procedure implement one or more test cases while each test case is handled by exactly one test procedure?</li>
<li class="noindent">Does a given test procedure accurately implement all its associated test cases?</li>
</ol>
<h3 class="h3" id="lev-9.5"><strong>9.5 For More Information</strong></h3>
<p class="ref">Bremer, Michael. <em>The User Manual Manual: How to Research, Write, Test, Edit, and Produce a Software Manual</em>. Grass Valley, CA: UnTechnical Press, 1999. A sample chapter is available at <em><a href="http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf">http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf</a></em>.</p>
<p class="ref">IEEE. “IEEE Standard 830-1998: IEEE Recommended Practice for Software Requirements Specifications.” October 20, 1998. <em><a href="https://doi.org/10.1109/IEEESTD.1998.88286">https://doi.org/10.1109/IEEESTD.1998.88286</a></em>.</p>
<p class="ref">Leffingwell, Dean, and Don Widrig. <em>Managing Software Requirements</em>. Boston: Addison-Wesley Professional, 2003.</p>
<p class="ref">McConnell, Steve. <em>Code Complete</em>. 2nd ed. Redmond, WA: Microsoft Press, 2004.</p>
<p class="ref">Miles, Russ, and Kim Hamilton. <em>Learning UML 2.0: A Pragmatic Introduction to UML</em>. Sebastopol, CA: O’Reilly Media, 2003.</p>
<p class="ref">Pender, Tom. <em>UML Bible</em>. Indianapolis: Wiley, 2003.</p>
<p class="ref">Roff, Jason T. <em>UML: A Beginner’s Guide</em>. Berkeley, CA: McGraw-Hill Education, 2003.</p>
<p class="ref">Wiegers, Karl E. <em>Software Requirements</em>. Redmond, WA: Microsoft Press, 2009.</p>
<p class="ref">———. “Writing Quality Requirements.” <em>Software Development</em> 7, no. 5 (May 1999): 44–48.</p>
</div>



  </body></html>