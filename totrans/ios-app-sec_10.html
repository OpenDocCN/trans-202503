<html><head></head><body>
<h2 class="h2" id="ch07"><a id="page_107"/><strong><span class="big">7</span></strong><br/><strong>IOS NETWORKING</strong></h2>
<p class="noindent">Almost all applications use one or more of three iOS network APIs. In order of abstraction, these are the URL loading system, the Foundation <code>NSStream</code> API, and the Core Foundation <code>CFStream</code> API. The URL loading system is used for fetching and manipulating data, such as network resources or files, via URLs. The <code>NSStream</code> and <code>CFStream</code> classes are slightly lower-level methods to deal with network connections, without going quite so low as the socket level. These classes are used for non-HTTP-based communications, or where you need more direct control over network behavior.</p>
<p class="indent">In this chapter, I’ll discuss iOS networking in detail, starting from the high-level APIs. For most purposes, apps can stick with the higher-level APIs, but there are some cases where you can’t quite bend those APIs to your will. With lower-level APIs, however, there are more pitfalls to consider.</p>
<h3 class="h3" id="ch07lev1sec01"><a id="page_108"/><strong>Using the iOS URL Loading System</strong></h3>
<p class="noindent">The URL loading system can handle most network tasks an app will need to perform. The primary method of interacting with the URL API is by constructing an <code>NSURLRequest</code> object and using it to instantiate an <code>NSURLConnection</code> object, along with a delegate that will receive the connection’s response. When the response is fully received, the delegate will be sent a <code>connection:didReceiveResponse</code> message, with an <code>NSURLResponse</code> object as the supplied parameter.<sup><a href="footnote.html#fn62" id="fn_62">1</a></sup></p>
<p class="indent">But not everyone uses the powers of the URL loading system properly, so in this section, I’ll first show you how to spot an app that bypasses Transport Layer Security. Then, you’ll learn how to authenticate endpoints through certificates, avoid the dangers of open redirects, and implement certificate pinning to limit how many certificates your app trusts.</p>
<h4 class="h4" id="ch07lev2sec01"><em><strong>Using Transport Layer Security Correctly</strong></em></h4>
<p class="noindent"><em>Transport Layer Security (TLS)</em>, the modern specification supplanting SSL, is crucial to the security of almost any networked application. When used correctly, TLS both keeps the data transmitted over a connection confidential and authenticates the remote endpoint, ensuring that the certificate presented is signed by a trusted certificate authority. By default, iOS does the Right Thing™ and refuses to connect to any endpoint with an untrusted or invalid certificate. But all too frequently, in applications of all kinds, mobile and otherwise, developers explicitly disable TLS/SSL endpoint validation, allowing the application’s traffic to be intercepted by network attackers.</p>
<p class="indent">In iOS, TLS can be disabled a number of ways. In the past, developers would often use the undocumented <code>setAllowsAnyHTTPSCertificate</code> private class method of <code>NSURLRequest</code> to easily disable verification. Apple fairly quickly started rejecting applications that used this method, as it tends to do with apps that use private APIs. There are, however, still obfuscation methods that may allow the use of this API to slip past the approval process, so check codebases to ensure that the method isn’t just called by another name.</p>
<p class="indent">There’s an even more disastrous way to bypass TLS validation. It will also (probably) get your app rejected in this day and age, but it illustrates an important point about categories. I once had a client that licensed what should have been a fairly simple piece of third-party code and included it in their product. Despite handling TLS correctly everywhere else in the project, their updated version of the third-party code did not validate any TLS connections. Apparently, the third-party vendor had implemented a category of <code>NSURLRequest</code>, using the <code>allowsAnyHTTPSCertificateForHost</code> method to avoid validation. The category contained only the directive <code>return YES;</code>, causing all <code>NSURLRequests</code> to silently ignore bad certificates. The moral? Test things, and don’t make assumptions! Also, you have to audit third-party code <a id="page_109"/>along with the rest of your codebase. Mistakes might not be your fault, but nobody is likely to care about that.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>Thankfully, it’s much more difficult to make accidental TLS-disabling mistakes in iOS 9, as it by default does not allow applications to make non-TLS connections. Instead, developers are required to put a specific exception in the app’s</em> Info.plist <em>for URLs to be accessed over plaintext HTTP. However, this won’t solve cases of willful disabling of TLS protections.</em></p>
</div>
<p class="indent">Now, there is actually an official API to bypass TLS verification. You can use a delegate of <code>NSURLConnection</code> with the <code>NSURLConnectionDelegate</code> protocol.<sup><a href="footnote.html#fn63" id="fn_63">2</a></sup> The delegate must implement the <code>willSendRequestForAuthenticationChallenge</code> method, which can then call the <code>continueWithoutCredentialForAuthenticationChallenge</code> method. This is the current, up-to-date method; you may also see older code that uses <code>connection:canAuthenticateAgainstProtectionSpace:</code> or <code>connection:didReceiveAuthenticationChallenge:</code>. <a href="ch07.html#ch7ex1">Listing 7-1</a> shows an example of how you might see this done in the wild.</p>
<pre>- (<span class="rose">void</span>)<span class="violet">connection</span>:(<span class="violet1">NSURLConnection</span> *)<span class="violet">connection</span><br/>     <span class="violet">willSendRequestForAuthenticationChallenge</span>:(<span class="violet1">NSURLAuthenticationChallenge</span> *)<br/>     challenge {<br/>    <span class="violet1">NSURLProtectionSpace</span> *space = [challenge protectionSpace];<br/>    <span class="rose">if</span>([[space authenticationMethod] <span class="violet">isEqualToString</span>:<span class="violet1">NS</span><br/>     <span class="violet1">URLAuthenticationMethodServerTrust])</span> {<br/>        <span class="violet1">NSURLCredential</span> *cred = [<span class="violet1">NSURLCredential</span> <span class="violet">credentialForTrust</span>:<br/>     [space serverTrust]];<br/>        [[challenge sender] useCredential:cred forAuthenticationChallenge:<br/>     challenge];<br/>    }<br/>}</pre>
<p class="listcap"><a id="ch7ex1"/><em>Listing 7-1: Sending a dummy</em> <code>NSURLCredential</code> <em>in response to the challenge</em></p>
<p class="indent">This code looks rather benign, especially since it uses the words <em>protection</em>, <em>credential</em>, <em>authentication</em>, and <em>trust</em> all over the place. What it actually does is bypass verification of the TLS endpoint, leaving the connection susceptible to interception.</p>
<p class="indent">Of course, I’m not encouraging you to actually <em>do</em> anything to bypass TLS verification in your app. You shouldn’t, and you’re a bad person if you do. These examples just show the pattern that you may see in code that you have to examine. These patterns can be difficult to spot and understand, but if you see code that bypasses TLS verification, be sure to change it.</p>
<h4 class="h4" id="ch07lev2sec02"><a id="page_110"/><em><strong>Basic Authentication with NSURLConnection</strong></em></h4>
<p class="noindent">HTTP basic authentication isn’t a particularly robust authentication mechanism. It doesn’t support session management or password management, and therefore, the user can’t log out or change their password without using a separate application. But for some tasks, such as authenticating to APIs, these issues are less important, and you still might run across this mechanism in an app’s codebase—or be required to implement it yourself.</p>
<p class="indent">You can implement HTTP basic authentication using either <code>NSURLSession</code> or <code>NSURLConnection</code>, but there are a couple of pitfalls that you’ll want to be aware of, whether you’re writing an app or examining someone else’s code.</p>
<p class="indent">The simplest implementation uses the <code>willSendRequestForAuthenticationChallenge</code> delegate method of <code>NSURLConnection</code>:</p>
<pre>- (<span class="rose">void</span>)<span class="violet">connection</span>:(<span class="violet1">NSURLConnection</span> *)<span class="violet">connection</span><br/>     <span class="violet">willSendRequestForAuthenticationChallenge</span>:(<span class="violet1">NSURLAuthenticationChallenge</span> *)<br/>     challenge {<br/>    <span class="violet1">NSString</span> *user = <span class="red">@"user"</span>;<br/>    <span class="violet1">NSString</span> *pass = <span class="red">@"pass"</span>;<br/><br/><br/>    <span class="rose">if</span> ([[challenge protectionSpace] receivesCredentialSecurely] == YES &amp;&amp;<br/>        [[[challenge protectionSpace] host] <span class="violet">isEqualToString</span>:<span class="red">@"myhost.com"</span>]) {<br/><br/>    <span class="violet1">NSURLCredential</span> *credential = [<span class="violet1">NSURLCredential</span> credentialWithUser:user password<br/>     :pass persistence<span class="violet1">:NSURLCredentialPersistenceForSession];</span><br/><br/>    [[challenge sender] useCredential:credential<br/>           forAuthenticationChallenge:challenge];<br/>    }<br/>}</pre>
<p class="indent">The delegate is first passed an <code>NSURLAuthenticationChallenge</code> object. It then creates a credential with a username and password, which can be either provided by the user or pulled from the Keychain. Finally, the sender of the challenge is passed the credential and challenge in return.</p>
<p class="indent">There are two potential problems to pay attention to when implementing HTTP basic authentication in this way. First, avoid storing the username and password within either the source code or the shared preferences. You can use the <code>NSURLCredentialStorage</code> API to store user-supplied credentials in the Keychain automatically, using <code>sharedCredentialStorage</code>, as shown in <a href="ch07.html#ch7ex2">Listing 7-2</a>.</p>
<pre><a id="page_111"/><span class="ent">➊</span> <span class="violet1">NSURLProtectionSpace</span> *protectionSpace = [[<span class="violet1">NSURLProtectionSpace</span> <span class="violet">alloc</span>] initWithHost:<br/>        <span class="red">@"myhost.com"</span> port:443 protocol:<span class="red">@"https"</span> realm:nil authenticationMethod:nil];<br/><br/><span class="ent">➋</span> <span class="violet1">NSURLCredential</span> *credential = [<span class="violet1">NSURLCredential</span> credentialWithUser:user password:<br/>        pass persistence:<span class="violet1">NSURLCredentialPersistencePermanent];</span><br/><br/><span class="ent">➌</span> <span class="violet1">[[NSURLCredentialStorage sharedCredentialStorage]</span> setDefaultCredential:credential<br/>        forProtectionSpace:protectionSpace];</pre>
<p class="listcap"><a id="ch7ex2"/><em>Listing 7-2: Setting the default credentials of a protection space</em></p>
<p class="indent">This simply creates a protection space <span class="ent">➊</span>, which includes the host, the port, the protocol, and optionally the HTTP authentication realm (if using HTTP basic authentication) and the authentication method (for example, using NTLM or another mechanism). At <span class="ent">➋</span>, the example creates a credential with the username and password that it most likely received from user input. It then sets that to the default credential for this protection space at <span class="ent">➌</span>, and the credential should be automatically stored in the Keychain. In the future, the app this code belongs to can read credentials with the same API, using the <code>defaultCredentialForProtectionSpace</code> method, as shown in <a href="ch07.html#ch7ex3">Listing 7-3</a>.</p>
<pre>credentialStorage = [[<span class="violet1">NSURLCredentialStorage</span> sharedCredentialStorage]<br/>     defaultCredentialForProtectionSpace:protectionSpace];</pre>
<p class="listcap"><a id="ch7ex3"/><em>Listing 7-3: Using the default credential for a protection space</em></p>
<p class="indent">Note, however, that credentials stored in <code>sharedCredentialStorage</code> are marked with the Keychain attribute <code>kSecAttrAccessibleWhenUnlocked</code>. If you need stricter protections, you’ll need to manage Keychain storage yourself. I talk more about managing the Keychain in <a href="ch13.html#ch13">Chapter 13</a>.</p>
<p class="indent">Also, be sure to pay attention to how you specify the value of the <code>persistence</code> argument when creating the credential. If you’re storing in the Keychain using <code>NSURLCredentialStorage</code>, you can use either the <code>NSURLCredentialPersistencePermanent</code> or <code>NSURLCredentialPersistenceSynchronizable</code> types when creating your credentials. If you’re using the authentication for something more transient, the <code>NSURLCredentialPersistenceNone</code> or <code>NSURLCredentialPersistenceForSession</code> types are more appropriate. You can find details on what each of these persistence types mean in <a href="ch07.html#ch7tab1">Table 7-1</a>.</p>
<p class="tablecap"><a id="page_112"/><a id="ch7tab1"/><strong>Table 7-1:</strong> Credential Persistence Types</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="80%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Persistence type</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Meaning</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table"><code>NSURLCredentialPersistenceNone</code></p></td>
<td class="table" valign="top"><p class="table">Don’t store the credential at all. Use this only when you need to make a single request to a protected resource.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>NSURLCredentialPersistenceForSession</code></p></td>
<td class="table" valign="top"><p class="table">Persist the credential for the lifetime of your application.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>NSURLCredentialPersistencePermanent</code></p></td>
<td class="table" valign="top"><p class="table">Store the credential in the Keychain.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>NSURLCredentialPersistenceForSession</code></p></td>
<td class="table" valign="top"><p class="table">Persist the credential for the lifetime of your application. Use this is if you need a credential just for the time your app remains running.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>NSURLCredentialPersistencePermanent</code></p></td>
<td class="table" valign="top"><p class="table">Store the credential in the Keychain. Use this when you’ll want this credential on a consistent basis as long as the user has the app installed.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>NSURLCredentialPersistenceSynchronizable</code></p></td>
<td class="table" valign="top"><p class="table">Store the credential in the Keychain, and allow it to be synchronized to other devices and iCloud. Use this when you want to have people transfer the credential between devices and don’t have concerns about sending the credential to a third party like iCloud.</p></td>
</tr>
</tbody>
</table>
<h4 class="h4" id="ch07lev2sec03"><em><strong>Implementing TLS Mutual Authentication with NSURLConnection</strong></em></h4>
<p class="noindent">One of the best methods of performing client authentication is to use a client certificate and private key; however, this is somewhat convoluted on iOS. The basic concept is relatively simple: implement a delegate for <code>willSendRequestForAuthenticationChallenge</code> (formerly <code>didReceiveAuthenticationChallenge</code>), check whether the authentication method is <code>NSURLAuthenticationMethodClientCertificate</code>, retrieve and load a certificate and private key, build a credential, and use the credential for the challenge. Unfortunately, there aren’t built-in Cocoa APIs for managing certificates, so you’ll need to muck about with Core Foundation a fair bit, like in this basic framework:</p>
<pre>   - (<span class="rose">void</span>)<span class="violet">connection</span>:(<span class="violet1">NSURLConnection</span> *) <span class="violet">willSendRequestForAuthenticationChallenge</span>:(<br/>        <span class="violet1">NSURLAuthenticationChallenge</span> *)challenge {<br/>       <span class="rose">if</span> ([[[challenge protectionSpace] authenticationMethod] <span class="violet">isEqualToString</span>:<span class="violet1">NS</span><br/>        <span class="violet1">URLAuthenticationMethodClientCertificate])</span> {<br/><br/>           <span class="green">SecIdentityRef</span> identity;<br/>           <span class="green">SecTrustRef</span> trust;<br/><span class="ent">➊</span>         <span class="green">extractIdentityAndTrus</span>t(somep12Data, &amp;identity, &amp;trust);<br/>           <span class="green">SecCertificateRef</span> certificate;<br/><span class="ent">➋</span>         SecIdentityCopyCertificate(identity, &amp;certificate);<br/><span class="ent">➌</span>         <span class="rose">const void</span> *certificates[] = { certificate };<br/><span class="ent">➍</span>         <span class="green">CFArrayRef</span> arrayOfCerts = CFArrayCreate(kCFAllocatorDefault, certificates,<br/>        1, NULL);<br/><br/><span class="ent">➎</span>         <span class="violet1">NSURLCredential</span> *cred = [<span class="violet1">NSURLCredential</span> credentialWithIdentity:identity<br/>        certificates:(__bridge <span class="violet1">NSArray*)arrayOfCerts</span><br/>         persistence:<span class="violet1">NSURLCredentialPersistenceNone];</span><br/><span class="ent">➏</span>         [[challenge sender] useCredential:cred<br/>                 forAuthenticationChallenge:challenge];<br/>       }<br/>   }</pre>
<p class="indent"><a id="page_113"/>This example creates a <code>SecIdentityRef</code> and <code>SecTrustRef</code> so that it has destinations to pass to the <code>extractIdentityAndTrust</code> function at <span class="ent">➊</span>. This function will extract the identity and trust information from a blob of PKCS #12 data (file extension <em>.p12</em>). These archive files just store a bunch of cryptography objects in one place.</p>
<p class="indent">The code then makes a <code>SecCertificateRef</code> into which it extracts the certificate from the identity <span class="ent">➋</span>. Next, it builds an array containing the one certificate at <span class="ent">➌</span> and creates a <code>CFArrayRef</code> to hold that certificate at <span class="ent">➍</span>. Finally, the code creates an <code>NSURLCredential</code>, passing in its identity and its array of certificates with only one element <span class="ent">➎</span>, and presents this credential as the answer to its challenge <span class="ent">➏</span>.</p>
<p class="indent">You’ll notice some handwaving around <span class="ent">➊</span>. This is because obtaining the actual certificate p12 data can happen a few different ways. You can perform a one-time bootstrap and fetch a newly generated certificate over a secure channel, generate a certificate locally, read one from the filesystem, or fetch one from the Keychain. One way to get the certificate information used in <code>somep12Data</code> is by retrieving it from the filesystem, like this:</p>
<pre><span class="violet1">NSData</span> *myP12Certificate = [<span class="violet1">NSData</span> dataWithContentsOfFile:path];<br/>CFDataRef somep12Data = (__bridge CFDataRef)myP12Certificate;</pre>
<p class="indent">The best place to store certificates of course is the Keychain; I’ll cover that further in <a href="ch13.html#ch13">Chapter 13</a>.</p>
<h4 class="h4" id="ch07lev2sec04"><em><strong>Modifying Redirect Behavior</strong></em></h4>
<p class="noindent">By default, <code>NSURLConnection</code> will follow HTTP redirects when it encounters them. However, its behavior when this happens is, well, unusual. When the redirect is encountered, <code>NSURLConnection</code> will send a request, containing the HTTP headers as they were used in the original <code>NSURLHttpRequest</code>, to the new location. Unfortunately, this also means that the current value of your cookies for the original domain is passed to the new location. As a result, if an attacker can get your application to visit a page on your site that accepts <a id="page_114"/>an arbitrary URL as a place to redirect to, that attacker can steal your users’ cookies, as well as any other sensitive data that your application might store in its HTTP headers. This type of flaw is called an <em>open redirect</em>.</p>
<p class="indent">You can modify this behavior by implementing <code>connect:willSendRequest: redirectResponse</code><sup><a href="footnote.html#fn64" id="fn_64">3</a></sup> on your <code>NSURLConnectionDelegate</code> in iOS 4.3 and older, or on your <code>NSURLConnectionDataDelegate</code> in iOS 5.0 and newer.<sup><a href="footnote.html#fn65" id="fn_65">4</a></sup></p>
<pre>   - (<span class="violet1">NSURLRequest</span> *)<span class="violet">connection</span>:(<span class="violet1">NSURLConnection</span> *)<span class="violet">connection</span><br/>                <span class="violet">willSendRequest</span>:(<span class="violet1">NSURLRequest</span> *)request<br/>               <span class="violet">redirectResponse</span>:(<span class="violet1">NSURLResponse</span> *)<span class="violet">redirectResponse</span><br/>   {<br/>       <span class="violet1">NSURLRequest</span> *newRequest = request;<br/><span class="ent">➊</span>     <span class="rose">if</span> (![[[<span class="violet">redirectResponse</span> URL] host] isEqual:<span class="red">@"myhost.com"</span>]) {<br/>           <span class="rose">return</span> newRequest;<br/>       }<br/><br/>       <span class="rose">else</span> {<br/><span class="ent">➋</span>         newRequest = nil;<br/>           <span class="rose">return</span> newRequest;<br/>       }<br/>   }</pre>
<p class="indent">At <span class="ent">➊</span>, this code checks whether the domain you’re redirecting to is different from the name of your site. If it’s the same, it carries on as normal. If it’s different, it modifies the request to be <code>nil</code> <span class="ent">➋</span>.</p>
<h4 class="h4" id="ch07lev2sec05"><em><strong>TLS Certificate Pinning</strong></em></h4>
<p class="noindent">In the past several years, there have been a number of troubling developments regarding certificate authorities (CAs), the entities that vouch for the TLS certificates that we encounter on a daily basis. Aside from the massive number of signing authorities trusted by your average client application, CAs have had several prominent security breaches where signing keys were compromised or where overly permissive certificates were issued. These breaches allow anyone in possession of the signing key to impersonate any TLS server, meaning they can successfully and transparently read or modify requests to the server and their responses.</p>
<p class="indent">To help mitigate these attacks, client applications of many types have implemented <em>certificate pinning</em>. This term can refer to a number of different techniques, but the core idea is to programmatically restrict the number of certificates that your application will trust. You could limit trust to a single <a id="page_115"/>CA (that is, the one that your company uses to sign its server certificates), to an internal root CA that you use to create your own certificates (the top of the chain of trust), or simply to a leaf certificate (a single specific certificate at the bottom of the chain of trust).</p>
<p class="indent">As part of the SSL Conservatory project, my colleague Alban Diquet has developed some convenient wrappers that allow you to implement certificate pinning in your application. (Learn more at <em><a href="https://github.com/iSECPartners/ssl-conservatory">https://github.com/iSECPartners/ssl-conservatory</a></em>.) You could write your own wrapper or use an existing one; either way, a good wrapper can make pinning rather simple. For example, here’s a look at how easy it would be to implement certificate pinning with Alban’s wrapper:</p>
<pre><span class="ent">➊</span> - (<span class="violet1">NSData*)</span><span class="violet">loadCertificateFromFile</span><span class="violet1">:(NSString*)fileName {</span><br/>       <span class="violet1">NSString</span> *certPath = [[<span class="violet1">NSString</span> <span class="violet">alloc</span>] initWithFormat:<span class="red">@"%@/%@"</span>, [[<span class="violet1">NSBundle</span><br/>        mainBundle] bundlePath], fileName];<br/>       <span class="violet1">NSData</span> *certData = [[<span class="violet1">NSData</span> <span class="violet">alloc</span>] initWithContentsOfFile:certPath];<br/>       <span class="rose">return</span> certData;<br/>   }<br/><br/>   - (<span class="rose">void</span>)pinThings {<br/>   <span class="violet1">NSMutableDictionary</span> *domainsToPin = [[<span class="violet1">NSMutableDictionary</span> <span class="violet">alloc</span>] <span class="violet">init</span>];<br/><br/><span class="ent">➋</span> <span class="violet1">NSData</span> *myCertData = [<span class="rose">self</span> <span class="violet">loadCertificateFromFile</span>:<span class="red">@"myCerts.der"</span>];<br/>   <span class="rose">if</span> (myCertData == nil) {<br/>       <span class="violet1">NSLog(</span><span class="red">@"Failed to load the certificates"</span><span class="violet1">);</span><br/>       <span class="rose">return</span>;<br/>       }<br/><br/><span class="ent">➌</span> [domainsToPin <span class="violet">setObject</span>:myCertData forKey:<span class="red">@"myhost.com"</span>];<br/><br/><span class="ent">➍</span> <span class="rose">if</span> ([<span class="green">SSLCertificatePinning</span> loadSSLPinsFromDERCertificates:domainsToPin] != YES) {<br/>       <span class="violet1">NSLog(</span><span class="red">@"Failed to pin the certificates"</span><span class="violet1">);</span><br/>       <span class="rose">return</span>;<br/>       }<br/>   }</pre>
<p class="indent">At <span class="ent">➊</span>, this code simply defines a method to load a certificate from a DER-formatted file into an <code>NSData</code> object and calls this method at <span class="ent">➋</span>. If this is successful, the code puts <code>myCertData</code> into an <code>NSMutableDictionary</code> <span class="ent">➌</span> and calls the <code>loadSSLPinsFromDERCertificates</code> method of the main <code>SSLCertificatePinning</code> class <span class="ent">➍</span>. With these pins loaded, an app would also need to implement an <code>NSURLConnection</code> delegate, as shown in <a href="ch07.html#ch7ex4">Listing 7-4</a>.</p>
<pre><a id="page_116"/>- (<span class="rose">void</span>)<span class="violet">connection</span>:(<span class="violet1">NSURLConnection</span> *)<span class="violet">connection</span><br/>     <span class="violet">willSendRequestForAuthenticationChallenge</span>:(<span class="violet1">NSURLAuthenticationChallenge</span> *)<br/>     challenge {<br/><br/>    <span class="rose">if</span>([challenge.protectionSpace.authenticationMethod <span class="violet">isEqualToString</span>:<span class="violet1">NS</span><br/>     <span class="violet1">URLAuthenticationMethodServerTrust])</span> {<br/><br/>        <span class="green">SecTrustRef</span> serverTrust = [[challenge protectionSpace] serverTrust];<br/>        <span class="violet1">NSString</span> *domain = [[challenge protectionSpace] host];<br/>        <span class="violet">SecTrustResultType</span> trustResult;<br/><br/>        <span class="violet">SecTrustEvaluate</span>(serverTrust, &amp;trustResult);<br/>        <span class="rose">if</span> (trustResult == kSecTrustResultUnspecified) {<br/><br/>            <span class="green1"><span class="codeitalic">// Look for a pinned public key in the server's certificate chain</span></span><br/>            <span class="rose">if</span> ([<span class="green">SSLCertificatePinning</span> verifyPinnedCertificateForTrust:serverTrust<br/>     andDomain:domain]) {<br/><br/>                <span class="green1"><span class="codeitalic">// Found the certificate; continue connecting</span></span><br/>                [challenge.sender useCredential:[<span class="violet1">NSURLCredential</span> <span class="violet">credentialForTrust</span><br/>     :challenge.protectionSpace.serverTrust] forAuthenticationChallenge:challenge];<br/>            }<br/>            <span class="rose">else</span> {<br/>                <span class="green1"><span class="codeitalic">// Certificate not found; cancel the connection</span></span><br/>                [[challenge sender] <span class="violet">cancelAuthenticationChallenge</span>: challenge];<br/>            }<br/>        }<br/>        <span class="rose">else</span> {<br/>            <span class="green1"><span class="codeitalic">// Certificate chain validation failed; cancel the connection</span></span><br/>            [[challenge sender] <span class="violet">cancelAuthenticationChallenge</span>: challenge];<br/>        }<br/>    }<br/>}</pre>
<p class="listcap"><a id="ch7ex4"/><em>Listing 7-4: An</em> <code>NSURLConnection</code> <em>delegate to handle certificate pinning logic</em></p>
<p class="indent">This simply evaluates the certificate chain presented by a remote server and compares it to the pinned certificates included with your application. If a pinned certificate is found, the connection continues; if it isn’t, the authentication challenge process is canceled.</p>
<p class="indent">With your delegate implemented as shown, all your uses of <code>NSURLConnection</code> should check to ensure that they are pinned to a domain and certificate pair in your predefined list. If you’re curious, you can <a id="page_117"/>find the rest of the code to implement your own certificate pinning at <em><a href="https://github.com/iSECPartners/ssl-conservatory/tree/master/ios">https://github.com/iSECPartners/ssl-conservatory/tree/master/ios</a></em>. There’s a fair bit of other logic involved, so I can’t show all the code here.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>If you’re in a hurry, a delegate that you can just subclass is included in the SSL Conservatory sample code.</em></p>
</div>
<p class="indent">Up to now, I’ve shown network security issues and solutions that revolve around <code>NSURLConnection</code>. But as of iOS 7, <code>NSURLSession</code> is preferred over the traditional <code>NSURLConnection</code> class. Let’s take a closer look at this API.</p>
<h3 class="h3" id="ch07lev1sec02"><strong>Using NSURLSession</strong></h3>
<p class="noindent">The <code>NSURLSession</code> class is generally favored by developers because it focuses on the use of network <em>sessions</em>, as opposed to <code>NSURLConnection</code>’s focus on individual requests. While broadening the scope of <code>NSURLConnection</code> somewhat, <code>NSURLSession</code> also gives additional flexibility by allowing configurations to be set on individual sessions rather than globally throughout the application. Once sessions are instantiated, they are handed individual tasks to perform, using the <code>NSURLSessionDataTask</code>, <code>NSURLSessionUploadTask</code>, and <code>NSURLSessionDownloadTask</code> classes.</p>
<p class="indent">In this section, you’ll explore some ways to use <code>NSURLSession</code>, some potential security pitfalls, and some security mechanisms not provided by the older <code>NSURLConnection</code>.</p>
<h4 class="h4" id="ch07lev2sec06"><em><strong>NSURLSession Configuration</strong></em></h4>
<p class="noindent">The <code>NSURLSessionConfiguration</code> class encapsulates options passed to <code>NSURLSession</code> objects so that you can have separate configurations for separate types of requests. For example, you can apply different caching and cookie policies to requests fetching data of varying sensitivity levels, rather than having these policies be app-wide. To use the system policies for <code>NSURLSession</code> configuration, you can use the default policy of <code>[NSURLSessionConfigurationdefaultConfiguration]</code>, or you can simply neglect to specify a configuration policy and instantiate your request object with <code>[NSURLSessionsharedSession]</code>.</p>
<p class="indent">For security-sensitive requests that should leave no remnants on local storage, the configuration method <code>ephemeralSessionConfiguration</code> should be used instead. A third method, <code>backgroundSessionConfiguration</code>, is available specifically for long-running upload or download tasks. This type of session will be handed off to a system service to manage completion, even if your application is killed or crashes.</p>
<p class="indent">Also, for the first time, you can specify that a connection use only TLS version 1.2, which helps defend against attacks such as BEAST<sup><a href="footnote.html#fn66" id="fn_66">5</a></sup> and <a id="page_118"/>CRIME,<sup><a href="footnote.html#fn67" id="fn_67">6</a></sup> both of which can allow network attackers to read or tamper with your TLS connections.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>Session configurations are read-only after an</em> <code><em>NSURLSession</em></code> <em>is instantiated; policies and configurations cannot be changed mid-session, and you cannot swap out for a separate configuration.</em></p>
</div>
<h4 class="h4" id="ch07lev2sec07"><em><strong>Performing NSURLSession Tasks</strong></em></h4>
<p class="noindent">Let’s walk through the typical flow of creating an <code>NSURLSessionConfiguration</code> and assigning it a simple task, as shown in <a href="ch07.html#ch7ex5">Listing 7-5</a>.</p>
<pre><span class="ent">➊</span> <span class="violet1">NSURLSessionConfiguration</span> *configuration = [<span class="violet1">NSURLSessionConfiguration</span><br/>        <span class="violet">ephemeralSessionConfiguration</span>];<br/><br/><span class="ent">➋</span> [configuration setTLSMinimumSupportedProtocol = kTLSProtocol12];<br/><br/><span class="ent">➌</span> <span class="violet1">NSURL</span> *url = [<span class="violet1">NSURL</span> URLWithString:<span class="red">@"https://www.mycorp.com"</span>];<br/><br/>   <span class="violet1">NSURLRequest</span> *request = [<span class="violet1">NSURLRequest</span> <span class="violet">requestWithURL</span>:url];<br/><br/><span class="ent">➍</span> <span class="violet1">NSURLSession</span> *session = [<span class="violet1">NSURLSession</span> <span class="violet">sessionWithConfiguration</span>:configuration<br/>                                                         delegate:<span class="rose">self</span><br/>                                                    delegateQueue:nil];<br/><br/><span class="ent">➎</span> <span class="violet1">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request<br/>                                           <span class="violet">completionHandler</span>:<br/>        ^(<span class="violet1">NSData</span> *data, <span class="violet1">NSURLResponse</span> *response, <span class="violet1">NSError</span> *error) {<br/><span class="ent">➏</span>         <span class="green1"><span class="codeitalic">// Your completion handler block</span></span><br/>        }];<br/><br/><span class="ent">➐</span> [task resume];</pre>
<p class="listcap"><a id="ch7ex5"/><em>Listing 7-5: Creating an ephemeral</em> <code>NSURLConfiguration</code> <em>requiring TLSv1.2</em></p>
<p class="indent">The <code>NSURLSessionConfiguration</code> object is instantiated at <span class="ent">➊</span>, with the specification that the connection should be ephemeral. This should prevent cached data from being written to local storage. Then, at <span class="ent">➋</span>, the configuration also requires TLS version 1.2 since the developer controls the endpoint and knows that it supports that version. Next, just as with <code>NSURLConnection</code>, an <code>NSURL</code> object and an <code>NSURLRequest</code> object with that URL <span class="ent">➌</span> are created. With the configuration and request created, the app can then instantiate the session <span class="ent">➍</span> and assign a task to that session <span class="ent">➎</span>.</p>
<p class="indent"><a id="page_119"/><code>NSURLSessionDataTask</code> and its siblings take a completion handler block as an argument <span class="ent">➏</span>. This block asynchronously handles the server response and data you receive as a result of the task. Alternatively (or in addition), you can specify a custom delegate conforming to the <code>NSURLSessionTaskDelegate</code> protocol. One reason you may want to use both a <code>completionHandler</code> and a delegate is to have the completion handler take care of the results of the request, while the delegate manages authentication and caching decisions on a session basis instead of a task basis (I’ll talk about this in the next section).</p>
<p class="indent">Finally, at <span class="ent">➐</span>, this code sets the task running with a call to its <code>resume</code> method because all tasks are suspended upon creation.</p>
<h4 class="h4" id="ch07lev2sec08"><em><strong>Spotting NSURLSession TLS Bypasses</strong></em></h4>
<p class="noindent"><code>NSURLSession</code> has a way to avoid TLS checks as well. Apps can just use the <code>didReceiveChallenge</code> delegate and pass the <code>proposedCredential</code> of the challenge received back as a credential for the session, as in <a href="ch07.html#ch7ex6">Listing 7-6</a>.</p>
<pre>   - (<span class="rose">void</span>)URLSession:(<span class="violet1">NSURLSession</span> *)session didReceiveChallenge:(<span class="violet1">NS</span><br/>        <span class="violet1">URLAuthenticationChallenge</span> *)challenge <span class="violet">completionHandler</span>:(<span class="rose">void</span> (^)(<span class="violet1">NS</span><br/>        <span class="violet1">URLSessionAuthChallengeDisposition</span> disposition, <span class="violet1">NSURLCredential</span> * credential))<br/>        <span class="violet">completionHandler</span> {<br/><br/><span class="ent">➊</span>      <span class="violet">completionHandler</span>(<span class="violet1">NSURLSessionAuthChallengeUseCredential,</span><br/>          [challenge proposedCredential]);<br/>   }</pre>
<p class="listcap"><a id="ch7ex6"/><em>Listing 7-6: Bypassing server verification with</em> <code><span class="violet1">NSURLSession</code></span></p>
<p class="indent">This is another bypass that can be tricky to spot. Look for code like that at <span class="ent">➊</span>, where there’s a <code>completionHandler</code> followed by <code>proposedCredential</code>.</p>
<h4 class="h4" id="ch07lev2sec09"><em><strong>Basic Authentication with NSURLSession</strong></em></h4>
<p class="noindent">HTTP authentication with <code>NSURLSession</code> is handled by the session and is passed to the <code>didReceiveChallenge</code> delegate, as shown in <a href="ch07.html#ch7ex7">Listing 7-7</a>.</p>
<pre><span class="ent">➊</span> - (<span class="rose">void</span>)URLSession:(<span class="violet1">NSURLSession</span> *)session didReceiveChallenge:(<span class="violet1">NS</span><br/>        <span class="violet1">URLAuthenticationChallenge</span> *)challenge <span class="violet">completionHandler</span>:(<span class="rose">void</span> (^)(<span class="violet1">NS</span><br/>        <span class="violet1">URLSessionAuthChallengeDisposition, NSURLCredential</span> *))<span class="violet">completionHandler</span> {<br/>       <span class="violet1">NSString</span> *user = <span class="red">@"user"</span>;<br/>       <span class="violet1">NSString</span> *pass = <span class="red">@"pass"</span>;<br/><br/>       <span class="violet1">NSURLProtectionSpace</span> *space = [challenge protectionSpace];<br/>        <span class="rose">if</span> ([space receivesCredentialSecurely] == YES &amp;&amp;<br/>            [[space host] <span class="violet">isEqualToString</span>:<span class="red">@"myhost.com"</span>] &amp;&amp;<br/>            [[space authenticationMethod] <span class="violet">isEqualToString</span>:<span class="violet1">NS</span><br/>        <span class="violet1">URLAuthenticationMethodHTTPBasic])</span> {<br/><br/><span class="ent">➋</span>    <span class="violet1">NSURLCredential</span> *credential =<br/>        [<span class="violet1">NSURLCredential</span> credentialWithUser:user<br/>                                   password:pass<br/>                                persistence:<span class="violet1">NSURLCredentialPersistenceForSession];</span><br/><br/><span class="ent">➌</span>    <span class="violet">completionHandler</span>(<span class="violet1">NSURLSessionAuthChallengeUseCredential,</span> credential);<br/>       }<br/>   }</pre>
<p class="listcap"><a id="ch7ex7"/><em>Listing 7-7: A sample</em> <code>didReceiveChallenge</code> <em>delegate</em></p>
<p class="indent"><a id="page_120"/>This approach defines a delegate and a completion handler at <span class="ent">➊</span>, creates an <code>NSURLCredential</code> at <span class="ent">➋</span>, and passes that credential to the completion handler at <span class="ent">➌</span>. Note that for either the <code>NSURLConnection</code> or <code>NSURLSession</code> approach, some developers forget to ensure that they’re talking to the correct host or sending credentials securely. This would result in credentials getting sent to <em>every</em> URL your app loads, instead of just yours; <a href="ch07.html#ch7ex8">Listing 7-8</a> shows an example of what that mistake might look like.</p>
<pre>- (<span class="rose">void</span>)URLSession:(<span class="violet1">NSURLSession</span> *)session didReceiveChallenge:(<span class="violet1">NS</span><br/>     <span class="violet1">URLAuthenticationChallenge</span> *)challenge <span class="violet">completionHandler</span>:(<span class="rose">void</span> (^)(<span class="violet1">NS</span><br/>     <span class="violet1">URLSessionAuthChallengeDisposition, NSURLCredential</span> *))<span class="violet">completionHandler</span> {<br/><br/>    <span class="violet1">NSURLCredential</span> *credential =<br/>      [<span class="violet1">NSURLCredential</span> credentialWithUser:user<br/>                                 password:pass<br/>                              persistence:<span class="violet1">NSURLCredentialPersistenceForSession];</span><br/><br/>    <span class="violet">completionHandler</span>(<span class="violet1">NSURLSessionAuthChallengeUseCredential,</span> credential);<br/>}</pre>
<p class="listcap"><a id="ch7ex8"/><em>Listing 7-8: The wrong way to do HTTP auth</em></p>
<p class="indent">If you want to use persistent credentials for a dedicated endpoint, you can store them in <code>sharedCredentialStorage</code> as you did with <code>NSURLConnection</code>. When constructing your session, you can provide these credentials beforehand without having to worry about a delegate method, as shown in <a href="ch07.html#ch7ex9">Listing 7-9</a>.</p>
<pre><span class="violet1">NSURLSessionConfiguration</span> *config = [<span class="violet1">NSURLSessionConfiguration</span><br/>     defaultSessionConfiguration];<br/>[config setURLCredentialStorage:<br/>    [<span class="violet1">NSURLCredentialStorage</span> sharedCredentialStorage]];<br/><br/><span class="violet1">NSURLSession</span> *session = [<span class="violet1">NSURLSession</span> <span class="violet">sessionWithConfiguration</span>:config<br/>                                                      delegate:nil<br/>                                                 delegateQueue:nil];</pre>
<p class="listcap"><a id="ch7ex9"/><em>Listing 7-9: Using an</em> <code>NSURLSessionConfiguration</code> <em>to reference stored credentials</em></p>
<p class="indent"><a id="page_121"/>This just creates an <code>NSURLSessionConfiguration</code> and specifies that it should use the shared credential storage. When you connect to a resource that has credentials stored in the Keychain, those will be used by the session.</p>
<h4 class="h4" id="ch07lev2sec10"><em><strong>Managing Stored URL Credentials</strong></em></h4>
<p class="noindent">You’ve seen how to store and read credentials using <code>sharedCredentialStorage</code>, but the <code>NSURLCredentialStorage</code> API also lets you remove credentials using the <code>removeCredential:forProtectionSpace</code> method. For example, you may want to do this when a user explicitly decides to log out of an application or remove an account. <a href="ch07.html#ch7ex10">Listing 7-10</a> shows a typical use case.</p>
<pre><span class="violet1">NSURLProtectionSpace</span> *space = [[<span class="violet1">NSURLProtectionSpace</span> <span class="violet">alloc</span>]<br/>     initWithHost:<span class="red">@"myhost.com"</span><br/>             port:443<br/>         protocol:<span class="red">@"https"</span><br/>            realm:nil authenticationMethod:nil];<br/><br/><span class="violet1">NSURLCredential</span> *credential = [credentialStorage<br/>     defaultCredentialForProtectionSpace:space];<br/><br/>[[<span class="violet1">NSURLCredentialStorage</span> sharedCredentialStorage] removeCredential:credential<br/>                                                forProtectionSpace:space];</pre>
<p class="listcap"><a id="ch7ex10"/><em>Listing 7-10: Removing default credentials</em></p>
<p class="indent">This will delete the credentials from your local Keychain. However, if a credential has a persistence of <code>NSURLCredentialPersistenceSynchronizable</code>, the credential may have been synchronized to other devices via iCloud. To remove the credentials from all devices, use the <code>NSURLCredentialStorageRemoveSynchronizableCredentials</code> option, as shown in <a href="ch07.html#ch7ex11">Listing 7-11</a>.</p>
<pre><span class="violet1">NSDictionary</span> *options = [<span class="violet1">NSDictionary</span> dictionaryWithObjects forKeys<span class="violet1">:NS</span><br/>     <span class="violet1">URLCredentialStorageRemoveSynchronizableCredentials,</span> YES];<br/><br/>[[<span class="violet1">NSURLCredentialStorage</span> sharedCredentialStorage] removeCredential:credential<br/>                                                forProtectionSpace:space<br/>                                                           options:options];</pre>
<p class="listcap"><a id="ch7ex11"/><em>Listing 7-11: Removing credentials from the local Keychain and from iCloud</em></p>
<p class="indent"><a id="page_122"/>At this point, you should have an understanding of the <code>NSURLConnection</code> and <code>NSURLSession</code> APIs and their basic usage. There are other network frameworks that you may encounter, which have their own behaviors and require slightly different security configuration. I’ll cover a few of these now.</p>
<h3 class="h3" id="ch07lev1sec03"><strong>Risks of Third-Party Networking APIs</strong></h3>
<p class="noindent">There are a few popular third-party networking APIs used in iOS applications, largely for simplifying various networking tasks such as multipart uploads and certificate pinning. The most commonly used one is AFNetworking,<sup><a href="footnote.html#fn68" id="fn_68">7</a></sup> followed by the now-obsolete ASIHTTPRequest.<sup><a href="footnote.html#fn69" id="fn_69">8</a></sup> In this section, I’ll introduce you to both.</p>
<h4 class="h4" id="ch07lev2sec11"><em><strong>Bad and Good Uses of AFNetworking</strong></em></h4>
<p class="noindent">AFNetworking is a popular library built on top of <code>NSOperation</code> and <code>NSHTTPRequest</code>. It provides several convenience methods to interact with different types of web APIs and perform common HTTP networking tasks.</p>
<p class="indent">As with other networking frameworks, one crucial task is to ensure that TLS safety mechanisms have not been disabled. In AFNetworking, TLS certificate validation can be disabled in a few ways. One is via the <code>_AFNETWORKING_ALLOW_INVALID_SSL_CERTIFICATES</code> flag, typically set in the <em>Prefix.pch</em> file. Another way is to set a property of <code>AFHTTPClient</code>, as in <a href="ch07.html#ch7ex12">Listing 7-12</a>.</p>
<pre><span class="violet1">NSURL</span> *baseURL = [<span class="violet1">NSURL</span> URLWithString:<span class="red">@"https://myhost.com"</span>];<br/><span class="green">AFHTTPClient*</span> client = [<span class="green">AFHTTPClient</span> <span class="violet">clientWithBaseURL</span>:baseURL];<br/>[client setAllowsInvalidSSLCertificate:YES];</pre>
<p class="listcap"><a id="ch7ex12"/><em>Listing 7-12: Disabling TLS validation with</em> <code>setAllowsInvalidSSLCertificate</code></p>
<p class="indent">The last way you might see TLS validation being disabled is by changing the security policy of <code>AFHTTPRequestOperationManager</code> with <code>setAllowsInvalidSSLCertificate</code>, as shown in <a href="ch07.html#ch7ex13">Listing 7-13</a>.</p>
<pre><span class="green">AFHTTPRequestOperationManager</span> *manager = [<span class="green">AFHTTPRequestOperationManager</span> manager];<br/>[manager [securityPolicy <span class="violet">setAllowInvalidCertificates</span>:YES]];</pre>
<p class="listcap"><a id="ch7ex13"/><em>Listing 7-13: Disabling TLS validation using</em> <code>securityPolicy</code></p>
<p class="indent"><a id="page_123"/>You’ll also want to verify that the code you’re examining doesn’t use the <code>AFHTTPRequestOperationLogger</code> class in production versions. This logger uses <code>NSLog</code> on the backend to write requested URLs to the Apple System Log, allowing them to be seen by other applications on some iOS versions.</p>
<p class="indent">One particularly useful feature that AFNetworking provides is the ability to easily perform certificate pinning. You can just set the <code>_AFNETWORKING_PIN_SSL_CERTIFICATES_</code> #define in your project’s <em>.pch</em> file, and set the pinning mode (<code>defaultSSLPinningMode</code>) property of your <code>AFHTTPClient</code> instance appropriately; the available modes are described in <a href="ch07.html#ch7tab2">Table 7-2</a>. You then put the certificates that you want to pin to in the bundle root, as files with a <em>.cer</em> extension.</p>
<p class="tablecap"><a id="ch7tab2"/><strong>Table 7-2:</strong> AFNetworking SSL Pinning Modes</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="80%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Mode</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Meaning</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table"><code>AFSSLPinningModeNone</code></p></td>
<td class="table" valign="top"><p class="table">Perform no certificate pinning, even if pinning is enabled. Use for debug mode if necessary.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>AFSSLPinningModePublicKey</code></p></td>
<td class="table" valign="top"><p class="table">Pin to the certificate’s public key.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>AFSSLPinningModeCertificate</code></p></td>
<td class="table" valign="top"><p class="table">Pin to the exact certificate (or certificates) supplied. This will require an application update if a certificate is reissued.</p></td>
</tr>
</tbody>
</table>
<p class="indent">As shown in sample code included with AFNetworking, you can examine URLs to determine whether they should be pinned. Just evaluate the scheme and domain name to see whether those domains belong to you. <a href="ch07.html#ch7ex14">Listing 7-14</a> shows an example.</p>
<pre><span class="rose">if</span> ([[url scheme] <span class="violet">isEqualToString</span>:<span class="red">@"https"</span>] &amp;&amp;<br/>    [[url host] <span class="violet">isEqualToString</span>:<span class="red">@"yourpinneddomain.com"</span>]) {<br/>        [<span class="rose">self</span> <span class="violet">setDefaultSSLPinningMode</span>:<span class="green">AFSSLPinningModePublicKey];</span><br/>    }<br/><br/>    <span class="rose">else</span> {<br/>        [<span class="rose">self</span> <span class="violet">setDefaultSSLPinningMode</span>:<span class="green">AFSSLPinningModeNone];</span><br/>    }<br/><br/>    <span class="rose">return self</span>;<br/>}</pre>
<p class="listcap"><a id="ch7ex14"/><em>Listing 7-14: Determining whether a URL should be pinned</em></p>
<p class="indent">The <code>else</code> statement is not strictly necessary because not pinning is the default, but it does provide some clarity.</p>
<p class="indent">Keep in mind that AFNetworking pins to all certificates provided in the bundle, but it doesn’t check that the certificate common name and the hostname of the network endpoint match. This is mostly an issue <a id="page_124"/>if your application pins to multiple sites with different security standards. In other words, if your application pins to both <em><a href="https://funnyimages.com">https://funnyimages.com</a></em> and <em><a href="https://www.bank.com">https://www.bank.com</a></em>, an attacker in possession of the <em>funnyimages.com</em> private key would be able to intercept communications from your application to <em>bank.com</em>.</p>
<p class="indent">Now that you’ve had a glimpse at how you can use and abuse the AFNetworking library, let’s move on to ASIHTTPRequest.</p>
<h4 class="h4" id="ch07lev2sec12"><em><strong>Unsafe Uses of ASIHTTPRequest</strong></em></h4>
<p class="noindent">ASIHTTPRequest is a deprecated library similar to AFNetworking, but it’s a bit less complete and is based on the CFNetwork API. It should not be used for new projects, but you may find it in existing codebases where migration has been considered too expensive. When examining these codebases, the standard SSL validation bypass to look for is <code>setValidatesSecureCertificate:NO</code>.</p>
<p class="indent">You’ll also want to examine <em>ASIHTTPRequestConfig.h</em> in your project to ensure that overly verbose logging is not enabled (see <a href="ch07.html#ch7ex15">Listing 7-15</a>).</p>
<pre><span class="green1"><span class="codeitalic">// If defined, will use the specified function for debug logging</span></span><br/><span class="green1"><span class="codeitalic">// Otherwise use NSLog</span></span><br/><span class="brown">#ifndef ASI_DEBUG_LOG</span><br/>    <span class="brown">#define ASI_DEBUG_LOG NSLog</span><br/><span class="brown">#endif</span><br/><br/><span class="green1"><span class="codeitalic">// When set to 1, ASIHTTPRequests will print information about what a request is</span></span><br/>      <span class="green1"><span class="codeitalic">doing</span></span><br/><span class="brown">#ifndef DEBUG_REQUEST_STATUS</span><br/>    <span class="brown">#define DEBUG_REQUEST_STATUS 0</span><br/><span class="brown">#endif</span><br/><br/><span class="green1"><span class="codeitalic">// When set to 1, ASIFormDataRequests will print information about the request body</span></span><br/>      <span class="green1"><span class="codeitalic">to the console</span></span><br/><span class="brown">#ifndef DEBUG_FORM_DATA_REQUEST</span><br/>    <span class="brown">#define DEBUG_FORM_DATA_REQUEST 0</span><br/><span class="brown">#endif</span><br/><br/><span class="green1"><span class="codeitalic">// When set to 1, ASIHTTPRequests will print information about bandwidth throttling</span></span><br/>      <span class="green1"><span class="codeitalic">to the console</span></span><br/><span class="brown">#ifndef DEBUG_THROTTLING</span><br/>    <span class="brown">#define DEBUG_THROTTLING 0</span><br/><span class="brown">#endif</span><br/><br/><span class="green1"><span class="codeitalic">// When set to 1, ASIHTTPRequests will print information about persistent</span></span><br/>      <span class="green1"><span class="codeitalic">connections to the console</span></span><br/><span class="brown">#ifndef DEBUG_PERSISTENT_CONNECTIONS</span><br/>    <span class="brown">#define DEBUG_PERSISTENT_CONNECTIONS 0</span><br/><span class="brown">#endif</span><br/><br/><span class="green1"><span class="codeitalic">// When set to 1, ASIHTTPRequests will print information about HTTP authentication</span></span><br/>      <span class="green1"><span class="codeitalic">(Basic, Digest or NTLM) to the console</span></span><br/><span class="brown">#ifndef DEBUG_HTTP_AUTHENTICATION</span><br/>    <span class="brown">#define DEBUG_HTTP_AUTHENTICATION 0</span><br/><span class="brown">#endif</span></pre>
<p class="listcap"><a id="ch7ex15"/><em>Listing 7-15: Logging defines in</em> ASIHTTPRequestConfig.h</p>
<p class="indent"><a id="page_125"/>If you do want to use these logging facilities, you may want to wrap them in <code>#ifdef DEBUG</code> conditionals, like this:</p>
<pre><span class="brown">#ifndef DEBUG_HTTP_AUTHENTICATION</span><br/>    <span class="brown">#ifdef DEBUG</span><br/>        <span class="brown">#define DEBUG_HTTP_AUTHENTICATION 1</span><br/>    <span class="brown">#else</span><br/>        <span class="brown">#define DEBUG_HTTP_AUTHENTICATION 0</span><br/>    <span class="brown">#endif</span><br/><span class="brown">#endif</span></pre>
<p class="indent">This <em>ASIHTTPRequestConfig.h</em> file wraps the logging facilities inside conditionals to keep this information from leaking in production builds.</p>
<h3 class="h3" id="ch07lev1sec04"><strong>Multipeer Connectivity</strong></h3>
<p class="noindent">iOS 7 introduced Multipeer Connectivity,<sup><a href="footnote.html#fn70" id="fn_70">9</a></sup> which allows nearby devices to communicate with each other with a minimal network configuration. Multipeer Connectivity communication can take place over Wi-Fi (either peer-to-peer or multipeer networks) or Bluetooth personal area networks (PANs). Bonjour is the default mechanism for browsing and advertising available services.</p>
<p class="indent">Developers can use Multipeer Connectivity to perform peer-to-peer file transfers or stream content between devices. As with any type of peer communication, the validation of incoming data from untrusted peers is crucial; however, there are also transport security mechanisms in place to ensure that the data is safe from eavesdropping.</p>
<p class="indent">Multipeer Connectivity sessions are created with either the <code>initWithPeer</code> or <code>initWithPeer:securityIdentity:encryptionPreference:</code> class method of the <code>MCSession</code> class. The latter method allows you to require encryption, as well as include a certificate chain to verify your device.</p>
<p class="indent">When specifying a value for <code>encryptionPreference</code>, your options are <code>MCEncryptionNone</code>, <code>MCEncryptionRequired</code>, and <code>MCEncryptionOptional</code>. Note that these are interchangeable with values of <code>0</code>, <code>1</code>, or <code>2</code>, respectively. So while <a id="page_126"/>values of <code>0</code> and <code>1</code> behave how you would expect if this value were a Boolean, a value of <code>2</code> is functionally equivalent to not having encryption at all.</p>
<p class="indent">It’s a good idea to require encryption unconditionally because <code>MCEncryptionOptional</code> is subject to downgrade attacks. (You can find more detail in Alban Diquet’s Black Hat talk on reversing the Multipeer Connectivity protocol.<sup><a href="footnote.html#fn71" id="fn_71">10</a></sup>) <a href="ch07.html#ch7ex16">Listing 7-16</a> shows a typical invocation, creating a session and requiring encryption.</p>
<pre>MCPeerID *peerID = [[MCPeerID <span class="violet">alloc</span>] initWithDisplayName:<span class="red">@"my device"</span>];<br/><br/>MCSession *session = [[MCSession <span class="violet">alloc</span>] initWithPeer:peerID<br/>                                    securityIdentity:nil<br/>                                encryptionPreference:MCEncryptionRequired];</pre>
<p class="listcap"><a id="ch7ex16"/><em>Listing 7-16: Creating an</em> <code>MCSession</code></p>
<p class="indent">When connecting to a remote device, the delegate method <code>session:didReceiveCertificate:fromPeer:certificateHandler:</code> is called, passing in the peer’s certificate and allowing you to specify a handler method to take specific action based on whether the certificate was verified successfully.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>If you fail to create the</em> <code><em>didReceiveCertificate</em></code> <em>delegate method or don’t implement a</em> <code><em>certificateHandler</em></code> <em>in this delegate method, no verification of the remote endpoint will occur, making the connection susceptible to interception by a third party.</em></p>
</div>
<p class="indent">When examining codebases using the Multipeer Connectivity API, ensure that all instantiations of <code>MCSession</code> provide an identity and require transport encryption. Sessions with any type of sensitive information should never be instantiated simply with <code>initWithPeer</code>. Also ensure that the delegate method for <code>didReceiveCertificate</code> exists and is implemented correctly and that the <code>certificateHandler</code> behaves properly when a peer fails certificate validation. You specifically <em>don’t</em> want to see something like this:</p>
<pre>- (<span class="rose">void</span>) session:(MCSession *)session <span class="violet">didReceiveCertificate</span>:(<span class="violet1">NSArray</span> *)certificate<br/>     fromPeer:(MCPeerID *)peerID<br/>     certificateHandler:(<span class="rose">void</span> (^)(<span class="rose">BOOL</span> accept))certificateHandler<br/>{<br/>    certificateHandler(YES);<br/>}</pre>
<p class="indent">This code blindly passes a <code>YES</code> boolean to the handler, which you should never, ever do.</p>
<p class="indent">It’s up to you to decide how you’d like to implement validation. Systems for validation tend to be somewhat customized, but you have a couple of basic options. You can have clients generate certificates themselves and then <em>trust on first use (TOFU)</em>, which just verifies that the certificate being <a id="page_127"/>presented is the same as the one shown the first time you paired with a peer. You can also implement a server that will return the public certificates of users when queried to centralize the management of identities. Choose a solution that makes sense for your business model and threat model.</p>
<h3 class="h3" id="ch07lev1sec05"><strong>Lower-Level Networking with NSStream</strong></h3>
<p class="noindent"><code>NSStream</code> is suitable for making non-HTTP network connections, but it can also be used for HTTP communications with fairly little effort. For some unfathomable reason, in the transition between OS X Cocoa and iOS Cocoa Touch, Apple removed the method that allows an <code>NSStream</code> to establish a network connection to a remote host, <code>getStreamsToHost</code>. So if you want to sit around streaming things to yourself, then awesome. Otherwise, in Technical Q&amp;A QA1652,<sup><a href="footnote.html#fn72" id="fn_72">11</a></sup> Apple describes a category that you can use to define a roughly equivalent <code>getStreamsToHostNamed</code> method of <code>NSStream</code>.</p>
<p class="indent">The alternative is to use the lower-level Core Foundation <code>CFStreamCreatePairWithSocketToHost</code> function and cast the input and output <code>CFStream</code>s to <code>NSStream</code>s, as shown in <a href="ch07.html#ch7ex17">Listing 7-17</a>.</p>
<pre><span class="violet1">NSInputStream</span> *inStream;<br/><span class="violet1">NSOutputStream</span> *outStream;<br/><br/>CFReadStreamRef readStream;<br/>CFWriteStreamRef writeStream;<br/>CFStreamCreatePairWithSocketToHost(NULL, (<span class="green">CFStringRef</span>)<span class="red">@"myhost.com"</span>, 80, &amp;<br/>     readStream, &amp;writeStream);<br/>inStream = (__bridge <span class="violet1">NSInputStream</span> *)readStream;<br/>outStream = (__bridge <span class="violet1">NSOutputStream</span> *)writeStream;</pre>
<p class="listcap"><a id="ch7ex17"/><em>Listing 7-17: Casting</em> <code>CFStreams</code> <em>to</em> <code>NSStreams</code></p>
<p class="indent"><code>NSStream</code>s allow users only minor control of the characteristics of the connection, such as TCP port and TLS settings (see <a href="ch07.html#ch7ex18">Listing 7-18</a>).</p>
<pre>   <span class="violet1">NSHost</span> *myhost = [<span class="violet1">NSHost</span> <span class="violet">hostWithName</span>:[<span class="red">@"www.conglomco.com"</span>]];<br/><br/>   [<span class="violet1">NSStream</span> <span class="violet">getStreamsToHostNamed</span>:myhost<br/>                              port:443<br/>                       inputStream:&amp;MyInputStream<br/>                      outputStream:&amp;MyOutputStream];<br/><br/><span class="ent">➊</span> [MyInputStream <span class="violet">setProperty</span>:<span class="violet1">NSStreamSocketSecurityLevelTLSv1</span><br/>                      forKey:<span class="violet1">NSStreamSocketSecurityLevelKey];</span></pre>
<p class="listcap"><a id="ch7ex18"/><em>Listing 7-18: Opening a basic TLS connection with</em> <code>NSStream</code></p>
<p class="indent"><a id="page_128"/>This is the typical use of an <code>NSStream</code>: setting a host, port, and input and output streams. Since you don’t have a ton of control over TLS settings, the only setting that might be screwed up is <span class="ent">➊</span>, the <code>NSStreamSocketSecurityLevel</code>. You should set it to <code>NSStreamSocketSecurityLevelTLSv1</code> to ensure that you don’t end up using an older, broken SSL/TLS protocol.</p>
<h3 class="h3" id="ch07lev1sec06"><strong>Even Lower-level Networking with CFStream</strong></h3>
<p class="noindent">With <code>CFStream</code>s, the developer is given an unfortunate amount of control in TLS session negotiation.<sup><a href="footnote.html#fn73" id="fn_73">12</a></sup> See <a href="ch07.html#ch7tab3">Table 7-3</a> for a number of <code>CFStream</code> properties that you should look for. These controls allow developers to override or disable verification of the peer’s canonical name (CN), ignore expiration dates, allow untrusted root certificates, and totally neglect to verify the certificate chain at all.</p>
<p class="tablecap"><a id="ch7tab3"/><strong>Table 7-3:</strong> Horrible <code>CFStream</code> TLS Security Constants</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="80%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Constant</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Meaning</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Default</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table"><code>kCFStreamSSLLevel</code></p></td>
<td class="table" valign="top"><p class="table">The protocol to be used for encrypting the connection.</p></td>
<td class="table" valign="top"><p class="table">negotiated<em><sup>a</sup></em></p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>kCFStreamSSLAllowsExpiredCertificates</code></p></td>
<td class="table" valign="top"><p class="table">Accept expired TLS certificates.</p></td>
<td class="table" valign="top"><p class="table">false</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>kCFStreamSSLAllowsExpiredRoots</code></p></td>
<td class="table" valign="top"><p class="table">Accept certificates that have expired root certificates in their certificate chain.</p></td>
<td class="table" valign="top"><p class="table">false</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>kCFStreamSSLAllowsAnyRoot</code></p></td>
<td class="table" valign="top"><p class="table">Whether a root certificate can be used as a TLS endpoint’s certificate (in other words, a self-signed or unsigned certificate).</p></td>
<td class="table" valign="top"><p class="table">false</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>kCFStreamSSLValidatesCertificateChain</code></p></td>
<td class="table" valign="top"><p class="table">Whether the certificate chain is validated.</p></td>
<td class="table" valign="top"><p class="table">true</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>kCFStreamSSLPeerName</code></p></td>
<td class="table" valign="top"><p class="table">Overrides the hostname compared to that of the certificate’s CN. If set to <code>kCFNull</code>, no validation is performed.</p></td>
<td class="table" valign="top"><p class="table">hostname</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>kCFStreamSSLIsServer</code></p></td>
<td class="table" valign="top"><p class="table">Whether this stream will act as a server.</p></td>
<td class="table" valign="top"><p class="table">false</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>kCFStreamSSLCertificates</code></p></td>
<td class="table" valign="top"><p class="table">An array of certificates that will be used if <code>kCFStreamSSLIsServer</code> is true.</p></td>
<td class="table" valign="top"><p class="table">none</p></td>
</tr>
</tbody>
</table>
<p class="footnote"><em>a</em>. The default constant is <code>kCFStreamSocketSecurityLevelNegotiatedSSL</code>, which negotiates the strongest method available from the server.</p>
<p class="indent"><a id="page_129"/>You probably shouldn’t be using these security constants at all, but if you must use TLS <code>CFStream</code>s, just do it the right way. It’s simple! Provided that you’re not creating a network server within the app itself (which is a pretty rare usage of <code>CFStream</code> in an iOS app), there are two steps you should follow:</p>
<ol>
<li><p class="noindent">Set <code>kCFStreamSSLLevel</code> to <code>kCFStreamSocketSecurityLevelTLSv1</code>.</p></li>
<li><p class="noindent">Don’t mess with anything else.</p></li>
</ol>
<h3 class="h3" id="ch07lev1sec07"><strong>Closing Thoughts</strong></h3>
<p class="noindent">You’ve looked at quite a number of ways for apps to communicate with the outside world and the incorrect ways those things can be implemented. Let’s now turn our attention to communication with other applications and some of the pitfalls that can happen when shuffling data around via IPC.<a id="page_130"/></p>
</body></html>