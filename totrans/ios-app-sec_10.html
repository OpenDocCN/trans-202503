<html><head></head><body>
<h2 class="h2" id="ch07"><a id="page_107"/><strong><span class="big">7</span></strong><br/><strong>IOS NETWORKING</strong></h2>
<p class="noindent">Almost all applications use one or more of three iOS network APIs. In order of abstraction, these are the URL loading system, the Foundation <span class="literal">NSStream</span> API, and the Core Foundation <span class="literal">CFStream</span> API. The URL loading system is used for fetching and manipulating data, such as network resources or files, via URLs. The <span class="literal">NSStream</span> and <span class="literal">CFStream</span> classes are slightly lower-level methods to deal with network connections, without going quite so low as the socket level. These classes are used for non-HTTP-based communications, or where you need more direct control over network behavior.</p>
<p class="indent">In this chapter, I’ll discuss iOS networking in detail, starting from the high-level APIs. For most purposes, apps can stick with the higher-level APIs, but there are some cases where you can’t quite bend those APIs to your will. With lower-level APIs, however, there are more pitfalls to consider.</p>
<h3 class="h3" id="ch07lev1sec01"><a id="page_108"/><strong>Using the iOS URL Loading System</strong></h3>
<p class="noindent">The URL loading system can handle most network tasks an app will need to perform. The primary method of interacting with the URL API is by constructing an <span class="literal">NSURLRequest</span> object and using it to instantiate an <span class="literal">NSURLConnection</span> object, along with a delegate that will receive the connection’s response. When the response is fully received, the delegate will be sent a <span class="literal">connection:didReceiveResponse</span> message, with an <span class="literal">NSURLResponse</span> object as the supplied parameter.<sup><a href="footnote.html#fn62" id="fn_62">1</a></sup></p>
<p class="indent">But not everyone uses the powers of the URL loading system properly, so in this section, I’ll first show you how to spot an app that bypasses Transport Layer Security. Then, you’ll learn how to authenticate endpoints through certificates, avoid the dangers of open redirects, and implement certificate pinning to limit how many certificates your app trusts.</p>
<h4 class="h4" id="ch07lev2sec01"><em><strong>Using Transport Layer Security Correctly</strong></em></h4>
<p class="noindent"><em>Transport Layer Security (TLS)</em>, the modern specification supplanting SSL, is crucial to the security of almost any networked application. When used correctly, TLS both keeps the data transmitted over a connection confidential and authenticates the remote endpoint, ensuring that the certificate presented is signed by a trusted certificate authority. By default, iOS does the Right Thing™ and refuses to connect to any endpoint with an untrusted or invalid certificate. But all too frequently, in applications of all kinds, mobile and otherwise, developers explicitly disable TLS/SSL endpoint validation, allowing the application’s traffic to be intercepted by network attackers.</p>
<p class="indent">In iOS, TLS can be disabled a number of ways. In the past, developers would often use the undocumented <span class="literal">setAllowsAnyHTTPSCertificate</span> private class method of <span class="literal">NSURLRequest</span> to easily disable verification. Apple fairly quickly started rejecting applications that used this method, as it tends to do with apps that use private APIs. There are, however, still obfuscation methods that may allow the use of this API to slip past the approval process, so check codebases to ensure that the method isn’t just called by another name.</p>
<p class="indent">There’s an even more disastrous way to bypass TLS validation. It will also (probably) get your app rejected in this day and age, but it illustrates an important point about categories. I once had a client that licensed what should have been a fairly simple piece of third-party code and included it in their product. Despite handling TLS correctly everywhere else in the project, their updated version of the third-party code did not validate any TLS connections. Apparently, the third-party vendor had implemented a category of <span class="literal">NSURLRequest</span>, using the <span class="literal">allowsAnyHTTPSCertificateForHost</span> method to avoid validation. The category contained only the directive <span class="literal">return YES;</span>, causing all <span class="literal">NSURLRequests</span> to silently ignore bad certificates. The moral? Test things, and don’t make assumptions! Also, you have to audit third-party code <a id="page_109"/>along with the rest of your codebase. Mistakes might not be your fault, but nobody is likely to care about that.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>Thankfully, it’s much more difficult to make accidental TLS-disabling mistakes in iOS 9, as it by default does not allow applications to make non-TLS connections. Instead, developers are required to put a specific exception in the app’s</em> Info.plist <em>for URLs to be accessed over plaintext HTTP. However, this won’t solve cases of willful disabling of TLS protections.</em></p>
</div>
<p class="indent">Now, there is actually an official API to bypass TLS verification. You can use a delegate of <span class="literal">NSURLConnection</span> with the <span class="literal">NSURLConnectionDelegate</span> protocol.<sup><a href="footnote.html#fn63" id="fn_63">2</a></sup> The delegate must implement the <span class="literal">willSendRequestForAuthenticationChallenge</span> method, which can then call the <span class="literal">continueWithoutCredentialForAuthenticationChallenge</span> method. This is the current, up-to-date method; you may also see older code that uses <span class="literal">connection:canAuthenticateAgainstProtectionSpace:</span> or <span class="literal">connection:didReceiveAuthenticationChallenge:</span>. <a href="ch07.html#ch7ex1">Listing 7-1</a> shows an example of how you might see this done in the wild.</p>
<p class="programs">- (<span class="rose">void</span>)<span class="violet">connection</span>:(<span class="violet1">NSURLConnection</span> *)<span class="violet">connection</span><br/>     <span class="violet">willSendRequestForAuthenticationChallenge</span>:(<span class="violet1">NSURLAuthenticationChallenge</span> *)<br/>     challenge {<br/>    <span class="violet1">NSURLProtectionSpace</span> *space = [challenge protectionSpace];<br/>    <span class="rose">if</span>([[space authenticationMethod] <span class="violet">isEqualToString</span>:<span class="violet1">NS</span><br/>     <span class="violet1">URLAuthenticationMethodServerTrust])</span> {<br/>        <span class="violet1">NSURLCredential</span> *cred = [<span class="violet1">NSURLCredential</span> <span class="violet">credentialForTrust</span>:<br/>     [space serverTrust]];<br/>        [[challenge sender] useCredential:cred forAuthenticationChallenge:<br/>     challenge];<br/>    }<br/>}</p>
<p class="listcap"><a id="ch7ex1"/><em>Listing 7-1: Sending a dummy</em> <span class="literal">NSURLCredential</span> <em>in response to the challenge</em></p>
<p class="indent">This code looks rather benign, especially since it uses the words <em>protection</em>, <em>credential</em>, <em>authentication</em>, and <em>trust</em> all over the place. What it actually does is bypass verification of the TLS endpoint, leaving the connection susceptible to interception.</p>
<p class="indent">Of course, I’m not encouraging you to actually <em>do</em> anything to bypass TLS verification in your app. You shouldn’t, and you’re a bad person if you do. These examples just show the pattern that you may see in code that you have to examine. These patterns can be difficult to spot and understand, but if you see code that bypasses TLS verification, be sure to change it.</p>
<h4 class="h4" id="ch07lev2sec02"><a id="page_110"/><em><strong>Basic Authentication with NSURLConnection</strong></em></h4>
<p class="noindent">HTTP basic authentication isn’t a particularly robust authentication mechanism. It doesn’t support session management or password management, and therefore, the user can’t log out or change their password without using a separate application. But for some tasks, such as authenticating to APIs, these issues are less important, and you still might run across this mechanism in an app’s codebase—or be required to implement it yourself.</p>
<p class="indent">You can implement HTTP basic authentication using either <span class="literal">NSURLSession</span> or <span class="literal">NSURLConnection</span>, but there are a couple of pitfalls that you’ll want to be aware of, whether you’re writing an app or examining someone else’s code.</p>
<p class="indent">The simplest implementation uses the <span class="literal">willSendRequestForAuthenticationChallenge</span> delegate method of <span class="literal">NSURLConnection</span>:</p>
<p class="programs">- (<span class="rose">void</span>)<span class="violet">connection</span>:(<span class="violet1">NSURLConnection</span> *)<span class="violet">connection</span><br/>     <span class="violet">willSendRequestForAuthenticationChallenge</span>:(<span class="violet1">NSURLAuthenticationChallenge</span> *)<br/>     challenge {<br/>    <span class="violet1">NSString</span> *user = <span class="red">@"user"</span>;<br/>    <span class="violet1">NSString</span> *pass = <span class="red">@"pass"</span>;<br/><br/><br/>    <span class="rose">if</span> ([[challenge protectionSpace] receivesCredentialSecurely] == YES &amp;&amp;<br/>        [[[challenge protectionSpace] host] <span class="violet">isEqualToString</span>:<span class="red">@"myhost.com"</span>]) {<br/><br/>    <span class="violet1">NSURLCredential</span> *credential = [<span class="violet1">NSURLCredential</span> credentialWithUser:user password<br/>     :pass persistence<span class="violet1">:NSURLCredentialPersistenceForSession];</span><br/><br/>    [[challenge sender] useCredential:credential<br/>           forAuthenticationChallenge:challenge];<br/>    }<br/>}</p>
<p class="indent">The delegate is first passed an <span class="literal">NSURLAuthenticationChallenge</span> object. It then creates a credential with a username and password, which can be either provided by the user or pulled from the Keychain. Finally, the sender of the challenge is passed the credential and challenge in return.</p>
<p class="indent">There are two potential problems to pay attention to when implementing HTTP basic authentication in this way. First, avoid storing the username and password within either the source code or the shared preferences. You can use the <span class="literal">NSURLCredentialStorage</span> API to store user-supplied credentials in the Keychain automatically, using <span class="literal">sharedCredentialStorage</span>, as shown in <a href="ch07.html#ch7ex2">Listing 7-2</a>.</p>
<p class="programs"><a id="page_111"/><span class="ent">➊</span> <span class="violet1">NSURLProtectionSpace</span> *protectionSpace = [[<span class="violet1">NSURLProtectionSpace</span> <span class="violet">alloc</span>] initWithHost:<br/>        <span class="red">@"myhost.com"</span> port:443 protocol:<span class="red">@"https"</span> realm:nil authenticationMethod:nil];<br/><br/><span class="ent">➋</span> <span class="violet1">NSURLCredential</span> *credential = [<span class="violet1">NSURLCredential</span> credentialWithUser:user password:<br/>        pass persistence:<span class="violet1">NSURLCredentialPersistencePermanent];</span><br/><br/><span class="ent">➌</span> <span class="violet1">[[NSURLCredentialStorage sharedCredentialStorage]</span> setDefaultCredential:credential<br/>        forProtectionSpace:protectionSpace];</p>
<p class="listcap"><a id="ch7ex2"/><em>Listing 7-2: Setting the default credentials of a protection space</em></p>
<p class="indent">This simply creates a protection space <span class="ent">➊</span>, which includes the host, the port, the protocol, and optionally the HTTP authentication realm (if using HTTP basic authentication) and the authentication method (for example, using NTLM or another mechanism). At <span class="ent">➋</span>, the example creates a credential with the username and password that it most likely received from user input. It then sets that to the default credential for this protection space at <span class="ent">➌</span>, and the credential should be automatically stored in the Keychain. In the future, the app this code belongs to can read credentials with the same API, using the <span class="literal">defaultCredentialForProtectionSpace</span> method, as shown in <a href="ch07.html#ch7ex3">Listing 7-3</a>.</p>
<p class="programs">credentialStorage = [[<span class="violet1">NSURLCredentialStorage</span> sharedCredentialStorage]<br/>     defaultCredentialForProtectionSpace:protectionSpace];</p>
<p class="listcap"><a id="ch7ex3"/><em>Listing 7-3: Using the default credential for a protection space</em></p>
<p class="indent">Note, however, that credentials stored in <span class="literal">sharedCredentialStorage</span> are marked with the Keychain attribute <span class="literal">kSecAttrAccessibleWhenUnlocked</span>. If you need stricter protections, you’ll need to manage Keychain storage yourself. I talk more about managing the Keychain in <a href="ch13.html#ch13">Chapter 13</a>.</p>
<p class="indent">Also, be sure to pay attention to how you specify the value of the <span class="literal">persistence</span> argument when creating the credential. If you’re storing in the Keychain using <span class="literal">NSURLCredentialStorage</span>, you can use either the <span class="literal">NSURLCredentialPersistencePermanent</span> or <span class="literal">NSURLCredentialPersistenceSynchronizable</span> types when creating your credentials. If you’re using the authentication for something more transient, the <span class="literal">NSURLCredentialPersistenceNone</span> or <span class="literal">NSURLCredentialPersistenceForSession</span> types are more appropriate. You can find details on what each of these persistence types mean in <a href="ch07.html#ch7tab1">Table 7-1</a>.</p>
<p class="tablecap"><a id="page_112"/><a id="ch7tab1"/><strong>Table 7-1:</strong> Credential Persistence Types</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="80%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Persistence type</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Meaning</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">NSURLCredentialPersistenceNone</span></p></td>
<td class="table" valign="top"><p class="table">Don’t store the credential at all. Use this only when you need to make a single request to a protected resource.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">NSURLCredentialPersistenceForSession</span></p></td>
<td class="table" valign="top"><p class="table">Persist the credential for the lifetime of your application.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">NSURLCredentialPersistencePermanent</span></p></td>
<td class="table" valign="top"><p class="table">Store the credential in the Keychain.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">NSURLCredentialPersistenceForSession</span></p></td>
<td class="table" valign="top"><p class="table">Persist the credential for the lifetime of your application. Use this is if you need a credential just for the time your app remains running.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">NSURLCredentialPersistencePermanent</span></p></td>
<td class="table" valign="top"><p class="table">Store the credential in the Keychain. Use this when you’ll want this credential on a consistent basis as long as the user has the app installed.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">NSURLCredentialPersistenceSynchronizable</span></p></td>
<td class="table" valign="top"><p class="table">Store the credential in the Keychain, and allow it to be synchronized to other devices and iCloud. Use this when you want to have people transfer the credential between devices and don’t have concerns about sending the credential to a third party like iCloud.</p></td>
</tr>
</tbody>
</table>
<h4 class="h4" id="ch07lev2sec03"><em><strong>Implementing TLS Mutual Authentication with NSURLConnection</strong></em></h4>
<p class="noindent">One of the best methods of performing client authentication is to use a client certificate and private key; however, this is somewhat convoluted on iOS. The basic concept is relatively simple: implement a delegate for <span class="literal">willSendRequestForAuthenticationChallenge</span> (formerly <span class="literal">didReceiveAuthenticationChallenge</span>), check whether the authentication method is <span class="literal">NSURLAuthenticationMethodClientCertificate</span>, retrieve and load a certificate and private key, build a credential, and use the credential for the challenge. Unfortunately, there aren’t built-in Cocoa APIs for managing certificates, so you’ll need to muck about with Core Foundation a fair bit, like in this basic framework:</p>
<p class="programs">   - (<span class="rose">void</span>)<span class="violet">connection</span>:(<span class="violet1">NSURLConnection</span> *) <span class="violet">willSendRequestForAuthenticationChallenge</span>:(<br/>        <span class="violet1">NSURLAuthenticationChallenge</span> *)challenge {<br/>       <span class="rose">if</span> ([[[challenge protectionSpace] authenticationMethod] <span class="violet">isEqualToString</span>:<span class="violet1">NS</span><br/>        <span class="violet1">URLAuthenticationMethodClientCertificate])</span> {<br/><br/>           <span class="green">SecIdentityRef</span> identity;<br/>           <span class="green">SecTrustRef</span> trust;<br/><span class="ent">➊</span>         <span class="green">extractIdentityAndTrus</span>t(somep12Data, &amp;identity, &amp;trust);<br/>           <span class="green">SecCertificateRef</span> certificate;<br/><span class="ent">➋</span>         SecIdentityCopyCertificate(identity, &amp;certificate);<br/><span class="ent">➌</span>         <span class="rose">const void</span> *certificates[] = { certificate };<br/><span class="ent">➍</span>         <span class="green">CFArrayRef</span> arrayOfCerts = CFArrayCreate(kCFAllocatorDefault, certificates,<br/>        1, NULL);<br/><br/><span class="ent">➎</span>         <span class="violet1">NSURLCredential</span> *cred = [<span class="violet1">NSURLCredential</span> credentialWithIdentity:identity<br/>        certificates:(__bridge <span class="violet1">NSArray*)arrayOfCerts</span><br/>         persistence:<span class="violet1">NSURLCredentialPersistenceNone];</span><br/><span class="ent">➏</span>         [[challenge sender] useCredential:cred<br/>                 forAuthenticationChallenge:challenge];<br/>       }<br/>   }</p>
<p class="indent"><a id="page_113"/>This example creates a <span class="literal">SecIdentityRef</span> and <span class="literal">SecTrustRef</span> so that it has destinations to pass to the <span class="literal">extractIdentityAndTrust</span> function at <span class="ent">➊</span>. This function will extract the identity and trust information from a blob of PKCS #12 data (file extension <em>.p12</em>). These archive files just store a bunch of cryptography objects in one place.</p>
<p class="indent">The code then makes a <span class="literal">SecCertificateRef</span> into which it extracts the certificate from the identity <span class="ent">➋</span>. Next, it builds an array containing the one certificate at <span class="ent">➌</span> and creates a <span class="literal">CFArrayRef</span> to hold that certificate at <span class="ent">➍</span>. Finally, the code creates an <span class="literal">NSURLCredential</span>, passing in its identity and its array of certificates with only one element <span class="ent">➎</span>, and presents this credential as the answer to its challenge <span class="ent">➏</span>.</p>
<p class="indent">You’ll notice some handwaving around <span class="ent">➊</span>. This is because obtaining the actual certificate p12 data can happen a few different ways. You can perform a one-time bootstrap and fetch a newly generated certificate over a secure channel, generate a certificate locally, read one from the filesystem, or fetch one from the Keychain. One way to get the certificate information used in <span class="literal">somep12Data</span> is by retrieving it from the filesystem, like this:</p>
<p class="programs"><span class="violet1">NSData</span> *myP12Certificate = [<span class="violet1">NSData</span> dataWithContentsOfFile:path];<br/>CFDataRef somep12Data = (__bridge CFDataRef)myP12Certificate;</p>
<p class="indent">The best place to store certificates of course is the Keychain; I’ll cover that further in <a href="ch13.html#ch13">Chapter 13</a>.</p>
<h4 class="h4" id="ch07lev2sec04"><em><strong>Modifying Redirect Behavior</strong></em></h4>
<p class="noindent">By default, <span class="literal">NSURLConnection</span> will follow HTTP redirects when it encounters them. However, its behavior when this happens is, well, unusual. When the redirect is encountered, <span class="literal">NSURLConnection</span> will send a request, containing the HTTP headers as they were used in the original <span class="literal">NSURLHttpRequest</span>, to the new location. Unfortunately, this also means that the current value of your cookies for the original domain is passed to the new location. As a result, if an attacker can get your application to visit a page on your site that accepts <a id="page_114"/>an arbitrary URL as a place to redirect to, that attacker can steal your users’ cookies, as well as any other sensitive data that your application might store in its HTTP headers. This type of flaw is called an <em>open redirect</em>.</p>
<p class="indent">You can modify this behavior by implementing <span class="literal">connect:willSendRequest: redirectResponse</span><sup><a href="footnote.html#fn64" id="fn_64">3</a></sup> on your <span class="literal">NSURLConnectionDelegate</span> in iOS 4.3 and older, or on your <span class="literal">NSURLConnectionDataDelegate</span> in iOS 5.0 and newer.<sup><a href="footnote.html#fn65" id="fn_65">4</a></sup></p>
<p class="programs">   - (<span class="violet1">NSURLRequest</span> *)<span class="violet">connection</span>:(<span class="violet1">NSURLConnection</span> *)<span class="violet">connection</span><br/>                <span class="violet">willSendRequest</span>:(<span class="violet1">NSURLRequest</span> *)request<br/>               <span class="violet">redirectResponse</span>:(<span class="violet1">NSURLResponse</span> *)<span class="violet">redirectResponse</span><br/>   {<br/>       <span class="violet1">NSURLRequest</span> *newRequest = request;<br/><span class="ent">➊</span>     <span class="rose">if</span> (![[[<span class="violet">redirectResponse</span> URL] host] isEqual:<span class="red">@"myhost.com"</span>]) {<br/>           <span class="rose">return</span> newRequest;<br/>       }<br/><br/>       <span class="rose">else</span> {<br/><span class="ent">➋</span>         newRequest = nil;<br/>           <span class="rose">return</span> newRequest;<br/>       }<br/>   }</p>
<p class="indent">At <span class="ent">➊</span>, this code checks whether the domain you’re redirecting to is different from the name of your site. If it’s the same, it carries on as normal. If it’s different, it modifies the request to be <span class="literal">nil</span> <span class="ent">➋</span>.</p>
<h4 class="h4" id="ch07lev2sec05"><em><strong>TLS Certificate Pinning</strong></em></h4>
<p class="noindent">In the past several years, there have been a number of troubling developments regarding certificate authorities (CAs), the entities that vouch for the TLS certificates that we encounter on a daily basis. Aside from the massive number of signing authorities trusted by your average client application, CAs have had several prominent security breaches where signing keys were compromised or where overly permissive certificates were issued. These breaches allow anyone in possession of the signing key to impersonate any TLS server, meaning they can successfully and transparently read or modify requests to the server and their responses.</p>
<p class="indent">To help mitigate these attacks, client applications of many types have implemented <em>certificate pinning</em>. This term can refer to a number of different techniques, but the core idea is to programmatically restrict the number of certificates that your application will trust. You could limit trust to a single <a id="page_115"/>CA (that is, the one that your company uses to sign its server certificates), to an internal root CA that you use to create your own certificates (the top of the chain of trust), or simply to a leaf certificate (a single specific certificate at the bottom of the chain of trust).</p>
<p class="indent">As part of the SSL Conservatory project, my colleague Alban Diquet has developed some convenient wrappers that allow you to implement certificate pinning in your application. (Learn more at <em><a href="https://github.com/iSECPartners/ssl-conservatory">https://github.com/iSECPartners/ssl-conservatory</a></em>.) You could write your own wrapper or use an existing one; either way, a good wrapper can make pinning rather simple. For example, here’s a look at how easy it would be to implement certificate pinning with Alban’s wrapper:</p>
<p class="programs"><span class="ent">➊</span> - (<span class="violet1">NSData*)</span><span class="violet">loadCertificateFromFile</span><span class="violet1">:(NSString*)fileName {</span><br/>       <span class="violet1">NSString</span> *certPath = [[<span class="violet1">NSString</span> <span class="violet">alloc</span>] initWithFormat:<span class="red">@"%@/%@"</span>, [[<span class="violet1">NSBundle</span><br/>        mainBundle] bundlePath], fileName];<br/>       <span class="violet1">NSData</span> *certData = [[<span class="violet1">NSData</span> <span class="violet">alloc</span>] initWithContentsOfFile:certPath];<br/>       <span class="rose">return</span> certData;<br/>   }<br/><br/>   - (<span class="rose">void</span>)pinThings {<br/>   <span class="violet1">NSMutableDictionary</span> *domainsToPin = [[<span class="violet1">NSMutableDictionary</span> <span class="violet">alloc</span>] <span class="violet">init</span>];<br/><br/><span class="ent">➋</span> <span class="violet1">NSData</span> *myCertData = [<span class="rose">self</span> <span class="violet">loadCertificateFromFile</span>:<span class="red">@"myCerts.der"</span>];<br/>   <span class="rose">if</span> (myCertData == nil) {<br/>       <span class="violet1">NSLog(</span><span class="red">@"Failed to load the certificates"</span><span class="violet1">);</span><br/>       <span class="rose">return</span>;<br/>       }<br/><br/><span class="ent">➌</span> [domainsToPin <span class="violet">setObject</span>:myCertData forKey:<span class="red">@"myhost.com"</span>];<br/><br/><span class="ent">➍</span> <span class="rose">if</span> ([<span class="green">SSLCertificatePinning</span> loadSSLPinsFromDERCertificates:domainsToPin] != YES) {<br/>       <span class="violet1">NSLog(</span><span class="red">@"Failed to pin the certificates"</span><span class="violet1">);</span><br/>       <span class="rose">return</span>;<br/>       }<br/>   }</p>
<p class="indent">At <span class="ent">➊</span>, this code simply defines a method to load a certificate from a DER-formatted file into an <span class="literal">NSData</span> object and calls this method at <span class="ent">➋</span>. If this is successful, the code puts <span class="literal">myCertData</span> into an <span class="literal">NSMutableDictionary</span> <span class="ent">➌</span> and calls the <span class="literal">loadSSLPinsFromDERCertificates</span> method of the main <span class="literal">SSLCertificatePinning</span> class <span class="ent">➍</span>. With these pins loaded, an app would also need to implement an <span class="literal">NSURLConnection</span> delegate, as shown in <a href="ch07.html#ch7ex4">Listing 7-4</a>.</p>
<p class="programs"><a id="page_116"/>- (<span class="rose">void</span>)<span class="violet">connection</span>:(<span class="violet1">NSURLConnection</span> *)<span class="violet">connection</span><br/>     <span class="violet">willSendRequestForAuthenticationChallenge</span>:(<span class="violet1">NSURLAuthenticationChallenge</span> *)<br/>     challenge {<br/><br/>    <span class="rose">if</span>([challenge.protectionSpace.authenticationMethod <span class="violet">isEqualToString</span>:<span class="violet1">NS</span><br/>     <span class="violet1">URLAuthenticationMethodServerTrust])</span> {<br/><br/>        <span class="green">SecTrustRef</span> serverTrust = [[challenge protectionSpace] serverTrust];<br/>        <span class="violet1">NSString</span> *domain = [[challenge protectionSpace] host];<br/>        <span class="violet">SecTrustResultType</span> trustResult;<br/><br/>        <span class="violet">SecTrustEvaluate</span>(serverTrust, &amp;trustResult);<br/>        <span class="rose">if</span> (trustResult == kSecTrustResultUnspecified) {<br/><br/>            <span class="green1"><span class="codeitalic">// Look for a pinned public key in the server's certificate chain</span></span><br/>            <span class="rose">if</span> ([<span class="green">SSLCertificatePinning</span> verifyPinnedCertificateForTrust:serverTrust<br/>     andDomain:domain]) {<br/><br/>                <span class="green1"><span class="codeitalic">// Found the certificate; continue connecting</span></span><br/>                [challenge.sender useCredential:[<span class="violet1">NSURLCredential</span> <span class="violet">credentialForTrust</span><br/>     :challenge.protectionSpace.serverTrust] forAuthenticationChallenge:challenge];<br/>            }<br/>            <span class="rose">else</span> {<br/>                <span class="green1"><span class="codeitalic">// Certificate not found; cancel the connection</span></span><br/>                [[challenge sender] <span class="violet">cancelAuthenticationChallenge</span>: challenge];<br/>            }<br/>        }<br/>        <span class="rose">else</span> {<br/>            <span class="green1"><span class="codeitalic">// Certificate chain validation failed; cancel the connection</span></span><br/>            [[challenge sender] <span class="violet">cancelAuthenticationChallenge</span>: challenge];<br/>        }<br/>    }<br/>}</p>
<p class="listcap"><a id="ch7ex4"/><em>Listing 7-4: An</em> <span class="literal">NSURLConnection</span> <em>delegate to handle certificate pinning logic</em></p>
<p class="indent">This simply evaluates the certificate chain presented by a remote server and compares it to the pinned certificates included with your application. If a pinned certificate is found, the connection continues; if it isn’t, the authentication challenge process is canceled.</p>
<p class="indent">With your delegate implemented as shown, all your uses of <span class="literal">NSURLConnection</span> should check to ensure that they are pinned to a domain and certificate pair in your predefined list. If you’re curious, you can <a id="page_117"/>find the rest of the code to implement your own certificate pinning at <em><a href="https://github.com/iSECPartners/ssl-conservatory/tree/master/ios">https://github.com/iSECPartners/ssl-conservatory/tree/master/ios</a></em>. There’s a fair bit of other logic involved, so I can’t show all the code here.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>If you’re in a hurry, a delegate that you can just subclass is included in the SSL Conservatory sample code.</em></p>
</div>
<p class="indent">Up to now, I’ve shown network security issues and solutions that revolve around <span class="literal">NSURLConnection</span>. But as of iOS 7, <span class="literal">NSURLSession</span> is preferred over the traditional <span class="literal">NSURLConnection</span> class. Let’s take a closer look at this API.</p>
<h3 class="h3" id="ch07lev1sec02"><strong>Using NSURLSession</strong></h3>
<p class="noindent">The <span class="literal">NSURLSession</span> class is generally favored by developers because it focuses on the use of network <em>sessions</em>, as opposed to <span class="literal">NSURLConnection</span>’s focus on individual requests. While broadening the scope of <span class="literal">NSURLConnection</span> somewhat, <span class="literal">NSURLSession</span> also gives additional flexibility by allowing configurations to be set on individual sessions rather than globally throughout the application. Once sessions are instantiated, they are handed individual tasks to perform, using the <span class="literal">NSURLSessionDataTask</span>, <span class="literal">NSURLSessionUploadTask</span>, and <span class="literal">NSURLSessionDownloadTask</span> classes.</p>
<p class="indent">In this section, you’ll explore some ways to use <span class="literal">NSURLSession</span>, some potential security pitfalls, and some security mechanisms not provided by the older <span class="literal">NSURLConnection</span>.</p>
<h4 class="h4" id="ch07lev2sec06"><em><strong>NSURLSession Configuration</strong></em></h4>
<p class="noindent">The <span class="literal">NSURLSessionConfiguration</span> class encapsulates options passed to <span class="literal">NSURLSession</span> objects so that you can have separate configurations for separate types of requests. For example, you can apply different caching and cookie policies to requests fetching data of varying sensitivity levels, rather than having these policies be app-wide. To use the system policies for <span class="literal">NSURLSession</span> configuration, you can use the default policy of <span class="literal">[NSURLSessionConfigurationdefaultConfiguration]</span>, or you can simply neglect to specify a configuration policy and instantiate your request object with <span class="literal">[NSURLSessionsharedSession]</span>.</p>
<p class="indent">For security-sensitive requests that should leave no remnants on local storage, the configuration method <span class="literal">ephemeralSessionConfiguration</span> should be used instead. A third method, <span class="literal">backgroundSessionConfiguration</span>, is available specifically for long-running upload or download tasks. This type of session will be handed off to a system service to manage completion, even if your application is killed or crashes.</p>
<p class="indent">Also, for the first time, you can specify that a connection use only TLS version 1.2, which helps defend against attacks such as BEAST<sup><a href="footnote.html#fn66" id="fn_66">5</a></sup> and <a id="page_118"/>CRIME,<sup><a href="footnote.html#fn67" id="fn_67">6</a></sup> both of which can allow network attackers to read or tamper with your TLS connections.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>Session configurations are read-only after an</em> <span class="literal"><em>NSURLSession</em></span> <em>is instantiated; policies and configurations cannot be changed mid-session, and you cannot swap out for a separate configuration.</em></p>
</div>
<h4 class="h4" id="ch07lev2sec07"><em><strong>Performing NSURLSession Tasks</strong></em></h4>
<p class="noindent">Let’s walk through the typical flow of creating an <span class="literal">NSURLSessionConfiguration</span> and assigning it a simple task, as shown in <a href="ch07.html#ch7ex5">Listing 7-5</a>.</p>
<p class="programs"><span class="ent">➊</span> <span class="violet1">NSURLSessionConfiguration</span> *configuration = [<span class="violet1">NSURLSessionConfiguration</span><br/>        <span class="violet">ephemeralSessionConfiguration</span>];<br/><br/><span class="ent">➋</span> [configuration setTLSMinimumSupportedProtocol = kTLSProtocol12];<br/><br/><span class="ent">➌</span> <span class="violet1">NSURL</span> *url = [<span class="violet1">NSURL</span> URLWithString:<span class="red">@"https://www.mycorp.com"</span>];<br/><br/>   <span class="violet1">NSURLRequest</span> *request = [<span class="violet1">NSURLRequest</span> <span class="violet">requestWithURL</span>:url];<br/><br/><span class="ent">➍</span> <span class="violet1">NSURLSession</span> *session = [<span class="violet1">NSURLSession</span> <span class="violet">sessionWithConfiguration</span>:configuration<br/>                                                         delegate:<span class="rose">self</span><br/>                                                    delegateQueue:nil];<br/><br/><span class="ent">➎</span> <span class="violet1">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request<br/>                                           <span class="violet">completionHandler</span>:<br/>        ^(<span class="violet1">NSData</span> *data, <span class="violet1">NSURLResponse</span> *response, <span class="violet1">NSError</span> *error) {<br/><span class="ent">➏</span>         <span class="green1"><span class="codeitalic">// Your completion handler block</span></span><br/>        }];<br/><br/><span class="ent">➐</span> [task resume];</p>
<p class="listcap"><a id="ch7ex5"/><em>Listing 7-5: Creating an ephemeral</em> <span class="literal">NSURLConfiguration</span> <em>requiring TLSv1.2</em></p>
<p class="indent">The <span class="literal">NSURLSessionConfiguration</span> object is instantiated at <span class="ent">➊</span>, with the specification that the connection should be ephemeral. This should prevent cached data from being written to local storage. Then, at <span class="ent">➋</span>, the configuration also requires TLS version 1.2 since the developer controls the endpoint and knows that it supports that version. Next, just as with <span class="literal">NSURLConnection</span>, an <span class="literal">NSURL</span> object and an <span class="literal">NSURLRequest</span> object with that URL <span class="ent">➌</span> are created. With the configuration and request created, the app can then instantiate the session <span class="ent">➍</span> and assign a task to that session <span class="ent">➎</span>.</p>
<p class="indent"><a id="page_119"/><span class="literal">NSURLSessionDataTask</span> and its siblings take a completion handler block as an argument <span class="ent">➏</span>. This block asynchronously handles the server response and data you receive as a result of the task. Alternatively (or in addition), you can specify a custom delegate conforming to the <span class="literal">NSURLSessionTaskDelegate</span> protocol. One reason you may want to use both a <span class="literal">completionHandler</span> and a delegate is to have the completion handler take care of the results of the request, while the delegate manages authentication and caching decisions on a session basis instead of a task basis (I’ll talk about this in the next section).</p>
<p class="indent">Finally, at <span class="ent">➐</span>, this code sets the task running with a call to its <span class="literal">resume</span> method because all tasks are suspended upon creation.</p>
<h4 class="h4" id="ch07lev2sec08"><em><strong>Spotting NSURLSession TLS Bypasses</strong></em></h4>
<p class="noindent"><span class="literal">NSURLSession</span> has a way to avoid TLS checks as well. Apps can just use the <span class="literal">didReceiveChallenge</span> delegate and pass the <span class="literal">proposedCredential</span> of the challenge received back as a credential for the session, as in <a href="ch07.html#ch7ex6">Listing 7-6</a>.</p>
<p class="programs">   - (<span class="rose">void</span>)URLSession:(<span class="violet1">NSURLSession</span> *)session didReceiveChallenge:(<span class="violet1">NS</span><br/>        <span class="violet1">URLAuthenticationChallenge</span> *)challenge <span class="violet">completionHandler</span>:(<span class="rose">void</span> (^)(<span class="violet1">NS</span><br/>        <span class="violet1">URLSessionAuthChallengeDisposition</span> disposition, <span class="violet1">NSURLCredential</span> * credential))<br/>        <span class="violet">completionHandler</span> {<br/><br/><span class="ent">➊</span>      <span class="violet">completionHandler</span>(<span class="violet1">NSURLSessionAuthChallengeUseCredential,</span><br/>          [challenge proposedCredential]);<br/>   }</p>
<p class="listcap"><a id="ch7ex6"/><em>Listing 7-6: Bypassing server verification with</em> <span class="literal"><span class="violet1">NSURLSession</span></span></p>
<p class="indent">This is another bypass that can be tricky to spot. Look for code like that at <span class="ent">➊</span>, where there’s a <span class="literal">completionHandler</span> followed by <span class="literal">proposedCredential</span>.</p>
<h4 class="h4" id="ch07lev2sec09"><em><strong>Basic Authentication with NSURLSession</strong></em></h4>
<p class="noindent">HTTP authentication with <span class="literal">NSURLSession</span> is handled by the session and is passed to the <span class="literal">didReceiveChallenge</span> delegate, as shown in <a href="ch07.html#ch7ex7">Listing 7-7</a>.</p>
<p class="programs"><span class="ent">➊</span> - (<span class="rose">void</span>)URLSession:(<span class="violet1">NSURLSession</span> *)session didReceiveChallenge:(<span class="violet1">NS</span><br/>        <span class="violet1">URLAuthenticationChallenge</span> *)challenge <span class="violet">completionHandler</span>:(<span class="rose">void</span> (^)(<span class="violet1">NS</span><br/>        <span class="violet1">URLSessionAuthChallengeDisposition, NSURLCredential</span> *))<span class="violet">completionHandler</span> {<br/>       <span class="violet1">NSString</span> *user = <span class="red">@"user"</span>;<br/>       <span class="violet1">NSString</span> *pass = <span class="red">@"pass"</span>;<br/><br/>       <span class="violet1">NSURLProtectionSpace</span> *space = [challenge protectionSpace];<br/>        <span class="rose">if</span> ([space receivesCredentialSecurely] == YES &amp;&amp;<br/>            [[space host] <span class="violet">isEqualToString</span>:<span class="red">@"myhost.com"</span>] &amp;&amp;<br/>            [[space authenticationMethod] <span class="violet">isEqualToString</span>:<span class="violet1">NS</span><br/>        <span class="violet1">URLAuthenticationMethodHTTPBasic])</span> {<br/><br/><span class="ent">➋</span>    <span class="violet1">NSURLCredential</span> *credential =<br/>        [<span class="violet1">NSURLCredential</span> credentialWithUser:user<br/>                                   password:pass<br/>                                persistence:<span class="violet1">NSURLCredentialPersistenceForSession];</span><br/><br/><span class="ent">➌</span>    <span class="violet">completionHandler</span>(<span class="violet1">NSURLSessionAuthChallengeUseCredential,</span> credential);<br/>       }<br/>   }</p>
<p class="listcap"><a id="ch7ex7"/><em>Listing 7-7: A sample</em> <span class="literal">didReceiveChallenge</span> <em>delegate</em></p>
<p class="indent"><a id="page_120"/>This approach defines a delegate and a completion handler at <span class="ent">➊</span>, creates an <span class="literal">NSURLCredential</span> at <span class="ent">➋</span>, and passes that credential to the completion handler at <span class="ent">➌</span>. Note that for either the <span class="literal">NSURLConnection</span> or <span class="literal">NSURLSession</span> approach, some developers forget to ensure that they’re talking to the correct host or sending credentials securely. This would result in credentials getting sent to <em>every</em> URL your app loads, instead of just yours; <a href="ch07.html#ch7ex8">Listing 7-8</a> shows an example of what that mistake might look like.</p>
<p class="programs">- (<span class="rose">void</span>)URLSession:(<span class="violet1">NSURLSession</span> *)session didReceiveChallenge:(<span class="violet1">NS</span><br/>     <span class="violet1">URLAuthenticationChallenge</span> *)challenge <span class="violet">completionHandler</span>:(<span class="rose">void</span> (^)(<span class="violet1">NS</span><br/>     <span class="violet1">URLSessionAuthChallengeDisposition, NSURLCredential</span> *))<span class="violet">completionHandler</span> {<br/><br/>    <span class="violet1">NSURLCredential</span> *credential =<br/>      [<span class="violet1">NSURLCredential</span> credentialWithUser:user<br/>                                 password:pass<br/>                              persistence:<span class="violet1">NSURLCredentialPersistenceForSession];</span><br/><br/>    <span class="violet">completionHandler</span>(<span class="violet1">NSURLSessionAuthChallengeUseCredential,</span> credential);<br/>}</p>
<p class="listcap"><a id="ch7ex8"/><em>Listing 7-8: The wrong way to do HTTP auth</em></p>
<p class="indent">If you want to use persistent credentials for a dedicated endpoint, you can store them in <span class="literal">sharedCredentialStorage</span> as you did with <span class="literal">NSURLConnection</span>. When constructing your session, you can provide these credentials beforehand without having to worry about a delegate method, as shown in <a href="ch07.html#ch7ex9">Listing 7-9</a>.</p>
<p class="programs"><span class="violet1">NSURLSessionConfiguration</span> *config = [<span class="violet1">NSURLSessionConfiguration</span><br/>     defaultSessionConfiguration];<br/>[config setURLCredentialStorage:<br/>    [<span class="violet1">NSURLCredentialStorage</span> sharedCredentialStorage]];<br/><br/><span class="violet1">NSURLSession</span> *session = [<span class="violet1">NSURLSession</span> <span class="violet">sessionWithConfiguration</span>:config<br/>                                                      delegate:nil<br/>                                                 delegateQueue:nil];</p>
<p class="listcap"><a id="ch7ex9"/><em>Listing 7-9: Using an</em> <span class="literal">NSURLSessionConfiguration</span> <em>to reference stored credentials</em></p>
<p class="indent"><a id="page_121"/>This just creates an <span class="literal">NSURLSessionConfiguration</span> and specifies that it should use the shared credential storage. When you connect to a resource that has credentials stored in the Keychain, those will be used by the session.</p>
<h4 class="h4" id="ch07lev2sec10"><em><strong>Managing Stored URL Credentials</strong></em></h4>
<p class="noindent">You’ve seen how to store and read credentials using <span class="literal">sharedCredentialStorage</span>, but the <span class="literal">NSURLCredentialStorage</span> API also lets you remove credentials using the <span class="literal">removeCredential:forProtectionSpace</span> method. For example, you may want to do this when a user explicitly decides to log out of an application or remove an account. <a href="ch07.html#ch7ex10">Listing 7-10</a> shows a typical use case.</p>
<p class="programs"><span class="violet1">NSURLProtectionSpace</span> *space = [[<span class="violet1">NSURLProtectionSpace</span> <span class="violet">alloc</span>]<br/>     initWithHost:<span class="red">@"myhost.com"</span><br/>             port:443<br/>         protocol:<span class="red">@"https"</span><br/>            realm:nil authenticationMethod:nil];<br/><br/><span class="violet1">NSURLCredential</span> *credential = [credentialStorage<br/>     defaultCredentialForProtectionSpace:space];<br/><br/>[[<span class="violet1">NSURLCredentialStorage</span> sharedCredentialStorage] removeCredential:credential<br/>                                                forProtectionSpace:space];</p>
<p class="listcap"><a id="ch7ex10"/><em>Listing 7-10: Removing default credentials</em></p>
<p class="indent">This will delete the credentials from your local Keychain. However, if a credential has a persistence of <span class="literal">NSURLCredentialPersistenceSynchronizable</span>, the credential may have been synchronized to other devices via iCloud. To remove the credentials from all devices, use the <span class="literal">NSURLCredentialStorageRemoveSynchronizableCredentials</span> option, as shown in <a href="ch07.html#ch7ex11">Listing 7-11</a>.</p>
<p class="programs"><span class="violet1">NSDictionary</span> *options = [<span class="violet1">NSDictionary</span> dictionaryWithObjects forKeys<span class="violet1">:NS</span><br/>     <span class="violet1">URLCredentialStorageRemoveSynchronizableCredentials,</span> YES];<br/><br/>[[<span class="violet1">NSURLCredentialStorage</span> sharedCredentialStorage] removeCredential:credential<br/>                                                forProtectionSpace:space<br/>                                                           options:options];</p>
<p class="listcap"><a id="ch7ex11"/><em>Listing 7-11: Removing credentials from the local Keychain and from iCloud</em></p>
<p class="indent"><a id="page_122"/>At this point, you should have an understanding of the <span class="literal">NSURLConnection</span> and <span class="literal">NSURLSession</span> APIs and their basic usage. There are other network frameworks that you may encounter, which have their own behaviors and require slightly different security configuration. I’ll cover a few of these now.</p>
<h3 class="h3" id="ch07lev1sec03"><strong>Risks of Third-Party Networking APIs</strong></h3>
<p class="noindent">There are a few popular third-party networking APIs used in iOS applications, largely for simplifying various networking tasks such as multipart uploads and certificate pinning. The most commonly used one is AFNetworking,<sup><a href="footnote.html#fn68" id="fn_68">7</a></sup> followed by the now-obsolete ASIHTTPRequest.<sup><a href="footnote.html#fn69" id="fn_69">8</a></sup> In this section, I’ll introduce you to both.</p>
<h4 class="h4" id="ch07lev2sec11"><em><strong>Bad and Good Uses of AFNetworking</strong></em></h4>
<p class="noindent">AFNetworking is a popular library built on top of <span class="literal">NSOperation</span> and <span class="literal">NSHTTPRequest</span>. It provides several convenience methods to interact with different types of web APIs and perform common HTTP networking tasks.</p>
<p class="indent">As with other networking frameworks, one crucial task is to ensure that TLS safety mechanisms have not been disabled. In AFNetworking, TLS certificate validation can be disabled in a few ways. One is via the <span class="literal">_AFNETWORKING_ALLOW_INVALID_SSL_CERTIFICATES</span> flag, typically set in the <em>Prefix.pch</em> file. Another way is to set a property of <span class="literal">AFHTTPClient</span>, as in <a href="ch07.html#ch7ex12">Listing 7-12</a>.</p>
<p class="programs"><span class="violet1">NSURL</span> *baseURL = [<span class="violet1">NSURL</span> URLWithString:<span class="red">@"https://myhost.com"</span>];<br/><span class="green">AFHTTPClient*</span> client = [<span class="green">AFHTTPClient</span> <span class="violet">clientWithBaseURL</span>:baseURL];<br/>[client setAllowsInvalidSSLCertificate:YES];</p>
<p class="listcap"><a id="ch7ex12"/><em>Listing 7-12: Disabling TLS validation with</em> <span class="literal">setAllowsInvalidSSLCertificate</span></p>
<p class="indent">The last way you might see TLS validation being disabled is by changing the security policy of <span class="literal">AFHTTPRequestOperationManager</span> with <span class="literal">setAllowsInvalidSSLCertificate</span>, as shown in <a href="ch07.html#ch7ex13">Listing 7-13</a>.</p>
<p class="programs"><span class="green">AFHTTPRequestOperationManager</span> *manager = [<span class="green">AFHTTPRequestOperationManager</span> manager];<br/>[manager [securityPolicy <span class="violet">setAllowInvalidCertificates</span>:YES]];</p>
<p class="listcap"><a id="ch7ex13"/><em>Listing 7-13: Disabling TLS validation using</em> <span class="literal">securityPolicy</span></p>
<p class="indent"><a id="page_123"/>You’ll also want to verify that the code you’re examining doesn’t use the <span class="literal">AFHTTPRequestOperationLogger</span> class in production versions. This logger uses <span class="literal">NSLog</span> on the backend to write requested URLs to the Apple System Log, allowing them to be seen by other applications on some iOS versions.</p>
<p class="indent">One particularly useful feature that AFNetworking provides is the ability to easily perform certificate pinning. You can just set the <span class="literal">_AFNETWORKING_PIN_SSL_CERTIFICATES_</span> #define in your project’s <em>.pch</em> file, and set the pinning mode (<span class="literal">defaultSSLPinningMode</span>) property of your <span class="literal">AFHTTPClient</span> instance appropriately; the available modes are described in <a href="ch07.html#ch7tab2">Table 7-2</a>. You then put the certificates that you want to pin to in the bundle root, as files with a <em>.cer</em> extension.</p>
<p class="tablecap"><a id="ch7tab2"/><strong>Table 7-2:</strong> AFNetworking SSL Pinning Modes</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="80%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Mode</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Meaning</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">AFSSLPinningModeNone</span></p></td>
<td class="table" valign="top"><p class="table">Perform no certificate pinning, even if pinning is enabled. Use for debug mode if necessary.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">AFSSLPinningModePublicKey</span></p></td>
<td class="table" valign="top"><p class="table">Pin to the certificate’s public key.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">AFSSLPinningModeCertificate</span></p></td>
<td class="table" valign="top"><p class="table">Pin to the exact certificate (or certificates) supplied. This will require an application update if a certificate is reissued.</p></td>
</tr>
</tbody>
</table>
<p class="indent">As shown in sample code included with AFNetworking, you can examine URLs to determine whether they should be pinned. Just evaluate the scheme and domain name to see whether those domains belong to you. <a href="ch07.html#ch7ex14">Listing 7-14</a> shows an example.</p>
<p class="programs"><span class="rose">if</span> ([[url scheme] <span class="violet">isEqualToString</span>:<span class="red">@"https"</span>] &amp;&amp;<br/>    [[url host] <span class="violet">isEqualToString</span>:<span class="red">@"yourpinneddomain.com"</span>]) {<br/>        [<span class="rose">self</span> <span class="violet">setDefaultSSLPinningMode</span>:<span class="green">AFSSLPinningModePublicKey];</span><br/>    }<br/><br/>    <span class="rose">else</span> {<br/>        [<span class="rose">self</span> <span class="violet">setDefaultSSLPinningMode</span>:<span class="green">AFSSLPinningModeNone];</span><br/>    }<br/><br/>    <span class="rose">return self</span>;<br/>}</p>
<p class="listcap"><a id="ch7ex14"/><em>Listing 7-14: Determining whether a URL should be pinned</em></p>
<p class="indent">The <span class="literal">else</span> statement is not strictly necessary because not pinning is the default, but it does provide some clarity.</p>
<p class="indent">Keep in mind that AFNetworking pins to all certificates provided in the bundle, but it doesn’t check that the certificate common name and the hostname of the network endpoint match. This is mostly an issue <a id="page_124"/>if your application pins to multiple sites with different security standards. In other words, if your application pins to both <em><a href="https://funnyimages.com">https://funnyimages.com</a></em> and <em><a href="https://www.bank.com">https://www.bank.com</a></em>, an attacker in possession of the <em>funnyimages.com</em> private key would be able to intercept communications from your application to <em>bank.com</em>.</p>
<p class="indent">Now that you’ve had a glimpse at how you can use and abuse the AFNetworking library, let’s move on to ASIHTTPRequest.</p>
<h4 class="h4" id="ch07lev2sec12"><em><strong>Unsafe Uses of ASIHTTPRequest</strong></em></h4>
<p class="noindent">ASIHTTPRequest is a deprecated library similar to AFNetworking, but it’s a bit less complete and is based on the CFNetwork API. It should not be used for new projects, but you may find it in existing codebases where migration has been considered too expensive. When examining these codebases, the standard SSL validation bypass to look for is <span class="literal">setValidatesSecureCertificate:NO</span>.</p>
<p class="indent">You’ll also want to examine <em>ASIHTTPRequestConfig.h</em> in your project to ensure that overly verbose logging is not enabled (see <a href="ch07.html#ch7ex15">Listing 7-15</a>).</p>
<p class="programs"><span class="green1"><span class="codeitalic">// If defined, will use the specified function for debug logging</span></span><br/><span class="green1"><span class="codeitalic">// Otherwise use NSLog</span></span><br/><span class="brown">#ifndef ASI_DEBUG_LOG</span><br/>    <span class="brown">#define ASI_DEBUG_LOG NSLog</span><br/><span class="brown">#endif</span><br/><br/><span class="green1"><span class="codeitalic">// When set to 1, ASIHTTPRequests will print information about what a request is</span></span><br/>      <span class="green1"><span class="codeitalic">doing</span></span><br/><span class="brown">#ifndef DEBUG_REQUEST_STATUS</span><br/>    <span class="brown">#define DEBUG_REQUEST_STATUS 0</span><br/><span class="brown">#endif</span><br/><br/><span class="green1"><span class="codeitalic">// When set to 1, ASIFormDataRequests will print information about the request body</span></span><br/>      <span class="green1"><span class="codeitalic">to the console</span></span><br/><span class="brown">#ifndef DEBUG_FORM_DATA_REQUEST</span><br/>    <span class="brown">#define DEBUG_FORM_DATA_REQUEST 0</span><br/><span class="brown">#endif</span><br/><br/><span class="green1"><span class="codeitalic">// When set to 1, ASIHTTPRequests will print information about bandwidth throttling</span></span><br/>      <span class="green1"><span class="codeitalic">to the console</span></span><br/><span class="brown">#ifndef DEBUG_THROTTLING</span><br/>    <span class="brown">#define DEBUG_THROTTLING 0</span><br/><span class="brown">#endif</span><br/><br/><span class="green1"><span class="codeitalic">// When set to 1, ASIHTTPRequests will print information about persistent</span></span><br/>      <span class="green1"><span class="codeitalic">connections to the console</span></span><br/><span class="brown">#ifndef DEBUG_PERSISTENT_CONNECTIONS</span><br/>    <span class="brown">#define DEBUG_PERSISTENT_CONNECTIONS 0</span><br/><span class="brown">#endif</span><br/><br/><span class="green1"><span class="codeitalic">// When set to 1, ASIHTTPRequests will print information about HTTP authentication</span></span><br/>      <span class="green1"><span class="codeitalic">(Basic, Digest or NTLM) to the console</span></span><br/><span class="brown">#ifndef DEBUG_HTTP_AUTHENTICATION</span><br/>    <span class="brown">#define DEBUG_HTTP_AUTHENTICATION 0</span><br/><span class="brown">#endif</span></p>
<p class="listcap"><a id="ch7ex15"/><em>Listing 7-15: Logging defines in</em> ASIHTTPRequestConfig.h</p>
<p class="indent"><a id="page_125"/>If you do want to use these logging facilities, you may want to wrap them in <span class="literal">#ifdef DEBUG</span> conditionals, like this:</p>
<p class="programs"><span class="brown">#ifndef DEBUG_HTTP_AUTHENTICATION</span><br/>    <span class="brown">#ifdef DEBUG</span><br/>        <span class="brown">#define DEBUG_HTTP_AUTHENTICATION 1</span><br/>    <span class="brown">#else</span><br/>        <span class="brown">#define DEBUG_HTTP_AUTHENTICATION 0</span><br/>    <span class="brown">#endif</span><br/><span class="brown">#endif</span></p>
<p class="indent">This <em>ASIHTTPRequestConfig.h</em> file wraps the logging facilities inside conditionals to keep this information from leaking in production builds.</p>
<h3 class="h3" id="ch07lev1sec04"><strong>Multipeer Connectivity</strong></h3>
<p class="noindent">iOS 7 introduced Multipeer Connectivity,<sup><a href="footnote.html#fn70" id="fn_70">9</a></sup> which allows nearby devices to communicate with each other with a minimal network configuration. Multipeer Connectivity communication can take place over Wi-Fi (either peer-to-peer or multipeer networks) or Bluetooth personal area networks (PANs). Bonjour is the default mechanism for browsing and advertising available services.</p>
<p class="indent">Developers can use Multipeer Connectivity to perform peer-to-peer file transfers or stream content between devices. As with any type of peer communication, the validation of incoming data from untrusted peers is crucial; however, there are also transport security mechanisms in place to ensure that the data is safe from eavesdropping.</p>
<p class="indent">Multipeer Connectivity sessions are created with either the <span class="literal">initWithPeer</span> or <span class="literal">initWithPeer:securityIdentity:encryptionPreference:</span> class method of the <span class="literal">MCSession</span> class. The latter method allows you to require encryption, as well as include a certificate chain to verify your device.</p>
<p class="indent">When specifying a value for <span class="literal">encryptionPreference</span>, your options are <span class="literal">MCEncryptionNone</span>, <span class="literal">MCEncryptionRequired</span>, and <span class="literal">MCEncryptionOptional</span>. Note that these are interchangeable with values of <span class="literal">0</span>, <span class="literal">1</span>, or <span class="literal">2</span>, respectively. So while <a id="page_126"/>values of <span class="literal">0</span> and <span class="literal">1</span> behave how you would expect if this value were a Boolean, a value of <span class="literal">2</span> is functionally equivalent to not having encryption at all.</p>
<p class="indent">It’s a good idea to require encryption unconditionally because <span class="literal">MCEncryptionOptional</span> is subject to downgrade attacks. (You can find more detail in Alban Diquet’s Black Hat talk on reversing the Multipeer Connectivity protocol.<sup><a href="footnote.html#fn71" id="fn_71">10</a></sup>) <a href="ch07.html#ch7ex16">Listing 7-16</a> shows a typical invocation, creating a session and requiring encryption.</p>
<p class="programs">MCPeerID *peerID = [[MCPeerID <span class="violet">alloc</span>] initWithDisplayName:<span class="red">@"my device"</span>];<br/><br/>MCSession *session = [[MCSession <span class="violet">alloc</span>] initWithPeer:peerID<br/>                                    securityIdentity:nil<br/>                                encryptionPreference:MCEncryptionRequired];</p>
<p class="listcap"><a id="ch7ex16"/><em>Listing 7-16: Creating an</em> <span class="literal">MCSession</span></p>
<p class="indent">When connecting to a remote device, the delegate method <span class="literal">session:didReceiveCertificate:fromPeer:certificateHandler:</span> is called, passing in the peer’s certificate and allowing you to specify a handler method to take specific action based on whether the certificate was verified successfully.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>If you fail to create the</em> <span class="literal"><em>didReceiveCertificate</em></span> <em>delegate method or don’t implement a</em> <span class="literal"><em>certificateHandler</em></span> <em>in this delegate method, no verification of the remote endpoint will occur, making the connection susceptible to interception by a third party.</em></p>
</div>
<p class="indent">When examining codebases using the Multipeer Connectivity API, ensure that all instantiations of <span class="literal">MCSession</span> provide an identity and require transport encryption. Sessions with any type of sensitive information should never be instantiated simply with <span class="literal">initWithPeer</span>. Also ensure that the delegate method for <span class="literal">didReceiveCertificate</span> exists and is implemented correctly and that the <span class="literal">certificateHandler</span> behaves properly when a peer fails certificate validation. You specifically <em>don’t</em> want to see something like this:</p>
<p class="programs">- (<span class="rose">void</span>) session:(MCSession *)session <span class="violet">didReceiveCertificate</span>:(<span class="violet1">NSArray</span> *)certificate<br/>     fromPeer:(MCPeerID *)peerID<br/>     certificateHandler:(<span class="rose">void</span> (^)(<span class="rose">BOOL</span> accept))certificateHandler<br/>{<br/>    certificateHandler(YES);<br/>}</p>
<p class="indent">This code blindly passes a <span class="literal">YES</span> boolean to the handler, which you should never, ever do.</p>
<p class="indent">It’s up to you to decide how you’d like to implement validation. Systems for validation tend to be somewhat customized, but you have a couple of basic options. You can have clients generate certificates themselves and then <em>trust on first use (TOFU)</em>, which just verifies that the certificate being <a id="page_127"/>presented is the same as the one shown the first time you paired with a peer. You can also implement a server that will return the public certificates of users when queried to centralize the management of identities. Choose a solution that makes sense for your business model and threat model.</p>
<h3 class="h3" id="ch07lev1sec05"><strong>Lower-Level Networking with NSStream</strong></h3>
<p class="noindent"><span class="literal">NSStream</span> is suitable for making non-HTTP network connections, but it can also be used for HTTP communications with fairly little effort. For some unfathomable reason, in the transition between OS X Cocoa and iOS Cocoa Touch, Apple removed the method that allows an <span class="literal">NSStream</span> to establish a network connection to a remote host, <span class="literal">getStreamsToHost</span>. So if you want to sit around streaming things to yourself, then awesome. Otherwise, in Technical Q&amp;A QA1652,<sup><a href="footnote.html#fn72" id="fn_72">11</a></sup> Apple describes a category that you can use to define a roughly equivalent <span class="literal">getStreamsToHostNamed</span> method of <span class="literal">NSStream</span>.</p>
<p class="indent">The alternative is to use the lower-level Core Foundation <span class="literal">CFStreamCreatePairWithSocketToHost</span> function and cast the input and output <span class="literal">CFStream</span>s to <span class="literal">NSStream</span>s, as shown in <a href="ch07.html#ch7ex17">Listing 7-17</a>.</p>
<p class="programs"><span class="violet1">NSInputStream</span> *inStream;<br/><span class="violet1">NSOutputStream</span> *outStream;<br/><br/>CFReadStreamRef readStream;<br/>CFWriteStreamRef writeStream;<br/>CFStreamCreatePairWithSocketToHost(NULL, (<span class="green">CFStringRef</span>)<span class="red">@"myhost.com"</span>, 80, &amp;<br/>     readStream, &amp;writeStream);<br/>inStream = (__bridge <span class="violet1">NSInputStream</span> *)readStream;<br/>outStream = (__bridge <span class="violet1">NSOutputStream</span> *)writeStream;</p>
<p class="listcap"><a id="ch7ex17"/><em>Listing 7-17: Casting</em> <span class="literal">CFStreams</span> <em>to</em> <span class="literal">NSStreams</span></p>
<p class="indent"><span class="literal">NSStream</span>s allow users only minor control of the characteristics of the connection, such as TCP port and TLS settings (see <a href="ch07.html#ch7ex18">Listing 7-18</a>).</p>
<p class="programs">   <span class="violet1">NSHost</span> *myhost = [<span class="violet1">NSHost</span> <span class="violet">hostWithName</span>:[<span class="red">@"www.conglomco.com"</span>]];<br/><br/>   [<span class="violet1">NSStream</span> <span class="violet">getStreamsToHostNamed</span>:myhost<br/>                              port:443<br/>                       inputStream:&amp;MyInputStream<br/>                      outputStream:&amp;MyOutputStream];<br/><br/><span class="ent">➊</span> [MyInputStream <span class="violet">setProperty</span>:<span class="violet1">NSStreamSocketSecurityLevelTLSv1</span><br/>                      forKey:<span class="violet1">NSStreamSocketSecurityLevelKey];</span></p>
<p class="listcap"><a id="ch7ex18"/><em>Listing 7-18: Opening a basic TLS connection with</em> <span class="literal">NSStream</span></p>
<p class="indent"><a id="page_128"/>This is the typical use of an <span class="literal">NSStream</span>: setting a host, port, and input and output streams. Since you don’t have a ton of control over TLS settings, the only setting that might be screwed up is <span class="ent">➊</span>, the <span class="literal">NSStreamSocketSecurityLevel</span>. You should set it to <span class="literal">NSStreamSocketSecurityLevelTLSv1</span> to ensure that you don’t end up using an older, broken SSL/TLS protocol.</p>
<h3 class="h3" id="ch07lev1sec06"><strong>Even Lower-level Networking with CFStream</strong></h3>
<p class="noindent">With <span class="literal">CFStream</span>s, the developer is given an unfortunate amount of control in TLS session negotiation.<sup><a href="footnote.html#fn73" id="fn_73">12</a></sup> See <a href="ch07.html#ch7tab3">Table 7-3</a> for a number of <span class="literal">CFStream</span> properties that you should look for. These controls allow developers to override or disable verification of the peer’s canonical name (CN), ignore expiration dates, allow untrusted root certificates, and totally neglect to verify the certificate chain at all.</p>
<p class="tablecap"><a id="ch7tab3"/><strong>Table 7-3:</strong> Horrible <span class="literal">CFStream</span> TLS Security Constants</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="80%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Constant</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Meaning</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Default</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">kCFStreamSSLLevel</span></p></td>
<td class="table" valign="top"><p class="table">The protocol to be used for encrypting the connection.</p></td>
<td class="table" valign="top"><p class="table">negotiated<em><sup>a</sup></em></p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">kCFStreamSSLAllowsExpiredCertificates</span></p></td>
<td class="table" valign="top"><p class="table">Accept expired TLS certificates.</p></td>
<td class="table" valign="top"><p class="table">false</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">kCFStreamSSLAllowsExpiredRoots</span></p></td>
<td class="table" valign="top"><p class="table">Accept certificates that have expired root certificates in their certificate chain.</p></td>
<td class="table" valign="top"><p class="table">false</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">kCFStreamSSLAllowsAnyRoot</span></p></td>
<td class="table" valign="top"><p class="table">Whether a root certificate can be used as a TLS endpoint’s certificate (in other words, a self-signed or unsigned certificate).</p></td>
<td class="table" valign="top"><p class="table">false</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">kCFStreamSSLValidatesCertificateChain</span></p></td>
<td class="table" valign="top"><p class="table">Whether the certificate chain is validated.</p></td>
<td class="table" valign="top"><p class="table">true</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">kCFStreamSSLPeerName</span></p></td>
<td class="table" valign="top"><p class="table">Overrides the hostname compared to that of the certificate’s CN. If set to <span class="literal">kCFNull</span>, no validation is performed.</p></td>
<td class="table" valign="top"><p class="table">hostname</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">kCFStreamSSLIsServer</span></p></td>
<td class="table" valign="top"><p class="table">Whether this stream will act as a server.</p></td>
<td class="table" valign="top"><p class="table">false</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><span class="literal">kCFStreamSSLCertificates</span></p></td>
<td class="table" valign="top"><p class="table">An array of certificates that will be used if <span class="literal">kCFStreamSSLIsServer</span> is true.</p></td>
<td class="table" valign="top"><p class="table">none</p></td>
</tr>
</tbody>
</table>
<p class="footnote"><em>a</em>. The default constant is <span class="literal">kCFStreamSocketSecurityLevelNegotiatedSSL</span>, which negotiates the strongest method available from the server.</p>
<p class="indent"><a id="page_129"/>You probably shouldn’t be using these security constants at all, but if you must use TLS <span class="literal">CFStream</span>s, just do it the right way. It’s simple! Provided that you’re not creating a network server within the app itself (which is a pretty rare usage of <span class="literal">CFStream</span> in an iOS app), there are two steps you should follow:</p>
<ol>
<li><p class="noindent">Set <span class="literal">kCFStreamSSLLevel</span> to <span class="literal">kCFStreamSocketSecurityLevelTLSv1</span>.</p></li>
<li><p class="noindent">Don’t mess with anything else.</p></li>
</ol>
<h3 class="h3" id="ch07lev1sec07"><strong>Closing Thoughts</strong></h3>
<p class="noindent">You’ve looked at quite a number of ways for apps to communicate with the outside world and the incorrect ways those things can be implemented. Let’s now turn our attention to communication with other applications and some of the pitfalls that can happen when shuffling data around via IPC.<a id="page_130"/></p>
</body></html>