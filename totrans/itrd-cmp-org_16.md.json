["```\n// Make an alphabetic text string uppercase.\n\n   #include <stdio.h>\n   #include \"to_upper.h\"\n   #include \"write_str.h\"\n   #include \"write_char.h\"\n   #include \"read_str.h\"\n➊ #define MAX 50\n➋ #define ARRAY_SZ MAX+1\n\n   int main(void)\n   {\n       char my_string[ARRAY_SZ];\n\n       write_str(\"Enter up to 50 alphabetic characters: \");\n    ➌ read_str(my_string, MAX);\n\n       to_upper(my_string, my_string);\n       write_str(\"All upper: \");\n       write_str(my_string);\n       write_char('\\n');\n\n       return 0;\n   }\n```", "```\n// Convert alphabetic letters in a C string to uppercase.\n\n#ifndef TO_UPPER_H\n#define TO_UPPER_H\nint to_upper(char *dest_ptr, char *src_ptr);\n#endif\n```", "```\n   // Convert alphabetic letters in a C string to uppercase.\n\n   #include \"to_upper.h\"\n➊ #define UPMASK 0xdf\n   #define NUL '\\0'\n\n   int to_upper(char *dest_ptr, char *src_ptr)\n   {\n       int count = 0;\n       while (*src_ptr != NUL) {\n        ➋ *dest_ptr = *src_ptr & UPMASK;\n           src_ptr++;\n           dest_ptr++;\n           count++;\n       }\n    ➌ *dest_ptr = *src_ptr;   // Include NUL\n\n       return count;\n}\n```", "```\n        .arch armv8-a\n        .file   \"to_upper.c\"\n        .text\n        .align  2\n        .global to_upper\n        .type   to_upper, %function\nto_upper:\n        sub     sp, sp, #32\n        str     x0, [sp, 8]       /// Save destination address\n        str     x1, [sp]          /// Save source address\n        str     wzr, [sp, 28]     /// count = 0;\n        b       .L2\n.L3:\n        ldr     x0, [sp, 8]\n        ldrb    w0, [x0]\n     ➊ and     w0, w0, -33       /// -33 = 0xffffffdf\n        and     w1, w0, 255       /// 255 = 0x000000ff\n        ldr     x0, [sp]\n        strb    w1, [x0]\n        ldr     x0, [sp, 8]\n        add     x0, x0, 1\n        str     x0, [sp, 8]\n        ldr     x0, [sp]\n        add     x0, x0, 1\n        str     x0, [sp]\n        ldr     w0, [sp, 28]\n        add     w0, w0, 1\n        str     w0, [sp, 28]\n.L2:\n        ldr     x0, [sp, 8]\n        ldrb    w0, [x0]\n        cmp     w0, 0\n        bne     .L3\n     ➋ ldr     x0, [sp, 8]       /// Copy NUL char\n        ldrb    w1, [x0]\n        ldr     x0, [sp]\n        strb    w1, [x0]\n        ldr     w0, [sp, 28]\n        add     sp, sp, 32\n        ret\n        .size   to_upper, .-to_upper\n        .ident  \"GCC: (Debian 12.2.0-14) 12.2.0\"\n        .section        .note.GNU-stack,\"\",@progbits\n```", "```\n// Make an alphabetic text string uppercase.\n        .arch armv8-a\n// Useful constant\n        .equ    MAX,50                    // Character limit\n// Stack frame\n        .equ    the_string, 16\n      ➊ .equ    FRAME, 80                 // Allows >51 bytes\n// Code\n        .text\n        .section  .rodata\n        .align  3\nprompt:\n        .string \"Enter up to 50 alphabetic characters: \"\nresult:\n        .string \"All upper: \"\n        .text\n        .align  2\n        .global main\n        .type   main, %function\nmain:\n        stp     fp, lr, [sp, -FRAME]! // Create stack frame\n        mov     fp, sp                // Set our frame pointer\n        adr     x0, prompt            // Prompt message\n        bl      write_str             // Ask for input\n\n        add     x0, sp, the_string    // Place to store string\n        mov     w1, MAX               // Limit number of input chars\n        bl      read_str              // Get from keyboard\n\n        add     x1, sp, the_string    // Address of string\n     ➋ mov     x0, x1                // Replace the string\n        bl      to_upper              // Do conversion\n\n        adr     x0, result            // Show result\n        bl      write_str\n        add     x0, sp, the_string    // Converted string\n        bl      write_str\n        mov     w0, '\\n'              // Nice formatting\n        bl      write_char\n\n        mov     w0, 0                 // Return 0\n        ldp     x29, x30, [sp], FRAME // Delete stack frame\n        ret\n```", "```\n// Convert alphabetic letters in a C string to uppercase.\n// Calling sequence:\n//    x0 <- pointer to result\n//    x1 <- pointer to string to convert\n//    Return number of characters converted.\n        .arch armv8-a\n// Useful constant\n     ➊ .equ    UPMASK, 0xdf\n// Program code\n        .text\n        .align  2\n        .global to_upper\n        .type   to_upper, %function\nto_upper:\n        mov     w2, wzr               // counter = 0\nloop:\n     ➋ ldrb    w3, [x1]              // Load character\n        cbz     w3, allDone           // All done if NUL char\n     ➌ movz    w4, UPMASK            // If not, do masking\n        and     w3, w3, w4            // Mask to upper\n        strb    w3, [x0]              // Store result\n        add     x0, x0, 1             // Increment destination pointer,\n        add     x1, x1, 1             //   source pointer,\n        add     w2, w2, 1             //   and counter,\n        b       loop                  //   and continue\ndone:\n        strb    w3, [x0]              // Terminating NUL got us here\n        mov     w0, w2                // Return count\n        ret                           // Back to caller\n```", "```\nand     w3, w3, -33\nand     w3, w3, 255\n```", "```\nand     w3, w3, 0xffffffdf\n```", "```\n// Get a hex number from the user and store it as an int.\n\n#include <stdio.h>\n#include \"write_str.h\"\n#include \"read_str.h\"\n#include \"hex_to_int.h\"\n\n#define MAX 8\n#define ARRAY_SZ MAX+1\n\nint main()\n{\n    char the_string[ARRAY_SZ];\n    int the_int;\n\n    write_str(\"Enter up to 8 hex characters: \");\n    read_str(the_string, MAX);\n\n    hex_to_int(&the_int, the_string);\n    printf(\"0x%x = %i\\n\", the_int, the_int);\n    return 0;\n}\n```", "```\n// Convert a hex character string to an int.\n// Return number of characters.\n\n#ifndef HEX_TO_INT_H\n#define HEX_TO_INT_H\nint hex_to_int(int *int_ptr, char *string_ptr);\n#endif\n```", "```\n// Convert a hex character string to an int.\n// Return number of characters.\n\n#include \"hex_to_int.h\"\n#define GAP 0x07\n#define INTPART 0x0f  // Also works for lowercase\n#define NUL '\\0'\n\nint hex_to_int(int *int_ptr, char *string_ptr)\n{\n    char current;\n    int result;\n    int count;\n\n    count = 0;\n ➊ result = 0;\n    current = *string_ptr;\n    while (current != NUL) {\n     ➋ if (current > '9') {\n            current -= GAP;\n        }\n     ➌ current = current & INTPART;\n     ➍ result = result << 4;\n     ➎ result |= current;\n        string_ptr++;\n        count++;\n        current = *string_ptr;\n    }\n\n    *int_ptr = result;\n    return count;\n}\n```", "```\n        .arch armv8-a\n        .file   \"hex_to_int.c\"\n        .text\n        .align  2\n        .global hex_to_int\n        .type   hex_to_int, %function\nhex_to_int:\n        sub     sp, sp, #32\n        str     x0, [sp, 8]\n        str     x1, [sp]\n        str     wzr, [sp, 20]\n        str     wzr, [sp, 24]\n        ldr     x0, [sp]\n        ldrb    w0, [x0]\n        strb    w0, [sp, 31]\n        b       .L2\n.L4:\n        ldrb    w0, [sp, 31]\n        cmp     w0, 57        /// > '9'?\n        bls     .L3\n        ldrb    w0, [sp, 31]  /// Yes\n        sub     w0, w0, #7    /// Remove gap\n        strb    w0, [sp, 31]\n.L3:\n     ➊ ldrb    w0, [sp, 31]\n     ➋ and     w0, w0, 15    /// Leave only 4 bits\n        strb    w0, [sp, 31]\n        ldr     w0, [sp, 24]\n     ➌ lsl     w0, w0, 4     /// Room for 4 bits\n        str     w0, [sp, 24]\n        ldrb    w0, [sp, 31]\n        ldr     w1, [sp, 24]\n        orr     w0, w1, w0    /// Copy new 4 bits\n        str     w0, [sp, 24]\n        ldr     x0, [sp]\n        add     x0, x0, 1\n        str     x0, [sp]\n        ldr     w0, [sp, 20]\n        add     w0, w0, 1\n        str     w0, [sp, 20]\n        ldr     x0, [sp]\n        ldrb    w0, [x0]\n        strb    w0, [sp, 31]\n.L2:\n        ldrb    w0, [sp, 31]\n        cmp     w0, 0         /// NUL\n        bne     .L4\n        ldr     x0, [sp, 8]\n        ldr     w1, [sp, 24]\n        str     w1, [x0]\n        ldr     w0, [sp, 20]\n        add     sp, sp, 32\n        ret\n        .size   hex_to_int, .-hex_to_int\n        .ident  \"GCC: (Debian 12.2.0-14) 12.2.0\"\n        .section        .note.GNU-stack,\"\",@progbits\n```", "```\n// Get a hex number from the user and store it as an int.\n        .arch armv8-a\n// Useful constant\n        .equ    MAX, 8\n// Stack frame\n        .equ    the_int, 16\n        .equ    the_string, 20\n     ➊ .equ    FRAME, 32\n// Code\n        .text\n        .section  .rodata\n        .align  3\nprompt:\n        .string \"Enter up to 8 hex characters: \"\nformat:\n        .string \"0x%x = %i\\n\"\n        .text\n        .align  2\n        .global main\n        .type   main, %function\nmain:\n        stp     fp, lr, [sp, -FRAME]! // Create stack frame\n        mov     fp, sp                // Our frame pointer\n\n        adr     x0, prompt            // Prompt message\n        bl      write_str             // Ask for input\n\n        add     x0, sp, the_string    // Place to store string\n        mov     w1, MAX               // Limit number of input chars\n        bl      read_str              // Get from keyboard\n\n        add     x1, sp, the_string    // Address of string\n        add     x0, sp, the_int       // Place to store int\n        bl      hex_to_int            // Do conversion\n\n        ldr     w2, [sp, the_int]     // Load int\n        ldr     w1, [sp, the_int]     // printf shows this copy in hex\n        adr     x0, format            // Format string\n        bl      printf\n\n        mov     w0, 0                 // Return 0\n        ldp     x29, x30, [sp], FRAME // Delete stack frame\n        ret\n```", "```\n// Convert a hex character string to an int.\n// Calling sequence:\n//    x0 <- pointer to int result\n//    x1 <- pointer to hex character string to convert\n//    Return number of characters converted.\n        .arch armv8-a\n// Useful constants\n        .equ    INTPART, 0x0f         // Also works for lowercase\n        .equ    GAP, 0x07             // Between numerals and alpha\n// Program code\n        .text\n        .align  2\n        .global hex_to_int\n        .type   hex_to_int, %function\nhex_to_int:\n        mov     w2, wzr               // result = 0\n        mov     w3, wzr               // counter = 0\nconvert:\n        ldrb    w4, [x1]              // Load character\n        cbz     w4, done              // NUL character?\n        cmp     w4, '9                // Numeral?\n        b.ls    no_gap                // Yes\n        sub     w4, w4, GAP           // No, remove gap\nno_gap:\n        and     w4, w4, INTPART       // 4-bit integer\n        lsl     w2, w2, 4             // Make room for it\n        orr     w2, w2, w4            // Insert new 4-bit integer\n        add     x1, x1, 1             // Increment source pointer\n        add     w3, w3, 1             //   and counter\n        b       convert               //   and continue\ndone:\n        str     w2, [x0]              // Output result\n        mov     w0, w3                // Return count\n        ret                           // Back to caller\n```", "```\n   // Get a decimal number from the user and store it as an int.\n\n   #include <stdio.h>\n   #include \"write_str.h\"\n   #include \"read_str.h\"\n   #include \"dec_to_int.h\"\n➊ #define MAX 11\n   #define ARRAY_SZ MAX+1\n\n   int main(void)\n   {\n       char the_string[ARRAY_SZ];\n       int the_int;\n\n       write_str(\"Enter an integer: \");\n       read_str(the_string, MAX);\n\n       dec_to_int(&the_int, the_string);\n       printf(\"\\\"%s\\\" is stored as 0x%x\\n\", the_string, the_int);\n\n       return 0;\n   }\n```", "```\n// Convert a decimal character string to an int.\n// Return number of decimal characters.\n\n#ifndef DEC_TO_INT_H\n#define DEC_TO_INT_H\nint dec_to_int(int *int_ptr, char *string_ptr);\n#endif\n```", "```\n   // Convert a decimal character string to an unsigned int.\n   // Return number of characters.\n\n   #include <stdio.h>\n   #include <stdbool.h>\n   #include \"dec_to_int.h\"\n   #define INTMASK 0x0f\n   #define RADIX 10\n   #define NUL '\\0'\n➊ int dec_to_int(int *int_ptr, char *string_ptr)\n   {\n       bool negative = false;       // Assume positive\n       int result = 0;\n       int count = 0;\n\n    ➋ if (*string_ptr == '-') {\n           negative = true;\n           string_ptr++;\n    ➌ } else if (*string_ptr == '+') {\n           string_ptr++;\n       }\n\n       while (*string_ptr != NUL) {\n        ➍ result = RADIX * result;\n        ➎ result += (int)(*string_ptr & INTMASK);\n           string_ptr++;\n           count++;\n       }\n\n       if (negative) {\n           result = -result;\n       }\n       *int_ptr = result;\n       return count;\n   }\n```", "```\n        .arch armv8-a\n        .file   \"dec_to_int.c\"\n        .text\n        .align  2\n        .global dec_to_int\n        .type   dec_to_int, %function\ndec_to_int:\n        sub     sp, sp, #32\n        str     x0, [sp, 8]     /// Save int_ptr\n        str     x1, [sp]        /// Save string_ptr\n        strb    wzr, [sp, 31]   /// negative = false;\n        str     wzr, [sp, 24]   /// result = 0;\n        str     wzr, [sp, 20]   /// count = 0;\n        ldr     x0, [sp]\n        ldrb    w0, [x0]\n        cmp     w0, 45\n        bne     .L2\n        mov     w0, 1\n        strb    w0, [sp, 31]\n        ldr     x0, [sp]\n        add     x0, x0, 1\n        str     x0, [sp]\n        b       .L4\n.L2:\n        ldr     x0, [sp]\n        ldrb    w0, [x0]\n        cmp     w0, 43\n        bne     .L4\n        ldr     x0, [sp]\n        add     x0, x0, 1\n        str     x0, [sp]\n        b       .L4\n.L5:\n        ldr     w1, [sp, 24]\n        mov     w0, w1\n     ➊ lsl     w0, w0, 2       /// 4 * result\n        add     w0, w0, w1      /// (4 * result) + result\n        lsl     w0, w0, 1       /// 2 * ((4 * result) + result)\n        str     w0, [sp, 24]    /// result = 10 * result;\n        ldr     x0, [sp]\n        ldrb    w0, [x0]\n        and     w0, w0, 15\n        ldr     w1, [sp, 24]\n        add     w0, w1, w0\n        str     w0, [sp, 24]\n        ldr     x0, [sp]\n        add     x0, x0, 1\n        str     x0, [sp]\n        ldr     w0, [sp, 20]\n        add     w0, w0, 1\n        str     w0, [sp, 20]\n.L4:\n        ldr     x0, [sp]\n        ldrb    w0, [x0]\n        cmp     w0, 0\n        bne     .L5\n        ldrb    w0, [sp, 31]    /// Check negative flag\n        cmp     w0, 0\n        beq     .L6\n        ldr     w0, [sp, 24]\n     ➋ neg     w0, w0\n        str     w0, [sp, 24]\n.L6:\n        ldr     x0, [sp, 8]\n        ldr     w1, [sp, 24]\n        str     w1, [x0]\n        ldr     w0, [sp, 20]\n        add     sp, sp, 32\n        ret\n        .size   dec_to_int, .-dec_to_int\n        .ident  \"GCC: (Debian 12.2.0-14) 12.2.0\"\n        .section        .note.GNU-stack,\"\",@progbits\n```", "```\nresult = 2 * ((4 * result) + result);\n```", "```\n// Get a decimal number from the user and store it as an int.\n        .arch armv8-a\n// Useful constant\n        .equ    MAX, 12               // Character storage limit\n// Stack frame\n        .equ    the_int, 16\n        .equ    the_string, 20\n        .equ    FRAME, 32\n// Code\n        .text\n        .section  .rodata\n        .align  3\nprompt:\n        .string \"Enter an integer: \"\n        .align  3\nformat:\n        .string \"\\\"%s\\\" is stored as 0x%x\\n\"\n        .text\n        .align  2\n        .global main\n        .type   main, %function\nmain:\n        stp     fp, lr, [sp, -FRAME]! // Create stack frame\n        mov     fp, sp                // Our frame pointer\n        adr     x0, prompt            // Prompt message\n        bl      write_str             // Ask for input\n\n        mov     w1, MAX               // Limit number of input chars\n        add     x0, sp, the_string    // Place to store string\n        bl      read_str              // Get from keyboard\n\n        add     x1, sp, the_string    // Address of string\n        add     x0, sp, the_int       // Place to store the int\n        bl      dec_to_int            // Do conversion\n        ldr     w2, [sp, the_int]     // Load the int\n        add     x1, sp, the_string    // Input text string\n        adr     x0, format            // Format message\n        bl      printf                // Show results\n        mov     w0, wzr               // Return 0\n        ldp     x29, x30, [sp], FRAME // Delete stack frame\n        ret\n```", "```\n// Convert a decimal text string to an int.\n// Calling sequence:\n//    x0 <- place to store int\n//    x1 <- pointer to string\n//    Return number of characters.\n        .arch armv8-a\n// Useful constants\n        .equ    RADIX,10\n        .equ    INTMASK,0x0f\n// Program code\n        .text\n        .align  2\n        .global dec_to_int\n        .type   dec_to_int, %function\ndec_to_int:\n        mov     w2, wzr               // count = 0\n        mov     w3, wzr               // result = 0\n        mov     w4, wzr               // negative = false\n        mov     w5, RADIX             // Handy to have in reg\n\n        ldrb    w6, [x1]              // Load first character\n        cmp     w6, '-                // Minus sign?\n        b.ne    check_pos             // No, check for plus sign\n        mov     x4, 1                 // Yes, negative = true\n        add     x1, x1, 1             // Increment string pointer\n        b       convert               //   and convert numerals\ncheck_pos:\n        cmp     w6, '+                // Plus sign?\n        b.ne    convert               // No, convert numerals\n        add     x1, x1, 1             // Yes, skip over it\n\nconvert:\n        ldrb    w6, [x1]              // Load character\n        cbz     w6, check_sign        // NUL char?\n        and     w6, w6, INTMASK       // No, mask to integer\n     ➊ mul     w3, w3, w5            // result * RADIX\n        add     w3, w3, w6            // Add new integer\n        add     w2, w2, 1             // count++\n        add     x1, x1, 1             // string_ptr++\n        b       convert               //   and continue\ncheck_sign:\n        cbz     w4, positive          // Check negative flag\n        neg     w3, w3                // Negate if flag is true\npositive:\n        str     w3, [x0]              // Output result\n        mov     w0, w2                // Return count\n        ret                           // Back to caller\n```", "```\nmul     x3, x0, x1\numulh   x2, x0, x1\n```", "```\nmul     x3, x0, x1\nsmulh   x2, x0, x1\n```", "```\n// Read an int from the user, subtract 123, and display the result.\n\n#include \"write_str.h\"\n#include \"write_char.h\"\n#include \"read_str.h\"\n#include \"dec_to_int.h\"\n#include \"int_to_dec.h\"\n#define MAX 11\n#define ARRAY_SZ MAX+1\n\nint main(void)\n{\n    char the_string[ARRAY_SZ];\n    int the_int;\n\n    write_str(\"Enter an integer: \");\n    read_str(the_string, MAX);\n\n    dec_to_int(&the_int, the_string);\n    the_int -= 123;\n    int_to_dec(the_string, the_int);\n\n    write_str(\"The result is: \");\n    write_str(the_string);\n    write_char('\\n');\n\n    return 0;\n}\n```", "```\n// Convert an int to its decimal text string representation.\n// Return number of characters.\n\n#ifndef INT_TO_DEC_H\n#define INT_TO_DEC_H\nint int_to_dec(char *dec_string, int the_int);\n#endif\n```", "```\n// Convert an int to its decimal text string representation.\n// Return number of characters.\n\n#include \"int_to_dec.h\"\n#define ARRAY_SZ 12\n#define ASCII 0x30\n#define RADIX 10\n#define NUL '\\0'\n\nint int_to_dec(char *dec_string, int the_int)\n{\n    char reverse[ARRAY_SZ];\n    char digit;\n    char *_ptr;\n    unsigned int working;\n    int count = 0;\n\n ➊ if (the_int < 0) {\n        the_int = -the_int;\n        *dec_string = '-';\n        count++;\n        decString++;\n    }\n    ptr = reverse;                   // Point to local char array\n ➋ *ptr = NUL;                      // Start with termination char\n ➌ working = (unsigned int)the_int; // Use unsigned arithmetic\n    do {\n        ptr++;\n     ➍ digit = (char)(working % RADIX);\n        *ptr = ASCII | digit;\n        working = working / RADIX;\n    } while (working > 0);\n\n    count = 0;\n    if (negative) {\n        *dec_string = '-';\n        count++;\n        dec_string++;\n    }\n ➎ do {                            // Reverse string\n        *dec_string = *ptr;\n        count++;\n        dec_string++;\n        ptr--;\n     ➏ } while (*ptr != NUL);\n    *dec_string = *ptr;             // Copy termination char\n\n    return count;\n}\n```", "```\n.arch armv8-a\n        .file   \"int_to_dec.c\"\n        .text\n        .align  2\n        .global int_to_dec\n        .type   int_to_dec, %function\nint_to_dec:\n        sub     sp, sp, #48\n        str     x0, [sp, 8]\n        str     w1, [sp, 4]\n        str     wzr, [sp, 32]\n        ldr     w0, [sp, 4]\n        cmp     w0, 0               /// Check for negative\n        bge     .L2\n        ldr     w0, [sp, 4]\n        neg     w0, w0\n        str     w0, [sp, 4]\n        ldr     x0, [sp, 8]\n        mov     w1, 45\n        strb    w1, [x0]\n        ldr     w0, [sp, 32]\n        add     w0, w0, 1\n        str     w0, [sp, 32]\n        ldr     x0, [sp, 8]\n        add     x0, x0, 1\n        str     x0, [sp, 8]\n.L2:\n        add     x0, sp, 16\n        str     x0, [sp, 40]        /// ptr\n        ldr     x0, [sp, 40]\n        strb    wzr, [x0]           /// *ptr = NUL;\n        ldr     w0, [sp, 4]\n        str     w0, [sp, 36]        /// working = the_int;\n.L3:\n        ldr     x0, [sp, 40]\n        add     x0, x0, 1\n        str     x0, [sp, 40]\n        ldr     w2, [sp, 36]\n     ➊ mov     w0, 52429           /// 0xcccd\n        movk    w0, 0xcccc, lsl 16  /// 0xcccccccd\n     ➋ umull   x0, w2, w0          /// Multiply by 0.1\n        lsr     x0, x0, 32          /// Divide by 2^35\n        lsr     w1, w0, 3\n        mov     w0, w1\n     ➌ lsl     w0, w0, 2\n        add     w0, w0, w1\n        lsl     w0, w0, 1\n     ➍ sub     w1, w2, w0          /// working % RADIX\n        mov     w0, w1\n        strb    w0, [sp, 31]\n        ldrb    w0, [sp, 31]\n     ➎ orr     w0, w0, 48          /// Convert to ASCII\n        and     w1, w0, 255\n        ldr     x0, [sp, 40]\n        strb    w1, [x0]            /// *ptr = ASCII | digit\n        ldr     w1, [sp, 36]\n     ➏ mov     w0, 52429\n        movk    w0, 0xcccc, lsl 16\n        umull   x0, w1, w0\n        lsr     x0, x0, 32\n        lsr     w0, w0, 3\n        str     w0, [sp, 36]        /// working = working / RADIX;\n        ldr     w0, [sp, 36]\n        cmp     w0, 0\n        bne     .L3\n.L4:\n        ldr     x0, [sp, 40]\n        ldrb    w1, [x0]\n        ldr     x0, [sp, 8]\n        strb    w1, [x0]\n        ldr     w0, [sp, 32]\n        add     w0, w0, 1\n        str     w0, [sp, 32]\n        ldr     x0, [sp, 8]\n        add     x0, x0, 1\n        str     x0, [sp, 8]\n        ldr     x0, [sp, 40]\n        sub     x0, x0, #1\n        str     x0, [sp, 40]\n        ldr     x0, [sp, 40]\n        ldrb    w0, [x0]\n        cmp     w0, 0\n        bne     .L4\n        ldr     x0, [sp, 40]\n        ldrb    w1, [x0]\n        ldr     x0, [sp, 8]\n        strb    w1, [x0]\n        ldr     w0, [sp, 32]\n        add     sp, sp, 48\n        ret\n        .size   int_to_dec, .-int_to_dec\n        .ident  \"GCC: (Debian 12.2.0-14) 12.2.0\"\n        .section        .note.GNU-stack,\"\",@progbits\n```", "```\n   // Subtract 123 from an integer.\n           .arch armv8-a\n   // Useful constants\n           .equ    CONSTANT, 123         // Number to subtract\n           .equ    MAX, 11               // Maximum digits\n➊ // Stack frame\n           .equ    the_int, 16\n           .equ    the_string, 20\n           .equ    FRAME, 32\n   // Code\n           .text\n           .section  .rodata\n           .align  3\n           prompt:\n           .string \"Enter an integer: \"\n   message:\n           .string \"The result is: \"\n           .text\n           .align  2\n           .global main\n           .type   main, %function\n   main:\n           stp     fp, lr, [sp, -FRAME]! // Create stack frame\n           mov     fp, sp                // Our frame pointer\n\n           adr     x0, prompt            // Prompt message\n           bl      write_str             // Ask for input\n           add     x0, sp, the_string\n           mov     w1, MAX\n           bl      read_str\n\n           add     x1, sp, the_string    // Input\n           add     x0, sp, the_int       // Place for output\n           bl      dec_to_int            // Convert to int\n\n           ldr     w1, [sp, the_int]\n           sub     w1, w1, CONSTANT      // Subtract our constant\n           add     x0, sp, the_string    // Place for output\n           bl      int_to_dec            // Convert to text string\n\n           adr     x0, message           // Tell user that\n           bl      write_str\n           add     x0, sp, the_string    //   this is the result\n           bl      write_str\n           mov     w0, '\\n'\n           bl      write_char\n\n           mov     w0, wzr               // Return 0\n           ldp     fp, lr, [sp], FRAME   // Delete stack frame\n           ret                           // Back to caller\n```", "```\n   // Convert an int to its decimal text string representation.\n   // Calling sequence:\n   //    x0 <- place to store string\n   //    w1 <- the int\n   //    Return number of characters in the string.\n           .arch armv8-a\n   // Useful constants\n           .equ    RADIX, 10             // Number base\n           .equ    INT2CHAR, 0x30        // ASCII zero\n           .equ    MINUS, '-             // Minus sign\n➊ // Stack frame\n           .equ    reverse, 0\n           .equ    FRAME, 16\n   // Code\n           .text\n           .align  2\n           .global int_to_dec\n           .type   int_to_dec, %function\n   int_to_dec:\n           sub     sp, sp, FRAME         // Local string on stack\n\n           cmp     w1, wzr               // => 0?\n           tbz     w1, 31, non_negative  // Yes, go to conversion\n           neg     w1, w1                // No, negate int\n           mov     w2, MINUS\n           strb    w2, [x0]              // Start with minus sign\n           add     x0, x0, 1             // Increment pointer\n   non_negative:\n           add     x3, sp, reverse       // Pointer to local string storage\n           strb    wzr, [x3]             // Create end with NUL\n           mov     w2, RADIX             // Put in register\n   do_while:\n           add     x3, x3, 1             // Increment local pointer\n        ➋ udiv    w4, w1, w2            // Quotient = dividend / RADIX\n        ➌ msub    w5, w4, w2, w1        // Rem. = dividend - RADIX * quot.\n           orr     w5, w5, INT2CHAR      // Convert to ASCII\n           strb    w5, [x3]              // Store character\n        ➍ mov     w1, w4                // Remove remainder\n           cbnz    w1, do_while          // Continue if more left\n\n           mov     w6, wzr               // count = 0\n   copy:\n           ldrb    w5, [x3]              // Load character\n           strb    w5, [x0]              // Store it\n           add     x0, x0, 1             // Increment to pointer\n           sub     x3, x3, 1             // Decrement from pointer\n           add     w6, w6, 1             // Increment counter\n           cbnz    w5, copy              // Continue until NUL char\n           strb    w5, [x0]              // Store NUL character\n\n           mov     w0, w6                // Return count\n           add     sp, sp, FRAME         // Delete stack frame\n           ret                           // Back to caller\n```"]