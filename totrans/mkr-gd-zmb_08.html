<html><head></head><body>
<h2 class="h2" id="ch08"><a id="page_139"/><strong>8</strong></h2>
<p class="h2a"><strong>BUILDING A CONTROL CENTER FOR YOUR BASE</strong></p>
<div class="image1"><img src="graphics/f0001-01.jpg" alt="image"/></div>
<p class="noindent">In this chapter, you’ll learn how to make an integrated control center using a Raspberry Pi computer interfaced with earlier projects from this book. The control center will allow you to monitor all of your alarm and surveillance devices on one screen so you’ll know instantly if a zombie has breached your compound (<a href="ch08.html#ch08fig1">Figure 8-1</a>). As an extra feature, you’ll learn how to add wireless connectivity to your control center.</p>
<div class="image"><a id="page_140"/><img src="graphics/f08-01.jpg" alt="image"/></div>
<p class="figuret"><a id="ch08fig1">Figure 8-1:</a> A quiet night at the security desk</p>
<h3 class="h3" id="ch00lev1sec137"><strong>PROJECT 13: A RASPBERRY PI CONTROL CENTER</strong></h3>
<p class="noindentb">In this project, you’ll connect the Raspberry Pi system of <a href="ch05.html#ch05">Chapter 5</a> with the following Arduino monitoring devices developed earlier in the book:</p>
<p class="bull">• “<a href="ch03.html#ch00lev1sec63">Project 4: Battery Monitor</a>” on <a href="ch03.html#page_53">page 53</a></p>
<p class="bull">• “<a href="ch04.html#ch00lev1sec81">Project 6: PIR Zombie Detector</a>” on <a href="ch04.html#page_72">page 72</a></p>
<p class="bull">• “<a href="ch06.html#ch00lev1sec116">Project 10: Door Sensor</a>” on <a href="ch06.html#page_112">page 112</a></p>
<p class="bull">• “<a href="ch07.html#ch00lev1sec121">Project 11: Quiet Fire Alarm</a>” on <a href="ch07.html#page_120">page 120</a></p>
<p class="bull">• “<a href="ch07.html#ch00lev1sec130">Project 12: Temperature Alarm</a>” on <a href="ch07.html#page_131">page 131</a></p>
<p class="indentt">We’ll link the two boards with USB cables, which we can later replace in Project 14 with a wireless Bluetooth link. The Arduino will still be able to work without the Raspberry Pi after this wireless modification, but linking it to the Raspberry Pi will allow you to show the status of your sensors and alarms in a window on the Raspberry Pi. <a href="ch08.html#ch08fig2">Figure 8-2</a> shows the setup; you can see the sensor status window in the center of the screen.</p>
<div class="image"><a id="page_141"/><img src="graphics/f08-02.jpg" alt="image"/></div>
<p class="figuret"><a id="ch08fig2">Figure 8-2:</a> Raspberry Pi and Arduino working together</p>
<h4 class="h4" id="ch00lev1sec138"><strong>WHAT YOU WILL NEED</strong></h4>
<p class="noindentb">This project brings together the Raspberry Pi system of <a href="ch05.html#ch05">Chapter 5</a> and most of the Arduino projects described in the book thus far. As such, all you will need is the following:</p>
<p class="bulla"><img src="graphics/square.jpg" alt="image"/> One or more of the previous Arduino projects</p>
<p class="bulla"><img src="graphics/square.jpg" alt="image"/> The Raspberry Pi system from <a href="ch05.html#ch05">Chapter 5</a></p>
<p class="bulla"><img src="graphics/square.jpg" alt="image"/> A USB lead/cable (of the same type used to program your Arduino project)</p>
<h4 class="h4" id="ch00lev1sec139"><strong>CONSTRUCTION</strong></h4>
<p class="noindent">Assuming that you have been slowly adding projects to your Arduino, the Arduino now has five projects attached to it. If you’re really prepared, you probably built these ages ago and have them stashed in your go bag, ready for the apocalypse. Either way, you should at least have the sensors you are interested in using.</p>
<p class="indent">If your Arduino projects and Raspberry Pi are already set up, you won’t need to do much construction to link them. You connect an Arduino project <a id="page_142"/>to the Raspberry Pi by plugging one end of the USB lead into the Pi and the other end into the Arduino. If your Raspberry Pi does not have any free USB ports, then you will need to add a USB hub to provide more ports.</p>
<p class="indent">Now that you have linked your Arduino and your Raspberry Pi, you’ll need to program them. It’s best to program the Arduino from your regular computer before swapping the USB cable over to the Raspberry Pi, as programming the Arduino from the Raspberry Pi’s small screen can be frustrating.</p>
<p class="indent"><a href="ch08.html#ch08fig3">Figure 8-3</a> shows the arrangement of the various system components.</p>
<div class="image"><img src="graphics/f08-03.jpg" alt="image"/></div>
<p class="figuret"><a id="ch08fig3">Figure 8-3:</a> A schematic of the control center</p>
<p class="indent">This arrangement plays to the strengths of both the Arduino and Raspberry Pi. The Raspberry Pi cannot directly use many of the sensors that are connected to the Arduino, while the Arduino can. At the same time, the Arduino does not have a screen, while the Raspberry Pi does.</p>
<h4 class="h4" id="ch00lev1sec140"><strong>SOFTWARE</strong></h4>
<p class="noindent">There are two parts to the software for this project: a modified version of the <em>All_Sensors</em> Arduino sketch and a Python program run on the Raspberry Pi to allow it to communicate with the Arduino.</p>
<p class="indent">Before the apocalypse, make sure you’ve downloaded the source code for this book; go to <em><a href="http://www.nostarch.com/zombies/">http://www.nostarch.com/zombies/</a></em> to get started.</p>
<h5 class="h5" id="ch00lev1sec141"><a id="page_143"/><strong>ARDUINO SOFTWARE</strong></h5>
<p class="noindent">The Arduino sketch you will use for this project, <em>Project_13_Control_Center_ USB</em>, is based on the <em>All_Sensors</em> sketch that runs all of the other Arduino projects in this book. <em>Project_13_Control_Center_USB</em> just adds code to allow your Arduino to communicate with other devices over a serial connection (in this case, USB).</p>
<div class="note">
<p class="notet"><span class="font1"><strong>NOTE</strong></span></p>
<p class="noindent">For instructions on loading sketches onto your Arduino, see <a href="app03.html#app03">Appendix C</a>.</p>
</div>
<p class="indent">It’s best to test each part of this fairly complex system in isolation on your regular desktop or laptop computer before connecting it to the Raspberry Pi. You can power the Arduino from the USB connection to your laptop while testing, so you don’t need to use your postapocalyptic car battery power supply for preapocalyptic testing.</p>
<p class="indent">To begin testing, load the <em>Project_13_Control_Center_USB</em> sketch onto the Arduino and click the magnifying glass in the Arduino IDE to open the serial monitor (<a href="ch08.html#ch08fig4">Figure 8-4</a>).</p>
<div class="image"><img src="graphics/f08-04.jpg" alt="image"/></div>
<p class="figuret"><a id="ch08fig4">Figure 8-4:</a> The serial monitor</p>
<p class="indent">Make sure that “9600 baud” is selected in the drop-down list at the bottom right of the serial monitor. This is the baud rate, the speed at which data is sent (measured in bits per second), and it must match the speed set in the sketch.</p>
<p class="indent">In the text entry area at the top of the serial monitor, enter the <span class="codestrong">?</span> command and click <strong>Send</strong>. The Arduino should display a line of numbers like the <span class="literal">4.27 26.10 1 0 0</span> shown in <a href="ch08.html#ch08fig4">Figure 8-4</a> (your numbers will not match these, exactly). These numbers are the battery voltage, temperature, door status, PIR status, and smoke alarm status, respectively. For the three status values, <a id="page_144"/><span class="literal">0</span> means everything is okay and <span class="literal">1</span> indicates an alarm. These are the values that will later be displayed on the control center. By simulating how the Raspberry Pi will fetch the values, you are testing that the Arduino part of the project is working.</p>
<p class="indent">If you’re currently holding any zombies captive for research, try putting the temperature sensor up against a zombie’s skin and enter the <span class="literal">?</span> command again. If you’re lacking in test subjects (or feeling less adventurous), just hold the sensor between your fingers. Either way, you should see the temperature part of the message change.</p>
<p class="indent">If the responses in the serial monitor indicate that the Arduino side of your control center is working properly, you can unplug the Arduino from the regular computer and attach it to a USB port of the Raspberry Pi.</p>
<p class="indent">If the numbers do not appear, then check that the sketch uploaded properly onto the Arduino. If the numbers reported are not what you would expect for one of the projects, then check the wiring for that particular project.</p>
<p class="indent">Look at the Arduino code in <em>Project_13_Control_Center_USB</em>, and you will see that unlike in <em>All_Sensors</em>, the setup function includes the following line at the end:</p>
<p class="programs">Serial.begin(9600);</p>
<p class="indent">This line tells the Arduino to open a serial connection, via its USB-serial interface, at a baud rate of 9600. The value passed to <span class="literal">begin</span> must match the value you set in the serial monitor’s baud rate drop-down list.</p>
<p class="indent">This sketch also has a change at the top of the loop function:</p>
<p class="programs">if (Serial.available() &amp;&amp; Serial.read() == '?')<br/>{<br/>  reportStatus();<br/>}</p>
<p class="indent">These lines check whether any serial communication over USB is waiting to be processed. If so, when you send the <span class="literal">?</span> message, the <span class="literal">reportStatus</span> function is called:</p>
<p class="programs">void reportStatus()<br/>{<br/>  Serial.print(readVoltage());<br/>  Serial.print(" "); <br/>  Serial.print(readTemp());<br/>  Serial.print(" "); <br/>  Serial.print(digitalRead(doorPin));<br/>  Serial.print(" "); <br/><a id="page_145"/>  Serial.print(digitalRead(pirPin)); <br/>  Serial.print(" "); <br/>  Serial.println(digitalRead(smokePin));<br/>}</p>
<p class="indent">The <span class="literal">reportStatus</span> function formats the response from earlier, separating the parts of the message with a space character. The final <span class="literal">println</span> command adds a newline character to the end of the response.</p>
<h5 class="h5" id="ch00lev1sec142"><strong>RASPBERRY PI SOFTWARE</strong></h5>
<p class="noindent">The program for this project can be found in the <em>Raspberry Pi/control_center_usb</em> folder. To download all the Raspberry Pi programs used in this book in one go, you could also use the following commands from a terminal window on the Raspberry Pi:</p>
<p class="programsb">$ <span class="codestrong">cd /home/pi</span><br/>$ <span class="codestrong">git clone https://github.com/simonmonk/zombies.git</span></p>
<p class="indent">These commands should fetch all of the code for the book, including the Arduino code used in other projects.</p>
<div class="note">
<p class="notet"><span class="font1"><strong>NOTE</strong></span></p>
<p class="noindent">For these commands to work, you will need to have the Pi connected to your network with an Ethernet cable, and your Internet connection needs to be up and running. Therefore, this is definitely something to do when you sense the apocalypse looming. Don’t wait until afterward!</p>
</div>
<p class="indent">To start the control center, you need to run the Python program <em>control.py</em>. Enter the following commands in a terminal window on your Raspberry Pi:</p>
<p class="programsb">$ <span class="codestrong">cd "zombies/Raspberry Pi/control_center_usb"</span><br/>$ <span class="codestrong">python control.py</span></p>
<p class="indent">When the program has started up, the window in <a href="ch08.html#ch08fig5">Figure 8-5</a> should appear.</p>
<p class="indent">The program displays the readings from the Arduino in a human-readable way, and any readings that require your immediate attention will be highlighted in red. When there is no cause for alarm, the readings will be green. In this example, my door is open, which means zombies may be breaking into my compound as I write! While I go check on that, you can open the <em>control_center_ usb.py</em> file in a text editor and take a look.</p>
<div class="image"><img src="graphics/f08-05.jpg" alt="image"/></div>
<p class="figuret"><a id="ch08fig5">Figure 8-5:</a> The control center</p>
<div class="note">
<p class="notet"><a id="page_146"/><span class="font1"><strong>NOTE</strong></span></p>
<p class="noindent">This is the first time we have looked at Python code since <a href="ch05.html#ch05">Chapter 5</a>, so the syntax may look unfamiliar after so much Arduino code. If you get confused about which is which, just keep in mind the main differences: in Python code, there aren’t any semicolons at the end of lines, and indentation is used to group code into blocks instead of curly braces as in Arduino code.</p>
</div>
<p class="indent">I haven’t listed the full code for the control center here as it is almost 100 lines, but in the following paragraphs, I’ll highlight a few key features. It is useful to know how the code works in case you decide you’d like to modify it. You might, for instance, want to improve the display window so it has an extra column for the units used in the measurements. You could even have it display more explicit warnings about fires, detected zombies, and so on to tell you when you need to get out of your base in a hurry. Visit <em><a href="http://effbot.org/tkinterbook/tkinter-index.htm">http://effbot.org/tkinterbook/tkinter-index.htm</a></em> to find out more about making fancy user interfaces in Tkinter.</p>
<h5 class="h5" id="ch00lev1sec143"><strong>THRESHOLD VALUES</strong></h5>
<p class="noindent">At the top of the file are three constants that may need to be changed:</p>
<p class="programs">MIN_VOLTS = 11.0<br/>TEMP_MIN = -10.0<br/>TEMP_MAX = 45.0</p>
<p class="indent">These constants specify the value limits that determine when the results turn red in the control window. In this example, if the voltage drops under 11V, that row will turn from green to red. The same happens if the temperature drops below –10 or rises above 45 degrees Celsius. The units of temperature used in <span class="literal">TEMP_MAX</span> and <span class="literal">TEMP_MIN</span> come from the units you used in the Arduino sketch. For details on how to switch between degrees Celsius and Fahrenheit, refer to “<a href="ch07.html#ch00lev1sec130">Project 12: Temperature Alarm</a>” on <a href="ch07.html#page_131">page 131</a>.</p>
<p class="indent">Set your thresholds to appropriate values for your base, taking into account how much advance warning you want if your battery level gets low or the temperature rises.</p>
<h5 class="h5" id="ch00lev1sec144"><strong>STATUS LABELS</strong></h5>
<p class="noindent">The following code shows how the labels and results in the user interface are coded, using battery voltage as an example. The code is contained within a class named <span class="literal">App</span>, and the user interface is defined in the <span class="literal">__init__</span> initialize method of this <span class="literal">App</span> class.</p>
<p class="programs"><a id="page_147"/>Label(self.frame, text='Volts').grid(row=0, column=0, sticky=E)<br/>self.volts_var = StringVar()<br/>self.volts_label = Label(self.frame, textvariable=self.volts_var)<br/>self.volts_label.grid(row=0, column=1)</p>
<p class="indent">The first line creates the label <span class="literal">Volts</span> and positions it using a grid layout at row 0, column 0. The <span class="literal">sticky</span> attribute indicates that the field should “stick” to the “east” wall of the layout cell—in other words, be right justified.</p>
<p class="indent">The second line defines a special type of variable (<span class="literal">StringVar</span>) used by the Tk graphics library that provides the user interface for the program. This variable is assigned to a member variable called <span class="literal">volts_var</span>, which is then referenced in the third line when the label for the voltage value is defined. When the value of the <span class="literal">volts_var</span> variable changes, the label field will automatically display the new value of <span class="literal">volts_var</span>.</p>
<p class="indent">Grid layouts divide the window up rather like table cells and allow you to specify the positions of user interface items without having to provide exact coordinates. The grid is arranged as rows numbered from top to bottom, with the topmost row being 0, and as columns numbered from left to right, with the leftmost column being 0. The last line of code for the volts display positions the label on the grid layout at row 0 and column 1 to put it alongside the label <span class="literal">Volts</span>.</p>
<p class="indent">The code for the other fields displayed in the window is defined in the same way.</p>
<p class="indent">Of course, you may want to use more—or less—descriptive labels, so change them to anything you like. For more information on formatting with the Tk graphics library, see <em><a href="http://tkinter.unpythonic.net/wiki/">http://tkinter.unpythonic.net/wiki/</a></em>.</p>
<h5 class="h5" id="ch00lev1sec145"><strong>COMMUNICATING WITH THE ARDUINO</strong></h5>
<p class="noindent">At the end of the <span class="literal">__init__</span> method you will find these two lines:</p>
<p class="programs">self.ser = serial.Serial(PORT, BAUD, timeout=1)<br/>time.sleep(2)</p>
<p class="indent">The first of these lines opens serial communication with the Arduino. The second pauses for two seconds to allow the Arduino time to start up before any messages are sent to it.</p>
<h5 class="h5" id="ch00lev1sec146"><strong>KEEPING YOUR CONTROL CENTER UPDATED</strong></h5>
<p class="noindent">If the displayed values don’t automatically update, your control center is pretty useless. Updating is accomplished with the <span class="literal">read_arduino</span> method.</p>
<p class="indent"><a id="page_148"/>Here is the first part:</p>
<p class="programs">def read_arduino(self):<br/>    self.ser.write('?')<br/>    volts, temp, door, pir, fire = self.ser.readline().split()<br/>    self.volts_var.set(volts)<br/>    self.temp_var.set(temp)<br/>    self.door_var.set(door)<br/>    self.pir_var.set(pir)<br/>    self.fire_var.set(fire)</p>
<p class="indent">The <span class="literal">read_arduino</span> method first sends the <span class="literal">?</span> command to the Arduino, which responds with a line of values separated by spaces, as you saw when trying out the Arduino code in the serial monitor. The returned string of values is then split up, using the spaces as a delimiter (this is the default delimiter for the <span class="literal">.split()</span> function). <span class="literal">StringVars</span> associated with each field in the window are then updated in the display.</p>
<p class="indent">After the values are updated, the remainder of the <span class="literal">read_arduino</span> method sets the color of the fields to red or green as appropriate.</p>
<p class="indent">To ensure that the <span class="literal">read_arduino</span> method is called at regular intervals, it is necessary to schedule a call to it from the Tk user interface object:</p>
<p class="programs">def update():<br/>    app.read_arduino()<br/>    root.after(500, update) <br/><br/>root.after(100, update)</p>
<p class="indent">This code ensures that after 100 milliseconds (1/10 second), the function update will be called. The function update first calls <span class="literal">read_arduino</span> and then schedules itself to run again in 500 milliseconds (half a second), meaning that our control center checks all of our sensors every half second. If you’re in danger, whether from zombies or environmental hazards, you’ll know quickly!</p>
<p class="indent">You can run this program at the same time as you run the USB webcam of “<a href="ch05.html#ch00lev1sec95">Project 7: Monitor Zombies with a USB Webcam</a>” on <a href="ch05.html#page_87">page 87</a> by opening two LXTerminal windows and running one program in each terminal window. That way, you can see instantly what might have triggered your alarms.</p>
<h4 class="h4" id="ch00lev1sec147"><strong>USING THE CONTROL CENTER</strong></h4>
<p class="noindent">Now, you have a screen that will give you continuous updates on all of the safeguards of your stronghold. Place your control center somewhere you can easily see it, and if you’ve included all of the components from <a href="ch08.html#ch08fig3">Figure 8-3</a>, you’ll know instantly if your supplies are in danger, if your power supply is running low, and if zombies have breached your perimeter.</p>
<p class="indent"><a id="page_149"/>If you find that the user interface values do not update, then go back to “<a href="ch08.html#ch00lev1sec141">Arduino Software</a>” on <a href="ch08.html#page_143">page 143</a> and again test the Arduino using the serial monitor by sending the <span class="literal">?</span> command to look for a status response in the serial monitor.</p>
<h3 class="h3" id="ch00lev1sec148"><strong>PROJECT 14: GOING WIRELESS WITH BLUETOOTH</strong></h3>
<p class="noindent">The control center of Project 13 is bogged down in wires right now, and you have to keep the Arduino and the Raspberry Pi together. That also means that you’ll probably only know that, say, your base has caught on fire once the flames have reached you—and then it will be too late. You can make your control center much more effective by connecting the Raspberry Pi and the Arduino wirelessly over Bluetooth, as we’ll do in this project, so your sensors can detect danger before it reaches you and your monitor.</p>
<p class="indent">The Raspberry Pi does not have Bluetooth built in, but it will accept a wide range of Bluetooth USB dongles. We’ll add Bluetooth to the Arduino using a Bluetooth serial module, shown sticking out at the right in <a href="ch08.html#ch08fig6">Figure 8-6</a>.</p>
<div class="image"><img src="graphics/f08-06.jpg" alt="image"/></div>
<p class="figuret"><a id="ch08fig6">Figure 8-6:</a> Adding Bluetooth to an Arduino</p>
<p class="indent">To make this project, first complete “<a href="ch08.html#ch00lev1sec137">Project 13: A Raspberry Pi Control Center</a>” on <a href="ch08.html#page_140">page 140</a> and make sure that everything else is working properly. Then you’ll be ready to add the wireless link.</p>
<h4 class="h4" id="ch00lev1sec149"><a id="page_150"/><strong>WHAT YOU WILL NEED</strong></h4>
<p class="noindentb">To make this project, you are going to need everything from Project 13 plus the following parts:</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="100%">
<thead>
<tr>
<th valign="top" class="table_th"><p class="table1"><strong>ITEMS</strong></p></th>
<th valign="top" class="table_th"><p class="table1"><strong>NOTES</strong></p></th>
<th valign="top" class="table_th"><p class="table1"><strong>SOURCE</strong></p></th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> USB Bluetooth dongle</p></td>
<td valign="top" class="table"><p class="table">Compatible with Raspberry Pi</p></td>
<td valign="top" class="table"><p class="table">Computer store, eBay</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Bluetooth module</p></td>
<td valign="top" class="table"><p class="table">HC-06 Bluetooth serial module</p></td>
<td valign="top" class="table"><p class="table">eBay</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> 270 Ω resistor</p></td>
<td valign="top" class="table"><p class="table"> </p></td>
<td valign="top" class="table"><p class="table">Mouser (293-270-RC)</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> 470 Ω resistor</p></td>
<td valign="top" class="table"><p class="table"> </p></td>
<td valign="top" class="table"><p class="table">Mouser (293-470-RC)</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Connecting wire</p></td>
<td valign="top" class="table"><p class="table"> </p></td>
<td valign="top" class="table"><p class="table"> </p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Header pins</p></td>
<td valign="top" class="table"><p class="table">4-way</p></td>
<td valign="top" class="table"><p class="table">Adafruit (392), eBay</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Screwshield</p></td>
<td valign="top" class="table"><p class="table"> </p></td>
<td valign="top" class="table"><p class="table">Adafruit (196)</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Multistranded or solid-core hookup wire</p></td>
<td valign="top" class="table"><p class="table">For making connections on the prototyping area of the screwshield</p></td>
<td valign="top" class="table"><p class="table">Adafruit (1311), scavenge</p></td>
</tr>
<tr>
<td valign="top" class="table"><p class="table-b"><img src="graphics/square.jpg" alt="image"/> Female-female jumper wires (×4)</p></td>
<td valign="top" class="table"><p class="table">(Optional) Would replace header pins</p></td>
<td valign="top" class="table"><p class="table">Adafruit (266)</p></td>
</tr>
</tbody>
</table>
<p class="indent">The hardware for this project can be built onto the screwshield that you have used while building up the various sensor projects (4, 6, 10, 11, and 12) that use a screwshield. The Bluetooth module I used is a Cambridge Silicon Radio (CSR) device. For a list of Bluetooth dongles compatible with the Raspberry Pi, visit <em><a href="http://elinux.org/RPi_USB_Bluetooth_adapters/">http://elinux.org/RPi_USB_Bluetooth_adapters/</a></em>. If you are worried about soldering the Bluetooth module directly to the header pins, then you may prefer to use four female-to-female jumper wires to link the header pins to the Bluetooth module.</p>
<div class="note">
<p class="notet"><span class="font1"><strong>NOTE</strong></span></p>
<p class="noindent">You can save yourself some tricky soldering by looking for a module and adapter pair that already has the module soldered into place.</p>
</div>
<p class="indent">A lot of the Bluetooth HC-06 modules have six rather than four pins. The pins you will be using are +5V, GND, TXD, and RXD, so you can ignore the other two. These are usually the outside pins, but do check the pinout names as occasionally some designs swap the pin positions around.</p>
<h4 class="h4" id="ch00lev1sec150"><strong>CONSTRUCTION</strong></h4>
<p class="noindent">To enable Bluetooth connectivity for your Raspberry Pi, you only need to attach a USB dongle to your system.</p>
<p class="indent">The Arduino requires the aforementioned Bluetooth module and a pair of resistors to divide the 5V signal level of the Arduino to the 3V level expected <a id="page_151"/>by the Bluetooth module. Mount the module and resistors to the side of the screwshield’s prototyping area not already being used by the fire alarm interface from Project 11.</p>
<p class="indent"><a href="ch08.html#ch08fig7">Figure 8-7</a> shows the wiring layout for the project. To avoid confusion, <a href="ch08.html#ch08fig7">Figure 8-7</a> shows the Bluetooth module attached to a screwshield without any other projects built on it.</p>
<div class="image"><img src="graphics/f08-07.jpg" alt="image"/></div>
<p class="figuret"><a id="ch08fig7">Figure 8-7:</a> Wiring layout for adding Bluetooth to an Arduino</p>
<p class="indent">The Bluetooth module needs to lie flat to keep it out of the way of the LCD shield. For this, you need to solder a row of four 0.1-inch header pins and then solder the Bluetooth module perpendicular to the pins, lying flat over the screwshield. If you prefer, you may also use female-to-female jumper wires to connect the Bluetooth module to the header pins.</p>
<h5 class="h5" id="ch00lev1sec151"><strong>STEP 1: SOLDER THE HEADER PINS</strong></h5>
<p class="noindent">Solder the strip of header pins into place. You can see in <a href="ch08.html#ch08fig8">Figure 8-8</a> that the +5V and GND pin connections neatly line up with the two power rows at the top of the screwshield.</p>
<div class="image"><a id="page_152"/><img src="graphics/f08-08.jpg" alt="image"/></div>
<p class="figuret"><a id="ch08fig8">Figure 8-8:</a> The header pins soldered in place</p>
<p class="indent">Note that the wire shown leading to pin 3 of the Arduino is part of the fire alarm from Project 11, not this project.</p>
<h5 class="h5" id="ch00lev1sec152"><strong>STEP 2: SOLDERING THE RESISTORS AND LINKING WIRE</strong></h5>
<p class="noindent">Solder the resistors and linking wire to the screwshield in the positions shown in <a href="ch08.html#ch08fig9">Figure 8-9</a>: the 470 Ω resistor goes from GND at Arduino column 7 to the bottom header at column 4; the 270 Ω resistor goes from the bottom pin of the header at row 3 to Arduino pin 1. The connecting wire runs from Arduino pin 0 to the third header pin down.</p>
<div class="image"><img src="graphics/f08-09.jpg" alt="image"/></div>
<p class="figuret"><a id="ch08fig9">Figure 8-9:</a> Soldering the resistors and connecting wire</p>
<p class="indent"><a id="page_153"/>When you’ve soldered the resistors and connecting wire in place, flip the screwshield over to solder the underside of the board.</p>
<p class="indent"><a href="ch08.html#ch08fig10">Figure 8-10</a> shows a close-up of the underside of the screwshield. To make it easier to identify what is connected to what, the resistors and linking wire are shown as if they were visible through the board.</p>
<div class="image"><img src="graphics/f08-10.jpg" alt="image"/></div>
<p class="figuret"><a id="ch08fig10">Figure 8-10:</a> Connecting the underside of the screwshield</p>
<p class="indent">First, bend the bottom lead of the 270 Ω resistor over toward the bottom pin header <span class="ent">➊</span>. Solder this to the bottom pin header’s pad and snip off the remaining lead. Bend the remaining lead from the bottom end of the 470 Ω resistor to meet the pad one position to its left <span class="ent">➋</span>. Solder the lead to that pad and snip off the excess lead. You have now made a continuous connection from the bottom of the header pins to the bottoms of the 270 Ω resistor and the 470 Ω resistor.</p>
<p class="indent">The final connection on the underside <span class="ent">➌</span> uses the spare wire from soldering the lead from the jumper wire to the header pin to its immediate left.</p>
<h5 class="h5" id="ch00lev1sec153"><strong>STEP 3: SOLDERING THE BLUETOOTH MODULE</strong></h5>
<p class="noindent">The final step is to solder the Bluetooth module to the header pins. Solder one pad on the module to one of the header pins, and while keeping the solder molten, position the Bluetooth module so that it is resting against the 1 kΩ resistor that came attached to the screwshield. Then attach the first prong of the module to the first pin. You can see this resistor on the bottom right of <a href="ch08.html#ch08fig9">Figure 8-9</a>. Once the first prong is soldered, all the other prongs should be <a id="page_154"/>lined up and easy to solder. If you prefer, you could use female-to-female jumper wires to link the screwshield to the Bluetooth module. <a href="ch08.html#ch08fig11">Figure 8-11</a> shows the Bluetooth module in position.</p>
<div class="image"><img src="graphics/f08-11.jpg" alt="image"/></div>
<p class="figuret"><a id="ch08fig11">Figure 8-11:</a> The Bluetooth module soldered in position</p>
<h4 class="h4" id="ch00lev1sec154"><strong>SOFTWARE</strong></h4>
<p class="noindent">Since your sensors aren’t changing, you’ll use the same Arduino software as in “<a href="ch08.html#ch00lev1sec141">Arduino Software</a>” on <a href="ch08.html#page_143">page 143</a>. The Bluetooth module replaces the USB interface.</p>
<p class="indent">Note that this hardware communicates with the Bluetooth module using the serial port, which on an Arduino Uno is shared with the USB interface. This means that you need to unplug the shield (or just the Bluetooth module if you used jumper wires) before you program the Arduino.</p>
<p class="indent">The Raspberry Pi software, however, does need a couple of minor changes, and getting the Raspberry Pi to use Bluetooth does require you to install a whole load of software. Remember: You’ll need to install this software before the Internet fails!</p>
<p class="indent">Plug the Bluetooth USB adapter into a free USB slot on your Raspberry Pi and then run the following commands in an LXTerminal window:</p>
<p class="programsb">$ <span class="codestrong">sudo apt-get update</span><br/>$ <span class="codestrong">sudo apt-get install bluetooth</span><br/>$ <span class="codestrong">sudo apt-get install bluez-utils</span><br/>$ <span class="codestrong">sudo apt-get install blueman</span></p>
<p class="indent"><a id="page_155"/>Installing the software will take a considerable amount of time, so you might want to practice your martial arts skills on any willing humans or unwilling zombies available.</p>
<p class="indent">When the software is installed and you’ve worked up a good sweat, reboot the Raspberry Pi with this command:</p>
<p class="programsb">$ <span class="codestrong">sudo reboot</span></p>
<p class="indent">Once the Raspberry Pi has rebooted, open a terminal and run the following command to ascertain the ID of the BT interface:</p>
<p class="programsb">   $ <span class="codestrong">hciconfig</span><br/><span class="ent">➊</span>  hci0: Type: BR/EDR Bus: USB<br/>         BD Address: 00:15:83:0C:BF:EB ACL MTU: 339:8 SCO MTU: 128:2<br/>         UP RUNNING PSCAN <br/>         RX bytes:419213 acl:19939 sco:0 events:7407 errors:0<br/>         TX bytes:95875 acl:7321 sco:0 commands:57 errors:0</p>
<p class="indent">The information we want here is the name of the interface, which in this case is <span class="literal">hci0</span> at <span class="ent">➊</span>. When you run this, if the number after <span class="literal">hci</span> above is not <span class="literal">0</span>, then make a note of the number; you will need it later.</p>
<p class="indent">Every Bluetooth device has a unique ID called a <em>MAC address</em>. We need to find the MAC address for our new Arduino Bluetooth module to pair it with the Raspberry Pi. When you power up the Arduino, you should see an LED blinking on the Bluetooth module. The LED is blinking because it has not yet been paired up with the Raspberry Pi; once it has been paired, the LED will go on and stay on. Run the following command to find the ID of the Bluetooth module:</p>
<p class="programsb">$ <span class="codestrong">hcitool scan</span></p>
<p class="indent">The output from the <span class="literal">hcitool</span> command should look like this:</p>
<p class="programs">Scanning ...<br/>      00:11:04:08:04:76   linvor</p>
<p class="indent">The ID is the six-part number. Copy this into the copy-and-paste buffer (Copy and Paste are on the right-click menu). Then enter the following command to link the Raspberry Pi and the Bluetooth module (remember to change the Bluetooth ID to match your Bluetooth module’s ID):</p>
<p class="programsb">$ <span class="codestrong">sudo hcitool cc</span> <span class="codeitalic"><span class="codestrong">00:11:04:08:04:76</span></span></p>
<p class="indent"><a id="page_156"/>If you have not already done so, follow the instructions in “<a href="ch08.html#ch00lev1sec142">Raspberry Pi Software</a>” on <a href="ch08.html#page_145">page 145</a> for downloading the Raspberry Pi software. You will find the Bluetooth version of <em>control.py</em> in the folder <em>Raspberry Pi/control_center_bt</em>.</p>
<p class="indent">When you have the program, run the following <span class="literal">sudo</span> command, again replacing the Bluetooth ID with your own:</p>
<p class="programsb">$ <span class="codestrong">sudo rfcomm connect 0</span> <span class="codeitalic"><span class="codestrong">00:11:04:08:04:76</span></span> <span class="codestrong">1 &amp;</span><br/>[1] 2625<br/>$ Connected /dev/rfcomm0 to 00:11:04:08:04:76 on channel 1<br/>Press CTRL-C for hangup<br/>$</p>
<p class="indent">You’ll need to run this command before you run the program each time your Raspberry Pi reboots. The <span class="literal">&amp;</span> on the end of the command runs it in the background so that you can use the terminal window to run the program itself. Hit <small>ENTER</small> to get the <span class="literal">$</span> command prompt back.</p>
<p class="indent">If your Bluetooth interface name did not have a <span class="literal">0</span> after <span class="literal">hci</span> when you ran the <span class="literal">hciconfig</span> command earlier, change the first <span class="literal">0</span> after <span class="literal">connect</span> to match the number on the end of <span class="literal">hci</span>. Remember when I asked you to make a note of this number?</p>
<p class="indent">Finally, move to the project directory and run the program:</p>
<p class="programsb">$ <span class="codestrong">cd ~/zombies/control_center_bt/</span><br/>$ <span class="codestrong">python control.py</span></p>
<p class="indent">If you look at the <em>control.py</em> files from this project and Project 13, you can see that the only difference is the port. In this version of <em>control.py</em>, we set the port to <em>/dev/rfcomm0</em> rather than <em>/dev/ttyACM0</em> so that it uses the Bluetooth connection rather than the USB connection.</p>
<h4 class="h4" id="ch00lev1sec155"><strong>USING THE BLUETOOTH-ENABLED COMMAND CENTER</strong></h4>
<p class="noindent">The project works in exactly the same way as the USB version in Project 13, with the window displaying the same information, only now it’s a little more portable as long as your webcam is wireless. If zombies get into your compound, just grab the Raspberry Pi, monitor, and power source and barricade yourself inside a closet until they lose interest.</p>
<p class="indent">In the next chapter, we’ll work on ways to distract zombies in a pinch, because the undead are usually much easier to run from than they are to actually kill.</p>
</body></html>