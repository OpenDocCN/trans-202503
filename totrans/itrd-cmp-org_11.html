<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_207"/><strong><span class="big">11</span><br/>INSIDE THE MAIN FUNCTION</strong></h2>&#13;
<div class="image1"><img src="../images/pg235_Image_254.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="noindentz">As you learned in <a href="ch10.xhtml">Chapter 10</a>, a C program begins by executing a function named <code>main</code>, which is called from a startup function in the C hosted environment. The <code>main</code> function will call other functions (<em>subfunctions</em>) to do most of the processing. Even a simple “Hello, World!” program needs to call another function to write the message on the screen.</p>&#13;
<p class="indent">In this chapter, we’ll focus on the <code>main</code> function, but the concepts apply to all the functions we’ll be writing. We’ll begin with a detailed look at the call stack, which is used for saving values and for local variables. Then we’ll look at how to process data in a function and how to pass arguments to other functions. I’ll wrap up the chapter by showing you how to use this knowledge to write the <code>main</code> function in assembly language.</p>&#13;
<h3 class="h3" id="ch11lev1sec1"><strong>Using the Call Stack</strong></h3>&#13;
<p class="noindent">The <em>call stack</em>, commonly referred to simply as the <em>stack</em>, is a very useful place for creating local variables and saving items within a function. Before we cover how to use the stack for these purposes, you need to understand what stacks are and how they work.</p>&#13;
<h4 class="h4" id="ch11lev2sec1"><span epub:type="pagebreak" id="page_208"/><em><strong>Stacks in General</strong></em></h4>&#13;
<p class="noindent">A stack is a linear data structure created in memory to store data items. Insertion of a data item onto (or deletion from) a stack can be done at only one end, called the <em>top</em>. Programs keep track of the top of the stack with a <em>stack pointer</em>.</p>&#13;
<p class="indent">Informally, you can think of a stack as being organized like a stack of dinner plates on a shelf. You need to be able to access only the item at the top of the stack. (And, yes, if you pull out a plate from somewhere within the stack, you will probably break something.) There are two fundamental operations on a stack:</p>&#13;
<div class="indL">&#13;
<p class="noindentin"><span class="codestrong">push</span> <span class="codestrongitalic">data_item</span> Places the <span class="codeitalic">data_item</span> at the top of the stack and moves the stack pointer to point to this latest item</p>&#13;
<p class="noindentin"><span class="codestrong">pop</span> <span class="codestrongitalic">location</span> Moves the data item at the top of the stack to <span class="codeitalic">location</span> and moves the stack pointer to point to the item now at the top of the stack</p>&#13;
</div>&#13;
<p class="indent">The stack is a <em>last in, first out (LIFO)</em> data structure. The last thing to be pushed onto the stack is the first thing to be popped off.</p>&#13;
<p class="indent">To illustrate the stack concept, let’s continue with the dinner plate example. Say we have three differently colored dinner plates: a red one on the dining table, a green one on the kitchen counter, and a blue one on the bedside table. We’ll stack them on the shelf in the following way:</p>&#13;
<ol>&#13;
<li class="noindent">Push red plate.</li>&#13;
<li class="noindent">Push green plate.</li>&#13;
<li class="noindent">Push blue plate.</li>&#13;
</ol>&#13;
<p class="indent">At this point, our stack of plates looks like <a href="ch11.xhtml#ch11fig1">Figure 11-1</a>.</p>&#13;
<div class="image"><img id="ch11fig1" src="../images/pg236_Image_255.jpg" alt="image" width="183" height="108"/></div>&#13;
<p class="figcap"><em>Figure 11-1: Three dinner plates in a stack</em></p>&#13;
<p class="indent">Now we perform the next operation:</p>&#13;
<ol start="4">&#13;
<li class="noindent">Pop kitchen counter.</li>&#13;
</ol>&#13;
<p class="indent">This moves the blue plate to the kitchen counter (recall that the blue plate was previously on the bedside table) and leaves the stack of dinner plates as shown in <a href="ch11.xhtml#ch11fig2">Figure 11-2</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_209"/><img id="ch11fig2" src="../images/pg237_Image_256.jpg" alt="image" width="183" height="71"/></div>&#13;
<p class="figcap"><em>Figure 11-2: One dinner plate has been popped from the stack.</em></p>&#13;
<p class="indent">If you have guessed that it’s easy to really mess up a stack, you’re right. A stack must be used according to a strict discipline. Within any function:</p>&#13;
<ul>&#13;
<li class="noindent">Always push an item onto the stack before popping anything off.</li>&#13;
<li class="noindent">Never pop more things off than you have pushed on.</li>&#13;
<li class="noindent">Always pop everything off the stack that you have pushed on.</li>&#13;
</ul>&#13;
<p class="indent">If you have no use for the item(s) that you have pushed onto the stack, you may simply set the stack pointer to where it was when the function was first entered. This is equivalent to discarding the items that are popped off. (Our dinner plate analogy breaks down here.)</p>&#13;
<p class="indent">A good way to maintain this discipline is to think of the use of parentheses in an algebraic expression. A push is analogous to a left parenthesis and a pop to a right parenthesis. The pairs of parentheses can be nested, but they have to match. An attempt to push too many items onto a stack is called <em>stack overflow</em>. An attempt to pop items off the stack beyond the bottom is called <em>stack underflow</em>.</p>&#13;
<p class="indent">A stack is implemented by dedicating a contiguous area of main memory to it. Stacks can grow in either direction in memory, into higher addresses or lower. An <em>ascending stack</em> grows into higher addresses, and a <em>descending stack</em> grows into lower addresses. The stack pointer can point to the top item on the stack, a <em>full stack</em>, or to the memory location where the next item will be pushed onto the stack, an <em>empty stack</em>. These four possible stack implementations are shown in <a href="ch11.xhtml#ch11fig3">Figure 11-3</a>, with the integers 1, 2, and 3 pushed onto the stack in that order. Notice that memory addresses are <em>increasing downward</em> in this figure, which is the way we usually view them in the <code>gdb</code> debugger.</p>&#13;
<div class="image"><img id="ch11fig3" src="../images/pg237_Image_257.jpg" alt="image" width="580" height="256"/></div>&#13;
<p class="figcap"><em>Figure 11-3: Four ways to implement a stack</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_210"/>The call stack in our environment is a <em>full descending stack</em>. To understand this choice, think about how you might organize things in memory. Recall that the control unit automatically increments the program counter as your program is executed. Programs come in vastly different sizes, so storing the program instructions at low memory addresses allows maximum flexibility with respect to program size.</p>&#13;
<p class="indent">The stack is a dynamic structure. You don’t know how much stack space will be required by any given program as it executes, so it’s impossible to know how much space to allocate. To allocate as much space as possible, while preventing it from colliding with program instructions, start the stack at the highest memory address and have it grow toward lower addresses.</p>&#13;
<p class="indent">This is a highly simplified rationalization for implementing stacks that grow “downward” in memory. The organization of various program elements in memory is much more complex than the description given here, but this may help you understand that there are some good reasons for what may seem to be a rather odd implementation.</p>&#13;
<p class="indent">The A64 architecture does not have <code>push</code> and <code>pop</code> instructions. It has instructions that allow you to effectively push items onto or pop items off of the stack, but most of the operations on the stack are done by allocating memory on the call stack and then directly storing items into or loading items from this allocated memory. Next, we’ll look at how functions use the call stack.</p>&#13;
<h4 class="h4" id="ch11lev2sec2"><em><strong>The Stack Frame</strong></em></h4>&#13;
<p class="noindent">Each function that calls another function needs to allocate memory on the stack for that function to use to save items and store local variables. This allocated memory is called a <em>stack frame</em> or <em>activation record</em>. To see how this works, we’ll start with a program that has one local variable and calls two functions in the C standard library: <code>printf</code> and <code>scanf</code>. The program is shown in <a href="ch11.xhtml#ch11list1">Listing 11-1</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>inc_int.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Increment an integer.&#13;
 &#13;
#include &lt;stdio.h&gt;&#13;
 &#13;
int main(void)&#13;
{&#13;
    int x;&#13;
 &#13;
    printf("Enter an integer: ");&#13;
    scanf("%i", &amp;x);&#13;
    x++;&#13;
    printf("Result: %i\n", x);<span epub:type="pagebreak" id="page_211"/>&#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch11list1"><em>Listing 11-1: A program to increment an integer</em></p>&#13;
<p class="indent">You can see how a stack frame is created by looking at the assembly language generated by the compiler, shown in <a href="ch11.xhtml#ch11list2">Listing 11-2</a>. I’ll be referring to the numbered lines in this listing in the next several sections of this chapter, through <a href="ch11.xhtml#page_222">page 222</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>inc_int.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "inc_int.c"&#13;
        .text&#13;
      <span class="ent">➊</span> .section        .rodata&#13;
        .align  3&#13;
.LC0:&#13;
        .string "Enter an integer: "&#13;
        .align  3&#13;
.LC1:&#13;
      <span class="ent">➋</span> .string "%i"&#13;
        .align  3&#13;
.LC2:&#13;
        .string "Result: %i\n"&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
     <span class="ent">➌</span> stp     x29, x30, [sp, -32]!  /// Create stack frame&#13;
        mov     x29, sp               /// Set our frame pointer&#13;
        adrp    x0, .LC0              /// Page address&#13;
        add     x0, x0, :lo12:.LC0    /// Offset in page&#13;
        bl      printf&#13;
     <span class="ent">➍</span> add     x0, sp, 28            /// Address of x&#13;
        mov     x1, x0&#13;
     <span class="ent">➎</span> adrp    x0, .LC1&#13;
        add     x0, x0, :lo12:.LC1&#13;
        bl      __isoc99_scanf&#13;
     <span class="ent">➏</span> ldr     w0, [sp, 28]          /// Load int&#13;
        add     w0, w0, 1&#13;
     <span class="ent">❼</span> str     w0, [sp, 28]          /// x++;&#13;
        ldr     w0, [sp, 28]&#13;
        mov     w1, w0&#13;
        adrp    x0, .LC2&#13;
        add     x0, x0, :lo12:.LC2<span epub:type="pagebreak" id="page_212"/>&#13;
        bl      printf&#13;
        mov     w0, 0&#13;
     <span class="ent">❽</span> ldp     x29, x30, [sp], 32&#13;
        ret&#13;
        .size   main, .-main&#13;
        .ident  "GCC: (Debian 10.2.1-6) 10.2.1 20210110"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<p class="list" id="ch11list2"><em>Listing 11-2: The compiler-generated assembly language for the program in <a href="ch11.xhtml#ch11list1">Listing 11-1</a></em></p>&#13;
<p class="indent">The instructions used to create the stack frame form the <em>function prologue</em>. The first instruction in a function prologue is usually an <code>stp</code> instruction:</p>&#13;
<p class="noindenttL"><span class="codestrong">stp</span><strong>—Store register pair</strong></p>&#13;
<p class="hang"><code>stp w</code><span class="codeitalic">s1</span>, <code>w</code><span class="codeitalic">s2</span>, [<code>x</code><span class="codeitalic">b</span><code>{,</code> <span class="codeitalic">offset</span><code>}]</code> stores the value in <code>w</code><span class="codeitalic">s1</span> at the address in <code>x</code><span class="codeitalic">b</span> and the value in <code>w</code><span class="codeitalic">s2</span> at <code>x</code><span class="codeitalic">b</span> + 4. If <span class="codeitalic">offset</span> exists, it must be a multiple of 4 and is added to the address before storing the register values; <code>x</code><span class="codeitalic">b</span> is not changed.</p>&#13;
<p class="hang"><code>stp x</code><span class="codeitalic">s1</span>, <code>x</code><span class="codeitalic">s2</span> , [<code>x</code><span class="codeitalic">b</span>{<code>,</code> <span class="codeitalic">offset</span><code>}]</code> stores the value in <code>x</code><span class="codeitalic">s1</span> at the address in <code>x</code><span class="codeitalic">b</span> and the value in <code>x</code><span class="codeitalic">s2</span> at <code>x</code><span class="codeitalic">b</span> + 8. If <span class="codeitalic">offset</span> exists, it must be a multiple of 8 and is added to the address before storing the register values; <code>x</code><span class="codeitalic">b</span> is not changed.</p>&#13;
<p class="noindentt"><span class="codestrong">stp</span><strong>—Store register pair, pre-index</strong></p>&#13;
<p class="hang"><code>stp w</code><span class="codeitalic">s1</span>, <code>w</code><span class="codeitalic">s2</span>, [<code>x</code><span class="codeitalic">b</span><code>,</code> <span class="codeitalic">offset</span><code>]!</code> adds <span class="codeitalic">offset</span>, which must be a multiple of 4, to <code>x</code><span class="codeitalic">b</span>. It then stores the value in <code>w</code><span class="codeitalic">s1</span> at the new address in <code>x</code><span class="codeitalic">b</span> and the value in <code>w</code><span class="codeitalic">s2</span> at <code>x</code><span class="codeitalic">b</span> + 4.</p>&#13;
<p class="hang"><code>stp x</code><span class="codeitalic">s1</span>, <code>x</code><span class="codeitalic">s2</span>, [<code>x</code><span class="codeitalic">b</span><code>,</code> <span class="codeitalic">offset</span><code>]!</code> adds <span class="codeitalic">offset</span>, which must be a multiple of 8, to <code>x</code><span class="codeitalic">b</span>. It then stores the value in <code>x</code><span class="codeitalic">s1</span> at the new address in <code>x</code><span class="codeitalic">b</span> and the value in <code>x</code><span class="codeitalic">s2</span> at <code>x</code><span class="codeitalic">b</span> + 8.</p>&#13;
<p class="noindent"><span class="codestrong">stp</span><strong>—Store register pair, post-index</strong></p>&#13;
<p class="hang"><code>stp w</code><span class="codeitalic">s1</span>, <code>w</code><span class="codeitalic">s2</span>, [<code>x</code><span class="codeitalic">b</span><code>],</code> <span class="codeitalic">offset</span> stores the value in <code>w</code><span class="codeitalic">s1</span> at the address in <code>x</code><span class="codeitalic">b</span> and the value in <code>w</code><span class="codeitalic">s2</span> at <code>x</code><span class="codeitalic">b</span> + 4. It then adds <span class="codeitalic">offset</span>, which must be a multiple of 4, to <code>x</code><span class="codeitalic">b</span>.</p>&#13;
<p class="hang"><code>stp x</code><span class="codeitalic">s1</span>, <code>x</code><span class="codeitalic">s2</span>, [<code>x</code><span class="codeitalic">b</span><code>],</code> <span class="codeitalic">offset</span> stores the value in <code>x</code><span class="codeitalic">s1</span> at the address in <code>x</code><span class="codeitalic">b</span> and the value in <code>x</code><span class="codeitalic">s2</span> at <code>x</code><span class="codeitalic">b</span> + 8. It then adds <span class="codeitalic">offset</span>, which must be a multiple of 8, to <code>x</code><span class="codeitalic">b</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The operand order for almost all other A64 instructions is</em> <code>destination(s), source(s)</code>, <em>but for the store instructions, it’s the opposite.</em></p>&#13;
</div>&#13;
<p class="indent">Almost all the functions we’ll write will begin with an <code>stp</code> instruction that looks like this:</p>&#13;
<pre class="pre">stp    x29, x30, [sp, -32]!</pre>&#13;
<p class="noindent">The compiler did this at the beginning of the function in <a href="ch11.xhtml#ch11list2">Listing 11-2</a>, creating the stack frame <span class="ent">❸</span>.</p>&#13;
<p class="indent"><a id="commonL3"/><span epub:type="pagebreak" id="page_213"/>The <em>Procedure Call Standard for the Arm 64-Bit Architecture (AArch64)</em> documentation (available in PDF and HTML formats at <em><a href="https://github.com/ARM-software/abi-aa/releases">https://github.com/ARM-software/abi-aa/releases</a></em>) specifies that the <em>frame pointer</em> (stored in register <code>x29</code>, also named <code>fp</code>) should point to the top of the stack frame, which is where the calling function’s frame pointer is stored. The instruction <code>mov x29, sp</code> will set the called function’s frame pointer, as shown in <a href="ch11.xhtml#ch11list2">Listing 11-2</a>.</p>&#13;
<p class="indent">The way the <code>stp</code> instruction has specified the stack memory address here, <code>[sp, -32]!</code>, probably doesn’t make a lot of sense to you. Let’s look at how instructions access memory in the A64 architecture.</p>&#13;
<h4 class="h4" id="ch11lev2sec3"><em><strong>A64 Memory Addressing</strong></em></h4>&#13;
<p class="noindent">There are two ways that an instruction might refer to a memory address: the address could be encoded as part of the instruction, usually called an <em>absolute address</em>, or it could use <em>relative addressing</em>, where the instruction specifies an <em>offset</em> from a <em>base address</em>. In the latter case, the size of the offset and the location of the base address are encoded in the instruction.</p>&#13;
<p class="indent">All instructions in the A64 architecture are 32 bits long, but addresses are 64 bits long. We’ll look at the details of the machine code in <a href="ch12.xhtml">Chapter 12</a>, but it’s clear that a 64-bit address will not fit within a 32-bit instruction. To refer to a 64-bit address, instructions use one of the relative addressing modes listed in <a href="ch11.xhtml#ch11tab1">Table 11-1</a> to compute the address when they are executed.</p>&#13;
<p class="tabcap" id="ch11tab1"><strong>Table 11-1:</strong> A64 Addressing Modes</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Mode</strong></th>&#13;
<th class="tab_th"><strong>Syntax</strong></th>&#13;
<th class="tab_th"><strong>Note</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1">Literal</td>&#13;
<td class="bg1"><span class="codeitalic">label</span></td>&#13;
<td class="bg1"><code>pc</code>-relative</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">Base register</td>&#13;
<td class="bg"><code>[</code><span class="codeitalic">base</span><code>]</code></td>&#13;
<td class="bg">Register only</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">Base plus offset</td>&#13;
<td class="bg1"><code>[</code><span class="codeitalic">base</span><code>,</code> <span class="codeitalic">offset</span><code>]</code></td>&#13;
<td class="bg1">Register-relative</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">Pre-indexed</td>&#13;
<td class="bg"><code>[</code><span class="codeitalic">base</span><code>,</code> <span class="codeitalic">offset</span><code>]!</code></td>&#13;
<td class="bg">Add offset to register before</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">Post-indexed</td>&#13;
<td class="bg1"><code>[</code><span class="codeitalic">base</span><code>],</code> <span class="codeitalic">offset</span></td>&#13;
<td class="bg1">Add offset to register after</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Each of the addressing modes in <a href="ch11.xhtml#ch11tab1">Table 11-1</a> starts with a 64-bit address in a <em>base register</em>. The literal mode uses <span class="codeitalic">pc</span>-<em>relative addressing</em>, where the program counter serves as the base register. If <span class="codeitalic">label</span> is in the same section as the instruction that references it, the assembler computes the address offset from the referencing instruction to the labeled instruction and fills in this offset as part of the referencing instruction. If the label is in another section, the linker will compute the offset and fill that in where the label is referenced. The number of bits allowed in the instruction limits the size of the address offset.</p>&#13;
<p class="indent">One of the advantages of <code>pc</code>-relative addressing is that it gives us <em>position-independent code (PIC)</em>, which means the function will execute correctly no matter where it is loaded into memory. The default for the <code>gcc</code> compiler in our environment is to produce PIC, with the linking phase producing a <em>position-independent executable (PIE)</em>. This means the linker doesn’t specify a load address for the program, so the operating system can load the program <span epub:type="pagebreak" id="page_214"/>wherever it chooses. Not including the load address with the executable file improves security.</p>&#13;
<p class="indent">In the other four modes, the base register is a general-purpose register, <code>x0</code>–<code>x30</code>, or <code>sp</code>. For the base-plus-offset mode, the offset can be an immediate value or in a register. The offset is sign-extended to 64 bits and added to the value in the base register to compute the address. If the offset is in a register, it can be scaled so that it is a multiple of the number of bytes being loaded or stored. You’ll see how this works when you learn to process integer arrays in <a href="ch17.xhtml">Chapter 17</a>.</p>&#13;
<p class="indent">In the pre-indexed mode, the computed address is stored in the base register <em>before</em> loading or storing the value. In the post-indexed mode, the computed address is stored in the base register <em>after</em> loading or storing the value.</p>&#13;
<p class="indent">For the pre-indexed mode, the offset can only be an immediate value. The post-indexed mode allows an immediate value for the offset or, for some advanced programming techniques, an offset value in a register.</p>&#13;
<p class="indent">The call stack in our environment is full-descending (see <a href="ch11.xhtml#ch11fig3">Figure 11-3</a>), so the <code>stp</code> instruction uses the pre-indexed addressing mode. In the function in <a href="ch11.xhtml#ch11list2">Listing 11-2</a>, the address is specified as <code>[sp, -32]!</code> <span class="ent">❸</span>. This subtracts 32 from the stack pointer <em>before</em> storing the caller’s frame pointer and return address on the stack. This effectively allocates 16 bytes on the stack for this function’s use, then pushes the return address and the caller’s frame pointer onto the call stack. The number of bytes allocated for the stack frame must always be a multiple of 16 because the stack pointer, <code>sp</code>, must always be aligned on a 16-byte address boundary.</p>&#13;
<p class="indent">After the function has completed its processing, we need a <em>function epilogue</em> to restore the caller’s frame pointer and link register and to delete the stack frame. In the function in <a href="ch11.xhtml#ch11list2">Listing 11-2</a>, this is done with the following instruction:</p>&#13;
<pre class="pre">ldp    x29, x30, [sp], 32</pre>&#13;
<p class="indent">This instruction loads the two values at the top of the stack into the frame pointer and link register, then adds 32 to the stack pointer <span class="ent">❽</span>. This effectively pops the two values off the top of the stack into the <code>x29</code> and <code>x30</code> registers and then deletes this function’s stack frame. Let’s look at some variants of the <code>ldp</code> instruction, which allows us to load two values at a time from memory:</p>&#13;
<p class="noindenttL"><span class="codestrong">ldp</span><strong>—Load register pair</strong></p>&#13;
<p class="hang"><code>ldp w</code><span class="codeitalic">d1</span>, <code>w</code><span class="codeitalic">d2</span>, <code>[x</code><span class="codeitalic">b</span><code>{,</code> <span class="codeitalic">offset</span><code>}]</code> loads the value at the address in <code>x</code><span class="codeitalic">b</span> into <code>w</code><span class="codeitalic">d1</span> and the value at <code>x</code><span class="codeitalic">b</span> + 4 into <code>w</code><span class="codeitalic">d2</span>. If <span class="codeitalic">offset</span> exists, it must be a multiple of 4 and is added to the address before loading the values; <code>x</code><span class="codeitalic">b</span> is not changed.</p>&#13;
<p class="hang"><code>ldp x</code><span class="codeitalic">d1</span>, <code>x</code><span class="codeitalic">d2</span>, [<code>x</code><span class="codeitalic">b</span><code>{,</code> <span class="codeitalic">offset</span><code>}]</code> loads the value at the address in <code>x</code><span class="codeitalic">b</span> into <code>x</code><span class="codeitalic">d1</span> and the value at <code>x</code><span class="codeitalic">b</span> + 8 into <code>x</code><span class="codeitalic">d2</span>. If <span class="codeitalic">offset</span> exists, it must be a multiple of 8 and is added to the address before loading the values; <code>x</code><span class="codeitalic">b</span> is not changed.</p>&#13;
<p class="noindentt"><span epub:type="pagebreak" id="page_215"/><span class="codestrong">ldp</span><strong>—Load register pair, pre-index</strong></p>&#13;
<p class="hang"><code>ldp w</code><span class="codeitalic">d1</span>, <code>w</code><span class="codeitalic">d2</span>, <code>[x</code><span class="codeitalic">b</span>, <span class="codeitalic">offset</span><code>]!</code> adds <span class="codeitalic">offset</span>, which must be a multiple of 4, to <code>x</code><span class="codeitalic">b</span>. It then loads the value at the new address in <code>x</code><span class="codeitalic">b</span> into <code>w</code><span class="codeitalic">d1</span> and the value at <code>x</code><span class="codeitalic">b</span> + 4 into <code>w</code><span class="codeitalic">d2</span>.</p>&#13;
<p class="hang"><code>ldp x</code><span class="codeitalic">d1</span>, <code>x</code><span class="codeitalic">d2</span>, [<code>x</code><span class="codeitalic">b</span><code>,</code> <span class="codeitalic">offset</span><code>]!</code> adds <span class="codeitalic">offset</span>, which must be a multiple of 8, to <code>x</code><span class="codeitalic">b</span>. It then loads the value at the new address in <code>x</code><span class="codeitalic">b</span> into <code>x</code><span class="codeitalic">d1</span> and the value at <code>x</code><span class="codeitalic">b</span> + 8 into <code>x</code><span class="codeitalic">d2</span>.</p>&#13;
<p class="noindentt"><span class="codestrong">ldp</span><strong>—Load register pair, post-index</strong></p>&#13;
<p class="hang"><code>ldp w</code><span class="codeitalic">d1</span>, <code>w</code><span class="codeitalic">d2</span>, [<code>x</code><span class="codeitalic">b</span><code>],</code> <span class="codeitalic">offset</span> loads the value at the address in <code>x</code><span class="codeitalic">b</span> into <code>w</code><span class="codeitalic">d1</span> and the value at <code>x</code><span class="codeitalic">b</span> + 4 into <code>w</code><span class="codeitalic">d2</span>. It then adds <span class="codeitalic">offset</span>, which must be a multiple of 4, to <code>x</code><span class="codeitalic">b</span>.</p>&#13;
<p class="hang"><code>ldp x</code><span class="codeitalic">d1</span>, <code>x</code><span class="codeitalic">d2</span>, [<code>x</code><span class="codeitalic">b</span><code>],</code> <span class="codeitalic">offset</span> loads the value at the address in <code>x</code><span class="codeitalic">b</span> into <code>x</code><span class="codeitalic">d1</span> and the value at <code>x</code><span class="codeitalic">b</span> + 8 into <code>x</code><span class="codeitalic">d2</span>. It then adds <span class="codeitalic">offset</span>, which must be a multiple of 8, to <code>x</code><span class="codeitalic">b</span>.</p>&#13;
<p class="indenttL">Next, we’ll see how this function uses the other 16 bytes of stack memory.</p>&#13;
<h4 class="h4" id="ch11lev2sec4"><em><strong>Local Variables on the Call Stack</strong></em></h4>&#13;
<p class="noindent">Local variables in C can be directly accessed by their names only in the function where they’re defined. We can allow another function to access a local variable in our function, including changing its value, by passing the address of that variable to the other function. This is what enables <code>scanf</code> to store a value for <code>x</code>, as you’ll see on <a href="ch11.xhtml#commonL2">page 221</a>.</p>&#13;
<p class="indent">You learned in <a href="ch09.xhtml">Chapter 9</a> that CPU registers can be used as variables. But if we were to use CPU registers to hold all of our variables, we’d soon run out of registers, even in a small program. So, we need to allocate space in memory for variables.</p>&#13;
<p class="indent">As we’ll see later in this chapter, a function needs to preserve the contents of some registers for the calling function. If we want to use such a register in our function, a local variable would be a good place to store a copy of its content so we can restore it before returning to the calling function.</p>&#13;
<p class="indent">The stack frame meets the requirements of local variables. It’s created when the function first starts, and it’s deleted once the function completes. The memory in a stack frame is easily accessed using the base-plus-offset addressing mode (see <a href="ch11.xhtml#ch11tab1">Table 11-1</a>), with <code>sp</code> as the base addressing register. An example in <a href="ch11.xhtml#ch11list2">Listing 11-2</a> is where we load the integer:</p>&#13;
<pre class="pre">ldr    w0, [sp, 28]</pre>&#13;
<p class="noindent">This instruction loads the 32-bit word located 28 bytes from the address in <code>sp</code> into <code>w0</code> <span class="ent">❻</span>. The function treats its stack frame as a record rather than a stack with this code. You’ll learn about records in <a href="ch17.xhtml">Chapter 17</a>.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11fig4">Figure 11-4</a> gives a pictorial view of the completed stack frame for the <code>main</code> function in <a href="ch11.xhtml#ch11list1">Listings 11-1</a> and <a href="ch11.xhtml#ch11list2">11-2</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_216"/><img id="ch11fig4" src="../images/pg244_Image_258.jpg" alt="image" width="440" height="204"/></div>&#13;
<p class="figcap"><em>Figure 11-4: The stack frame for the function in <a href="ch11.xhtml#ch11list1">Listings 11-1</a> and <a href="ch11.xhtml#ch11list2">11-2</a></em></p>&#13;
<p class="indent">The two addresses on the stack each take 8 bytes, and the <code>int</code> variable, <code>x</code>, takes 4 bytes. The memory in the gray area is unused but necessary for keeping the stack pointer, <code>sp</code>, aligned on a 16-byte address boundary.</p>&#13;
<p class="indent">Now that you know how to use a stack frame, let’s look at how this function processes data.</p>&#13;
<h3 class="h3" id="ch11lev1sec2"><strong>Processing Data in a Function</strong></h3>&#13;
<p class="noindent">A64 is a <em>load–store architecture</em>, which means the instructions that operate on data cannot access memory. There is a separate group of instructions for moving data to and from memory.</p>&#13;
<p class="indent">This is in contrast to a <em>register–memory architecture</em>, which includes instructions that can operate on data in memory. The data operations are still performed by the arithmetic/logic unit in the CPU (see <a href="ch09.xhtml#ch9fig1">Figure 9-1</a>), but they use registers that are hidden from the programmer. The Intel x86 is an example of a register–memory architecture.</p>&#13;
<p class="indent">The processing in the <code>main</code> function in <a href="ch11.xhtml#ch11list2">Listing 11-2</a> is very simple: the program adds 1 to an integer. But before it can perform this operation, it needs to load the value into a register using the <code>ldr</code> instruction <span class="ent">❻</span>. Since this program changes the value in the variable, the new value must be stored back into memory with the <code>str</code> instruction <span class="ent">❼</span>.</p>&#13;
<p class="indent">Let’s look at some common instructions used for loading values from memory:</p>&#13;
<p class="noindenttL"><span class="codestrong">ldr</span><strong>—Load register,</strong> <span class="codestrong">pc</span><strong>-relative</strong></p>&#13;
<p class="hang"><code>ldr w</code><span class="codeitalic">d</span><code>,</code> <span class="codeitalic">addr</span> loads <code>w</code><span class="codeitalic">d</span> with the 32-bit value at memory location <span class="codeitalic">addr</span>, which must be ±1MB from this instruction. Bits 63 to 32 of <code>x</code><span class="codeitalic">d</span> are set to <code>0</code>.</p>&#13;
<p class="hang"><code>ldr x</code><span class="codeitalic">d</span><code>,</code> <span class="codeitalic">addr</span> loads <code>x</code><span class="codeitalic">d</span> with the 64-bit value at memory location <span class="codeitalic">addr</span>, which must be ±1MB from this instruction.</p>&#13;
<p class="noindentt"><span class="codestrong">ldr</span><strong>—Load register, base register–relative</strong></p>&#13;
<p class="hang"><code>ldr w</code><span class="codeitalic">d</span>, <code>[x</code><span class="codeitalic">b</span><code>{,</code> <span class="codeitalic">offset</span><code>}]</code> loads <code>w</code><span class="codeitalic">d</span> with the 32-bit value at the memory location obtained by adding the address in <code>x</code><span class="codeitalic">b</span> and the optional <span class="codeitalic">offset</span>, <span epub:type="pagebreak" id="page_217"/>which is a multiple of 4 in the range 0 to 16,380. Bits 63 to 32 of <code>x</code><span class="codeitalic">d</span> are set to <code>0</code>.</p>&#13;
<p class="hang"><code>ldr x</code><span class="codeitalic">d</span>, <code>[x</code><span class="codeitalic">b</span><code>{,</code> <span class="codeitalic">offset</span><code>}]</code> loads <code>x</code><span class="codeitalic">d</span> with the 64-bit value at the memory location obtained by adding the address in <code>x</code><span class="codeitalic">b</span> and the optional <span class="codeitalic">offset</span>, which is a multiple of 8 in the range 0 to 32,760.</p>&#13;
<p class="noindentt"><span class="codestrong">ldrsw</span><strong>—Load register, signed word, base register–relative</strong></p>&#13;
<p class="hang"><code>ldrsw w</code><span class="codeitalic">d</span>, <code>[x</code><span class="codeitalic">b</span><code>{,</code> <span class="codeitalic">offset</span><code>}]</code> loads <code>w</code><span class="codeitalic">d</span> with the 32-bit value at the memory location obtained by adding the address in <code>x</code><span class="codeitalic">b</span> and the optional <span class="codeitalic">offset</span>, which is a multiple of 4 in the range 0 to 16,380. Bits 63 to 32 of <code>x</code><span class="codeitalic">d</span> are set to a copy of bit 31 of the loaded word.</p>&#13;
<p class="noindentt"><span class="codestrong">ldrb</span><strong>—Load register, unsigned byte, base register–relative</strong></p>&#13;
<p class="hang"><code>ldrb w</code><span class="codeitalic">d</span>, <code>[x</code><span class="codeitalic">b</span><code>{,</code> <span class="codeitalic">offset</span><code>}]</code> loads the low-order byte of <code>w</code><span class="codeitalic">d</span> with the 8-bit value at the memory location obtained by adding the address in <code>x</code><span class="codeitalic">b</span> and the optional <span class="codeitalic">offset</span>, which is in the range 0 to 4,095. Bits 31 to 8 of <code>x</code><span class="codeitalic">d</span> are set to <code>0</code>; bits 63 to 32 are unchanged.</p>&#13;
<p class="noindentt"><span class="codestrong">ldrsb</span><strong>—Load register, signed byte, base register–relative</strong></p>&#13;
<p class="hang"><code>ldrsb w</code><span class="codeitalic">d</span>, <code>[x</code><span class="codeitalic">b</span><code>{,</code> <span class="codeitalic">offset</span><code>}]</code> loads the low-order byte of <code>w</code><span class="codeitalic">d</span> with the 8-bit value at the memory location obtained by adding the address in <code>x</code><span class="codeitalic">b</span> and the optional <span class="codeitalic">offset</span>, which is in the range 0 to 4,095. Bits 31 to 8 of <code>x</code><span class="codeitalic">d</span> are set to a copy of bit 7 of the loaded byte; bits 63 to 32 are unchanged.</p>&#13;
<p class="indenttL">Here are some similar instructions for storing values in memory:</p>&#13;
<p class="noindenttL"><span class="codestrong">str</span><strong>—Store register,</strong> <span class="codestrong">pc</span><strong>-relative</strong></p>&#13;
<p class="hang"><code>str w</code><span class="codeitalic">s</span><code>,</code> <span class="codeitalic">addr</span> stores the 32-bit value in <code>w</code><span class="codeitalic">s</span> at memory location <span class="codeitalic">addr</span>, which must be ±1MB from this instruction.</p>&#13;
<p class="hang"><code>str x</code><span class="codeitalic">s</span><code>,</code> <span class="codeitalic">addr</span> stores the 64-bit value in <code>x</code><span class="codeitalic">s</span> at memory location <span class="codeitalic">addr</span>, which must be ±1MB from this instruction.</p>&#13;
<p class="noindentt"><span class="codestrong">str</span><strong>—Store register, base register–relative</strong></p>&#13;
<p class="hang"><code>str w</code><span class="codeitalic">s</span>, <code>[x</code><span class="codeitalic">b</span><code>{,</code> <span class="codeitalic">offset</span><code>}]</code> stores the 32-bit value in <code>w</code><span class="codeitalic">s</span> at the memory location obtained by adding the address in <code>x</code><span class="codeitalic">b</span> and the optional <span class="codeitalic">offset</span>, which is a multiple of 4 in the range 0 to 16,380.</p>&#13;
<p class="hang"><code>str x</code><span class="codeitalic">s</span>, <code>[x</code><span class="codeitalic">b</span><code>{,</code> <span class="codeitalic">offset</span><code>}]</code> stores the 64-bit value in <code>x</code><span class="codeitalic">s</span> at the memory location obtained by adding the address in <code>x</code><span class="codeitalic">b</span> and the optional <span class="codeitalic">offset</span>, which is a multiple of 8 in the range 0 to 32,670.</p>&#13;
<p class="noindentt"><span class="codestrong">strb</span><strong>—Store register, byte, base register–relative</strong></p>&#13;
<p class="hang"><code>strb w</code><span class="codeitalic">s</span>, <code>[x</code><span class="codeitalic">b</span><code>{,</code> <span class="codeitalic">offset</span><code>}]</code> stores the low-order 8 bits in <code>w</code><span class="codeitalic">s</span> at the memory location obtained by adding the address in <code>x</code><span class="codeitalic">b</span> and the optional <span class="codeitalic">offset</span>, which is in the range 0 to 4,095.</p>&#13;
<p class="indenttL">The program simply adds 1 to the variable, which can be done with the <code>add</code> instruction. I’ll include the <code>sub</code> instruction here because it’s very similar, <span epub:type="pagebreak" id="page_218"/>but I’ll give only some basic syntax (both instructions have several options, which are described in the manuals):</p>&#13;
<p class="noindenttL"><span class="codestrong">add</span><strong>—Add extended register</strong></p>&#13;
<p class="hang"><code>add w</code><span class="codeitalic">d</span>, <code>w</code><span class="codeitalic">s1</span>, <code>w</code><span class="codeitalic">s2</span><code>{,</code> <span class="codeitalic">xtnd amnt</span><code>}</code> adds the values in <code>w</code><span class="codeitalic">s1</span> and <code>w</code><span class="codeitalic">s2</span> and stores the result in <code>w</code><span class="codeitalic">d</span>. The value added from <code>w</code><span class="codeitalic">s2</span> can be a byte, halfword, word, or doubleword. It can be sign- or zero-extended and then left-shifted 0 to 4 bits before the addition, using the <span class="codeitalic">xtnd amnt</span> option.</p>&#13;
<p class="hang"><code>add x</code><span class="codeitalic">d</span>, <code>x</code><span class="codeitalic">s1</span>, <code>x</code><span class="codeitalic">s2</span><code>{,</code> <span class="codeitalic">xtnd amnt</span><code>}</code> adds the values in <code>x</code><span class="codeitalic">s1</span> and <code>x</code><span class="codeitalic">s2</span> and stores the result in <code>x</code><span class="codeitalic">d</span>. The value added from <code>x</code><span class="codeitalic">s2</span> can be a byte, halfword, word, or doubleword. It can be sign- or zero-extended and then left-shifted 0 to 4 bits before the addition, using the <span class="codeitalic">xtnd amnt</span> option.</p>&#13;
<p class="noindentt"><span class="codestrong">add</span><strong>—Add immediate</strong></p>&#13;
<p class="hang"><code>add w</code><span class="codeitalic">d</span>, <code>w</code><span class="codeitalic">s</span><code>,</code> <span class="codeitalic">imm</span><code>{,</code> <span class="codeitalic">shft</span><code>}</code> adds <span class="codeitalic">imm</span> to the value in <code>w</code><span class="codeitalic">s</span> and stores the result in <code>w</code><span class="codeitalic">d</span>. The <span class="codeitalic">imm</span> operand is an unsigned integer in the range 0 to 4,095, which can be left-shifted 0 or 12 bits before the addition, using the <span class="codeitalic">shft</span> option.</p>&#13;
<p class="hang"><code>add x</code><span class="codeitalic">d</span>, <code>x</code><span class="codeitalic">s</span><code>,</code> <span class="codeitalic">imm</span><code>{,</code> <span class="codeitalic">shft</span><code>}</code> adds <span class="codeitalic">imm</span> to the value in <code>x</code><span class="codeitalic">s</span> and stores the result in <code>x</code><span class="codeitalic">d</span>. The <span class="codeitalic">imm</span> operand is an unsigned integer in the range 0 to 4,095, which can be left-shifted 0 or 12 bits before the addition, using the <span class="codeitalic">shft</span> option.</p>&#13;
<p class="noindentt"><span class="codestrong">sub</span><strong>—Subtract extended register</strong></p>&#13;
<p class="hang"><code>sub w</code><span class="codeitalic">d</span>, <code>w</code><span class="codeitalic">s1</span>, <code>w</code><span class="codeitalic">s2</span><code>{,</code> <span class="codeitalic">xtnd amnt</span><code>}</code> subtracts the value in <code>w</code><span class="codeitalic">s2</span> from <code>w</code><span class="codeitalic">s1</span> and stores the result in <code>w</code><span class="codeitalic">d</span>. The value subtracted from <code>w</code><span class="codeitalic">s2</span> can be a byte, halfword, word, or doubleword. It can be sign- or zero-extended and then left-shifted 0 to 4 bits before the subtraction, using the <span class="codeitalic">xtnd amnt</span> option.</p>&#13;
<p class="hang"><code>sub x</code><span class="codeitalic">d</span>, <code>x</code><span class="codeitalic">s1</span>, <code>x</code><span class="codeitalic">s2</span><code>{,</code> <span class="codeitalic">xtnd amnt</span><code>}</code> subtracts the value in <code>x</code><span class="codeitalic">s2</span> from <code>x</code><span class="codeitalic">s1</span> and stores the result in <code>x</code><span class="codeitalic">d</span>. The value subtracted from <code>x</code><span class="codeitalic">s2</span> can be a byte, halfword, word, or doubleword. It can be sign- or zero-extended and then left-shifted 0 to 4 bits before the subtraction, using the <span class="codeitalic">xtnd amnt</span> option.</p>&#13;
<p class="noindentt"><span class="codestrong">sub</span><strong>—Subtract immediate</strong></p>&#13;
<p class="hang"><code>sub w</code><span class="codeitalic">d</span>, <code>w</code><span class="codeitalic">s</span><code>,</code> <span class="codeitalic">imm</span><code>{,</code> <span class="codeitalic">shft</span><code>}</code> subtracts <span class="codeitalic">imm</span> from the value in <code>w</code><span class="codeitalic">s</span> and stores the result in <code>w</code><span class="codeitalic">d</span>. The <span class="codeitalic">imm</span> operand is an unsigned integer in the range 0 to 4,095, which can be left-shifted 0 or 12 bits before the subtraction, using the <span class="codeitalic">shft</span> option.</p>&#13;
<p class="hang"><code>sub x</code><span class="codeitalic">d</span>, <code>x</code><span class="codeitalic">s</span><code>,</code> <span class="codeitalic">imm</span><code>{,</code> <span class="codeitalic">shft</span><code>}</code> subtracts <span class="codeitalic">imm</span> from the value in <code>x</code><span class="codeitalic">s</span> and stores the result in <code>x</code><span class="codeitalic">d</span>. The <span class="codeitalic">imm</span> operand is an unsigned integer in the range 0 to 4,095, which can be left-shifted 0 or 12 bits before the subtraction, using the <span class="codeitalic">shft</span> option.</p>&#13;
<p class="indenttL"><span epub:type="pagebreak" id="page_219"/><a href="ch11.xhtml#ch11tab2">Table 11-2</a> lists the allowable values for the <span class="codeitalic">xtnd</span> option in the <code>add</code> and <code>sub</code> instructions.</p>&#13;
<p class="tabcap" id="ch11tab2"><strong>Table 11-2:</strong> Allowable Values for <span class="codeitalic">xtnd</span> in <code>add</code> and <code>sub</code> Instructions</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><span class="codestrongitalic">xtnd</span></th>&#13;
<th class="tab_th"><strong>Effect</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><code>uxtb</code></td>&#13;
<td class="bg1">Unsigned extension of byte</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>uxth</code></td>&#13;
<td class="bg">Unsigned extension of halfword</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>uxtw</code></td>&#13;
<td class="bg1">Unsigned extension of word</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>uxtx</code></td>&#13;
<td class="bg">Unsigned extension of doubleword</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>sxtb</code></td>&#13;
<td class="bg1">Signed extension of byte</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>sxth</code></td>&#13;
<td class="bg">Signed extension of halfword</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>sxtw</code></td>&#13;
<td class="bg1">Signed extension of word</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>sxtx</code></td>&#13;
<td class="bg">Signed extension of doubleword</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The extension begins with the indicated low-order portion of the source register and adds bits to the left to match the width of the other registers in the instruction. For unsigned extension, the added bits are all <code>0</code>. For signed extension, the added bits are copies of the highest-order bit of the starting value. When using <code>w</code> registers, <code>uxtw</code> can be replaced with <code>lsl</code>; with <code>x</code> registers, <code>uxtx</code> can be replaced with <code>lsl</code>.</p>&#13;
<p class="indent">It might seem meaningless to extend a doubleword, which is already 64 bits wide, to match the size of an <code>x</code> register, but the instruction syntax requires that we use the entire <span class="codeitalic">xtnd amnt</span> option if we wish to shift the value.</p>&#13;
<p class="indent">As an example of how these size extensions work, let’s start with the following values in <code>x2</code> and <code>x3</code>:</p>&#13;
<pre class="pre">x2: 0xaaaaaaaaaaaaaaaa&#13;
x3: 0x89abba89fedccdef</pre>&#13;
<p class="noindent">The instruction sequence</p>&#13;
<pre class="pre">add    w0, w3, w2, uxtb&#13;
add    w1, w3, w2, sxtb</pre>&#13;
<p class="noindent">gives:</p>&#13;
<pre class="pre">x0: 0xfedcce99&#13;
x3: 0xfedccd99</pre>&#13;
<p class="noindent">We’ll see other instructions that use these width extensions as we continue through the book.</p>&#13;
<p class="indent">Now that you know how to do the arithmetic, let’s look at how to call the other functions.</p>&#13;
<h3 class="h3" id="ch11lev1sec3"><span epub:type="pagebreak" id="page_220"/><strong>Passing Arguments in Registers</strong></h3>&#13;
<p class="noindent">There are several ways for a function to pass arguments to another function. I’ll start by describing how to use registers for passing arguments. I’ll discuss other ways when I cover subfunctions in more detail in <a href="ch14.xhtml">Chapter 14</a>.</p>&#13;
<p class="indent">Recall from <a href="ch02.xhtml">Chapter 2</a> that when a function calls another function, it can pass arguments that the called function can use as parameters. In principle, the C compiler—or you, when you’re writing in assembly language—could use any of the 31 general-purpose registers, except the link register, <code>x30</code>, to pass arguments from one function to another. Just store the arguments in the registers and call the desired function. Of course, the calling and called functions need to agree on exactly which register each argument is in.</p>&#13;
<p class="indent">The best way to avoid making mistakes is to follow a standard set of rules. This is especially important if more than one person is writing code for a program. Other people have realized the importance of having such standards and have developed an <em>application binary interface (ABI)</em> that includes a set of standards for passing arguments in the A64 architecture. The compiler we’re using, <code>gcc</code>, follows the rules in the <em>Procedure Call Standard for the Arm 64-Bit Architecture</em> (referenced on <a href="ch11.xhtml#commonL3">page 213</a>), and we’ll do the same for the assembly language we write.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11tab3">Table 11-3</a> summarizes the standards for how the called function uses the registers.</p>&#13;
<p class="tabcap" id="ch11tab3"><strong>Table 11-3:</strong> General-Purpose Register Usage</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:45%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Register</strong></th>&#13;
<th class="tab_th"><strong>Usage</strong></th>&#13;
<th class="tab_th"><strong>Save?</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><code>x0</code>–<code>x7</code></td>&#13;
<td class="bg1">Parameter; result</td>&#13;
<td class="bg1">No</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>x8</code></td>&#13;
<td class="bg">Address of result</td>&#13;
<td class="bg">No</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>x9</code>–<code>x18</code></td>&#13;
<td class="bg1">Scratch</td>&#13;
<td class="bg1">No</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>x19</code>–<code>x28</code></td>&#13;
<td class="bg">Variables</td>&#13;
<td class="bg">Yes</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>x29</code></td>&#13;
<td class="bg1">Frame pointer</td>&#13;
<td class="bg1">Yes</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>x30</code></td>&#13;
<td class="bg">Link register</td>&#13;
<td class="bg">Yes</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><code>sp</code></td>&#13;
<td class="bg1">Stack pointer</td>&#13;
<td class="bg1">Yes</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><code>xzr</code></td>&#13;
<td class="bg">Zero register</td>&#13;
<td class="bg">N/A</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">We would use <code>w</code><span class="codeitalic">n</span> instead of <code>x</code><span class="codeitalic">n</span> for 32-bit register names. We’re using 64-bit addressing in this book. Because <code>x29</code> and <code>x30</code> will always contain addresses, we’ll never use <code>w29</code> or <code>w30</code>.</p>&#13;
<p class="indent">The “Save?” column shows whether a called function needs to preserve the value in that register for the calling function. If we need to use a register that must be preserved, we’ll create a local variable in our stack frame for that purpose.</p>&#13;
<p class="indent">The calling function passes the arguments in the registers in the order in which they’re listed, from left to right in a C function, starting with <code>x0</code> (or <code>w0</code> for a 32-bit value). This allows for the passing of up to eight arguments, <span epub:type="pagebreak" id="page_221"/><code>x0</code>–<code>x7</code>. You’ll see how to use the call stack to pass more than eight arguments in <a href="ch14.xhtml">Chapter 14</a>.</p>&#13;
<p class="indent"><a id="commonL2"/>For an example of how to pass arguments, let’s look at the call to <code>scanf</code> in <a href="ch11.xhtml#ch11list1">Listing 11-1</a>:</p>&#13;
<pre class="pre">scanf("%i", &amp;x);</pre>&#13;
<p class="indent">Let’s start with the second argument, the address of <code>x</code>. In <a href="ch11.xhtml#ch11fig4">Figure 11-4</a>, <code>x</code> is located at an offset of 28 bytes from the stack pointer, <code>sp</code>. Looking at the assembly language generated by the compiler in <a href="ch11.xhtml#ch11list2">Listing 11-2</a>, you can see that computing the address can be done by adding 28 to <code>sp</code> <span class="ent">❹</span>. Since it’s the second argument, it needs to be moved to <code>x1</code>.</p>&#13;
<p class="indent">The first argument—the text string <code>"%i"</code>, which is created with a <code>.string</code> assembler directive <span class="ent">❷</span>—is more complex. The general format for the <code>.string</code> directive is:</p>&#13;
<pre class="pre">.string "<span class="codeitalic1">text</span>"</pre>&#13;
<p class="noindent">This creates a C-style text string as a <code>char</code> array with one byte for each character code point in <span class="codeitalic">text</span>, plus one byte for the terminating <code>NUL</code> character.</p>&#13;
<p class="indent">The compiler places the three text strings in this program in the <code>.rodata</code> section <span class="ent">❶</span> of the object file. The loader/linker typically loads <code>.rodata</code> sections into the <code>text</code> segment following the executable code. Notice that each text string is aligned to an 8-byte (64 bits) address boundary with a <code>.align 3</code> directive. This might make the code execute a little faster.</p>&#13;
<p class="indent">When you pass an array to a function in C, only the address of the first element in the array gets passed. So, the address of the first character of <code>"%i"</code> is passed to <code>scanf</code>. The A64 architecture provides two instructions for getting an address into a register:</p>&#13;
<p class="noindenttL"><span class="codestrong">adr</span><strong>—Address</strong></p>&#13;
<p class="hang"><code>adr x</code><span class="codeitalic">d</span><code>,</code> <span class="codeitalic">addr</span> loads the memory address <span class="codeitalic">addr</span> into <code>x</code><span class="codeitalic">d</span>; <span class="codeitalic">addr</span> must be within ±1MB of this instruction.</p>&#13;
<p class="noindentt"><span class="codestrong">adrp</span><strong>—Address page</strong></p>&#13;
<p class="hang"><code>adrp x</code><span class="codeitalic">d</span><code>,</code> <span class="codeitalic">addr</span> loads the page address of <span class="codeitalic">addr</span> into bits 63 to 12 of <code>x</code><span class="codeitalic">d</span>, with bits 11 to 0 set to <code>0</code>. The page address is the next-lower 4KB address boundary of <span class="codeitalic">addr</span>, and <span class="codeitalic">addr</span> must be within ±4GB of this instruction.</p>&#13;
<p class="indenttL">Both instructions use the literal addressing mode (see <a href="ch11.xhtml#ch11tab1">Table 11-1</a>) to refer to a memory address. They each allow a 21-bit offset value, hence the ±1MB range for <code>adr</code>. With <code>0</code>s in the low-order 12 bits, the <code>adrp</code> instruction gives a 33-bit offset from the <code>pc</code>, for an addressing range of ±4GB from the <code>pc</code>, but with 4KB granularity.</p>&#13;
<p class="indent">The <code>adrp</code> instruction effectively treats memory as being divided into 4KB <em>pages</em>. (These pages are conceptually distinct from the memory pages that the operating system uses to manage main memory.) It loads the beginning address of a 4KB page, the <em>page address</em>, into the destination register. Compared to the <code>adr</code> instruction, this increases the range of addresses we can <span epub:type="pagebreak" id="page_222"/>load into a register from ±1MB to ±4GB, but we still need to add the offset within the 4KB page to the page address in the register.</p>&#13;
<p class="indent">Thus, we can load a 64-bit address located within ±4GB with a two-instruction sequence. The compiler did this in <a href="ch11.xhtml#ch11list2">Listing 11-2</a> using the following code <span class="ent">❺</span>:</p>&#13;
<pre class="pre">adrp    x0, .LC1&#13;
add     x0, x0, :lo12:.LC1</pre>&#13;
<p class="indent">Since the label <code>.LC1</code> is in the <code>.rodata</code> section, the linker computes the offset from the instruction to the label. The <code>adrp</code> instruction loads the page number of that offset into <code>x0</code>. The <code>:lo12:</code> modifier tells the assembler to use only the low-order 12 bits of the offset as the immediate value for the <code>add</code> instruction. This two-step process may seem a bit puzzling to you. It’s due to the limited number of bits available for immediate values in an instruction; you’ll see the details when we cover how instructions are coded in binary in <a href="ch12.xhtml">Chapter 12</a>.</p>&#13;
<p class="indent">After loading the arguments into registers, we transfer the program flow to the other function with a <code>bl</code> or a <code>blr</code> instruction:</p>&#13;
<p class="noindenttL"><span class="codestrong">bl</span><strong>—Branch and link</strong></p>&#13;
<p class="hang"><code>bl</code> <span class="codeitalic">addr</span> adds 4 to the address in the <code>pc</code> and loads the sum into <code>x30</code>. It then loads the memory address of <span class="codeitalic">addr</span> into the <code>pc</code>, thus branching to <span class="codeitalic">addr</span>, which must be within ±128MB of this instruction.</p>&#13;
<p class="noindentt"><span class="codestrong">blr</span><strong>—Branch and link, register</strong></p>&#13;
<p class="hang"><code>blr x</code><span class="codeitalic">s</span> adds 4 to the address in the <code>pc</code> and loads the sum into <code>x30</code>. It then moves the 64-bit address in <code>x</code><span class="codeitalic">s</span> to the <code>pc</code>, thus branching to that address.</p>&#13;
<p class="indenttL">These instructions are used to call a function. Adding 4 to the address in the <code>pc</code> gives the address of the instruction immediately after the <code>bl</code> or <code>blr</code> in memory. We usually want the called function to return to this location. The <code>x30</code> register is used as a link register by these two branching instructions.</p>&#13;
<p class="indent">In the next section, we’ll write the program in assembly language. It’ll be very similar to what the compiler generated, but we’ll use names that make it easier to read.</p>&#13;
<h3 class="h3" id="ch11lev1sec4"><strong>Writing main in Assembly Language</strong></h3>&#13;
<p class="noindent"><a href="ch11.xhtml#ch11list3">Listing 11-3</a> shows my assembly language version of the <code>inc_int</code> program. It closely follows the assembly language generated from the C version by the compiler in <a href="ch11.xhtml#ch11list2">Listing 11-2</a>, but I’ve added comments and used more meaningful labels for the string constants. This should make it a little easier to understand how the program uses the stack and passes arguments to other functions.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>inc_int.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Increment an integer.&#13;
        .arch armv8-a&#13;
// Stack frame&#13;
     <span class="ent">➊</span> .equ    x, 28<span epub:type="pagebreak" id="page_223"/>&#13;
     <span class="ent">➋</span> .equ    FRAME, 32&#13;
// Constant data&#13;
     <span class="ent">➌</span> .section .rodata&#13;
prompt:&#13;
        .string "Enter an integer: "&#13;
input_format:&#13;
        .string "%i"&#13;
result:&#13;
        .string "Result: %i\n"&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
     <span class="ent">➍</span> stp     fp, lr, [sp, FRAME]!  // Create stack frame&#13;
        mov     fp, sp                // Set our frame pointer&#13;
 &#13;
        adr     x0, prompt            // Prompt user&#13;
        bl      printf&#13;
        add     x1, sp, x             // Address for input&#13;
        adr     x0, input_format      // scanf format string&#13;
     <span class="ent">➎</span> bl      scanf&#13;
 &#13;
        ldr     w0, [sp, x]           // Get x&#13;
        add     w1, w0, 1             // Add 1&#13;
        str     w1, [sp, x]           // x++&#13;
 &#13;
        adr     x0, result            // printf format string&#13;
        bl      printf                // Result is in w1&#13;
 &#13;
        mov     w0, wzr&#13;
     <span class="ent">➏</span> ldp     fp, lr, [sp], FRAME   // Delete stack frame&#13;
        ret</pre>&#13;
<p class="list" id="ch11list3"><em>Listing 11-3: A program to increment an integer, in assembly language</em></p>&#13;
<p class="indent">We see another assembler directive, <code>.equ</code>, in <a href="ch11.xhtml#ch11list3">Listing 11-3</a>. The format is:</p>&#13;
<pre class="pre">.equ <span class="codeitalic1">symbol</span>, <span class="codeitalic1">expression</span></pre>&#13;
<p class="noindent">The <span class="codeitalic">expression</span> must evaluate to an integer, and the assembler sets <span class="codeitalic">symbol</span> equal to that value. You can then use the symbol in your code, making it much easier to read, and the assembler will plug in the value of the expression. The expression is often just an integer. For example, I have equated the symbol <code>FRAME</code> to the integer 32 <span class="ent">❷</span>. This allows us to write code that is self-documenting <span class="ent">❹</span>. I’ve also used the assembler names, <code>fp</code> and <code>lr</code>, for the register names <code>x29</code> and <code>x30</code>, respectively.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_224"/>Note that we don’t need to specify the <code>.text</code> segment for the <code>.rodata</code> section <span class="ent">❸</span>. The assembler and linker produce a <code>.rodata</code> section, and it’s up to the operating system to determine where to load it. I didn’t align the text strings in the <code>.rodata</code> section either. Although alignment might make the code execute a little faster, it could waste a few bytes of memory. (Both factors are irrelevant for the programming we’re doing in this book.) I’ve also used <code>adr</code> instead of <code>adrp</code> to load the addresses of the strings. The programs we’ll be writing in this book are very simple, so I expect the strings in the  <code>.rodata</code> section to be within ±1MB of the instructions that use them.</p>&#13;
<p class="indent">Finally, I’ve called <code>scanf</code> instead of <code>__isoc99_scanf</code> <span class="ent">❺</span>. The <code>__isoc99_</code> prefix disallows several nonstandard conversion specifiers; again, this is beyond the scope of this book.</p>&#13;
<p class="indent">Our variable, <code>x</code>, is in the stack frame <span class="ent">❶</span>. The stack frame is created in the function prologue <span class="ent">❹</span> and deleted in the function epilogue <span class="ent">❻</span>, making <code>x</code> an automatic local variable.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch11exe1">11.1     You can tell the <code>gcc</code> compiler to optimize the code it generates for speed with the <code>-Ofast</code> option or for size with the <code>-Os</code> option. Generate the assembly language for the program in <a href="ch11.xhtml#ch11list1">Listing 11-1</a> for each option. What are the differences?</p>&#13;
<p class="box-list1" id="ch11exe2">11.2     Modify the program in <a href="ch11.xhtml#ch11list3">Listing 11-3</a> so that it inputs two integers and then displays the sum and difference of the two.</p>&#13;
<p class="box-list1" id="ch11exe3">11.3     Enter the following C code in a file named <em>sum_diff.c</em>:</p>&#13;
<pre class="pre2Laa">// Add and subtract two integers.&#13;
 &#13;
void sum_diff(int x, int y, int *sum, int *diff)&#13;
{&#13;
    *sum = x + y;&#13;
    *diff = x - y;&#13;
}</pre>&#13;
<p class="box-listpL">Modify the program in <a href="ch11.xhtml#ch11list3">Listing 11-3</a> so that it inputs two integers, calls <code>sum_diff</code> to compute the sum and difference of the two integers, and then displays the two results.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch11lev1sec5"><strong>What You’ve Learned</strong></h3>&#13;
<div class="indL">&#13;
<p class="noindentin"><strong>Call stack</strong> An area of memory used for storing program data and addresses that grows and shrinks as needed.</p>&#13;
<p class="noindentin"><strong>Stack frame</strong> Memory on the call stack used for saving the return address and caller’s frame pointer, as well as for creating local variables.</p>&#13;
<p class="noindentin"><strong>Function prologue</strong> The instructions that create a stack frame.</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_225"/><strong>Function epilogue</strong> The instructions that restore the caller’s link register and frame pointer and delete the stack frame.</p>&#13;
<p class="noindentin"><strong>Automatic local variables</strong> Variables created anew each time a function is called. They can easily be created on the call stack.</p>&#13;
<p class="noindentin"><strong>Passing arguments to a subfunction</strong> Up to eight arguments are passed in the <code>x0</code>–<code>x7</code> registers.</p>&#13;
<p class="noindentin"><strong>Calling a function</strong> The branch and link instructions, <code>bl</code> and <code>blr</code>, transfer program flow to a function, storing the return address in <code>x30</code>.</p>&#13;
<p class="noindentin"><strong>A64 addressing</strong> There are several modes for generating a 64-bit address with a 32-bit instruction.</p>&#13;
<p class="noindentin"><strong>Position-independent executable</strong> The operating system can load the program anywhere in memory, and it will execute correctly.</p>&#13;
<p class="noindentin"><strong>Load–store architecture</strong> Instructions can operate only on data that is in registers.</p>&#13;
</div>&#13;
<p class="indent">In the next chapter, we’ll take a brief look at how instructions are coded in machine language. This will help you understand the reasons for some of the limitations of instructions, such as the size of offset when referring to a memory address.<span epub:type="pagebreak" id="page_226"/></p>&#13;
</div>
</div>
</body></html>