<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Method Lookup and Constant Lookup"><div class="titlepage"><div><div><h1 class="title"><a id="method_lookup_and_constant_lookup"/>Chapter 6. Method Lookup and Constant Lookup</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="informalfigure"><div class="mediaobject"><a id="med_id00132"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1853819.png.jpg"/></div></div><p><span class="emphasis"><em>Inside of Ruby, modules are classes.</em></span></p></blockquote></div><p><a class="indexterm" id="iddle1136"/><a class="indexterm" id="iddle1738"/>As we saw in <a class="xref" href="ch05.html" title="Chapter 5. Objects and Classes">Chapter 5</a>, classes play an important role in Ruby, holding method definitions and constant values, among other things. We also learned how Ruby implements inheritance using the <code class="literal">super</code> pointer in each <code class="literal">RClass</code> structure.</p><p>In fact, as your program grows, you might imagine it organized by class and superclass, creating a kind of giant tree structure. At the base is the <code class="literal">Object</code> class (or, actually, the internal <code class="literal">BasicObject</code> class). This class is Ruby’s default superclass, and all of your classes appear somewhere higher up in the tree, branching out in different directions. In this chapter we’ll study how Ruby uses this superclass tree to look up methods. When you write code that calls a method, Ruby looks through this tree in a very precise manner. We’ll step through a concrete example to see the method lookup process in action.</p><p>Later in this chapter we’ll learn another way to visualize your Ruby code. Every time you create a new class or module, Ruby adds a new scope to a different tree, a tree based on the syntactical structure of your program. The trunk of this tree is the top-level scope, or the beginning of your Ruby code file where you start typing. As you define more and more highly nested modules and classes, this tree would grow higher and higher as well. We’ll learn how this syntax, or namespace, tree allows Ruby to find constant definitions, just as the superclass tree allows Ruby to find methods.</p><p>But before we get to method and constant lookup, let’s get started with a look at Ruby modules. What are modules? How are they different from classes? What happens when you include a module into a class?</p><div class="sidebar"><a id="roadmap-id00018"/><p class="title">Roadmap</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch06.html#how_ruby_implements_modules" title="How Ruby Implements Modules">How Ruby Implements Modules</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch06.html#modules_are_classes" title="Modules Are Classes">Modules Are Classes</a></p></li><li class="listitem"><p><a class="xref" href="ch06.html#including_a_module_into_a_class" title="Including a Module into a Class">Including a Module into a Class</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch06.html#rubyapostrophes_method_lookup_algorithm" title="Ruby’s Method Lookup Algorithm">Ruby’s Method Lookup Algorithm</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch06.html#method_lookup_example" title="A Method Lookup Example">A Method Lookup Example</a></p></li><li class="listitem"><p><a class="xref" href="ch06.html#method_lookup_algorithm_in_action" title="The Method Lookup Algorithm in Action">The Method Lookup Algorithm in Action</a></p></li><li class="listitem"><p><a class="xref" href="ch06.html#multiple_inheritance_in_ruby" title="Multiple Inheritance in Ruby">Multiple Inheritance in Ruby</a></p></li><li class="listitem"><p><a class="xref" href="ch06.html#global_method_cache" title="The Global Method Cache">The Global Method Cache</a></p></li><li class="listitem"><p><a class="xref" href="ch06.html#inline_method_cache" title="The Inline Method Cache">The Inline Method Cache</a></p></li><li class="listitem"><p><a class="xref" href="ch06.html#clearing_rubyapostrophes_method_caches" title="Clearing Ruby’s Method Caches">Clearing Ruby’s Method Caches</a></p></li><li class="listitem"><p><a class="xref" href="ch06.html#including_two_modules_into_one_class" title="Including Two Modules into One Class">Including Two Modules into One Class</a></p></li><li class="listitem"><p><a class="xref" href="ch06.html#including_one_module_into_another" title="Including One Module into Another">Including One Module into Another</a></p></li><li class="listitem"><p><a class="xref" href="ch06.html#modulehashprepend_example" title="A Module#prepend Example">A Module#prepend Example</a></p></li><li class="listitem"><p><a class="xref" href="ch06.html#how_ruby_implements_modulehashprepend" title="How Ruby Implements Module#prepend">How Ruby Implements Module#prepend</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch06.html#experiment_6-1_modifying_a_module_after" title="Experiment 6-1: Modifying a Module After Including It">Experiment 6-1: Modifying a Module After Including It</a></strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch06.html#classes_see_methods_added_to_a_module_la" title="Classes See Methods Added to a Module Later">Classes See Methods Added to a Module Later</a></p></li><li class="listitem"><p><a class="xref" href="ch06.html#classes_donapostrophet_see_submodules_in" title="Classes Don’t See Submodules Included Later">Classes Don’t See Submodules Included Later</a></p></li><li class="listitem"><p><a class="xref" href="ch06.html#included_classes_share_the_method_table" title="Included Classes Share the Method Table with the Original Module">Included Classes Share the Method Table with the Original Module</a></p></li><li class="listitem"><p><a class="xref" href="ch06.html#close_look_at_how_ruby_copies_modules" title="A Close Look at How Ruby Copies Modules">A Close Look at How Ruby Copies Modules</a></p></li></ul></div></li><li class="listitem"><p><a class="indexterm" id="iddle1407"/><a class="indexterm" id="iddle1696"/><a class="xref" href="ch06.html#constant_lookup" title="Constant Lookup">Constant Lookup</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch06.html#finding_a_constant_in_a_superclass" title="Finding a Constant in a Superclass">Finding a Constant in a Superclass</a></p></li><li class="listitem"><p><a class="xref" href="ch06.html#how_does_ruby_find_a_constant_in_the_par" title="How Does Ruby Find a Constant in the Parent Namespace?">How Does Ruby Find a Constant in the Parent Namespace?</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch06.html#lexical_scope_in_ruby" title="Lexical Scope in Ruby">Lexical Scope in Ruby</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch06.html#creating_a_constant_for_a_new_class_or_m" title="Creating a Constant for a New Class or Module">Creating a Constant for a New Class or Module</a></p></li><li class="listitem"><p><a class="xref" href="ch06.html#finding_a_constant_in_the_parent_namespa" title="Finding a Constant in the Parent Namespace Using Lexical Scope">Finding a Constant in the Parent Namespace Using Lexical Scope</a></p></li><li class="listitem"><p><a class="xref" href="ch06.html#rubyapostrophes_constant_lookup_algorith" title="Ruby’s Constant Lookup Algorithm">Ruby’s Constant Lookup Algorithm</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch06.html#experiment_6-2_which_constant_will_ruby" title="Experiment 6-2: Which Constant Will Ruby Find First?">Experiment 6-2: Which Constant Will Ruby Find First?</a></strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch06.html#rubyapostrophes_actual_constant_lookup_a" title="Ruby’s Actual Constant Lookup Algorithm">Ruby’s Actual Constant Lookup Algorithm</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch06.html#summary-id00023" title="Summary">Summary</a></p></li></ul></div></div><div class="sect1" title="How Ruby Implements Modules"><div class="titlepage"><div><div><h1 class="title"><a id="how_ruby_implements_modules"/>How Ruby Implements Modules</h1></div></div></div><p>As you may know, modules are very similar to classes in Ruby. You can create a module just as you create a class—by typing the <code class="literal">module</code> keyword followed by a series of method definitions. But while modules are similar to classes, they are handled differently by Ruby in three important ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Ruby doesn’t allow you to create objects directly from modules. In practice this means that you can’t call the <code class="literal">new</code> method on a module because <code class="literal">new</code> is a method of <code class="literal">Class</code>, not of <code class="literal">Module</code>.</p></li><li class="listitem"><p>Ruby doesn’t allow you to specify a superclass for a module.</p></li><li class="listitem"><p>In addition, you can include a module into a class using the <code class="literal">include</code> keyword.</p></li></ul></div><p>But what are modules exactly? How does Ruby represent them internally? Does it use an <code class="literal">RModule</code> structure? And what does it mean to “include” a module into a class?</p><div class="sect2" title="Modules Are Classes"><div class="titlepage"><div><div><h2 class="title"><a id="modules_are_classes"/>Modules Are Classes</h2></div></div></div><p>As it turns out, internally Ruby implements modules as classes. When you create a module, Ruby creates another <code class="literal">RClass</code>/<code class="literal">rb_classext_struct</code> structure pair, just as it would for a new class. For example, suppose we define a new module like this.</p><a id="pro_id00032"/><pre class="programlisting">module Professor
end</pre><p>Internally, Ruby would create a class, not a module! <a class="xref" href="ch06.html#portion_of_rubyapostrophes_class_str" title="Figure 6-1. The portion of Ruby’s class structures that’s used for modules">Figure 6-1</a> shows how Ruby represents a module internally.</p><div class="figure"><a id="portion_of_rubyapostrophes_class_str"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00133"/><img alt="The portion of Ruby’s class structures that’s used for modules" src="httpatomoreillycomsourcenostarchimages1854087.png.jpg"/></div></div><p class="title">Figure 6-1. The portion of Ruby’s class structures that’s used for modules</p></div><p><a class="indexterm" id="iddle1412"/><a class="indexterm" id="iddle1414"/><a class="indexterm" id="iddle1637"/><a class="indexterm" id="iddle1697"/>In this figure I show Ruby’s <code class="literal">RClass</code> structure again. However, I’ve removed some of the values from the diagram because modules don’t use all of them. Most importantly, I removed <code class="literal">iv_index_tbl</code> because you can’t create object instances of a module—in other words, you can’t call the <code class="literal">new</code> method on a module. This means there are no object-level attributes to keep track of. I also removed the <code class="literal">refined_class</code> and <code class="literal">allocator</code> values because modules don’t use them either. I’ve left the <code class="literal">super</code> pointer because modules do have superclasses internally even though you aren’t allowed to specify them yourself.</p><p>A technical definition of a Ruby module (ignoring the <code class="literal">origin</code> value for now) might look like this:</p><div class="blockquote"><blockquote class="blockquote"><p>A Ruby module is a Ruby object that also contains method definitions, a superclass pointer, and a constants table.</p></blockquote></div></div><div class="sect2" title="Including a Module into a Class"><div class="titlepage"><div><div><h2 class="title"><a id="including_a_module_into_a_class"/>Including a Module into a Class</h2></div></div></div><p>The real magic behind modules happens when you include a module into a class, as shown in <a class="xref" href="ch06.html#including_a_module_into_a_class-id00019" title="Example 6-1. Including a module into a class">Example 6-1</a>.</p><div class="example"><a id="including_a_module_into_a_class-id00019"/><p class="title">Example 6-1. Including a module into a class</p><div class="example-contents"><pre class="programlisting">module Professor
end

class Mathematician &lt; Person
  include Professor
end</pre></div></div><p><a class="indexterm" id="iddle1129"/><a class="indexterm" id="iddle1410"/>When we run <a class="xref" href="ch06.html#including_a_module_into_a_class-id00019" title="Example 6-1. Including a module into a class">Example 6-1</a>, Ruby creates a copy of the <code class="literal">RClass</code> structure for the <code class="literal">Professor</code> module and uses it as the new superclass for <code class="literal">Mathematician</code>. Ruby’s C source code refers to this copy of the module as an <span class="emphasis"><em>included class</em></span>. The superclass of the new copy of <code class="literal">Professor</code> is set to the original superclass of <code class="literal">Mathematician</code>, which preserves the superclass, or ancestor chain. <a class="xref" href="ch06.html#including_a_module_into_a_class-id00020" title="Figure 6-2. Including a module into a class">Figure 6-2</a> summarizes this somewhat confusing state of affairs.</p><div class="figure"><a id="including_a_module_into_a_class-id00020"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00134"/><img alt="Including a module into a class" src="httpatomoreillycomsourcenostarchimages1854089.png.jpg"/></div></div><p class="title">Figure 6-2. Including a module into a class</p></div><p>You can see the <code class="literal">Mathematician</code> class at the top-left corner of <a class="xref" href="ch06.html#including_a_module_into_a_class-id00020" title="Figure 6-2. Including a module into a class">Figure 6-2</a>. Below it and along the left side, you see its superclass chain: <code class="literal">Mathematician</code>’s superclass is <code class="literal">Person</code>, whose superclass is <code class="literal">Another Superclass</code>, and so on. The <code class="literal">super</code> pointer in each <code class="literal">RClass</code> structure (actually, each <code class="literal">rb_classext_struct</code> structure) points down to the next superclass.</p><p>Now to the <code class="literal">Professor</code> module on the right side of <a class="xref" href="ch06.html#including_a_module_into_a_class-id00020" title="Figure 6-2. Including a module into a class">Figure 6-2</a>. When we include this module into the <code class="literal">Mathematician</code> class, Ruby changes the <code class="literal">super</code> pointer of <code class="literal">Mathematician</code> to point to a copy of <code class="literal">Professor</code> and the <code class="literal">super</code> pointer of this copy of <code class="literal">Professor</code> to point to <code class="literal">Person</code>, the original superclass of <code class="literal">Mathematician</code>.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note01"/>Note</h3><p><a class="indexterm" id="iddle1010"/><a class="indexterm" id="iddle1290"/><a class="indexterm" id="iddle1600"/><a class="indexterm" id="iddle1601"/><a class="indexterm" id="iddle1635"/><span class="emphasis"><em>Ruby implements <code class="literal">extend</code> in exactly the same way, except the included class becomes the superclass of the target class’s class, or metaclass. Thus, <code class="literal">extend</code> allows you to add class methods to a class.</em></span></p></div></div></div><div class="sect1" title="Ruby’s Method Lookup Algorithm"><div class="titlepage"><div><div><h1 class="title"><a id="rubyapostrophes_method_lookup_algorithm"/>Ruby’s Method Lookup Algorithm</h1></div></div></div><p>Whenever you call a method, whenever you “send a message to a receiver” to use object-oriented programming jargon, Ruby needs to determine which class implements that method. Sometimes this is obvious: The receiver’s class might implement the target method. However, this isn’t often the case. It might be that some other module or class in your system implements the method. Ruby uses a very precise algorithm to search through the modules and classes in your program in a particular order to find the target method. An understanding of this process is essential for every Ruby developer, so let’s take a close look at it.</p><p>The flowchart in <a class="xref" href="ch06.html#rubyapostrophes_method_lookup_al-id00021" title="Figure 6-3. Ruby’s method lookup algorithm">Figure 6-3</a> gives you a graphical picture of Ruby’s method lookup algorithm.</p><div class="figure"><a id="rubyapostrophes_method_lookup_al-id00021"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00135"/><img alt="Ruby’s method lookup algorithm" src="httpatomoreillycomsourcenostarchimages1854091.png.jpg"/></div></div><p class="title">Figure 6-3. Ruby’s method lookup algorithm</p></div><p>This algorithm is remarkably simple, isn’t it? As you can see, Ruby simply follows the <code class="literal">super</code> pointers until it finds the class or module that contains <a class="indexterm" id="iddle1258"/><a class="indexterm" id="iddle1602"/>the target method. You might imagine that Ruby would have to distinguish between modules and classes using some special logic—that it would have to handle the case where there are multiple included modules, for example. But no, it’s just a simple loop on the <code class="literal">super</code> pointer linked list.</p><div class="sect2" title="A Method Lookup Example"><div class="titlepage"><div><div><h2 class="title"><a id="method_lookup_example"/>A Method Lookup Example</h2></div></div></div><p>In a moment we’ll walk through this algorithm to be sure we understand it thoroughly. But first, let’s set up an example we can use that has a class, a superclass, and a module. This will allow us to see how classes and modules work together inside of Ruby.</p><p><a class="xref" href="ch06.html#simple_ruby_classcomma_repeated_from_l" title="Example 6-2. A simple Ruby class, repeated from Example 5-1">Example 6-2</a> shows the <code class="literal">Mathematician</code> class with the accessor methods <code class="literal">first_name</code> and <code class="literal">last_name</code>.</p><div class="example"><a id="simple_ruby_classcomma_repeated_from_l"/><p class="title">Example 6-2. A simple Ruby class, repeated from <a class="xref" href="ch05.html#simple_ruby_class" title="Example 5-1. A simple Ruby class">Example 5-1</a></p><div class="example-contents"><pre class="programlisting">class Mathematician
  attr_accessor :first_name
  attr_accessor :last_name
end</pre></div></div><p>Now let’s introduce a superclass. In <a class="xref" href="ch06.html#person_is_the_superclass_of_mathematicia" title="Example 6-3. Person is the superclass of Mathematician.">Example 6-3</a>, at <span class="inlinemediaobject"><a id="inline_id00156"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> we set <code class="literal">Person</code> as the superclass of <code class="literal">Mathematician</code>.</p><div class="example"><a id="person_is_the_superclass_of_mathematicia"/><p class="title">Example 6-3. <code class="literal">Person</code> is the superclass of <code class="literal">Mathematician</code>.</p><div class="example-contents"><pre class="programlisting">    class Person
    end

<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> class Mathematician &lt; Person
      attr_accessor :first_name
      attr_accessor :last_name
    end</pre></div></div><p>We’ll move the name attributes to the <code class="literal">Person</code> superclass because not only mathematicians have names. We end up with the code shown in <a class="xref" href="ch06.html#now_the_name_attributes_are_in_the_perso" title="Example 6-4. Now the name attributes are in the Person superclass.">Example 6-4</a>.</p><div class="example"><a id="now_the_name_attributes_are_in_the_perso"/><p class="title">Example 6-4. Now the name attributes are in the <code class="literal">Person</code> superclass.</p><div class="example-contents"><pre class="programlisting">class Person
  attr_accessor :first_name
  attr_accessor :last_name
end

class Mathematician &lt; Person
end</pre></div></div><p>Finally, we’ll include the <code class="literal">Professor</code> module into the <code class="literal">Mathematician</code> class at <span class="inlinemediaobject"><a id="inline_id00158"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>. <a class="xref" href="ch06.html#now_we_have_a_class_that_includes_a_modu" title="Example 6-5. Now we have a class that includes a module and has a superclass.">Example 6-5</a> shows the completed example.</p><div class="example"><a id="now_we_have_a_class_that_includes_a_modu"/><p class="title">Example 6-5. Now we have a class that includes a module and has a superclass.</p><div class="example-contents"><pre class="programlisting">    class Person
      attr_accessor :first_name
      attr_accessor :last_name
    end

    module Professor
      def lectures; end
    end

    class Mathematician &lt; Person
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   include Professor
    end</pre></div></div></div><div class="sect2" title="The Method Lookup Algorithm in Action"><div class="titlepage"><div><div><h2 class="title"><a id="method_lookup_algorithm_in_action"/>The Method Lookup Algorithm in Action</h2></div></div></div><p>Now that we have our example set up, we’re ready to see how Ruby finds a method we call. Every time you call any method in one of your programs, Ruby follows the same process we’re about to see here.</p><p>To kick things off, let’s call a method. Using this code, we create a new mathematician object and set its first name:</p><a id="pro_id00033"/><pre class="programlisting">ramanujan = Mathematician.new
ramanujan.first_name = "Srinivasa"</pre><p>To execute this code, Ruby needs to find the <code class="literal">first_name=</code> method. Where is this method? How does Ruby find it exactly?</p><p>First, Ruby gets the class from the <code class="literal">ramanujan</code> object via the <code class="literal">klass</code> pointer, as shown in <a class="xref" href="ch06.html#ruby_first_looks_for_the_firstunderscore" title="Figure 6-4. Ruby first looks for the first_name= method in the object’s class.">Figure 6-4</a>.</p><div class="figure"><a id="ruby_first_looks_for_the_firstunderscore"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00136"/><img alt="Ruby first looks for the first_name= method in the object’s class." src="httpatomoreillycomsourcenostarchimages1854093.png.jpg"/></div></div><p class="title">Figure 6-4. Ruby first looks for the <code class="literal">first_name=</code> method in the object’s class.</p></div><p>Next, Ruby checks to see whether <code class="literal">Mathematician</code> implements <code class="literal">first_name=</code> directly by looking through its method table, as shown in <a class="xref" href="ch06.html#ruby_first_looks_for_firstunderscorename" title="Figure 6-5. Ruby first looks for first_name= in the class’s method table.">Figure 6-5</a>.</p><div class="figure"><a id="ruby_first_looks_for_firstunderscorename"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00137"/><img alt="Ruby first looks for first_name= in the class’s method table." src="httpatomoreillycomsourcenostarchimages1854095.png.jpg"/></div></div><p class="title">Figure 6-5. Ruby first looks for <code class="literal">first_name=</code> in the class’s method table.</p></div><p><a class="indexterm" id="iddle1418"/><a class="indexterm" id="iddle1711"/>Because we’ve moved all of the methods down into the <code class="literal">Person</code> superclass, the <code class="literal">first_name=</code> method is no longer there. Ruby continues through the algorithm and gets the superclass of <code class="literal">Mathematician</code> using the <code class="literal">super</code> pointer, as shown in <a class="xref" href="ch06.html#superclass_of_mathematician_is_the_c" title="Figure 6-6. The superclass of Mathematician is the copy of the Professor module.">Figure 6-6</a>.</p><div class="figure"><a id="superclass_of_mathematician_is_the_c"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00138"/><img alt="The superclass of Mathematician is the copy of the Professor module." src="httpatomoreillycomsourcenostarchimages1854097.png.jpg"/></div></div><p class="title">Figure 6-6. The superclass of <code class="literal">Mathematician</code> is the copy of the <code class="literal">Professor</code> module.</p></div><p>Remember, this is not the <code class="literal">Person</code> class; it’s the <span class="emphasis"><em>included</em></span> class, which is a copy of the <code class="literal">Professor</code> module. Because it’s a copy, Ruby looks through the method table for <code class="literal">Professor</code>. Recall from <a class="xref" href="ch06.html#now_we_have_a_class_that_includes_a_modu" title="Example 6-5. Now we have a class that includes a module and has a superclass.">Example 6-5</a> that <code class="literal">Professor</code> contains only the single method <code class="literal">lectures</code>. Ruby won’t find the <code class="literal">first_name=</code> method.</p><div class="note" title="Note"><h3 class="title"><a id="ch06note02"/>Note</h3><p><span class="emphasis"><em>Notice that because Ruby inserts modules above the original superclass in the superclass chain, methods in an included module override methods present in a superclass. In this case, if <code class="literal">Professor</code> also had a <code class="literal">first_name=</code> method, Ruby would call it and not the method in <code class="literal">Person</code>.</em></span></p></div><p>Because Ruby doesn’t find <code class="literal">first_name=</code> in <code class="literal">Professor</code>, it continues to iterate over the <code class="literal">super</code> pointers, but this time it uses the <code class="literal">super</code> pointer in <code class="literal">Professor</code>, as shown in <a class="xref" href="ch06.html#person_class_is_the_superclass_of_th" title="Figure 6-7. The Person class is the superclass of the included copy of the Professor module.">Figure 6-7</a>.</p><div class="figure"><a id="person_class_is_the_superclass_of_th"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00139"/><img alt="The Person class is the superclass of the included copy of the Professor module." src="httpatomoreillycomsourcenostarchimages1854099.png.jpg"/></div></div><p class="title">Figure 6-7. The <code class="literal">Person</code> class is the superclass of the included copy of the <code class="literal">Professor</code> module.</p></div><p>Note that the superclass of the <code class="literal">Professor</code> module—or more precisely, the superclass of the included copy of the <code class="literal">Professor</code> module—is the <code class="literal">Person</code> class. This was the original superclass of <code class="literal">Mathematician</code>. Finally, Ruby sees the <code class="literal">first_name=</code> method in the method table for <code class="literal">Person</code>. Because it has identified which class implements <code class="literal">first_name=</code>, Ruby can now call the method using the method dispatch process we learned about in <a class="xref" href="ch04.html" title="Chapter 4. Control Structures and Method Dispatch">Chapter 4</a>.</p></div><div class="sect2" title="Multiple Inheritance in Ruby"><div class="titlepage"><div><div><h2 class="title"><a id="multiple_inheritance_in_ruby"/>Multiple Inheritance in Ruby</h2></div></div></div><p>What is most interesting here is that internally, Ruby implements module inclusion using class inheritance. Essentially, there is no difference between including a module and specifying a superclass. Both procedures make new <a class="indexterm" id="iddle1134"/><a class="indexterm" id="iddle1360"/><a class="indexterm" id="iddle1447"/><a class="indexterm" id="iddle1593"/>methods available to the target class, and both use the class’s <code class="literal">super</code> pointer internally. Including multiple modules into a Ruby class is equivalent to specifying multiple superclasses.</p><p>Still, Ruby keeps things simple by enforcing a single list of ancestors. While including multiple modules does create multiple superclasses internally, Ruby maintains them in a single list. The result? As a Ruby developer, you get the benefits of multiple inheritance (adding new behavior to a class from as many different modules as you would like) while keeping the simplicity of the single inheritance model.</p><p>Ruby benefits from this simplicity as well! By enforcing this single list of superclass ancestors, its method lookup algorithm can be very simple. Whenever you call a method on an object, Ruby simply has to iterate through the superclass linked list until it finds the class or module that contains the target method.</p></div><div class="sect2" title="The Global Method Cache"><div class="titlepage"><div><div><h2 class="title"><a id="global_method_cache"/>The Global Method Cache</h2></div></div></div><p>Depending on the number of superclasses in the chain, method lookup can be time consuming. To alleviate this, Ruby caches the result of a lookup for later use. It records which class or module implemented the method that your code called in two caches: a global method cache and an inline method cache.</p><p>Let’s learn about the global method cache first. Ruby uses the <span class="emphasis"><em>global method cache</em></span> to save a mapping between the receiver and implementer classes, as shown in <a class="xref" href="ch06.html#example_of_what_the_global_method_cac" title="Table 6-1. An Example of What the Global Method Cache Might Contain">Table 6-1</a>.</p><div class="table"><a id="example_of_what_the_global_method_cac"/><p class="title">Table 6-1. An Example of What the Global Method Cache Might Contain</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="An Example of What the Global Method Cache Might Contain"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">klass</code></p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">defined_class</code></p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">Fixnum#times</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">Integer#times</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">Object#puts</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">BasicObject#puts</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p>etc...</p></td><td style="" valign="top"><p>etc...</p></td></tr></tbody></table></div></div><p>The left column in <a class="xref" href="ch06.html#example_of_what_the_global_method_cac" title="Table 6-1. An Example of What the Global Method Cache Might Contain">Table 6-1</a>, <code class="literal">klass</code>, shows the receiver class; this is the class of the object you call a method on. The right column, <code class="literal">defined_class</code>, records the result of the method lookup. This is the implementer class, or the class that implements the method Ruby was looking for.</p><p>Let’s take the first row of <a class="xref" href="ch06.html#example_of_what_the_global_method_cac" title="Table 6-1. An Example of What the Global Method Cache Might Contain">Table 6-1</a> as an example; it reads <code class="literal">Fixnum#times</code> and <code class="literal">Integer#times</code>. In the global method cache, this information means that Ruby’s method lookup algorithm started to look for the <code class="literal">times</code> method in the <code class="literal">Fixnum</code> class but actually found it in the <code class="literal">Integer</code> class. In a similar way, the second row of <a class="xref" href="ch06.html#example_of_what_the_global_method_cac" title="Table 6-1. An Example of What the Global Method Cache Might Contain">Table 6-1</a> means that Ruby started to look for the <code class="literal">puts</code> method in the <code class="literal">Object</code> class but actually found it in the <code class="literal">BasicObject</code> class.</p><p>The global method cache allows Ruby to skip the method lookup process the next time your code calls a method listed in the first column of the global cache. After your code has called <code class="literal">Fixnum#times</code> once, Ruby knows that it can execute the <code class="literal">Integer#times</code> method, regardless of from where in your program you call <code class="literal">times</code>.</p></div><div class="sect2" title="The Inline Method Cache"><div class="titlepage"><div><div><h2 class="title"><a id="inline_method_cache"/>The Inline Method Cache</h2></div></div></div><p><a class="indexterm" id="iddle1099"/><a class="indexterm" id="iddle1164"/><a class="indexterm" id="iddle1419"/><a class="indexterm" id="iddle1592"/><a class="indexterm" id="iddle1594"/>Ruby uses another type of cache, called an <span class="emphasis"><em>inline method cache</em></span>, to speed up method lookup even more. The inline cache saves information alongside the compiled YARV instructions that Ruby executes (see <a class="xref" href="ch06.html#yarv_instructions_on_the_left_should" title="Figure 6-8. The YARV instructions on the left should call the implementation of Integer#times on the right.">Figure 6-8</a>).</p><div class="figure"><a id="yarv_instructions_on_the_left_should"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00140"/><img alt="The YARV instructions on the left should call the implementation of Integer#times on the right." src="httpatomoreillycomsourcenostarchimages1854101.png.jpg"/></div></div><p class="title">Figure 6-8. The YARV instructions on the left should call the implementation of <code class="literal">Integer#times</code> on the right.</p></div><p>On the left side of this figure, we see the compiled YARV instructions that correspond to the code <code class="literal">10.times do... end</code>. First, <code class="literal">putobject 10</code> pushes the <code class="literal">Fixnum</code> object <code class="literal">10</code> onto YARV’s internal stack. This is the receiver of the <code class="literal">times</code> method call. Next, <code class="literal">send</code> calls the <code class="literal">times</code> method, as indicated by the text between the angle brackets.</p><p>The rectangle on the right side of the figure represents the <code class="literal">Integer#times</code> method, which Ruby found using its method lookup algorithm (after looking up the <code class="literal">times</code> method among the <code class="literal">Fixnum</code> class and its superclasses). Ruby’s inline cache enables it to save the mapping between the <code class="literal">times</code> method call and the <code class="literal">Integer#times</code> implementation right in the YARV instructions. <a class="xref" href="ch06.html#inline_cache_saves_the_result_of_met" title="Figure 6-9. The inline cache saves the result of method lookup next to the send instruction that needs to call the method.">Figure 6-9</a> shows how the inline cache might look.</p><div class="figure"><a id="inline_cache_saves_the_result_of_met"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00141"/><img alt="The inline cache saves the result of method lookup next to the send instruction that needs to call the method." src="httpatomoreillycomsourcenostarchimages1854103.png.jpg"/></div></div><p class="title">Figure 6-9. The inline cache saves the result of method lookup next to the <code class="literal">send</code> instruction that needs to call the method.</p></div><p>If Ruby executes this line of code again, it will immediately execute <code class="literal">Integer#times</code> without having to call the method lookup algorithm.</p></div><div class="sect2" title="Clearing Ruby’s Method Caches"><div class="titlepage"><div><div><h2 class="title"><a id="clearing_rubyapostrophes_method_caches"/>Clearing Ruby’s Method Caches</h2></div></div></div><p>Because Ruby is a dynamic language, you can define new methods when you like. In order for you to be able to do so, Ruby must clear the global and inline method caches, because the results of method lookups might change. For example, if we add a new definition of the <code class="literal">times</code> method to the <code class="literal">Fixnum</code> or <code class="literal">Integer</code> classes, Ruby would need to call the new <code class="literal">times</code> method, not the <code class="literal">Integer#times</code> method that it was previously using.</p><p>In effect, whenever you create or remove (<span class="emphasis"><em>undefine</em></span>) a method, include a module into a class, or perform a similar action, Ruby clears the global and inline method caches, forcing a new call to the method lookup code. Ruby also clears the cache when you use refinements or employ other types <a class="indexterm" id="iddle1416"/><a class="indexterm" id="iddle1699"/>of metaprogramming. In fact, clearing the cache happens quite frequently in Ruby. The global and inline method caches might remain valid for only a short time.</p></div><div class="sect2" title="Including Two Modules into One Class"><div class="titlepage"><div><div><h2 class="title"><a id="including_two_modules_into_one_class"/>Including Two Modules into One Class</h2></div></div></div><p>While Ruby’s method lookup algorithm may be simple, the code that it uses to include modules is not. As we saw above, when you include a module into a class, Ruby inserts a copy of the module into the class’s ancestor chain. This means that if you include two modules, one after the other, the second module appears first in the ancestor chain and is found first by Ruby’s method lookup logic.</p><p>For example, suppose we include two modules into <code class="literal">Mathematician</code>, as shown in <a class="xref" href="ch06.html#including_two_modules_into_one_c-id00022" title="Example 6-6. Including two modules into one class">Example 6-6</a>.</p><div class="example"><a id="including_two_modules_into_one_c-id00022"/><p class="title">Example 6-6. Including two modules into one class</p><div class="example-contents"><pre class="programlisting">class Mathematician &lt; Person
  include Professor
  include Employee
end</pre></div></div><p>Now <code class="literal">Mathematician</code> objects have methods from the <code class="literal">Professor</code> module, the <code class="literal">Employee</code> module, and the <code class="literal">Person</code> class. But which methods does Ruby find first and which methods override which?</p><p><a class="xref" href="ch06.html#in_listing_6-6_we_include_the_professor" title="Figure 6-10. In Example 6-6 we include the Professor module first.">Figure 6-10</a> and <a class="xref" href="ch06.html#in_listing_6-6_we_include_the_employee_m" title="Figure 6-11. In Example 6-6 we include the Employee module second, after including Professor.">Figure 6-11</a> show the order of precedence. Because we include the <code class="literal">Professor</code> module first, Ruby inserts the included class corresponding to the <code class="literal">Professor</code> module as a superclass first.</p><div class="figure"><a id="in_listing_6-6_we_include_the_professor"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00142"/><img alt="In we include the Professor module first." src="httpatomoreillycomsourcenostarchimages1854105.png.jpg"/></div></div><p class="title">Figure 6-10. In <a class="xref" href="ch06.html#including_two_modules_into_one_c-id00022" title="Example 6-6. Including two modules into one class">Example 6-6</a> we include the <code class="literal">Professor</code> module first.</p></div><p>Now, when we include the <code class="literal">Employee</code> module, the included class for the <code class="literal">Employee</code> module is inserted above the included class for the <code class="literal">Professor</code> module, as shown in <a class="xref" href="ch06.html#in_listing_6-6_we_include_the_employee_m" title="Figure 6-11. In Example 6-6 we include the Employee module second, after including Professor.">Figure 6-11</a>.</p><div class="figure"><a id="in_listing_6-6_we_include_the_employee_m"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00143"/><img alt="In we include the Employee module second, after including Professor." src="httpatomoreillycomsourcenostarchimages1854107.png.jpg"/></div></div><p class="title">Figure 6-11. In <a class="xref" href="ch06.html#including_two_modules_into_one_c-id00022" title="Example 6-6. Including two modules into one class">Example 6-6</a> we include the <code class="literal">Employee</code> module second, after including <code class="literal">Professor</code>.</p></div><p><a class="indexterm" id="iddle1415"/><a class="indexterm" id="iddle1698"/>Because <code class="literal">Employee</code> appears above <code class="literal">Professor</code> in the superclass chain, as shown along the left side of <a class="xref" href="ch06.html#in_listing_6-6_we_include_the_employee_m" title="Figure 6-11. In Example 6-6 we include the Employee module second, after including Professor.">Figure 6-11</a>, methods from <code class="literal">Employee</code> override methods from <code class="literal">Professor</code>, which in turn override methods from <code class="literal">Person</code>, the actual superclass.</p></div><div class="sect2" title="Including One Module into Another"><div class="titlepage"><div><div><h2 class="title"><a id="including_one_module_into_another"/>Including One Module into Another</h2></div></div></div><p>Modules don’t allow you to specify superclasses. For example, we can’t write the following:</p><a id="pro_id00034"/><pre class="programlisting">module Professor &lt; Employee
end</pre><p>But we can include one module into another, as shown in <a class="xref" href="ch06.html#one_module_including_another_module" title="Example 6-7. One module including another module">Example 6-7</a>.</p><div class="example"><a id="one_module_including_another_module"/><p class="title">Example 6-7. One module including another module</p><div class="example-contents"><pre class="programlisting">module Professor
  include Employee
end</pre></div></div><p>What if we include <code class="literal">Professor</code>, a module with other modules included into it, into <code class="literal">Mathematician</code>? Which methods will Ruby find first? As shown in <a class="xref" href="ch06.html#when_you_include_one_module_into_another" title="Figure 6-12. When you include one module into another, Ruby sets it as the superclass of the target module.">Figure 6-12</a>, when we include <code class="literal">Employee</code> into <code class="literal">Professor</code>, Ruby creates a copy of <code class="literal">Employee</code> and sets it as the superclass of <code class="literal">Professor</code>.</p><div class="figure"><a id="when_you_include_one_module_into_another"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00144"/><img alt="When you include one module into another, Ruby sets it as the superclass of the target module." src="httpatomoreillycomsourcenostarchimages1854109.png.jpg"/></div></div><p class="title">Figure 6-12. When you include one module into another, Ruby sets it as the superclass of the target module.</p></div><p><a class="indexterm" id="iddle1259"/><a class="indexterm" id="iddle1646"/><a class="indexterm" id="iddle1692"/>Modules can’t have a superclass in your code, but they can inside Ruby because Ruby represents modules with classes internally!</p><p>Finally, when we include <code class="literal">Professor</code> into <code class="literal">Mathematician</code>, Ruby iterates over the two modules and inserts them both as superclasses of <code class="literal">Mathematician</code>, as shown in <a class="xref" href="ch06.html#including_two_modules_into_a_class_at_th" title="Figure 6-13. Including two modules into a class at the same time">Figure 6-13</a>.</p><div class="figure"><a id="including_two_modules_into_a_class_at_th"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00145"/><img alt="Including two modules into a class at the same time" src="httpatomoreillycomsourcenostarchimages1854111.png.jpg"/></div></div><p class="title">Figure 6-13. Including two modules into a class at the same time</p></div><p>Now Ruby will find the methods in <code class="literal">Professor</code> first and <code class="literal">Employee</code> second.</p></div><div class="sect2" title="A Module#prepend Example"><div class="titlepage"><div><div><h2 class="title"><a id="modulehashprepend_example"/>A Module#prepend Example</h2></div></div></div><p>In <a class="xref" href="ch06.html#including_a_module_into_a_class-id00020" title="Figure 6-2. Including a module into a class">Figure 6-2</a> we saw how Ruby includes a module into a class. Specifically, we saw how Ruby inserts a copy of the module’s <code class="literal">RClass</code> structure into the superclass chain for the target class, between the class and its superclass.</p><p>Beginning with version 2.0, Ruby now allows you to “prepend” a module into a class. We’ll use the <code class="literal">Mathematician</code> class to explain, as shown in <a class="xref" href="ch06.html#simple_ruby_class_with_a_name_attribut" title="Example 6-8. A simple Ruby class with a name attribute">Example 6-8</a>.</p><div class="example"><a id="simple_ruby_class_with_a_name_attribut"/><p class="title">Example 6-8. A simple Ruby class with a <code class="literal">name</code> attribute</p><div class="example-contents"><pre class="programlisting">    class Mathematician
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   attr_accessor :name
    end

    poincaré = Mathematician.new
    poincaré.name = "Henri Poincaré"
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> p poincaré.name
     =&gt; "Henri Poincaré"</pre></div></div><p>First, we define the <code class="literal">Mathematician</code> class with just the single attribute <code class="literal">name</code> at <span class="inlinemediaobject"><a id="inline_id00162"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>. Then, we create an instance of <code class="literal">Mathematician</code>, set its name, and display it at <span class="inlinemediaobject"><a id="inline_id00163"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>.</p><p>Now suppose we make all of our mathematicians professors by including the <code class="literal">Professor</code> module into the <code class="literal">Mathematician</code> class again, as shown at <span class="inlinemediaobject"><a id="inline_id00164"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> in <a class="xref" href="ch06.html#including_the_professor_module_into_the" title="Example 6-9. Including the Professor module into the Mathematician class">Example 6-9</a>.</p><div class="example"><a id="including_the_professor_module_into_the"/><p class="title">Example 6-9. Including the <code class="literal">Professor</code> module into the <code class="literal">Mathematician</code> class</p><div class="example-contents"><pre class="programlisting">    module Professor
    end

    class Mathematician
      attr_accessor :name
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   include Professor
    end</pre></div></div><p><a class="xref" href="ch06.html#professor_is_a_superclass_of_mathematici" title="Figure 6-14. Professor is a superclass of Mathematician.">Figure 6-14</a> shows the superclass chain for <code class="literal">Mathematician</code> and <code class="literal">Professor</code>.</p><div class="figure"><a id="professor_is_a_superclass_of_mathematici"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00146"/><img alt="Professor is a superclass of Mathematician." src="httpatomoreillycomsourcenostarchimages1854113.png.jpg"/></div></div><p class="title">Figure 6-14. <code class="literal">Professor</code> is a superclass of <code class="literal">Mathematician</code>.</p></div><p>If we decide to display the title <code class="literal">Prof.</code> in front of each mathematician’s name, we can just add that behavior to the <code class="literal">Mathematician</code> class, as shown in <a class="xref" href="ch06.html#ugly_way_to_display_the_profdot_title" title="Example 6-10. An ugly way to display the Prof. title before each mathematician’s name">Example 6-10</a>.</p><div class="example"><a id="ugly_way_to_display_the_profdot_title"/><p class="title">Example 6-10. An ugly way to display the <code class="literal">Prof.</code> title before each mathematician’s name</p><div class="example-contents"><pre class="programlisting">    module Professor
    end

    class Mathematician
      attr_writer :name
      include Professor
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   def name
        "Prof. #{@name}"
      end
    end</pre></div></div><p>But this is a very ugly solution: The <code class="literal">Mathematician</code> class has to do the work of displaying the professor title at <span class="inlinemediaobject"><a id="inline_id00167"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>. What if other classes include <code class="literal">Professor</code>? Shouldn’t they display the <code class="literal">Prof.</code> title also? If <code class="literal">Mathematician</code> contains the code for showing <code class="literal">Prof.</code>, then any other classes that include <code class="literal">Professor</code> would be missing this code.</p><p>It makes more sense to include the code for displaying the title in the <code class="literal">Professor</code> module, as shown in <a class="xref" href="ch06.html#how_can_we_get_ruby_to_call_the_moduleap" title="Example 6-11. How can we get Ruby to call the module’s name method?">Example 6-11</a>. This way every class that includes <code class="literal">Professor</code> will be able to display the title <code class="literal">Prof.</code> along with its class name.</p><div class="example"><a id="how_can_we_get_ruby_to_call_the_moduleap"/><p class="title">Example 6-11. How can we get Ruby to call the module’s <code class="literal">name</code> method?</p><div class="example-contents"><pre class="programlisting">    module Professor
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   def name
        "Prof. #{super}"
      end
    end

    class Mathematician
      attr_accessor :name
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   include Professor
    end

    poincaré = Mathematician.new
    poincaré.name = "Henri Poincaré"
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/> p poincaré.name
     =&gt; "Henri Poincaré"</pre></div></div><p>At <span class="inlinemediaobject"><a id="inline_id00171"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> we define a <code class="literal">name</code> method inside <code class="literal">Professor</code> that will display the <code class="literal">Prof.</code> title before the actual name (assuming that <code class="literal">name</code> is defined in a superclass). At <span class="inlinemediaobject"><a id="inline_id00172"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> we include <code class="literal">Professor</code> into <code class="literal">Mathematician</code>. Finally, at <span class="inlinemediaobject"><a id="inline_id00173"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> we call the <code class="literal">name</code> method, but we get the name <code class="literal">Henri Poincaré</code> without the <code class="literal">Prof.</code> title. What went wrong?</p><p>The problem, as shown in <a class="xref" href="ch06.html#professor_is_a_superclass_of_mathematici" title="Figure 6-14. Professor is a superclass of Mathematician.">Figure 6-14</a>, is that <code class="literal">Professor</code> is a superclass of <code class="literal">Mathematician</code>, not the other way around. This means when I call <code class="literal">poincaré.name</code> at <span class="inlinemediaobject"><a id="inline_id00174"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> in <a class="xref" href="ch06.html#how_can_we_get_ruby_to_call_the_moduleap" title="Example 6-11. How can we get Ruby to call the module’s name method?">Example 6-11</a>, Ruby finds the <code class="literal">name</code> method from <code class="literal">Mathematician</code>, not from <code class="literal">Professor</code>. <a class="xref" href="ch06.html#ruby_calls_the_attrunderscoreaccessor_me" title="Figure 6-15. Ruby calls the attr_accessor method before finding the name method from Professor.">Figure 6-15</a> shows visually what Ruby’s method lookup algorithm finds when I call <code class="literal">poincaré.name</code>.</p><div class="figure"><a id="ruby_calls_the_attrunderscoreaccessor_me"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00147"/><img alt="Ruby calls the attr_accessor method before finding the name method from Professor." src="httpatomoreillycomsourcenostarchimages1854115.png.jpg"/></div></div><p class="title">Figure 6-15. Ruby calls the <code class="literal">attr_accessor</code> method before finding the <code class="literal">name</code> method from <code class="literal">Professor</code>.</p></div><p>When we call <code class="literal">name</code> at <span class="inlinemediaobject"><a id="inline_id00175"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> in <a class="xref" href="ch06.html#how_can_we_get_ruby_to_call_the_moduleap" title="Example 6-11. How can we get Ruby to call the module’s name method?">Example 6-11</a>, Ruby finds the first <code class="literal">name</code> method that it sees in the superclass chain starting from the top and moving down. As you can see in <a class="xref" href="ch06.html#ruby_calls_the_attrunderscoreaccessor_me" title="Figure 6-15. Ruby calls the attr_accessor method before finding the name method from Professor.">Figure 6-15</a>, the first <code class="literal">name</code> method is the simple <code class="literal">attr_accessor</code> method in <code class="literal">Mathematician</code>.</p><p>However, if we prepend <code class="literal">Professor</code> instead of including it, we get the behavior we were hoping for, as shown in <a class="xref" href="ch06.html#using_prependcomma_ruby_finds_the_module" title="Example 6-12. Using prepend, Ruby finds the module’s name method first.">Example 6-12</a>.</p><div class="example"><a id="using_prependcomma_ruby_finds_the_module"/><p class="title">Example 6-12. Using <code class="literal">prepend</code>, Ruby finds the module’s <code class="literal">name</code> method first.</p><div class="example-contents"><pre class="programlisting">    module Professor
      def name
        "Prof. #{super}"
      end
    end

    class Mathematician
      attr_accessor :name
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   prepend Professor
    end

    poincaré = Mathematician.new
    poincaré.name = "Henri Poincaré"
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> p poincaré.name
     =&gt; "Prof. Henri Poincaré"</pre></div></div><p>The only difference here is the use of <code class="literal">prepend</code> at <span class="inlinemediaobject"><a id="inline_id00178"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>.</p></div><div class="sect2" title="How Ruby Implements Module#prepend"><div class="titlepage"><div><div><h2 class="title"><a id="how_ruby_implements_modulehashprepend"/>How Ruby Implements Module#prepend</h2></div></div></div><p><a class="indexterm" id="iddle1139"/><a class="indexterm" id="iddle1406"/><a class="indexterm" id="iddle1693"/><a class="indexterm" id="iddle1763"/>When you prepend a module to a class, Ruby places it before the class in the superclass chain, as shown in <a class="xref" href="ch06.html#using_prependcomma_ruby_places_the_modul" title="Figure 6-16. Using prepend, Ruby places the module before the target class in the superclass chain.">Figure 6-16</a>.</p><div class="figure"><a id="using_prependcomma_ruby_places_the_modul"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00148"/><img alt="Using prepend, Ruby places the module before the target class in the superclass chain." src="httpatomoreillycomsourcenostarchimages1854117.png.jpg"/></div></div><p class="title">Figure 6-16. Using <code class="literal">prepend</code>, Ruby places the module before the target class in the superclass chain.</p></div><p>But there is something odd here. When we call <code class="literal">name</code> on a mathematician object, how does Ruby find the module’s method? That is, at <span class="inlinemediaobject"><a id="inline_id00179"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> in <a class="xref" href="ch06.html#using_prependcomma_ruby_finds_the_module" title="Example 6-12. Using prepend, Ruby finds the module’s name method first.">Example 6-12</a>, we’re calling <code class="literal">name</code> on the <code class="literal">Mathematician</code> class, not on the <code class="literal">Professor</code> module. Ruby should find the simple <code class="literal">attr_accessor</code> method, not the version from the module, but that’s not the case. Does Ruby look backward up the superclass chain to find the module? If so, how does it do this when the <code class="literal">super</code> pointers point down?</p><p>The secret is that internally Ruby uses a trick to make it seem as if <code class="literal">Mathematician</code> is the superclass of <code class="literal">Professor</code> when it’s not, as shown in <a class="xref" href="ch06.html#ruby_creates_a_copy_of_the_target_class" title="Figure 6-17. Ruby creates a copy of the target class and sets it as the superclass of the prepended module.">Figure 6-17</a>. Prepending a module is like including a module. <code class="literal">Mathematician</code> is at the top of the superclass chain, and moving down the chain, we see that Ruby still sets the included class for <code class="literal">Professor</code> to be the superclass of <code class="literal">Mathematician</code>.</p><p>But below <code class="literal">Professor</code> in <a class="xref" href="ch06.html#ruby_creates_a_copy_of_the_target_class" title="Figure 6-17. Ruby creates a copy of the target class and sets it as the superclass of the prepended module.">Figure 6-17</a> we see something new, the <span class="emphasis"><em>origin class</em></span> for <code class="literal">Mathematician</code>. This is a new copy of <code class="literal">Mathematician</code> that Ruby creates to make <code class="literal">prepend</code> work.</p><p>When you prepend a module, Ruby creates a copy of the target class (called the <span class="emphasis"><em>origin class</em></span> internally) and sets it as the superclass of the prepended module. Ruby uses the <code class="literal">origin</code> pointer that we saw in the <code class="literal">rb_classext_struct</code> structure in <a class="xref" href="ch06.html#portion_of_rubyapostrophes_class_str" title="Figure 6-1. The portion of Ruby’s class structures that’s used for modules">Figure 6-1</a> and <a class="xref" href="ch06.html#including_a_module_into_a_class-id00020" title="Figure 6-2. Including a module into a class">Figure 6-2</a> to track this new origin copy of the class. In addition, Ruby moves all of the methods from the original class to the origin class, which means that those methods may now be overridden by methods with the same name in the prepended module. In <a class="xref" href="ch06.html#ruby_creates_a_copy_of_the_target_class" title="Figure 6-17. Ruby creates a copy of the target class and sets it as the superclass of the prepended module.">Figure 6-17</a> you can see that Ruby moved the <code class="literal">attr_accessor</code> method down from <code class="literal">Mathematician</code> to the origin class.</p><div class="figure"><a id="ruby_creates_a_copy_of_the_target_class"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00149"/><img alt="Ruby creates a copy of the target class and sets it as the superclass of the prepended module." src="httpatomoreillycomsourcenostarchimages1854119.png.jpg"/></div></div><p class="title">Figure 6-17. Ruby creates a copy of the target class and sets it as the superclass of the prepended module.</p></div></div></div><div class="sect1" title="Experiment 6-1: Modifying a Module After Including It"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_6-1_modifying_a_module_after"/>Experiment 6-1: Modifying a Module After Including It</h1></div></div></div><p><a class="indexterm" id="iddle1281"/><a class="indexterm" id="iddle1688"/><a class="indexterm" id="iddle1700"/><a class="indexterm" id="iddle1730"/>Following a suggestion by Xavier Noria, this experiment will explore what happens when you modify a module once it’s been included into a class. We’ll use the same <code class="literal">Mathematician</code> class and the <code class="literal">Professor</code> module but with different methods, as shown in <a class="xref" href="ch06.html#another_example_of_including_a_module_in" title="Example 6-13. Another example of including a module into a class">Example 6-13</a>.</p><div class="example"><a id="another_example_of_including_a_module_in"/><p class="title">Example 6-13. Another example of including a module into a class</p><div class="example-contents"><pre class="programlisting">    module Professor
      def lectures; end
    end

    class Mathematician
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   attr_accessor :first_name
      attr_accessor :last_name
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   include Professor
    end</pre></div></div><p><a class="indexterm" id="iddle1130"/><a class="indexterm" id="iddle1146"/><a class="indexterm" id="iddle2028"/>This time the <code class="literal">Mathematician</code> class contains the accessor methods at <span class="inlinemediaobject"><a id="inline_id00182"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> for <code class="literal">@first_name</code> and <code class="literal">@last_name</code>, and we’ve included the <code class="literal">Professor</code> module again at <span class="inlinemediaobject"><a id="inline_id00183"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>. If we inspect the methods of a mathematician object, as shown in <a class="xref" href="ch06.html#inspecting_the_methods_of_a_mathematicia" title="Example 6-14. Inspecting the methods of a mathematician object">Example 6-14</a>, we should see the attribute methods, such as <code class="literal">first_name=</code> and the <code class="literal">lectures</code> method from <code class="literal">Professor</code>.</p><div class="example"><a id="inspecting_the_methods_of_a_mathematicia"/><p class="title">Example 6-14. Inspecting the methods of a mathematician object</p><div class="example-contents"><pre class="programlisting">fermat = Mathematician.new
fermat.first_name = 'Pierre'
fermat.last_name = 'de Fermat'

p fermat.methods.sort
 =&gt; [ ... :first_name, :first_name=, ... :last_name, :last_name=, :lectures ... ]</pre></div></div><p>No surprise; we see all the methods.</p><div class="sect2" title="Classes See Methods Added to a Module Later"><div class="titlepage"><div><div><h2 class="title"><a id="classes_see_methods_added_to_a_module_la"/>Classes See Methods Added to a Module Later</h2></div></div></div><p>Now let’s add some new methods to the <code class="literal">Professor</code> module after including it into the <code class="literal">Mathematician</code> class. Does Ruby know that the new methods should be added to <code class="literal">Mathematician</code> as well? Let’s find out by running <a class="xref" href="ch06.html#adding_a_new_method_to_professor_after_i" title="Example 6-15. Adding a new method to Professor after including it into Mathematician">Example 6-15</a> right after <a class="xref" href="ch06.html#inspecting_the_methods_of_a_mathematicia" title="Example 6-14. Inspecting the methods of a mathematician object">Example 6-14</a> finishes.</p><div class="example"><a id="adding_a_new_method_to_professor_after_i"/><p class="title">Example 6-15. Adding a new method to <code class="literal">Professor</code> after including it into <code class="literal">Mathematician</code></p><div class="example-contents"><pre class="programlisting">    module Professor
      def primary_classroom; end
    end

    p fermat.methods.sort
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>  =&gt; [ ... :first_name, :first_name=, ... :last_name, :last_name=, :lectures,
    ... :primary_classroom, ... ]</pre></div></div><p>As you can see, at <span class="inlinemediaobject"><a id="inline_id00185"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> we get all the methods, including the new <code class="literal">primary_classroom</code> method that was added to <code class="literal">Professor</code> after it was included into <code class="literal">Mathematician</code>. No surprise here either. Ruby is one step ahead of us.</p></div><div class="sect2" title="Classes Don’t See Submodules Included Later"><div class="titlepage"><div><div><h2 class="title"><a id="classes_donapostrophet_see_submodules_in"/>Classes Don’t See Submodules Included Later</h2></div></div></div><p>Now for one more test. What if we reopen the <code class="literal">Professor</code> module and include yet another module into it using <a class="xref" href="ch06.html#including_a_new_module_into_professor_af" title="Example 6-16. Including a new module into Professor after it was included into Mathematician">Example 6-16</a>?</p><div class="example"><a id="including_a_new_module_into_professor_af"/><p class="title">Example 6-16. Including a new module into <code class="literal">Professor</code> after it was included into <code class="literal">Mathematician</code></p><div class="example-contents"><pre class="programlisting">module Employee
  def hire_date; end
end

module Professor
  include Employee
end</pre></div></div><p><a class="indexterm" id="iddle1411"/><a class="indexterm" id="iddle1663"/>This is getting confusing, so let’s review what we did in <a class="xref" href="ch06.html#another_example_of_including_a_module_in" title="Example 6-13. Another example of including a module into a class">Example 6-13</a> and <a class="xref" href="ch06.html#including_a_new_module_into_professor_af" title="Example 6-16. Including a new module into Professor after it was included into Mathematician">Example 6-16</a>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>In <a class="xref" href="ch06.html#another_example_of_including_a_module_in" title="Example 6-13. Another example of including a module into a class">Example 6-13</a> we included the <code class="literal">Professor</code> module into the <code class="literal">Mathematician</code> class.</p></li><li class="listitem"><p>Then, in <a class="xref" href="ch06.html#including_a_new_module_into_professor_af" title="Example 6-16. Including a new module into Professor after it was included into Mathematician">Example 6-16</a> we included the <code class="literal">Employee</code> module into the <code class="literal">Professor</code> module. Therefore, the methods of the <code class="literal">Employee</code> module should now be available on a mathematician object.</p></li></ul></div><p>Let’s see whether Ruby works as expected:</p><a id="pro_id00035"/><pre class="programlisting">p fermat.methods.sort
 =&gt; [ ... :first_name, :first_name=, ... :last_name, :last_name=, :lectures ... ]</pre><p>It didn’t work! The <code class="literal">hire_date</code> method is <span class="emphasis"><em>not</em></span> available in the <code class="literal">fermat</code> object. Including a module into a module already included into a class <span class="emphasis"><em>does not</em></span> affect that class.</p><p>As we’ve learned how Ruby implements modules, this fact shouldn’t be too hard to understand. Including <code class="literal">Employee</code> into <code class="literal">Professor</code> changes the <code class="literal">Professor</code> module, not the copy of <code class="literal">Professor</code> that Ruby created when we included it into <code class="literal">Mathematician</code>, as shown in <a class="xref" href="ch06.html#employee_module_is_included_into_the" title="Figure 6-18. The Employee module is included into the original Professor module, not the included copy used by Mathematician.">Figure 6-18</a>.</p><div class="figure"><a id="employee_module_is_included_into_the"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00150"/><img alt="The Employee module is included into the original Professor module, not the included copy used by Mathematician." src="httpatomoreillycomsourcenostarchimages1854121.png.jpg"/></div></div><p class="title">Figure 6-18. The <code class="literal">Employee</code> module is included into the original <code class="literal">Professor</code> module, not the included copy used by <code class="literal">Mathematician</code>.</p></div></div><div class="sect2" title="Included Classes Share the Method Table with the Original Module"><div class="titlepage"><div><div><h2 class="title"><a id="included_classes_share_the_method_table"/>Included Classes Share the Method Table with the Original Module</h2></div></div></div><p>But what about the <code class="literal">primary_classroom</code> method we added in <a class="xref" href="ch06.html#adding_a_new_method_to_professor_after_i" title="Example 6-15. Adding a new method to Professor after including it into Mathematician">Example 6-15</a>? How was Ruby able to include the <code class="literal">primary_classroom</code> method into <code class="literal">Mathematician</code> even though we added it to <code class="literal">Professor</code> after we included <code class="literal">Professor</code> into <code class="literal">Mathematician</code>? <a class="xref" href="ch06.html#employee_module_is_included_into_the" title="Figure 6-18. The Employee module is included into the original Professor module, not the included copy used by Mathematician.">Figure 6-18</a> shows that Ruby created a copy of the <code class="literal">Professor</code> module before we added the new method to it. But how does the <code class="literal">fermat</code> object get the new method?</p><p><a class="indexterm" id="iddle1695"/><a class="indexterm" id="iddle1870"/>As it turns out, when you include a module, Ruby copies the <code class="literal">RClass</code> structure, not the underlying method table, as shown in <a class="xref" href="ch06.html#ruby_doesnapostrophet_copy_the_method_ta" title="Figure 6-19. Ruby doesn’t copy the method table when you include a module.">Figure 6-19</a>.</p><div class="figure"><a id="ruby_doesnapostrophet_copy_the_method_ta"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00151"/><img alt="Ruby doesn’t copy the method table when you include a module." src="httpatomoreillycomsourcenostarchimages1854123.png.jpg"/></div></div><p class="title">Figure 6-19. Ruby doesn’t copy the method table when you include a module.</p></div><p>Ruby doesn’t copy the method table for <code class="literal">Professor</code>. Instead, it simply sets <code class="literal">m_tbl</code> in the new copy of <code class="literal">Professor</code>, the “included class,” to point to the same method table. This means that modifying the method table by reopening the module and adding new methods will change both the module and any classes into which it was already included.</p><div class="sidebar"><a id="close_look_at_how_ruby_copies_modules"/><p class="title">A Close Look at How Ruby Copies Modules</p><p>By looking at Ruby’s C source code directly, you’ll gain a precise understanding of how Ruby copies modules when you include them and why Ruby behaves as you’ll see in this experiment. You’ll find the C function that Ruby uses to make a copy of a module in the <span class="emphasis"><em>class.c</em></span> file. <a class="xref" href="ch06.html#portion_of_the_rbunderscoreincludeunde" title="Example 6-17. A portion of the rb_include_class_new C function, from class.c">Example 6-17</a> shows a portion of the function <code class="literal">rb_include_class_new</code>.</p><div class="example"><a id="portion_of_the_rbunderscoreincludeunde"/><p class="title">Example 6-17. A portion of the <code class="literal">rb_include_class_new</code> C function, from <span class="emphasis"><em><code class="literal">class.c</code></em></span></p><div class="example-contents"><pre class="programlisting">    VALUE
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> rb_include_class_new(VALUE module, VALUE super)
    {
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>     VALUE klass = class_alloc(T_ICLASS, rb_cClass);
        --<span class="emphasis"><em>snip</em></span>--
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>     RCLASS_IV_TBL(klass) = RCLASS_IV_TBL(module);
        RCLASS_CONST_TBL(klass) = RCLASS_CONST_TBL(module);
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/>     RCLASS_M_TBL(klass) = RCLASS_M_TBL(RCLASS_ORIGIN(module));
<img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/>     RCLASS_SUPER(klass) = super;
        --<span class="emphasis"><em>snip</em></span>--
        return (VALUE)klass;
    }</pre></div></div><p><a class="indexterm" id="iddle1122"/><a class="indexterm" id="iddle1413"/><a class="indexterm" id="iddle1881"/><a class="indexterm" id="iddle1882"/><a class="indexterm" id="iddle1883"/><a class="indexterm" id="iddle1884"/>At <span class="inlinemediaobject"><a id="inline_id00191"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> Ruby passes in <code class="literal">module</code> (the target module to copy) and <code class="literal">super</code> (the superclass to use for the new copy of <code class="literal">module</code>). By specifying a particular superclass, Ruby inserts the new copy into the superclass chain at a particular place. If you search <span class="emphasis"><em>class.c</em></span> for <code class="literal">rb_include_class_new</code>, you’ll find that Ruby calls it from another C function, <code class="literal">include_modules_at</code>, which handles the complex internal logic that Ruby uses to include modules.</p><p>At <span class="inlinemediaobject"><a id="inline_id00192"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> Ruby calls <code class="literal">class_alloc</code> to create a new <code class="literal">RClass</code> structure and saves a reference to it in <code class="literal">klass</code>. Notice the first parameter to <code class="literal">class_alloc</code> is the value <code class="literal">T_ICLASS</code>, which identifies the new class as an included class. Ruby uses <code class="literal">T_ICLASS</code> throughout its C source code when dealing with included classes.</p><p>At <span class="inlinemediaobject"><a id="inline_id00193"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> Ruby copies a series of pointers from the original module’s <code class="literal">RClass</code> structure over to the new copy using three C macros that operate on <code class="literal">RClass</code>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">RCLASS_IV_TBL</code> gets or sets a pointer to the instance variable table.</p></li><li class="listitem"><p><code class="literal">RCLASS_CONST_TBL</code> gets or sets a pointer to the constant variable table.</p></li><li class="listitem"><p><code class="literal">RCLASS_M_TBL</code> gets or sets a pointer to the method table.</p></li></ul></div><p>For example, <code class="literal">RCLASS_IV_TBL(klass) = RCLASS_IV_TBL(module)</code> sets the instance variable table pointer in <code class="literal">klass</code> (the new copy) to the instance variable pointer from <code class="literal">module</code> (the target module to copy). Now <code class="literal">klass</code> and <code class="literal">module</code> use the same instance variables. In the same way, <code class="literal">klass</code> shares constant and method tables with <code class="literal">module</code>. Because they share the same method table, adding a new method to <code class="literal">module</code> also adds it to <code class="literal">klass</code>. This explains the behavior we saw in <a class="xref" href="ch06.html#experiment_6-1_modifying_a_module_after" title="Experiment 6-1: Modifying a Module After Including It">Experiment 6-1: Modifying a Module After Including It</a>: Adding a method to a module also adds it to each class that includes that module.</p><p>Also note at <span class="inlinemediaobject"><a id="inline_id00194"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span> Ruby uses <code class="literal">RCLASS_ORIGIN(module)</code>, not <code class="literal">module</code>. Normally <code class="literal">RCLASS_ORIGIN(module)</code> is the same as <code class="literal">module</code>; however, if you have earlier used <code class="literal">prepend</code> in <code class="literal">module</code>, then <code class="literal">RCLASS_ORIGIN(module)</code> instead returns the origin class for <code class="literal">module</code>. Recall that when you call <code class="literal">Module#prepend</code>, Ruby makes a copy (the origin class) of the target module and inserts the copy into the superclass chain. By using <code class="literal">RCLASS_ORIGIN(module)</code>, Ruby gets the original module’s method table, even if you prepended it with a different module.</p><p>Finally, at <span class="inlinemediaobject"><a id="inline_id00195"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/></span> Ruby sets the superclass pointer of <code class="literal">klass</code> to the specified superclass and returns it.</p></div></div></div><div class="sect1" title="Constant Lookup"><div class="titlepage"><div><div><h1 class="title"><a id="constant_lookup"/>Constant Lookup</h1></div></div></div><p>We’ve learned about Ruby’s method lookup algorithm and how it searches through the superclass chain to find the right method to call. Now we’ll turn our attention to a related process: Ruby’s constant lookup algorithm, or the process Ruby uses to find a constant value that you refer to in your code.</p><p>Clearly method lookup is central to the language, but why study constant lookup? As Ruby developers, we don’t use constants very often in our code—certainly not as often as we use classes, modules, variables, and blocks.</p><p><a class="indexterm" id="iddle1194"/><a class="indexterm" id="iddle1293"/>One reason is that constants, like modules and classes, are central to the way Ruby works internally and to the way we use Ruby. Whenever you define a module or class, you also define a constant. And whenever you refer to or use a module or class, Ruby has to look up the corresponding constant.</p><p>The second reason has to do with the way Ruby finds a constant that you refer to in your code. As you may know, Ruby finds constants defined in a superclass, but it also finds constants in the surrounding namespace or syntactical scope of your program. Studying how Ruby handles syntactical scope leads us to some important discoveries about how Ruby works internally.</p><p>Let’s begin by reviewing how constants work in Ruby.</p><div class="sect2" title="Finding a Constant in a Superclass"><div class="titlepage"><div><div><h2 class="title"><a id="finding_a_constant_in_a_superclass"/>Finding a Constant in a Superclass</h2></div></div></div><p>One way that Ruby searches for the definition of a constant you refer to is by using the superclass chain just as it would look for a method definition. <a class="xref" href="ch06.html#ruby_finds_constants_you_define_in_a_sup" title="Example 6-18. Ruby finds constants you define in a superclass.">Example 6-18</a> shows an example of one class finding a constant in its superclass.</p><div class="example"><a id="ruby_finds_constants_you_define_in_a_sup"/><p class="title">Example 6-18. Ruby finds constants you define in a superclass.</p><div class="example-contents"><pre class="programlisting">    class MyClass
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   SOME_CONSTANT = "Some value..."
    end

<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> class Subclass &lt; MyClass
      p SOME_CONSTANT
    end</pre></div></div><p>In <a class="xref" href="ch06.html#ruby_finds_constants_you_define_in_a_sup" title="Example 6-18. Ruby finds constants you define in a superclass.">Example 6-18</a> we define <code class="literal">MyClass</code> with a single constant, <code class="literal">SOME_CONSTANT</code> at <span class="inlinemediaobject"><a id="inline_id00198"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>. Then we create <code class="literal">Subclass</code> and set <code class="literal">MyClass</code> as a superclass at <span class="inlinemediaobject"><a id="inline_id00199"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>. When we print the value of <code class="literal">SOME_CONSTANT</code>, Ruby uses the same algorithm it uses to find a method, as shown in <a class="xref" href="ch06.html#ruby_searches_for_constants_using_the_su" title="Figure 6-20. Ruby searches for constants using the superclass chain, just as it does with methods.">Figure 6-20</a>.</p><div class="figure"><a id="ruby_searches_for_constants_using_the_su"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00152"/><img alt="Ruby searches for constants using the superclass chain, just as it does with methods." src="httpatomoreillycomsourcenostarchimages1854125.png.jpg"/></div></div><p class="title">Figure 6-20. Ruby searches for constants using the superclass chain, just as it does with methods.</p></div><p><a class="indexterm" id="iddle1137"/><a class="indexterm" id="iddle1739"/><a class="indexterm" id="iddle1767"/>Here, on the right, you see the code from <a class="xref" href="ch06.html#ruby_finds_constants_you_define_in_a_sup" title="Example 6-18. Ruby finds constants you define in a superclass.">Example 6-18</a> and, on the left, the <code class="literal">RClass</code> structures that correspond to each of the two classes we created. At the top left of the figure, you see <code class="literal">MyClass</code>, which contains the value of <code class="literal">SOME_CONSTANT</code> in its constants table. Below that is <code class="literal">Subclass</code>. When we refer to <code class="literal">SOME_CONSTANT</code> from inside <code class="literal">Subclass</code>, Ruby uses the <code class="literal">super</code> pointer to find <code class="literal">MyClass</code> and the value of <code class="literal">SOME_CONSTANT</code>.</p></div><div class="sect2" title="How Does Ruby Find a Constant in the Parent Namespace?"><div class="titlepage"><div><div><h2 class="title"><a id="how_does_ruby_find_a_constant_in_the_par"/>How Does Ruby Find a Constant in the Parent Namespace?</h2></div></div></div><p><a class="xref" href="ch06.html#using_a_constant_defined_in_the_surround" title="Example 6-19. Using a constant defined in the surrounding namespace">Example 6-19</a> shows another way to define a constant.</p><div class="example"><a id="using_a_constant_defined_in_the_surround"/><p class="title">Example 6-19. Using a constant defined in the surrounding namespace</p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> module Namespace
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   SOME_CONSTANT = "Some value..."
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>   class Subclass
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/>     p SOME_CONSTANT
      end
    end</pre></div></div><p>Using idiomatic Ruby style, we create a module called <code class="literal">Namespace</code> at <span class="inlinemediaobject"><a id="inline_id00204"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>. Then, inside this module, we declare the same <code class="literal">SOME_CONSTANT</code> value at <span class="inlinemediaobject"><a id="inline_id00205"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>. Next, we declare <code class="literal">Subclass</code> inside <code class="literal">Namespace</code> at <span class="inlinemediaobject"><a id="inline_id00206"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span>, and we’re able to refer to and print the value of <code class="literal">SOME_CONSTANT</code>, just as in <a class="xref" href="ch06.html#ruby_finds_constants_you_define_in_a_sup" title="Example 6-18. Ruby finds constants you define in a superclass.">Example 6-18</a>.</p><p>But how does Ruby find <code class="literal">SOME_CONSTANT</code> in <a class="xref" href="ch06.html#using_a_constant_defined_in_the_surround" title="Example 6-19. Using a constant defined in the surrounding namespace">Example 6-19</a> when we display it at <span class="inlinemediaobject"><a id="inline_id00207"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span>? <a class="xref" href="ch06.html#how_does_ruby_find_constants_in_the_surr" title="Figure 6-21. How does Ruby find constants in the surrounding namespace?">Figure 6-21</a> shows the problem.</p><div class="figure"><a id="how_does_ruby_find_constants_in_the_surr"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00153"/><img alt="How does Ruby find constants in the surrounding namespace?" src="httpatomoreillycomsourcenostarchimages1854127.png.jpg"/></div></div><p class="title">Figure 6-21. How does Ruby find constants in the surrounding namespace?</p></div><p><a class="indexterm" id="iddle1538"/>On the left side of this figure are two <code class="literal">RClass</code> structures, one for the <code class="literal">Namespace</code> module and one for <code class="literal">Subclass</code>. Notice that <code class="literal">Namespace</code> is not a superclass of <code class="literal">Subclass</code>; the <code class="literal">super</code> pointer in <code class="literal">Subclass</code> refers to the <code class="literal">Object</code> class, Ruby’s default superclass. Then how does Ruby find <code class="literal">SOME_CONSTANT</code> when we refer to it inside of <code class="literal">Subclass</code>? Somehow Ruby allows you to search up the “namespace chain” to find constants. This behavior is called using lexical scope to find a constant.</p></div></div><div class="sect1" title="Lexical Scope in Ruby"><div class="titlepage"><div><div><h1 class="title"><a id="lexical_scope_in_ruby"/>Lexical Scope in Ruby</h1></div></div></div><p><span class="emphasis"><em>Lexical scope</em></span> refers to a section of code within the syntactical structure of your program, rather than within the superclass hierarchy or some other scheme. For example, suppose we use the <code class="literal">class</code> keyword to define <code class="literal">MyClass</code>, as shown in <a class="xref" href="ch06.html#defining_a_class_with_the_class_keyword" title="Example 6-20. Defining a class with the class keyword">Example 6-20</a>.</p><div class="example"><a id="defining_a_class_with_the_class_keyword"/><p class="title">Example 6-20. Defining a class with the <code class="literal">class</code> keyword</p><div class="example-contents"><pre class="programlisting">class MyClass
  SOME_CONSTANT = "Some value..."
end</pre></div></div><p>This code tells Ruby to create a new copy of the <code class="literal">RClass</code> structure, but it also defines a new scope or syntactical section of your program. This is the area between the <code class="literal">class</code> and <code class="literal">end</code> keywords, as shown with shading in <a class="xref" href="ch06.html#class_keyword_creates_a_class_and_a" title="Figure 6-22. The class keyword creates a class and a new lexical scope.">Figure 6-22</a>.</p><div class="figure"><a id="class_keyword_creates_a_class_and_a"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00154"/><img alt="The class keyword creates a class and a new lexical scope." src="httpatomoreillycomsourcenostarchimages1854129.png.jpg"/></div></div><p class="title">Figure 6-22. The <code class="literal">class</code> keyword creates a class and a new lexical scope.</p></div><p>Think of your Ruby program as a series of scopes, one for each module or class that you create and another for the default, top-level lexical scope. To keep track of where this new scope lies inside your program’s lexical structure, Ruby attaches a couple of pointers to the YARV instruction snippet corresponding to the code it compiles inside this new scope, as shown in <a class="xref" href="ch06.html#for_each_snippet_of_compiled_codecomma_r" title="Figure 6-23. For each snippet of compiled code, Ruby uses pointers to track the parent lexical scope and the current class or module.">Figure 6-23</a>.</p><div class="figure"><a id="for_each_snippet_of_compiled_codecomma_r"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00155"/><img alt="For each snippet of compiled code, Ruby uses pointers to track the parent lexical scope and the current class or module." src="httpatomoreillycomsourcenostarchimages1854131.png.jpg"/></div></div><p class="title">Figure 6-23. For each snippet of compiled code, Ruby uses pointers to track the parent lexical scope and the current class or module.</p></div><p><a class="indexterm" id="iddle1193"/><a class="indexterm" id="iddle1213"/><a class="indexterm" id="iddle1694"/><a class="indexterm" id="iddle1713"/><a class="indexterm" id="iddle1715"/><a class="indexterm" id="iddle1810"/><a class="indexterm" id="iddle1812"/>This figure shows the lexical scope information attached to the right side of the Ruby code. There are two important values here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>First, the <code class="literal">nd_next</code> pointer is set to the parent or surrounding lexical scope—the default or top-level scope in this case.</p></li><li class="listitem"><p>Next, the <code class="literal">nd_clss</code> pointer indicates which Ruby class or module corresponds to this scope. In this example, because we just defined <code class="literal">MyClass</code> using the <code class="literal">class</code> keyword, Ruby sets the <code class="literal">nd_clss</code> pointer to the <code class="literal">RClass</code> structure corresponding to <code class="literal">MyClass</code>.</p></li></ul></div><div class="sect2" title="Creating a Constant for a New Class or Module"><div class="titlepage"><div><div><h2 class="title"><a id="creating_a_constant_for_a_new_class_or_m"/>Creating a Constant for a New Class or Module</h2></div></div></div><p>Whenever you create a class or module, Ruby automatically creates a corresponding constant and saves it in the class or module for the parent lexical scope.</p><p>Let’s return to the “namespace” example from <a class="xref" href="ch06.html#using_a_constant_defined_in_the_surround" title="Example 6-19. Using a constant defined in the surrounding namespace">Example 6-19</a>. <a class="xref" href="ch06.html#when_you_declare_a_new_classcomma_ruby_c" title="Figure 6-24. When you declare a new class, Ruby creates a new RClass structure and defines a new constant set to the new class’s name.">Figure 6-24</a> shows what Ruby does internally when you create <code class="literal">MyClass</code> inside <code class="literal">Namespace</code>.</p><div class="figure"><a id="when_you_declare_a_new_classcomma_ruby_c"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00156"/><img alt="When you declare a new class, Ruby creates a new RClass structure and defines a new constant set to the new class’s name." src="httpatomoreillycomsourcenostarchimages1854133.png.jpg"/></div></div><p class="title">Figure 6-24. When you declare a new class, Ruby creates a new <code class="literal">RClass</code> structure and defines a new constant set to the new class’s name.</p></div><p><a class="indexterm" id="iddle1195"/><a class="indexterm" id="iddle1294"/>The dashed arrows in this figure show what actions Ruby takes when you create a new class or module:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>First, Ruby creates a new <code class="literal">RClass</code> structure for the new module or class, as shown at the bottom.</p></li><li class="listitem"><p>Then, Ruby creates a new constant using the new module or class name and saves it inside the class corresponding to the parent lexical scope. Ruby sets the value of the new constant to be a reference or pointer to the new <code class="literal">RClass</code> structure. In <a class="xref" href="ch06.html#when_you_declare_a_new_classcomma_ruby_c" title="Figure 6-24. When you declare a new class, Ruby creates a new RClass structure and defines a new constant set to the new class’s name.">Figure 6-24</a> you can see that the <code class="literal">MyClass</code> constant appears in the constants table for the <code class="literal">Namespace</code> module.</p></li></ul></div><p>The new class also gets its own new lexical scope, as shown in <a class="xref" href="ch06.html#new_class_also_gets_its_own_lexical_sc" title="Figure 6-25. A new class also gets its own lexical scope, shown here as the second shaded rectangle.">Figure 6-25</a>.</p><div class="figure"><a id="new_class_also_gets_its_own_lexical_sc"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00157"/><img alt="A new class also gets its own lexical scope, shown here as the second shaded rectangle." src="httpatomoreillycomsourcenostarchimages1854135.png.jpg"/></div></div><p class="title">Figure 6-25. A new class also gets its own lexical scope, shown here as the second shaded rectangle.</p></div><p>This figure shows a new shaded rectangle for the new scope. Its <code class="literal">nd_clss</code> pointer is set to the new <code class="literal">RClass</code> structure for <code class="literal">MyClass</code>, and its <code class="literal">nd_next</code> pointer is set to the parent scope that corresponds to the <code class="literal">Namespace</code> module.</p></div><div class="sect2" title="Finding a Constant in the Parent Namespace Using Lexical Scope"><div class="titlepage"><div><div><h2 class="title"><a id="finding_a_constant_in_the_parent_namespa"/>Finding a Constant in the Parent Namespace Using Lexical Scope</h2></div></div></div><p>In <a class="xref" href="ch06.html#finding_a_constant_in_the_parent_lexical" title="Example 6-21. Finding a constant in the parent lexical scope (repeated from Example 6-19)">Example 6-21</a> let’s return to the example from <a class="xref" href="ch06.html#using_a_constant_defined_in_the_surround" title="Example 6-19. Using a constant defined in the surrounding namespace">Example 6-19</a>, which prints the value of <code class="literal">SOME_CONSTANT</code>.</p><div class="example"><a id="finding_a_constant_in_the_parent_lexical"/><p class="title">Example 6-21. Finding a constant in the parent lexical scope (repeated from <a class="xref" href="ch06.html#using_a_constant_defined_in_the_surround" title="Example 6-19. Using a constant defined in the surrounding namespace">Example 6-19</a>)</p><div class="example-contents"><pre class="programlisting">    module Namespace
      SOME_CONSTANT = "Some value..."
      class Subclass
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>     p SOME_CONSTANT
      end
    end</pre></div></div><p>In <a class="xref" href="ch06.html#ruby_searches_for_constants_using_the_su" title="Figure 6-20. Ruby searches for constants using the superclass chain, just as it does with methods.">Figure 6-20</a> we saw how Ruby iterates over <code class="literal">super</code> pointers to find a constant from a superclass. But in <a class="xref" href="ch06.html#how_does_ruby_find_constants_in_the_surr" title="Figure 6-21. How does Ruby find constants in the surrounding namespace?">Figure 6-21</a> we saw that Ruby couldn’t use <code class="literal">super</code> pointers to find <code class="literal">SOME_CONSTANT</code> in this example because <code class="literal">Namespace</code> is not a superclass of <code class="literal">MyClass</code>. Instead, as <a class="xref" href="ch06.html#ruby_can_find_someunderscoreconstant_in" title="Figure 6-26. Ruby can find SOME_CONSTANT in the parent lexical scope using the nd_next and nd_clss pointers.">Figure 6-26</a> shows, Ruby can use the <code class="literal">nd_next</code> pointers to iterate up through your program’s lexical scopes in search of constant values.</p><div class="figure"><a id="ruby_can_find_someunderscoreconstant_in"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00158"/><img alt="Ruby can find SOME_CONSTANT in the parent lexical scope using the nd_next and nd_clss pointers." src="httpatomoreillycomsourcenostarchimages1854137.png.jpg"/></div></div><p class="title">Figure 6-26. Ruby can find <code class="literal">SOME_CONSTANT</code> in the parent lexical scope using the <code class="literal">nd_next</code> and <code class="literal">nd_clss</code> pointers.</p></div><p>By following the arrows in this figure, you can see how the <code class="literal">p SOME_CONSTANT</code> command at <span class="inlinemediaobject"><a id="inline_id00209"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> in <a class="xref" href="ch06.html#finding_a_constant_in_the_parent_lexical" title="Example 6-21. Finding a constant in the parent lexical scope (repeated from Example 6-19)">Example 6-21</a> works:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>First, Ruby looks for the value of <code class="literal">SOME_CONSTANT</code> in the current scope’s class, <code class="literal">MyClass</code>. In <a class="xref" href="ch06.html#ruby_can_find_someunderscoreconstant_in" title="Figure 6-26. Ruby can find SOME_CONSTANT in the parent lexical scope using the nd_next and nd_clss pointers.">Figure 6-26</a> the current scope contains the <code class="literal">p SOME_CONSTANT</code> code. You can see how Ruby finds the current scope’s class on the right using the <code class="literal">nd_clss</code> pointer. Here, <code class="literal">MyClass</code> has nothing in its constants table.</p></li><li class="listitem"><p>Next, Ruby finds the parent lexical scope using the <code class="literal">nd_next</code> pointer, moving up <a class="xref" href="ch06.html#ruby_can_find_someunderscoreconstant_in" title="Figure 6-26. Ruby can find SOME_CONSTANT in the parent lexical scope using the nd_next and nd_clss pointers.">Figure 6-26</a>.</p></li><li class="listitem"><p>Ruby repeats the process, searching the current scope’s class using the <code class="literal">nd_clss</code> pointer. This time the current scope’s class is the <code class="literal">Namespace</code> module, at the top right of <a class="xref" href="ch06.html#ruby_can_find_someunderscoreconstant_in" title="Figure 6-26. Ruby can find SOME_CONSTANT in the parent lexical scope using the nd_next and nd_clss pointers.">Figure 6-26</a>. Now Ruby finds <code class="literal">SOME_CONSTANT</code> in <code class="literal">Namespace</code>’s constants table.</p></li></ul></div></div><div class="sect2" title="Ruby’s Constant Lookup Algorithm"><div class="titlepage"><div><div><h2 class="title"><a id="rubyapostrophes_constant_lookup_algorith"/>Ruby’s Constant Lookup Algorithm</h2></div></div></div><p><a class="indexterm" id="iddle1006"/><a class="indexterm" id="iddle1196"/><a class="indexterm" id="iddle1269"/><a class="indexterm" id="iddle1559"/>The flowchart in <a class="xref" href="ch06.html#part_of_rubyapostrophes_constant_lookup" title="Figure 6-27. Part of Ruby’s constant lookup algorithm">Figure 6-27</a> summarizes how Ruby iterates over the lexical scope chain while looking for constants.</p><div class="figure"><a id="part_of_rubyapostrophes_constant_lookup"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00159"/><img alt="Part of Ruby’s constant lookup algorithm" src="httpatomoreillycomsourcenostarchimages1854139.png.jpg"/></div></div><p class="title">Figure 6-27. Part of Ruby’s constant lookup algorithm</p></div><p>Notice that this figure is very similar to <a class="xref" href="ch06.html#rubyapostrophes_method_lookup_al-id00021" title="Figure 6-3. Ruby’s method lookup algorithm">Figure 6-3</a>. Ruby iterates over the linked list formed by the <code class="literal">nd_next</code> pointers in each lexical scope while looking for a constant, just as it iterates over the <code class="literal">super</code> pointers while looking for a method. Ruby uses superclasses to find methods and parent lexical scopes to find constants.</p><p>However, this is just part of Ruby’s constant lookup algorithm. As we saw earlier in <a class="xref" href="ch06.html#ruby_searches_for_constants_using_the_su" title="Figure 6-20. Ruby searches for constants using the superclass chain, just as it does with methods.">Figure 6-20</a>, Ruby also looks through superclasses for constants.</p></div></div><div class="sect1" title="Experiment 6-2: Which Constant Will Ruby Find First?"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_6-2_which_constant_will_ruby"/>Experiment 6-2: Which Constant Will Ruby Find First?</h1></div></div></div><p>We’ve just learned that Ruby iterates over a linked list of lexical scopes in order to look up constant values. However, we saw earlier in <a class="xref" href="ch06.html#ruby_searches_for_constants_using_the_su" title="Figure 6-20. Ruby searches for constants using the superclass chain, just as it does with methods.">Figure 6-20</a> that Ruby also uses the superclass chain to look up constants. Let’s use <a class="xref" href="ch06.html#does_ruby_search_the_lexical_scope_chain" title="Example 6-22. Does Ruby search the lexical scope chain first? Or does it search the superclass chain first? (find-constant.rb)">Example 6-22</a> to see how this works in more detail.</p><div class="example"><a id="does_ruby_search_the_lexical_scope_chain"/><p class="title">Example 6-22. Does Ruby search the lexical scope chain first? Or does it search the superclass chain first? <span class="emphasis"><em>(find-constant.rb)</em></span></p><div class="example-contents"><pre class="programlisting">    class Superclass
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   FIND_ME = "Found in Superclass"
    end

    module ParentLexicalScope
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   FIND_ME = "Found in ParentLexicalScope"

      module ChildLexicalScope

        class Subclass &lt; Superclass
          p FIND_ME
        end

      end
    end</pre></div></div><p><a class="indexterm" id="iddle1007"/><a class="indexterm" id="iddle1197"/><a class="indexterm" id="iddle1560"/>Notice here that I’ve defined the constant <code class="literal">FIND_ME</code> twice—at <span class="inlinemediaobject"><a id="inline_id00212"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> and at <span class="inlinemediaobject"><a id="inline_id00213"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>. Which constant will Ruby find first? Will Ruby first iterate over the lexical scope chain and find the constant at <span class="inlinemediaobject"><a id="inline_id00214"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>? Or will it iterate over the superclass chain and find the constant value at <span class="inlinemediaobject"><a id="inline_id00215"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>?</p><p>Let’s find out! When we run <a class="xref" href="ch06.html#does_ruby_search_the_lexical_scope_chain" title="Example 6-22. Does Ruby search the lexical scope chain first? Or does it search the superclass chain first? (find-constant.rb)">Example 6-22</a>, we get the following:</p><a id="pro_id00036"/><pre class="programlisting">$ <span class="strong"><strong>ruby find-constant.rb</strong></span>
"Found in ParentLexicalScope"</pre><p>You can see that Ruby looks through the lexical scope chain first.</p><p>Now let’s comment out the second definition at <span class="inlinemediaobject"><a id="inline_id00216"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> in <a class="xref" href="ch06.html#does_ruby_search_the_lexical_scope_chain" title="Example 6-22. Does Ruby search the lexical scope chain first? Or does it search the superclass chain first? (find-constant.rb)">Example 6-22</a> and try the experiment again:</p><a id="pro_id00037"/><pre class="programlisting">    module ParentLexicalScope
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   #FIND_ME = "Found in ParentLexicalScope"</pre><p>When we run the modified <a class="xref" href="ch06.html#does_ruby_search_the_lexical_scope_chain" title="Example 6-22. Does Ruby search the lexical scope chain first? Or does it search the superclass chain first? (find-constant.rb)">Example 6-22</a>, we get the following:</p><a id="pro_id00038"/><pre class="programlisting">$ <span class="strong"><strong>ruby find-constant.rb</strong></span>
"Found in Superclass"</pre><p>Because now there is only one definition of <code class="literal">FIND_ME</code>, Ruby finds it by iterating over the superclass chain.</p><div class="sect2" title="Ruby’s Actual Constant Lookup Algorithm"><div class="titlepage"><div><div><h2 class="title"><a id="rubyapostrophes_actual_constant_lookup_a"/>Ruby’s Actual Constant Lookup Algorithm</h2></div></div></div><p>Unfortunately, things aren’t quite so simple; there are some other quirks in Ruby’s behavior with regard to constants. <a class="xref" href="ch06.html#high-level_summary_of_rubyapostrophes" title="Figure 6-28. A high-level summary of Ruby’s constant lookup algorithm">Figure 6-28</a> is a simplified flowchart showing Ruby’s entire constant lookup algorithm.</p><div class="figure"><a id="high-level_summary_of_rubyapostrophes"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00160"/><img alt="A high-level summary of Ruby’s constant lookup algorithm" src="httpatomoreillycomsourcenostarchimages1854141.png.jpg"/></div></div><p class="title">Figure 6-28. A high-level summary of Ruby’s constant lookup algorithm</p></div><p><a class="indexterm" id="iddle1064"/><a class="indexterm" id="iddle1199"/><a class="indexterm" id="iddle1502"/><a class="indexterm" id="iddle1623"/>At the top, you can see that Ruby begins by iterating up the lexical scope chain, as we saw in <a class="xref" href="ch06.html#does_ruby_search_the_lexical_scope_chain" title="Example 6-22. Does Ruby search the lexical scope chain first? Or does it search the superclass chain first? (find-constant.rb)">Example 6-22</a>. Ruby always finds constants, including classes or modules, that are defined in a parent lexical scope. However, as Ruby iterates up the scope chain, it looks to see whether you used the <code class="literal">autoload</code> keyword, which instructs it to open and read in a new code file if a given constant is undefined. (The Rails framework uses <code class="literal">autoload</code> to allow you to load models, controllers, and other Rails objects without having to use <code class="literal">require</code> explicitly.)</p><p>If Ruby loops through the entire lexical scope chain without finding the given constant or a corresponding <code class="literal">autoload</code> keyword, it then iterates up the superclass chain, as we saw in <a class="xref" href="ch06.html#ruby_finds_constants_you_define_in_a_sup" title="Example 6-18. Ruby finds constants you define in a superclass.">Example 6-18</a>. This allows you to load constants defined in a superclass. Ruby once again honors any <code class="literal">autoload</code> keyword that might exist in any of those superclasses, loading an additional file if necessary.</p><p>Finally, if all else fails and the constant still isn’t found, Ruby calls the <code class="literal">const_missing</code> method on your module if you provided one.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00023"/>Summary</h1></div></div></div><p>In this chapter we’ve learned two very different ways to look at your Ruby program. On the one hand, you can organize your code by class and superclass, and on the other, you can organize it by lexical scope. We saw how internally Ruby uses different sets of C pointers to keep track of these two trees as it executes your program. The <code class="literal">super</code> pointers found in the <code class="literal">RClass</code> structures form the superclass tree, while the <code class="literal">nd_next</code> pointers from the lexical scope structures form the namespace or lexical scope tree.</p><p>We studied two important algorithms that use these trees: how Ruby looks up methods and constants. Ruby uses the class tree to find the methods that your code (and Ruby’s own internal code) calls. Similarly, Ruby uses both the lexical scope tree and the superclass hierarchy to find constants that your code refers to. Understanding the method and constant lookup algorithms is essential. They allow you to design your program and organize your code using these two trees in a way that is appropriate for the problem you are trying to solve.</p><p>At first glance, these two organizational schemes seem completely orthogonal, but in fact they are closely related by the way Ruby’s classes behave. When you create a class or module, you add both to the superclass and lexical scope hierarchy, and when you refer to a class or superclass, you instruct Ruby to look up a particular constant using the lexical scope tree.</p></div></div></body></html>