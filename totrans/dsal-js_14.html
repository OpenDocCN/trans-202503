<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch11">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_203" aria-label="203"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch11">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">11</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">BAGS, SETS, AND MAPS</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">In this chapter we’ll consider some widely used abstract data types (ADTs): bags, sets, and maps. A <i>bag</i> is just a collection of values (repeated or not), a <i>set</i> is a collection of <i>distinct</i> values, and a <i>map</i> is a set of key + data pairs. We’ll consider some new ways of implementing these ADTs, starting with JavaScript’s own objects, and then move on to bitmaps, lists, and <i>hashing</i>, a new method we haven’t yet explored.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-51"/><span class="SANS_Futura_Std_Bold_B_11">Introducing Bags, Sets, and Maps</span></h3>&#13;
<p class="TNI1">In <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> we defined the ADT for bags with the set operations shown in <a href="chapter11.xhtml#tab11-1">Table 11-1</a>. (The use of the word <i>set</i> in this context is fully correct according <span role="doc-pagebreak" epub:type="pagebreak" id="pg_204" aria-label="204"/>to its mathematical definition.) When you need to store many (possibly repeated) values, you need a bag.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab11-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 11-1:</span></span> <span class="SANS_Futura_Std_Book_11">Operations on</span> <span class="SANS_Futura_Std_Book_11">Bags</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Signature</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">bag</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create a new bag.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">bag</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a bag, determine whether it is empty.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">bag × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">bag</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a new value, add it to the bag.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">bag × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">bag</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a value, remove it from the bag.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">bag × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a value, check whether it exists in the bag.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">In <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> we had an extra operation to retrieve the greatest value from the bag, but that won’t be considered here because it’s not standard. You could also have an operation to find the current size of the bag, and possibly some more, but these are enough.</p>&#13;
<p class="TX">In some cases you want an actual set, so you don’t want to allow for repeated values, and that restriction calls for a slightly different set of operations, as shown in <a href="chapter11.xhtml#tab11-2">Table 11-2</a>.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab11-2"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 11-2:</span></span> <span class="SANS_Futura_Std_Book_11">Operations on Sets</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Signature</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">set</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create a new set.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">set</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a</span> <span class="SANS_Futura_Std_Book_11">set, determine whether it is empty.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">set × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">set | error</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a new value, add it to the set.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">set × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">set</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a value, remove it from the set.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">set × value</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a value, check whether it exists in the set.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">All operations are the same, except that when you try to add a new value and find that it is already there, you’ll do something different. One possibility is just to ignore the situation (after all, if you want to include a value in the set and the value is already there, everything is fine), or you could throw an error or perform some other action. You could always test beforehand whether the value to be added is in the set already, but it’s usually more efficient to do it when adding.</p>&#13;
<p class="TX">Finally, in some cases you’ll want to store key + data pairs. For example, for an application that uses information about countries, the key might be an ISO 3166 country code (such as <span class="SANS_TheSansMonoCd_W5Regular_11">CH</span> for Switzerland, <span class="SANS_TheSansMonoCd_W5Regular_11">TV</span> for Tuvalu, or <span class="SANS_TheSansMonoCd_W5Regular_11">UY</span> for Uruguay), and the data could be the country name, its population, and so on. Having implemented sets, implementing maps is simple. Instead of storing single values, you would store objects with key + data and make changes so <i>find</i> and <i>remove</i> work with just keys; the former returns the data if found instead of a boolean. See <a href="chapter11.xhtml#tab11-3">Table 11-3</a> for all operations.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab11-3"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_205" aria-label="205"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 11-3:</span></span> <span class="SANS_Futura_Std_Book_11">Operations on Maps</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Signature</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">map</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create a new map.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Empty?</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">map</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">boolean</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a map, determine if it is empty.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">map × (key + data)</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">map | error</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a new key + data, add it to the map.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">map × key</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">map</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Given a key, remove it from the map.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">map × key</span> <span class="symbol">→</span> <span class="SANS_Futura_Std_Book_11">data | undefined</span></p></td>&#13;
<td class="TBL"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Given a key, check whether it exists in the map, and if found, return the data or undefined instead.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">All of these changes are fairly straightforward to do, so we’ll work with plain bags and sets. Let’s now consider specific implementations, starting with JavaScript’s own.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-52"/><span class="SANS_Futura_Std_Bold_B_11">JavaScript’s Solutions for Sets</span></h3>&#13;
<p class="TNI1">You learned how to implement a bag in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> using several different methods. With a few changes, you can implement sets instead of bags; all you need to do is before adding a new value, check whether it was already present. In this section we’ll consider two more ways to implement sets in JavaScript: using plain objects (which is not the best way) and using standard set objects.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-85"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Objects as Sets</span></h4>&#13;
<p class="TNI1">Even if objects aren’t designed to be used as sets (or maps), many developers use plain objects for them. If you can use values as attributes (mostly strings or numbers converted to strings), you can use them as property names:</p>&#13;
<pre id="pre-174"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const mySet = {};&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> mySet.one = 1;&#13;
mySet.two = 2;</code></pre>&#13;
<p class="TX">In plain JavaScript, creating an object means assigning an empty object <span class="CodeAnnotation" aria-label="annotation1">❶</span> and adding values to it <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Here, you now have a set with two keys: <span class="SANS_TheSansMonoCd_W5Regular_11">one</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">two</span>. (If you want a map, the values associated with those keys are the data.)</p>&#13;
<p class="TX">You can test whether a key is in the object with the <span class="SANS_TheSansMonoCd_W5Regular_11">in</span> operator:</p>&#13;
<pre id="pre-175"><code>"two" in mySet;   // true&#13;
"three" in mySet; // false</code></pre>&#13;
<p class="TX">Finally, you can use <span class="SANS_TheSansMonoCd_W5Regular_11">delete</span> to remove a key:</p>&#13;
<pre id="pre-176"><code>delete mySet.two;</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_206" aria-label="206"/>As extra operations, you can get a list of all an object’s attributes with <span class="SANS_TheSansMonoCd_W5Regular_11">Object.keys(...)</span>, and you can even iterate over them with <span class="SANS_TheSansMonoCd_W5Regular_11">for...in</span>.</p>&#13;
<p class="TX">Using plain JavaScript objects obviously works, but you probably will want to make your intentions clearer for more understandable code and use a proper set, which, after all, directly represents the data structure you want.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-86"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Set Objects</span></h4>&#13;
<p class="TNI1">Sets are objects that let you store unique values. Creating a new JavaScript set and adding a couple of values is straightforward; try redoing the examples from the previous section:</p>&#13;
<pre id="pre-177"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const mySet = new Set();&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> mySet.add("one");&#13;
mySet.add("two");</code></pre>&#13;
<p class="TX">Create a set by producing a new instance of the <span class="SANS_TheSansMonoCd_W5Regular_11">Set</span> class <span class="CodeAnnotation" aria-label="annotation1">❶</span> and add values to it with its <span class="SANS_TheSansMonoCd_W5Regular_11">.add(...)</span> method <span class="CodeAnnotation" aria-label="annotation2">❷</span>. By the way, you can chain calls, so you can write those two additions on a single line:</p>&#13;
<pre id="pre-178"><code>mySet.add("one").add("two");</code></pre>&#13;
<p class="TX">To test whether a value is in the set, use a <span class="SANS_TheSansMonoCd_W5Regular_11">.has(...)</span> method:</p>&#13;
<pre id="pre-179"><code>mySet.has("two");   // true&#13;
mySet.has("three"); // false</code></pre>&#13;
<p class="TX">Finally, you can remove values with the <span class="SANS_TheSansMonoCd_W5Regular_11">.delete(...)</span> method:</p>&#13;
<pre id="pre-180"><code>mySet.delete("two");</code></pre>&#13;
<p class="TX">JavaScript’s sets have a couple of extra interesting methods. To remove all values, you can use set<span class="SANS_TheSansMonoCd_W5Regular_11">.clear()</span>. You also can find the number of elements in a set using the <span class="SANS_TheSansMonoCd_W5Regular_11">.size</span> property.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h1-53"/><span class="SANS_Futura_Std_Bold_B_11">Bitmaps</span></h3>&#13;
<p class="TNI1">In some cases you can implement sets by making do with bitmaps (recall the bitmap sort from <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>). If the values to store are numbers with a restricted range of values, an array of boolean flags will suffice.</p>&#13;
<p class="TX">We won’t see the code here, as it’s directly based upon the sorting you learned in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. The main idea is to set up an array filled with <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> values. The index to that array is the value itself. To add a value, set its flag to <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>; to remove it, reset its flag to <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>. Finally, to test whether a value is in the set, check the corresponding flag. You can’t do any better.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_207" aria-label="207"/>&#13;
<h3 class="H1" id="sec6"><span id="h1-54"/><span class="SANS_Futura_Std_Bold_B_11">Using Lists</span></h3>&#13;
<p class="TNI1">We discussed lists in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, and you can adapt them to work as bags or sets. Consider three distinct possibilities:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b>Ordered lists </b>Plain lists that keep their values in ascending order</p>&#13;
<p class="RunInPara"><b>Skip lists </b>Two-dimensional structures with fast searches</p>&#13;
<p class="RunInPara"><b>Self-organizing lists </b>Interesting applications that work for caches and similar situations</p>&#13;
</div>&#13;
<p class="TX">Note that some of the solutions you’ll consider in the “<span class="Xref">Hashing</span>” section on page <span class="Xref">218</span> will also use lists.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-87"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Ordered Lists</span></h4>&#13;
<p class="TNI1">As mentioned in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, the concept of an ordered list is simple: instead of always adding values at one extreme or the other, you’ll add them so the values remain in order. This practice slows down insertions (you have to look for the right place to add the new value), but it makes for faster searches on average (when you reach a higher value than the one you wanted, you can stop the search). Take a look at the implementation.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h5 class="H3" id="sec8"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Searching for a Value in an Ordered List</span></h5>&#13;
<p class="TNI1">The logic for searching is as direct as it gets: start at the beginning and follow the links until you reach the value or learn that the value isn’t there, because you either reached the end of the list or found a greater value than the one you wanted. <a href="chapter11.xhtml#fig11-1">Figure 11-1</a> shows how you’d (successfully) look for value 22 in an ordered list.</p>&#13;
<figure class="IMG"><img class="img7" id="fig11-1" src="../images/Figure11-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-1: A successful search for a value (22) in a list</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This works the same way as linear searching (<span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>). Start at the head of the list and keep going. In this case you found the value you wanted, so you succeeded. If you were searching for 20 instead, at this same point you’d have given up the search. If you reach a value that’s higher than what you wanted, the search has failed.</p>&#13;
<p class="TX">The other possibility for failure is searching past the end of the list; see <a href="chapter11.xhtml#fig11-2">Figure 11-2</a>, which shows a search for 86.</p>&#13;
<figure class="IMG"><img class="img7" id="fig11-2" src="../images/Figure11-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-2: A failed search for a value (86) in a list</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_208" aria-label="208"/>The code for a linear search is as follows:</p>&#13;
<pre id="pre-181"><code>const find = (list, valueToFind) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(list) || valueToFind &lt; list.value) {&#13;
   return false;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else if (valueToFind === list.value) {&#13;
   return true;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else {&#13;
   // valueToRemove &gt; list.value&#13;
   return find(list.next, valueToFind);&#13;
 }&#13;
};</code></pre>&#13;
<p class="TX">If you got an empty list—either it was empty from the beginning or you traveled down it and reached its end (you saw the code for this in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>)—you know the value isn’t there. It also isn’t there if the list isn’t empty but its first value is greater than the value you’re seeking <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the list isn’t empty and its first element matches the value you want <span class="CodeAnnotation" aria-label="annotation2">❷</span>, the value was found. Finally, if the list isn’t empty and the value you want is greater than the first element of the list <span class="CodeAnnotation" aria-label="annotation3">❸</span>, continue the search starting at the next node of the list.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h5 class="H3" id="sec9"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Adding a New Value to an Ordered List</span></h5>&#13;
<p class="TNI1">To add a new value, first do a search until you reach the place where the new value should go (meaning between a node with a smaller value and a node with a greater one), and then change a couple of pointers to include the new value in the list. <a href="chapter11.xhtml#fig11-3">Figure 11-3</a> shows how to add 20 to the list.</p>&#13;
<figure class="IMG"><img class="img7" id="fig11-3" src="../images/Figure11-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-3: Adding a new value (20) to an ordered list</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you want to add a value that’s smaller than the one at the head of the list, you’ll need to change the pointer to the list itself. Another border case is adding a value greater than the last one in the list; you have to be careful when going down the list. You can use recursion to implement all of these cases more easily:</p>&#13;
<pre id="pre-182"><code>const add = (list, valueToAdd) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(list) || valueToAdd &lt; list.value) {&#13;
   list = {value: valueToAdd, next: list};&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_209" aria-label="209"/><span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else {&#13;
 <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> list.next = add(list.next, valueToAdd);&#13;
 }&#13;
 return list;&#13;
};</code></pre>&#13;
<p class="TX">The logic is similar to what you saw for the linear search. If the list is empty, or if it’s not empty but the first value is greater than the one you want to add <span class="CodeAnnotation" aria-label="annotation1">❶</span>, create a single node with the new value whose <span class="SANS_TheSansMonoCd_W5Regular_11">next</span> pointer points to the list you had. (This covers the case of adding a value past the end; can you see how?) If you want to make a set, add a test <span class="CodeAnnotation" aria-label="annotation2">❷</span>, because if you find the value you want to add, you would throw an error or otherwise reject the operation. If you’re making a bag and the value to add is greater than the first of the list <span class="CodeAnnotation" aria-label="annotation3">❸</span>, add it using recursion, after the first element.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h5 class="H3" id="sec10"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Removing a Value from an Ordered List</span></h5>&#13;
<p class="TNI1">Removing a value is a matter of finding it (which you already know how to do) and then modifying its predecessor’s link to point at the next value, as shown in <a href="chapter11.xhtml#fig11-4">Figure 11-4</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig11-4" src="../images/Figure11-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-4: Removing the value (22) from an ordered list</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As mentioned, do a search, and if it’s successful, skip the value to be removed. The only unusual case is when you delete the head of the list, you need to modify the pointer to the list:</p>&#13;
&#13;
<pre id="pre-183"><code>const remove = (list, valueToRemove) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(list) || valueToRemove &lt; list.value) {&#13;
   return list;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else if (valueToRemove === list.value) {&#13;
   return list.next;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else {&#13;
   // valueToRemove &gt; list.value&#13;
   list.next = remove(list.next, valueToRemove);&#13;
   return list;&#13;
 }&#13;
};</code></pre>&#13;
<p class="TX">The logic fully matches the search, case by case. It’s also logical; you must first find the value before you can remove it from the list. If the list is empty or if its first value is greater than the value <span class="CodeAnnotation" aria-label="annotation1">❶</span>, return the list as-is, because there’s nothing to remove. If the value to remove is at the head of the list <span class="CodeAnnotation" aria-label="annotation2">❷</span>, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_210" aria-label="210"/>return the list’s tail, skipping the value to be removed. Finally, if the value to be removed is greater than the head of the list <span class="CodeAnnotation" aria-label="annotation3">❸</span>, proceed recursively to delete the value from the tail of the list and return the (updated) list.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h5 class="H3" id="sec11"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Considering Performance for Ordered Lists</span></h5>&#13;
<p class="TNI1">There’s no way to speed up any of the processes, and if the list has <i>n</i> nodes, all functions are <i>O</i>(<i>n</i>). On average, all operations will visit half the nodes of the list. This implementation is good enough for small values of <i>n</i>, but for larger values, you’ll need something that allows you to move faster through the list—and in the next section we’ll see just that.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-88"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Skip Lists</span></h4>&#13;
<p class="TNI1">As just mentioned, searching a list is an <i>O</i>(<i>n</i>) process, because there’s no way to speed things up and move faster. However, you can take a tip from the jump search method (<span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>). What would happen if you could take long jumps to skip many places quickly, and when you get closer to the needed value, start doing smaller jumps, and then even smaller ones, until you finish with a one-by-one search? In this section we’ll consider <i>skip lists</i>, which allow you to traverse a list much more quickly by providing ways to skip ahead faster.</p>&#13;
<p class="TX">Consider an ordered list as shown in <a href="chapter11.xhtml#fig11-5">Figure 11-5</a> (for clarity, I haven’t included the arrows; all go from left to right).</p>&#13;
<figure class="IMG"><img class="img1" id="fig11-5" src="../images/Figure11-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-5: Searching a long list is logically slower.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As is, you can’t jump quickly as with a jump search, but with an auxiliary second list, doing so is possible, as shown in <a href="chapter11.xhtml#fig11-6">Figure 11-6</a> (the vertical lines indicate pointers from top to bottom).</p>&#13;
<figure class="IMG"><img class="img1" id="fig11-6" src="../images/Figure11-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-6: Adding a second list to advance faster when searching the list</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you wanted to search for 42, you’d start at the topmost list and move right until you get past 42; then you’d go back and down and continue the search (see <a href="chapter11.xhtml#fig11-7">Figure 11-7</a>).</p>&#13;
<figure class="IMG"><img class="img1" id="fig11-7" src="../images/Figure11-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-7: Searching for a value (42) with the aid of the second list</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_211" aria-label="211"/>The topmost list, which includes only a few values of the bottom list, allows you to make longer jumps, so the searches are speedier. Of course, for even faster processes, you could have three or more levels, as shown in <a href="chapter11.xhtml#fig11-8">Figure 11-8</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig11-8" src="../images/Figure11-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-8: A third list helps speed up the search even more.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This works well and provides better expected performance of <i>O</i>(log <i>n</i>). However, having all of these lists with repeated values everywhere isn’t good in practice. It would be better to have each value only once in a node with several pointers, according to the different levels, as shown in <a href="chapter11.xhtml#fig11-9">Figure 11-9</a>. (In reality, all nodes could have the same number of pointers, but <a href="chapter11.xhtml#fig11-9">Figure 11-9</a> shows only the used ones.)</p>&#13;
<figure class="IMG"><img class="img1" id="fig11-9" src="../images/Figure11-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-9: An actual implementation of skip lists, with several pointers per node</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We’ll use this style of search to simplify our work. We’ll also add some sentinel nodes at the beginning and end of the lists to simplify all logic. You won’t ever have cases like “adding at the beginning” or “adding at the end,” because no value can be lower than the first sentinel or higher than the last one. Also, you won’t have to deal with empty lists (at least the sentinels will be there), and you’ll never go past the last item of a list.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h5 class="H3" id="sec13"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Creating a Skip List</span></h5>&#13;
<p class="TNI1">An empty list will consist of a node with two sentinels: a minus infinity value and a single level with a plus infinity value. Implementing it is as follows:</p>&#13;
<pre id="pre-184"><code>const newSkipList = () =&gt; ({&#13;
  value: -Infinity,&#13;
  next: [{value: Infinity, next: [null]}]&#13;
});</code></pre>&#13;
<p class="TX">You have a list with just two values: <span class="SANS_TheSansMonoCd_W5Regular_11">-Infinity</span> first and <span class="SANS_TheSansMonoCd_W5Regular_11">Infinity</span> last. (You are working with numeric values here; for strings, you’d have to use appropriate low and high strings.) The skip list is flat, having just one level. (No <span role="doc-pagebreak" epub:type="pagebreak" id="pg_212" aria-label="212"/><span class="SANS_TheSansMonoCd_W5Regular_11">next</span> array has more than one element.) Knowing this, testing whether a skip list is empty is a tad more complex:</p>&#13;
<pre id="pre-185"><code>const isEmpty = (sl) =&gt; sl.next[0].next[0] === null;</code></pre>&#13;
<p class="TX">If a skip list doesn’t have any values added to it, you’ll have the initial configuration, so your sentinels will be on the bottom level. In this data structure, the only value that has a null pointer to the next is the <span class="SANS_TheSansMonoCd_W5Regular_11">+Infinity</span> sentinel; all other nodes have non-null pointers.</p>&#13;
<p class="TX">You can find how many levels a skip list has by simply looking at the length of the <span class="SANS_TheSansMonoCd_W5Regular_11">next</span> arrays. Another function that will come in handy just returns the last index of the array of pointers:</p>&#13;
<pre id="pre-186"><code>const _level = (sl) =&gt; sl.next.length - 1;</code></pre>&#13;
<p class="TX">You have to subtract 1 because the array of pointers is zero indexed, as usual.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h5 class="H3" id="sec14"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Searching for a Value in a Skip List</span></h5>&#13;
<p class="TNI1">You saw the general idea for searches earlier, but now consider how they’d work with the actual implementation. Searches begin at the topmost level and advance to the right unless they go past the searched-for value, in which case they go down a level. If there are no more levels, the search is a failure.</p>&#13;
<p class="TX">The code isn’t very long, but dealing with multiple levels requires care:</p>&#13;
<pre id="pre-187"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const _find = (node, currLevel, valueToFind) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (currLevel &lt; 0) {&#13;
   return false;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else if (valueToFind === node.value) {&#13;
   return true;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span>} else if (valueToFind &gt;= node.next[currLevel].value) {&#13;
   return _find(node.next[currLevel], currLevel, valueToFind);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span>} else {&#13;
   return _find(node, currLevel - 1, valueToFind);&#13;
 }&#13;
};&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span> const find = (sl, valueToFind) =&gt; _find(sl, _level(sl), valueToFind);</code></pre>&#13;
<p class="TX">We’ll use an auxiliary recursive function for the search. This function has three arguments: a node (somewhere in the skip list), the level at which it is searching, and the value to find <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If you try to go below level 0 <span class="CodeAnnotation" aria-label="annotation2">❷</span>, you’ve failed, as you were at the bottom level and couldn’t find the value there. If the node has the value that you want <span class="CodeAnnotation" aria-label="annotation3">❸</span>, the search succeeded. If the value you want is greater than or equal to the next value at the same level <span class="CodeAnnotation" aria-label="annotation4">❹</span>, keep going without changing level. Otherwise, if you’ve already reached a higher value <span class="CodeAnnotation" aria-label="annotation5">❺</span>, go down to the next level. The implementation of a general search <span class="CodeAnnotation" aria-label="annotation6">❻</span> starts at the first node at the top level.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_213" aria-label="213"/>&#13;
<h5 class="H3" id="sec15"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Adding a Value to a Skip List</span></h5>&#13;
<p class="TNI1">We haven’t really discussed how to decide what values go at which levels. The solution we’ll use is based on random numbers. Obviously, all values will be at the bottom level, but they all won’t be at the other levels. We’ll decide whether a new value goes up one level by “flipping a coin”; we want approximately 50 percent of values to be in the next level. We’ll keep deciding randomly whether to move the value up one more level until the flip fails or you get a maximum level. In the code that follows, set <span class="SANS_TheSansMonoCd_W5Regular_11">MAX_LEVEL</span> to 32, which implies that, on average, one value out of 2<sup>³²</sup> will go that high—a really big structure!</p>&#13;
<p class="TX">We’ll require an auxiliary function to add a value at a certain level and all levels below it. An obvious question is why do you first add the value at a higher level and then at lower levels? Lists that are higher up have fewer elements, so insertions are faster there. Here’s the code:</p>&#13;
<pre id="pre-188"><code>const _add = (currNode, currLevel, newNode, newLevel) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (newNode.value &gt; currNode.next[currLevel].value) {&#13;
    _add(currNode.next[currLevel], currLevel, newNode, newLevel);&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (currLevel &lt;= newLevel) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> newNode.next[currLevel] = currNode.next[currLevel];&#13;
      currNode.next[currLevel] = newNode;&#13;
    }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if (currLevel &gt; 0) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> _add(currNode, currLevel - 1, newNode, newLevel);&#13;
    }&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">If the new value is greater than the next value at this level <span class="CodeAnnotation" aria-label="annotation1">❶</span>, you must advance; you’ll be able to add the new value when it lies between two consecutive values in the list. If you’re at a level lower than or equal to the maximum new level <span class="CodeAnnotation" aria-label="annotation2">❷</span>, add the value and adjust the pointers to include the new value in the list <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Finally, if you haven’t reached bottom yet <span class="CodeAnnotation" aria-label="annotation4">❹</span>, use recursion to add the value one level down <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">With this function, adding a value is as follows:</p>&#13;
<pre id="pre-189"><code>const add = (sl, valueToAdd) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> let newLevel = 0;&#13;
  while (newLevel &lt; MAX_LEVEL &amp;&amp; Math.random() &gt; 0.5) {&#13;
    newLevel++;&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const newNode = {value: valueToAdd, next: new Array(newLevel)};&#13;
&#13;
  let currLevel = _level(sl);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> while (newLevel &gt;= currLevel) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> sl.next[currLevel].next.push(null);&#13;
    sl.next.push(sl.next[currLevel]);&#13;
    currLevel++;&#13;
  }&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_214" aria-label="214"/><span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> _add(sl, currLevel, newNode, newLevel);&#13;
  return sl;&#13;
};</code></pre>&#13;
<p class="TX">First, decide up to which level you’ll find the new node <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Going up one more level will depend on the “coin flip.” After deciding that <span class="CodeAnnotation" aria-label="annotation2">❷</span>, create a node with the value and an array with the right number of pointers. There’s the possibility that you’re going “higher” than before <span class="CodeAnnotation" aria-label="annotation3">❸</span> and that the skip list will be taller. If so <span class="CodeAnnotation" aria-label="annotation4">❹</span>, you’ll have to add new pointers to the rightmost value. After this is taken care of <span class="CodeAnnotation" aria-label="annotation5">❺</span>, use the auxiliary function to add the value to all the corresponding lists.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h5 class="H3" id="sec16"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Removing a Value from a Skip List</span></h5>&#13;
<p class="TNI1">Removing a value requires two steps: first, remove it from all the lists it’s in, which you’ll do with an auxiliary function, and than possibly make the skip list “shorter” because by removing the value, it may not be as tall as before.</p>&#13;
<p class="TX">Here’s the logic for actually removing the value:</p>&#13;
<pre id="pre-190"><code>const _remove = (currNode, currLevel, valueToRemove) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (valueToRemove &gt; currNode.next[currLevel].value) {&#13;
    _remove(currNode.next[currLevel], currLevel, valueToRemove);&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (valueToRemove === currNode.next[currLevel].value) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> currNode.next[currLevel] = currNode.next[currLevel].next[currLevel];&#13;
    }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if (currLevel &gt; 0) {&#13;
      _remove(currNode, currLevel - 1, valueToRemove);&#13;
    }&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">Advance down the list <span class="CodeAnnotation" aria-label="annotation1">❶</span> until you find where the value should be. If you actually found it <span class="CodeAnnotation" aria-label="annotation2">❷</span> (the user may be asking to remove a value that simply isn’t in the list), fix the pointers <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Then keep doing removals until you reach the bottom level <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">Removing the value is the first step, as described; you may have to restructure multiple levels after that:</p>&#13;
<pre id="pre-191"><code>const remove = (sl, valueToRemove) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> _remove(sl, _level(sl), valueToRemove);&#13;
  for (&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> let level = _level(sl) – 1;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> level &gt; 0 &amp;&amp; sl.next[level].next[level] === null;&#13;
    level--&#13;
  ) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> sl.next[level].next.splice(level, 1);&#13;
    sl.next.splice(level, 1);&#13;
  }&#13;
  return sl;&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_215" aria-label="215"/>After removing the value <span class="CodeAnnotation" aria-label="annotation1">❶</span>, go down all levels from the top <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and while the lists are basically empty (only the sentinels) <span class="CodeAnnotation" aria-label="annotation3">❸</span>, you’ve made the list shorter <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h5 class="H3" id="sec17"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Considering</span> <span class="SANS_Futura_Std_Bold_Condensed_B_11">Performance for Skip Lists</span></h5>&#13;
<p class="TNI1">Skip lists are probabilistic in nature, and the average performance can be shown to be logarithmic (see <a href="chapter11.xhtml#tab11-4">Table 11-4</a>).</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab11-4"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 11-4:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Skip Lists</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Average performance</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Worst case</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(log</span> <span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">There is a quite low probability that the structure will behave badly (maybe having just a single level or having most values at all levels), but that’s not likely.</p>&#13;
<p class="TX">As with hashing (which you’ll explore later in this chapter) and other structures, you can solve performance problems by restructuring the skip list; see question 11.4 for a possible idea. You can also modify the list to allow retrieving a value by position; see question 11.5.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2" id="sec18"><span id="h2-89"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Self-Organizing Lists</span></h4>&#13;
<p class="TNI1">There’s a particular case for which you can use an “auto-modified” bag successfully. Think about a cache with a limited maximum size. It’s not infrequent that one may require a given element several times in a short interval and then for a long time may not require it at all. In that case you can use a self-organizing list that places the elements required most often near the beginning (for quicker searches) and the ones required less often near the end (allowing a slower search).</p>&#13;
<p class="TX">As an example, think of a mapping (Global Positioning System [GPS]–style) application. You can’t hold every street name in memory, but to optimize speed, you could have a small cache of street names. Traveling in a certain zone, one often requires a certain group of street names, and it’s more unlikely one will need to find streets much farther away. The idea of a self-organizing list is to always add new values at the front, and if you search for a value and find it, move it to the front with the idea that if you soon require it again, you’ll get to it in a few steps.</p>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h5 class="H3" id="sec19"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Searching for a Value in a Self-Organizing List</span></h5>&#13;
<p class="TNI1">Searching an unordered list is not hard; you just have to keep going until you either find the value or reach the end of the list. You saw how to do this kind of search in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span> (see the section “<span class="Xref">Implementing Lists with</span> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_216" aria-label="216"/><span class="Xref">Dynamic Memory</span>” on page <span class="Xref">180</span>). The important detail is what to do if you find the element. Make it the head of the list and take it out of its original place. <a href="chapter11.xhtml#fig11-10">Figure 11-10</a> shows an example search for 12.</p>&#13;
<figure class="IMG"><img class="img7" id="fig11-10" src="../images/Figure11-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-10: After a successful search in a self-organizing list, the found node is brought to the head of the list.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">First, do a search for 12 (this is nothing new), but after finding it, there are some changes. Since the value wasn’t already at the head of the list, you’ll restructure the list so 12 is at the head, pointing to the old head of the list. If in the future you need to search for it again, those searches will be quite fast, because the value will be either at the head of the list or very close.</p>&#13;
<p class="TX">The code is as follows:</p>&#13;
<pre id="pre-192"><code>const findMTF = (list, keyToFind) =&gt; {&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation1">❶</span> if (isEmpty(list)) {&#13;
    return [list, false];&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation2">❷</span>} else if (list.value === keyToFind) {&#13;
    return [list, true];&#13;
  } else {&#13;
 <span class="Code_CodeAnnotation1" aria-label="annotation3">❸</span> let [prev, curr] = [list, list.next];&#13;
 <span class="Code_CodeAnnotation1" aria-label="annotation4">❹</span> while (!isEmpty(curr) &amp;&amp; curr.value !== keyToFind) {&#13;
     [prev, curr] = [curr, curr.next];&#13;
   }&#13;
&#13;
 <span class="Code_CodeAnnotation1" aria-label="annotation5">❺</span> if (isEmpty(curr)) {&#13;
     return [list, false];&#13;
 <span class="Code_CodeAnnotation1" aria-label="annotation6">❻</span>} else {&#13;
     [prev.next, curr.next] = [curr.next, list];&#13;
     return [curr, true];&#13;
   }&#13;
 }&#13;
};</code></pre>&#13;
<p class="TX">When you search now you’re also modifying the list, so you’ll have to return two values: the list itself (which was possibly updated if the value was found) and a boolean value with the result of the search. (Too much bother? See question 11.3.) If the list is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, return the list and <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>, because trivially the value isn’t there. If the list isn’t empty and the value you want is at the list’s head <span class="CodeAnnotation" aria-label="annotation2">❷</span>, you don’t have to change the list, so you return it as is, plus <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> because you succeeded. If the list isn’t empty and <span role="doc-pagebreak" epub:type="pagebreak" id="pg_217" aria-label="217"/>the value you want isn’t at the list’s head <span class="CodeAnnotation" aria-label="annotation3">❸</span>, set up a loop in which <span class="SANS_TheSansMonoCd_W5Regular_11">prev</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">curr</span> will point to consecutive nodes in the list. That loop will finish when either you get to the list’s end or you find the value you want <span class="CodeAnnotation" aria-label="annotation4">❹</span>. In the case of the former condition <span class="CodeAnnotation" aria-label="annotation5">❺</span>, return the list and a <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> value, just as when the list is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>; if the latter <span class="CodeAnnotation" aria-label="annotation6">❻</span>, change pointers and return the current node as the new list’s head, plus <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h5 class="H3" id="sec20"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Adding a Value to a Self-Organizing List</span></h5>&#13;
<p class="TNI1">Since these lists are unordered, you can add values anywhere, using the simple logic you’ve used before:</p>&#13;
<pre id="pre-193"><code>const add = (list, valueToAdd) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> list = {value: valueToAdd, next: list};&#13;
  return list;&#13;
};</code></pre>&#13;
<p class="TX">Putting the new value at the top of the list, as its head, is as simple as can be. Make a new node that points to the old list <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and the new list has that node as its head. This code is functionally equivalent to the <span class="SANS_TheSansMonoCd_W5Regular_11">push(...)</span> method that you wrote for stacks in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h5 class="H3" id="sec21"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Removing a Value from a Self-Organizing List</span></h5>&#13;
<p class="TNI1">Earlier we saw how to remove a value from an ordered list. Doing the same with an unordered list is not very different, except that you may always have to go to the end of the list, because there’s no way to stop the search earlier. You already saw how to do the search in an iterative way, so now do this recursively:</p>&#13;
<pre id="pre-194"><code>const remove = (list, valueToRemove) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(list)) {&#13;
   return list;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else if (valueToRemove === list.value) {&#13;
   return list.next;&#13;
 } else {&#13;
 <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> list.next = remove(list.next, valueToRemove);&#13;
   return list;&#13;
 }&#13;
};</code></pre>&#13;
<p class="TX">If the list is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, just return it, because the value to be removed isn’t there. If the value you want to remove is the one the list points at <span class="CodeAnnotation" aria-label="annotation2">❷</span>, returning the tail of the list (which <span class="SANS_TheSansMonoCd_W5Regular_11">list.next</span> points to) causes the removal. Finally, if the head of the list doesn’t have the value you want <span class="CodeAnnotation" aria-label="annotation3">❸</span>, make that node point to the result of removing the value from the tail of the list.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h5 class="H3" id="sec22"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Considering Performance and</span> <span class="SANS_Futura_Std_Bold_Condensed_B_11">Variants for Self-Organizing Lists</span></h5>&#13;
<p class="TNI1">This structure’s performance is <i>O</i>(<i>n</i>), as with common lists, and a search looks at <i>n</i>/2 elements on average. However, in actual experience with <span role="doc-pagebreak" epub:type="pagebreak" id="pg_218" aria-label="218"/>clustered requirements, it behaves much better, with far fewer looks at elements. It’s not a theoretical advantage, but a fully empirical, pragmatic one, and in the worst case, you are no worse off.</p>&#13;
<p class="TX">There are other variants with similar performance. The “move to front” (MTF) solution is not the only possible one. Another possibility is “swap with previous” in which instead of moving the found element to the head of the list, you just swap it with the one before, making it closer to the head. If you make many searches for a given value, it eventually reaches the front of the list, but if the search was just a one-off case, then it stays around where it was.</p>&#13;
<p class="TX">Another variant is to add a count of references to each value, increment it by 1 every time a value is searched for and found, and move it nearer the head of the list so that the values are in descending order of counts.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h3 class="H1" id="sec23"><span id="h1-55"/><span class="SANS_Futura_Std_Bold_B_11">Hashing</span></h3>&#13;
<p class="TNI1">In this section we’ll move on to a different concept that potentially provides the fastest possible searches: <i>hashing</i>. The idea of hashing is somewhat related to bitmaps. If the values to be stored in the set are taken from a small range, you can use a bitmap, which provides <i>O</i>(1) searches, as you saw. However, if the values are from a very large range (for instance, US Social Security Numbers, nine digits long, with 1,000,000,000 possible values), a bitmap becomes prohibitive because of the needed space. In addition, it’s most likely that you’ll be dealing with a very small percentage of all possible keys. The idea is to first use an array of <i>slots</i> to store values, but then instead of using the key as an index (as in bitmaps), you’ll compute a hash of the value and use that hash as the index.</p>&#13;
<p class="TX">In reference to a hash, Ambrose Bierce said, “There’s no definition for this word—nobody knows what [a] hash is.” For us, a hash is any function that transforms a value—numeric, string, and so on—into a number in a given range. For the Social Security number example, to get a hash between 000 and 999, you could just take the three final numbers. To get a hash between 0 and a top number <i>K</i>, dividing values by <i>K</i> and taking the remainder would do. There are many ways to compute hashes, but we’ll use the remainder function, like the following:</p>&#13;
<pre id="pre-195"><code>const hash = (ht, value) =&gt; value % ht.slots.length;</code></pre>&#13;
<p class="TX">When using hashing to decide where to store (or look for) a value, we first compute the hash and then go to the corresponding slot in the array (see <a href="chapter11.xhtml#fig11-11">Figure 11-11</a>). It’s quite similar to what we did with bitmaps, but in that case, we used the key as an index; here we assume that the number of possible keys is exceedingly large, so we apply hashing to reduce it to a manageable value.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_219" aria-label="219"/>&#13;
<figure class="IMG"><img class="img5" id="fig11-11" src="../images/Figure11-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-11: In hashing, a hash function is used to decide where a value should be stored in a table.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If the value you want occupies the slot, you’ve found it. If the slot is free, you know for sure that the value isn’t in the set. But how do you deal with different values that produce the same hash, so that all should go in the same slot? This situation is called a <i>collision</i>, and you must specify how to solve it. (If you think this isn’t likely, try searching for “Birthday Paradox” online; you’ll be surprised!) Different hashing strategies differ in how they handle collisions. This chapter will discuss three distinct strategies: buckets with chaining, open addressing, and double hashing. The implementations will be bags, but we’ll consider how to do sets in the questions at the end of the chapter.</p>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h4 class="H2" id="sec24"><span id="h2-90"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Hashing with Chaining</span></h4>&#13;
<p class="TNI1">A first solution to collisions is to consider each slot as a bucket into which you may place multiple values. The simplest way to implement this is by taking advantage of the ordered lists you saw earlier in the chapter, and most of the work will already be done for you. All values that go into the slot are placed in a list, and you’ll work with a small set of numbers for simplicity. <a href="chapter11.xhtml#fig11-12">Figure 11-12</a> shows slots at the left (slot #3 is unoccupied) and the lists at the right.</p>&#13;
<figure class="IMG"><img class="img5" id="fig11-12" src="../images/Figure11-12.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-12: Hashing with chaining uses lists for values that hash to the same value.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_220" aria-label="220"/>To search for a value, first compute in which slot to look for it (which in this case means finding the remainder of the value divided by 5, the table’s length) and then search the corresponding list. If the value is in the set, you should find it in the list. This implementation isn’t hard, considering you already saw how to use lists for bags or sets, so here are the details.</p>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h5 class="H3" id="sec25"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Creating a Chained Hash Table</span></h5>&#13;
<p class="TNI1">To create a new hash table for use with chaining, create an empty array and fill it with new lists (you’ll use ordered lists, as shown earlier in this chapter, as a refresher):</p>&#13;
<pre id="pre-196"><code>const newHashTable = (n = 100) =&gt; ({&#13;
  slots: new Array(n).fill(0).map(() =&gt; newList())&#13;
});</code></pre>&#13;
<p class="TX">You are creating an object instead of an array in case of other solutions that will require extra fields—for instance, to keep track of how many slots are used or are free. (See question 11.6 for a common mistake.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h5 class="H3" id="sec26"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Adding a Value to a Chained Hash Table</span></h5>&#13;
<p class="TNI1">You can add a new value to this hash table easily; the code is as follows:</p>&#13;
<pre id="pre-197"><code>const add = (ht, value) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const i = hash(ht, value);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> ht.slots[i] = addToList(ht.slots[i], value);&#13;
  return ht;&#13;
};</code></pre>&#13;
<p class="TX">You just have to compute into which slot the new value should go <span class="CodeAnnotation" aria-label="annotation1">❶</span> and then add it to the corresponding list <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h5 class="H3" id="sec27"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Searching for a Value in a Chained Hash Table</span></h5>&#13;
<p class="TNI1">Searching for a value is also simple: after deciding in which slot the value should be, search the corresponding list. You could write the search in a single line, but it’s clearer as follows:</p>&#13;
<pre id="pre-198"><code>const find = (ht, value) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const i = hash(ht, value);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> return findInList(ht.slots[i], value);&#13;
};</code></pre>&#13;
<p class="TX">Calculate the corresponding slot <span class="CodeAnnotation" aria-label="annotation1">❶</span> and then search for it <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Note that you had to rename the <span class="SANS_TheSansMonoCd_W5Regular_11">find(...)</span> method from lists to <span class="SANS_TheSansMonoCd_W5Regular_11">findInList(...)</span> to avoid recursively calling the wrong function. Another possibility would be writing something like <span class="SANS_TheSansMonoCd_W5Regular_11">List.find(...)</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_221" aria-label="221"/>&#13;
<h5 class="H3" id="sec28"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Removing a Value from a Chained Hash Table</span></h5>&#13;
<p class="TNI1">Again, removing a value is easy because of all the code you developed earlier:</p>&#13;
<pre id="pre-199"><code>const remove = (ht, value) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const i = hash(ht, value);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> ht.slots[i] = removeFromList(ht.slots[i], value);&#13;
  return ht;&#13;
};</code></pre>&#13;
<p class="TX">As when adding a value, first compute the correct slot <span class="CodeAnnotation" aria-label="annotation1">❶</span> and then remove the value from the list <span class="CodeAnnotation" aria-label="annotation2">❷</span> by using the <span class="SANS_TheSansMonoCd_W5Regular_11">removeFromList(...)</span> method from lists, which is also renamed to avoid conflicts.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h5 class="H3" id="sec29"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Considering Performance for Chaining</span></h5>&#13;
<p class="TNI1">The performance of the worst case of hashing with chaining is, obviously, <i>O</i>(<i>n</i>) if all values map to the very same slot. If the situation isn’t as extreme and there are <i>s</i> slots, each chain should be around <i>n/s</i> values long, so searches are <i>O</i>(<i>n/s</i>), which is actually <i>O</i>(<i>n</i>) but with a better expected constant. The more slots you have, the shorter the chains and the better the performance.</p>&#13;
<p class="TX">You could keep track of how many values are in the table (or of the lengths of the individual chains), and should those numbers exceed some limit, you could re-create the table with a larger number of slots to improve performance. We’ll study this kind of process in the next sections.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
&#13;
<h4 class="H2" id="sec30"><span id="h2-91"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Hashing with</span> <span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Open Addressing</span></h4>&#13;
<p class="TNI1">Another common solution to dealing with collisions is this: if the slot to use is already occupied, try the following place (and, if needed, the one after that, and the next, and so on, returning to the beginning cyclically after reaching the end of the table) until you find an empty slot. To do a search, apply the same scheme: first check the corresponding hash, and if the slot is empty, the search failed. If the slot is occupied and it’s the value you wanted, the search succeeded; otherwise, proceed to the (cyclically) next place and try again. You can see how this works with a simple example. Start with an empty hash table into which just 22 was added; see <a href="chapter11.xhtml#fig11-13">Figure 11-13</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig11-13" src="../images/Figure11-13.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-13: A hash table with just one element</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You could add 04, 75, 09, and 60, and each would go into its corresponding slot, as shown in <a href="chapter11.xhtml#fig11-14">Figure 11-14</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_222" aria-label="222"/>&#13;
<figure class="IMG"><img class="img5" id="fig11-14" src="../images/Figure11-14.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-14: Four more elements were added, with no collisions so far.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The problem appears if you try to add 12, because the corresponding slot, the second one, is already occupied. You must start advancing, so 12 ends up in slot 3, as shown in <a href="chapter11.xhtml#fig11-15">Figure 11-15</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig11-15" src="../images/Figure11-15.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-15: A collision occurs when you try to add a value (12) to an occupied slot.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As the table becomes more and more full, it’s more likely that new values will end up far from their correct slot; for instance, if you add 63, it ends up at slot 6, as shown in <a href="chapter11.xhtml#fig11-16">Figure 11-16</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig11-16" src="../images/Figure11-16.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-16: In a fuller table, values end up far from their corresponding slot.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Of course, as defined, it becomes apparent that if the table becomes full, you’ll be in an infinite loop. The <i>load factor</i> is defined as the ratio between occupied slots and total slots. An empty hash table has a zero load, and a totally full one has a load factor of 1. The result is intuitive, but you can show mathematically that as the load factor grows, insertions and searches will progressively become slower. As a rule of thumb, if the load factor gets above 0.75, you should move to a larger hash table.</p>&#13;
<pre id="pre-200"><code>const load = (ht) =&gt; ht.used / ht.slots.length;</code></pre>&#13;
<p class="TX">When conducting searches, the process is exactly the same as for insertions. If you are looking for 63, you’d start at slot 3, and if it’s not there, advance by one until finding it at slot 6. If you are looking for 73 instead, you’d advance until slot 7, which is empty, and then decide that 73 isn’t in the table.</p>&#13;
<p class="TX">Deletions are not a straightforward process. Consider removing 22, as shown in <a href="chapter11.xhtml#fig11-17">Figure 11-17</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_223" aria-label="223"/>&#13;
<figure class="IMG"><img class="img5" id="fig11-17" src="../images/Figure11-17.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-17: The wrong way to delete a value (22) messes up other searches.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now, if you want to search for 12, what happens? Finding that slot 2 is empty, you’d decide that 12 isn’t there, which is bad. We’ll have to do lazy deletions. Instead of actually emptying a slot when removing a value, we’ll mark it as available. We’ll treat deleted locations as empty when adding new values, but as occupied when searching. Deleting 12 would get the result shown in <a href="chapter11.xhtml#fig11-18">Figure 11-18</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig11-18" src="../images/Figure11-18.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-18: The right way to delete a value (22) just marks the slot (#2) as “used but available.”</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">For searches, slot 2 is considered to be occupied, so when looking for 12, you won’t stop at slot 2, but will instead keep advancing. For insertions (suppose at a later time you wanted to add 42 to the table), slot 2 is considered available, so you could use it, as shown in <a href="chapter11.xhtml#fig11-19">Figure 11-19</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig11-19" src="../images/Figure11-19.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-19: A “used but available” slot (#2) may be used for new insertions.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now that you’ve explored how a hash table works with the important detail of how to deal with deletions, consider the actual code.</p>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h5 class="H3" id="sec31"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Creating an Open-Addressed Hash Table</span></h5>&#13;
<p class="TNI1">For open addressing, all you need is a table, but you’ll also keep track of how many slots have been used in order to compute the load factor. You’ll start by defining, for ease of coding, a couple of constants:</p>&#13;
<pre id="pre-201"><code>const EMPTY = undefined;&#13;
const AVAILABLE = null;</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">EMPTY</span> value will be assigned to all as yet unused slots, and <span class="SANS_TheSansMonoCd_W5Regular_11">AVAILABLE</span> will be used for slots that were occupied before but that are now available because you removed the original value that was there.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_224" aria-label="224"/>A new hash table will be an object with 100 slots by default:</p>&#13;
<pre id="pre-202"><code>const newHashTable = (n = 100) =&gt; ({&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> slots: new Array(n).fill(EMPTY),&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> used: 0&#13;
});</code></pre>&#13;
<p class="TX">Given the desired size for the hash table (defaulting to 100), create an empty array of that size, filled with the <span class="SANS_TheSansMonoCd_W5Regular_11">EMPTY</span> value <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and set the initial count of used slots to <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
&#13;
<h5 class="H3" id="sec32"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Adding a Value to an Open-Addressed Hash Table</span></h5>&#13;
<p class="TNI1">You’ve already seen the logic for additions, and the code is somewhat long:</p>&#13;
<pre id="pre-203"><code>const add = (ht, value) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> let i = hash(ht, value);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> while (ht.slots[i] !== EMPTY &amp;&amp; ht.slots[i] !== AVAILABLE) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> i = (i + 1) % ht.slots.length;&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if (ht.slots[i] === EMPTY) {&#13;
    ht.used++;&#13;
  }&#13;
  ht.slots[i] = value;&#13;
  return ht;&#13;
};</code></pre>&#13;
<p class="TX">Start by calculating in which slot the value should go <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then start a linear search <span class="CodeAnnotation" aria-label="annotation2">❷</span> that stops when you get to an <span class="SANS_TheSansMonoCd_W5Regular_11">EMPTY</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">AVAILABLE</span> slot; note that using the modulus operation <span class="CodeAnnotation" aria-label="annotation3">❸</span> makes the search wrap to the beginning. After the search for an open slot succeeds, if the slot was empty <span class="CodeAnnotation" aria-label="annotation4">❹</span>, add one to the count of used slots. If you’re wondering why you don’t do it if the slot was <span class="SANS_TheSansMonoCd_W5Regular_11">AVAILABLE</span> instead, you’ll understand why when you look at removing a value. An important detail is that you assume the table has some free space. You’ll see how that works when you look at performance for hashing with open addresses.</p>&#13;
<p class="TX">You’re actually implementing a bag here. To do a set instead, see question 11.7.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h5 class="H3" id="sec33"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Searching for a Value in an Open-Addressed Hash Table</span></h5>&#13;
<p class="TNI1">As described previously, the search is similar to the insertion process. You’ll do the same kind of process as if you were looking to insert a new value, but you’ll skip the actual insertion. The code is as follows:</p>&#13;
<pre id="pre-204"><code>const find = (ht, value) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> let i = hash(ht, value);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> while (ht.slots[i] !== EMPTY &amp;&amp; ht.slots[i] !== value) {&#13;
    i = (i + 1) % ht.slots.length;&#13;
  }&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_225" aria-label="225"/><span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> return ht.slots[i] === value;&#13;
};</code></pre>&#13;
<p class="TX">As when inserting, first decide in which slot the value should be found <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and if needed, loop <span class="CodeAnnotation" aria-label="annotation2">❷</span> until you either get the value or reach an <span class="SANS_TheSansMonoCd_W5Regular_11">EMPTY</span> slot. Depending on how the loop ends, return <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. You’re ignoring <span class="SANS_TheSansMonoCd_W5Regular_11">AVAILABLE</span> slots, for reasons that will become apparent.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
&#13;
<h5 class="H3" id="sec34"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Removing a Value from an Open-Addressed Hash Table</span></h5>&#13;
<p class="TNI1">Removing a value is strongly based on how you do searches. The key issue is that upon finding the value to be deleted, you’ll mark the slot as <span class="SANS_TheSansMonoCd_W5Regular_11">AVAILABLE</span>, implying that the slot is free now for future insertions, but it isn’t really free, so for searches, consider it as filled and keep going.</p>&#13;
<p class="TX">Here’s the code:</p>&#13;
<pre id="pre-205"><code>const remove = (ht, value) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> let i = hash(ht, value);&#13;
  while (ht.slots[i] !== EMPTY &amp;&amp; ht.slots[i] !== value) {&#13;
    i = (i + 1) % ht.slots.length;&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (ht.slots[i] === value) {&#13;
    ht.slots[i] = AVAILABLE;&#13;
  }&#13;
  return ht;&#13;
};</code></pre>&#13;
<p class="TX">The first part <span class="CodeAnnotation" aria-label="annotation1">❶</span> is the same code as in the search function. The only difference with that code is that after exiting the loop, if the search succeeded, set the slot to <span class="SANS_TheSansMonoCd_W5Regular_11">AVAILABLE</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">An important question is why you didn’t decrement the <span class="SANS_TheSansMonoCd_W5Regular_11">used</span> count. A border case shows the problem: imagine you entered <i>n</i> values, from 1 to <i>n</i>, into a hash table of size <i>n</i>, then removed them all, and finally tried to add any new value. What would happen? An infinite loop when checking if the value was already in the table! The load factor considers all slots that are or were occupied; you’ll see what to do when that load becomes too high in the next section.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
&#13;
<h5 class="H3" id="sec35"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Considering Performance for Hashing with Open Addressing</span></h5>&#13;
<p class="TNI1">As mentioned, the search performance degrades considerably when the load factor tends to 1, eventually becoming <i>O</i>(<i>n</i>). The worst case is always <i>O</i>(<i>n</i>); an example of this (not the only one, for sure) would be if all keys hash to the same slot. See <a href="chapter11.xhtml#tab11-5">Table 11-5</a>.</p>&#13;
&#13;
<table class="table">&#13;
<caption><p class="TT" id="tab11-5"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_226" aria-label="226"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 11-5:</span></span> <span class="SANS_Futura_Std_Book_11">Performance of Operations for Open-Addressed</span> <span class="SANS_Futura_Std_Book_11">Hash Tables</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operation</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Average performance</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Worst case</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Create</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
<td class="TBF"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Add</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_11">Remove</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
<td class="TB"><p class="TBGREY"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Find</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(1)</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">O</span><span class="SANS_Futura_Std_Book_11">(</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">If you keep the load factor limited, you can expect good performance, but as you add more values to the table, it will degrade. There’s no way out of this, but you can modify the <span class="SANS_TheSansMonoCd_W5Regular_11">add(...)</span> logic to produce a larger table automatically to avoid high loads. You just have to change the final <span class="SANS_TheSansMonoCd_W5Regular_11">return ht</span> from the code for adding a value to the following:</p>&#13;
<pre id="pre-206"><code><span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (load(ht) &gt; 0.75) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> let newHT = newHashTable(ht.slots.length * 2);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> ht.slots.forEach((v) =&gt; {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if (v !== EMPTY &amp;&amp; v !== AVAILABLE) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> newHT = add(newHT, v);&#13;
      }&#13;
    });&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> return newHT;&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> return ht;&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">If the load factor has exceeded the recommended 0.75 threshold <span class="CodeAnnotation" aria-label="annotation1">❶</span>, create a new hash table, double the size <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and go through the original table slot by slot <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Every value you find <span class="CodeAnnotation" aria-label="annotation4">❹</span> will be added to the new table <span class="CodeAnnotation" aria-label="annotation5">❺</span>. At the end, instead of returning the original table as you did before, you’ll return the new larger table <span class="CodeAnnotation" aria-label="annotation6">❻</span>. Had the load factor been acceptable <span class="CodeAnnotation" aria-label="annotation7">❼</span>, you’d return the original table as before. For an alternative technique, see question 11.9.</p>&#13;
<p class="TX">This sort of logic also comes in handy for the versions of hashing tables that we’ll consider next.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
&#13;
<h4 class="H2" id="sec36"><span id="h2-92"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Double Hashing</span></h4>&#13;
<p class="TNI1">The logic you’ve been applying doesn’t really help much with collisions. Should two values coincide at a slot, they’ll also coincide at the following slot, and the next, and so on. This scheme is likely to produce long lengths of adjacent occupied slots that will slow down searches and insertions.</p>&#13;
<p class="TX">An idea that helps in that situation is not always trying the next slot, but rather skip a number of slots and make that number depend on the value, so different values skip different numbers of slots. The concept of <i>double hashing</i> works this way: a first hashing function finds the first slot to try, but if that’s occupied, a second hashing function determines what size steps to take, instead of always jumping to the immediate next slot.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_227" aria-label="227"/>If you return to the example from the “<span class="Xref">Hashing with Open Addressing</span>” section on page <span class="Xref">221</span>, while there are no collisions, everything works the same way, so after the first five insertions, you’d have the situation shown in <a href="chapter11.xhtml#fig11-20">Figure 11-20</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig11-20" src="../images/Figure11-20.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-20: A hash table using double hashing, with no collisions so far</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now you want to add 12, and the #2 slot is occupied. In the previous section you used open addressing, so you tried slot #3, and if that also was occupied, you would have tried slots #4, #5, and so on, in succession, until finding an empty one. With double hashing, you’ll use a second function to decide how far to jump. Use the remainder of dividing the value by 9, plus 1, which is guaranteed to be a number between 1 and 9 inclusive. For value 12, the step would be 4, so the next attempt would be at slot #6, as shown in <a href="chapter11.xhtml#fig11-21">Figure 11-21</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig11-21" src="../images/Figure11-21.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 11-21: Double hashing uses a second function to work with collisions.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If slot #6 had been occupied, you’d have advanced four slots again (cyclically) and tried slot #0, and after that slot #4, and so on. There’s a possible problem here. If you wanted to add value 130 to the table in <a href="chapter11.xhtml#fig11-21">Figure 11-21</a>, what would happen? The first attempt would be at slot #0, and that fails. The second attempt would be at slot #5 (because the step for 130 would be 5), but that also fails. The third attempt would be at slot #0 again (because of the cyclical search), and you’d be in a loop.</p>&#13;
<p class="TX">You’ll have to take care of detecting (and solving) these loops; there are two different ways to achieve this.</p>&#13;
<section epub:type="division" aria-labelledby="sec37">&#13;
&#13;
<h5 class="H3" id="sec37"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Creating a Table That Uses Double Hashing</span></h5>&#13;
<p class="TNI1">Creating a table for double hashing is exactly the same as for open addressing, so we don’t need special code here. Here’s the needed logic again for easier reference:</p>&#13;
<pre id="pre-207"><code>const EMPTY = undefined;&#13;
const AVAILABLE = null;&#13;
&#13;
const newHashTable = (n = 100) =&gt; ({&#13;
  slots: new Array(n).fill(EMPTY),&#13;
  used: 0&#13;
});</code></pre>&#13;
<p class="TX">The key differences are in how you add, search for, and remove values.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec38">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_228" aria-label="228"/>&#13;
<h5 class="H3" id="sec38"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Adding a Value to a Table That Uses Double Hashing</span></h5>&#13;
<p class="TNI1">You saw the procedure for adding a value in a double hash earlier in this section, so let’s get to the code. You’ll use two hashing functions: a first one to determine the initial slot to try and a second one to skip in the search. It’s very important that the second function must never return a zero value.</p>&#13;
<pre id="pre-208"><code>const hash1 = (ht, value) =&gt; value % ht.slots.length;&#13;
const hash2 = (ht, value) =&gt; 1 + (value % (ht.slots.length - 1));</code></pre>&#13;
<p class="TX">The logic to add a value needs careful attention to avoid infinite looping:</p>&#13;
<pre id="pre-209"><code>const add = (ht, value) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> let i = hash1(ht, value);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (ht.slots[i] !== EMPTY &amp;&amp; ht.slots[i] !== AVAILABLE) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const step = hash2(ht, value);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> let i0 = i;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> while (ht.slots[i] !== EMPTY &amp;&amp; ht.slots[i] !== AVAILABLE) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> i = (i + step) % ht.slots.length;&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> if (i === i0) {&#13;
        i = (i + 1) % ht.slots.length;&#13;
        i0 = i;&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> if (ht.slots[i] === EMPTY) {&#13;
    ht.used++;&#13;
  }&#13;
  ht.slots[i] = value;&#13;
  return ht;&#13;
};</code></pre>&#13;
<p class="TX">Start by using the first hash function <span class="CodeAnnotation" aria-label="annotation1">❶</span> to get the initial slot. If that slot isn’t empty <span class="CodeAnnotation" aria-label="annotation2">❷</span>, use the second hash function <span class="CodeAnnotation" aria-label="annotation3">❸</span> to see how far to jump at every step. You’ll save the initial slot at <span class="SANS_TheSansMonoCd_W5Regular_11">i0</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span> to detect a loop, and then start looking for an empty or available slot <span class="CodeAnnotation" aria-label="annotation5">❺</span>. At each pass of the loop, advance <span class="SANS_TheSansMonoCd_W5Regular_11">step</span> places <span class="CodeAnnotation" aria-label="annotation6">❻</span>, and if you detect that you’re back at the initial <span class="SANS_TheSansMonoCd_W5Regular_11">i0</span> place, then advance just one place and save the new initial slot <span class="CodeAnnotation" aria-label="annotation7">❼</span>. After finding where to put the new value <span class="CodeAnnotation" aria-label="annotation8">❽</span>, the logic is as for the previous hash methods: update the count of used slots and save the value. You should regenerate the table in case of a high load factor, in the same way as in the open addressing section.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec39">&#13;
&#13;
<h5 class="H3" id="sec39"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Searching for a Value in a Table That Uses Double Hashing</span></h5>&#13;
<p class="TNI1">The logic for searching for a value matches the way you add new values:</p>&#13;
<pre id="pre-210"><code>const find = (ht, value) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> let i = hash1(ht, value);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const step = hash2(ht, value);&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_229" aria-label="229"/><span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> let i0 = i;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> while (ht.slots[i] !== EMPTY &amp;&amp; ht.slots[i] !== value) {&#13;
    i = (i + step) % ht.slots.length;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> if (i0 === i) {&#13;
      i = (i + 1) % ht.slots.length;&#13;
      i0 = i;&#13;
    }&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> return ht.slots[i] === value;&#13;
};</code></pre>&#13;
<p class="TX">Start by deciding on the initial slot to test <span class="CodeAnnotation" aria-label="annotation1">❶</span> and the step amount to jump <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Then save the initial spot to detect a loop <span class="CodeAnnotation" aria-label="annotation3">❸</span> and start jumping until you find an empty slot or the desired value <span class="CodeAnnotation" aria-label="annotation4">❹</span>; the logic for jumps is exactly the same as for insertions, including the loop detection <span class="CodeAnnotation" aria-label="annotation5">❺</span>. At the end, return <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> <span class="CodeAnnotation" aria-label="annotation6">❻</span> depending on where you stopped the search.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec40">&#13;
&#13;
<h5 class="H3" id="sec40"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Removing a Value from a Table That Uses Double Hashing</span></h5>&#13;
<p class="TNI1">I won’t repeat the explanation here, but to remove a value, you’ll use the same technique as for open addressing. You won’t mark removed values as <span class="SANS_TheSansMonoCd_W5Regular_11">EMPTY</span>, but rather as <span class="SANS_TheSansMonoCd_W5Regular_11">AVAILABLE</span>. The code is as follows:</p>&#13;
<pre id="pre-211"><code>const remove = (ht, value) =&gt; {&#13;
  let i = hash1(ht, value);&#13;
  let i0 = i;&#13;
  const step = hash2(ht, value);&#13;
  while (ht.slots[i] !== EMPTY &amp;&amp; ht.slots[i] !== value) {&#13;
    i = (i + step) % ht.slots.length;&#13;
    if (i0 === i) {&#13;
      i = (i + 1) % ht.slots.length;&#13;
      i0 = i;&#13;
    }&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (ht.slots[i] === value) {&#13;
    ht.slots[i] = AVAILABLE;&#13;
  }&#13;
  return ht;&#13;
};</code></pre>&#13;
<p class="TX">The code is exactly the same as for the open addressing search, and you change only what to do after finishing the loop. If you found the value <span class="CodeAnnotation" aria-label="annotation1">❶</span>, mark the slot as <span class="SANS_TheSansMonoCd_W5Regular_11">AVAILABLE</span>; if it’s not found, don’t do anything.</p>&#13;
<p class="TX">The logic for double hashing works well, but you can easily make it more streamlined, as we’ll see next.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec41">&#13;
&#13;
<h4 class="H2" id="sec41"><span id="h2-93"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Double Hashing with Prime Lengths</span></h4>&#13;
<p class="TNI1">The only problem with the logic that you saw with double hashing operations is the need to deal with possible loops. You’ll get a loop whenever the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_230" aria-label="230"/>step size you choose happens to have some common factor with the table’s length. For instance, if the table size is 18 and the step is 12, after three steps you’ll be back where you started. If you could choose a table length that doesn’t have any common factors with all possible steps, the logic would be simpler. There’s an easy way to do that: if the table length is a prime number (divisible only by itself or by 1), no loops are possible, because a prime number has no common divisors with any lower number. Also, if the step is 1, everything is fine, because before returning to the initial slot, you’ll have gone through the complete array.</p>&#13;
<section epub:type="division" aria-labelledby="sec42">&#13;
&#13;
<h5 class="H3" id="sec42"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Creating a Table That Uses Double Hashing with Prime Lengths</span></h5>&#13;
<p class="TNI1">You can create a new hash table exactly as before, except you must ensure that its length is a prime number. First you need to check whether a number is prime:</p>&#13;
<pre id="pre-212"><code>const isPrime = (n) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (n &lt;= 3) {&#13;
   return true;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else if (n % 2 === 0) {&#13;
   return false;&#13;
 }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> for (let d = 3, q = n; d &lt; q; d += 2) {&#13;
   q = n / d;&#13;
 <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if (Math.floor(q) === q) {&#13;
     return false;&#13;
   }&#13;
 }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> return true;&#13;
};</code></pre>&#13;
<p class="TX">Small numbers are prime (and for the purposes here 1 works as a prime number, no matter what mathematicians may say) <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Even numbers (you excluded 2 in the previous <span class="SANS_TheSansMonoCd_W5Regular_11">if</span>) aren’t prime <span class="CodeAnnotation" aria-label="annotation2">❷</span>, so those cases are simple. For other numbers, test all odd possible divisors starting at 3 <span class="CodeAnnotation" aria-label="annotation3">❸</span> and stop when you find an exact division <span class="CodeAnnotation" aria-label="annotation4">❹</span> or when the tested possible divisor exceeds the square root of the number, in which case the number is prime <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">Next you need a simple function to find the first prime number greater than a given value, and you can write it simply by using the <span class="SANS_TheSansMonoCd_W5Regular_11">isPrime(...)</span> function:</p>&#13;
<pre id="pre-213"><code>const findNextPrime = (n) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> while (!isPrime(n)) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> n++;&#13;
  }&#13;
  return n;&#13;
};</code></pre>&#13;
<p class="TX">The logic is straightforward: given a number, if it’s not prime <span class="CodeAnnotation" aria-label="annotation1">❶</span>, add 1 to it <span class="CodeAnnotation" aria-label="annotation2">❷</span> until the number becomes a prime.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_231" aria-label="231"/>Now you can create a table. The logic is the same as before, except you make sure that the length of the table is a prime number:</p>&#13;
<pre id="pre-214"><code>const newHashTable = (n = 100) =&gt; ({&#13;
  slots: new Array(findNextPrime(n)).fill(EMPTY),&#13;
  used: 0&#13;
});</code></pre>&#13;
<p class="TX">Whatever size you get, you find the next higher prime and use it as the table length.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec43">&#13;
&#13;
<h5 class="H3" id="sec43"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Adding a Value to a Table That Uses Double Hashing with Prime Lengths</span></h5>&#13;
<p class="TNI1">To add a value, work the same way as with the double hashing code, except you don’t have to test for loops; prime numbers have this covered:</p>&#13;
<pre id="pre-215"><code>const add = (ht, value) =&gt; {&#13;
  let i = hash1(ht, value);&#13;
  if (ht.slots[i] !== EMPTY) {&#13;
    const step = hash2(ht, value);&#13;
    while (ht.slots[i] !== EMPTY &amp;&amp; ht.slots[i] !== AVAILABLE) {&#13;
      i = (i + step) % ht.slots.length;&#13;
    }&#13;
  }&#13;
&#13;
  if (ht.slots[i] === EMPTY) {&#13;
    ht.used++;&#13;
  }&#13;
  ht.slots[i] = value;&#13;
  return ht;&#13;
};</code></pre>&#13;
<p class="TX">You’ll advance as before, but all the code related to <span class="SANS_TheSansMonoCd_W5Regular_11">i0</span> (which you used for loop detection) is now gone.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec44">&#13;
&#13;
<h5 class="H3" id="sec44"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Searching for a Value in a Table That Uses Double Hashing with Prime Lengths</span></h5>&#13;
<p class="TNI1">Searching is also simpler:</p>&#13;
<pre id="pre-216"><code>const find = (ht, value) =&gt; {&#13;
  let i = hash1(ht, value);&#13;
  const step = hash2(ht, value);&#13;
  while (ht.slots[i] !== EMPTY &amp;&amp; ht.slots[i] !== value) {&#13;
    i = (i + step) % ht.slots.length;&#13;
  }&#13;
&#13;
  return ht.slots[i] === value;&#13;
};</code></pre>&#13;
<p class="TX">Again comparing this code with the code for common double hashing, the key difference is that you did away with all the loop detection and prevention.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec45">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_232" aria-label="232"/>&#13;
<h5 class="H3" id="sec45"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Removing a Value from a Table That Uses Double Hashing with Prime Lengths</span></h5>&#13;
<p class="TNI1">Finally, as expected, removing a value is also easier:</p>&#13;
<pre id="pre-217"><code>const remove = (ht, value) =&gt; {&#13;
  let i = hash1(ht, value);&#13;
  const step = hash2(ht, value);&#13;
  while (ht.slots[i] !== EMPTY &amp;&amp; ht.slots[i] !== value) {&#13;
    i = (i + step) % ht.slots.length;&#13;
  }&#13;
&#13;
  if (ht.slots[i] === value) {&#13;
    ht.slots[i] = AVAILABLE;&#13;
  }&#13;
  return ht;&#13;
};</code></pre>&#13;
<p class="TX">Once more, the code is the same as for common double hashing, but without checking for loops; it’s faster, simpler code.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec46">&#13;
&#13;
<h3 class="H1" id="sec46"><span id="h1-56"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>&#13;
<p class="TNI1">In this chapter we’ve considered several ways to implement bags and sets, including the hashing technique that, when properly applied, can provide the fastest possible search times. The structures considered here were basically linear; in the next chapter we’ll start considering nonlinear ones such as trees to explore further implementations of bags and sets.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec47">&#13;
&#13;
<h3 class="H1" id="sec47"><span id="h1-57"/><span class="SANS_Futura_Std_Bold_B_11">Questions</span></h3>&#13;
<p class="ListHead"><b>11.1  Sentinels for Searches</b></p>&#13;
<p class="ListPlainFirst">Show how an ordered list could benefit from a final <span class="SANS_TheSansMonoCd_W5Regular_11">+Infinity</span> sentinel value for simpler code.</p>&#13;
<p class="ListHead"><b>11.2  More Sentinels?</b></p>&#13;
<p class="ListPlainFirst">Would adding an initial <span class="SANS_TheSansMonoCd_W5Regular_11">-Infinity</span> sentinel help with ordered lists?</p>&#13;
<p class="ListHead"><b>11.3  A Simpler Search?</b></p>&#13;
<p class="ListPlainFirst">Can you simplify the code to avoid having to return two values when searching a self-organizing list? A tip: if the search was successful, the list won’t be empty and its head will have the searched value.</p>&#13;
<p class="ListHead"><b>11.4  Re-skipping Lists</b></p>&#13;
<p class="ListPlainFirst">Can you sketch out an algorithm that will restructure a skip list to make sure it is well balanced?</p>&#13;
<p class="ListHead"><b>11.5  Skip to an Index</b></p>&#13;
<p class="ListPlainFirst">In the earlier definition you just wanted to search for a value, but what if you had an index <i>i</i> and wanted the <i>i</i>th value of the list? Can you think <span role="doc-pagebreak" epub:type="pagebreak" id="pg_233" aria-label="233"/>of a way to modify skip lists in order to find a value by index in an efficient way?</p>&#13;
<p class="ListHead"><b>11.6  Simpler Filling</b></p>&#13;
<p class="ListPlainFirst">Why wouldn’t the following code work to create a hashing table with chaining?</p>&#13;
<pre class="pre" id="pre-218"><code>const newHashTable = (n = 100) =&gt; ({&#13;
  slots: new Array(n).fill(newList())&#13;
});</code></pre>&#13;
<p class="ListHead"><b>11.7  A Hashed Set</b></p>&#13;
<p class="ListPlainFirst">In the hash table code for insertions you allowed repeated values, so you’re doing bags instead of sets. Can you modify the code as efficiently as possible to implement sets instead? Obviously, you could start by doing a search, but if that search failed, you’d be redoing a lot of work for the addition.</p>&#13;
<p class="ListHead"><b>11.8  Wrong Seating</b></p>&#13;
<p class="ListPlainFirst">This puzzle will remind you of hashing. Imagine that 100 people were given tickets for a show. The theater has 100 seats, and each ticket is assigned to a different seat. There was a problem, though. The first person to arrive at the theater didn’t pay attention and sat in a random seat. All the other people tried to go to their seats, and if their seats were already occupied, they also took random seats. What’s the probability that the last person (the 100th one) will find that their seat is unoccupied?</p>&#13;
<p class="ListHead"><b>11.9  Progressive Resizing</b></p>&#13;
<p class="ListPlainFirst">Doing a whole resizing operation (with the corresponding delay in time) may not be acceptable for some systems, so you need some kind of progressive resizing solution. Can you sketch a way to do the rehashing gradually, somehow working with two tables (an old one and a new one) but not rehashing the entire old table at once?</p>&#13;
</section>&#13;
</section>&#13;
</body></html>