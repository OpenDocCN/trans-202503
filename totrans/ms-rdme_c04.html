<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
	<head>
		<title>Chapter 4: Writing Operable Code</title>
		<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:7db14923-61d0-434f-baa0-3e20bf74259e" name="Adept.expected.resource"/>
	</head>
	<body epub:type="bodymatter chapter">
		<section>
			<header>
				<h1 class="chapter"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_47" title="47"/>4</span><br/><span class="ChapterTitle">Writing Operable Code</span></h1>
			</header>
			<p class="BodyFirst"><span class="DropCap">C</span>ode does weird things when exposed to “the real world.” Users are unpredictable. Networks are unreliable. Things go wrong. Production software has to keep working. Writing operable code helps you deal with the unforeseen. Operable code has built-in protection, diagnostics, and controls. Protect your system by programming defensively with safe and resilient coding practices. Safe code prevents many failures, and resilient code recovers when failures do occur. You also need to be able to see what’s going on so you can diagnose failures. Expose logging, metrics, and call trace information for easy diagnostics. Finally, you need to control systems without rewriting code. An operable system has configuration parameters and system tools.</p>
			<p>This chapter describes some best practices that will make your code easier to run in production. There’s a lot of ground to cover, so we kept things dense. By the end, you’ll be familiar with key concepts and tools you need to make your software operable. Moreover, operability comments are common in code reviews; this information will help you give and receive better feedback.</p>
			<h2 id="h1-501836c04-0001"><span epub:type="pagebreak" id="Page_48" title="48"/>Defensive Programming</h2>
			<p class="BodyFirst">Well-defended code is an act of compassion for anyone who runs your code (including you!). Defensive code fails less often, and when it does, it is more likely to recover. Make your code safe and resilient. <em>Safe code</em> takes advantage of compile-time validation to avoid runtime failures. Use immutable variables, access modifiers to restrict scope, and static type-checkers to prevent bugs. At runtime, validate input to avoid surprises. <em>Resilient code</em> uses exception-handling best practices and handles failures gracefully.</p>
			<h3 id="h2-501836c04-0001">Avoid Null Values</h3>
			<p class="BodyFirst">In many languages, variables without a value default to <code>null</code> (or <code>nil</code>, <code>None</code>, or some other variant thereof). Null pointer exceptions are a common occurrence. Stack traces prompt head-scratching and a “how could this variable not have been set?” investigation. Avoid null pointer exceptions by checking that variables aren’t null, by using the null object pattern, and by using option types.</p>
			<p>
				Perform null checks at the beginning of methods. Use <code>NotNull</code> annotations and similar language features when available. Validating up front that variables aren’t null means that later code can safely assume that it’s dealing with real values; this will keep your code cleaner and more legible.</p>
			<p>
				The <em>null object pattern</em> uses objects in lieu of null values. An example of this pattern is a search method that returns an empty list instead of <code>null</code> when no objects are found. Returning an empty list allows callers to safely iterate over the results, without special code to handle empty result sets.</p>
			<p>
				Some languages have built-in <em>option types</em>—<code>Optional</code> or <code>Maybe</code>—that force developers to think about how empty responses are handled. Take advantage of option types if they’re available.</p>
			<h3 id="h2-501836c04-0002">Make Variables Immutable</h3>
			<p class="BodyFirst">Immutable variables can’t be changed once they’re set. If your language has a way to explicitly declare variables as immutable (<code>final</code> in Java, <code>val</code> <span epub:type="pagebreak" id="Page_49" title="49"/>rather than <code>var</code> in Scala, <code>let</code> instead of <code>let mut</code> in Rust), do so whenever possible. Immutable variables prevent unexpected modifications. Many more variables can be made immutable than you might expect at first blush. As a bonus, using immutable variables makes parallel programming simpler, and a compiler or runtime that knows a variable is not going to change can be more efficient.</p>
			<h3 id="h2-501836c04-0003">Use Type Hinting and Static Type Checking</h3>
			<p class="BodyFirst">Constrain the values that variables can take. For example, variables with only a few valid string values should be an <code>Enum</code> rather than a <code>String</code>. Constraining variables will ensure that unexpected values will immediately fail (or might not even compile) rather than cause bugs. Use the most specific type possible when defining variables.</p>
			<p>
				Dynamic languages such as Python (starting with Python 3.5), Ruby via Sorbet (slated to be part of Ruby 3), and JavaScript (via TypeScript) all now have increasingly robust support for <em>type hinting</em> and <em>static type checkers</em>. Type hinting lets you specify a variable’s type in a language that’s normally dynamically typed. For example, the following Python 3.5 method uses type hinting to receive and return a string:</p>
			<pre><code>def say(something: str) -&gt; str: return "You said: " + something</code></pre>
			<p>Best of all, type hinting can be added gradually to existing codebases. When combined with a static type checker, which uses type hints to find bugs before code is executed, you can prevent runtime failures.</p>
			<h3 id="h2-501836c04-0004">Validate Inputs</h3>
			<p class="BodyFirst">Never trust the input your code receives. Developers, faulty hardware, and human error can mangle input data. Protect your code by validating that its input is well formed. Use preconditions, checksum and validate data, use security best practices, and use tools to find common errors. Reject bad input as early as possible.</p>
			<p><span epub:type="pagebreak" id="Page_50" title="50"/>Validate method input variables using preconditions and postconditions. Use libraries and frameworks that validate preconditions when the type you use does not fully capture valid variable values. Most languages have libraries with methods like <code>checkNotNull</code> or annotations like <code>@Size(min=0, max=100)</code>. Be as constrained as possible. Check that input strings match expected formats, and remember to deal with leading or trailing whitespace. Validate that all numbers are in appropriate ranges: if a parameter should be greater than zero, ensure that it is; if a parameter is an IP address, check that it’s a valid IP.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="box trade">
					<h2>No Word Allowed</h2>
					<p class="BoxBodyFirst">Dmitriy worked part-time at a comparative genomics lab in college. His team built a web service for scientists to upload DNA sequences and run the lab’s tools on them. One of the most common causes of errors they encountered was that biologists would put the text of the DNA sequence—a long string of As, Cs, Ts, and Gs—into a Word document rather than a simple text file. The parsers would of course break, and no results would be generated. The user was told that no matching sequence was found. This was a common occurrence. People filed bug reports suggesting that the DNA search was broken: it wasn’t finding sequences that absolutely must be in the database.</p>
					<p>This went on for quite some time. The team blamed the users because the directions clearly stated “plaintext file.” Eventually, Dmitriy got tired of responding to the emails with instructions for saving a plaintext file, so he updated the site. Did he add a Word parser? Goodness no. Did he add file format checking and proper error instrumentation to alert the user that the site couldn’t handle their submission? Of course not. He added a large Microsoft Word icon with a red line through it and a link to instructions. The support email volume went down drastically! Success!</p>
					<p><span epub:type="pagebreak" id="Page_51" title="51"/>The old website is still up, though it has been upgraded. The “No Word allowed!” icon is gone; just a warning remains: “Text files only. Word documents are not accepted<em>.</em>” Fifteen years after leaving that job, Dmitriy tried uploading a Word document of a well-studied gene. No results were found; no errors returned. That’s decades of misleading results because Dmitriy was too lazy to handle inputs properly. Don’t be 20-year-old Dmitriy. He might have sabotaged a cure for cancer with this.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>Computer hardware isn’t always trustworthy. Networks and disks can corrupt data. If you need strong durability guarantees, use checksums to validate that data hasn’t changed unexpectedly.</p>
			<p>
				Don’t overlook security, either. External inputs are dangerous. Malicious users might try to inject code or SQL into inputs, or overrun buffers to gain control of your application. Use mature libraries and frameworks to prevent cross-site scripting. Always escape inputs to prevent SQL injection attacks. Explicitly set size parameters when manipulating memory with commands like <code>strcpy</code> (specifically use <code>strncpy</code>) to prevent buffer overflows. Use widely adopted security and cryptography libraries or protocols instead of writing your own. Familiarize yourself with the Open Web Application Security Project (OWASP) Top 10 security report (<a class="LinkURL" href="https://owasp.org/www-project-top-ten/">https://owasp.org/www-project-top-ten/</a>) to quickly bootstrap your security knowledge.</p>
			<h3 id="h2-501836c04-0005">Use Exceptions</h3>
			<p class="BodyFirst">Don’t use special return values (<code>null</code>, <code>0</code>, <code>–1</code>, and so on) to signal an error. All modern languages support exceptions or have a standard exception-handling pattern (like Go’s <code>error</code> type). Special values aren’t obviously visible from a method signature. Developers won’t know that error conditions are returned and need to be handled. It’s also difficult to remember which return value corresponds to which failure state. Exceptions <span epub:type="pagebreak" id="Page_52" title="52"/>carry more information than a <code>null</code> or <code>–1</code>; they’re named and have stack traces, line numbers, and messages.</p>
			<p>
				For example, in Python a <code>ZeroDivisionError</code> returns a lot more information than a <code>None</code> return value:</p>
			<pre><code>Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ZeroDivisionError: integer division or modulo by zero</code></pre>
			<p>In many languages, checked exceptions are visible from method signatures:</p>
			<pre><code>// Go’s Open method clearly has an error return
func Open(name string) (file *File, err error)
// Java’s open() method clearly throws an IOException
public void open (File file) throws IOException</code></pre>
			<p>An error declaration in Go and an exception declaration in Java clearly signal that the open methods can raise errors that need to be handled.</p>
			<h3 id="h2-501836c04-0006">Be Precise with Exceptions</h3>
			<p class="BodyFirst">Precise exceptions make code easier to use. Use built-in exceptions when possible and avoid creating generic exceptions. Use exceptions for failures, not to control application logic.</p>
			<p>
				Most languages have built-in exception types (<code>FileNotFoundException</code>, <code>AssertionError</code>, <code>NullPointerException</code>, and so on). Don’t create custom exceptions if a built-in type can describe the problem. Developers have experience with existing exception types and will know what they mean.</p>
			<p>
				When creating your own exceptions, don’t make them too generic. Generic exceptions are difficult to handle because developers don’t know what kind of problem they’re dealing with. If developers don’t get a precise signal of the error that occurred, they’ll be forced to fail the <span epub:type="pagebreak" id="Page_53" title="53"/>application—a significant action. Be as specific as possible about the exception types you raise so developers can react to failures appropriately.</p>
			<p>Don’t use exceptions for application logic, either. You want your code to be unsurprising, not clever. Using exceptions to break out of a method is confusing and makes code hard to debug.</p>
			<p>
				This Python example uses <code>FoundNodeException</code> rather than directly returning the node that was found:</p>
			<pre><code>def find_node(start_node, search_name): for node in start_node.neighbors: if search_name in node.name: raise FoundNodeException(node) find_node(node, search_name)</code></pre>
			<p>Don’t do this. Just return the node.</p>
			<h3 id="h2-501836c04-0007">Throw Exceptions Early, Catch Exceptions Late</h3>
			<p class="BodyFirst">Follow the “throw early, catch late” principle. <em>Throwing early</em> means raising exceptions as close to the error as possible so developers can quickly find the relevant code. Waiting to throw an exception makes it harder to find where the failure actually happened. When an error occurs but other code is executed before the exception is thrown, you risk the possibility of a second error being triggered. If an exception is thrown for the second error, you don’t know that the first error happened. Tracking down this kind of bug is maddening. You fix a bug only to discover that the real problem was something upstream.</p>
			<p><em>Catching exceptions late</em> means propagating exceptions up the call stack until you reach the level of the program that is capable of handling the exception. Consider an application that tries to write to a full disk. There are many possible next steps: blocking and retrying, retrying asynchronously, writing to a different disk, alerting a human user, or even crashing. The appropriate reaction depends on application specifics. A database write-ahead log must be written, while a word processor’s <span epub:type="pagebreak" id="Page_54" title="54"/>background save can be delayed. The piece of code that can make this decision is likely several layers removed from the low-level library that encounters a full disk. All the intermediate layers need to propagate the exception upward and not attempt premature remediation. The worst of premature remediation is “swallowing” an exception you can’t address, usually by ignoring it in a <code>catch</code> block:</p>
			<pre><code>try { // ...
} catch (Exception e) { // ignoring since there’s nothing I can do about it
}</code></pre>
			<p>This exception will not get logged or rethrown, nor will any other action be taken; it’s completely ignored. The failure gets hidden, possibly to disastrous effect. When calling code that might throw exceptions, either handle them completely or propagate them up the stack.</p>
			<h3 id="h2-501836c04-0008">Retry Intelligently</h3>
			<p class="BodyFirst">The appropriate reaction to an error is often to simply try again. Plan on occasionally having to try multiple times when calling remote systems. Retrying an operation sounds easy: catch the exception and retry the operation. In practice, when and how often to retry requires some know-how.</p>
			<p>The most naïve retry approach is simply to catch an exception and retry the operation immediately. But what if the operation fails again? If a disk runs out of space, it’s likely to be out of space 10 milliseconds later, and 10 milliseconds after that. Banging away over and over slows things down and makes it harder for the system to recover.</p>
			<p>
				It’s prudent to use a strategy called <em>backoff</em>. Backoff increases sleep time nonlinearly (usually using an exponential backoff, such as <code>(retry number)^2</code>). If you use this approach, make sure to cap the backoff at some maximum so it doesn’t get too large. However, if a network server <span epub:type="pagebreak" id="Page_55" title="55"/>has a blip and all clients experience that blip simultaneously, then back off using the same algorithm; they will all reissue their requests at the same time. This is called a <em>thundering herd</em>; many clients issuing retry requests simultaneously can bring a recovering service back down. To handle this, add <em>jitter</em> to the backoff strategy. With jitter, clients add a random, bounded amount of time to the backoff. Introducing randomness spreads out the requests, reducing the likelihood of a stampede.</p>
			<p>
				Don’t blindly retry all failed calls, particularly ones that write data or cause some business process to execute. It is better to let the application crash when it encounters an error it was not designed to handle; this is called <em>failing fast</em>. If you fail fast, no further damage will be done, and a human can figure out the correct course of action. Make sure to fail not only fast but also loudly. Relevant information should be visible so that debugging is easy.</p>
			<h3 id="h2-501836c04-0009">Write Idempotent Systems</h3>
			<p class="BodyFirst">It’s not always obvious what state the system was left in after a failure. If the network fails during a remote write request, did the request succeed before the failure or not? This leaves you in a pickle: Do you retry and risk double-writing the request, or do you give up and risk losing the data? In a billing system, a retry might double-charge the customer, while not retrying might mean not charging them at all. Sometimes you can read the remote system to check, but not always. Local state mutations can suffer from similar problems. Nontransactional in-memory data structure mutations can leave your system in an inconsistent state.</p>
			<p>
				The best way to deal with retries is to build idempotent systems. An <em>idempotent</em> operation is one that can be applied multiple times and still yield the same outcome. Adding a value to a set is idempotent. No matter how many times the value is added, it exists in the set once. Remote APIs can be made idempotent by allowing clients to supply a unique ID for each request. When a client retries, it supplies the same unique ID as its failed attempt; the server can then de-duplicate the request if it’s already <span epub:type="pagebreak" id="Page_56" title="56"/>been processed. Making all your operations idempotent greatly simplifies system interactions and eliminates a large class of possible errors.</p>
			<h3 id="h2-501836c04-0010">Clean Up Resources</h3>
			<p class="BodyFirst">Be sure to clean all resources when a failure occurs. Release memory, data structures, network sockets, and file handles that you no longer need. Operating systems have a fixed amount of space for file handles and network sockets; once exceeded, all new handles and sockets fail to open. Leaking network sockets—failing to close them after use—will keep useless connections alive, which will fill connection pools. The following code is dangerous:</p>
			<pre><code>f = open('foo.txt', 'w')
# ...
f.close()</code></pre>
			<p>
				Any failures that happen before <code>f.close()</code> will prevent the file pointer from being closed. If your language doesn’t support auto-closing, wrap your code in a <code>try</code>/<code>finally</code> block to safely close file handles even if an exception occurs.</p>
			<p>
				Many modern languages have features that automatically close resources. Rust will automatically close resources by invoking a destructor method when objects leave scope. Python’s <code>with</code> statement automatically closes handles when the call path leaves the block:</p>
			<pre><code>with open('foo.txt') as f: # ...</code></pre>
			<h2 id="h1-501836c04-0002">Logging</h2>
			<p class="BodyFirst">The first time you wrote “Hello, world!” to a terminal, you were logging. Printing log messages is simple and convenient for understanding code or debugging a small program. For complex applications, languages have sophisticated logging libraries to give operators more control over <span epub:type="pagebreak" id="Page_57" title="57"/>what’s logged and when. Operators can modulate log volume through logging levels and control log formats. Frameworks also inject contextual information—thread names, hostnames, IDs—that you can use when debugging. Logging frameworks work well with log management systems, which aggregate log messages so operators can filter and search them.</p>
			<p>Use a logging framework to make your code easier to operate and debug. Set log levels so your operators can control your application’s log volume. Keep logs atomic, fast, and secure.</p>
			<h3 id="h2-501836c04-0011">Use Log Levels</h3>
			<p class="BodyFirst">Logging frameworks have <em>log levels</em>, which let operators filter messages based on importance. When an operator sets a log level, all logs at or above the level will be emitted, while messages from lower levels will be silenced. Levels are usually controlled through both a global setting and package or class-level overrides. Log levels let operators adjust log volume as befits a given situation, from extremely detailed debugging logs to a steady background hum of normal operations.</p>
			<p>
				For example, here’s a Java <code>log4j.properties</code> snippet that defines an ERROR-level root verbosity and a package-specific INFO-level verbosity for logs coming from the <code>com.foo.bar</code> package space:</p>
			<pre><code># set root logger to ERROR level for fout FileAppender
log4j.rootLogger=ERROR,fout
# set com.foo.bar to INFO level 
log4j.logger.com.foo.bar=INFO</code></pre>
			<p>You must use the appropriate criticality for each log message for log levels to be useful. While log levels are not completely standard, the following levels are common:</p>
			<ol class="none">
				<li><span class="RunInHead">TRACE</span>  This is an extremely fine level of detail that only gets turned on for specific packages or classes. This is rarely used outside of development. If you need line-by-line logs or data structure dumps, <span epub:type="pagebreak" id="Page_58" title="58"/>this level is for you. If you find yourself using TRACE frequently, you should consider using a debugger to step through code instead.</li>
				<li><span class="RunInHead">DEBUG</span>  This is used when the message will be useful during a production issue but not during normal operations. Don’t use debug-level logging so much that the output is unusable when debugging; save that for TRACE.</li>
				<li><span class="RunInHead">INFO</span>  This is nice-to-have information about the state of the application but not indicative of any problems. Application state messages like “Service started” and “Listening on port 5050” go here. INFO is the default log level. Don’t emit frivolous logs with INFO—“just in case” logging goes into TRACE or DEBUG. INFO logging should tell us something useful during normal operations.</li>
				<li><span class="RunInHead">WARN</span>  These are messages about potentially problematic situations. A resource nearing its capacity merits a warning. Whenever you log a warning, there should be a concrete action you want the person seeing the message to take. If the warning is not actionable, log it to INFO.</li>
				<li><span class="RunInHead">ERROR</span>  These messages indicate that an error that needs attention is occurring. An unwritable database usually merits an ERROR log. ERROR logs should be detailed enough to diagnose problems. Log explicit details, including relevant stack traces and the resulting actions the software is performing.</li>
				<li><span class="RunInHead">FATAL</span>  These are the “last gasp” log messages. If the program encounters a condition so severe that it must exit immediately, a message about the cause of the problem can be logged at the FATAL level. Include relevant context about the program’s state; locations of recovery or diagnostic-related data should be logged.</li>
			</ol>
			<p>Here’s an INFO-level log emitted in Rust:</p>
			<pre><code>info!("Failed request: {}, retrying", e);</code></pre>
			<p class="BodyFirst"><span epub:type="pagebreak" id="Page_59" title="59"/>The log line includes the error that causes the request to fail. The INFO level is used because the application is automatically retrying; no operator action is needed.</p>
			<h3 id="h2-501836c04-0012">Keep Logs Atomic</h3>
			<p class="BodyFirst">If information is useful only when coupled with other data, log it all <em>atomically</em> in one message. Atomic logs, which have all relevant information in one line, work better with log aggregators. Don’t assume that logs will be seen in a specific order; many operational tools reorder or even drop messages. Don’t rely on system clock timestamps for ordering: system clocks can get reset or drift between hosts. Avoid newlines in log messages; many log aggregators treat each new line as a separate message. Make extra sure that stack traces are logged in a single message, as they often include newlines when printed.</p>
			<p>Here’s an example of nonatomic log messages:</p>
			<pre><code>2022-03-19 12:18:32,320 – appLog – WARNING – Request failed with:
2022-03-19 12:18:32,348 – appLog – INFO – User login: 986
Unable to read from pipe.
2022-03-19 12:18:32,485 – appLog – INFO – User logout: 986</code></pre>
			<p>The WARNING log message has a newline in it, which makes it hard to read. Subsequent lines from the WARNING have no timestamp and are intermingled with other INFO messages coming from another thread. The WARNING should have been written atomically as one line.</p>
			<p>If log messages can’t be output atomically, include a unique ID in the messages so they can be stitched together later.</p>
			<h3 id="h2-501836c04-0013">Keep Logs Fast</h3>
			<p class="BodyFirst">Excessive logging will hurt performance. Logs must be written somewhere—to disk, to a console, or to a remote system. Strings must be concatenated and formatted before they’re written. Use parameterized logging and asynchronous appenders to keep logging fast.</p>
			<p><span epub:type="pagebreak" id="Page_60" title="60"/>You’ll find string concatenation is very slow and can be devastating in performance-sensitive loops. When a concatenated string is passed into a log method, the concatenation happens regardless of the verbosity level because arguments are evaluated before they’re passed into a method. Log frameworks provide mechanisms to delay string concatenation until it’s actually needed. Some frameworks force log messages into closures that aren’t evaluated unless a log line is invoked, while others provide support parameterized messages.</p>
			<p>
				For example, Java has three ways to concatenate strings in log calls, two of which concatenate the string parameter before calling the <code>trace</code> method:</p>
			<pre><code>while(messages.size() &gt; 0) { Message m = message.poll(); // This string is concatenated even when trace is disabled! log.trace("got message: " + m); // This string is also concatenated when trace is disabled. log.trace("got message: {}".format(m)); // This string is only concatenated when trace is enabled. It’s faster. log.trace("got message: {}", m);
}</code></pre>
			<p>The final call uses a parameterized string that will be evaluated only if the log line is actually written.</p>
			<p>
				You can also manage performance impact using <em>appenders</em>. Appenders route logs to different locations: the console, a file, or a remote log aggregator. Default log appenders usually operate in the caller’s thread, the same way a call to <code>print</code> would. <em>Asynchronous</em> appenders write log messages without blocking execution threads. This improves performance since application code doesn’t need to wait for logs to be written. <em>Batching</em> appenders buffer log messages in-memory before writing to disk, thus improving write throughput. The operating system’s page cache helps log throughput by acting as a buffer as well. While asynchronous <span epub:type="pagebreak" id="Page_61" title="61"/>and batching writes improve performance, they can result in lost log messages if an application crashes, since not all logs are guaranteed to be flushed to disk.</p>
			<p>Beware that changing log verbosity and configuration can eliminate race conditions and bugs because it slows down the application. If you enable verbose logging to debug an issue and discover a bug disappears, the logging change itself might be the reason.</p>
			<h3 id="h2-501836c04-0014">Don’t Log Sensitive Data</h3>
			<p class="BodyFirst">Be careful when dealing with sensitive data. Log messages shouldn’t include private data like passwords, security tokens, credit card numbers, or emails. This might seem obvious, but it’s easy to get wrong—simply logging a URL or HTTP response can expose information that log aggregators are not set up to safeguard. Most frameworks support rule-based string replacement and redaction; configure them, but do not rely on them as your only defense. Be paranoid; logging sensitive data can create security risks and violate privacy regulations.</p>
			<h2 id="h1-501836c04-0003">Metrics</h2>
			<p class="BodyFirst">Instrument your application with metrics to see what it is doing. Metrics are the numerical equivalent of logs; they measure application behavior. How long did a query take? How many elements are in a queue? How much data was written to disk? Measuring application behavior helps detect problems and is useful for debugging.</p>
			<p>
				There are three common metric types: counters, gauges, and histograms. These names are similar, but not consistent, across different monitoring systems. <em>Counters</em> measure the number of times an event happens. Using a cache hit counter and a request counter, you can calculate cache hit rates. Counters only increase in value or reset to 0 when a process restarts (they are <em>monotonically increasing</em>). <em>Gauges</em> are point-in-time measurements that can go up or down; think of a speedometer or <span epub:type="pagebreak" id="Page_62" title="62"/>a gas volume indicator in a car. Gauges expose statistics such as the size of a queue, stack, or map. <em>Histograms</em> break events into ranges based on their magnitude. Each range has a counter that is incremented whenever an event value falls into its range. Histograms commonly measure the amount of time requests take, or data payload sizes.</p>
			<p>
				System performance is often measured in terms of metric values at threshold percentiles—for example, the 99th percentile, referred to as <em>P99</em>. A system with a 2-millisecond P99 latency takes 2 milliseconds or less to respond to 99 percent of the requests it receives. Percentiles are derived from histograms. To cut down on the data that needs to be tracked, some systems require you to configure which percentiles you care about; if a system tracks P95 by default but you have a P99 service level objective (SLO<em>)</em>, make sure to change settings accordingly.</p>
			<p>
				Application metrics are aggregated into centralized <em>observability</em><em> systems</em> like Datadog, LogicMonitor, or Prometheus. Observability is a concept from control theory that defines how easy it is to determine the state of a system by looking at its outputs. Observability systems try to make it easier to determine a running application’s state by providing dashboards and monitoring tools on top of aggregated metrics. Dashboards show operators what’s going on in the system, and monitoring tools trigger alerts based on metric values.</p>
			<p>
				Metrics are also used to automatically scale a system up or down. <em>Autoscaling</em> is common in environments that provide dynamic resource allocation. For example, cloud hosts may automatically adjust the number of running instances by monitoring load metrics. Autoscaling increases server capacity when it is needed and reduces server capacity to save money later.</p>
			<p>To track SLOs, use observability systems, and take advantage of autoscaling features, you must measure everything. Metrics are tracked using a standard metrics library; most application frameworks provide these. As a developer, it is your job to ensure that important metrics are exposed to observability systems.</p>
			<h3 id="h2-501836c04-0015"><span epub:type="pagebreak" id="Page_63" title="63"/>Use Standard Metrics Libraries</h3>
			<p class="BodyFirst">While counters, gauges, and histograms are pretty easy to calculate, don’t roll your own metrics library. Nonstandard libraries are a maintenance nightmare. Standard libraries will integrate with everything out of the box. Your company probably has a metrics library that they prefer. If they do, use it. If they don’t, start a discussion to adopt one.</p>
			<p>Most observability systems offer metric client libraries in a range of languages. We’ll use a StatsD client in a simple Python web application to show what metrics look like. Metrics libraries all look pretty similar, so our example should translate nearly verbatim to whichever library you use.</p>
			<p>
				The Python web application in <a href="#listing4-1" id="listinganchor4-1">Listing 4-1</a> has four methods: <code>set</code>, <code>get</code>, <code>unset</code>, and <code>dump</code>. The methods <code>set</code> and <code>get</code> simply set and retrieve values in a map stored in the service. The <code>unset</code> method deletes key-value pairs from the map and <code>dump</code> JSON-encodes the map and returns it.</p>
			<pre><code>import json
from flask import Flask, jsonify
from statsd import StatsClient
app = Flask(__name__)
statsd = StatsClient()
map = {}
@app.route('/set/&lt;k&gt;/&lt;v&gt;')
def set(k, v): """ Sets a key's value. Overwrites if key already exists. """ map[k] = v statsd.gauge('map_size', len(map))
@app.route('/get/&lt;k&gt;')
def get(k): """ Returns key's value if it exists. Else, None is returned. """ try: v = map[k] statsd.incr('key_hit') return v except KeyError as e: statsd.incr('key_miss')<span epub:type="pagebreak" id="Page_64" title="64"/>    return None
@app.route('/unset/&lt;k&gt;')
def unset(k): """ Deletes key from map if it exists. Else, no-op. """ map.pop(k, None) statsd.gauge('map_size', len(map))
@app.route('/dump')
def dump(): """ Encodes map as a JSON string and returns it. """ with statsd.timer('map_json_encode_time'): return jsonify(map)</code></pre>
			<p class="CodeListingCaption"><a id="listing4-1">Listing 4-1</a>: An example Python Flask application using the StatsD client metrics library</p>
			<p>
				This example uses counters <code>key_hit</code> and <code>key_miss</code> to track hits and misses in <code>get</code> with <code>statsd.incr</code>. A timer (<code>statsd.timer</code>) measures how long it takes to encode the map into JSON, which will be added to a timing histogram. Serialization is a costly, CPU-intensive operation, so it should be measured. A gauge (<code>statsd.gauge</code>) measures the current size of the map. We could have used increment and decrement methods on a counter to track the map size, but using a gauge is less error prone.</p>
			<p>Web application frameworks like Flask usually do a lot of metric calculations for you. Most will count all HTTP status codes for every method invocation in the web service and time all HTTP requests. Framework metrics are a great way to get a ton of metrics for free; just configure the framework to output to your observability system. Plus, your code will be cleaner since measurement happens underneath.</p>
			<h3 id="h2-501836c04-0016">Measure Everything</h3>
			<p class="BodyFirst">Measurements are cheap; you should use them extensively. Measure all of the following data structures, operations, and behaviors:</p>
			<ul>
				<li>Resource pools</li>
				<li>Caches</li>
				<li>Data structures</li>
				<li><span epub:type="pagebreak" id="Page_65" title="65"/>CPU-intensive operations</li>
				<li>I/O-intensive operations</li>
				<li>Data size</li>
				<li>Exceptions and errors</li>
				<li>Remote requests and responses</li>
			</ul>
			<p>Use gauges to measure the size of resource pools. Pay special attention to thread pools and connection pools. Large pools are an indication that the system is stuck or unable to keep up.</p>
			<p>Count cache hits and misses. Shifts in the hit-to-miss ratio impact application performance.</p>
			<p>Measure the size of key data structures with gauges. Abnormal data structure size is an indication that something strange is going on.</p>
			<p>Time CPU-intensive operations. Pay special attention to data serialization operations, which are surprisingly expensive. A simple JSON-encode of a data structure is often the costliest operation in code.</p>
			<p>
				Disk and network I/O operations are slow and unpredictable. Use timers to measure how long they take. Measure the size of the data that your code deals with. Track the size of <em>remote procedure call</em><em> (RPC</em><em>)</em> payloads. Track the size of data generated for I/O using histograms (similar to timers) so you can see 99th percentile data sizes. Large data has an impact on memory footprint, I/O speed, and disk usage.</p>
			<p>Count every exception, error response code, and bad input. Measuring errors makes it easy to trigger an alert when things go wrong.</p>
			<p>Measure any requests to your application. An abnormally high or low request count is a sign that something is amiss. Users want your systems to respond quickly, so you need to measure latency. Time all responses so you know when your system is slow.</p>
			<p>Take time to understand how your metrics library works. It’s not always obvious how a library calculates a metric; many libraries will sample measurements. Sampling keeps performance fast and reduces disk and memory usage, but it also makes measurements less accurate.</p>
			<h2 id="h1-501836c04-0004"><span epub:type="pagebreak" id="Page_66" title="66"/>Traces</h2>
			<p class="BodyFirst">Developers all know about stack traces, but there’s a less familiar kind of trace: a <em>distributed call trace</em>. A single call to a frontend API might result in hundreds of downstream RPC calls to different services. Distributed call traces stitch all of these downstream calls together into one graph. Distributed traces are useful for debugging errors, measuring performance, understanding dependencies, and analyzing system cost (which APIs are the most expensive to serve, which customers cost the most, and so on).</p>
			<p>RPC clients use a tracing library to attach a call-trace ID to their request. Subsequent RPC calls by downstream services attach the same call-trace ID. Services then report the invocations that they receive along with the call-trace ID and other data, such as metadata tags and processing time. A dedicated system records all these reports and stitches call traces back together by call-trace ID. With this knowledge, the tracing system can present full distributed call graphs.</p>
			<p>Call-trace IDs are usually propagated for you automatically through RPC client wrappers and service meshes. Verify that you’re propagating any required state as you make calls to other services.</p>
			<h2 id="h1-501836c04-0005">Configuration</h2>
			<p class="BodyFirst">Applications and services should expose settings that allow developers or site reliability engineers (SREs) to configure runtime behavior. Applying configuration best practices will make your code easier to run. Don’t get too creative; use a standard configuration format, provide sensible defaults, validate configuration inputs, and avoid dynamic configuration when possible.</p>
			<p>Configuration can be expressed in many ways:</p>
			<ul>
				<li>Files in plain, human-readable formats such as INI, JSON, or YAML</li>
				<li>Environment variables</li>
				<li>Command line flags</li>
				<li><span epub:type="pagebreak" id="Page_67" title="67"/>A custom <em>domain-specific language</em><em> (DSL</em><em>)</em></li>
				<li>The language the application is written in</li>
			</ul>
			<p>
				Human-readable config files, environment variables, and command line flags are the most common approaches. Files are used when there are many values to set or there’s a desire to version control the configurations. Environment variables are easy to set in scripts, and environments can be easily examined and logged. Command line flags are easy to set and are visible in process lists like <code>ps</code>.</p>
			<p>
				DSLs are helpful when configuration needs programmable logic, like <code>for</code> loops or <code>if</code> statements. DSL-based configuration is commonly used when an application is written in a DSL-friendly language (like Scala). Using a DSL rather than a full-blown programming language, authors can provide shortcuts for complex operations and limit configurations to safe values and types—an important consideration for security and startup performance. But DSLs are hard to parse using standard tools, which makes interoperability with other tools difficult.</p>
			<p>Expressing configuration in the application’s language usually happens when the application is written in a scripting language like Python. Using code to generate configuration is powerful but also dangerous. Customizable logic obscures the configuration the application is seeing.</p>
			<h3 id="h2-501836c04-0017">Don’t Get Creative with Configuration</h3>
			<p class="BodyFirst">Configuration systems should be boring. An operator paged at 3 <span class="KeyCaps">AM</span> shouldn’t need to remember Tcl syntax to change a timeout value.</p>
			<p>
				Innovating on a configuration system is tempting. Configuration is familiar to everyone, and simple configuration systems seem to miss useful features—variable substitution, <code>if</code> statements, and so on. Many creative and well-meaning people have spent incredible amounts of time making fancy configuration systems. Sadly, the cleverer your configuration scheme is, the more bizarre your bugs will be. Do not get creative with configuration—use the simplest possible approach that will work. A static configuration file in a single standard format is ideal.</p>
			<p><span epub:type="pagebreak" id="Page_68" title="68"/>Most applications are configured through a static configuration file. Changing the file while the application is running won’t affect the application; to pick up changes, the application needs to be restarted. Dynamic configuration systems are used when an application needs to be reconfigured without restarting. Dynamic configuration is typically stored in a dedicated configuration service, which gets polled or pushed by the application when values change. Alternatively, dynamic configuration is refreshed by periodically checking a local config file for updates.</p>
			<p>Dynamic configuration is usually not worth the complexity it introduces. You need to think through all the implications of various configurations changing midflight. It also makes it harder to track when configuration was changed, who changed it, and what the value used to be—information that can be critical when debugging operational issues. It can also add external dependencies on other distributed systems. It sounds rudimentary, but restarting a process to pick up a new configuration is usually operationally and architecturally superior.</p>
			<p>There are some common use cases that do warrant dynamic configuration, though. Log verbosity is frequently a dynamic setting. Operators can change the log level to a higher verbosity like DEBUG when something strange is going on. Restarting a process when odd behavior surfaces might change the behavior that you’re trying to observe. Flipping a running process’s log level lets you peek into its behavior without restarting.</p>
			<h3 id="h2-501836c04-0018">Log and Validate All Configuration</h3>
			<p class="BodyFirst">Log all (nonsecret) configuration immediately upon startup to show what the application is seeing. Developers and operators occasionally misunderstand where a configuration file is supposed to be placed or how multiple configuration files get merged. Logging config values shows users whether the application is seeing the expected configuration.</p>
			<p>
				Always validate configuration values when they’re loaded. Do the validation only once, as early as possible (right after the configuration <span epub:type="pagebreak" id="Page_69" title="69"/>is loaded). Make sure that the values are set to the proper types, such as an integer for a port, and check that values make logical sense: check boundaries, string length, valid enum values, and so on. <code>–200</code> is an integer but not a valid port. Take advantage of configuration systems that have robust type systems to express acceptable configuration values.</p>
			<h3 id="h2-501836c04-0019">Provide Defaults</h3>
			<p class="BodyFirst">If a user has to set a large number of configuration parameters, your system will be hard to run. Set good defaults so your application will work well for most users out of the box. Default to network ports greater than 1024 (lower ports are restricted) if no port is configured. Use the system’s temporary directory or the user’s home directory if directory paths are unspecified.</p>
			<h3 id="h2-501836c04-0020">Group Related Configuration</h3>
			<p class="BodyFirst">It’s easy for application configuration to grow unmanageable, especially key-value formats that don’t support nested configuration. Use a standard format like YAML that allows for nesting. Grouping related properties makes configuration easier to organize and maintain.</p>
			<p>
				Combine tightly coupled parameters (like timeout duration and unit) in a single structure so the relationship is clear, and force the operator to declare the values atomically. Rather than defining <code>timeout_duration=10</code> and <code>timeout_units=second</code>, use <code>timeout=10s</code> or <code>timeout: { duration: 10, units = second }</code>.</p>
			<h3 id="h2-501836c04-0021">Treat Configuration as Code</h3>
			<p class="BodyFirst">The <em>configuration as code (CAC)</em> philosophy says that configuration should be subjected to the same rigor as code. Configuration mistakes can be disastrous. A single incorrect integer or missing parameter can break an application.</p>
			<p>
				To keep configuration changes safe, configuration should be version controlled, reviewed, tested, built, and published. Keep configuration in a VCS like Git so you have a history of changes. Review configuration <span epub:type="pagebreak" id="Page_70" title="70"/>changes just like code reviews. Validate that configuration is properly formatted and conforms to expected types and value bounds. Build and publish configuration packages. We cover more on config delivery in Chapter 8.</p>
			<h3 id="h2-501836c04-0022">Keep Configuration Files Clean</h3>
			<p class="BodyFirst">Clean configuration is easier for others to understand and change. Delete unused configuration, use standard formatting and spacing, and don’t blindly copy configuration from other files (an example of <em>cargo culting</em>: copying things without actually understanding what they do or how they work). Tidy configuration is hard to maintain when you’re iterating quickly, but misconfiguration causes production outages.</p>
			<h3 id="h2-501836c04-0023">Don’t Edit Deployed Configuration</h3>
			<p class="BodyFirst">Avoid hand-editing configuration on a specific machine. One-off config changes are overwritten on subsequent deployments, it’s unclear who made the changes, and machines with similar configuration end up diverging.</p>
			<p>As with keeping configuration files clean, resisting the temptation to hand-edit a config file in production is difficult, and in some cases unavoidable. If you edit configuration manually during a production incident, make sure changes get committed to the source of truth (the VCS) later.</p>
			<h2 id="h1-501836c04-0006">Tools</h2>
			<p class="BodyFirst">Operable systems come with tools that help operators run the application. Operators might need to bulk-load data, run a recovery, reset database state, trigger a leadership election, or shift a partition assignment from one machine to another. Systems should come with tools to help operators deal with common operations.</p>
			<p>
				Tool writing is collaborative. In some cases, you will be expected to write and supply operations tools. Organizations with strong SRE teams <span epub:type="pagebreak" id="Page_71" title="71"/>might also write tools for your systems. Regardless, work with your operations team to understand what they need.</p>
			<p>SREs will usually prefer CLI-based tools and self-describing APIs since they are easily scriptable. Scriptable tools are easy to automate. If you plan on building UI-based tools, abstract the logic into a shared library or service that CLI-based tools can use as well. And treat your system’s tools as code like any other: follow clean coding standards and test rigorously.</p>
			<p>
				Your company might already have an existing toolset; it’s common to have a standard internal web tools framework, for example. Integrate your tools with the standard frameworks available to you. Look for <em>single panes of glass</em> (unified management consoles). Companies with unified management consoles will expect all tools to be integrated with it. If your company has existing CLI-based tools, ask if it makes sense to integrate your tools with them. Everyone is used to the existing tool interfaces; integrating with them will make your tools easier to work with.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="box trade">
					<h2>Amazon Brings Down the Internet</h2>
					<p class="BoxBodyFirst">On February 28, 2017, Chris was in a meeting room in the office when he noticed that the meeting scheduling software, Zoom, stopped working. Not thinking much of it, he found himself back at his desk a few minutes later. He noticed that several major websites were acting funny. At this point, he heard from the operations team that Amazon Web Services (AWS) was having issues with its S3 storage system. Many large websites depend on Amazon, and Amazon depends heavily on S3. This was impacting basically the entire internet. Twitter began to fill with “Guess it’s a snow day” and “Time to go home.”</p>
					<p>
						Amazon eventually posted a note describing what happened. An operations team was investigating a billing subsystem. An engineer executed a command to remove a small number of <span epub:type="pagebreak" id="Page_72" title="72"/>machines from the S3 billing pool. The engineer “fat fingered” (made a typo in) the node-count parameter. A lot more machines than intended were removed from the node pool, which triggered a full restart in several other critical subsystems. Eventually, this cascaded to a multihour outage that impacted many other top-tier companies.</p>
					<p>Amazon’s note has this brief, but telling, comment: “We are making several changes as a result of this operational event. While removal of capacity is a key operational practice, in this instance, the tool used allowed too much capacity to be removed too quickly. We have modified this tool to remove capacity more slowly and added safeguards to prevent capacity from being removed when it will take any subsystem below its minimum required capacity level. This will prevent an incorrect input from triggering a similar event in the future. We are also auditing our other operational tools to ensure we have similar safety checks.”</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<h2 id="h1-501836c04-0007">Do’s and Don’ts</h2>
			<table border="1" class="trade" id="tabular-501836c04-0001">
				<thead>
					<tr>
						<td><b>Do’s</b></td>
						<td><b>Don’ts</b></td>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td><b>DO</b> prefer compilation errors to runtime errors.<br/></td>
						<td><b>DON’T</b> use exceptions for application logic.<br/></td>
					</tr>
					<tr>
						<td><b>DO</b> make things immutable whenever possible.<br/></td>
						<td><b>DON’T</b> use return codes for exception handling.<br/></td>
					</tr>
					<tr>
						<td><b>DO</b> validate inputs and outputs.<br/></td>
						<td><b>DON’T </b>catch exceptions that you can’t handle.<br/></td>
					</tr>
					<tr>
						<td><b>DO</b> study the OWASP Top 10.<br/></td>
						<td><b>DON’T</b> write multiline logs.<br/></td>
					</tr>
					<tr>
						<td><b>DO</b> use bug-checking tools and types or type hinting.<br/></td>
						<td><b>DON’T</b> write secrets or sensitive data to logs.<br/></td>
					</tr>
					<tr>
						<td><b>DO</b> clean up resources after exceptions (especially sockets, file pointers, and memory).<br/></td>
						<td><b>DON’T</b> manually edit configuration on a machine.<br/></td>
					</tr>
					<tr>
						<td><span epub:type="pagebreak" id="Page_73" title="73"/><b>DO</b> instrument your code with metrics.<br/></td>
						<td><b>DON’T</b> store passwords or secrets in configuration files.<br/></td>
					</tr>
					<tr>
						<td><b>DO</b> make your application configurable.<br/></td>
						<td><b>DON’T</b> write custom configuration formats.<br/></td>
					</tr>
					<tr>
						<td><b>DO</b> validate and log all configuration.<br/></td>
						<td><b>DON’T</b> use dynamic configuration if you can avoid it.<br/></td>
					</tr>
				</tbody>
			</table>
			<h2 id="h1-501836c04-0008">Level Up</h2>
			<p class="BodyFirst">There aren’t many books dedicated to writing operable code. Instead, these subjects appear in chapters throughout many software engineering books. Chapter 8 of Steve McConnell’s <em>Code Complete</em> (Microsoft Press, 2004) covers defensive programming. Chapters 7 and 8 of <em>Clean Code</em> by Robert C. Martin (Pearson, 2008) cover error handling and boundaries. These are good places to start.</p>
			<p>
				The web also has a lot of writing on defensive programming, exceptions, logging, configuration, and tooling. The <em>Amazon Builders’ Library</em> (<a class="LinkURL" href="https://aws.amazon.com/builders-library/">https://aws.amazon.com/builders-library/</a>) from Amazon is a particularly useful resource.</p>
			<p>
				Google SRE group’s <em>Building Secure &amp; Reliable Systems</em> (O’Reilly Media, 2020) is a treasure trove of sound advice, particularly from a security point of view. Google’s <em>Site Reliability Engineering</em> (O’Reilly Media, 2016) is the canonical book on all things site reliability related. It’s less focused on <em>writing</em> operable code, but it’s still a must-read. It will give you a glimpse into the complex world of running production software. Both are available for free online, as well as in print.</p>
			<aside class="endnote" epub:type="rearnote">
</aside>
		</section>
	</body>
</html>