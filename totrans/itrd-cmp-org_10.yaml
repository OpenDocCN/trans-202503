- en: '**10'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PROGRAMMING IN ASSEMBLY LANGUAGE**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg213_Image_246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In previous chapters, you learned how computers can be programmed using `1`s
    and `0`s to represent operations and data. Those `1`s and `0`s are the *machine
    language*. Now, we’ll move on to programming at the machine level. Instead of
    using machine language, we’ll use *assembly language*, which uses a short mnemonic
    for each machine language instruction. We’ll use an *assembler* program to translate
    the assembly language into the machine language instructions that control the
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a program in assembly language is similar to creating one in a higher-level
    compiled language such as C, C++, Java, or FORTRAN. I’ll use C as the programming
    model to explore the primary programming constructs and data structures that are
    common to essentially all higher-level programming languages. The compiler we’re
    using, `gcc`, allows us to look at the assembly language it generates. From there,
    I’ll show you how I would implement the programming constructs and data structures
    directly in assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by looking at the steps the compiler takes to create an executable
    program from C source code. Next, I’ll discuss which of these steps apply to assembly
    language programming and walk you through creating a program directly in assembly
    language that will run in the C hosted environment. You’ll also learn about a
    `gdb` mode that’s useful for learning assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: While reading this chapter, you should also consult the man pages and `info`
    documentation resources available in Raspberry Pi OS for the programs discussed
    here. You’ll probably need to install some of them on your Raspberry Pi, as described
    in “The Programming Environment” on [page 4](ch01.xhtml#ch01lev1sec3).
  prefs: []
  type: TYPE_NORMAL
- en: I’ll be using the GNU assembler program, `as`, quite a bit through the rest
    of the book. Some call this assembler `gas`, short for *GNU assembler*. I’ll explain
    what you need to know about using the `as` program, but I recommend getting a
    copy of the *Using as* manual so you can learn the details as we go. It’s available
    in the Software Development section at *[https://www.gnu.org/manual/manual.html](https://www.gnu.org/manual/manual.html)*,
    as part of the GNU Binutils collection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Starting in C**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `gcc` compiler creates an executable program from one or more source files
    by performing several distinct steps. Each step results in an intermediate file
    that serves as the input to the next step. The description of each step here assumes
    a single C source file, *filename.c*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Preprocessing**'
  prefs: []
  type: TYPE_NORMAL
- en: Preprocessing is the first step. This step resolves *preprocessor directives*
    such as `#include` (file inclusion), `#define` (macro definition), and `#if` (conditional
    compilation) by invoking the program `cpp`. Each preprocessor directive begins
    with the `#` character, which may be pronounced or not—for example, you may hear
    the `#include` directive referred to as *include*, *pound-include*, *hash-include*,
    or *hashtag-include*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compilation process can be stopped at the end of the preprocessing phase
    using the `-E` option, which writes the resulting C source code to *standard output*.
    Standard output is the plaintext output from a command line program in Linux.
    It is usually connected to the terminal window. You can redirect the output to
    a file with the `>` operator, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The *.i* file extension denotes a file that does not require preprocessing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Compilation**'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the compiler translates the source code that results from preprocessing
    into assembly language. The compilation process can be stopped at the end of the
    compilation phase with the `-S` option (an uppercase S), which writes the assembly
    language source code to *<filename>.s*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Assembly**'
  prefs: []
  type: TYPE_NORMAL
- en: After the compiler generates the assembly language that implements the C source
    code, the assembler program, `as`, translates the assembly language into machine
    code (instructions and data). The process can be stopped at the end of the assembly
    phase using the `-c` option, which writes the machine code to an *object file*
    named *<filename>.o*. In addition to the machine code, the object file includes
    metadata about the code used by the linker to resolve cross-references between
    different modules, determine where to locate the different parts of the program,
    and so forth. It also includes metadata about the module, for use by the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linking**'
  prefs: []
  type: TYPE_NORMAL
- en: The `ld` program determines where each function and data item will be located
    in memory when the program is executed. It replaces the programmer’s labels, where
    each is referenced with the memory address of the label. If a called function
    is in an external library, this is noted where the function is called, and the
    address of the external library function is determined during program execution.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler directs the `ld` program to add the computer code to the executable
    file that sets up the C hosted environment. This includes operations such as opening
    paths to standard output (the screen) and standard input (the keyboard) for use
    by the program.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this linking is written to an executable file. The default name
    of the executable file is *a.out*, but you can specify another name with the `-o`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t use any of the `gcc` options to stop the process at the end of
    one of these steps (`-E`, `-S`, `-c`), the compiler will perform all four steps
    and automatically delete the intermediate files, leaving only the executable program
    as the final result. You can direct `gcc` to keep all the intermediate files with
    the `-save-temps` option.
  prefs: []
  type: TYPE_NORMAL
- en: The complement of being able to stop `gcc` along the way is that we can supply
    files that have effectively gone through the earlier steps, and `gcc` will incorporate
    those files into the remaining steps. For example, if we write a file in assembly
    language (*.s*), `gcc` will skip the preprocessing and compilation steps and perform
    only the assembly and linking steps for that file. If we supply only object files
    (*.o*), `gcc` will go directly to the linking step. An implicit benefit of this
    is that we can write programs in assembly language that call functions in the
    C standard library (which are already in object file format), and `gcc` will automatically
    link our assembly language with those library functions.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to use the filename extensions specified in the GNU programming environment
    when naming a file. The default action of the compiler at each step depends upon
    the filename extension appropriate to that step. To see these naming conventions,
    enter info gcc into the command line, select **Invoking GCC**, and then select
    **Overall Options**. If you don’t use the specified filename extension, the compiler
    might not do what you want or might even overwrite a required file.
  prefs: []
  type: TYPE_NORMAL
- en: '***From C to Assembly Language***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Programs written in C are organized into functions. Each function has a name
    that is unique within the program. After the C hosted environment is set up, the
    `main` function is called, so our programs will start with a `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by looking at the assembly language that `gcc` generates for the
    minimum C program in [Listing 10-1](ch10.xhtml#ch10list1).
  prefs: []
  type: TYPE_NORMAL
- en: '*do_nothing.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-1: The minimum C program*'
  prefs: []
  type: TYPE_NORMAL
- en: This program does nothing except return 0 to the operating system. A program
    can return various numerical error codes; 0 indicates that the program did not
    detect any errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though this program accomplishes very little, some instructions need to
    be executed just to return 0\. To see what takes place, we’ll first translate
    this program from C to assembly language with the following Linux command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re not familiar with the GNU* make *program, it’s worth learning how
    to use it to build your programs. It may seem like overkill at this point, but
    it’s much easier to learn with simple programs. The manual is available in several
    formats at* [https://www.gnu.org/software/make/manual/](https://www.gnu.org/software/make/manual/),
    *and I have some comments about using it on my website at* [https://rgplantz.github.io](https://rgplantz.github.io).'
  prefs: []
  type: TYPE_NORMAL
- en: Before showing the result of this command, I’ll explain the options I’ve used.
    The `-O0` (uppercase O and zero) option tells the compiler not to use any optimization.
    This is in keeping with the goal of this book, which is to show what’s taking
    place at the machine level; asking the compiler to optimize the code may obscure
    some important details.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve already learned that the `-Wall` option asks the compiler to warn you
    about questionable constructions in your code. That’s not likely to be an issue
    in this simple program, but it’s a good habit to get into.
  prefs: []
  type: TYPE_NORMAL
- en: The `-S` option directs the compiler to stop after the compilation phase and
    write the assembly language resulting from the compilation to a file with the
    same name as the C source code file, but with the *.s* extension instead of *.c*.
    The previous compiler command generates the assembly language shown in [Listing
    10-2](ch10.xhtml#ch10list2), which is saved in the file *do_nothing.s*.
  prefs: []
  type: TYPE_NORMAL
- en: '*do_nothing.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-2: The minimum C program in assembly language generated by the
    compiler*'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to notice in [Listing 10-2](ch10.xhtml#ch10list2) is that assembly
    language is organized by lines. Only one assembly language statement is on each
    line, and none of the statements spans more than one line. This differs from the
    free-form nature of many high-level languages, where the line structure is irrelevant.
    In fact, good programmers use the ability to write program statements across multiple
    lines and indentation to emphasize the structure of their code. Good assembly
    language programmers use blank lines to help separate parts of an algorithm, and
    they comment almost every line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lines are organized roughly into columns. They probably do not make much
    sense to you at this point because they’re written in assembly language, but if
    you look carefully, each of the lines is organized into four possible fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Not all the lines will have entries in all the fields. The assembler requires
    at least one space or tab character to separate the fields. When writing assembly
    language, your program will be much easier to read if you use the TAB key to move
    from one field to the next so the columns line up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at each field in a bit more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: label This field allows us to give a symbolic name to a memory address in the
    program. Other parts of the program can then refer to the memory address by name.
    A label consists of an identifier immediately followed by the `:` character. I’ll
    cover the rules for creating an identifier soon. Only the lines that need to be
    referred to are labeled.
  prefs: []
  type: TYPE_NORMAL
- en: operation This field contains either an *instruction operation code (opcode)*
    or an *assembler directive* (sometimes called a *pseudo-op*). The assembler translates
    an opcode and its operands into machine instructions, which are copied into memory
    when the program is to be executed. Assembler directives are instructions to the
    assembler program that guide the assembly process.
  prefs: []
  type: TYPE_NORMAL
- en: operand(s) This field specifies the arguments to be used in the operation. The
    arguments can be explicit values, names of registers, or programmer-created names.
    There may be zero to several operands, depending on the operation.
  prefs: []
  type: TYPE_NORMAL
- en: comment Everything on a line following two `/` characters (`//`) is ignored
    by the assembler, thus providing a way for the programmer to provide human-readable
    comments. Since assembly language is not as easy to read as higher-level languages,
    good programmers will place a comment on almost every line. Of course, the compiler
    has not commented the code in [Listing 10-2](ch10.xhtml#ch10list2) because it
    has no way of knowing the programmer’s intent.
  prefs: []
  type: TYPE_NORMAL
- en: You probably noticed that most of the operators in [Listing 10-2](ch10.xhtml#ch10list2)
    begin with a `.` character. These are assembler directives. Each assembler directive
    begins with the `.` character, which may be pronounced or not—for example, you
    might hear `.text` referred to as *text* or *dot-text*. These are instructions
    to the assembler program itself, not computer instructions. The compiler generates
    some assembler directives that we won’t need for the assembly language we write
    in this book; we’ll take a quick look at those next, then look at the required
    directives.
  prefs: []
  type: TYPE_NORMAL
- en: '***Unused Assembler Directives***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The assembler directives in [Listing 10-2](ch10.xhtml#ch10list2) that begin
    with `.cfi` tell the assembler to generate information that can be used for debugging
    and certain error situations. The labels beginning with `.LF` mark places in the
    code used to generate this information. A discussion of this is beyond the scope
    of this book, but their appearance in the listing can be confusing, so we’ll tell
    the compiler not to include them in the assembly language file using the `-fno-asynchronous-unwind-tables`
    and `-fno-unwind-tables` options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This produces the file *do_nothing.s*, shown in [Listing 10-3](ch10.xhtml#ch10list3).
    I’ve used boldface to show the directives that we will use and left the ones we
    won’t use unbolded. The compiler did not comment the assembly language code in
    this listing, but I’ve added my own comment using `///` to help you see the relationship
    with the C source code. I’ll add my own comments to many of the compiler-generated
    assembly language listings I show in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '*do_nothing.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-3: The minimum C program in assembly language generated by the
    compiler, without* .cfi *directives*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve stripped away the `.cfi` directives, but we still have several assembler
    directives that we won’t need when we write our own functions in assembly language.
    These include:'
  prefs: []
  type: TYPE_NORMAL
- en: .file This is used by `gcc` to specify the name of the C source file that this
    assembly language came from. This directive isn’t used when writing directly in
    assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: .size This computes the size of the machine code, in bytes, that results from
    assembling this file. The `.` symbol refers to the current address in the code,
    so the arithmetic expression `.-main` subtracts the address of `main` from the
    current address. The `.size` directive associates this value with the `main` label
    as part of the metadata in the object file, thus giving the number of bytes in
    this function. This can be useful information in systems with limited memory,
    but it’s of no concern in our programs.
  prefs: []
  type: TYPE_NORMAL
- en: .ident This provides information in the object file about the compiler that
    was used. This might be useful in large projects that have evolved over several
    years, but we won’t need it.
  prefs: []
  type: TYPE_NORMAL
- en: .section This provides guidance to the linker about how the stack should be
    treated for this function. We won’t include it and will just accept the default
    settings of the linker.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at the directives that will be required when we write in assembly
    language.
  prefs: []
  type: TYPE_NORMAL
- en: '***Required Assembler Directives***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The required assembler directives are shown in boldface in [Listing 10-3](ch10.xhtml#ch10list3).
  prefs: []
  type: TYPE_NORMAL
- en: There are several variations of the ARM instruction set architecture, and it
    continues to evolve. The `.arch` assembler directive tells the assembler which
    ARM architecture we’re using. It causes the assembler to warn us if we use an
    instruction that is not available in our specific architecture. The `.arch` directive
    is arguably not required for the simple programs we’re writing in this book, but
    we’ll use it to be on the safe side.
  prefs: []
  type: TYPE_NORMAL
- en: The `.text` assembler directive tells the assembler to place whatever follows
    in the text section. What does *text section* mean? In Linux, the object files
    produced by the assembler are in the *Executable and Linkable Format (ELF)*. The
    ELF standard specifies many types of sections, each specifying the type of information
    stored in it. We use assembler directives to tell the assembler in which section
    to place the code. The text section is where the program’s executable instructions
    go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Linux operating system also divides memory into *segments* for specific
    purposes when a program is loaded from the disk. The linker gathers together all
    the sections that belong in each segment and outputs an executable ELF file that’s
    organized by segment to make it easier for the operating system to load the program
    into memory. The four general types of segments are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text (also called code)** The *text segment* is where program instructions
    and constant data are stored. The operating system prevents a program from changing
    anything stored in the text segment, making it read-only.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data** Global variables and static local variables are stored in the *data
    segment*. Global variables can be accessed by any of the functions in a program.
    A static local variable can be accessed only by the function it’s defined in,
    but its value remains the same between calls to its function. Programs can both
    read from and write to variables in the data segment. These variables remain in
    place for the duration of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack** Automatic local variables and the information that links functions
    are stored on the *call stack*. Automatic local variables are created when a function
    is called and deleted when the function returns to its calling function. A program
    can both read from and write to memory on the stack; it’s allocated and deallocated
    dynamically as the program executes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Heap** The *heap* is a pool of memory that’s available for a program to use
    when running. A C program calls the `malloc` function (C++ programs call `new`)
    to get a chunk of memory from the heap. Programs can both read from and write
    to heap memory; it’s used to store data and is explicitly deallocated by calling
    `free` (`delete` in C++) in the program.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This is a simplistic overview of ELF sections and segments. For more details,
    read the man page for ELF and sources such as “ELF-64 Object File Format,” which
    you can download at* [https://uclibc.org/docs/elf-64-gen.pdf](https://uclibc.org/docs/elf-64-gen.pdf),
    *and John R. Levine’s* Linkers & Loaders *(Morgan Kaufmann, 1999). The* readelf
    *program is also useful for learning about ELF files.*'
  prefs: []
  type: TYPE_NORMAL
- en: The `.align` directive is used to align the code following it on an address
    boundary. The argument used in [Listing 10-3](ch10.xhtml#ch10list3), `2`, has
    different meanings depending on the platform you’re using. On the ARM platform,
    it specifies the number of low-order bits that should be `0` in the program counter.
    If the bits are not `0`, the assembler increments the address until they are.
    Thus, the code that follows this `.align 2` directive will start at a full word
    address.
  prefs: []
  type: TYPE_NORMAL
- en: The `.global` directive has one argument, the identifier `main`. The `.global`
    directive makes the name globally known, so functions that are defined in other
    files can refer to this name. The code that sets up the C hosted environment was
    written to call the function named `main`, so the name must be global in scope.
    All C/C++ programs start with a `main` function. In this book, I’ll also start
    the assembly language programs with a `main` function and execute them within
    the C hosted environment.
  prefs: []
  type: TYPE_NORMAL
- en: You can write stand-alone assembly language programs that don’t depend on the
    C hosted environment, in which case you can create your own name for the first
    function in the program. You need to stop the compilation process at the end of
    the assembly step with the `-c` option. You then link the object (*.o*) files
    using the `ld` command by itself, not as part of `gcc`. I’ll describe this in
    more detail in [Chapter 21](ch21.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.type` directive has two arguments: `main` and `@function`. This causes
    the identifier `main` to be recorded in the object file as the name of a function.'
  prefs: []
  type: TYPE_NORMAL
- en: These last three directives are not translated into actual machine instructions.
    Rather, they’re used to describe the characteristics of the statements that follow.
    In the next chapter, we’ll start seeing assembler directives that store constant
    data in memory for the program to use.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how the compiler translates C code into assembly language,
    let’s look at how to write a program directly in assembly language. In the Introduction,
    I said you should avoid writing programs in assembly language. But the goal of
    this book is to help you learn how computers work at the machine level. Writing
    programs directly in assembly language is a better learning technique than just
    reading what the compiler does.
  prefs: []
  type: TYPE_NORMAL
- en: '**Starting in Assembly Language**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing 10-4](ch10.xhtml#ch10list4) was written in assembly language by a
    programmer (me), rather than by a compiler. Naturally, I’ve added comments to
    explain what my code accomplishes.'
  prefs: []
  type: TYPE_NORMAL
- en: '*do_nothing.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-4: The minimum C-style program written in assembly language*'
  prefs: []
  type: TYPE_NORMAL
- en: The first line begins with two slashes, `//`. Everything after those two characters,
    up to the end of the line, is a comment and does not generate any action by the
    assembler. Comments can be started with two slashes at any place on a line. As
    in a high-level language, they are intended solely for human readers and have
    no effect on the program.
  prefs: []
  type: TYPE_NORMAL
- en: This comment line is followed by a blank line, also causing no action by the
    assembler, but very helpful for human readability.
  prefs: []
  type: TYPE_NORMAL
- en: A word about program comments here. Beginners often comment on what the programming
    statement does, not its purpose relative to solving the problem. Your comments
    should describe what *you* are doing, not what the computer is doing. For example,
    a comment like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: in C is not very useful. But a comment like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: could be very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: After the five assembler directives that we’re using in our assembly language
    programs (described in the previous section), we see the label `main` on the first
    memory address in this function ❶. It’s common to place a label on its own line,
    in which case it applies to the address of the next assembly language statement
    that takes up memory ❷. This allows you to create longer, more meaningful labels
    while maintaining the column organization of your code, to improve readability.
  prefs: []
  type: TYPE_NORMAL
- en: '***Symbolic Names in Assembly Language***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since this is the top-level function in this program, the label `main` is required,
    but we’ll soon be writing programs that require us to create our own names. The
    rules for creating a symbolic name are similar to those for C/C++. Each name starts
    with either a letter or the character `.` or `_` followed by a string of letters,
    numerals, and/or `$` and `_` characters. The first character must not be a numeral,
    except for local labels, as described shortly. A name may be any length, and all
    characters are significant. Although the letter case of keywords (operators, register
    names, directives) is not significant, it is significant for labels. For example,
    `my_label` and `My_label` are different. Compiler-generated labels begin with
    the `.` character, and many system-related names begin with the `_` character;
    it’s a good idea to avoid beginning your own labels with these characters so you
    don’t inadvertently create one that’s already being used by the system.
  prefs: []
  type: TYPE_NORMAL
- en: Our assembler also allows us to use an unsigned integer, N, to create a *local
    label*. Your assembly language code can refer to these labels as N`b` for the
    most recently used (N *backward*) and N`f` for the next used (N *forward*). This
    means you can have more than one local label with the same number. While it might
    seem to simplify your code writing, using local labels is usually not a good programming
    technique because the names don’t show the purpose of the labels.
  prefs: []
  type: TYPE_NORMAL
- en: '***Basic Format of Assembly Language Instructions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'ARM instructions fall into three categories: load and store, data processing,
    and program flow control. We’ll start by looking at the general format of the
    assembly language instruction. Rather than list all the A64 instructions, I will
    introduce a few at a time—the ones that will be needed to illustrate the programming
    concept at hand. I will also give only the commonly used variants of those instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: For a detailed description of the instructions and all their variants, download
    a copy of the *Arm Architecture Reference Manual for A-Profile Architecture* from
    *[https://developer.arm.com/documentation/ddi0487/latest](https://developer.arm.com/documentation/ddi0487/latest)*.
    This manual can be a little difficult to read, but going back and forth between
    my descriptions of the instructions in this book and the descriptions in the manual
    should help you learn how to read the manual.
  prefs: []
  type: TYPE_NORMAL
- en: Assembly language provides a set of mnemonics that correspond directly to the
    machine language instructions. A *mnemonic* is a short, English-like group of
    characters that suggests the action of the instruction. Even if you’ve never seen
    assembly language before, the `mov w0, wzr` instruction in [Listing 10-4](ch10.xhtml#ch10list4)
    ❷ probably makes much more sense to you than the machine code it represents, `0x2a1f03e0`.
    You can probably figure out that it moves the contents of the 32-bit zero register
    `wzr` to the `w0` register. You’ll see what that means in the next few paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, the mnemonics are completely arbitrary, as long as you have
    an assembler program that will translate them into the desired machine instructions.
    However, most assembler programs follow the mnemonics used in the manuals provided
    by CPU vendors.
  prefs: []
  type: TYPE_NORMAL
- en: ARM uses a *load and store architecture*, which means data items must be loaded
    into registers or be part of the instruction itself before they can be used in
    an arithmetic or logic operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general format of a load or store instruction is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The memory_address is either a label on a memory address or the name of a register
    that contains the address. Load instructions copy the data item from the memory_address
    to the register. Store instructions copy the data item from the register to the
    memory_address. In most cases, you will be dealing with only one data item for
    each load or store instruction, but the A64 architecture includes load and store
    instructions that allow you to work with two data items in separate registers
    with one instruction. You’ll see how this works in [Chapter 11](ch11.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Data processing instructions—arithmetic and logic operations—have the general
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first operand is where the result of the operation is placed. Some instructions
    use two registers for the results. There can be from one to three source(s), which
    are registers or an *immediate value*. An immediate value is an explicit constant.
  prefs: []
  type: TYPE_NORMAL
- en: Instructions that control program flow have the general format
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The memory_address is either a label on a memory address or the name of a register
    that contains the address. The data must be in a register or an immediate value.
  prefs: []
  type: TYPE_NORMAL
- en: '***Symbols Used for Instruction Descriptions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is a list of symbols I’ll use for describing instructions in this book,
    which are a little different from those used in the Arm manual:'
  prefs: []
  type: TYPE_NORMAL
- en: wd A 32-bit destination register for the result of an operation.
  prefs: []
  type: TYPE_NORMAL
- en: xd A 64-bit destination register for the result of an operation.
  prefs: []
  type: TYPE_NORMAL
- en: ws**,** wn A 32-bit source register for an operation. If there’s more than one
    source register, they are numbered.
  prefs: []
  type: TYPE_NORMAL
- en: xs**,** xn A 64-bit source register for an operation. If there’s more than one
    source register, they are numbered.
  prefs: []
  type: TYPE_NORMAL
- en: xb**,** xn A 64-bit register that holds a base address.
  prefs: []
  type: TYPE_NORMAL
- en: offset A constant number that is added to a base address.
  prefs: []
  type: TYPE_NORMAL
- en: imm A constant number whose size depends on the instruction.
  prefs: []
  type: TYPE_NORMAL
- en: amnt The number of bits to shift a source operand.
  prefs: []
  type: TYPE_NORMAL
- en: addr An address, typically a label.
  prefs: []
  type: TYPE_NORMAL
- en: cond A logical combination of the bits in the `nzcv` register.
  prefs: []
  type: TYPE_NORMAL
- en: xtnd Specifies a wider version of an operand to use in an operation.
  prefs: []
  type: TYPE_NORMAL
- en: '{} Indicates one or more operands that are optional.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Indicates that either the operand on the left or the operand on the right
    can be used.'
  prefs: []
  type: TYPE_NORMAL
- en: The registers can be any of the 31 general-purpose registers described in [Chapter
    9](ch09.xhtml). Most instructions also allow us to use the `wzr`, `xzr`, `wsp`,
    and `sp` registers.
  prefs: []
  type: TYPE_NORMAL
- en: '***First Instructions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Again, I won’t describe all the instructions, nor will I describe all the variants
    of the instructions that I do describe. My aim is to equip you with the information
    you need to understand the programming concepts I introduce in this book and to
    be comfortable using other sources as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the most commonly used assembly language instruction, `mov`.
    Some of the variations of this instruction follow; you can find more in the Arm
    manual:'
  prefs: []
  type: TYPE_NORMAL
- en: mov**—Move register**
  prefs: []
  type: TYPE_NORMAL
- en: '`mov w`d, `w`s `|wzr` copies the 32-bit value in `w`s or `wzr` to `w`d and
    zeros bits 63 to 32 of `x`d.'
  prefs: []
  type: TYPE_NORMAL
- en: '`mov x`d, `x`s `|xzr` copies the 64-bit value in `x`s or `xzr` to `x`d.'
  prefs: []
  type: TYPE_NORMAL
- en: mov**—Move to or from** sp
  prefs: []
  type: TYPE_NORMAL
- en: '`mov x`d `|sp, x`s `|sp` copies the 64-bit value in `x`s or `sp` to `x`d or
    `sp`.'
  prefs: []
  type: TYPE_NORMAL
- en: mov**—Move immediate**
  prefs: []
  type: TYPE_NORMAL
- en: '`mov w`d`,` imm copies the 16-bit value imm to the low-order part of `w`d and
    zeros bits 63 to 16 of `x`d.'
  prefs: []
  type: TYPE_NORMAL
- en: '`mov x`d`,` imm copies the 16-bit value imm to the low-order part of `x`d and
    zeros bits 63 to 16 of `x`d.'
  prefs: []
  type: TYPE_NORMAL
- en: movz**—Move immediate and zero**
  prefs: []
  type: TYPE_NORMAL
- en: '`movz w`d`,` imm`{, lsl` amnt`}` copies the 16-bit value imm to `w`d, optionally
    shifted amnt bits to the left. The other 48 bits of `x`d are set to `0`. amnt
    can be `0` (the default) or `16`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`movz x`d`,` imm`{, lsl` amnt`}` copies the 16-bit value imm to `x`d, optionally
    shifted amnt bits to the left. The other 48 bits of `x`d are set to `0`. amnt
    can be `0` (the default), `16`, `32`, or `48`.'
  prefs: []
  type: TYPE_NORMAL
- en: movk**—Move immediate and keep**
  prefs: []
  type: TYPE_NORMAL
- en: '`movk w`d`,` imm`{, lsl` amnt`}` copies the 16-bit value imm to `w`d, optionally
    shifted amnt bits to the left. The other 48 bits of `x`d are not changed. amnt
    can be `0` (the default) or `16`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`movk x`d`,` imm`{, lsl` amnt`}` copies the 16-bit value imm to `x`d, optionally
    shifted amnt bits to the left. The other 48 bits of `x`d are not changed. amnt
    can be `0` (the default), `16`, `32`, or `48`.'
  prefs: []
  type: TYPE_NORMAL
- en: movn**—Move immediate and NOT**
  prefs: []
  type: TYPE_NORMAL
- en: '`movn w`d`,` imm`{, lsl` amnt`}` copies the inverse of the 16-bit value imm
    to `w`d, optionally shifted amnt bits to the left. The other 48 bits of `x`d are
    set to `1`. amnt can be `0` (the default) or `16`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`movn x`d`,` imm`{, lsl` amnt`}` copies the inverse of the 16-bit value in
    imm to `x`d, optionally shifted amnt bits to the left. The other 48 bits of `x`d
    are set to `1`. amnt can be `0` (the default), `16`, `32`, or `48`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only other instruction in [Listing 10-4](ch10.xhtml#ch10list4) is a `ret`,
    which causes a return to the calling function, assuming the return address is
    in `x30`:'
  prefs: []
  type: TYPE_NORMAL
- en: ret**—Return from a function**
  prefs: []
  type: TYPE_NORMAL
- en: '`ret` moves the address in `x30` to the program counter, `pc`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you see why I said in [Chapter 9](ch09.xhtml) that `x30` is commonly used
    as the link register: when a function is called, the return address is placed
    in `x30`. We’ll see how this works when we look at function calls in [Chapter
    11](ch11.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most valuable uses of `gdb` is as a learning tool. It has a mode
    that is especially helpful in learning what each assembly language instruction
    does. I’ll show you how to do this in the next section, using the program in [Listing
    10-4](ch10.xhtml#ch10list4). This will also help you to become more familiar with
    using `gdb`, which is an important skill to have when debugging your programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using gdb to Learn Assembly Language**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This would be a good place for you to run the program in [Listing 10-4](ch10.xhtml#ch10list4)
    so you can follow along with the discussion. You can assemble, link, and execute
    it with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `--gstabs` option (note the two dashes here) tells the assembler to include
    debugging information with the object file. The `gcc` program recognizes that
    the only input file is already an object file, so it goes directly to the linking
    stage. There is no need to tell `gcc` to include the debugging information, because
    the assembler already included it in the object file.
  prefs: []
  type: TYPE_NORMAL
- en: As you might guess from the name, you won’t see anything on the screen when
    you run this program. We’ll use `gdb` to walk through the execution of the program,
    which will allow us to see that this program actually does do something.
  prefs: []
  type: TYPE_NORMAL
- en: The `gdb` debugger has a mode that’s useful for seeing the effects of each assembly
    language instruction as it’s executed. The *text user interface (TUI)* mode splits
    the terminal window into a display pane at the top and the usual command pane
    at the bottom. The display pane can be further split into two display panes.
  prefs: []
  type: TYPE_NORMAL
- en: Each display pane can show either the source code (`src`), the registers (`regs`),
    or the disassembled machine code (`asm`). *Disassembly* is the process of translating
    the machine code (`1`s and `0`s) into the corresponding assembly language. The
    disassembly process does not know the programmer-defined names, so you will see
    only the numerical values that were generated by the assembly and linking processes.
    The `asm` display will probably be more useful when we look at the details of
    instructions in [Chapter 12](ch12.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The documentation for using the TUI mode is in `info` for `gdb`. I’ll give a
    simple introduction to using the TUI mode here, using our assembly language version
    of `do_nothing` from [Listing 10-4](ch10.xhtml#ch10list4). I’ll step through each
    of the instructions. You’ll get a chance to single-step through each of them in
    “Your Turn” [exercise 10.1](ch10.xhtml#ch10exe1) on [page 205](ch10.xhtml#commonL1).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*My example here shows* gdb *being run from the command line. I’ve been told
    that this doesn’t work well if you try to run* gdb *within Emacs.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did in [Chapter 2](ch02.xhtml), we’ll run `do_nothing` under `gdb`, but
    this time we’ll use the TUI mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This should bring up a screen like the one in [Figure 10-1](ch10.xhtml#ch10fig1).
    Note that [Figures 10-1](ch10.xhtml#ch10fig1) through [10-7](ch10.xhtml#ch10fig7)
    are zoomed in for readability; your screen view may look different, depending
    on your terminal window settings.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg227_Image_247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-1: Starting* gdb *in TUI mode gives the* src *display.*'
  prefs: []
  type: TYPE_NORMAL
- en: Enter c to continue through the preliminary message shown in this screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Next, set a breakpoint at the first instruction of the program and set a display
    layout. There are several display layouts available in TUI mode. We’ll use the
    `regs` layout, shown in [Figure 10-2](ch10.xhtml#ch10fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg228_Image_248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-2: Adding the* regs *display pane to the TUI window*'
  prefs: []
  type: TYPE_NORMAL
- en: The `layout regs` command divides the display pane into a `regs` pane and an
    `src` pane. I’ve moved the focus to the `regs` pane before telling `gdb` to run
    the program. The program starts with a `0x1` in the `x0` register (your value
    may differ). The instruction in the program that is about to be executed is highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: The display isn’t large enough to show all the A64 registers. With the focus
    on the `regs` pane, use the up and down arrow keys and the page up and page down
    keys to scroll through the register display. I pressed the page down key three
    times to get [Figure 10-3](ch10.xhtml#ch10fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg229_Image_249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-3: Viewing other registers*'
  prefs: []
  type: TYPE_NORMAL
- en: The value in `x30` shows the location the program will return to in the C hosted
    environment when it completes execution. You’ll see how this works in [Figure
    10-6](ch10.xhtml#ch10fig6). The value in `pc` is the address of the first instruction
    in our `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s tell `gdb` to execute a single instruction, as shown in [Figure 10-4](ch10.xhtml#ch10fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg230_Image_250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-4: Changes in the registers are highlighted.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 10-4](ch10.xhtml#ch10fig4), `gdb` highlights the next instruction
    to be executed as well as the registers that were changed. We knew `pc` would
    change, since we executed one instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction that was executed changed `x0`, but that doesn’t show in our
    `regs` display pane in [Figure 10-4](ch10.xhtml#ch10fig4). I used the page up
    key to give the view of `x0` in [Figure 10-5](ch10.xhtml#ch10fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg231_Image_251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-5: Viewing the register changed by the instruction that was just
    executed*'
  prefs: []
  type: TYPE_NORMAL
- en: The `x0` register is highlighted in [Figure 10-5](ch10.xhtml#ch10fig5) to show
    that it changed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll tell `gdb` to execute the `ret` instruction, which should take us
    back to the C hosted environment, as shown in [Figure 10-6](ch10.xhtml#ch10fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg232_Image_252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-6: Back in the C hosted environment*'
  prefs: []
  type: TYPE_NORMAL
- en: The `ret` instruction has copied the address from the link register, `x30`,
    to `pc`, thus implementing the return from the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we continue execution of the program in [Figure 10-7](ch10.xhtml#ch10fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg233_Image_253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-7: The program has completed.*'
  prefs: []
  type: TYPE_NORMAL
- en: All that remains is to quit `gdb`.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 10.1     Enter the program in [Listing 10-4](ch10.xhtml#ch10list4) and use `gdb`
    to single-step through the code.
  prefs: []
  type: TYPE_NORMAL
- en: '10.2     Write the following C function in assembly language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Make sure it assembles with no errors. Use the `-S` option to compile *f.c*
    and compare `gcc`’s assembly language with yours. Write a `main` function in C
    that tests your assembly language function, `f`, and prints out the function’s
    return value.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3     Write three assembly language functions that do nothing but return
    an integer. They should each return a different nonzero integer. Write a `main`
    function in C that tests your assembly language functions and prints out the functions’
    return values using `printf`.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4     Write three assembly language functions that do nothing but return
    a character. Each should return a different character. Write a `main` function
    in C that tests your assembly language functions and prints out the functions’
    return values using `printf`.
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Editor** A program used to write the source code for a program in the chosen
    programming language.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Preprocessing** The first stage of compilation. It brings other files into
    the source, interprets directives, and so forth, in preparation for actual compilation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compilation** Translates from the chosen programming language into assembly
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assembly** Translates assembly language into machine language.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linking** Links separate object code modules and libraries together to produce
    the final executable program.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assembler directives** Guide the assembler program during the assembly process.'
  prefs: []
  type: TYPE_NORMAL
- en: mov **instruction** Moves values within the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: ret **instruction** Returns program flow to the calling function.
  prefs: []
  type: TYPE_NORMAL
- en: gdb **TUI mode** Displays changes in registers in real time as you step through
    a program. It’s an excellent learning tool.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering what happens to the return address in `x30` if we call
    another function from `main`. To use `x30` as the link register to call the other
    function, we need to save the return address somewhere while the other function
    is being executed. You’ll learn how to do this in the next chapter, where we look
    at the details of how to pass arguments to functions, how to use the call stack,
    and how to create local variables in functions.
  prefs: []
  type: TYPE_NORMAL
