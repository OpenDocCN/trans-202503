["```\n#include <cstdio>\n\nconstexpr int isqrt(int n) {\n  int i=1;\n  while (i*i<n) ++i;\n  return i-(i*i!=n);\n}\n\nint main() {\n  constexpr int x = isqrt(1764); ➊\n  printf(\"%d\", x);\n}\n```", "```\n.LC0:\n        .string \"%d\"\nmain:\n        sub     rsp, 8\n        mov     esi, 42 ➊\n        mov     edi, OFFSET FLAT:.LC0\n        xor     eax, eax\n        call    printf\n        xor     eax, eax\n        add     rsp, 8\n        ret\n```", "```\nchar* itoa(int value, char* str, int base);\nchar* ltoa(long value, char* buffer, int base);\nchar* ultoa(unsigned long value, char* buffer, int base);\n```", "```\nchar* toa(int value, char* buffer, int base) {\n  --snip--\n}\n\nchar* toa(long value, char* buffer, int base)\n  --snip--\n}\n\nchar* toa(unsigned long value, char* buffer, int base) {\n  --snip--\n}\n\nint main() {\n  char buff[10];\n  int a = 1; ➊\n  long b = 2; ➋\n  unsigned long c = 3; ➌\n  toa(a, buff, 10);\n  toa(b, buff, 10);\n  toa(c, buff, 10);\n}\n```", "```\nstruct HolmesIV {\n  bool is_sentient;\n  int sense_of_humor_rating;\n};\nvoid make_sentient(HolmesIV*); // Takes a pointer to a HolmesIV\nvoid make_sentient(HolmesIV&); // Takes a reference to a HolmesIV\n```", "```\nvoid make_sentient(HolmesIV* mike) {\n  mike->is_sentient = true;\n}\n\nvoid make_sentient(HolmesIV& mike) {\n  mike.is_sentient = true;\n}\n```", "```\nmake_sentient(HolmesIV*):\n        mov     BYTE PTR [rdi], 1\n        ret\nmake_sentient(HolmesIV&):\n        mov     BYTE PTR [rdi], 1\n        ret\n```", "```\nvoid make_sentient(HolmesIV* mike) {\n  if(mike == nullptr) return;\n  mike->is_sentient = true;\n}\n```", "```\nHolmesIV& not_dinkum() {\n  HolmesIV mike;\n  return mike;\n}\n```", "```\nint main() {\n  int a = 42;\n  int& a_ref = a; ➊\n  int b = 100;\n  a_ref = b; ➋\n}\n```", "```\nint main() {\n  int a = 42;\n  int* a_ptr = &a; ➊\n  int b = 100;\n  *a_ptr = b; ➋\n}\n```", "```\nint x = 42;\nauto y = 42;\n```", "```\n#include <cstdlib>\n\nstruct HolmesIV {\n  --snip--\n};\nHolmesIV* make_mike(int sense_of_humor) {\n  --snip--\n}\n\nint main() {\n  auto mike = make_mike(1000);\n  free(mike);\n}\n```", "```\ntypedef struct Jabberwocks {\n  void* tulgey_wood;\n  int is_galumphing;\n} Jabberwock;\n```", "```\nstruct Jabberwock {\n  void* tulgey_wood;\n  int is_galumphing;\n};\n```", "```\n#include <cstdio>\n\nnamespace Creature { ➊\n  struct Jabberwock {\n    void* tulgey_wood;\n    int is_galumphing;\n  };\n}\nnamespace Func { ➋\n  void Jabberwock() {\n    printf(\"Burble!\");\n  }\n}\n```", "```\nCreature::Jabberwock x;\nFunc::Jabberwock();\n```", "```\n#include <cstdio>\n\nnamespace Creature {\n  struct Jabberwock {\n    void* tulgey_wood;\n    int is_galumphing;\n  };\n}\n\nnamespace Func {\n  void Jabberwock() {\n    printf(\"Burble!\");\n  }\n}\n\nusing namespace Creature; ➊\n\nint main() {\n  Jabberwock x; ➋\n  Func::Jabberwock();\n}\n```", "```\n// header.h\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nvoid extract_arkenstone();\n\nstruct MistyMountains {\n  int goblin_count;\n};\n#ifdef __cplusplus\n}\n#endif\n```", "```\nvoid extract_arkenstone();\n\nstruct MistyMountains {\n  int goblin_count;\n};\n```", "```\nextern \"C\" {\n  void extract_arkenstone();\n\n  struct MistyMountains {\n    int goblin_count;\n  };\n}\n```", "```\n#include <cstddef>\n\nint main() {\n  const size_t n{ 100 };\n  int v[n];\n\n  // ANSI-C\n  size_t i;\n  for (i=0; i<n; i++) v[i] = 0; ➊\n  // C99\n  for (size_t i=0; i<n; i++)  v[i] = 0; ➋\n\n  // C++17\n  for (auto& x : v) x = 0; ➌\n}\n```", "```\nvoid navigate_to(double x, double y);\n```", "```\nstruct Position{\n--snip--\n};\nvoid navigate_to(const Position& p);\n```", "```\nPosition* get_position(); ➊\nvoid get_position(Position* p); ➋\n```", "```\nPosition➊ get_position() {\n  --snip--\n}\nvoid navigate() {\n  auto p = get_position(); ➋\n  // p is now available for use\n  --snip--\n}\n```", "```\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n  std::vector<int> x{ 0, 1, 8, 13, 5, 2, 3 }; ➊\n  x[0] = 21; ➋\n  x.push_back(1); ➌\n  std::sort(x.begin(), x.end()); ➍\n  std::cout << \"Printing \" << x.size() << \" Fibonacci numbers.\\n\"; ➎\n  for (auto number : x) {\n    std::cout << number << std::endl; ➏\n  }\n}\n```", "```\nauto n_evens = std::count_if(x.begin(), x.end(),\n                             [] (auto number) { return number % 2 == 0; });\n```", "```\n[capture] (arguments) { body }\n```", "```\ntemplate <typename T>\nT add(T x, T y, T z) { ➊\n  return x + y + z;\n}\n\nint main() {\n  auto a = add(1, 2, 3);       // a is an int\n  auto b = add(1L, 2L, 3L);    // b is a long\n  auto c = add(1.F, 2.F, 3.F); // c is a float\n}\n```", "```\n#include <cstdio>\n\nstruct Hal {\n  Hal() : version{ 9000 } { // Constructor ➊\n    printf(\"I'm completely operational.\\n\");\n  }\n  ~Hal() { // Destructor ➋\n    printf(\"Stop, Dave.\\n\");\n  }\n  const int version;\n};\n```", "```\n#include <cstdio>\n\nstruct Hal {\n--snip--\n};\n\nint main() {\n  auto hal = new Hal{};  // Memory is allocated, then constructor is called\n  delete hal;            // Destructor is called, then memory is deallocated\n}\n-----------------------------------------------------------------------\nI'm completely operational.\nStop, Dave.\n```", "```\n#include <exception>\n\ntry {\n  // Some code that might throw a std::exception ➊\n} catch (const std::exception &e) {\n  // Recover the program here. ➋\n}\n```", "```\n#include <system_error>\n#include <cstdio>\n\nstruct File {\n  File(const char* path, bool write) { ➊\n    auto file_mode = write ? \"w\" : \"r\"; ➋\n    file_pointer = fopen(path, file_mode); ➌\n    if (!file_pointer) throw std::system_error(errno, std::system_category()); ➍\n  }\n  ~File() {\n    fclose(file_pointer);\n  }\n  FILE* file_pointer;\n};\n```", "```\nx ? val_if_true : val_if_false\n```", "```\n#include <cstdio>\n#include <system_error>\n#include <cstring>\n\nstruct File {\n--snip–\n};\n\nint main() {\n  { ➊\n    File file(\"last_message.txt\", true); ➋\n    const auto message = \"We apologize for the inconvenience.\";\n    fwrite(message, strlen(message), 1, file.file_pointer);\n  } ➌\n  // last_message.txt is closed here!\n  {\n    File file(\"last_message.txt\", false); ➍\n    char read_message[37]{};\n    fread(read_message, sizeof(read_message), 1, file.file_pointer);\n    printf(\"Read last message: %s\\n\", read_message);\n  }\n}\n-----------------------------------------------------------------------\nWe apologize for the inconvenience.\n```", "```\n#include <memory>\n\nstruct Foundation{\n  const char* founder;\n};\n\nint main() {\n  std::unique_ptr<Foundation> second_foundation{ new Foundation{} }; ➊\n  // Access founder member variable just like a pointer:\n  second_foundation->founder = \"Wanda\";\n} ➋\n```", "```\n#include <memory>\n\nstruct Foundation{\n  const char* founder;\n};\n\nstruct Mutant {\n  // Constructor sets foundation appropriately:\n  Mutant(std::unique_ptr<Foundation> foundation)\n    : foundation(std::move(foundation)) {}\n  std::unique_ptr<Foundation> foundation;\n};\n\nint main() {\n  std::unique_ptr<Foundation> second_foundation{ new Foundation{} }; ➊\n  // ... use second_foundation\n  Mutant the_mule{ std::move(second_foundation) }; ➋\n  // second_foundation is in a 'moved-from' state\n  // the_mule owns the Foundation\n}\n```"]