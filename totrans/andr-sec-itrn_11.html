<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;NFC and Secure Elements"><div class="titlepage"><div><div><h1 class="title"><a id="nfc_and_secure_elements"/>Chapter 11. NFC and Secure Elements</h1></div></div></div><p><a id="iddle2310" class="indexterm"/><a id="iddle2320" class="indexterm"/>This chapter gives a brief overview of near field communication (NFC) and secure elements (SEs), and explains how they’re integrated into mobile devices. While NFC has many uses, we focus on its card emulation mode, which is used to provide an interface to an SE integrated into a mobile device. Secure elements offer protected storage for private data, such as authentication keys, and provide a secure execution environment that can protect security-critical code. We’ll describe which types of SEs Android supports and introduce the APIs that Android applications can use to communicate with SEs. Finally, we’ll discuss host-based card emulation (HCE) and its Android implementations, and demonstrate how to implement an HCE application.</p><div class="sect1" title="NFC Overview"><div class="titlepage"><div><div><h1 class="title"><a id="nfc_overview"/>NFC Overview</h1></div></div></div><p><span class="emphasis"><em>NFC</em></span> is a technology that allows devices that are in close proximity (usually 10 centimeters or less) to establish radio communication with each other and exchange data. NFC is not a single standard, but is based on a set of <a id="iddle1323" class="indexterm"/><a id="iddle1330" class="indexterm"/><a id="iddle2311" class="indexterm"/><a id="iddle2314" class="indexterm"/><a id="iddle2321" class="indexterm"/><a id="iddle2438" class="indexterm"/><a id="iddle2554" class="indexterm"/><a id="iddle2562" class="indexterm"/><a id="iddle2616" class="indexterm"/><a id="iddle2645" class="indexterm"/>standards that define radio frequencies, communication protocols, and data exchange formats. NFC builds upon radio-frequency identification (RFID) technology and operates at the 13.56 MHz frequency, allowing various data transmission rates such as 106kbps, 212kbps, and 424kbps.</p><p>NFC communication involves two devices: an initiator and a target. In <span class="emphasis"><em>active mode</em></span>, both the initiator and the target have their own power supplies and each can transmit a radio signal in order to communicate with the other party. In <span class="emphasis"><em>passive mode</em></span>, the target device does not have its own power source and is activated and powered by the electromagnetic field emitted by the initiator.</p><p>When communicating in passive mode, the initiator is often called a <span class="emphasis"><em>reader</em></span>, and the target a <span class="emphasis"><em>tag</em></span>. The reader can be a dedicated device or be embedded in a general purpose device, such as a personal computer or a mobile phone. Tags come in various shapes and sizes and range from simple stickers with very limited amount of memory to contactless smart cards, which have an embedded CPU.</p><p>NFC devices can operate in three different modes: reader/writer (R/W), peer-to-peer (P2P), and card emulation (CE). In R/W mode, a device acts as an active initiator and can read and write data to external tags. In P2P mode, two NFC devices can actively exchange data using a bidirectional communication protocol. The CE mode allows an NFC device to emulate a tag or a contactless smart card. Android supports all three modes with some limitations. We give an overview of Android’s NFC architecture and show how to use each mode in the next section.</p></div><div class="sect1" title="Android NFC Support"><div class="titlepage"><div><div><h1 class="title"><a id="android_nfc_support"/>Android NFC Support</h1></div></div></div><p>NFC support in Android was introduced in version 2.3 and the related architecture and features remained largely unchanged until version 4.4, which introduced HCE support.</p><p>Android’s NFC implementation resides in the <code class="literal">NfcService</code> system service, part of the <code class="literal">Nfc</code> system application (package <code class="literal">com.android.nfc</code>). It wraps the native libraries required to drive each supported NFC controller; implements access control, tag discovery, and dispatch; and controls card emulation. Android doesn’t expose a low-level API to the functionality of <code class="literal">NfcService</code>, but instead offers an event-driven framework that allows interested applications to register for NFC events. This event-driven approach is used in all three NFC operating modes.</p><div class="sect2" title="Reader/Writer Mode"><div class="titlepage"><div><div><h2 class="title"><a id="readersoliduswriter_mode"/>Reader/Writer Mode</h2></div></div></div><p>NFC-enabled Android applications can’t directly set the device in R/W mode. Instead, they declare the type of tags they’re interested in, and Android’s tag dispatch system selects and starts the matching application when it discovers a tag.</p><p>The tag dispatch system both uses the tag technology (discussed shortly) and parses tag contents in order to decide which application to dispatch the tag to. The tag dispatch system uses three intent actions to notify applications <a id="iddle1061" class="indexterm"/><a id="iddle1067" class="indexterm"/><a id="iddle1068" class="indexterm"/><a id="iddle2267" class="indexterm"/><a id="iddle2303" class="indexterm"/><a id="iddle2565" class="indexterm"/>about the discovered tag: <code class="literal">ACTION_NDEF_DISCOVERED</code>, <code class="literal">ACTION_TECH_DISCOVERED</code>, and <code class="literal">ACTION_TAG_DISCOVERED</code>. The <code class="literal">ACTION_NDEF_DISCOVERED</code> intent has the highest priority and is sent when Android discovers a tag that is formatted using the standard NFC Data Exchange Format (NDEF)<sup>[<a id="ch11fn01" href="#ftn.ch11fn01" class="footnote">111</a>]</sup> and that contains a recognized data type. The <code class="literal">ACTION_TECH_DISCOVERED</code> intent is sent when the scanned tag does not contain NDEF data or the data format is not recognized by applications that can handle the discovered tag technology. If no applications can handle <code class="literal">ACTION_NDEF_DISCOVERED</code> or <code class="literal">ACTION_TECH_DISCOVERED</code>, the <code class="literal">NfcService</code> sends the generic <code class="literal">ACTION_TAG_DISCOVERED</code> intent. Tag dispatch events are delivered only to activities, and therefore cannot be processed in the background without user interaction.</p><div class="sect3" title="Registering for Tag Dispatch"><div class="titlepage"><div><div><h3 class="title"><a id="registering_for_tag_dispatch"/>Registering for Tag Dispatch</h3></div></div></div><p>Applications register for NFC events using the standard intent filter system by declaring the intents that an NFC-enabled activity supports in <span class="emphasis"><em>AndroidManifest.xml</em></span>, as shown in <a class="xref" href="ch11.html#manifest_file_of_an_nfc-enabled_applicat" title="Example 11-1. Manifest file of an NFC-enabled application">Example 11-1</a>.</p><div class="example"><a id="manifest_file_of_an_nfc-enabled_applicat"/><p class="title">Example 11-1. Manifest file of an NFC-enabled application</p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest 
    package="com.example.nfc" ...&gt;
    --<span class="emphasis"><em>snip</em></span>--

    &lt;uses-permission android:name="android.permission.NFC" /&gt;➊
    --<span class="emphasis"><em>snip</em></span>-
    &lt;application ...&gt;
        &lt;activity
            android:name=".NfcActivity"➋
            android:launchMode="singleTop" &gt;
            &lt;intent-filter&gt;
                &lt;action android:name="android.nfc.action.NDEF_DISCOVERED"/&gt;➌
                &lt;category android:name="android.intent.category.DEFAULT"/&gt;
                &lt;data android:mimeType="text/plain" /&gt;
            &lt;/intent-filter&gt;
            &lt;intent-filter&gt;
                &lt;action android:name="android.nfc.action.TECH_DISCOVERED" /&gt;➍
            &lt;/intent-filter&gt;
            &lt;intent-filter&gt;
                &lt;action android:name="android.nfc.action.TAG_DISCOVERED" /&gt;➎
            &lt;/intent-filter&gt;

            &lt;meta-data
                android:name="android.nfc.action.TECH_DISCOVERED"➏
                android:resource="@xml/filter_nfc" &gt;
            &lt;/meta-data&gt;
        &lt;/activity&gt;
        --<span class="emphasis"><em>snip</em></span>--
    &lt;/application&gt;
&lt;/manifest&gt;</pre></div></div><p><a id="iddle1717" class="indexterm"/><a id="iddle2266" class="indexterm"/><a id="iddle2298" class="indexterm"/><a id="iddle2299" class="indexterm"/><a id="iddle2566" class="indexterm"/><a id="iddle2911" class="indexterm"/><a id="iddle2914" class="indexterm"/><a id="iddle2915" class="indexterm"/>As you can see in this listing, the application first requests the <code class="literal">android.permission.NFC</code> permission ➊, which is required to access the NFC controller, and then declares an activity that handles NFC events, <code class="literal">NfcActivity</code> ➋. The activity registers three intent filters; one for each tag discovery event. The application declares that it can handle NDEF data with the <span class="emphasis"><em>text/plain</em></span> MIME type by specifying the <code class="literal">mimeType</code> attribute of the <code class="literal">&lt;data&gt;</code> tag in the <code class="literal">NDEF_DISCOVERED</code> intent filter ➌. <code class="literal">NfcActivity</code> also declares that it can handle the <code class="literal">TECH_DISCOVERED</code> intent ➍, which is sent if the scanned tag uses one of the technologies specified in the associated metadata XML resource file ➏. Finally, the application requests that it be notified about all discovered NFC tags by adding the catch-all <code class="literal">TAG_DISCOVERED</code> intent filter ➎.</p><p>If more than one activity that supports the scanned tag is found, Android shows a selection dialog, allowing the user to select which activity should handle the tag. Applications already in the foreground can short-circuit this selection by calling the <code class="literal">NfcAdapter.enableForegroundDispatch()</code> method. Such an application will be given priority over all other matching applications and will automatically receive the NFC intent when it’s in the foreground.</p></div><div class="sect3" title="Tag Technologies"><div class="titlepage"><div><div><h3 class="title"><a id="tag_technologies"/>Tag Technologies</h3></div></div></div><p>A <span class="emphasis"><em>tag technology</em></span> is an abstract term that describes a concrete NFC tag. The tag technology is determined by the communication protocol the tag uses, its internal structure, or the features it offers. For example, a tag that uses the NFC-A protocol (based on ISO 14443-3A)<sup>[<a id="ch11fn02" href="#ftn.ch11fn02" class="footnote">112</a>]</sup> for communication matches the <span class="emphasis"><em>NfcA</em></span> technology, and a tag that contains NDEF-formatted data matches the <span class="emphasis"><em>Ndef</em></span> technology, regardless of the underlying communication protocol. (See the <code class="literal">TagTechnology</code> class reference documentation<sup>[<a id="ch11fn03" href="#ftn.ch11fn03" class="footnote">113</a>]</sup> for a full list of tag technologies supported by Android.)</p><p>An activity that specifies the <code class="literal">TECH_DISCOVERED</code> intent filter must provide an XML resource file that in turn specifies the concrete technologies it supports with a <code class="literal">&lt;tech-list&gt;</code> element. An activity is considered a match for a tag if one of the tech lists it declares is a subset of the technologies supported by the tag. Multiple tech lists can be declared in order to match different tags, as shown in <a class="xref" href="ch11.html#declaring_technologies_to_match_using_te" title="Example 11-2. Declaring technologies to match using tech lists">Example 11-2</a>.</p><div class="example"><a id="declaring_technologies_to_match_using_te"/><p class="title">Example 11-2. Declaring technologies to match using tech lists</p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;
    &lt;tech-list&gt;➊
        &lt;tech&gt;android.nfc.tech.IsoDep&lt;/tech&gt;
        &lt;tech&gt;android.nfc.tech.NfcA&lt;/tech&gt;
    &lt;/tech-list&gt;

    &lt;tech-list&gt;➋
        &lt;tech&gt;android.nfc.tech.NfcF&lt;/tech&gt;
    &lt;/tech-list&gt;
&lt;/resources&gt;</pre></div></div><p><a id="iddle1875" class="indexterm"/><a id="iddle2563" class="indexterm"/><a id="iddle2564" class="indexterm"/>Here, the first tech list ➊ will match tags that provide a communication interface compatible with ISO 14443-4 (ISO-DEP), and which are implemented using the NFC-A technology (usually used by NXP contactless smart cards); the second tech list ➋ matches tags that use the NFC-F technology (typically Felica cards). Because both tech lists are defined independently, our example <code class="literal">NfcActivity</code> (see <a class="xref" href="ch11.html#manifest_file_of_an_nfc-enabled_applicat" title="Example 11-1. Manifest file of an NFC-enabled application">Example 11-1</a>) will be notified when either a contactless NXP smart card or a Felica card or tag is scanned.</p></div><div class="sect3" title="Reading a Tag"><div class="titlepage"><div><div><h3 class="title"><a id="reading_a_tag"/>Reading a Tag</h3></div></div></div><p>After the tag dispatch system selects an activity to handle the scanned tag, it creates an NFC intent object and passes it to the selected activity. The activity can then use the <code class="literal">EXTRA_TAG</code> extra to obtain a <code class="literal">Tag</code> object representing the scanned tag and call its methods in order to read or write to the tag. (Tags that contain NDEF data also provide the <code class="literal">EXTRA_NDEF_MESSAGES</code> extra, which contains an array of NDEF messages parsed from the tag.)</p><p>A concrete <code class="literal">Tag</code> object representing the underlying tag technology can be obtained using the static <code class="literal">get()</code> method of the corresponding technology class, as shown in <a class="xref" href="ch11.html#obtaining_a_concrete_tag_instance_from_t" title="Example 11-3. Obtaining a concrete Tag instance from the NFC intent">Example 11-3</a>. If the <code class="literal">Tag</code> object does not support the requested technology, the <code class="literal">get()</code> method returns <code class="literal">null.</code></p><div class="example"><a id="obtaining_a_concrete_tag_instance_from_t"/><p class="title">Example 11-3. Obtaining a concrete <code class="literal">Tag</code> instance from the NFC intent</p><div class="example-contents"><pre class="programlisting">protected void onNewIntent(Intent intent) {
    setIntent(intent);

    Tag tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);
    IsoDep isoDep = IsoDep.get(tag);
    if (isoDep != null) {
         isoDep.connect();
         byte[] command = {...};
         byte[] response = isoDep.transceive(command);
         --<span class="emphasis"><em>snip</em></span>--
    }
}</pre></div></div></div><div class="sect3" title="Using Reader Mode"><div class="titlepage"><div><div><h3 class="title"><a id="using_reader_mode"/>Using Reader Mode</h3></div></div></div><p>In addition to the intent-based tag dispatch system, Android 4.4 adds a new method that activities can use to obtain a live <code class="literal">Tag</code> object, called reader mode. Reader mode guarantees that while the target activity is in the foreground, all other operation modes supported by the NFC controller <a id="iddle1619" class="indexterm"/><a id="iddle1718" class="indexterm"/><a id="iddle2300" class="indexterm"/><a id="iddle2313" class="indexterm"/><a id="iddle2345" class="indexterm"/><a id="iddle2439" class="indexterm"/><a id="iddle2841" class="indexterm"/><a id="iddle2848" class="indexterm"/>(such as peer-to-peer and card emulation) are disabled. This mode is helpful when scanning an active NFC device, such as another Android device in host-based emulation mode, which could trigger point-to-point communication and thus take control away from the current foreground activity.</p><p>Activities can enable reader mode by calling the <code class="literal">enableReaderMode()</code> method of the <code class="literal">NfcAdapter</code> class,<sup>[<a id="ch11fn04" href="#ftn.ch11fn04" class="footnote">114</a>]</sup> as shown in <a class="xref" href="ch11.html#enabling_reader_mode_and_obtaining_a_tag" title="Example 11-4. Enabling reader mode and obtaining a Tag object using ReaderCallback">Example 11-4</a>.</p><div class="example"><a id="enabling_reader_mode_and_obtaining_a_tag"/><p class="title">Example 11-4. Enabling reader mode and obtaining a <code class="literal">Tag</code> object using <code class="literal">ReaderCallback</code></p><div class="example-contents"><pre class="programlisting">public class NfcActivity extends Activity implements NfcAdapter.ReaderCallback {
    private NfcAdapter adapter;
    --<span class="emphasis"><em>snip</em></span>--
    @Override
    public void onResume() {
       super.onResume();
       if (adapter != null) {
           adapter.enableReaderMode(this, this, NfcAdapter.FLAG_READER_NFC_A➊
                   | NfcAdapter.FLAG_READER_SKIP_NDEF_CHECK, null);
       }
    }

    @Override
    public void onTagDiscovered(Tag tag) {➋
        IsoDep isoDep = IsoDep.get(tag);
        if (isoDep != null) {
             isoDep.connect();
             byte[] command = {...};
             byte[] response = isoDep.transceive(command);
             --<span class="emphasis"><em>snip</em></span>--
        }
    }
    --<span class="emphasis"><em>snip</em></span>--
}</pre></div></div><p>In this case, the activity enables reader mode when it comes to the foreground by calling the <code class="literal">enableReaderMode()</code> method ➊ (the activity should disable reader mode using the matching <code class="literal">disableReaderMode()</code> method when it leaves the foreground), and obtains a <code class="literal">Tag</code> instance directly (without an intermediate intent) via the <code class="literal">onTagDiscovered()</code> callback ➋. The <code class="literal">Tag</code> object is then used in the same way as in intent-based dispatch.</p></div></div><div class="sect2" title="Peer-to-Peer Mode"><div class="titlepage"><div><div><h2 class="title"><a id="peer-to-peer_mode"/>Peer-to-Peer Mode</h2></div></div></div><p>Android implements a limited NFC P2P mode data exchange between devices using the proprietary NDEF push and the standard Simple NDEF Exchange Protocol (SNEP) protocols.<sup>[<a id="ch11fn05" href="#ftn.ch11fn05" class="footnote">115</a>]</sup> Android devices can exchange a <a id="iddle1134" class="indexterm"/><a id="iddle1324" class="indexterm"/><a id="iddle1331" class="indexterm"/><a id="iddle2301" class="indexterm"/><a id="iddle2312" class="indexterm"/><a id="iddle2681" class="indexterm"/><a id="iddle2785" class="indexterm"/><a id="iddle2786" class="indexterm"/>single NDEF message with any device that supports either of these protocols, but the P2P mode is typically used with another Android device in order to implement the so-called Android Beam feature.</p><p>In addition to NDEF messages, Android Beam allows for the transfer of larger data objects, such as photos and videos, which cannot fit in a single NDEF message by creating a temporary Bluetooth connection between devices. This process is called <span class="emphasis"><em>NFC handover</em></span> and was added in Android 4.1.</p><p>NDEF message exchange in P2P mode is enabled by calling the <code class="literal">setNdefPushMessage()</code> or <code class="literal">setNdefPushMessageCallback()</code> methods of the <code class="literal">NfcAdapter</code> class. (See the official NFC API guide<sup>[<a id="ch11fn06" href="#ftn.ch11fn06" class="footnote">116</a>]</sup> for more details and sample code.)</p></div><div class="sect2" title="Card Emulation Mode"><div class="titlepage"><div><div><h2 class="title"><a id="card_emulation_mode"/>Card Emulation Mode</h2></div></div></div><p>As mentioned in “<a class="xref" href="ch11.html#nfc_overview" title="NFC Overview">NFC Overview</a>”, CE mode allows an Android device to emulate a contactless smart card or an NFC tag. In CE mode, the device receives commands over NFC, processes them, and sends replies, again over NFC. The component responsible for processing commands can be either a hardware secure element (as discussed in the next section) connected to the device’s NFC controller, or an Android application running on the device (when in host-based card emulation, HCE).</p><p>In the following sections, we’ll discuss secure elements in mobile devices, and the Android APIs that applications can use to communicate with SEs. We’ll also describe how Android implements HCE and demonstrate how to create an application that enables card emulation.</p></div></div><div class="sect1" title="Secure Elements"><div class="titlepage"><div><div><h1 class="title"><a id="secure_elements"/>Secure Elements</h1></div></div></div><p>A <span class="emphasis"><em>secure element (SE)</em></span> is a tamper-resistant smart card chip capable of running smart card applications (called <span class="emphasis"><em>applets</em></span> or <span class="emphasis"><em>cardlets</em></span>) with a certain level of security and isolation. A smart card is essentially a minimal computing environment on a single chip, complete with a CPU, ROM, EEPROM, RAM, and I/O port. Recent cards also include cryptographic co-processors that implement common algorithms such as AES and RSA.</p><p>Smart cards use various techniques to implement tamper resistance, making it quite hard to extract data by disassembling or analyzing the chip. Modern smart cards come pre-programmed with a multi-application OS that takes advantage of the hardware’s memory protection features to ensure that each application’s data is only available to itself. Application installation and (optionally) access is controlled by requiring the use of cryptographic keys for each operation.</p><p><a id="iddle2342" class="indexterm"/><a id="iddle2374" class="indexterm"/><a id="iddle2956" class="indexterm"/>The SE can be integrated in mobile devices as a Universal Integrated Circuit Card (UICC, commonly known as a <span class="emphasis"><em>SIM card</em></span>) embedded in the handset or connected to a SD card slot. If the device supports NFC, the SE is usually connected to (or embedded into) the NFC controller, making it possible to communicate with the SE wirelessly.</p><p>Smart cards have been around since the 1970s and are now used in applications ranging from pre-paid phone calls and transit ticketing to credit cards and VPN credential storage. Because an SE installed in a mobile device has equivalent or superior capabilities to that of a smart card, it can theoretically be used for any application that physical smart cards are currently used for. Additionally, because an SE can host multiple applications, it has the potential to replace the bunch of cards people use daily with a single device. Furthermore, because the SE can be controlled by the device’s OS, access to it can be restricted by requiring additional authentication (PIN, passphrase, or code signature) to enable it.</p><p>One of the main applications of SEs in mobile devices is that of emulating contactless payment cards, and the goal of enabling mobile payments has indeed been the driving force behind SE deployment. Aside from financial applications, mobile SEs could be used to emulate other contactless cards that are in wide use, such as access cards, loyalty cards, and so on.</p><p>Mobile SEs could also be used to enhance the security of apps that deal with sensitive information or algorithms: The security-critical part of the app, such as credential storage or license verification, can be implemented inside the SE in order to guarantee that it’s impervious to reverse engineering and information extraction. Other apps that can benefit from being implemented in the SE are One Time Password (OTP) generators and, of course, credential storage (for shared secret keys, or private keys in a PKI).</p><p>While it’s possible to implement SE-enabled apps today with standard tools and technologies, using them in practice on current commercial Android devices isn’t straightforward. We’ll discuss this in detail in “<a class="xref" href="ch11.html#android_se_execution_environment" title="Android SE Execution Environment">Android SE Execution Environment</a>”, but let’s first explore the types of SEs available on mobile devices, and the level of support they have in Android.</p><div class="sect2" title="SE Form Factors in Mobile Devices"><div class="titlepage"><div><div><h2 class="title"><a id="se_form_factors_in_mobile_devices"/>SE Form Factors in Mobile Devices</h2></div></div></div><p><a class="xref" href="ch11.html#android_nfc_and_se_components" title="Figure 11-1. Android NFC and SE components">Figure 11-1</a> shows a simplified block diagram of the components of an Android device as they relate to NFC and SE support, including the embedded SE (eSE) and the UICC. We’ll refer to the components in this diagram in our discussion of secure elements and host-based card emulation in the rest of this chapter.</p><p>In the following subsections, we briefly review the types of SEs available on Android devices, how they’re connected to other device components, and the methods the OS uses to communicate with each type of SE.</p><div class="figure"><a id="android_nfc_and_se_components"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00068"/><img src="figs/web/11fig01.png.jpg" alt="Android NFC and SE components"/></div></div><p class="title">Figure 11-1. Android NFC and SE components</p></div><div class="sect3" title="UICC"><div class="titlepage"><div><div><h3 class="title"><a id="uicc"/>UICC</h3></div></div></div><p><a id="iddle1237" class="indexterm"/><a id="iddle2689" class="indexterm"/><a id="iddle2720" class="indexterm"/><a id="iddle2836" class="indexterm"/><a id="iddle2845" class="indexterm"/><a id="iddle2957" class="indexterm"/>Most mobile devices today have some kind of UICC. Although UICCs are smart cards that can host applications, because the UICC has traditionally only been connected to the baseband processor (not the application processor that runs the main device OS), they can’t be accessed directly from Android. All communication goes through the Radio Interface Layer (RIL), which is essentially a proprietary IPC interface to the baseband.</p><p>Communication with the UICC SE is carried out using extended AT commands (<code class="literal">AT+CCHO</code>, <code class="literal">AT+CCHC</code>, <code class="literal">AT+CGLA</code> as defined by 3GPP TS 27.007),<sup>[<a id="ch11fn07" href="#ftn.ch11fn07" class="footnote">117</a>]</sup> which the current Android telephony manager does not support. The SEEK for Android project<sup>[<a id="ch11fn08" href="#ftn.ch11fn08" class="footnote">118</a>]</sup> provides patches to implement the needed commands, allowing for communication with the UICC via the SmartCard API, which is a reference implementation of the SIMalliance Open Mobile API specification<sup>[<a id="ch11fn09" href="#ftn.ch11fn09" class="footnote">119</a>]</sup> (discussed in “<a class="xref" href="ch11.html#using_the_openmobile_api" title="Using the OpenMobile API">Using the OpenMobile API</a>”). However, as with most components that talk directly to the hardware in Android, <a id="iddle1109" class="indexterm"/><a id="iddle1232" class="indexterm"/><a id="iddle1708" class="indexterm"/><a id="iddle1759" class="indexterm"/><a id="iddle2208" class="indexterm"/><a id="iddle2682" class="indexterm"/><a id="iddle2688" class="indexterm"/><a id="iddle2843" class="indexterm"/><a id="iddle2886" class="indexterm"/>the RIL consists of an open source part (<span class="emphasis"><em>rild</em></span>), and a proprietary library (<span class="emphasis"><em>libXXX-ril.so</em></span>). In order to support communication with the UICC secure element, support must be added both to the <span class="emphasis"><em>rild</em></span> and to the underlying proprietary library. The choice of whether to add that support is left to hardware vendors.</p><p>As of this writing, the SmartCard API has not been integrated into mainline Android (although the AOSP source tree includes an empty <span class="emphasis"><em>packages/ apps/SmartCardService/</em></span> directory). However, Android devices from major vendors ship with an implementation of the SmartCard API, which allows communication from the UICC to third-party applications (subject to various access restrictions).</p><p>The Single Wire Protocol (SWP) offers an alternative way to use the UICC as an SE. SWP is used to connect the UICC to a NFC controller, allowing the NFC controller to expose the UICC to external readers when in card emulation mode. The NFC controllers built into recent Nexus devices (such as the Broadcom BCM20793M in the Nexus 5) support SWP, but this functionality is disabled by default. (It can be enabled by changing the configuration file of the <span class="emphasis"><em>libnfc-brcm</em></span> library on the Nexus 5.) A standard API to switch between the UICC, the embedded SE (if available), and HCE when in card emulation mode is currently not exposed, but the “off-host” routing functionality available in Android 4.4 can theoretically route commands to the UICC (see “<a class="xref" href="ch11.html#apdu_routing" title="APDU Routing">APDU Routing</a>” for details).</p></div><div class="sect3" title="microSD-Based SE"><div class="titlepage"><div><div><h3 class="title"><a id="microsd-based_se"/>microSD-Based SE</h3></div></div></div><p>Another form factor for an SE is an <span class="emphasis"><em>Advanced Security SD card (ASSD)</em></span>,<sup>[<a id="ch11fn10" href="#ftn.ch11fn10" class="footnote">120</a>]</sup> which is basically an SD card with an embedded SE chip. When connected to an Android device with an SD card slot, running a SEEK-patched Android version, the SE can be accessed via the SmartCard API. However, Android devices with an SD card slot are becoming the exceptions rather than the norm, so it’s unlikely that ASSD Android support will make it to the mainstream. Additionally, even when available, recent Android versions treat SD cards as secondary storage devices and allow access to them only via a very high-level, restrictive API.</p></div><div class="sect3" title="Embedded SE"><div class="titlepage"><div><div><h3 class="title"><a id="embedded_se"/>Embedded SE</h3></div></div></div><p>An <span class="emphasis"><em>embedded SE (eSE)</em></span> is not a distinct device but is usually integrated with the NFC controller and housed in the same enclosure. An example of an eSE is NXP’s PN65N chip, which combines the PN544 NFC radio controller with the P5CN072 SE (part of the SmartMX series).</p><p>The first mainstream Android device to feature an embedded SE was the Nexus S, which also introduced NFC support to Android and was built using the PN65N controller. Its successors, the Galaxy Nexus and the Nexus 4, also <a id="iddle1710" class="indexterm"/><a id="iddle1908" class="indexterm"/><a id="iddle2304" class="indexterm"/><a id="iddle2305" class="indexterm"/><a id="iddle2322" class="indexterm"/><a id="iddle2646" class="indexterm"/><a id="iddle2684" class="indexterm"/><a id="iddle2820" class="indexterm"/><a id="iddle3142" class="indexterm"/>came equipped with an eSE. However, recent Google-branded devices, such as the Nexus 5 and Nexus 7 (2013), have deprecated the eSE in favor of host-based card emulation and do not include an eSE.</p><p>The embedded SE is connected to the NFC controller through a SignalIn/SignalOut connection (S2C), standardized as NFC Wired Interface (NFC-WI),<sup>[<a id="ch11fn11" href="#ftn.ch11fn11" class="footnote">121</a>]</sup> and has three modes of operation: off, wired, and virtual. In off mode, there’s no communication with the SE. In wired mode, the SE is visible to the Android OS as if it were a contactless smart card connected to the NFC reader. In virtual mode, the SE is visible to external readers as if the phone were a contactless smart card. These modes are mutually exclusive, so we can communicate with the SE either via the contactless interface (that is, from an external reader), or through the wired interface (that is, from an Android app). The next section shows how to use the wired mode to communicate with the eSE from an Android app.</p></div></div><div class="sect2" title="Accessing the Embedded SE"><div class="titlepage"><div><div><h2 class="title"><a id="accessing_the_embedded_se"/>Accessing the Embedded SE</h2></div></div></div><p>As of this writing, no public Android SDK API allows communication with the embedded SE, but recent Android versions include an optional library called <span class="emphasis"><em>nfc_extras</em></span>, which offers a stable interface to the eSE. This section demonstrates how to configure Android to allow eSE access to certain Android applications, as well as how to use the <span class="emphasis"><em>nfc_extras</em></span> library.</p><p>Card emulation, and consequently, internal APIs for accessing the embedded SE were introduced in Android 2.3.4 (the version that introduced Google Wallet). Those APIs are hidden from SDK applications and using them required system signature permissions (<code class="literal">WRITE_SECURE_SETTINGS</code> or <code class="literal">NFCEE_ADMIN</code>) in Android 2.3.4 and subsequent 2.3.x releases, as well as in the initial Android 4.0 release (API Level 14). A signature permission is quite restrictive because it allows only parties that control the platform signature keys to distribute apps that can use the eSE.</p><p>Android 4.0.4 (API Level 15) lifted this restriction by replacing the signature permission with signing certificate whitelisting at the OS level. While this still requires modifying core OS files, and thus vendor cooperation, there is no need to sign SE applications with the vendor key, which greatly simplifies distribution. Additionally, since the whitelist is maintained in a file, it can easily be updated using an OTA to add support for more SE applications.</p><div class="sect3" title="Granting Access to the eSE"><div class="titlepage"><div><div><h3 class="title"><a id="granting_access_to_the_ese"/>Granting Access to the eSE</h3></div></div></div><p>The new whitelisting access control approach is implemented by the <code class="literal">NfceeAccessControl</code> class and enforced by the system <code class="literal">NfcService</code>. The <code class="literal">NfceeAccessControl</code> class reads the whitelist from <span class="emphasis"><em>/etc/nfcee_access.xml</em></span>, which is an XML file that stores a list of signing certificates and package names that are allowed to access the eSE. Access can be granted both to all apps <a id="iddle1711" class="indexterm"/><a id="iddle2306" class="indexterm"/><a id="iddle2685" class="indexterm"/>signed by a particular certificate’s private key (if no package name is specified), or to a single package (app) only. <a class="xref" href="ch11.html#contents_of_the_nfceeunderscoreaccessdot" title="Example 11-5. Contents of the nfcee_access.xml file">Example 11-5</a> shows how the contents of the <span class="emphasis"><em>nfcee_access.xml</em></span> file might appear:</p><div class="example"><a id="contents_of_the_nfceeunderscoreaccessdot"/><p class="title">Example 11-5. Contents of the <span class="roman">nfcee_access.xml</span> file</p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources &gt;
    &lt;signer android:signature="308204a830820390a003020102020900b399..."&gt;➊
        &lt;package android:name="com.example.nfc"&gt;➋
        &lt;/package&gt;
    &lt;/signer&gt;
&lt;/resources&gt;</pre></div></div><p>This configuration allows SE access to the <code class="literal">com.example.nfc</code> package ➋ if it is signed by the specified signing certificate ➊. On production devices, this file usually contains only the Google Wallet app signing certificate, thus restricting eSE access to Google Wallet.</p><div class="note" title="Note"><h3 class="title"><a id="ch11note01"/>Note</h3><p><span class="emphasis"><em>As of April 2014, Google Wallet is supported only on Android 4.4 and later, and uses HCE rather than the eSE.</em></span></p></div><p>After an application’s signing certificate has been added to <span class="emphasis"><em>nfcee_access.xml</em></span>, no permissions other than the standard NFC permission are required to access the eSE. In addition to whitelisting the app’s signing certificate, the <span class="emphasis"><em>nfc_extras</em></span> library must be explicitly added to the app’s manifest and marked as required with the <code class="literal">&lt;uses-library&gt;</code> tag in order to enable eSE access (because the library is optional, it’s not loaded by default), as shown in <a class="xref" href="ch11.html#adding_the_nfcunderscoreextras_library_t" title="Example 11-6. Adding the nfc_extras library to AndroidManifest.xml">Example 11-6</a> at ➊.</p><div class="example"><a id="adding_the_nfcunderscoreextras_library_t"/><p class="title">Example 11-6. Adding the <span class="roman">nfc_extras</span> library to <span class="roman">AndroidManifest.xml</span></p><div class="example-contents"><pre class="programlisting">&lt;manifest 
    package="com.example.nfc" ...&gt;
    --<span class="emphasis"><em>snip</em></span>--
    &lt;uses-permission android:name="android.permission.NFC" /&gt;
    &lt;application ...&gt;
        --<span class="emphasis"><em>snip</em></span>--
        &lt;uses-library
            android:name="com.android.nfc_extras"➊
            android:required="true" /&gt;
    &lt;/application&gt;
&lt;/manifest&gt;</pre></div></div></div><div class="sect3" title="Using the NfcExecutionEnvironment API"><div class="titlepage"><div><div><h3 class="title"><a id="using_the_nfcexecutionenvironment_api"/>Using the NfcExecutionEnvironment API</h3></div></div></div><p>Android’s eSE access API isn’t based on a standard smart card communication API, such as JSR 177<sup>[<a id="ch11fn12" href="#ftn.ch11fn12" class="footnote">122</a>]</sup> or the Open Mobile API, but instead offers a very <a id="iddle1709" class="indexterm"/><a id="iddle1863" class="indexterm"/><a id="iddle2302" class="indexterm"/><a id="iddle2307" class="indexterm"/><a id="iddle2683" class="indexterm"/>basic communication interface, implemented in the <code class="literal">NfcExecutionEnvironment</code> class. The class has only three public methods, as shown in <a class="xref" href="ch11.html#nfcexecutionenvironment_api" title="Example 11-7. NfcExecutionEnvironment API">Example 11-7</a>.</p><div class="example"><a id="nfcexecutionenvironment_api"/><p class="title">Example 11-7. <code class="literal">NfcExecutionEnvironment</code> API</p><div class="example-contents"><pre class="programlisting">public class NfcExecutionEnvironment {
    public void open() throws EeIOException {...}

    public void close() throws IOException {...}

    public byte[] transceive(byte[] in) throws IOException {...}
}</pre></div></div><p>This simple interface is sufficient to communicate with the SE, but in order to use it you first need to obtain an instance of the <code class="literal">NfcExecutionEnvironment</code> class. An instance can be obtained from the <code class="literal">NfcAdapterExtras</code> class, which is in turn accessed via its static <code class="literal">get()</code> method, as shown in <a class="xref" href="ch11.html#using_the_nfcexecutionenvironmen-id00025" title="Example 11-8. Using the NfcExecutionEnvironment API">Example 11-8</a>.</p><div class="example"><a id="using_the_nfcexecutionenvironmen-id00025"/><p class="title">Example 11-8. Using the <code class="literal">NfcExecutionEnvironment</code> API</p><div class="example-contents"><pre class="programlisting">NfcAdapterExtras adapterExtras =
     NfcAdapterExtras.get(NfcAdapter.getDefaultAdapter(context));➊
NfcExecutionEnvironment nfceEe =
     adapterExtras.getEmbeddedExecutionEnvironment();➋
nfcEe.open();➌
byte[] emptySelectCmd = { 0x00, (byte) 0xa4, 0x04, 0x00, 0x00 };
byte[] response = nfcEe.transceive(emptySelectCmd);➍
nfcEe.close();➎</pre></div></div><p>Here, we first obtain an <code class="literal">NfcAdapterExtras</code> instance ➊, and then call its <code class="literal">getEmbeddedExecutionEnvironment()</code> method in order to obtain an interface to the eSE ➋. To be able to communicate with the eSE, we first open a connection ➌, and then use the <code class="literal">transceive()</code> method to send a command and get a response ➍. Finally, we close the connection using the <code class="literal">close()</code> method ➎.</p></div><div class="sect3" title="eSE-Related Broadcasts"><div class="titlepage"><div><div><h3 class="title"><a id="ese-related_broadcasts"/>eSE-Related Broadcasts</h3></div></div></div><p>An SE-enabled app needs to be notified of NFC events such as RF field detection, as well as of events pertaining to the eSE and the applets installed on it, such as applet selection via the NFC interface, in order to be able to change state accordingly. Because disclosure of such events to malicious applications can lead to leaking of sensitive information and denial of service attacks, access to eSE-related events must be limited to trusted applications only.</p><p>In Android, global events are implemented by using broadcasts, and applications can create and register broadcast receivers that receive the broadcasts the app is interested in. Access to eSE-related broadcasts can be controlled with standard Android signature-based permissions, but this approach has the disadvantage that only apps signed with the platform certificate can receive eSE events, thus limiting SE-enabled apps to those created by the device manufacturer or mobile network operator (MNO). To avoid this limitation, Android uses the same mechanism employed to <a id="iddle1158" class="indexterm"/><a id="iddle1159" class="indexterm"/><a id="iddle1176" class="indexterm"/><a id="iddle1909" class="indexterm"/><a id="iddle1979" class="indexterm"/><a id="iddle2005" class="indexterm"/><a id="iddle2053" class="indexterm"/><a id="iddle2195" class="indexterm"/><a id="iddle2686" class="indexterm"/>control eSE access; namely, whitelisting application certificates, in order to control the scope of applications that can receive eSE-related broadcasts. Any application whose signing certificate (and optionally package name) is registered in <span class="emphasis"><em>nfcee_access.xml</em></span> can receive eSE-related broadcasts by registering a receiver like the one shown in <a class="xref" href="ch11.html#declaring_a_broadcast_receiver_for_ese-r" title="Example 11-9. Declaring a broadcast receiver for eSE-related events in AndroidManifest.xml">Example 11-9</a>.</p><div class="example"><a id="declaring_a_broadcast_receiver_for_ese-r"/><p class="title">Example 11-9. Declaring a broadcast receiver for eSE-related events in <span class="roman">AndroidManifest.xml</span></p><div class="example-contents"><pre class="programlisting">&lt;receiver android:name="com.example.nfc.SEReceiver" &gt;
  &lt;intent-filter&gt;
   &lt;action android:name="com.android.nfc_extras.action.RF_FIELD_ON_DETECTED" /&gt;➊
   &lt;action android:name="com.android.nfc_extras.action.RF_FIELD_OFF_DETECTED" /&gt;➋
   &lt;action android:name="com.android.nfc_extras.action.APDU_RECEIVED" /&gt;➌
   &lt;action android:name="com.android.nfc_extras.action.AID_SELECTED" /&gt;➍
   &lt;action android:name="com.android.nfc_extras.action.MIFARE_ACCESS_DETECTED" /&gt;➎
   &lt;action android:name="com.android.nfc_extras.action.EMV_CARD_REMOVAL" /&gt;➏
   &lt;action android:name="com.android.nfc.action.INTERNAL_TARGET_DESELECTED" /&gt;➐
   &lt;action android:name="android.intent.action.MASTER_CLEAR_NOTIFICATION" /&gt;➑
  &lt;/intent-filter&gt;
&lt;/receiver&gt;</pre></div></div><p>As you can see, Android offers notifications for lower-level communication events, such as RF field detection ➊➋, APDU reception ➌, and applet selection ➍, as well as for higher-level events, such as MIFARE sector access ➎ and EMV card removal ➏. (APDUs are <span class="emphasis"><em>Application Protocol Data Units</em></span>, the basic building block of smart card protocols; see “<a class="xref" href="ch11.html#se_communication_protocols" title="SE Communication Protocols">SE Communication Protocols</a>”. The <code class="literal">APDU_RECIEVED</code> broadcast is not implemented, because in practice the NFC controller routes incoming APDUs directly to the eSE, which makes them invisible to the OS.) SE-enabled apps register for these broadcasts in order to be able to change their internal state or start a related activity when each event occurs (for example, to start a PIN entry activity when an EMV applet is selected). The <code class="literal">INTERNAL_TARGET_DESELECTED</code> broadcast ➐ is sent when card emulation is deactivated, and the <code class="literal">MASTER_CLEAR_NOTIFICATION</code> broadcast ➑ is sent when the contents of the eSE are cleared. (Pre-HCE versions of Google Wallet offered users the option to clear the eSE remotely if their device was lost or stolen.)</p></div></div><div class="sect2" title="Android SE Execution Environment"><div class="titlepage"><div><div><h2 class="title"><a id="android_se_execution_environment"/>Android SE Execution Environment</h2></div></div></div><p>The Android SE is essentially a smart card in a different package, so most standards and protocols originally developed for smart cards apply. Let’s briefly review the most important ones.</p><p>Smart cards have traditionally been filesystem-oriented and the main role of their OS has been to handle file access and enforce access permissions. Newer cards support a virtual machine running on top of the native OS that allows for the execution of “platform independent” applications called applets, which use a well-defined runtime library to implement their functionality. While different implementations of this paradigm exist, by far the most popular one is the Java Card runtime environment (JCRE). Applets are implemented in a restricted version of the Java language and <a id="iddle1890" class="indexterm"/><a id="iddle1996" class="indexterm"/><a id="iddle2308" class="indexterm"/><a id="iddle2926" class="indexterm"/>use a limited runtime library, which offers basic classes for I/O, message parsing, and cryptographic operations. While the JCRE specification<sup>[<a id="ch11fn13" href="#ftn.ch11fn13" class="footnote">123</a>]</sup> fully defines the applet runtime environment, it does not specify how to load, initialize, and delete applets on actual physical cards (tools are only provided for the JCRE emulator).</p><p>Because one of the main applications of smart cards are various payment services, the application loading and initialization process (often referred to as <span class="emphasis"><em>card personalization</em></span>) needs to be controlled, and only authorized entities should be able to alter the state of the card and installed applications. Visa originally developed a specification for securely managing applets, called Open Platform, which is now maintained and developed by the GlobalPlatform (GP) organization under the name GlobalPlatform Card Specification.<sup>[<a id="ch11fn14" href="#ftn.ch11fn14" class="footnote">124</a>]</sup> The gist of this specification is that each GP-compliant card has a mandatory <span class="emphasis"><em>Issuer Security Domain (ISD)</em></span> component (informally referred to as the <span class="emphasis"><em>Card Manager</em></span>) that offers a well-defined interface for card and application life cycle management. Executing ISD operations requires authentication using cryptographic keys saved on the card, and thus only an entity that knows those keys can change the state of the card (one of <code class="literal">OP_READY</code>, <code class="literal">INITIALIZED</code>, <code class="literal">SECURED</code>, <code class="literal">CARD_LOCKED</code>, or <code class="literal">TERMINATED</code>) or manage applets. Additionally, the GP card specification defines various secure communication protocols (called Secure Channels) that offer authentication, confidentiality, and message integrity when communicating with the card.</p><div class="sect3" title="SE Communication Protocols"><div class="titlepage"><div><div><h3 class="title"><a id="se_communication_protocols"/>SE Communication Protocols</h3></div></div></div><p>As discussed in “<a class="xref" href="ch11.html#using_the_nfcexecutionenvironment_api" title="Using the NfcExecutionEnvironment API">Using the NfcExecutionEnvironment API</a>”, Android’s interface for communicating with the SE is the <code class="literal">byte[] transceive(byte[] command)</code> method of the <code class="literal">NfcExecutionEnvironment</code> class. The messages exchanged using this API are in practice APDUs, and their structure is defined in the <span class="emphasis"><em>ISO/IEC 7816-4: Organization, security and commands for interchange</em></span> standard.<sup>[<a id="ch11fn15" href="#ftn.ch11fn15" class="footnote">125</a>]</sup> The reader (also known as a <span class="emphasis"><em>Card Acceptance Device</em></span>, or <span class="emphasis"><em>CAD</em></span>) sends command APDUs (sometimes referred to as <span class="emphasis"><em>C-APDUs</em></span>) to the card, composed of a mandatory four-byte header with a command class (<span class="emphasis"><em>CLA</em></span>), instruction (<span class="emphasis"><em>INS</em></span>), and two parameters (<span class="emphasis"><em>P1</em></span> and <span class="emphasis"><em>P2</em></span>). This is followed by the optional command data length (<span class="emphasis"><em>Lc</em></span>), the actual data, and finally the maximum number of response bytes expected, if any (<span class="emphasis"><em>Le</em></span>). The card returns a response APDU (<span class="emphasis"><em>R-APDU</em></span>) with a mandatory status word (<span class="emphasis"><em>SW</em></span>, consisting of two bytes: <span class="emphasis"><em>SW1</em></span> and <span class="emphasis"><em>SW2</em></span>) and optional response data.</p><p>Historically, command APDU data has been limited to 255 bytes (total APDU length 261 bytes) and response APDU data to 256 bytes (total APDU length 258 bytes). Recent cards and readers support extended APDUs with data length up to 65536 bytes, but extended APDUs are not always usable, <a id="iddle1120" class="indexterm"/><a id="iddle1173" class="indexterm"/><a id="iddle1891" class="indexterm"/><a id="iddle2687" class="indexterm"/>mostly for reasons of compatibility. The lower-level communication between the reader and the card is carried out by one of several transmission protocols, the most widely used of which are T=0 (byte-oriented) and T=1 (block-oriented). Both are defined in <span class="emphasis"><em>ISO 7816-3: Cards with contacts — Electrical interface and transmission protocols</em></span>. The APDU exchange is not completely protocol-agnostic, because T=0 cannot directly send response data, but only notify the reader of the number of available bytes. Additional command APDUs (<code class="literal">GET RESPONSE</code>) need to be sent in order to retrieve the response data.</p><p>The original ISO 7816 standards were developed for contact cards, but the same APDU-based communication model is used for contactless cards as well. It’s layered on top of the wireless transmission protocol defined by ISO/IEC 14443-4, which behaves much like T=1 for contact cards.</p></div><div class="sect3" title="Querying the eSE Execution Environment"><div class="titlepage"><div><div><h3 class="title"><a id="querying_the_ese_execution_environment"/>Querying the eSE Execution Environment</h3></div></div></div><p>As discussed in “<a class="xref" href="ch11.html#embedded_se" title="Embedded SE">Embedded SE</a>”, the eSE in the Galaxy Nexus is a chip from NXP’s SmartMX series. It runs a Java Card–compatible operating system and comes with a GlobalPlatform-compliant ISD. The ISD is configured to require authentication for most card management operations, and the authentication keys are, naturally, not publicly available. Additionally, a number of subsequent failed authentication attempts (usually 10) will lock the ISD and make it impossible to install or remove applets, so trying to brute-force the authentication keys is not an option. However, the ISD does provide some information about itself and the runtime environment on the card without requiring authentication in order to make it possible for clients to adjust their behavior dynamically and be compatible with different cards.</p><p>Because both Java Card and GlobalPlatform define a multi-application environment, each application needs a unique identifier called the <span class="emphasis"><em>Application Identifier (AID)</em></span>. The AID consists of a 5-byte Registered Application Provider Identifier (RID, also called a Resource Identifier) and a Proprietary Identifier eXtension (PIX), which can be up to 11 bytes long. Thus, the length of an AID can be 5 to 16 bytes long. Before being able to send commands to a particular applet, it needs to be made active, or selected, by issuing the <code class="literal">SELECT</code> (<code class="literal">CLA</code>=00, <code class="literal">INS</code>=A4) command with its AID. As all applications, the ISD is also identified by an AID, which varies between card manufacturers and GP implementations. We can find out the AID of the ISD by sending an empty <code class="literal">SELECT</code> command, which both selects the ISD and returns information about the card and the ISD configuration. An empty <code class="literal">SELECT</code> is simply a select without an AID specified, so the <code class="literal">SELECT</code> command APDU becomes <code class="literal">00 A4 04 00 00</code>. If we send this command using the <code class="literal">transcieve()</code> method of the <code class="literal">NfcExecutionEnvironment</code> class (<a class="xref" href="ch11.html#using_the_nfcexecutionenvironmen-id00025" title="Example 11-8. Using the NfcExecutionEnvironment API">Example 11-8</a> at ➍), the returned response might look like <a class="xref" href="ch11.html#galaxy_nexus_eseapostrophes_response_to" title="Example 11-10. Galaxy Nexus eSE’s response to empty SELECT">Example 11-10</a> at ➋ (➊ is the <code class="literal">SELECT</code> command).</p><div class="example"><a id="galaxy_nexus_eseapostrophes_response_to"/><p class="title">Example 11-10. Galaxy Nexus eSE’s response to empty <code class="literal">SELECT</code></p><div class="example-contents"><pre class="programlisting">--&gt; 00A4040000➊
&lt;-- 6F658408A000000003000000A5599F6501FF9F6E06479100783300734A06072A86488
6FC6B01600C060A2A864886FC6B02020101630906072A864886FC6B03640B06092A86488
6FC6B040215650B06092B8510864864020103660C060A2B060104012A026E0102 9000➋</pre></div></div><p><a id="iddle1121" class="indexterm"/><a id="iddle1174" class="indexterm"/><a id="iddle1808" class="indexterm"/><a id="iddle2690" class="indexterm"/><a id="iddle2694" class="indexterm"/><a id="iddle2839" class="indexterm"/><a id="iddle2958" class="indexterm"/><a id="iddle2962" class="indexterm"/>The response includes a successful status (0x9000) and a long string of bytes. The format of this data is defined in “APDU Command Reference,” <a class="xref" href="ch09.html" title="Chapter 9. Enterprise Security">Chapter 9</a> of the GlobalPlatform Card Specification and, as with most things in the smart card world, is in tag-length-value (TLV) format. In TLV, each unit of data is described by a unique tag, followed by its length in bytes, and finally the actual data. Most structures are recursive, so the data can host another TLV structure, which in turns wraps another, and so on. The structure shown in <a class="xref" href="ch11.html#galaxy_nexus_eseapostrophes_response_to" title="Example 11-10. Galaxy Nexus eSE’s response to empty SELECT">Example 11-10</a> is called <span class="emphasis"><em>File Control Information (FCI)</em></span> and in this case it wraps a Security Domain Management Data structure, which describes the ISD. When parsed, the FCI might look like <a class="xref" href="ch11.html#parsed_fci_of_the_isd_on_the_ese_in_gala" title="Example 11-11. Parsed FCI of the ISD on the eSE in Galaxy Nexus">Example 11-11</a>.</p><div class="example"><a id="parsed_fci_of_the_isd_on_the_ese_in_gala"/><p class="title">Example 11-11. Parsed FCI of the ISD on the eSE in Galaxy Nexus</p><div class="example-contents"><pre class="programlisting">SD FCI: Security Domain FCI
   AID: a0 00 00 00 03 00 00 00➊
    RID: a0 00 00 00 03 (Visa International [US])
    PIX: 00 00 00

   Data field max length: 255
   Application prod. life cycle data: 479100783300
   Tag allocation authority (OID): globalPlatform 01
   Card management type and version (OID): globalPlatform 02020101
   Card identification scheme (OID): globalPlatform 03
   Global Platform version: 2.1.1➋
   Secure channel version: SC02 (options: 15)➌
   Card config details: 06092B8510864864020103➍
   Card/chip details: 060A2B060104012A026E0102➎</pre></div></div><p>Here, the AID of the ISD is A0 00 00 00 03 00 00 00 ➊, the version of the GlobalPlatform implementation is 2.1.1 ➋, the supported Secure Channel protocol is SC02 ➌, and the last two fields of the structure contain some proprietary data about the card configuration (➍ and ➎). The only other GP command that doesn’t require authentication is <code class="literal">GET DATA</code>, which can be used to return additional data about the ISD configuration.</p></div></div><div class="sect2" title="UICC as a Secure Element"><div class="titlepage"><div><div><h2 class="title"><a id="uicc_as_a_secure_element"/>UICC as a Secure Element</h2></div></div></div><p>As discussed in “<a class="xref" href="ch11.html#se_form_factors_in_mobile_devices" title="SE Form Factors in Mobile Devices">SE Form Factors in Mobile Devices</a>”, the UICC in a mobile device can be used as a general-purpose SE when accessed using the Open Mobile API or a similar programming interface. This section gives a brief overview of UICCs and the applications they typically host, and then shows how to access the UICC via the Open Mobile API.</p><div class="sect3" title="SIM Cards and UICCs"><div class="titlepage"><div><div><h3 class="title"><a id="sim_cards_and_uiccs"/>SIM Cards and UICCs</h3></div></div></div><p>The predecessor of the UICC is the SIM card, and UICCs are still colloquially referred to as “SIM cards.” <span class="emphasis"><em>SIM</em></span> stands for <span class="emphasis"><em>Subscriber Identity Module</em></span> <a id="iddle2693" class="indexterm"/><a id="iddle2961" class="indexterm"/>and refers to a smart card that securely stores the subscriber identifier and the associated key used to identify and authenticate a device to a mobile network. SIMs were initially used on GSM networks and the original GSM standards were later extended to support 3G and LTE. Because SIMs are smart cards, they conform to ISO-7816 standards regarding physical characteristics and electrical interface. The first SIM cards were the same size as “regular” smart cards (Full-size, FF), but by far the most popular sizes today are Mini-SIM (2FF) and Micro-SIM (3FF), with Nano-SIM (4FF), which was introduced in 2012, also gaining market share.</p><p>Of course, not every smart card that fits in the SIM slot can be used in a mobile device, so the next question is: What makes a smart card a SIM card? Technically, it’s conformance to mobile communication standards such as 3GPP TS 11.11 and certification by the SIMalliance. In practice, it is the ability to run an application that allows it to communicate with the phone (referred to as <span class="emphasis"><em>Mobile Equipment</em></span> or <span class="emphasis"><em>Mobile Station</em></span> in related standards) and connect to a mobile network. While the original GSM standard did not distinguish between the physical smart card and the software required to connect to the mobile network, with the introduction of 3G standards, a clear distinction has been made. The physical smart card is referred to as a <span class="emphasis"><em>Universal Integrated Circuit Card (UICC),</em></span> and different mobile network applications that run on it have been defined: GSM, CSIM, USIM, ISIM, and so on. A UICC can host and run more than one network application (hence the name <span class="emphasis"><em>universal</em></span>), and thus can be used to connect to different networks. While network application functionality depends on the specific mobile network, their core features are quite similar: store network parameters securely and identify to the network, as well as authenticate the user (optionally) and store user data.</p></div><div class="sect3" title="UICC Applications"><div class="titlepage"><div><div><h3 class="title"><a id="uicc_applications"/>UICC Applications</h3></div></div></div><p>Let’s take GSM as an example and briefly review how a network application works. For GSM, the main network parameters are network identity (International Mobile Subscriber Identity, IMSI; tied to the SIM), phone number (MSISDN, used for routing calls and changeable), and a shared network authentication key <span class="emphasis"><em>Ki</em></span>. To connect to the network, the phone needs to authenticate and negotiate a session key. Both authentication and session keys are derived using <span class="emphasis"><em>Ki</em></span>, which is also known to the network and looked up by IMSI. The phone sends a connection request that includes its IMSI, which the network uses to find the corresponding <span class="emphasis"><em>Ki</em></span>. The network then uses the <span class="emphasis"><em>Ki</em></span> to generate a challenge (<span class="emphasis"><em>RAND</em></span>), expected challenge response (<span class="emphasis"><em>SRES</em></span>), and session key <span class="emphasis"><em>Kc</em></span>. When those parameters have been generated, the network sends <span class="emphasis"><em>RAND</em></span> to the phone and the GSM application running on the SIM card comes into play: the mobile passes the <span class="emphasis"><em>RAND</em></span> to the SIM card, which generates its own <span class="emphasis"><em>SRES</em></span> and <span class="emphasis"><em>Kc</em></span>. The <span class="emphasis"><em>SRES</em></span> is sent to the network and if it matches the expected value, encrypted communication is established using the session key <span class="emphasis"><em>Kc</em></span>.</p><p>As you can see, the security of this protocol hinges solely on the secrecy of the <span class="emphasis"><em>Ki</em></span>. Because all operations involving the <span class="emphasis"><em>Ki</em></span> are implemented inside <a id="iddle2367" class="indexterm"/><a id="iddle2691" class="indexterm"/><a id="iddle2692" class="indexterm"/><a id="iddle2842" class="indexterm"/><a id="iddle2874" class="indexterm"/><a id="iddle2959" class="indexterm"/><a id="iddle2960" class="indexterm"/>the SIM card, and it never comes in direct contact with the phone or the network, the scheme is kept reasonably secure. Of course, security depends on the encryption algorithms used as well, and major weaknesses that allow intercepted GSM calls to be decrypted using off-the-shelf hardware were found in the original versions of the A5/1 stream cipher (which was initially secret).</p><p>In Android, network authentication is implemented by the baseband processor (more on this in “<a class="xref" href="ch11.html#accessing_the_uicc" title="Accessing the UICC">Accessing the UICC</a>” below) and is never directly visible to the main OS.</p></div><div class="sect3" title="UICC Application Implementation and Installation"><div class="titlepage"><div><div><h3 class="title"><a id="uicc_application_implementation_and_inst"/>UICC Application Implementation and Installation</h3></div></div></div><p>We’ve seen that UICCs need to run applications; now let’s see how those applications are implemented and installed. Initial smart cards were based on a filesystem model, where files (called <span class="emphasis"><em>elementary files</em></span>, or <span class="emphasis"><em>EF</em></span>) and directories (called <span class="emphasis"><em>dedicated files</em></span>, or <span class="emphasis"><em>DF</em></span>) were named with a two-byte identifier. Thus, developing “an application” involved selecting an ID for the DF that hosts the application’s files (called <span class="emphasis"><em>ADF</em></span>), and specifying the formats and names of the EFs that store data. For example, the GSM application is under the <span class="emphasis"><em>7F20</em></span> ADF, and the USIM ADF hosts the <span class="emphasis"><em>EF_imsi</em></span>, <span class="emphasis"><em>EF_keys</em></span>, <span class="emphasis"><em>EF_sms</em></span>, and other required files.</p><p>Because practically all UICCs in use today are based on Java Card technology and implement GlobalPlatform card specifications, all network applications are implemented as Java Card applets and emulate the legacy file-based structure for backward compatibility. Applets are installed according to GlobalPlatform specifications by authenticating to the ISD and issuing <code class="literal">LOAD</code> and <code class="literal">INSTALL</code> commands.</p><p>One application management feature specific to SIM cards is support for OTA updates via binary SMS. This functionality is not used by all carriers, but it allows carriers to remotely install applets on SIM cards they’ve issued. OTA is implemented by wrapping card commands (APDUs) in SMS T-PDUs (transport protocol data units), which the phone forwards to the UICC. In most UICCs, this is the only way to load applets on the card, even during initial personalization.</p><p>The major use case for this OTA functionality is to install and maintain SIM Toolkit (STK) applications that can interact with the handset via standard “proactive” commands (which in reality are implemented via polling), and to display menus or even open web pages and send SMS. Android supports STK with a dedicated STK system app, which is automatically disabled if the UICC card has no STK applets installed.</p></div><div class="sect3" title="Accessing the UICC"><div class="titlepage"><div><div><h3 class="title"><a id="accessing_the_uicc"/>Accessing the UICC</h3></div></div></div><p>As we discussed in “<a class="xref" href="ch11.html#uicc_applications" title="UICC Applications">UICC Applications</a>”, mobile network–related functionality in Android, including UICC access, is implemented by the baseband software. The main OS (Android) is limited in what it can do with the UICC by the features the baseband exposes. Android supports STK applications and can look up and store contacts on the SIM, so it’s clear that it has internal support for communicating to the SIM. However, the Android security overview explicitly states that “low-level access to the <a id="iddle1366" class="indexterm"/><a id="iddle2349" class="indexterm"/><a id="iddle2695" class="indexterm"/><a id="iddle2721" class="indexterm"/><a id="iddle2768" class="indexterm"/><a id="iddle2847" class="indexterm"/><a id="iddle2928" class="indexterm"/><a id="iddle2963" class="indexterm"/>SIM card is not available to third-party apps.”<sup>[<a id="ch11fn16" href="#ftn.ch11fn16" class="footnote">126</a>]</sup> How can we use the SIM card (UICC) as an SE then? Some Android builds from major vendors, most notably Samsung, provide an implementation of the SIMalliance Open Mobile API, and an open source implementation (for compatible devices) of the API is available from the SEEK for Android project. The Open Mobile API aims to provide a unified interface for accessing SEs on Android, including the UICC.</p><p>To understand how the Open Mobile API works and the cause of its limitations, let’s review how access to the SIM card is implemented in Android. On Android devices, all mobile network functionality (dialing, sending SMS, and so on) is provided by the baseband processor (also referred to as <span class="emphasis"><em>modem</em></span> or <span class="emphasis"><em>radio</em></span>). Android applications and system services communicate with the baseband only indirectly via the Radio Interface Layer (RIL) daemon (<span class="emphasis"><em>rild</em></span>). The <span class="emphasis"><em>rild</em></span> in turn talks to the actual hardware by using a manufacturer-provided RIL HAL library, which wraps the proprietary interface that the baseband provides. The UICC card is typically connected only to the baseband processor (though sometimes also to the NFC controller via SWP), and thus all communication needs to go through the RIL.</p><p>While the proprietary RIL implementation can always access the UICC in order to perform network identification and authentication, as well as read and write contacts and access STK applications, support for transparent APDU exchange is not always available. As we mentioned in <a class="xref" href="ch11.html#uicc" title="UICC">UICC</a>, the standard way to provide this feature is to use extended AT commands such <code class="literal">AT+CSIM</code> (Generic SIM access) and <code class="literal">AT+CGLA</code> (Generic UICC Logical Channel Access), but some vendors implement APDU exchange using proprietary extensions, so support for the necessary AT commands doesn’t automatically provide UICC access.</p><p>SEEK for Android implements a resource manager service (<code class="literal">SmartCardService</code>) that can connect to any supported SE (eSE, ASSD, or UICC) and extensions to the Android telephony framework that allow for transparent APDU exchange with the UICC. Because access through the RIL is hardware- and HAL-dependent, you need both a compatible device and a build that includes the <code class="literal">SmartCardService</code> and related framework extensions, such as those found in most recent Samsung Galaxy devices.</p></div><div class="sect3" title="Using the OpenMobile API"><div class="titlepage"><div><div><h3 class="title"><a id="using_the_openmobile_api"/>Using the OpenMobile API</h3></div></div></div><p>The OpenMobile API is relatively small and defines classes that represent the card reader that an SE is connected to (<code class="literal">Reader</code>), a communication session with an SE (<code class="literal">Session</code>), and a basic (channel 0, as per ISO 7816-4) or logical channel with the SE (<code class="literal">Channel</code>). The <code class="literal">Channel</code> class allows applications to exchange APDUs with the SE using the <code class="literal">transmit()</code> method. The entry point to the API is the <code class="literal">SEService</code> class, which connects to the remote resource manager service (<code class="literal">SmartcardService</code>) and provides a method that returns a list <a id="iddle1884" class="indexterm"/><a id="iddle2348" class="indexterm"/><a id="iddle2350" class="indexterm"/><a id="iddle2846" class="indexterm"/>of <code class="literal">Reader</code> objects available on the device. (For more information about the OpenMobile API and the architecture of the <code class="literal">SmartcardService</code>, refer to the SEEK for Android Wiki.<sup>[<a id="ch11fn17" href="#ftn.ch11fn17" class="footnote">127</a>]</sup>)</p><p>In order to be able to use the OpenMobile API, applications need to request the <code class="literal">org.simalliance.openmobileapi.SMARTCARD</code> permission and add the <span class="emphasis"><em>org.simalliance.openmobileapi</em></span> extension library to their manifest as shown in <a class="xref" href="ch11.html#androidmanifestdotxml_configuration_requ" title="Example 11-12. AndroidManifest.xml configuration required to use the OpenMobile API">Example 11-12</a>.</p><div class="example"><a id="androidmanifestdotxml_configuration_requ"/><p class="title">Example 11-12. <span class="roman">AndroidManifest.xml</span> configuration required to use the OpenMobile API</p><div class="example-contents"><pre class="programlisting">&lt;manifest ...&gt;
    --<span class="emphasis"><em>snip</em></span>--
    &lt;uses-permission android:name="org.simalliance.openmobileapi.SMARTCARD" /&gt;

    &lt;application ...&gt;
        &lt;uses-library
            android:name="org.simalliance.openmobileapi"
            android:required="true" /&gt;
     --<span class="emphasis"><em>snip</em></span>--
    &lt;/application&gt;
&lt;/manifest&gt;</pre></div></div><p><a class="xref" href="ch11.html#sending_a_command_to_the_first_se_using" title="Example 11-13. Sending a command to the first SE using the OpenMobile API">Example 11-13</a> demonstrates how an application can use the OpenMobile API to connect and send a command to the first SE on the device.</p><div class="example"><a id="sending_a_command_to_the_first_se_using"/><p class="title">Example 11-13. Sending a command to the first SE using the OpenMobile API</p><div class="example-contents"><pre class="programlisting">Context context = getContext();
SEService.CallBack callback = createSeCallback();
SEService seService = new SEService(context, callback);➊
Reader[] readers = seService.getReaders();➋
Session session = readers[0].openSession();➌
Channel channel = session.openLogicalChannel(aid);➍
byte[] command = { ... };
byte[] response = channel.transmit(command);➎</pre></div></div><p>Here, the application first creates an <code class="literal">SEService</code> ➊ instance, which connects to the <code class="literal">SmartCardService</code> asynchronously and notifies the application via the <code class="literal">serviceConnected()</code> method (not shown) of the <code class="literal">SEService.CallBack</code> interface when the connection is established. The app can then get a list of the available SE readers using the <code class="literal">getReaders()</code> method ➋, and then open a session to the selected reader using the <code class="literal">openSession()</code> method ➌. If the device does not contain an eSE (or another form of SE besides the UICC), or the <code class="literal">SmartCardService</code> hasn’t been configured to use it, the list of readers contains a single <code class="literal">Reader</code> instance that represents the built-in UICC reader in the device. When the app has an open <code class="literal">Session</code> with the target SE, it calls the <code class="literal">openLogicalChannel()</code> method ➍ in order to obtain a <code class="literal">Channel</code>, which it then uses to send APDUs and receive responses using its <code class="literal">transmit()</code> method ➎.</p></div></div></div><div class="sect1" title="Software Card Emulation"><div class="titlepage"><div><div><h1 class="title"><a id="software_card_emulation"/>Software Card Emulation</h1></div></div></div><p><a id="iddle1507" class="indexterm"/><a id="iddle1922" class="indexterm"/><a id="iddle1927" class="indexterm"/><a id="iddle2233" class="indexterm"/><a id="iddle2316" class="indexterm"/><a id="iddle2323" class="indexterm"/><a id="iddle2337" class="indexterm"/><a id="iddle2517" class="indexterm"/><span class="emphasis"><em>Software card emulation</em></span> (also referred to as <span class="emphasis"><em>host-based card emulation</em></span> or <span class="emphasis"><em>HCE</em></span>) allows commands received by the NFC controller to be delivered to the application processor (main OS), and to be processed by regular Android applications, instead of by applets installed on a hardware SE. Responses are then sent back to the reader via NFC, allowing an app to act as a virtual contactless smart card.</p><p>Before being officially added to the Android API, HCE was first available as an experimental feature of the CyanogenMod Android distribution.<sup>[<a id="ch11fn18" href="#ftn.ch11fn18" class="footnote">128</a>]</sup> Beginning with version 9.1, CyanogenMod integrated a set of patches (developed by Doug Yeager) that unlock the HCE functionality of the popular PN544 NFC controller and provide a framework interface to HCE. In order to support HCE, two new tag technologies (<code class="literal">IsoPcdA</code> and <code class="literal">IsoPcdB</code>, representing external contactless readers based on NFC Type A and Type B technology, respectively) were added to the NFC framework. (The letters <span class="emphasis"><em>Pcd</em></span> stand for <span class="emphasis"><em>Proximity Coupling Device</em></span>, which is just another technical term for contactless reader.)</p><p>The <code class="literal">IsoPcdA</code> and <code class="literal">IsoPcdB</code> classes reversed the role of <code class="literal">Tag</code> objects in the Android NFC API: because the external contactless reader is presented as a “tag,” “commands” you send from the phone are actually replies to the reader-initiated communication. Unlike the rest of Android’s NFC stack, this architecture was not event driven and required applications to handle blocking I/O while waiting for the reader to send its next command. Android 4.4 introduced a standard, event-driven framework for developing HCE applications, which we discuss next.</p><div class="sect2" title="Android 4.4 HCE Architecture"><div class="titlepage"><div><div><h2 class="title"><a id="android_4dot4_hce_architecture"/>Android 4.4 HCE Architecture</h2></div></div></div><p>Unlike the R/W and P2P mode, which are only available to activities, HCE applications can work in the background and are implemented by defining a service that processes commands received from the external reader and returns responses. Such HCE services extend the <code class="literal">HostApduService</code> abstract framework class and implement its <code class="literal">onDeactivated()</code> and <code class="literal">processCommand()</code> methods. <code class="literal">HostApduService</code> itself is a very thin mediator class that enables twoway communication with the system <code class="literal">NfcService</code> by using <code class="literal">Messenger</code> objects.<sup>[<a id="ch11fn19" href="#ftn.ch11fn19" class="footnote">129</a>]</sup> For example, when the <code class="literal">NfcService</code> receives an APDU that needs to be routed (APDU routing is discussed in the next section) to a HCE service, it sends a <code class="literal">MSG_COMMAND_APDU</code> to <code class="literal">HostApduService</code>, which then extracts the APDU from the message and passes it to its concrete implementation by calling the <code class="literal">processCommand()</code> method. If <code class="literal">processCommand()</code> returns an APDU, <code class="literal">HostApduService</code> encapsulates it in a <code class="literal">MSG_RESPONSE_APDU</code> message and sends it to the <code class="literal">NfcService</code>, which in turn forwards it to the NFC controller. If the concrete HCE service cannot return a response APDU immediately, it <a id="iddle1160" class="indexterm"/><a id="iddle1275" class="indexterm"/><a id="iddle1920" class="indexterm"/><a id="iddle1926" class="indexterm"/><a id="iddle1928" class="indexterm"/><a id="iddle2315" class="indexterm"/><a id="iddle2317" class="indexterm"/><a id="iddle2851" class="indexterm"/>returns <code class="literal">null</code> and sends the response later (when it is available) by calling the <code class="literal">sendResponseApdu()</code>, which sends the response to the <code class="literal">NfcService</code> wrapped in a <code class="literal">MSG_RESPONSE_APDU</code> message.</p></div><div class="sect2" title="APDU Routing"><div class="titlepage"><div><div><h2 class="title"><a id="apdu_routing"/>APDU Routing</h2></div></div></div><p>When the device is in card emulation mode, the NFC controller receives all APDUs coming from external readers and decides whether to send them to a physical SE (if any), or to an HCE service based on its internal APDU routing table. The routing table is AID-based and is populated using the metadata SE-enabled applications and HCE services declared in their application manifests. When the external reader sends a <code class="literal">SELECT</code> command that is not directly routed to the SE, the NFC controller forwards it to the <code class="literal">NfcService</code>, which extracts the target AID from the command and searches the routing table for a matching HCE service by calling the <code class="literal">resolveAidPrefix()</code> method of the <code class="literal">RegisteredAidCache</code> class.</p><p>If a matching service is found, <code class="literal">NfcService</code> binds to it and obtains a <code class="literal">Messenger</code> instance, which it then uses to send subsequent APDUs (wrapped in <code class="literal">MSG_COMMAND_APDU</code> messages, as discussed in the previous section). For this to work, the app’s HCE service needs to be declared in <span class="emphasis"><em>AndroidManifest.xml</em></span> as shown in <a class="xref" href="ch11.html#declaring_a_hce_service_in_androidmanife" title="Example 11-14. Declaring a HCE service in AndroidManifest.xml">Example 11-14</a>.</p><div class="example"><a id="declaring_a_hce_service_in_androidmanife"/><p class="title">Example 11-14. Declaring a HCE service in <span class="roman">AndroidManifest.xml</span></p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest 
    package="com.example.hce" ...&gt;
    --<span class="emphasis"><em>snip</em></span>--
    &lt;uses-permission android:name="android.permission.NFC" /&gt;

    &lt;application ...&gt;
        --<span class="emphasis"><em>snip</em></span>--
        &lt;service
            android:name=".MyHostApduService"➊
            android:exported="true"
            android:permission="android.permission.BIND_NFC_SERVICE" &gt;➋
            &lt;intent-filter&gt;
                &lt;action
                    android:name="android.nfc.cardemulation.action.HOST_APDU_SERVICE" /&gt;➌
            &lt;/intent-filter&gt;

            &lt;meta-data
                android:name="android.nfc.cardemulation.host_apdu_service"➍
                android:resource="@xml/apduservice" /&gt;
        &lt;/service&gt;
        --<span class="emphasis"><em>snip</em></span>--
    &lt;/application&gt;
&lt;/manifest&gt;</pre></div></div><p>The application declares its HCE service ➊ as usual, using the <code class="literal">&lt;service&gt;</code> tag, but there are a few additional requirements. First, the service must be protected with the <code class="literal">BIND_NFC_SERVICE</code> system signature permission ➋, to <a id="iddle1122" class="indexterm"/><a id="iddle1123" class="indexterm"/><a id="iddle1162" class="indexterm"/><a id="iddle1175" class="indexterm"/><a id="iddle1325" class="indexterm"/><a id="iddle1542" class="indexterm"/><a id="iddle1886" class="indexterm"/><a id="iddle1925" class="indexterm"/><a id="iddle1929" class="indexterm"/><a id="iddle1992" class="indexterm"/><a id="iddle2599" class="indexterm"/>guarantee that only system apps (in practice, only the <code class="literal">NfcService</code>) can bind to it. Next, the service needs to declare an intent filter that matches the <code class="literal">android.nfc.cardemulation.action.HOST_APDU_SERVICE</code> action ➌ so that it can be identified as a HCE service when scanning installed packages, and be bound to when a matching APDU is received. Finally, the service must have an XML resource metadata entry under the name <span class="emphasis"><em>android.nfc.cardemulation.host_apdu_ service</em></span> ➍, which points to an XML resource file listing the AIDs that the service can handle. The contents of this file is used to build the AID routing table, which the NFC stack consults when it receives a <code class="literal">SELECT</code> command.</p><div class="sect3" title="Specifying Routing for HCE Services"><div class="titlepage"><div><div><h3 class="title"><a id="specifying_routing_for_hce_services"/>Specifying Routing for HCE Services</h3></div></div></div><p>For HCE applications, the XML file must include a <code class="literal">&lt;host-apdu-service&gt;</code> root element as shown in <a class="xref" href="ch11.html#hce_service_aid_metadata_file" title="Example 11-15. HCE service AID metadata file">Example 11-15</a>.</p><div class="example"><a id="hce_service_aid_metadata_file"/><p class="title">Example 11-15. HCE service AID metadata file</p><div class="example-contents"><pre class="programlisting">&lt;host-apdu-service
    
    android:description="@string/servicedesc"
    android:requireDeviceUnlock="false"&gt;➊
    &lt;aid-group android:description="@string/aiddescription"➋
               android:category="other"&gt;➌
        &lt;aid-filter android:name="A0000000010101"/&gt;➍
    &lt;/aid-group&gt;
&lt;/host-apdu-service&gt;</pre></div></div><p>The <code class="literal">&lt;host-apdu-service&gt;</code> tag has a <code class="literal">description</code> attribute and a <code class="literal">requireDeviceUnlock</code> attribute ➊, which specifies whether the corresponding HCE service should be activated when the device is locked. (The device’s screen must be on for NFC to work.) The root element contains one or more <code class="literal">&lt;aid-group&gt;</code> entries ➋, which each have a <code class="literal">category</code> attribute ➌ and contain one or more <code class="literal">&lt;aid-filter&gt;</code> ➍ tags that specify an AID in their <code class="literal">name</code> attribute (<span class="emphasis"><em>A0000000010101</em></span> in this example).</p><p>An AID group defines a set of AIDs that is always handled by a particular HCE service. The NFC framework guarantees that if a single AID is handled by an HCE service, then all other AIDs in the group are also handled by the same service. If two or more HCE services define the same AID, the system shows a selection dialog letting the user choose which application should handle the incoming <code class="literal">SELECT</code> command. When an app is chosen, all subsequent commands are routed to it after the user confirms the selection by tapping on the dialog shown in <a class="xref" href="ch11.html#hce_application_selection_confirmation_d" title="Figure 11-2. HCE application selection confirmation dialog">Figure 11-2</a>.</p><p>Each AID group is associated with a category (specified with the <code class="literal">category</code> attribute), which allows the system to set a default handler per category, rather than per AID. An application can check if a particular service is the default handler for a category by calling the <code class="literal">isDefaultServiceForCategory()</code> method of the <code class="literal">CardEmulation</code> class, and get the selection mode for a category by calling the <code class="literal">getSelectionModeForCategory()</code> method. As of this writing, only two categories are defined: <code class="literal">CATEGORY_PAYMENT</code> and <code class="literal">CATEGORY_OTHER</code>.</p><p><a id="iddle1161" class="indexterm"/><a id="iddle1930" class="indexterm"/>Android enforces a single active payment category in order to ensure that the user has explicitly selected which app should handle payment transactions. The default app for the payment category is selected in the Tap &amp; pay screen of the system Settings app, as shown in <a class="xref" href="ch11.html#selecting_the_default_payment_applicatio" title="Figure 11-3. Selecting the default payment application in the Tap &amp; pay screen">Figure 11-3</a>. (See the official HCE documentation<sup>[<a id="ch11fn20" href="#ftn.ch11fn20" class="footnote">130</a>]</sup> for more on payment applications.)</p><div class="figure"><a id="hce_application_selection_confirmation_d"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00069"/><img src="figs/web/11fig02.png.jpg" alt="HCE application selection confirmation dialog"/></div></div><p class="title">Figure 11-2. HCE application selection confirmation dialog</p></div><div class="figure"><a id="selecting_the_default_payment_applicatio"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00070"/><img src="figs/web/11fig03.png.jpg" alt="Selecting the default payment application in the Tap &amp; pay screen"/></div></div><p class="title">Figure 11-3. Selecting the default payment application in the Tap &amp; pay screen</p></div></div><div class="sect3" title="Specifying Routing for SE Applets"><div class="titlepage"><div><div><h3 class="title"><a id="specifying_routing_for_se_applets"/>Specifying Routing for SE Applets</h3></div></div></div><p>If a device supports HCE and also has a physical SE, a <code class="literal">SELECT</code> command sent by an external reader can target either an HCE service, or an applet installed on the SE. Because Android 4.4 directs all AIDs not listed in the AID routing table to the host, the AIDs of applets installed on the SE must be explicitly added to the NFC controller’s routing table. This is accomplished with the same mechanism used for registering HCE services: by adding a service entry to the application’s manifest, and linking it to a meta-data XML file that specifies a list of AIDs that should be routed to the SE. When the route is established, command APDUs are sent directly to the SE (which processes them and returns a response via the NFC controller), so the service is used only as a marker and provides no functionality.</p><p><a id="iddle2334" class="indexterm"/><a id="iddle2335" class="indexterm"/><a id="iddle2336" class="indexterm"/>The Android SDK includes a helper service (<code class="literal">OffHostApduService</code>) that can be used to list AIDs that should be routed directly to the SE. This <code class="literal">OffHostApduService</code> class defines some useful constants, but is otherwise empty. An application can extend it and declare the resulting service component in its manifest as shown in <a class="xref" href="ch11.html#declaring_an_off-host_apdu_service_in_an" title="Example 11-16. Declaring an off-host APDU service in AndroidManifest.xml">Example 11-16</a>.</p><div class="example"><a id="declaring_an_off-host_apdu_service_in_an"/><p class="title">Example 11-16. Declaring an off-host APDU service in <span class="roman">AndroidManifest.xml</span></p><div class="example-contents"><pre class="programlisting">&lt;manifest 
    package="com.example.hce" ...&gt;
    --<span class="emphasis"><em>snip</em></span>--
    &lt;uses-permission android:name="android.permission.NFC" /&gt;

    &lt;application ... &gt;
        --<span class="emphasis"><em>snip</em></span>--
        &lt;service android:name=".MyOffHostApduService"
                 android:exported="true"
                 android:permission="android.permission.BIND_NFC_SERVICE"&gt;
        &lt;intent-filter&gt;
            &lt;action
                android:name="android.nfc.cardemulation.action.OFF_HOST_APDU_SERVICE"/&gt;➊
        &lt;/intent-filter&gt;
        &lt;meta-data
            android:name="android.nfc.cardemulation.off_host_apdu_service"➋
            android:resource="@xml/apduservice"/&gt;
    &lt;/service&gt;
    --<span class="emphasis"><em>snip</em></span>--
    &lt;/application&gt;
&lt;/manifest&gt;</pre></div></div><p>The service declaration is similar to that of <a class="xref" href="ch11.html#declaring_a_hce_service_in_androidmanife" title="Example 11-14. Declaring a HCE service in AndroidManifest.xml">Example 11-14</a>, except that the declared intent action is <span class="emphasis"><em>android.nfc.cardemulation.action.OFF_HOST_ APDU_SERVICE</em></span> ➊ and the XML metadata name is <span class="emphasis"><em>android.nfc.cardemulation.off_host_apdu_service</em></span> ➋. The metadata file is also slightly different, as shown in <a class="xref" href="ch11.html#off-host_apdu_service_metadata_file" title="Example 11-17. Off-host APDU service metadata file">Example 11-17</a>.</p><div class="example"><a id="off-host_apdu_service_metadata_file"/><p class="title">Example 11-17. Off-host APDU service metadata file</p><div class="example-contents"><pre class="programlisting">&lt;offhost-apdu-service
    
    android:description="@string/servicedesc"&gt;➊
    &lt;aid-group android:description="@string/se_applets"
               android:category="other"&gt;➋
        &lt;aid-filter android:name="F0000000000001"/&gt;➌
        &lt;aid-filter android:name="F0000000000002"/&gt;➍
    &lt;/aid-group&gt;
&lt;/offhost-apdu-service&gt;</pre></div></div><p>As you can see, the format is the same as that of an HCE service, but the root element of the file is <code class="literal">&lt;offhost-apdu-service&gt;</code> ➊ instead of <code class="literal">&lt;host-apdu-service&gt;</code>. Another subtle difference is that <code class="literal">&lt;offhost-apdu-service&gt;</code> does not support the <code class="literal">requireDeviceUnlock</code> attribute, because transactions are sent directly to the SE and therefore the host cannot intervene regardless <a id="iddle1124" class="indexterm"/><a id="iddle1923" class="indexterm"/><a id="iddle1932" class="indexterm"/><a id="iddle2319" class="indexterm"/>of the state of the lockscreen. The AIDs of the applets residing on the SE (➌ and ➍) are included in a <code class="literal">&lt;aid-group&gt;</code> ➋. Those AIDs are sent directly to the NFC controller, which saves them in its internal routing table in order to be able to send matching APDUs directly to the SE, without interacting with the Android OS. If the received APDU is not in the NFC controller’s routing table, it forwards it to the <code class="literal">NfcService</code>, which sends it to the matching HCE service, or returns an error if no matches are found.</p></div></div><div class="sect2" title="Writing an HCE Service"><div class="titlepage"><div><div><h2 class="title"><a id="writing_an_hce_service"/>Writing an HCE Service</h2></div></div></div><p>When the HCE service of an application has been declared in its manifest as shown in <a class="xref" href="ch11.html#declaring_a_hce_service_in_androidmanife" title="Example 11-14. Declaring a HCE service in AndroidManifest.xml">Example 11-14</a>, HCE functionality can be added by extending the <code class="literal">HostApduService</code> base class and implementing its abstract methods as shown in <a class="xref" href="ch11.html#implementing_a_hostapduservice" title="Example 11-18. Implementing a HostApduService">Example 11-18</a>.</p><div class="example"><a id="implementing_a_hostapduservice"/><p class="title">Example 11-18. Implementing a <code class="literal">HostApduService</code></p><div class="example-contents"><pre class="programlisting">public class MyHostApduService extends HostApduService {
    --<span class="emphasis"><em>snip</em></span>--
    static final int OFFSET_CLA = 0;➊
    static final int OFFSET_INS = 1;
    static final int OFFSET_P1 = 2;
    static final int OFFSET_P2 = 3;
    --<span class="emphasis"><em>snip</em></span>--
    static final short SW_SUCCESS = (short) 0x9000;➋
    static final short SW_CLA_NOT_SUPPORTED = 0x6E00;
    static final short SW_INS_NOT_SUPPORTED = 0x6D00;
    --<span class="emphasis"><em>snip</em></span>--
    static final byte[] SELECT_CMD = { 0x00, (byte) 0xA4,
            0x04, 0x00, 0x06, (byte) 0xA0,
            0x00, 0x00, 0x00, 0x01, 0x01, 0x01 };➌

    static final byte MY_CLA = (byte) 0x80;➍
    static final byte INS_CMD1 = (byte) 0x01;
    static final byte INS_CMD2 = (byte) 0x02;

    boolean selected = false;

    public byte[] processCommandApdu(byte[] cmd, Bundle extras) {
        if (!selected) {
            if (Arrays.equals(cmd, SELECT_CMD)) {➎
                selected = true;

                return toBytes(SW_SUCCESS);
            }
            --<span class="emphasis"><em>snip</em></span>-
        }

        if (cmd[OFFSET_CLA] != MY_CLA) {➏
            return toBytes(SW_CLA_NOT_SUPPORTED);
        }

        byte ins = cmd[OFFSET_INS];➐
        switch (ins) {
            case INS_CMD1:➑
                byte p1 = cmd[OFFSET_P1];
                byte p2 = cmd[OFFSET_P2];
                --<span class="emphasis"><em>snip</em></span>--
                return toBytes(SW_SUCCESS);
            case INS_CMD2:
                --<span class="emphasis"><em>snip</em></span>--
                return null;➒
            default:
                return toBytes(SW_INS_NOT_SUPPORTED);
        }
    }

    @Override
    public void onDeactivated(int reason) {
        --<span class="emphasis"><em>snip</em></span>--
        selected = false;➊
    }
    --<span class="emphasis"><em>snip</em></span>--
}</pre></div></div><p><a id="iddle1924" class="indexterm"/><a id="iddle2338" class="indexterm"/><a id="iddle2759" class="indexterm"/>Here, the example HCE service first declares a few constants that will be helpful when accessing APDU data ➊ and returning a standard status result ➋. The service defines the <code class="literal">SELECT</code> command that is used to activate it, including the AID ➌. The next few constants ➍ declare the instruction class (<span class="emphasis"><em>CLA</em></span>) and instructions that the service can handle.</p><p>When the HCE service receives an APDU, it passes it to the <code class="literal">processCommandApdu()</code> method as a byte array, which the service analyzes. If the service hasn’t been selected yet, the <code class="literal">processCommandApdu()</code> method checks if the APDU contains a <code class="literal">SELECT</code> command ➎, and sets the <code class="literal">selected</code> flag if it does. If the APDU contains some other command, the code checks to see if it has a class byte (<span class="emphasis"><em>CLA</em></span>) the services supports ➏, and then extracts the instruction byte (<span class="emphasis"><em>INS</em></span>) included in the command ➐. If the command APDU contains the <code class="literal">INS_CMD1</code> instruction ➑, the service extracts the <span class="emphasis"><em>P1</em></span> and <span class="emphasis"><em>P2</em></span> parameters, possibly parses the data included in the APDU (not shown), sets some internal state, and returns a success status.</p><p>If the command includes <code class="literal">INS_CMD2</code>, which in our example maps to a hypothetical operation that requires some time to process (for example, asymmetric key generation), the service starts a worker thread (not shown), and returns <code class="literal">null</code> ➒ in order not to block the main thread of the application. When the worker thread completes execution, it can return its result using the inherited <code class="literal">sendResponseApdu()</code> (defined in the parent <code class="literal">HostApduService</code> class). When another service or SE applet is selected, the system calls the <code class="literal">onDeactivated()</code> method, which should release any used resources before returning, but in our example simply sets the <code class="literal">selected</code> flag to <code class="literal">false</code> ➓.</p><p><a id="iddle1276" class="indexterm"/><a id="iddle1931" class="indexterm"/><a id="iddle2318" class="indexterm"/><a id="iddle2516" class="indexterm"/>Because an HCE service essentially parses command APDUs and returns responses, the programming model is very similar to that of Java Card applets. However, because a HCE service lives inside a regular Android application, it does not execute in a constrained environment and can take advantage of all available Android features. This makes it easy to implement complex functionality, but also impacts the security of HCE apps, as discussed next.</p></div><div class="sect2" title="Security of HCE Applications"><div class="titlepage"><div><div><h2 class="title"><a id="security_of_hce_applications"/>Security of HCE Applications</h2></div></div></div><p>Because any Android application can declare an HCE service and receive and process APDUs, the system guarantees that a malicious application cannot inject rogue APDU commands into an HCE service by requiring the <code class="literal">BIND_NFC_SERVICE</code> system signature permission in order to bind to HCE services. Additionally, Android’s sandboxing model ensures that other applications cannot access sensitive data stored by the HCE application by reading its files or calling any data access APIs it might expose without permission (assuming such APIs have been properly secured, of course).</p><p>Nevertheless, a malicious application that manages to obtain root privileges on a device (for example, by exploiting a privilege escalation vulnerability) can both inspect and inject APDUs targeted at an HCE service, and read its private data. The HCE application can take some measures to detect this situation, for example by inspecting the identity and signing certificate of the caller of its <code class="literal">processCommandApdu()</code> method, but such measures can ultimately be defeated given unconstrained access to the OS. Like all applications that store sensitive data, HCE applications should also take steps to protect stored data, such as by encrypting it on disk or by storing it in the system credential store in the case of cryptographic keys. Another way to protect both the code and data of HCE applications is to forward all received commands to a remote server, over an encrypted channel, and relay only its replies. However, because most of these measures are implemented in software, they can ultimately be disabled or bypassed by a sufficiently sophisticated malicious application with root access.</p><p>In contrast, hardware security elements offer physical tamper resistance, reduced attack surface due to their constrained functionality, and tight control over installed applets. Therefore, physical SEs are much harder to attack and provide much stronger protection of sensitive data used in typical card emulation scenarios like contactless payments, even when the default security guarantees of the host OS have been bypassed.</p><div class="note" title="Note"><h3 class="title"><a id="ch11note02"/>Note</h3><p><span class="emphasis"><em>For a detailed discussion of the difference in security level of card emulation applications when implemented in secure elements as opposed to in software using HCE, see the “HCE vs embedded secure element” blog post series by Cem Paya (who worked on the original eSE-backed Google Wallet implementation).</em></span><sup>[<a id="ch11fn21" href="#ftn.ch11fn21" class="footnote">131</a>]</sup></p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00026"/>Summary</h1></div></div></div><p>Android supports the three NFC modes: reader/writer, point-to-point, and card emulation. In reader/writer mode, Android devices can access NFC tags, contactless cards, and NFC emulation devices, while the point-to-point mode provides simple data exchange functionality. The card emulation mode can be backed either by a physical secure element (SE) such as a UICC, one that is integrated with the NFC controller (embedded SE), or by regular Android applications since Android 4.4. Hardware security elements provide the highest security by offering physical tamper resistance and stringent control over SE application (typically implemented as Java Card applets) management. However, because the authentication keys required to install an application on an SE are typically controlled by a single entity (such as the device manufacturer or MNO), distributing SE applications can be problematic. Host-based card emulation (HCE), introduced in Android 4.4, makes it easy to develop and distribute applications that work in card emulation mode, but it relies solely on the OS to enforce security and therefore offers weaker protection of sensitive application code and data.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch11fn01" href="#ch11fn01" class="para">111</a>] </sup>The NDEF format and its implementation using various tag technologies are described in the NFC Forum specification, available on its website: <span class="emphasis"><em><a class="ulink" href="http://nfc-forum.org/our-work/specifications-and-application-documents/specifications/nfc-forum-technical-specifications/">http://nfc-forum.org/our-work/specifications-and-application-documents/specifications/nfc-forum-technical-specifications/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn02" href="#ch11fn02" class="para">112</a>] </sup>Official versions of all ISO standards can be purchased on its website, <span class="emphasis"><em><a class="ulink" href="http://www.iso.org/iso/home/store/catalogue_ics.htm">http://www.iso.org/iso/home/store/catalogue_ics.htm</a></em></span>. Draft versions of standards can usually be obtained from the website of the standard working group.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn03" href="#ch11fn03" class="para">113</a>] </sup>Google, <span class="emphasis"><em>Android API Reference</em></span>, “TagTechnology,” <span class="emphasis"><em><a class="ulink" href="https://developer.android.com/reference/android/nfc/tech/TagTechnology.html">https://developer.android.com/reference/android/nfc/tech/TagTechnology.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn04" href="#ch11fn04" class="para">114</a>] </sup>Google, <span class="emphasis"><em>Android API Reference</em></span>, “NfcAdapter,” <span class="emphasis"><em><a class="ulink" href="https://developer.android.com/reference/android/nfc/NfcAdapter.html">https://developer.android.com/reference/android/nfc/NfcAdapter.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn05" href="#ch11fn05" class="para">115</a>] </sup>NFC Forum, “NFC Forum Technical Specifications,” <span class="emphasis"><em><a class="ulink" href="http://nfc-forum.org/our-work/specifications-and-application-documents/specifications/nfc-forum-technical-specifications/">http://nfc-forum.org/our-work/specifications-and-application-documents/specifications/nfc-forum-technical-specifications/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn06" href="#ch11fn06" class="para">116</a>] </sup>Google, <span class="emphasis"><em>Android API Guides</em></span>, “NFC Basics,” <span class="emphasis"><em><a class="ulink" href="https://developer.android.com/guide/topics/connectivity/nfc/nfc.html#p2p">https://developer.android.com/guide/topics/connectivity/nfc/nfc.html#p2p</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn07" href="#ch11fn07" class="para">117</a>] </sup>3GPP, <span class="emphasis"><em>AT command set for User Equipment (UE)</em></span>, <span class="emphasis"><em><a class="ulink" href="http://www.3gpp.org/ftp/Specs/html-info/27007.htm">http://www.3gpp.org/ftp/Specs/html-info/27007.htm</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn08" href="#ch11fn08" class="para">118</a>] </sup>“Secure Element Evaluation Kit for the Android platform,” <span class="emphasis"><em><a class="ulink" href="https://code.google.com/p/seek-for-android/">https://code.google.com/p/seek-for-android/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn09" href="#ch11fn09" class="para">119</a>] </sup>SIMalliance Limited, <span class="emphasis"><em>Open Mobile API Specification v2.05</em></span>, <span class="emphasis"><em><a class="ulink" href="http://www.simalliance.org/en?t=/documentManager/sfdoc.file.supply&amp;fileID=1392314878580">http://www.simalliance.org/en?t=/documentManager/sfdoc.file.supply&amp;fileID=1392314878580</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn10" href="#ch11fn10" class="para">120</a>] </sup>SD Association, “Advanced Security SD Card: ASSD,” <span class="emphasis"><em><a class="ulink" href="https://www.sdcard.org/developers/overview/ASSD/">https://www.sdcard.org/developers/overview/ASSD/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn11" href="#ch11fn11" class="para">121</a>] </sup>ECMA International, <span class="emphasis"><em>ECMA-373: Near Field Communication Wired Interface (NFC-WI)</em></span>, <span class="emphasis"><em><a class="ulink" href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-373.pdf">http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-373.pdf</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn12" href="#ch11fn12" class="para">122</a>] </sup>Oracle, “JSR 177: Security and Trust Services API for J2METM,” <span class="emphasis"><em><a class="ulink" href="https://jcp.org/en/jsr/detail?id=177">https://jcp.org/en/jsr/detail?id=177</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn13" href="#ch11fn13" class="para">123</a>] </sup>Oracle, “Java Card Classic Platform Specification 3.0.4,” <span class="emphasis"><em><a class="ulink" href="http://www.oracle.com/technetwork/java/javacard/specs-jsp-136430.html">http://www.oracle.com/technetwork/java/javacard/specs-jsp-136430.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn14" href="#ch11fn14" class="para">124</a>] </sup>GlobalPlatform, “Card Specifications,” <span class="emphasis"><em><a class="ulink" href="http://www.globalplatform.org/specificationscard.asp">http://www.globalplatform.org/specificationscard.asp</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn15" href="#ch11fn15" class="para">125</a>] </sup>A summary of ISO 7816 and other smart card-related standards is available on CardWerk’s website: <span class="emphasis"><em><a class="ulink" href="http://www.cardwerk.com/smartcards/smartcard_standards.aspx">http://www.cardwerk.com/smartcards/smartcard_standards.aspx</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn16" href="#ch11fn16" class="para">126</a>] </sup>Google, <span class="emphasis"><em>Android Security Overview</em></span>, “SIM Card Access,” <span class="emphasis"><em><a class="ulink" href="https://source.android.com/devices/tech/security/#sim-card-access">https://source.android.com/devices/tech/security/#sim-card-access</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn17" href="#ch11fn17" class="para">127</a>] </sup><span class="emphasis"><em>SEEK for Android</em></span>, “SmartCardAPI<span class="emphasis"><em>,” <a class="ulink" href="https://code.google.com/p/seek-for-android/wiki/SmartcardAPI">https://code.google.com/p/seek-for-android/wiki/SmartcardAPI</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn18" href="#ch11fn18" class="para">128</a>] </sup>CyanogenMod<span class="emphasis"><em>, <a class="ulink" href="http://www.cyanogenmod.org/">http://www.cyanogenmod.org/</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn19" href="#ch11fn19" class="para">129</a>] </sup>Google, <span class="emphasis"><em>Android API Reference</em></span>, “Messenger,” <span class="emphasis"><em><a class="ulink" href="https://developer.android.com/reference/android/os/Messenger.html">https://developer.android.com/reference/android/os/Messenger.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn20" href="#ch11fn20" class="para">130</a>] </sup>Google<span class="emphasis"><em>, Host-based Card Emulation</em></span>, “Payment Applications,” <span class="emphasis"><em><a class="ulink" href="https://developer.android.com/guide/topics/connectivity/nfc/hce.html#PaymentApps">https://developer.android.com/guide/topics/connectivity/nfc/hce.html#PaymentApps</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch11fn21" href="#ch11fn21" class="para">131</a>] </sup>Cem Paya<span class="emphasis"><em>, Random Oracle</em></span>, “HCE vs embedded secure element,” parts I to VI, <span class="emphasis"><em><a class="ulink" href="http://randomoracle.wordpress.com/2014/03/08/hce-vs-embedded-secure-element-comparing-risks-part-i/">http://randomoracle.wordpress.com/2014/03/08/hce-vs-embedded-secure-element-comparing-risks-part-i/</a></em></span></p></div></div></div></body></html>