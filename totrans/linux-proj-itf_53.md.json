["```\n#include <fcntl.h>            /* Defines O_* constants */\n#include <sys/stat.h>         /* Defines mode constants */\n#include <semaphore.h>\n\nsem_t *`sem_open`(const char **name*, int *oflag*, ...\n                /* mode_t *mode*, unsigned int *value* */ );\n```", "```\nsem_t *sp, sem2\nsp = sem_open(...);\nsem2 = *sp;\nsem_wait(&sem2);\n```", "```\n$ `umask 007`\n$ `./psem_create -cx /demo 666`             *666 means read+write for all users*\n$ `ls -l /dev/shm/sem.*`\n-rw-rw----  1 mtk users 16 Jul  6 12:09 /dev/shm/sem.demo\n```", "```\n$ `./psem_create -cx /demo 666`\nERROR [EEXIST File exists] sem_open       *Failed because of* O_EXCL\n```", "```\n`psem/psem_create.c`\n#include <semaphore.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"tlpi_hdr.h\"\n\nstatic void\nusageError(const char *progName)\n{\n    fprintf(stderr, \"Usage: %s [-cx] name [octal-perms [value]]\\n\", progName);\n    fprintf(stderr, \"    -c   Create semaphore (O_CREAT)\\n\");\n    fprintf(stderr, \"    -x   Create exclusively (O_EXCL)\\n\");\n    exit(EXIT_FAILURE);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int flags, opt;\n    mode_t perms;\n    unsigned int value;\n    sem_t *sem;\n\n    flags = 0;\n    while ((opt = getopt(argc, argv, \"cx\")) != -1) {\n        switch (opt) {\n        case 'c':   flags |= O_CREAT;           break;\n        case 'x':   flags |= O_EXCL;            break;\n        default:    usageError(argv[0]);\n        }\n    }\n\n    if (optind >= argc)\n        usageError(argv[0]);\n\n    /* Default permissions are rw-------; default semaphore initialization\n       value is 0 */\n\n    perms = (argc <= optind + 1) ? (S_IRUSR | S_IWUSR) :\n                getInt(argv[optind + 1], GN_BASE_8, \"octal-perms\");\n    value = (argc <= optind + 2) ? 0 : getInt(argv[optind + 2], 0, \"value\");\n\n    sem = sem_open(argv[optind], flags, perms, value);\n    if (sem == SEM_FAILED)\n        errExit(\"sem_open\");\n\n    exit(EXIT_SUCCESS);\n}\n    `psem/psem_create.c`\n```", "```\n#include <semaphore.h>\n\nint `sem_close`(sem_t **sem*);\n```", "```\n#include <semaphore.h>\n\nint `sem_unlink`(const char **name*);\n```", "```\n`psem/psem_unlink.c`\n#include <semaphore.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    if (argc != 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s sem-name\\n\", argv[0]);\n\n    if (sem_unlink(argv[1]) == -1)\n        errExit(\"sem_unlink\");\n    exit(EXIT_SUCCESS);\n}\n    `psem/psem_unlink.c`\n```", "```\n#include <semaphore.h>\n\nint `sem_wait`(sem_t **sem*);\n```", "```\n`psem/psem_wait.c`\n#include <semaphore.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    sem_t *sem;\n\n    if (argc < 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s sem-name\\n\", argv[0]);\n\n    sem = sem_open(argv[1], 0);\n    if (sem == SEM_FAILED)\n        errExit(\"sem_open\");\n\n    if (sem_wait(sem) == -1)\n        errExit(\"sem_wait\");\n\n    printf(\"%ld sem_wait() succeeded\\n\", (long) getpid());\n    exit(EXIT_SUCCESS);\n}\n    `psem/psem_wait.c`\n```", "```\n#include <semaphore.h>\n\nint `sem_trywait`(sem_t **sem*);\n```", "```\n#include <semaphore.h>\n\nint `sem_timedwait`(sem_t **sem*, const struct timespec **abs_timeout*);\n```", "```\n#include <semaphore.h>\n\nint `sem_post`(sem_t **sem*);\n```", "```\n`psem/psem_post.c`\n#include <semaphore.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    sem_t *sem;\n\n    if (argc != 2)\n        usageErr(\"%s sem-name\\n\", argv[0]);\n\n    sem = sem_open(argv[1], 0);\n    if (sem == SEM_FAILED)\n        errExit(\"sem_open\");\n\n    if (sem_post(sem) == -1)\n        errExit(\"sem_post\");\n    exit(EXIT_SUCCESS);\n}\n    `psem/psem_post.c`\n```", "```\n#include <semaphore.h>\n\nint `sem_getvalue`(sem_t **sem*, int **sval*);\n```", "```\n`psem/psem_getvalue.c`\n#include <semaphore.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int value;\n    sem_t *sem;\n\n    if (argc != 2)\n        usageErr(\"%s sem-name\\n\", argv[0]);\n\n    sem = sem_open(argv[1], 0);\n    if (sem == SEM_FAILED)\n        errExit(\"sem_open\");\n\n    if (sem_getvalue(sem, &value) == -1)\n        errExit(\"sem_getvalue\");\n\n    printf(\"%d\\n\", value);\n    exit(EXIT_SUCCESS);\n}\n    `psem/psem_getvalue.c`\n```", "```\n$ `./psem_create -c /demo 600 0`\n$ `./psem_wait /demo &`\n[1] 31208\n```", "```\n$ `./psem_getvalue /demo`\n0\n```", "```\n$ `./psem_post /demo`\n$ 31208 sem_wait() succeeded\n```", "```\n*Press Enter*\n[1]-  Done          ./psem_wait /demo\n$ `./psem_post /demo` *Increment semaphore*\n$ `./psem_getvalue /demo` *Retrieve semaphore value*\n1\n$ `./psem_unlink /demo` *Weâ€™re done with this semaphore*\n```", "```\n#include <semaphore.h>\n\nint `sem_init`(sem_t **sem*, int *pshared*, unsigned int *value*);\n```", "```\n`psem/thread_incr_psem.c`\n#include <semaphore.h>\n#include <pthread.h>\n#include \"tlpi_hdr.h\"\n\nstatic int glob = 0;\nstatic sem_t sem;\n\nstatic void *                   /* Loop 'arg' times incrementing 'glob' */\nthreadFunc(void *arg)\n{\n    int loops = *((int *) arg);\n    int loc, j;\n\n    for (j = 0; j < loops; j++) {\n        if (sem_wait(&sem) == -1)\n            errExit(\"sem_wait\");\n\n        loc = glob;\n        loc++;\n        glob = loc;\n\n        if (sem_post(&sem) == -1)\n            errExit(\"sem_post\");\n    }\n\n    return NULL;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    pthread_t t1, t2;\n    int loops, s;\n\n    loops = (argc > 1) ? getInt(argv[1], GN_GT_0, \"num-loops\") : 10000000;\n\n    /* Initialize a thread-shared mutex with the value 1 */\n\n    if (sem_init(&sem, 0, 1) == -1)\n        errExit(\"sem_init\");\n\n    /* Create two threads that increment 'glob' */\n\n    s = pthread_create(&t1, NULL, threadFunc, &loops);\n    if (s != 0)\n        errExitEN(s, \"pthread_create\");\n    s = pthread_create(&t2, NULL, threadFunc, &loops);\n    if (s != 0)\n        errExitEN(s, \"pthread_create\");\n\n    /* Wait for threads to terminate */\n\n    s = pthread_join(t1, NULL);\n    if (s != 0)\n        errExitEN(s, \"pthread_join\");\n    s = pthread_join(t2, NULL);\n    if (s != 0)\n        errExitEN(s, \"pthread_join\");\n\n    printf(\"glob = %d\\n\", glob);\n    exit(EXIT_SUCCESS);\n}\n    `psem/thread_incr_psem.c`\n```", "```\n#include <semaphore.h>\n\nint `sem_destroy`(sem_t **sem*);\n```"]