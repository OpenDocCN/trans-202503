<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch7">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_130" aria-label="130"/>&#13;
<figure class="co-img"><img id="fig-pg130" class="img60" src="../images/pg130.jpg" alt="" width="687" height="1576"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-15.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_131" aria-label="131"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch7">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">COMPOUND STATEMENTS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">In this chapter, you’ll implement compound statements. Compound statements serve two important purposes. As you saw in the two previous chapters, they group together other statements and declarations into a single unit that can appear in a larger construct, like an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement. More interestingly, they also delineate the different <i>scopes</i> within a function. A variable’s scope is the part of the program where that variable can be used; when you declare a variable inside a compound statement, its scope extends only to the end of that statement.</p>&#13;
<p class="TX">We’ll spend a little time in this chapter extending the parser so we can group block items together, but our main task will be extending the variable resolution pass to keep track of each variable’s scope. We’ll barely <span role="doc-pagebreak" epub:type="pagebreak" id="pg_132" aria-label="132"/>change the TACKY generation stage, and we won’t touch the lexer or the assembly generation stage at all. Before starting on the parser, I’ll give a quick overview of how scoping works in C and define some terms that I’ll use later in the chapter.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-58"/><samp class="SANS_Futura_Std_Bold_B_11">The Scoop on Scopes</samp></h3>&#13;
<p class="TNI">A language construct that can contain declarations, and that determines the scope of those declarations, is called a <i>block</i>. Compound statements and function bodies are both blocks. So are loops, which we’ll implement in <span class="Xref-1"><a href="chapter8.xhtml">Chapter 8</a></span>. (Technically, <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements are too, but that doesn’t matter for our implementation.) A local variable’s scope begins at the point where that variable is declared. That means a variable’s scope can begin in the middle of a block. Its scope extends until the end of the block in which it was declared. For example, in the program</p>&#13;
<pre><code>int main(void) {&#13;
    int a <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> = 5;&#13;
    return a;&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span>}</code></pre>&#13;
<p class="BodyContinued">the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>’s scope begins right before its initializer <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and extends until the very end of the function <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">A compound statement can appear either on its own or inside another statement. In <a href="chapter7.xhtml#list7-1">Listing 7-1</a>, we use a compound statement as the body of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement.</p>&#13;
<a id="list7-1"/>&#13;
<pre><code>int main(void) {&#13;
    if (1) {&#13;
        int a <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> = 2;&#13;
        return a + 1;&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span>}&#13;
    return 0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: Using a compound statement as an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement body</samp></p>&#13;
<p class="TX">In this example, the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>’s scope runs from <span class="CodeAnnotation" aria-label="annotation1">❶</span> to the end of the compound statement <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">When you enter a new block, you can still use variables from the outer scope, as this code fragment illustrates:</p>&#13;
<pre><code>int a = 2;&#13;
{&#13;
    int b = a + 2;&#13;
}</code></pre>&#13;
<p class="TX">Although <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is declared in the outer scope, we can refer to it when we initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> in the inner scope. We therefore initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>. But let’s see what <span role="doc-pagebreak" epub:type="pagebreak" id="pg_133" aria-label="133"/>happens in <a href="chapter7.xhtml#list7-2">Listing 7-2</a>, where we declare another variable named <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> inside the inner block.</p>&#13;
<a id="list7-2"/>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> int a = 2;&#13;
{&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> int a = 3;&#13;
    int b = a + 2;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: Declaring two variables with the same name but different scopes</samp></p>&#13;
<p class="TX">This time, when we initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, two different variables named <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> are in scope: the one declared in the outer scope <span class="CodeAnnotation" aria-label="annotation1">❶</span> and the one declared in the inner scope <span class="CodeAnnotation" aria-label="annotation2">❷</span>. In cases like this, we always use the variable declared in the innermost scope. As a result, we initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>. Even though the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is still in scope, we can’t access it; it’s <i>hidden</i> (or <i>shadowed</i>) by the inner one.</p>&#13;
<p class="TX">Being hidden is different from being out of scope, because a hidden variable can become visible again later in the program. <a href="chapter7.xhtml#list7-3">Listing 7-3</a>, which is almost identical to <a href="chapter7.xhtml#list7-2">Listing 7-2</a>, illustrates this distinction.</p>&#13;
<a id="list7-3"/>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> int a = 2;&#13;
{&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> int a = 3;&#13;
    int b = a + 2;&#13;
}&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">❸</span> return a;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: A hidden variable becoming visible again</samp></p>&#13;
<p class="TX">As we saw in the previous example, the first declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> is hidden by the second declaration <span class="CodeAnnotation" aria-label="annotation2">❷</span>. But the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement <span class="CodeAnnotation" aria-label="annotation3">❸</span> comes after the end of the compound statement. At that point, the second <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is no longer in scope, so the first one is visible again. We’ll therefore use the first <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement, returning <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>.</p>&#13;
<p class="TX">What if we switched the order of the two statements in the inner block in <a href="chapter7.xhtml#list7-2">Listing 7-2</a>? Then we’d have:</p>&#13;
<pre><code>int a = 2;&#13;
{&#13;
    int b = a + 2;&#13;
    int a = 3;&#13;
}</code></pre>&#13;
<p class="TX">Now when we declare <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> isn’t in scope yet, so it doesn’t hide the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> will refer to the first declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, so we’ll initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>.</p>&#13;
<p class="TX">You can have many layers of nested scopes, as <a href="chapter7.xhtml#list7-4">Listing 7-4</a> demonstrates.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_134" aria-label="134"/>&#13;
<a id="list7-4"/>&#13;
<pre><code>int main(void) {&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> int x = 1;&#13;
    {&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> int x = 2;&#13;
        if (x &gt; 1) {&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> x = 3;&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> int x = 4;&#13;
        }&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> return x;&#13;
    }&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span> return x;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-4: Multiple nested scopes</samp></p>&#13;
<p class="TX">In this listing, we declare three variables named <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with three different scopes. We declare the first <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> at <span class="CodeAnnotation" aria-label="annotation1">❶</span> and the second at <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We assign the value <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> to the second <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> at <span class="CodeAnnotation" aria-label="annotation3">❸</span> and return it at <span class="CodeAnnotation" aria-label="annotation5">❺</span>, so the whole program returns <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>. The third variable named <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, declared at <span class="CodeAnnotation" aria-label="annotation4">❹</span>, is never used. We never reach the final <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement at <span class="CodeAnnotation" aria-label="annotation6">❻</span>, but if we did, it would return <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, the value of the very first variable named <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> that was declared back at <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">We need to handle two error cases related to variable scope. (We covered both of these briefly in <span class="Xref-1"><a href="chapter5.xhtml">Chapter 5</a></span>, but detecting them is a bit more complicated in programs with multiple scopes.) First, it’s illegal to use a variable name if no variable with that name is in scope. <a href="chapter7.xhtml#list7-5">Listing 7-5</a> illustrates this error.</p>&#13;
<a id="list7-5"/>&#13;
<pre><code>int main(void) {&#13;
    {&#13;
        int x <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> = 4;&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span>}&#13;
    return <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> x;&#13;
    int x <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> = 3;&#13;
<span class="CodeAnnotationHang" aria-label="annotation5">❺</span>}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-5: Using an undeclared variable</samp></p>&#13;
<p class="TX">In this listing, we declare two different variables named <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. The scope of the first declaration starts at <span class="CodeAnnotation" aria-label="annotation1">❶</span> and ends at <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The scope of the second declaration starts at <span class="CodeAnnotation" aria-label="annotation4">❹</span> and extends to the end of the function <span class="CodeAnnotation" aria-label="annotation5">❺</span>. Neither of these declarations is in scope at <span class="CodeAnnotation" aria-label="annotation3">❸</span>. It’s an error to use the variable name <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> at that point, because that name doesn’t refer to anything.</p>&#13;
<p class="TX">Second, you can’t have multiple declarations of the same variable name with the same scope. We say that two variables have the same scope if their scopes end at exactly the same point; that is, if they’re declared in the same block. For example, this code fragment is invalid:</p>&#13;
<pre><code>int a = 3;&#13;
{&#13;
    int b = a;&#13;
    int b = 1;&#13;
}</code></pre>&#13;
<p class="TX">The second declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is illegal because it has the same scope as the first declaration.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_135" aria-label="135"/>Now that you understand the scoping rules you need to implement, let’s start on the parser.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-59"/><samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp></h3>&#13;
<p class="TNI">A list of statements and declarations wrapped in braces can be either a function body or a compound statement. Let’s define a <samp class="SANS_TheSansMonoCd_W5Regular_11">block</samp> AST node to represent both constructs:</p>&#13;
<pre><code>block = Block(block_item*)</code></pre>&#13;
<p class="TX">Note that this AST node doesn’t represent <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements and won’t represent loops once we implement them in <span class="Xref-1"><a href="chapter8.xhtml">Chapter 8</a></span>, even though they’re technically also blocks.</p>&#13;
<p class="TX">Next, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp> node to represent compound statements:</p>&#13;
<pre><code>statement = Return(exp)&#13;
          | Expression(exp)&#13;
          | If(exp condition, statement then, statement? else)&#13;
<b>          | Compound(block)</b>&#13;
          | Null</code></pre>&#13;
<p class="TX">And we’ll change the <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp> node to use <samp class="SANS_TheSansMonoCd_W5Regular_11">block</samp> too:</p>&#13;
<pre><code>function_definition = Function(identifier name, <b>block </b>body)</code></pre>&#13;
<p class="TX"><a href="chapter7.xhtml#list7-6">Listing 7-6</a> gives the new AST definition with these changes bolded.</p>&#13;
<a id="list7-6"/>&#13;
<pre><code>program = Program(function_definition)&#13;
function_definition = Function(identifier name, <b>block</b> body)&#13;
block_item = S(statement) | D(declaration)&#13;
<b>block = Block(block_item*)</b>&#13;
declaration = Declaration(identifier name, exp? init)&#13;
statement = Return(exp)&#13;
          | Expression(exp)&#13;
          | If(exp condition, statement then, statement? else)&#13;
<b>          | Compound(block)</b>&#13;
          | Null&#13;
exp = Constant(int)&#13;
    | Var(identifier)&#13;
    | Unary(unary_operator, exp)&#13;
    | Binary(binary_operator, exp, exp)&#13;
    | Assignment(exp, exp)&#13;
    | Conditional(exp condition, exp, exp)&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or&#13;
                | Equal | NotEqual | LessThan | LessOrEqual&#13;
                | GreaterThan | GreaterOrEqual</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-6: The abstract syntax tree with compound statements</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_136" aria-label="136"/><a href="chapter7.xhtml#list7-7">Listing 7-7</a> shows the corresponding changes to the grammar.</p>&#13;
<a id="list7-7"/>&#13;
<pre><code>&lt;program&gt; ::= &lt;function&gt;&#13;
&lt;function&gt; ::= "int" &lt;identifier&gt; "(" "void" ")" <b>&lt;block&gt;</b>&#13;
<b>&lt;block&gt; ::= "{" {&lt;block-item&gt;} "}"</b>&#13;
&lt;block-item&gt; ::= &lt;statement&gt; | &lt;declaration&gt;&#13;
&lt;declaration&gt; ::= "int" &lt;identifier&gt; ["=" &lt;exp&gt;] ";"&#13;
&lt;statement&gt; ::= "return" &lt;exp&gt; ";"&#13;
              | &lt;exp&gt; ";"&#13;
              | "if" "(" &lt;exp&gt; ")" &lt;statement&gt; ["else" &lt;statement&gt;]&#13;
              <b>| &lt;block&gt;</b>&#13;
              | ";"&#13;
&lt;exp&gt; ::= &lt;factor&gt; | &lt;exp&gt; &lt;binop&gt; &lt;exp&gt; | &lt;exp&gt; "?" &lt;exp&gt; ":" &lt;exp&gt;&#13;
&lt;factor&gt; ::= &lt;int&gt; | &lt;identifier&gt; | &lt;unop&gt; &lt;factor&gt; | "(" &lt;exp&gt; ")"&#13;
&lt;unop&gt; ::= "-" | "~" | "!"&#13;
&lt;binop&gt; ::= "-" | "+" | "*" | "/" | "%" | "&amp;&amp;" | "||"&#13;
          | "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | "="&#13;
&lt;identifier&gt; ::= ? An identifier token ?&#13;
&lt;int&gt; ::= ? A constant token ?</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-7: The grammar with compound statements</samp></p>&#13;
<p class="TX">Remember that the <samp class="SANS_TheSansMonoCd_W5Regular_11">"{"</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">"}"</samp> in the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;block&gt;</samp> are literal braces, and <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and} indicate repetition. You can parse the updated grammar using the recursive descent techniques you’re already familiar with. When you’re parsing a <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;statement&gt;</samp> symbol, a <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>token will tell you that you’ve hit a compound statement, just like the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> keyword signals the beginning of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement and <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> signals the start of a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement.</p>&#13;
<aside class="box" aria-label="box-103"><p class="BoxTitle" id="box-103"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE PARSER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test the parser, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 7 --stage parse</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Your parser should successfully parse every test program in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_7/valid</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_7/invalid_semantics</samp><samp class="SANS_Futura_Std_Book_11">, and it should reject every test program in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_7/invalid_parse</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1" id="sec3"><span id="h1-60"/><samp class="SANS_Futura_Std_Bold_B_11">Variable Resolution</samp></h3>&#13;
<p class="TNI">Now we’ll update the variable resolution pass to follow the scoping rules we talked about at the start of the chapter. Any local variables that share the same name in the original program will receive different names during this pass. In later passes, we won’t have to think about scopes at all; because <span role="doc-pagebreak" epub:type="pagebreak" id="pg_137" aria-label="137"/>every variable will have a unique name, we can convert each variable in the AST to a TACKY variable, then a pseudoregister, and finally a memory address, exactly as we’ve done in earlier chapters, without worrying about which object each name refers to.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-45"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Resolving Variables in Multiple Scopes</samp></h4>&#13;
<p class="TNI">As an example, let’s take another look at the program from <a href="chapter7.xhtml#list7-4">Listing 7-4</a>:</p>&#13;
<pre><code>int main(void) {&#13;
    int x = 1;&#13;
    {&#13;
        int x = 2;&#13;
        if (x &gt; 1) {&#13;
            x = 3;&#13;
            int x = 4;&#13;
        }&#13;
        return x;&#13;
    }&#13;
    return x;&#13;
}</code></pre>&#13;
<p class="TX"><a href="chapter7.xhtml#list7-8">Listing 7-8</a> shows how this program looks after variable resolution.</p>&#13;
<a id="list7-8"/>&#13;
<pre><code>int main(void) {&#13;
    int x0 = 1;&#13;
    {&#13;
        int x1 = 2;&#13;
        if (x1 &gt; 1) {&#13;
            x1 = 3;&#13;
            int x2 = 4;&#13;
        }&#13;
        return x1;&#13;
    }&#13;
    return x0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-8: The program from <a href="chapter7.xhtml#list7-4">Listing 7-4</a> after variable resolution</samp></p>&#13;
<p class="TX">Now every variable has a different name. These new names make explicit which variable we’re using at every point. For example, it’s now clear that the variable declared at the start of the function (which we’ve renamed to <samp class="SANS_TheSansMonoCd_W5Regular_11">x0</samp>) is used only once, at the very end.</p>&#13;
<p class="TX">Our basic approach to variable resolution is the same as in earlier chapters. We’ll traverse the AST, maintaining a map from user-defined names to generated names as we go. But now our new scoping rules will dictate how we update this map. <a href="chapter7.xhtml#tab7-1">Table 7-1</a> shows how the variable map will look at each point in <a href="chapter7.xhtml#list7-4">Listing 7-4</a>.</p>&#13;
<p class="TT" id="tab7-1"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_138" aria-label="138"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 7-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">The Variable Map Throughout <a href="chapter7.xhtml#list7-4">Listing 7-4</a></samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table graybg TBF1" scope="col"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">int main(void) {</samp></p></th>&#13;
<th class="Basic-Table graybg TBF1" scope="col"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">(empty map)</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">    int x</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W5Regular_11">1;&#13;
    {</samp></code></pre></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <span class="symbol">→</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">x0</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">        int x</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W5Regular_11">2;&#13;
        if (x &gt; 1) {&#13;
            x</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W5Regular_11">3;</samp></code></pre></td>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <span class="symbol">→</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">x1</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">            int x</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W5Regular_11">4;&#13;
         }</samp></code></pre></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <span class="symbol">→</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">x2</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">        return x;&#13;
     }</samp></code></pre></td>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <span class="symbol">→</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">x1</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_Futura_Std_Book_11"> </samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">   return x;&#13;
}</samp></code></pre></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <span class="symbol">→</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">x0</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">The state of the variable map changes in two cases. First, when a new variable is declared, we add it to the map, overwriting any existing variable with the same name. Second, when we exit a block, we revert to the same variable map we had before entering that block.</p>&#13;
<p class="TX">The first case is already familiar: whenever we encounter a variable declaration, we’ll add a map entry. To handle the second case, we’ll make a copy of the variable map whenever we enter a new block. As we process that block, we’ll add new entries to that copy of the map, leaving the variable map for the outer scope unchanged.</p>&#13;
<p class="TX">Now that you have a basic idea of how this pass will work, let’s walk through the pseudocode.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-46"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating the Variable Resolution Pseudocode</samp></h4>&#13;
<p class="TNI">First, let’s process declarations. In earlier chapters, the compiler would fail if it ever saw two declarations of the same variable name:</p>&#13;
<pre><code>resolve_declaration(Declaration(name, init), variable_map):&#13;
    if name is in variable_map:&#13;
        fail("Duplicate variable declaration!")&#13;
<var>    --snip--</var></code></pre>&#13;
<p class="TX">But now things are a little more complicated. It’s legal to reuse the same variable name in multiple declarations. However, it’s illegal to declare the same variable name more than once <i>in the same block</i>. To enforce this rule, we’ll track two facts about each entry in the variable map: its new autogenerated name and whether it was declared in the current block. <a href="chapter7.xhtml#list7-9">Listing 7-9</a> gives the updated pseudocode to handle a declaration. Changes from the previous version of this pseudocode, in <span class="Xref-1"><a href="chapter5.xhtml#list5-9">Listing 5-9</a></span>, are bolded.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_139" aria-label="139"/>&#13;
<a id="list7-9"/>&#13;
<pre><code>resolve_declaration(Declaration(name, init), variable_map):&#13;
    if name is in variable_map <b>and variable_map.get(name).from_current_block:</b>&#13;
        fail("Duplicate variable declaration!")&#13;
    unique_name = make_temporary()&#13;
    variable_map.add(name, <b>MapEntry(new_name=unique_name, from_current_block=True)</b>)&#13;
    if init is not null:&#13;
        init = resolve_exp(init, variable_map)&#13;
    return Declaration(unique_name, init)</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-9: Resolving a variable declaration</samp></p>&#13;
<p class="TX">Next, we need a function that can process block items in order (I’ll call this <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_block</samp> in later pseudocode listings). You’ve already written this code to process function bodies; now you just need to refactor it so you can reuse it to process compound statements too. Remember that changes you make while processing one block item (specifically, a declaration) must be visible when you process later block items.</p>&#13;
<p class="TX">We’ll also update <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp> to handle compound statements. <a href="chapter7.xhtml#list7-10">Listing 7-10</a> gives the updated pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>, with changes from the previous version in <span class="Xref-1"><a href="chapter5.xhtml#list5-10">Listing 5-10</a></span> bolded. The important detail here is that we’ll pass a <i>copy</i> of the variable map when we traverse the compound statement, so any declarations we process inside the compound statement won’t be visible outside of it.</p>&#13;
<a id="list7-10"/>&#13;
<pre><code>resolve_statement(statement, variable_map):&#13;
    match statement with&#13;
    | Return(e) -&gt; return Return(resolve_exp(e, variable_map))&#13;
    | Expression(e) -&gt; return Expression(resolve_exp(e, variable_map))&#13;
<b>    | Compound(block) -&gt;</b>&#13;
<b>        new_variable_map = copy_variable_map(variable_map)</b>&#13;
<b>        return Compound(resolve_block(block, new_variable_map))</b>&#13;
    | <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-10: Resolving compound statements</samp></p>&#13;
<p class="TX">Finally, we’ll implement <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_variable_map</samp>. This should create a copy of the variable map with the <samp class="SANS_TheSansMonoCd_W5Regular_11">from_current_block</samp> flag set to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> for every entry. That way, we won’t throw an error when we process declarations in the inner scope that hide declarations from the outer scope.</p>&#13;
<p class="TX">Once you’ve made those changes, your variable resolution pass will be able to handle nested scopes!</p>&#13;
<aside class="box" aria-label="box-104"><p class="BoxTitle" id="box-104"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE VARIABLE RESOLUTION PASS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">The variable resolution pass should accept every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_7/valid</samp> <samp class="SANS_Futura_Std_Book_11">and reject every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_7/invalid_semantics</samp><samp class="SANS_Futura_Std_Book_11">. To test it out, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 7 --stage validate</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">You might also want to write your own tests to make sure variables are renamed consistently.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_140" aria-label="140"/>&#13;
<h3 class="H1" id="sec6"><span id="h1-61"/><samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp></h3>&#13;
<p class="TNI">The last step is extending the TACKY generation stage to handle compound statements. It’s pretty straightforward: to convert a compound statement to TACKY, just convert each block item inside it to TACKY. Basically, you should handle compound statements exactly like you’re already handling function bodies. You don’t need to touch later compiler stages at all; once you have TACKY generation working, you’re done with the chapter!</p>&#13;
<aside class="box" aria-label="box-105"><p class="BoxTitle" id="box-105"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out the whole compiler, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 7</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1" id="sec7"><span id="h1-62"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">In this chapter, you implemented a new kind of statement by extending just a few stages in your compiler. You wrote a more sophisticated variable resolution pass that correctly resolves variables in multiple scopes, dramatically expanding the set of programs you can compile. Next, you’ll implement loops, <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statements, and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements. The work you did in this chapter will be especially important when you add support for <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops, since a single <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop contains two distinct scopes.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>