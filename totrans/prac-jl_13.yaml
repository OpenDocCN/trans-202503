- en: '**11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BIOLOGY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '*Modern biology is becoming very much a branch of information technology.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: —Richard Dawkins
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: As Professor Dawkins points out, computation has become a central tool in many
    areas of biology. This was perhaps inevitable, as evolution is the central organizing
    principle of biology, and evolution occurs through the transmission of information
    in the form of a digital storage device known as DNA.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: The biology ecosystem around Julia is sophisticated, wide-ranging, and growing
    rapidly. The language and its packages are being used in many areas of biological
    and medical research, in both industry and academia.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: This chapter begins with a brief overview of the Julia biology landscape and
    proceeds directly to a detailed case study in simulated evolution.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '**The Julia Biology Ecosystem**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bioinformatics has become a major subfield of biology that is defined by the
    use of computers. It mainly deals with the analysis and manipulation of protein
    sequences, so it has a strong computational linguistics flavor. The BioJulia GitHub
    organization provides a starting place for browsing this large collection of packages.
    It includes, among others, modules for handling the various file types that bioinformaticians
    have devised over the years.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: To discover other Julia packages outside of the bioinformatics organization,
    we can turn to the general GitHub search methods described in “How to Find Public
    Packages” on [page 80](ch03.xhtml#ch03lev1sec14). Many of these packages do not
    include general tags such as “biology,” so you can find them more easily with
    focused searches using terms such as *phylogenetics* or *ecology*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The `Pumas` pharmaceutical modeling and simulation toolkit merits particular
    mention as a major success story for Julia in medicine and biology. `Pumas` is
    used by major corporations and research groups to develop and test drugs. Its
    GitHub page contains links to extensive documentation and tutorials.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Many Julia biology packages were created to work with other packages in the
    areas of statistics, equation solving, or other areas useful in mathematical biology.
    An example is `EvolutionaryModelingTools`, which works with the `DifferentialEquations`
    package (see “Combining DifferentialEquations with Measurements” on [page 302](ch09.xhtml#ch09lev1sec20)),
    providing macros to assist in setting up problems that use Gillespie’s algorithm
    (a method for attacking stochastic differential equations) in the simulation of
    models of infectious disease propagation and problems with a similar structure.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '**Simulating Evolution with Agent-Based Modeling**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Agent-based modeling (ABM)* is a simulation technique using a community of
    computational entities, the *agents*, interacting with each other and their environment
    through a set of *rules*. The agents may be representations of life forms, vehicles,
    or something more abstract, such as information. The rules can depend on time,
    the distance between agents, their movement, the state of the environment near
    the agent, or nearly anything else we can imagine. Agents may move, store data,
    die, and be born. The environment itself can change as well.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于代理的建模 (ABM)* 是一种模拟技术，通过一群计算实体——*代理*——彼此与环境进行交互，遵循一组*规则*。这些代理可以是生命形式、车辆或更抽象的事物，如信息。规则可以依赖于时间、代理之间的距离、它们的运动、代理附近环境的状态，或者我们能想象的几乎任何其他因素。代理可能会移动、存储数据、死亡并诞生。环境本身也可能发生变化。'
- en: Researchers have used ABM to simulate traffic flow, the progress of infectious
    diseases, the collective behavior of social animals, the spread of opinions, and
    much more. See “Further Reading” on [page 380](ch11.xhtml#fur11) for some links
    to background information about this approach, and to documentation of the main
    packages used in this section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员已使用ABM模拟交通流、传染病的进展、社会动物的集体行为、舆论的传播等等。请参见[第380页](ch11.xhtml#fur11)中的“进一步阅读”，获取一些关于这种方法的背景信息链接，以及本节所使用的主要包的文档。
- en: Our project will be the simulation of evolution through natural selection in
    a population of two types of simple creatures representing predators and prey.
    We will see how the prey creatures, when allowed to inherit their “genes” from
    their parents, evolve to be better at evading their predators. This evolution
    results from random mutations in the inherited characteristics combined with the
    selection pressure from the predators eating the less evasive prey before they
    have a chance to reproduce.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目将模拟自然选择过程中的进化，模拟一个由两种简单生物组成的种群，这些生物代表捕食者和猎物。我们将看到，当猎物生物允许从父母那里继承它们的“基因”时，它们如何进化得更擅长躲避捕食者。这种进化源于遗传特征的随机突变，加上捕食者从吃掉不善于躲避的猎物开始施加的选择压力，迫使它们在繁殖前被捕食。
- en: The `Agents` package provides a framework for a wide variety of ABM calculations.
    It attends to the lower-level details, such as calculating the motions of agents,
    enforcing boundary conditions, and searching for neighbors, allowing us to concentrate
    on programming the rules for agent interaction at a fairly high level.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Agents`包提供了一个框架，用于各种ABM计算。它处理低级别的细节，如计算代理的运动、执行边界条件和查找邻居，从而使我们能够专注于在较高层次上编程代理交互的规则。'
- en: The space in which the agents live can be a continuous physical space (the one
    we will use here); a grid space on which agents can only occupy discrete positions;
    a more abstract tree space, in which agents are not located physically, but within
    a tree data structure; and even a space defined on an actual road map, using OpenStreetMap
    data. The space can become an environment containing spatially and temporally
    varying conditions affecting the agents.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 代理所处的空间可以是一个连续的物理空间（我们在这里使用的空间）；一个网格空间，代理只能占据离散的位置；一个更抽象的树形空间，其中代理并不物理存在，而是存在于树状数据结构中；甚至是一个基于实际道路地图定义的空间，使用OpenStreetMap数据。这个空间可以变成一个环境，包含空间和时间变化的条件，影响代理的行为。
- en: The agents have position and velocity properties and a unique ID. We can endow
    them, as well, with any data structures convenient for our simulation. We can
    create or destroy agents, or change any of their properties, based on their proximity
    to other agents, on time, or on environmental conditions. Agent proximity—nearest
    neighbors or neighbors within a given radius—is returned by a simple function
    call.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代理具有位置、速度属性以及唯一的ID。我们还可以赋予它们任何适合我们模拟的数据结构。我们可以基于代理之间的接近程度、时间或环境条件来创建或销毁代理，或者更改它们的任何属性。代理的接近性——最近的邻居或在给定半径内的邻居——可以通过简单的函数调用返回。
- en: Any particular project typically will make use of only a small subset of `Agents`’s
    capabilities, and this section’s project is no exception.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 任何特定项目通常只会使用`Agents`的一个小子集功能，本节的项目也不例外。
- en: '**Overview of the Simulation Problem**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**模拟问题概述**'
- en: 'Our universe will contain two types of creatures: predators and prey. Each
    type has a simple behavior. Predators chase prey. If a predator manages to get
    very close to its target, it vanishes from the simulation, devoured by its pursuer.
    The predators choose their targets from among all those within their detection
    range, but they are polite: they won’t chase prey that one of their colleagues
    is already chasing. Predators have only one speed, which is somewhat faster than
    the one speed with which the prey are able to run. They turn toward their prey
    as they chase them, but their superior speed is offset by limited agility: they
    can turn only through some maximum angle at every simulation step. Like some actual
    predator species, our simulated predators adjust their reproductive rate to maintain
    a certain ratio of predator population to prey population.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的宇宙将包含两种类型的生物：捕食者和猎物。每种类型都有简单的行为。捕食者追赶猎物。如果捕食者成功接近目标，它会从模拟中消失，被追捕者吞噬。捕食者从所有处于其探测范围内的猎物中选择目标，但它们很有礼貌：如果同伴已经追捕某个猎物，它们不会再追赶那个猎物。捕食者只有一个速度，稍微快于猎物的速度。它们在追赶猎物时会转向目标，但它们的高速度被有限的灵活性所抵消：它们每次模拟步骤只能转动一定的最大角度。像某些实际的捕食者物种一样，我们的模拟捕食者会调整它们的繁殖率，以保持捕食者种群与猎物种群的比例。
- en: The prey make turns at regular intervals according to a list of angles; each
    prey creature has its own list. When it reaches the end of the list, it goes back
    to the top. Prey don’t react to predators, they simply run around making their
    prescribed turns. One can imagine that their environment is rich with uniformly
    distributed food, as a property (which is called `mojo` in the program) gets incremented
    by a fixed amount at every step. If a prey creature manages to reach a predetermined
    amount of `mojo` without getting eaten, it reproduces. Reproduction is fatal;
    the creature is replaced by two descendants. Each descendant inherits a copy of
    its parent’s table of angles, with some random mutations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 猎物按照一组角度在固定的时间间隔内转弯；每个猎物有自己的一组角度。当它到达列表的末尾时，它会回到列表的顶部。猎物不会对捕食者做出反应，它们只是按照预定的角度转弯四处奔跑。可以想象，它们的环境充满了均匀分布的食物，因为一个属性（在程序中称为`mojo`）在每一步都会增加一个固定的量。如果猎物在不被吃掉的情况下成功地积累了一定数量的`mojo`，它就会繁殖。繁殖是致命的；这个生物会被两个后代所取代。每个后代继承其父母的角度列表，并带有一些随机突变。
- en: The only property that distinguishes different prey individuals, aside from
    their locations and velocities, is the list of angles. We initialize the agents
    with a random list, uniformly distributed from –*π* to *π*. Some lists of turns
    will, by chance, be slightly better than others in allowing the agent to survive
    longer, as they will, on average, make it more difficult for the predators, with
    their limited agility, to catch it. These agents will be more likely to reproduce,
    as will their children. Through mutation, some of these children may be even more
    likely to survive to reproduce. We hope to observe an evolution in the distribution
    of angles in the prey population, and an average increase in the ability to evade
    predation, as a result of this selection pressure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 区分不同猎物个体的唯一特性，除了它们的位置和速度，就是角度列表。我们以一个随机列表初始化这些代理，列表中的角度均匀分布在–*π*到*π*之间。某些转弯列表由于偶然的原因，可能比其他列表更适合让代理生存得更久，因为它们会使捕食者由于有限的灵活性而更难以抓住猎物。这些代理更有可能繁殖，正如它们的后代一样。通过突变，这些后代中的一些可能比其他后代更有可能生存下来并繁殖。我们希望观察到猎物种群中角度分布的演化，以及由于这种选择压力，避免被捕食的能力的平均提高。
- en: The foregoing is an overview of the structure and aims of the project. In the
    next few sections, we’ll put together all the components of our simulation, in
    the order in which they appear in the complete program, which is assembled for
    convenience in the code section of the web supplement for this chapter at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org).
    When turning these ideas into a program, we’ll have to make everything concrete.
    For example, we’ll decide to make the list of angles contain eight elements. Many
    of these details are, within limits, arbitrary, and the reader might experiment
    with altering all or some of them, and perhaps improve upon the experiment described
    here.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容是该项目的结构和目标概述。在接下来的几个部分，我们将按照在完整程序中出现的顺序，将所有的模拟组件拼接在一起，完整程序方便地汇总在本章节的网页补充材料中，网址为[*https://julia.lee-phillips.org*](https://julia.lee-phillips.org)。在将这些思想转化为程序时，我们需要将一切具体化。例如，我们决定让角度列表包含八个元素。这些细节在一定范围内是任意的，读者可以尝试更改其中的全部或部分，甚至可能改进此处描述的实验。
- en: '**The Predator and Prey Agents**'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**捕食者和猎物代理**'
- en: 'The `Agents` package provides a convenient macro for defining our agents:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Agents` 包提供了一个便捷的宏来定义我们的代理：'
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First we import the needed packages. In addition to `Agents`, we need `StatsBase`
    for creating histograms of the angle distributions, `JLD2` for saving and loading
    simulation data (see [Listing 9-4](ch09.xhtml#ch9lis4) on [page 289](ch09.xhtml#ch9lis4)),
    and `Random` for random numbers (see “Random Numbers in Julia” on [page 307](ch10.xhtml#ch10lev2)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的包。除了`Agents`，我们还需要`StatsBase`来创建角度分布的直方图，`JLD2`来保存和加载模拟数据（参见[列表 9-4](ch09.xhtml#ch9lis4)，[第289页](ch09.xhtml#ch9lis4)），以及`Random`用于生成随机数（参见《Julia中的随机数》[第307页](ch10.xhtml#ch10lev2)）。
- en: The `@agent` macro defines the agents as composite types. After executing the
    macros in the listing, we have an agent type called `Prey` and another called
    `Predator`. The `ContinuousAgent{2}` notation means that the agents are destined
    to live in a continuous, two-dimensional space, where their positions are defined
    by a tuple of two floating-point numbers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`@agent`宏将代理定义为复合类型。在执行列表中的宏后，我们有了一种名为`Prey`的代理类型，和另一种名为`Predator`的代理类型。`ContinuousAgent{2}`表示这些代理将在一个连续的二维空间中生活，其中它们的位置由一个包含两个浮点数的元组定义。'
- en: 'Each instance of `Prey` is endowed with two properties: `mojo`, the float that
    will determine when it’s ready to reproduce; and `moves`, its vector of angles
    that determines the path it takes as it wanders blindly through the environment.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Prey`实例都拥有两个属性：`mojo`，它是一个浮动值，用来决定猎物何时准备好繁殖；以及`moves`，它是一个角度向量，决定猎物在环境中盲目徘徊时的路径。
- en: 'A predator has only one property: `victim` will be the ID of the individual
    prey that it’s chasing. If this is 0, it’s sitting still and waiting for a potential
    victim to wander within range.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 捕食者只有一个属性：`victim`，它是捕食者正在追逐的猎物的ID。如果该值为0，则捕食者静止不动，等待潜在猎物进入其范围。
- en: '***Constants Defining Model Behavior***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义模型行为的常量***'
- en: Certain parameters determining model behavior are defined in a list of constants,
    shown in [Listing 11-1](ch11.xhtml#ch11lis1). We can alter these constants to
    experiment with evolution under different conditions without making changes to
    the program. These are declared `const`, a declaration we should apply to all
    global quantities in the interests of performance. In general, a program should
    not use non-`const` global variables.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 决定模型行为的某些参数在一系列常量中定义，如[列表 11-1](ch11.xhtml#ch11lis1)所示。我们可以修改这些常量，以便在不同条件下进行进化实验，而无需更改程序。这些常量被声明为`const`，我们应当对所有全局变量应用此声明，以提高性能。一般来说，程序不应使用非`const`的全局变量。
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 11-1: Constants defining the model*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-1：定义模型的常量*'
- en: The predator population adjusts itself at every step to maintain the `PPR`,
    adding predators if needed and eliminating them if the ratio is more than 5 percent
    too large.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 捕食者种群会在每一步进行调整，以保持`PPR`，根据需要增加捕食者，若比例超过5%则会消除部分捕食者。
- en: The parameter `M` is the length of the vector of angles that amounts to the
    prey’s genome. The prey will proceed in a straight line for `SBT` steps before
    turning through the next angle in the angle vector.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`M`是代表猎物基因组的角度向量的长度。猎物将在直线前进`SBT`步，然后转向角度向量中的下一个角度。
- en: A predator can “see” a prey creature if it’s closer than the distance `TAD`.
    It begins chasing the first such prey that it sees that is not already being chased.
    If a predator manages to close the distance to its target to within `KD`, the
    target is eliminated.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: When a prey creature reproduces, it replaces itself with `LS` descendants.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The prey creatures eat continuously as they run, increasing their `mojo` by
    `MIPS` every step. The `mojo` is really just a measure of how long a creature
    has survived. Once a prey creature’s `mojo` has reached `MNFR`, it reproduces.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The predator’s straight-line speed is `SPEEDR` times the prey’s speed. The predator’s
    ability to corner is limited by `LAA`. It turns in the direction of the prey,
    adjusting its heading at every step, but can turn no more than `LAA` radians each
    time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The `Agents` integration routine (a simple Euler step) uses a timestep of `dt`.
    This constant serves as an overall scale for agent speeds.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: In order to be able to repeat simulations using identical sequences of random
    numbers, and to create ensembles of simulations when desired, we’ll use a random
    number generator with a seed that we can control (see “Random Numbers in Julia”
    on [page 307](ch10.xhtml#ch10lev2)). This is the purpose of `SEED` and the `rng`.
    Also, the `rand()` functions are somewhat more efficient when passed an `rng`,
    although this concern is not as acute as it has been in some past versions of
    Julia and the `Random` package.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '***Utility Functions***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’d like to have a few functions to make the code that orients the predators
    and changes the direction of the prey more concise:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We’re going to need to normalize velocity vectors, which means adjusting their
    lengths to unity. This is what `vnorm()` does. The `angle_between()` function
    returns the angle between two vectors. The predators need this to calculate where
    to turn when chasing their food. And turning, both of predators and prey, relies
    on `turn()`, which, when supplied with a starting vector and an angle, returns
    the vector rotated through the angle.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we need a function to mutate the `moves` table. Without this,
    no evolution takes place:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This makes a random change to a specified number of the angles in the table
    by an angle uniformly distributed from –*π*/4 to *π*/4.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '***Model Initialization***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every `Agents` simulation requires, in addition to the agents themselves, three
    data structures:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `arena` is the space in which the agents live and interact. Our space will
    be continuous, have coordinates running from 0 to 1 along each dimension, and
    have periodic boundary conditions. This makes the space infinite in the sense
    that an agent running off the right side will reemerge on the left side.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The `properties` is a dictionary of quantities relating to the simulation as
    a whole. In our simulation we use it just to keep track of how many steps have
    passed. For keeping track of when it’s time for the prey to make a turn, we use
    `stepno` and increment `total_step` at each step. The former could be derived
    from the latter, but maintaining the two counters can be convenient when restarting
    a simulation from a saved state. We initialize both counters to 0.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`properties`是一个与整个仿真相关的数量字典。在我们的仿真中，我们用它来跟踪已过的步骤数。为了跟踪何时是猎物转弯的时间，我们使用`stepno`，并在每一步时增加`total_step`。前者可以从后者中推导出来，但在从保存的状态重新启动仿真时，维护两个计数器会很方便。我们将这两个计数器初始化为0。'
- en: With these two objects in place we can initialize the `model`, which maintains
    the whole simulation state. Checkpointing and restarting the simulation requires
    merely saving the `model` to disk. The two positional arguments of its constructor
    are the agent types and the space. If we had only one type of agent, the call
    would look like `ABM(Prey, arena; properties)`, for example.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个对象，我们可以初始化`model`，它维护整个仿真状态。检查点和重启仿真仅需要将`model`保存到磁盘。它的构造函数的两个位置参数分别是代理类型和空间。如果我们只有一种类型的代理，调用的方式将像`ABM(Prey,
    arena; properties)`，例如。
- en: We choose `properties` for the name of the property dictionary because that
    name is used for a keyword in the model constructor, which makes the call to `ABM`
    simpler (see “Concise Syntax for Keyword Arguments” on [page 154](ch06.xhtml#ch06lev1sec1)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择`properties`作为属性字典的名称，因为该名称在模型构造函数中用作关键字，这使得调用`ABM`更加简洁（参见“关键字参数的简洁语法”在[第154页](ch06.xhtml#ch06lev1sec1)）。
- en: '**NOTE**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*With the version of* Agents *used at the time of writing, we get a warning
    after constructing the model this way. The message warns us about a potential
    inefficiency when using a* Union *of agent types. This is an area of ongoing development
    effort, and the warning will probably disappear in future versions. The inefficiency
    doesn’t actually become a problem unless we use more than three agent types.*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*在写作时使用的* Agents *版本中，在这种方式下构建模型后，我们会收到一个警告。消息警告我们在使用代理类型的* Union *时可能会出现效率低下的问题。这是一个正在进行中的开发领域，警告可能会在未来版本中消失。除非我们使用超过三种代理类型，否则这个效率问题实际上并不会成为问题。*'
- en: 'With `model` defined, we can initialize it by adding the agents:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了`model`后，我们可以通过添加代理来初始化它：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `add_agent!()` function is named using an exclamation point to remind us
    that it mutates one of its arguments: it alters `model` by adding agents to it.
    This function creates an agent at a random position within the `arena`. It expects
    an agent type as a first argument, the model in the second position, and a tuple
    giving the agent’s initial *x* and *y* velocities. Positional arguments following
    the third are passed to the agent constructor. Therefore, in the first loop, each
    `add_agent!()` call will create a `Prey` instance using `Prey(0.0, moves)`. The
    initial `mojo` is set to 0, and the starting vector of angles is randomly set
    ➊.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_agent!()`函数的命名使用了感叹号，提醒我们它会修改其中一个参数：它通过向`model`中添加代理来改变它。此函数在`arena`中随机位置创建一个代理。它期望第一个参数为代理类型，第二个为模型，第三个参数为一个元组，指定代理的初始*x*和*y*速度。第三个位置之后的其他位置参数将传递给代理构造函数。因此，在第一次循环中，每个`add_agent!()`调用都会使用`Prey(0.0,
    moves)`创建一个`Prey`实例。初始的`mojo`设置为0，起始角度向量随机设置 ➊。'
- en: '**Functions to Extract Information from the Model**'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从模型中提取信息的函数**'
- en: Let’s look at some more short utility functions that accept the `model` as an
    argument and return information about its current state. We’ll use some of them
    in the calculation and others to extract data that we’ll store and use later when
    we analyze the results.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些接受`model`作为参数并返回其当前状态的短小实用函数。我们将在计算中使用其中一些函数，并用其他的来提取数据，之后在分析结果时存储并使用它们。
- en: 'First we’ll need functions to give us a vector of all the prey or predators
    in the system:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些函数来返回系统中所有猎物或捕食者的向量：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Inside the list comprehensions we use the `allagents()` function, which creates
    an iterator over the agents of a model.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表推导式内部，我们使用了`allagents()`函数，它创建了一个迭代器，用于遍历模型中的代理。
- en: 'The following suggestively named functions simply call the ones just shown
    and return the lengths of the agent vectors:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下这些富有提示性的函数只是调用了前面展示的函数，并返回代理向量的长度：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since the predators do not compete for prey with their colleagues, they need
    to know if a potential meal is already under pursuit:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于捕食者之间不会争夺猎物，它们需要知道潜在的猎物是否已经被追捕：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function returns a vector of all the `ID`s of prey creatures that are marked
    as victims by some predator. In order to determine if a potential meal is not
    already being chased, a predator checks whether its `ID` is in this list.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回一个包含所有被某些捕食者标记为受害者的猎物生物 `ID` 的向量。为了判断潜在的猎物是否已经被追捕，捕食者会检查其 `ID` 是否在该列表中。
- en: As mentioned earlier, we expect the vectors of angles to evolve. One way to
    get an overview of this process is to observe the evolution of the distribution
    of angles in the population (see “Distributions” on [page 321](ch10.xhtml#ch10lev7)
    for an overview of the concept of a distribution).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们期望角度向量会发生变化。了解这一过程的一个方法是观察群体中角度分布的演变（有关分布概念的概述，请参见 [第 321 页](ch10.xhtml#ch10lev7)的“分布”）。
- en: 'The following function gathers all the angles in all the `moves` vectors from
    all the prey creatures and returns a `Histogram` data structure representing a
    binning of the distribution into 40 equal buckets. We can then normalize and plot
    the results at various timesteps to analyze one aspect of the simulation:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数收集所有捕食者的 `moves` 向量中的所有角度，并返回一个 `Histogram` 数据结构，表示将分布划分为 40 个相等的桶。然后，我们可以在不同的时间步对结果进行归一化并绘制图表，以分析仿真的一个方面：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function, and its use of `fit()` and the `Histogram` data structure, are
    the reason we imported the `StatsBase` package. The pattern in the comprehension
    in the second line, with its two `for` loops, is a common way to flatten a collection
    of collections.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数及其对 `fit()` 和 `Histogram` 数据结构的使用，是我们导入 `StatsBase` 包的原因。第二行中的推导式模式，带有两个
    `for` 循环，是扁平化一组集合的常见方法。
- en: '***Stepping Through the Simulation***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过仿真步进***'
- en: The `agent_step!()` and `model_step!()` functions are at the core of any `Agents`
    simulation. At every timestep, the `agent_step!()` function updates each agent
    as it’s selected by the *scheduler*. This update can include moving the agent,
    changing its velocity, altering the values of its properties, or anything else
    that makes sense to apply to individual agents. The scheduler is the component
    of the calculation that selects which agents to update and in what order. In most
    `Agents` simulations, we can leave the order unspecified; allowing the scheduler
    to update the agents in an arbitrary order is the fastest option.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`agent_step!()` 和 `model_step!()` 函数是任何 `Agents` 仿真中的核心。在每个时间步，`agent_step!()`
    函数会在 *调度器* 选中代理时更新该代理。这个更新可以包括移动代理、改变其速度、修改其属性值，或者对单个代理应用其他任何合理的变化。调度器是计算的一个组成部分，负责选择哪些代理需要更新以及更新的顺序。在大多数
    `Agents` 仿真中，我们可以不指定顺序；允许调度器以任意顺序更新代理是最快的选择。'
- en: After the `agent_step!()` function comes (by default) the `model_step!()` function,
    which makes updates that apply to the model as a whole. This includes updates
    that require access to the entire agent population, including those that search
    for near neighbors.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `agent_step!()` 函数之后（默认情况下）是 `model_step!()` 函数，该函数会执行对整个模型的更新。这包括需要访问整个代理群体的更新内容，例如那些寻找邻近代理的更新。
- en: The `agent_step!()` function is required, but `model_step!()` is optional; our
    calculation uses both. Also, there is an option to perform `model_step!()` before
    `agent_step!()` if the calculation needs that.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`agent_step!()` 函数是必需的，但 `model_step!()` 是可选的；我们的计算同时使用了这两者。此外，如果计算需要，也可以在
    `agent_step!()` 之前执行 `model_step!()`。'
- en: '**Stepping the Agents**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**代理步进**'
- en: 'The following shows the entire function for updating both predator and `Prey`
    agents:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更新捕食者和 `猎物` 代理的整个函数：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `agent_step!()` function (which can be named anything, but we’ve used the
    conventional name) must accept `agent` and `model` as arguments. The scheduler
    passes each agent in turn to the function as it cycles through them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`agent_step!()` 函数（可以命名为任何名称，但我们使用了传统名称）必须接受 `agent` 和 `model` 作为参数。调度器会依次将每个代理传递给该函数，随着它对代理的轮流操作。'
- en: The first line moves the agent by an amount determined through the timestep,
    `dt`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行通过时间步 `dt` 确定的量来移动代理。
- en: We then kill off any `Prey` agents that have been caught by the predators that
    are chasing them, where “caught” means that the distance between them has become
    less than `KD`. We use `euclidean_distance()`, a function built into the package,
    to measure this distance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们消除任何被捕食者追逐的`Prey`代理，这里的“被捕获”意味着它们之间的距离小于`KD`。我们使用包内的`euclidean_distance()`函数来衡量这个距离。
- en: After the meal, the predator waits, stationary ➊, for another available prey
    to come within range.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 吃完饭后，捕食者静止不动➊，等待另一只猎物进入攻击范围。
- en: 'If the prey is too far away to eat, we continue the chase by turning toward
    it. The first step is finding the current angle between the predator’s velocity
    vector and the vector between the positions of the predator and its prey. Fortunately,
    `Agents` comes with a function just for this: `get_direction()`. In calling this
    function, we use two additional features of the `model`: an agent’s position tuple
    is available as `agent.pos`, and `model[i]` returns the agent with `ID i`. Although
    `model`s aren’t arrays, the `Agents` package defines a `getindex()` method that
    enables this. After limiting the turning angle ➋ to the predator’s agility, set
    with the constant `LAA`, we update its velocity.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果猎物距离太远无法吃掉，我们通过转向继续追逐。第一步是找到捕食者速度向量与捕食者与猎物位置之间的向量之间的当前角度。幸运的是，`Agents`包提供了一个专门的函数：`get_direction()`。调用此函数时，我们使用了`model`的两个附加特性：一个代理的位置元组可以通过`agent.pos`获得，`model[i]`返回具有`ID
    i`的代理。虽然`model`不是数组，但`Agents`包定义了一个`getindex()`方法来支持这一点。在将转向角度限制到捕食者的灵活性，即常数`LAA`之后，我们更新它的速度。
- en: 'We then check for any sufficiently close eligible prey: any `Prey` agent within
    a distance `TAD` that’s not already being chased. If we find one, we set the predator’s
    velocity vector to point toward the prey, again using `get_direction()` ➌.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查是否有任何足够接近的可追捕猎物：任何距离`TAD`以内且尚未被追逐的`Prey`代理。如果找到了，我们将捕食者的速度向量指向猎物，再次使用`get_direction()`
    ➌。
- en: Turning to the prey creatures, first we check if they have accumulated enough
    `mojo` to reproduce. Those who have enough give birth to `LS` copies, which are
    then mutated. We kill off the parent using the `kill_agent!()` function ➍, which
    is part of the `Agents` package.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 转向猎物时，我们首先检查它们是否积累了足够的`mojo`以进行繁殖。那些有足够`mojo`的会繁殖出`LS`个副本，然后这些副本会发生突变。我们使用`kill_agent!()`函数
    ➍杀死父体，这是`Agents`包的一部分。
- en: When it’s time to make a turn, we rotate the velocity using our `turn()` function.
    We need to convert the result to a `Tuple` ➎ because the package uses those to
    store agent velocities.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要转向时，我们使用`turn()`函数旋转速度。由于该包使用元组来存储代理的速度，我们需要将结果转换为`Tuple` ➎。
- en: 'After making the turn, we rotate the agent’s private turn table with a function
    that we’re using for the first time: `circshift()`, which rotates an array. This
    invocation rotates the `moves` vector to the left, so its second element becomes
    its first and its first becomes its last. The outcome is that the prey makes the
    `M` turns stored in `moves` repeatedly (if it survives long enough to do so).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 转向后，我们使用一个首次使用的函数`circshift()`来旋转代理的私人转向表，这个函数可以旋转数组。这个调用将`moves`向量向左旋转，使其第二个元素成为第一个，第一个元素成为最后一个。结果是猎物会重复做`moves`中存储的`M`次转向（如果它足够活跃的话）。
- en: '**Stepping the Model**'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**模型步进**'
- en: 'After the scheduler updates all the agents, it calls this function, passing
    the model as an argument:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在调度器更新所有代理后，它调用此函数，并将模型作为参数传递：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First we increment `model_step`, using modular arithmetic to maintain a cycle
    of length `SBT`; then we increment the total step. Since `total_step`, as well
    as its other properties, is stored along with the model, we can checkpoint and
    seamlessly restart the simulation by using `JLD2` to save and reload the model,
    and `total_step` will keep track of how long it’s been run.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们增加`model_step`，使用模算术来保持长度为`SBT`的循环；然后我们增加总步数。由于`total_step`及其其他属性与模型一起存储，我们可以通过使用`JLD2`保存并重新加载模型来进行检查点并无缝重启仿真，同时`total_step`将跟踪运行了多久。
- en: 'We maintain the predator/prey ratio specified with `PPR` by adding or removing
    predators as needed. The `add_agent()` function from `Agents` adds an agent at
    a random position. The tuple in the argument list is its initial velocity, and
    subsequent arguments are passed to the agent constructor. In this case, there
    is only one such argument: the initial `victim` property is set to 0.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: We remove agents by passing a random agent to `kill_agent()` using the function
    `random_agent()` ➊. This `Agents` function takes, in its optional second argument,
    a function expressing a condition that the potentially doomed agent must satisfy.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the routine maintains a logfile, writing an entry every `LI` steps.
    We `flush()` the logfile so that we can take a look at it while the simulation
    is running. Without this call, the file may not be written until the calculation
    ends.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Simulation***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `run!()` function is `Agents`’s basic facility for stepping through a model,
    as shown in [Listing 11-2](ch11.xhtml#ch11lis2). Its four positional arguments
    are the model, the function for updating the agents, the optional function for
    updating the model, and the total number of steps.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 11-2: Running the simulation*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'It returns two dataframes (see “CSV Files” on [page 332](ch10.xhtml#ch10lev1sec6)):
    one for the agents and one for the model. The `adata` keyword argument is a `Vector`
    of quantities to include in the agent dataframe, and the `mdata` keyword argument
    is for the model dataframe. These quantities can be agent or model properties,
    which become symbols, or functions of the `model`. In the value for `mdata`, we’re
    using three functions that we defined with this in mind: we’re keeping track of
    the two population sizes and the angle distribution.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: We’ve wrapped `run!()` in a function that calls it `nruns` times, each time
    asking it to run the model for `nsteps_per_run` steps, and uses the save function
    from `JLD2` to store the model dataframe and the entire model to disk.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: To load the model from its saved version on disk, we can enter
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: where the string argument specifies the variable to be loaded from the file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '***Visualizing System Behavior***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The most convenient way to get a snapshot of the model at any time, or to create
    an animation of its progress, is to use two functions provided by the `InteractiveDynamics`
    package, which needs a separate import:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We need to import a `Makie` library as well because `InteractiveDynamics` uses
    it for drawing. `Makie` is a graphics framework along more or less the same lines
    as the current standard, `Plots`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'As we plan to create visualizations of our model with its two agent types,
    let’s create functions that map the agent types to two distinct colors and shapes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These functions, when used together, will render prey creatures as blue dots
    and predators as circles with dots inside them. Predators on the chase will be
    red, while idle predators will be green.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'After evolving the model to any step using `run!()`, we can create and save
    a picture of its state with the following calls:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The plotting function, `abmplot()`, returns two values, of which we only need
    the first. The agent color (`ac`) and agent shape (`am`) use our functions defined
    earlier, and we set the agent marker size (`as`) to a value that worked well in
    the visualization. [Figure 11-1](ch11.xhtml#ch11fig1) shows the result after 10,000
    steps.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch11fig01.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: The model configuration at step 10,000*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: At the moment shown in [Figure 11-1](ch11.xhtml#ch11fig1), there are 139 total
    agents. None of the predators happen to be idle at this moment, so they are all
    rendered in the same color.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create an animation of the model using `abmvideo()`, which is supplied
    by `InteractiveDynamics` as well. It actually runs the model, beginning with the
    initial state supplied in its second argument, stepping through it using the same
    step functions that we supply to `run!()`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The run stops after the number of steps given in the `frames` keyword argument,
    and the video file is saved with the name given in the first argument. We can
    use constants or, as we did here, functions for agent shapes and colors, as in
    `abmplot()`. You can view some animations made with this method in the online
    supplement for this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Animations are excellent devices for verifying that an ABM simulation is working
    as intended and for communicating the results when the dynamic behavior is interesting.
    However, running the model through `abmvideo()` is much slower than running it
    with `run!()` because, in addition to the model calculations, the function renders
    an image at each step using `abmplot()` and assembles a video file. A strategy
    for long-running agent simulations, therefore, may be to run the calculation using
    `run!()` and then render subsets of steps as animations. This strategy requires
    periodically saving the model, as we do in our example within `agent_step!()`,
    so we have various saved states available to start from.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Two additional quirks to note about `abmvideo()` are that it doesn’t use the
    convention of the exclamation point in its name, despite mutating the model, and
    that it cannot generate dataframes directly as can `run!()`. We can get around
    this last issue by putting data recording into `model_step!()`, as we did in our
    example with logging. This is a more flexible approach in any case, as it allows
    us more control over the recorded data. For example, we might decide to add a
    row to the dataframes less frequently than every step.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The `CairoMakie` graphics library is appropriate for making high-quality plots
    and animations saved in files. For more immediate feedback, we can import `GLMakie`
    instead. If both are imported, the calls `GLMakie.activate!()` and `CairoMakie.activate!()`
    switch between them. When `GLMakie` is active, `abmplot()` and `abmvideo()` open
    a dedicated graphics window when using the REPL, or they can insert graphics into
    a computational notebook.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyzing the Results**'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The call to run the simulation in [Listing 11-2](ch11.xhtml#ch11lis2) stores
    the distribution of angles in the prey angle tables in the model dataframe at
    every timestep. These angles are initially uniformly distributed, so if the distribution
    changes over time, we know that some form of evolution is occurring. The angle
    distribution over the population doesn’t tell us everything about its character,
    but if we reach a point where the distribution has stopped evolving, this suggests
    that the population may have achieved some form of optimum in response to the
    selection pressure exerted by the predators.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'We can plot a histogram of the distribution at any step by extracting `moves_dist_data`
    from the model dataframe. The dataframe for the 20th run looks like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the call to plot the histogram from the last row in this dataframe:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We need the `LinearAlgebra` package for the `normalize()` function, which rescales
    the histogram of raw counts into one that can be interpreted as a probability
    density function (see “Probability Density Functions” on [page 325](ch10.xhtml#ch10lev1sec4)).
    This allows us to compare distributions from populations of different sizes directly.
    At this stage, there are 5,069 `Prey` agents, as can be read off from the dataframe,
    and comparing the distribution at earlier times shows that it seems to have converged
    to the shape shown in [Figure 11-2](ch11.xhtml#ch11fig2).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch11fig02.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: Evolved angle distribution*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit of reflection reveals why the prey creatures may have evolved such a
    distribution. The predators are significantly faster than their prey (`SPEEDR`
    `= 1.5`) but they have severely limited agility: `LAA =` π`/128`, which means
    that they can turn no more than 1.4° in any step. If the prey try to run in a
    straight line, the predators are likely to catch them before they have a chance
    to reproduce. This fact produces the pronounced dip in the distribution near 0°.
    Making sharp turns of close to 180° buys the most time, and that’s where we find
    the peaks in the distribution.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: If this idea, that the prey have “learned” to avoid predators with these particular
    attributes, is correct, then a different species of predator with different attributes
    should give rise to a different angle distribution.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: To test this idea, we need simply to change the `LAA` and `SPEEDR` constants
    and run the simulation again. After trying this with `SPEEDR = 1.05` and `LAA`
    = π`/16`, we observe the distribution shown in [Figure 11-3](ch11.xhtml#ch11fig3)
    after 13,000 steps.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch11fig03.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Evolved angle distribution with slower but more agile predators*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: This result is distinctly different and admits a clear intuitive explanation.
    These predators can only travel 5 percent faster than the prey, so their potential
    victims can often survive long enough to reproduce by simply continuing in something
    close to a straight line. Although slow, they are far more agile than the predators
    in the previous simulation, able to turn through 11.25° at each step, so prey
    who make many large turns are more likely to be caught. Hence we see a distribution
    with a broad peak near 0°, falling off at larger angles.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The distribution evolution is suggestive, but let’s see if we can confirm the
    idea that the prey have evolved to be better predator avoiders. We’ll do this
    by comparing the evolved population to unevolved populations with uniform distributions
    of angles in their `moves` tables. Since we use a seeded random number generator,
    we can create ensembles of populations by running the simulation multiple times
    while varying the `SEED`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability of a population to survive in an environment with predators of
    a particular type is its *fitness*. The predators’ type in our model is defined
    by two parameters: `SPEEDR` and `LAA`, their speed and agility.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: To test the fitness of the initial, unevolved population, we start with 200
    `Prey` agents and 100 `Predator` agents, and turn off the `Prey` agents’ ability
    to reproduce. In such a situation, the prey population should decay roughly exponentially,
    eventually dwindling to zero. We perform this experiment 10 times.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: To test the fitness of the evolved population, we load the model after 20,000
    steps and extract a random sample of 200 `Prey` agents from it. We put that sample
    into the arena with 100 predators and observe the population decay, repeating
    this experiment 10 times as well. Each experiment uses a different random seed,
    so we’ll get a different random sample each time.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-4](ch11.xhtml#ch11fig4) shows the results: the evolved population
    performs distinctly better than the initial population.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch11fig04.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Comparing fitness*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the evolved population becomes extinct as well, as it must without
    the ability to reproduce. But the comparison shows that the sharpturn strategy
    suggested by [Figure 11-2](ch11.xhtml#ch11fig2) is effective, as this population
    decays more slowly.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, I presented a complete, detailed example of a research problem:
    we began with some curiosity about whether we could simulate natural selection
    acting on specific attributes of a population. Then we made the question concrete
    by devising a scenario where behavior was codified by a list of eight numbers.
    Next, we constructed a simulation capturing the mechanisms we wanted to study
    and observed that the simulation displayed evolution of the population, apparently
    converging to some optimum. Lastly, we tested the evolved population and found
    that it did have increased fitness.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The `Agents` package, and Julia’s expressiveness and efficiency, dramatically
    streamlined the path from initial speculation to a verifiable, quantitative, and
    easily visualized result. The ability to try out a variety of scenarios and analyze
    and view the results, all within a unified interactive environment, and with no
    compromise in performance, is an unprecedented boon for the researcher.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: For more information on BioJulia, the “bioinformatics infrastructure for the
    Julia language,” see [*https://biojulia.dev*](https://biojulia.dev).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The article “Julia for Biologists” provides an overview of the use of the language
    in biology: [*https://arxiv.org/abs/2109.09973*](https://arxiv.org/abs/2109.09973).'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details on `Agents.jl` is available at [*https://juliadynamics.github.io/Agents.jl/stable/*](https://juliadynamics.github.io/Agents.jl/stable/).
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Watch a video about `Agents.jl` here: [*https://youtu.be/Iaco6v6TVXk*](https://youtu.be/Iaco6v6TVXk).'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A detailed survey of the field of artificial life is available at [*https://www.ais.uni-bonn.de/SS09/skript_artif_life_pfeifer_unizh.pdf*](https://www.ais.uni-bonn.de/SS09/skript_artif_life_pfeifer_unizh.pdf).
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For interesting anecdotes about artificial life simulations, visit [*https://direct.mit.edu/artl/article/26/2/274/93255/The-Surprising-Creativity-of-Digital-Evolution-A*](https://direct.mit.edu/artl/article/26/2/274/93255/The-Surprising-Creativity-of-Digital-Evolution-A).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
