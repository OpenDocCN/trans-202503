- en: '**11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11'
- en: BIOLOGY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 生物学**
- en: '*Modern biology is becoming very much a branch of information technology.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*现代生物学正越来越成为信息技术的一个分支。*'
- en: —Richard Dawkins
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —理查德·道金斯
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: As Professor Dawkins points out, computation has become a central tool in many
    areas of biology. This was perhaps inevitable, as evolution is the central organizing
    principle of biology, and evolution occurs through the transmission of information
    in the form of a digital storage device known as DNA.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如道金斯教授所指出的，计算已经成为生物学许多领域中的核心工具。这或许是不可避免的，因为进化是生物学的核心组织原则，而进化通过被称为 DNA 的数字存储设备的形式传递信息。
- en: The biology ecosystem around Julia is sophisticated, wide-ranging, and growing
    rapidly. The language and its packages are being used in many areas of biological
    and medical research, in both industry and academia.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 周围的生物学生态系统非常复杂，涵盖面广，且增长迅速。该语言及其包在生物学和医学研究的许多领域中得到了应用，涵盖了工业界和学术界。
- en: This chapter begins with a brief overview of the Julia biology landscape and
    proceeds directly to a detailed case study in simulated evolution.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先简要概述了 Julia 生物学领域的概况，然后直接进入模拟进化的详细案例研究。
- en: '**The Julia Biology Ecosystem**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Julia 生物学生态系统**'
- en: Bioinformatics has become a major subfield of biology that is defined by the
    use of computers. It mainly deals with the analysis and manipulation of protein
    sequences, so it has a strong computational linguistics flavor. The BioJulia GitHub
    organization provides a starting place for browsing this large collection of packages.
    It includes, among others, modules for handling the various file types that bioinformaticians
    have devised over the years.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 生物信息学已成为生物学的一个主要子领域，其特点是使用计算机。它主要处理蛋白质序列的分析和操作，因此具有很强的计算语言学特征。BioJulia GitHub
    组织为浏览这一大规模包集提供了一个起点。它包括了许多其他模块，用于处理生物信息学家多年来开发的各种文件类型。
- en: To discover other Julia packages outside of the bioinformatics organization,
    we can turn to the general GitHub search methods described in “How to Find Public
    Packages” on [page 80](ch03.xhtml#ch03lev1sec14). Many of these packages do not
    include general tags such as “biology,” so you can find them more easily with
    focused searches using terms such as *phylogenetics* or *ecology*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要发现 bioinformatics 组织之外的其他 Julia 包，我们可以转向“如何查找公共包”一节中描述的常规 GitHub 搜索方法（参见[第
    80 页](ch03.xhtml#ch03lev1sec14)）。这些包中的许多并没有包含像“biology”这样的通用标签，因此你可以使用像 *系统发育学*
    或 *生态学* 这样的关键词进行集中搜索，从而更轻松地找到它们。
- en: The `Pumas` pharmaceutical modeling and simulation toolkit merits particular
    mention as a major success story for Julia in medicine and biology. `Pumas` is
    used by major corporations and research groups to develop and test drugs. Its
    GitHub page contains links to extensive documentation and tutorials.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pumas` 药物建模与仿真工具包作为 Julia 在医学和生物学领域的一个重大成功值得特别提及。`Pumas` 被大公司和研究团队用来开发和测试药物。其
    GitHub 页面包含了丰富的文档和教程链接。'
- en: Many Julia biology packages were created to work with other packages in the
    areas of statistics, equation solving, or other areas useful in mathematical biology.
    An example is `EvolutionaryModelingTools`, which works with the `DifferentialEquations`
    package (see “Combining DifferentialEquations with Measurements” on [page 302](ch09.xhtml#ch09lev1sec20)),
    providing macros to assist in setting up problems that use Gillespie’s algorithm
    (a method for attacking stochastic differential equations) in the simulation of
    models of infectious disease propagation and problems with a similar structure.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Julia 生物学包被创建来与统计学、方程求解或其他在数学生物学中有用的领域的其他包一起使用。例如，`EvolutionaryModelingTools`
    就与 `DifferentialEquations` 包协作（参见[第 302 页](ch09.xhtml#ch09lev1sec20)中的“将 DifferentialEquations
    与测量结合”），提供宏来帮助设置使用 Gillespie 算法（攻击随机微分方程的一种方法）进行传染病传播模型和类似结构问题的仿真。
- en: '**Simulating Evolution with Agent-Based Modeling**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用基于代理的建模模拟进化**'
- en: '*Agent-based modeling (ABM)* is a simulation technique using a community of
    computational entities, the *agents*, interacting with each other and their environment
    through a set of *rules*. The agents may be representations of life forms, vehicles,
    or something more abstract, such as information. The rules can depend on time,
    the distance between agents, their movement, the state of the environment near
    the agent, or nearly anything else we can imagine. Agents may move, store data,
    die, and be born. The environment itself can change as well.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于代理的建模 (ABM)* 是一种模拟技术，通过一群计算实体——*代理*——彼此与环境进行交互，遵循一组*规则*。这些代理可以是生命形式、车辆或更抽象的事物，如信息。规则可以依赖于时间、代理之间的距离、它们的运动、代理附近环境的状态，或者我们能想象的几乎任何其他因素。代理可能会移动、存储数据、死亡并诞生。环境本身也可能发生变化。'
- en: Researchers have used ABM to simulate traffic flow, the progress of infectious
    diseases, the collective behavior of social animals, the spread of opinions, and
    much more. See “Further Reading” on [page 380](ch11.xhtml#fur11) for some links
    to background information about this approach, and to documentation of the main
    packages used in this section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员已使用ABM模拟交通流、传染病的进展、社会动物的集体行为、舆论的传播等等。请参见[第380页](ch11.xhtml#fur11)中的“进一步阅读”，获取一些关于这种方法的背景信息链接，以及本节所使用的主要包的文档。
- en: Our project will be the simulation of evolution through natural selection in
    a population of two types of simple creatures representing predators and prey.
    We will see how the prey creatures, when allowed to inherit their “genes” from
    their parents, evolve to be better at evading their predators. This evolution
    results from random mutations in the inherited characteristics combined with the
    selection pressure from the predators eating the less evasive prey before they
    have a chance to reproduce.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目将模拟自然选择过程中的进化，模拟一个由两种简单生物组成的种群，这些生物代表捕食者和猎物。我们将看到，当猎物生物允许从父母那里继承它们的“基因”时，它们如何进化得更擅长躲避捕食者。这种进化源于遗传特征的随机突变，加上捕食者从吃掉不善于躲避的猎物开始施加的选择压力，迫使它们在繁殖前被捕食。
- en: The `Agents` package provides a framework for a wide variety of ABM calculations.
    It attends to the lower-level details, such as calculating the motions of agents,
    enforcing boundary conditions, and searching for neighbors, allowing us to concentrate
    on programming the rules for agent interaction at a fairly high level.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Agents`包提供了一个框架，用于各种ABM计算。它处理低级别的细节，如计算代理的运动、执行边界条件和查找邻居，从而使我们能够专注于在较高层次上编程代理交互的规则。'
- en: The space in which the agents live can be a continuous physical space (the one
    we will use here); a grid space on which agents can only occupy discrete positions;
    a more abstract tree space, in which agents are not located physically, but within
    a tree data structure; and even a space defined on an actual road map, using OpenStreetMap
    data. The space can become an environment containing spatially and temporally
    varying conditions affecting the agents.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 代理所处的空间可以是一个连续的物理空间（我们在这里使用的空间）；一个网格空间，代理只能占据离散的位置；一个更抽象的树形空间，其中代理并不物理存在，而是存在于树状数据结构中；甚至是一个基于实际道路地图定义的空间，使用OpenStreetMap数据。这个空间可以变成一个环境，包含空间和时间变化的条件，影响代理的行为。
- en: The agents have position and velocity properties and a unique ID. We can endow
    them, as well, with any data structures convenient for our simulation. We can
    create or destroy agents, or change any of their properties, based on their proximity
    to other agents, on time, or on environmental conditions. Agent proximity—nearest
    neighbors or neighbors within a given radius—is returned by a simple function
    call.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代理具有位置、速度属性以及唯一的ID。我们还可以赋予它们任何适合我们模拟的数据结构。我们可以基于代理之间的接近程度、时间或环境条件来创建或销毁代理，或者更改它们的任何属性。代理的接近性——最近的邻居或在给定半径内的邻居——可以通过简单的函数调用返回。
- en: Any particular project typically will make use of only a small subset of `Agents`’s
    capabilities, and this section’s project is no exception.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 任何特定项目通常只会使用`Agents`的一个小子集功能，本节的项目也不例外。
- en: '**Overview of the Simulation Problem**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**模拟问题概述**'
- en: 'Our universe will contain two types of creatures: predators and prey. Each
    type has a simple behavior. Predators chase prey. If a predator manages to get
    very close to its target, it vanishes from the simulation, devoured by its pursuer.
    The predators choose their targets from among all those within their detection
    range, but they are polite: they won’t chase prey that one of their colleagues
    is already chasing. Predators have only one speed, which is somewhat faster than
    the one speed with which the prey are able to run. They turn toward their prey
    as they chase them, but their superior speed is offset by limited agility: they
    can turn only through some maximum angle at every simulation step. Like some actual
    predator species, our simulated predators adjust their reproductive rate to maintain
    a certain ratio of predator population to prey population.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的宇宙将包含两种类型的生物：捕食者和猎物。每种类型都有简单的行为。捕食者追赶猎物。如果捕食者成功接近目标，它会从模拟中消失，被追捕者吞噬。捕食者从所有处于其探测范围内的猎物中选择目标，但它们很有礼貌：如果同伴已经追捕某个猎物，它们不会再追赶那个猎物。捕食者只有一个速度，稍微快于猎物的速度。它们在追赶猎物时会转向目标，但它们的高速度被有限的灵活性所抵消：它们每次模拟步骤只能转动一定的最大角度。像某些实际的捕食者物种一样，我们的模拟捕食者会调整它们的繁殖率，以保持捕食者种群与猎物种群的比例。
- en: The prey make turns at regular intervals according to a list of angles; each
    prey creature has its own list. When it reaches the end of the list, it goes back
    to the top. Prey don’t react to predators, they simply run around making their
    prescribed turns. One can imagine that their environment is rich with uniformly
    distributed food, as a property (which is called `mojo` in the program) gets incremented
    by a fixed amount at every step. If a prey creature manages to reach a predetermined
    amount of `mojo` without getting eaten, it reproduces. Reproduction is fatal;
    the creature is replaced by two descendants. Each descendant inherits a copy of
    its parent’s table of angles, with some random mutations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 猎物按照一组角度在固定的时间间隔内转弯；每个猎物有自己的一组角度。当它到达列表的末尾时，它会回到列表的顶部。猎物不会对捕食者做出反应，它们只是按照预定的角度转弯四处奔跑。可以想象，它们的环境充满了均匀分布的食物，因为一个属性（在程序中称为`mojo`）在每一步都会增加一个固定的量。如果猎物在不被吃掉的情况下成功地积累了一定数量的`mojo`，它就会繁殖。繁殖是致命的；这个生物会被两个后代所取代。每个后代继承其父母的角度列表，并带有一些随机突变。
- en: The only property that distinguishes different prey individuals, aside from
    their locations and velocities, is the list of angles. We initialize the agents
    with a random list, uniformly distributed from –*π* to *π*. Some lists of turns
    will, by chance, be slightly better than others in allowing the agent to survive
    longer, as they will, on average, make it more difficult for the predators, with
    their limited agility, to catch it. These agents will be more likely to reproduce,
    as will their children. Through mutation, some of these children may be even more
    likely to survive to reproduce. We hope to observe an evolution in the distribution
    of angles in the prey population, and an average increase in the ability to evade
    predation, as a result of this selection pressure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 区分不同猎物个体的唯一特性，除了它们的位置和速度，就是角度列表。我们以一个随机列表初始化这些代理，列表中的角度均匀分布在–*π*到*π*之间。某些转弯列表由于偶然的原因，可能比其他列表更适合让代理生存得更久，因为它们会使捕食者由于有限的灵活性而更难以抓住猎物。这些代理更有可能繁殖，正如它们的后代一样。通过突变，这些后代中的一些可能比其他后代更有可能生存下来并繁殖。我们希望观察到猎物种群中角度分布的演化，以及由于这种选择压力，避免被捕食的能力的平均提高。
- en: The foregoing is an overview of the structure and aims of the project. In the
    next few sections, we’ll put together all the components of our simulation, in
    the order in which they appear in the complete program, which is assembled for
    convenience in the code section of the web supplement for this chapter at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org).
    When turning these ideas into a program, we’ll have to make everything concrete.
    For example, we’ll decide to make the list of angles contain eight elements. Many
    of these details are, within limits, arbitrary, and the reader might experiment
    with altering all or some of them, and perhaps improve upon the experiment described
    here.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容是该项目的结构和目标概述。在接下来的几个部分，我们将按照在完整程序中出现的顺序，将所有的模拟组件拼接在一起，完整程序方便地汇总在本章节的网页补充材料中，网址为[*https://julia.lee-phillips.org*](https://julia.lee-phillips.org)。在将这些思想转化为程序时，我们需要将一切具体化。例如，我们决定让角度列表包含八个元素。这些细节在一定范围内是任意的，读者可以尝试更改其中的全部或部分，甚至可能改进此处描述的实验。
- en: '**The Predator and Prey Agents**'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**捕食者和猎物代理**'
- en: 'The `Agents` package provides a convenient macro for defining our agents:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Agents` 包提供了一个便捷的宏来定义我们的代理：'
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First we import the needed packages. In addition to `Agents`, we need `StatsBase`
    for creating histograms of the angle distributions, `JLD2` for saving and loading
    simulation data (see [Listing 9-4](ch09.xhtml#ch9lis4) on [page 289](ch09.xhtml#ch9lis4)),
    and `Random` for random numbers (see “Random Numbers in Julia” on [page 307](ch10.xhtml#ch10lev2)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的包。除了`Agents`，我们还需要`StatsBase`来创建角度分布的直方图，`JLD2`来保存和加载模拟数据（参见[列表 9-4](ch09.xhtml#ch9lis4)，[第289页](ch09.xhtml#ch9lis4)），以及`Random`用于生成随机数（参见《Julia中的随机数》[第307页](ch10.xhtml#ch10lev2)）。
- en: The `@agent` macro defines the agents as composite types. After executing the
    macros in the listing, we have an agent type called `Prey` and another called
    `Predator`. The `ContinuousAgent{2}` notation means that the agents are destined
    to live in a continuous, two-dimensional space, where their positions are defined
    by a tuple of two floating-point numbers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`@agent`宏将代理定义为复合类型。在执行列表中的宏后，我们有了一种名为`Prey`的代理类型，和另一种名为`Predator`的代理类型。`ContinuousAgent{2}`表示这些代理将在一个连续的二维空间中生活，其中它们的位置由一个包含两个浮点数的元组定义。'
- en: 'Each instance of `Prey` is endowed with two properties: `mojo`, the float that
    will determine when it’s ready to reproduce; and `moves`, its vector of angles
    that determines the path it takes as it wanders blindly through the environment.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Prey`实例都拥有两个属性：`mojo`，它是一个浮动值，用来决定猎物何时准备好繁殖；以及`moves`，它是一个角度向量，决定猎物在环境中盲目徘徊时的路径。
- en: 'A predator has only one property: `victim` will be the ID of the individual
    prey that it’s chasing. If this is 0, it’s sitting still and waiting for a potential
    victim to wander within range.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 捕食者只有一个属性：`victim`，它是捕食者正在追逐的猎物的ID。如果该值为0，则捕食者静止不动，等待潜在猎物进入其范围。
- en: '***Constants Defining Model Behavior***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定义模型行为的常量***'
- en: Certain parameters determining model behavior are defined in a list of constants,
    shown in [Listing 11-1](ch11.xhtml#ch11lis1). We can alter these constants to
    experiment with evolution under different conditions without making changes to
    the program. These are declared `const`, a declaration we should apply to all
    global quantities in the interests of performance. In general, a program should
    not use non-`const` global variables.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 决定模型行为的某些参数在一系列常量中定义，如[列表 11-1](ch11.xhtml#ch11lis1)所示。我们可以修改这些常量，以便在不同条件下进行进化实验，而无需更改程序。这些常量被声明为`const`，我们应当对所有全局变量应用此声明，以提高性能。一般来说，程序不应使用非`const`的全局变量。
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 11-1: Constants defining the model*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-1：定义模型的常量*'
- en: The predator population adjusts itself at every step to maintain the `PPR`,
    adding predators if needed and eliminating them if the ratio is more than 5 percent
    too large.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 捕食者种群会在每一步进行调整，以保持`PPR`，根据需要增加捕食者，若比例超过5%则会消除部分捕食者。
- en: The parameter `M` is the length of the vector of angles that amounts to the
    prey’s genome. The prey will proceed in a straight line for `SBT` steps before
    turning through the next angle in the angle vector.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`M`是代表猎物基因组的角度向量的长度。猎物将在直线前进`SBT`步，然后转向角度向量中的下一个角度。
- en: A predator can “see” a prey creature if it’s closer than the distance `TAD`.
    It begins chasing the first such prey that it sees that is not already being chased.
    If a predator manages to close the distance to its target to within `KD`, the
    target is eliminated.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果捕食者与猎物的距离小于`TAD`，它就能“看到”猎物。它开始追赶它所看到的第一个猎物，且该猎物尚未被其他捕食者追赶。如果捕食者成功地将与目标的距离缩小到`KD`以内，则目标被消灭。
- en: When a prey creature reproduces, it replaces itself with `LS` descendants.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个猎物生殖时，它会用`LS`后代替代自己。
- en: The prey creatures eat continuously as they run, increasing their `mojo` by
    `MIPS` every step. The `mojo` is really just a measure of how long a creature
    has survived. Once a prey creature’s `mojo` has reached `MNFR`, it reproduces.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 猎物在跑步时不断进食，每一步都增加`MIPS`的`mojo`值。`mojo`实际上只是衡量一个生物存活时间的指标。当猎物的`mojo`值达到`MNFR`时，它就会繁殖。
- en: The predator’s straight-line speed is `SPEEDR` times the prey’s speed. The predator’s
    ability to corner is limited by `LAA`. It turns in the direction of the prey,
    adjusting its heading at every step, but can turn no more than `LAA` radians each
    time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 捕食者的直线速度是猎物速度的`SPEEDR`倍。捕食者的转弯能力受到`LAA`的限制。它会朝猎物的方向转向，每一步调整一次航向，但每次转向的角度不超过`LAA`弧度。
- en: The `Agents` integration routine (a simple Euler step) uses a timestep of `dt`.
    This constant serves as an overall scale for agent speeds.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Agents`集成例程（一个简单的欧拉步进）使用`dt`作为时间步长。这个常量作为代理速度的总体尺度。'
- en: In order to be able to repeat simulations using identical sequences of random
    numbers, and to create ensembles of simulations when desired, we’ll use a random
    number generator with a seed that we can control (see “Random Numbers in Julia”
    on [page 307](ch10.xhtml#ch10lev2)). This is the purpose of `SEED` and the `rng`.
    Also, the `rand()` functions are somewhat more efficient when passed an `rng`,
    although this concern is not as acute as it has been in some past versions of
    Julia and the `Random` package.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用相同的随机数序列重复仿真，并在需要时创建仿真集，我们将使用一个可控的随机数生成器（详见“Julia中的随机数”[第307页](ch10.xhtml#ch10lev2)）。这就是`SEED`和`rng`的用途。此外，当传递一个`rng`时，`rand()`函数的效率会更高，尽管这种问题在一些早期版本的Julia和`Random`包中比现在更为严重。
- en: '***Utility Functions***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实用函数***'
- en: 'We’d like to have a few functions to make the code that orients the predators
    and changes the direction of the prey more concise:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一些函数使得控制捕食者的方向和改变猎物方向的代码更加简洁：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We’re going to need to normalize velocity vectors, which means adjusting their
    lengths to unity. This is what `vnorm()` does. The `angle_between()` function
    returns the angle between two vectors. The predators need this to calculate where
    to turn when chasing their food. And turning, both of predators and prey, relies
    on `turn()`, which, when supplied with a starting vector and an angle, returns
    the vector rotated through the angle.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对速度向量进行归一化处理，也就是将它们的长度调整为单位长度。这正是`vnorm()`的作用。`angle_between()`函数返回两个向量之间的角度。捕食者需要这个函数来计算在追捕猎物时该怎么转向。转向，无论是捕食者还是猎物，都依赖于`turn()`，该函数在给定一个起始向量和角度后，会返回经过该角度旋转后的向量。
- en: 'In addition, we need a function to mutate the `moves` table. Without this,
    no evolution takes place:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要一个函数来变异`moves`表格。如果没有这个函数，进化过程就不会发生：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This makes a random change to a specified number of the angles in the table
    by an angle uniformly distributed from –*π*/4 to *π*/4.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会对表格中指定数量的角度进行随机变化，变化量是一个均匀分布在–*π*/4到*π*/4之间的角度。
- en: '***Model Initialization***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模型初始化***'
- en: 'Every `Agents` simulation requires, in addition to the agents themselves, three
    data structures:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Agents`仿真除了需要代理本身外，还需要三种数据结构：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `arena` is the space in which the agents live and interact. Our space will
    be continuous, have coordinates running from 0 to 1 along each dimension, and
    have periodic boundary conditions. This makes the space infinite in the sense
    that an agent running off the right side will reemerge on the left side.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`arena`是代理生活和互动的空间。我们的空间将是连续的，坐标范围从0到1，并且每个维度都采用周期性边界条件。这使得空间变得无限——一个代理跑到右边界时会重新出现在左边界。'
- en: The `properties` is a dictionary of quantities relating to the simulation as
    a whole. In our simulation we use it just to keep track of how many steps have
    passed. For keeping track of when it’s time for the prey to make a turn, we use
    `stepno` and increment `total_step` at each step. The former could be derived
    from the latter, but maintaining the two counters can be convenient when restarting
    a simulation from a saved state. We initialize both counters to 0.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`properties`是一个与整个仿真相关的数量字典。在我们的仿真中，我们用它来跟踪已过的步骤数。为了跟踪何时是猎物转弯的时间，我们使用`stepno`，并在每一步时增加`total_step`。前者可以从后者中推导出来，但在从保存的状态重新启动仿真时，维护两个计数器会很方便。我们将这两个计数器初始化为0。'
- en: With these two objects in place we can initialize the `model`, which maintains
    the whole simulation state. Checkpointing and restarting the simulation requires
    merely saving the `model` to disk. The two positional arguments of its constructor
    are the agent types and the space. If we had only one type of agent, the call
    would look like `ABM(Prey, arena; properties)`, for example.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个对象，我们可以初始化`model`，它维护整个仿真状态。检查点和重启仿真仅需要将`model`保存到磁盘。它的构造函数的两个位置参数分别是代理类型和空间。如果我们只有一种类型的代理，调用的方式将像`ABM(Prey,
    arena; properties)`，例如。
- en: We choose `properties` for the name of the property dictionary because that
    name is used for a keyword in the model constructor, which makes the call to `ABM`
    simpler (see “Concise Syntax for Keyword Arguments” on [page 154](ch06.xhtml#ch06lev1sec1)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择`properties`作为属性字典的名称，因为该名称在模型构造函数中用作关键字，这使得调用`ABM`更加简洁（参见“关键字参数的简洁语法”在[第154页](ch06.xhtml#ch06lev1sec1)）。
- en: '**NOTE**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*With the version of* Agents *used at the time of writing, we get a warning
    after constructing the model this way. The message warns us about a potential
    inefficiency when using a* Union *of agent types. This is an area of ongoing development
    effort, and the warning will probably disappear in future versions. The inefficiency
    doesn’t actually become a problem unless we use more than three agent types.*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*在写作时使用的* Agents *版本中，在这种方式下构建模型后，我们会收到一个警告。消息警告我们在使用代理类型的* Union *时可能会出现效率低下的问题。这是一个正在进行中的开发领域，警告可能会在未来版本中消失。除非我们使用超过三种代理类型，否则这个效率问题实际上并不会成为问题。*'
- en: 'With `model` defined, we can initialize it by adding the agents:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了`model`后，我们可以通过添加代理来初始化它：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `add_agent!()` function is named using an exclamation point to remind us
    that it mutates one of its arguments: it alters `model` by adding agents to it.
    This function creates an agent at a random position within the `arena`. It expects
    an agent type as a first argument, the model in the second position, and a tuple
    giving the agent’s initial *x* and *y* velocities. Positional arguments following
    the third are passed to the agent constructor. Therefore, in the first loop, each
    `add_agent!()` call will create a `Prey` instance using `Prey(0.0, moves)`. The
    initial `mojo` is set to 0, and the starting vector of angles is randomly set
    ➊.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_agent!()`函数的命名使用了感叹号，提醒我们它会修改其中一个参数：它通过向`model`中添加代理来改变它。此函数在`arena`中随机位置创建一个代理。它期望第一个参数为代理类型，第二个为模型，第三个参数为一个元组，指定代理的初始*x*和*y*速度。第三个位置之后的其他位置参数将传递给代理构造函数。因此，在第一次循环中，每个`add_agent!()`调用都会使用`Prey(0.0,
    moves)`创建一个`Prey`实例。初始的`mojo`设置为0，起始角度向量随机设置 ➊。'
- en: '**Functions to Extract Information from the Model**'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从模型中提取信息的函数**'
- en: Let’s look at some more short utility functions that accept the `model` as an
    argument and return information about its current state. We’ll use some of them
    in the calculation and others to extract data that we’ll store and use later when
    we analyze the results.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些接受`model`作为参数并返回其当前状态的短小实用函数。我们将在计算中使用其中一些函数，并用其他的来提取数据，之后在分析结果时存储并使用它们。
- en: 'First we’ll need functions to give us a vector of all the prey or predators
    in the system:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些函数来返回系统中所有猎物或捕食者的向量：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Inside the list comprehensions we use the `allagents()` function, which creates
    an iterator over the agents of a model.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表推导式内部，我们使用了`allagents()`函数，它创建了一个迭代器，用于遍历模型中的代理。
- en: 'The following suggestively named functions simply call the ones just shown
    and return the lengths of the agent vectors:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下这些富有提示性的函数只是调用了前面展示的函数，并返回代理向量的长度：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since the predators do not compete for prey with their colleagues, they need
    to know if a potential meal is already under pursuit:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于捕食者之间不会争夺猎物，它们需要知道潜在的猎物是否已经被追捕：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function returns a vector of all the `ID`s of prey creatures that are marked
    as victims by some predator. In order to determine if a potential meal is not
    already being chased, a predator checks whether its `ID` is in this list.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回一个包含所有被某些捕食者标记为受害者的猎物生物 `ID` 的向量。为了判断潜在的猎物是否已经被追捕，捕食者会检查其 `ID` 是否在该列表中。
- en: As mentioned earlier, we expect the vectors of angles to evolve. One way to
    get an overview of this process is to observe the evolution of the distribution
    of angles in the population (see “Distributions” on [page 321](ch10.xhtml#ch10lev7)
    for an overview of the concept of a distribution).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们期望角度向量会发生变化。了解这一过程的一个方法是观察群体中角度分布的演变（有关分布概念的概述，请参见 [第 321 页](ch10.xhtml#ch10lev7)的“分布”）。
- en: 'The following function gathers all the angles in all the `moves` vectors from
    all the prey creatures and returns a `Histogram` data structure representing a
    binning of the distribution into 40 equal buckets. We can then normalize and plot
    the results at various timesteps to analyze one aspect of the simulation:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数收集所有捕食者的 `moves` 向量中的所有角度，并返回一个 `Histogram` 数据结构，表示将分布划分为 40 个相等的桶。然后，我们可以在不同的时间步对结果进行归一化并绘制图表，以分析仿真的一个方面：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function, and its use of `fit()` and the `Histogram` data structure, are
    the reason we imported the `StatsBase` package. The pattern in the comprehension
    in the second line, with its two `for` loops, is a common way to flatten a collection
    of collections.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数及其对 `fit()` 和 `Histogram` 数据结构的使用，是我们导入 `StatsBase` 包的原因。第二行中的推导式模式，带有两个
    `for` 循环，是扁平化一组集合的常见方法。
- en: '***Stepping Through the Simulation***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过仿真步进***'
- en: The `agent_step!()` and `model_step!()` functions are at the core of any `Agents`
    simulation. At every timestep, the `agent_step!()` function updates each agent
    as it’s selected by the *scheduler*. This update can include moving the agent,
    changing its velocity, altering the values of its properties, or anything else
    that makes sense to apply to individual agents. The scheduler is the component
    of the calculation that selects which agents to update and in what order. In most
    `Agents` simulations, we can leave the order unspecified; allowing the scheduler
    to update the agents in an arbitrary order is the fastest option.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`agent_step!()` 和 `model_step!()` 函数是任何 `Agents` 仿真中的核心。在每个时间步，`agent_step!()`
    函数会在 *调度器* 选中代理时更新该代理。这个更新可以包括移动代理、改变其速度、修改其属性值，或者对单个代理应用其他任何合理的变化。调度器是计算的一个组成部分，负责选择哪些代理需要更新以及更新的顺序。在大多数
    `Agents` 仿真中，我们可以不指定顺序；允许调度器以任意顺序更新代理是最快的选择。'
- en: After the `agent_step!()` function comes (by default) the `model_step!()` function,
    which makes updates that apply to the model as a whole. This includes updates
    that require access to the entire agent population, including those that search
    for near neighbors.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `agent_step!()` 函数之后（默认情况下）是 `model_step!()` 函数，该函数会执行对整个模型的更新。这包括需要访问整个代理群体的更新内容，例如那些寻找邻近代理的更新。
- en: The `agent_step!()` function is required, but `model_step!()` is optional; our
    calculation uses both. Also, there is an option to perform `model_step!()` before
    `agent_step!()` if the calculation needs that.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`agent_step!()` 函数是必需的，但 `model_step!()` 是可选的；我们的计算同时使用了这两者。此外，如果计算需要，也可以在
    `agent_step!()` 之前执行 `model_step!()`。'
- en: '**Stepping the Agents**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**代理步进**'
- en: 'The following shows the entire function for updating both predator and `Prey`
    agents:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更新捕食者和 `猎物` 代理的整个函数：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `agent_step!()` function (which can be named anything, but we’ve used the
    conventional name) must accept `agent` and `model` as arguments. The scheduler
    passes each agent in turn to the function as it cycles through them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`agent_step!()` 函数（可以命名为任何名称，但我们使用了传统名称）必须接受 `agent` 和 `model` 作为参数。调度器会依次将每个代理传递给该函数，随着它对代理的轮流操作。'
- en: The first line moves the agent by an amount determined through the timestep,
    `dt`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行通过时间步 `dt` 确定的量来移动代理。
- en: We then kill off any `Prey` agents that have been caught by the predators that
    are chasing them, where “caught” means that the distance between them has become
    less than `KD`. We use `euclidean_distance()`, a function built into the package,
    to measure this distance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们消除任何被捕食者追逐的`Prey`代理，这里的“被捕获”意味着它们之间的距离小于`KD`。我们使用包内的`euclidean_distance()`函数来衡量这个距离。
- en: After the meal, the predator waits, stationary ➊, for another available prey
    to come within range.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 吃完饭后，捕食者静止不动➊，等待另一只猎物进入攻击范围。
- en: 'If the prey is too far away to eat, we continue the chase by turning toward
    it. The first step is finding the current angle between the predator’s velocity
    vector and the vector between the positions of the predator and its prey. Fortunately,
    `Agents` comes with a function just for this: `get_direction()`. In calling this
    function, we use two additional features of the `model`: an agent’s position tuple
    is available as `agent.pos`, and `model[i]` returns the agent with `ID i`. Although
    `model`s aren’t arrays, the `Agents` package defines a `getindex()` method that
    enables this. After limiting the turning angle ➋ to the predator’s agility, set
    with the constant `LAA`, we update its velocity.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果猎物距离太远无法吃掉，我们通过转向继续追逐。第一步是找到捕食者速度向量与捕食者与猎物位置之间的向量之间的当前角度。幸运的是，`Agents`包提供了一个专门的函数：`get_direction()`。调用此函数时，我们使用了`model`的两个附加特性：一个代理的位置元组可以通过`agent.pos`获得，`model[i]`返回具有`ID
    i`的代理。虽然`model`不是数组，但`Agents`包定义了一个`getindex()`方法来支持这一点。在将转向角度限制到捕食者的灵活性，即常数`LAA`之后，我们更新它的速度。
- en: 'We then check for any sufficiently close eligible prey: any `Prey` agent within
    a distance `TAD` that’s not already being chased. If we find one, we set the predator’s
    velocity vector to point toward the prey, again using `get_direction()` ➌.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查是否有任何足够接近的可追捕猎物：任何距离`TAD`以内且尚未被追逐的`Prey`代理。如果找到了，我们将捕食者的速度向量指向猎物，再次使用`get_direction()`
    ➌。
- en: Turning to the prey creatures, first we check if they have accumulated enough
    `mojo` to reproduce. Those who have enough give birth to `LS` copies, which are
    then mutated. We kill off the parent using the `kill_agent!()` function ➍, which
    is part of the `Agents` package.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 转向猎物时，我们首先检查它们是否积累了足够的`mojo`以进行繁殖。那些有足够`mojo`的会繁殖出`LS`个副本，然后这些副本会发生突变。我们使用`kill_agent!()`函数
    ➍杀死父体，这是`Agents`包的一部分。
- en: When it’s time to make a turn, we rotate the velocity using our `turn()` function.
    We need to convert the result to a `Tuple` ➎ because the package uses those to
    store agent velocities.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要转向时，我们使用`turn()`函数旋转速度。由于该包使用元组来存储代理的速度，我们需要将结果转换为`Tuple` ➎。
- en: 'After making the turn, we rotate the agent’s private turn table with a function
    that we’re using for the first time: `circshift()`, which rotates an array. This
    invocation rotates the `moves` vector to the left, so its second element becomes
    its first and its first becomes its last. The outcome is that the prey makes the
    `M` turns stored in `moves` repeatedly (if it survives long enough to do so).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 转向后，我们使用一个首次使用的函数`circshift()`来旋转代理的私人转向表，这个函数可以旋转数组。这个调用将`moves`向量向左旋转，使其第二个元素成为第一个，第一个元素成为最后一个。结果是猎物会重复做`moves`中存储的`M`次转向（如果它足够活跃的话）。
- en: '**Stepping the Model**'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**模型步进**'
- en: 'After the scheduler updates all the agents, it calls this function, passing
    the model as an argument:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在调度器更新所有代理后，它调用此函数，并将模型作为参数传递：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First we increment `model_step`, using modular arithmetic to maintain a cycle
    of length `SBT`; then we increment the total step. Since `total_step`, as well
    as its other properties, is stored along with the model, we can checkpoint and
    seamlessly restart the simulation by using `JLD2` to save and reload the model,
    and `total_step` will keep track of how long it’s been run.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们增加`model_step`，使用模算术来保持长度为`SBT`的循环；然后我们增加总步数。由于`total_step`及其其他属性与模型一起存储，我们可以通过使用`JLD2`保存并重新加载模型来进行检查点并无缝重启仿真，同时`total_step`将跟踪运行了多久。
- en: 'We maintain the predator/prey ratio specified with `PPR` by adding or removing
    predators as needed. The `add_agent()` function from `Agents` adds an agent at
    a random position. The tuple in the argument list is its initial velocity, and
    subsequent arguments are passed to the agent constructor. In this case, there
    is only one such argument: the initial `victim` property is set to 0.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过根据需要添加或移除捕食者来保持指定的捕食者/猎物比（`PPR`）。`Agents`中的`add_agent()`函数在随机位置添加一个代理。参数列表中的元组是其初始速度，后续的参数传递给代理构造函数。在这个例子中，只有一个这样的参数：初始的`victim`属性被设置为0。
- en: We remove agents by passing a random agent to `kill_agent()` using the function
    `random_agent()` ➊. This `Agents` function takes, in its optional second argument,
    a function expressing a condition that the potentially doomed agent must satisfy.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将一个随机代理传递给`kill_agent()`来移除代理，使用`random_agent()`函数➊。这个`Agents`函数在其可选的第二个参数中接收一个函数，该函数表示潜在被删除的代理必须满足的条件。
- en: Finally, the routine maintains a logfile, writing an entry every `LI` steps.
    We `flush()` the logfile so that we can take a look at it while the simulation
    is running. Without this call, the file may not be written until the calculation
    ends.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，例程维护一个日志文件，每`LI`步写入一次记录。我们通过`flush()`调用日志文件，以便在仿真运行时查看它。如果没有这个调用，文件可能直到计算结束后才会写入。
- en: '***Running the Simulation***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行仿真***'
- en: The `run!()` function is `Agents`’s basic facility for stepping through a model,
    as shown in [Listing 11-2](ch11.xhtml#ch11lis2). Its four positional arguments
    are the model, the function for updating the agents, the optional function for
    updating the model, and the total number of steps.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`run!()`函数是`Agents`的基本设施，用于逐步执行模型， 如[Listing 11-2](ch11.xhtml#ch11lis2)所示。它的四个位置参数是模型、用于更新代理的函数、用于更新模型的可选函数以及步骤总数。'
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 11-2: Running the simulation*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-2：运行仿真*'
- en: 'It returns two dataframes (see “CSV Files” on [page 332](ch10.xhtml#ch10lev1sec6)):
    one for the agents and one for the model. The `adata` keyword argument is a `Vector`
    of quantities to include in the agent dataframe, and the `mdata` keyword argument
    is for the model dataframe. These quantities can be agent or model properties,
    which become symbols, or functions of the `model`. In the value for `mdata`, we’re
    using three functions that we defined with this in mind: we’re keeping track of
    the two population sizes and the angle distribution.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回两个数据框（参见“CSV文件”在[第332页](ch10.xhtml#ch10lev1sec6)）：一个用于代理，另一个用于模型。`adata`关键字参数是一个包含代理数据的数据向量，`mdata`关键字参数则用于模型数据框。这些数量可以是代理或模型的属性，变成符号，或者是`model`的函数。在`mdata`的值中，我们使用了三个我们在此基础上定义的函数：我们正在跟踪两个种群规模和角度分布。
- en: We’ve wrapped `run!()` in a function that calls it `nruns` times, each time
    asking it to run the model for `nsteps_per_run` steps, and uses the save function
    from `JLD2` to store the model dataframe and the entire model to disk.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`run!()`封装在一个函数中，该函数调用它`nruns`次，每次让它运行模型`nsteps_per_run`步，并使用`JLD2`中的保存函数将模型数据框和整个模型存储到磁盘上。
- en: To load the model from its saved version on disk, we can enter
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从磁盘加载模型的保存版本，我们可以输入
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: where the string argument specifies the variable to be loaded from the file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，字符串参数指定了从文件中加载的变量。
- en: '***Visualizing System Behavior***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可视化系统行为***'
- en: 'The most convenient way to get a snapshot of the model at any time, or to create
    an animation of its progress, is to use two functions provided by the `InteractiveDynamics`
    package, which needs a separate import:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 获取模型在任何时刻的快照，或创建其进展的动画，最方便的方式是使用`InteractiveDynamics`包提供的两个函数，这需要单独导入：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We need to import a `Makie` library as well because `InteractiveDynamics` uses
    it for drawing. `Makie` is a graphics framework along more or less the same lines
    as the current standard, `Plots`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要导入`Makie`库，因为`InteractiveDynamics`使用它进行绘图。`Makie`是一个图形框架，基本上与当前的标准`Plots`类似。
- en: 'As we plan to create visualizations of our model with its two agent types,
    let’s create functions that map the agent types to two distinct colors and shapes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们计划为包含两种代理类型的模型创建可视化时，让我们创建将代理类型映射到两种不同颜色和形状的函数：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These functions, when used together, will render prey creatures as blue dots
    and predators as circles with dots inside them. Predators on the chase will be
    red, while idle predators will be green.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些函数一起使用时，它们将使猎物以蓝色点表示，捕食者以圆圈内有点的形式表示。追逐中的捕食者为红色，而静止的捕食者则为绿色。
- en: 'After evolving the model to any step using `run!()`, we can create and save
    a picture of its state with the following calls:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`run!()`将模型演化到任意步骤后，我们可以通过以下调用创建并保存其状态的图片：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The plotting function, `abmplot()`, returns two values, of which we only need
    the first. The agent color (`ac`) and agent shape (`am`) use our functions defined
    earlier, and we set the agent marker size (`as`) to a value that worked well in
    the visualization. [Figure 11-1](ch11.xhtml#ch11fig1) shows the result after 10,000
    steps.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图函数`abmplot()`返回两个值，我们只需要第一个。代理的颜色（`ac`）和形状（`am`）使用我们之前定义的函数，我们将代理的标记大小（`as`）设置为在可视化中效果较好的值。[图
    11-1](ch11.xhtml#ch11fig1)显示了第10,000步后的结果。
- en: '![Image](../images/ch11fig01.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch11fig01.jpg)'
- en: '*Figure 11-1: The model configuration at step 10,000*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：第10,000步的模型配置*'
- en: At the moment shown in [Figure 11-1](ch11.xhtml#ch11fig1), there are 139 total
    agents. None of the predators happen to be idle at this moment, so they are all
    rendered in the same color.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 11-1](ch11.xhtml#ch11fig1)中所示的时刻，总共有139个代理。此时没有任何捕食者处于空闲状态，因此它们全部以相同的颜色渲染。
- en: 'We can also create an animation of the model using `abmvideo()`, which is supplied
    by `InteractiveDynamics` as well. It actually runs the model, beginning with the
    initial state supplied in its second argument, stepping through it using the same
    step functions that we supply to `run!()`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`abmvideo()`创建模型的动画，这个函数同样由`InteractiveDynamics`提供。它实际上是运行模型，从第二个参数提供的初始状态开始，通过我们提供给`run!()`的相同步骤函数进行演化：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The run stops after the number of steps given in the `frames` keyword argument,
    and the video file is saved with the name given in the first argument. We can
    use constants or, as we did here, functions for agent shapes and colors, as in
    `abmplot()`. You can view some animations made with this method in the online
    supplement for this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 运行将在`frames`关键字参数中给定的步数后停止，并将视频文件保存为第一个参数给定的名称。我们可以像在`abmplot()`中一样使用常量或函数来表示代理的形状和颜色。你可以在本章的在线补充中查看使用这种方法制作的动画。
- en: Animations are excellent devices for verifying that an ABM simulation is working
    as intended and for communicating the results when the dynamic behavior is interesting.
    However, running the model through `abmvideo()` is much slower than running it
    with `run!()` because, in addition to the model calculations, the function renders
    an image at each step using `abmplot()` and assembles a video file. A strategy
    for long-running agent simulations, therefore, may be to run the calculation using
    `run!()` and then render subsets of steps as animations. This strategy requires
    periodically saving the model, as we do in our example within `agent_step!()`,
    so we have various saved states available to start from.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 动画是验证ABM仿真是否按预期工作的优秀工具，尤其是在动态行为有趣时，可以用来传达结果。然而，使用`abmvideo()`运行模型要比使用`run!()`慢得多，因为除了模型计算之外，该函数还会在每个步骤使用`abmplot()`渲染图像，并且会组装一个视频文件。因此，对于长时间运行的代理仿真，策略可能是先用`run!()`运行计算，然后将某些步骤渲染为动画。这种策略需要定期保存模型，就像我们在`agent_step!()`示例中所做的那样，以便我们可以从多个已保存的状态开始。
- en: Two additional quirks to note about `abmvideo()` are that it doesn’t use the
    convention of the exclamation point in its name, despite mutating the model, and
    that it cannot generate dataframes directly as can `run!()`. We can get around
    this last issue by putting data recording into `model_step!()`, as we did in our
    example with logging. This is a more flexible approach in any case, as it allows
    us more control over the recorded data. For example, we might decide to add a
    row to the dataframes less frequently than every step.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`abmvideo()`还需要注意两个额外的特性：它没有像`run!()`那样使用感叹号作为名称的一部分，尽管它会改变模型；并且它不能像`run!()`那样直接生成数据框。我们可以通过将数据记录放入`model_step!()`来绕过这个问题，就像我们在示例中使用日志记录所做的那样。无论如何，这是一种更灵活的方法，因为它让我们可以更好地控制记录的数据。例如，我们可能决定不在每一步都向数据框中添加一行。
- en: The `CairoMakie` graphics library is appropriate for making high-quality plots
    and animations saved in files. For more immediate feedback, we can import `GLMakie`
    instead. If both are imported, the calls `GLMakie.activate!()` and `CairoMakie.activate!()`
    switch between them. When `GLMakie` is active, `abmplot()` and `abmvideo()` open
    a dedicated graphics window when using the REPL, or they can insert graphics into
    a computational notebook.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`CairoMakie` 图形库适用于制作高质量的图表和动画，并保存为文件。为了更及时的反馈，我们可以导入`GLMakie`。如果两者都已导入，调用`GLMakie.activate!()`和`CairoMakie.activate!()`可以在它们之间切换。当`GLMakie`处于活动状态时，`abmplot()`和`abmvideo()`在使用REPL时会打开一个专用的图形窗口，或者它们可以将图形插入到计算笔记本中。'
- en: '**Analyzing the Results**'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分析结果**'
- en: The call to run the simulation in [Listing 11-2](ch11.xhtml#ch11lis2) stores
    the distribution of angles in the prey angle tables in the model dataframe at
    every timestep. These angles are initially uniformly distributed, so if the distribution
    changes over time, we know that some form of evolution is occurring. The angle
    distribution over the population doesn’t tell us everything about its character,
    but if we reach a point where the distribution has stopped evolving, this suggests
    that the population may have achieved some form of optimum in response to the
    selection pressure exerted by the predators.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 11-2](ch11.xhtml#ch11lis2)中运行仿真时，会在每个时间步长存储捕食者角度表中的角度分布。这些角度最初是均匀分布的，所以如果分布随时间变化，我们就知道某种形式的进化正在发生。种群的角度分布并不能告诉我们其所有特征，但如果我们达到一个分布停止变化的点，这表明种群可能已经在捕食者施加的选择压力下达到了某种最优状态。
- en: 'We can plot a histogram of the distribution at any step by extracting `moves_dist_data`
    from the model dataframe. The dataframe for the 20th run looks like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从模型数据框中提取`moves_dist_data`来绘制任意一步的分布直方图。第20次运行的数据框如下所示：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the call to plot the histogram from the last row in this dataframe:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是调用绘制直方图的代码，来自此数据框的最后一行：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We need the `LinearAlgebra` package for the `normalize()` function, which rescales
    the histogram of raw counts into one that can be interpreted as a probability
    density function (see “Probability Density Functions” on [page 325](ch10.xhtml#ch10lev1sec4)).
    This allows us to compare distributions from populations of different sizes directly.
    At this stage, there are 5,069 `Prey` agents, as can be read off from the dataframe,
    and comparing the distribution at earlier times shows that it seems to have converged
    to the shape shown in [Figure 11-2](ch11.xhtml#ch11fig2).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`LinearAlgebra`包来使用`normalize()`函数，它将原始计数的直方图重新缩放为可以解释为概率密度函数的形式（请参见[第325页](ch10.xhtml#ch10lev1sec4)的“概率密度函数”）。这使得我们能够直接比较不同大小种群的分布。在这一阶段，数据框中可以读取到有5,069个`Prey`代理，并且比较早期的分布显示，分布似乎已经收敛到[图
    11-2](ch11.xhtml#ch11fig2)所示的形态。
- en: '![Image](../images/ch11fig02.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch11fig02.jpg)'
- en: '*Figure 11-2: Evolved angle distribution*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-2：进化后的角度分布*'
- en: 'A bit of reflection reveals why the prey creatures may have evolved such a
    distribution. The predators are significantly faster than their prey (`SPEEDR`
    `= 1.5`) but they have severely limited agility: `LAA =` π`/128`, which means
    that they can turn no more than 1.4° in any step. If the prey try to run in a
    straight line, the predators are likely to catch them before they have a chance
    to reproduce. This fact produces the pronounced dip in the distribution near 0°.
    Making sharp turns of close to 180° buys the most time, and that’s where we find
    the peaks in the distribution.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一些反思揭示了为何猎物生物可能进化出了这样的分布。捕食者比猎物显著更快（`SPEEDR` `= 1.5`），但它们的灵活性极为有限：`LAA =` π`/128`，这意味着它们在任何一步骤中最多只能转动1.4°。如果猎物试图沿直线奔跑，捕食者很可能会在它们有机会繁殖之前抓住它们。这个事实导致了分布在接近0°时出现明显的下降。在接近180°的大转弯处，猎物能争取到最多的时间，这就是我们在分布中找到峰值的地方。
- en: If this idea, that the prey have “learned” to avoid predators with these particular
    attributes, is correct, then a different species of predator with different attributes
    should give rise to a different angle distribution.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个想法是正确的，即猎物已经“学会”避免具有这些特定属性的捕食者，那么具有不同属性的捕食者物种应该会导致不同的角度分布。
- en: To test this idea, we need simply to change the `LAA` and `SPEEDR` constants
    and run the simulation again. After trying this with `SPEEDR = 1.05` and `LAA`
    = π`/16`, we observe the distribution shown in [Figure 11-3](ch11.xhtml#ch11fig3)
    after 13,000 steps.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这个观点，我们只需要改变`LAA`和`SPEEDR`常量，并重新运行模拟。在尝试了`SPEEDR = 1.05`和`LAA = π/16`后，我们观察到在13,000步后，得到如[图11-3](ch11.xhtml#ch11fig3)所示的分布。
- en: '![Image](../images/ch11fig03.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch11fig03.jpg)'
- en: '*Figure 11-3: Evolved angle distribution with slower but more agile predators*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-3：进化后的角度分布，捕食者更慢但更灵活*'
- en: This result is distinctly different and admits a clear intuitive explanation.
    These predators can only travel 5 percent faster than the prey, so their potential
    victims can often survive long enough to reproduce by simply continuing in something
    close to a straight line. Although slow, they are far more agile than the predators
    in the previous simulation, able to turn through 11.25° at each step, so prey
    who make many large turns are more likely to be caught. Hence we see a distribution
    with a broad peak near 0°, falling off at larger angles.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果与之前的明显不同，并且有一个直观的解释。这些捕食者的速度仅比猎物快5%，因此猎物通常能够在接近直线的路径上生存足够长的时间以进行繁殖。尽管捕食者很慢，但它们比之前模拟中的捕食者要灵活得多，能够在每一步中转动11.25°，因此做出许多大幅度转弯的猎物更容易被捕获。因此，我们看到的分布在0°附近有一个宽阔的峰值，并且在较大角度时逐渐下降。
- en: The distribution evolution is suggestive, but let’s see if we can confirm the
    idea that the prey have evolved to be better predator avoiders. We’ll do this
    by comparing the evolved population to unevolved populations with uniform distributions
    of angles in their `moves` tables. Since we use a seeded random number generator,
    we can create ensembles of populations by running the simulation multiple times
    while varying the `SEED`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 分布演化具有启发性，但我们需要确认一个观点：猎物是否已经进化得更擅长避开捕食者。我们通过将进化后的种群与具有均匀角度分布的未进化种群进行比较来验证这一想法，这些种群的`moves`表格中的角度分布是均匀的。由于我们使用了种子随机数生成器，我们可以通过多次运行模拟并调整`SEED`来创建不同种群的集合。
- en: 'The ability of a population to survive in an environment with predators of
    a particular type is its *fitness*. The predators’ type in our model is defined
    by two parameters: `SPEEDR` and `LAA`, their speed and agility.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个种群在特定类型捕食者环境中的生存能力被称为其*适应度*。我们模型中的捕食者类型由两个参数定义：`SPEEDR`和`LAA`，即它们的速度和灵活性。
- en: To test the fitness of the initial, unevolved population, we start with 200
    `Prey` agents and 100 `Predator` agents, and turn off the `Prey` agents’ ability
    to reproduce. In such a situation, the prey population should decay roughly exponentially,
    eventually dwindling to zero. We perform this experiment 10 times.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试初始未进化种群的适应度，我们从200个`Prey`（猎物）代理和100个`Predator`（捕食者）代理开始，并关闭`Prey`代理的繁殖能力。在这种情况下，猎物种群应该会呈现大致指数衰减，最终趋于零。我们进行这个实验10次。
- en: To test the fitness of the evolved population, we load the model after 20,000
    steps and extract a random sample of 200 `Prey` agents from it. We put that sample
    into the arena with 100 predators and observe the population decay, repeating
    this experiment 10 times as well. Each experiment uses a different random seed,
    so we’ll get a different random sample each time.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试进化后种群的适应度，我们在模拟运行20,000步后加载模型，并从中提取200个`Prey`代理的随机样本。我们将该样本放入竞技场，与100个捕食者一起观察种群衰减过程，重复此实验10次。每次实验使用不同的随机种子，因此每次得到的随机样本都会不同。
- en: '[Figure 11-4](ch11.xhtml#ch11fig4) shows the results: the evolved population
    performs distinctly better than the initial population.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-4](ch11.xhtml#ch11fig4)显示了结果：进化后的种群明显表现得比初始种群要好。'
- en: '![Image](../images/ch11fig04.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch11fig04.jpg)'
- en: '*Figure 11-4: Comparing fitness*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-4：适应度比较*'
- en: Of course, the evolved population becomes extinct as well, as it must without
    the ability to reproduce. But the comparison shows that the sharpturn strategy
    suggested by [Figure 11-2](ch11.xhtml#ch11fig2) is effective, as this population
    decays more slowly.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，进化后的种群也会灭绝，因为没有繁殖能力。但比较结果表明，[图11-2](ch11.xhtml#ch11fig2)所示的急转弯策略是有效的，因为这个种群衰减得较慢。
- en: '**Conclusion**'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: 'In this chapter, I presented a complete, detailed example of a research problem:
    we began with some curiosity about whether we could simulate natural selection
    acting on specific attributes of a population. Then we made the question concrete
    by devising a scenario where behavior was codified by a list of eight numbers.
    Next, we constructed a simulation capturing the mechanisms we wanted to study
    and observed that the simulation displayed evolution of the population, apparently
    converging to some optimum. Lastly, we tested the evolved population and found
    that it did have increased fitness.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我展示了一个完整的、详细的研究问题示例：我们首先对是否可以模拟自然选择作用于种群的特定属性产生了好奇。然后，我们通过设计一个情景使问题变得具体，其中行为通过八个数字的列表来编码。接下来，我们构建了一个模拟，捕捉了我们想要研究的机制，并观察到模拟显示出种群的进化，显然趋向某个最优解。最后，我们测试了进化后的种群，发现其确实具有更强的适应性。
- en: The `Agents` package, and Julia’s expressiveness and efficiency, dramatically
    streamlined the path from initial speculation to a verifiable, quantitative, and
    easily visualized result. The ability to try out a variety of scenarios and analyze
    and view the results, all within a unified interactive environment, and with no
    compromise in performance, is an unprecedented boon for the researcher.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Agents`包以及Julia的表现力和高效性，大大简化了从初步假设到可验证、定量且易于可视化结果的路径。在一个统一的交互环境中尝试多种情境并分析和查看结果，同时不牺牲性能，对于研究人员来说是前所未有的福音。'
- en: '**FURTHER READING**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: For more information on BioJulia, the “bioinformatics infrastructure for the
    Julia language,” see [*https://biojulia.dev*](https://biojulia.dev).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关BioJulia（Julia语言的生物信息学基础设施）的更多信息，请访问[*https://biojulia.dev*](https://biojulia.dev)。
- en: 'The article “Julia for Biologists” provides an overview of the use of the language
    in biology: [*https://arxiv.org/abs/2109.09973*](https://arxiv.org/abs/2109.09973).'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文章“Julia for Biologists”概述了该语言在生物学中的应用：[ *https://arxiv.org/abs/2109.09973*](https://arxiv.org/abs/2109.09973)。
- en: More details on `Agents.jl` is available at [*https://juliadynamics.github.io/Agents.jl/stable/*](https://juliadynamics.github.io/Agents.jl/stable/).
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Agents.jl`的更多详细信息，请访问[*https://juliadynamics.github.io/Agents.jl/stable/*](https://juliadynamics.github.io/Agents.jl/stable/)。'
- en: 'Watch a video about `Agents.jl` here: [*https://youtu.be/Iaco6v6TVXk*](https://youtu.be/Iaco6v6TVXk).'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里观看关于`Agents.jl`的视频：[ *https://youtu.be/Iaco6v6TVXk*](https://youtu.be/Iaco6v6TVXk)。
- en: A detailed survey of the field of artificial life is available at [*https://www.ais.uni-bonn.de/SS09/skript_artif_life_pfeifer_unizh.pdf*](https://www.ais.uni-bonn.de/SS09/skript_artif_life_pfeifer_unizh.pdf).
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关人工生命领域的详细调研，请访问[*https://www.ais.uni-bonn.de/SS09/skript_artif_life_pfeifer_unizh.pdf*](https://www.ais.uni-bonn.de/SS09/skript_artif_life_pfeifer_unizh.pdf)。
- en: For interesting anecdotes about artificial life simulations, visit [*https://direct.mit.edu/artl/article/26/2/274/93255/The-Surprising-Creativity-of-Digital-Evolution-A*](https://direct.mit.edu/artl/article/26/2/274/93255/The-Surprising-Creativity-of-Digital-Evolution-A).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于人工生命模拟的有趣轶事，请访问[*https://direct.mit.edu/artl/article/26/2/274/93255/The-Surprising-Creativity-of-Digital-Evolution-A*](https://direct.mit.edu/artl/article/26/2/274/93255/The-Surprising-Creativity-of-Digital-Evolution-A)。
