- en: '**11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BIOLOGY**
  prefs: []
  type: TYPE_NORMAL
- en: '*Modern biology is becoming very much a branch of information technology.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Richard Dawkins
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As Professor Dawkins points out, computation has become a central tool in many
    areas of biology. This was perhaps inevitable, as evolution is the central organizing
    principle of biology, and evolution occurs through the transmission of information
    in the form of a digital storage device known as DNA.
  prefs: []
  type: TYPE_NORMAL
- en: The biology ecosystem around Julia is sophisticated, wide-ranging, and growing
    rapidly. The language and its packages are being used in many areas of biological
    and medical research, in both industry and academia.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter begins with a brief overview of the Julia biology landscape and
    proceeds directly to a detailed case study in simulated evolution.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Julia Biology Ecosystem**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bioinformatics has become a major subfield of biology that is defined by the
    use of computers. It mainly deals with the analysis and manipulation of protein
    sequences, so it has a strong computational linguistics flavor. The BioJulia GitHub
    organization provides a starting place for browsing this large collection of packages.
    It includes, among others, modules for handling the various file types that bioinformaticians
    have devised over the years.
  prefs: []
  type: TYPE_NORMAL
- en: To discover other Julia packages outside of the bioinformatics organization,
    we can turn to the general GitHub search methods described in “How to Find Public
    Packages” on [page 80](ch03.xhtml#ch03lev1sec14). Many of these packages do not
    include general tags such as “biology,” so you can find them more easily with
    focused searches using terms such as *phylogenetics* or *ecology*.
  prefs: []
  type: TYPE_NORMAL
- en: The `Pumas` pharmaceutical modeling and simulation toolkit merits particular
    mention as a major success story for Julia in medicine and biology. `Pumas` is
    used by major corporations and research groups to develop and test drugs. Its
    GitHub page contains links to extensive documentation and tutorials.
  prefs: []
  type: TYPE_NORMAL
- en: Many Julia biology packages were created to work with other packages in the
    areas of statistics, equation solving, or other areas useful in mathematical biology.
    An example is `EvolutionaryModelingTools`, which works with the `DifferentialEquations`
    package (see “Combining DifferentialEquations with Measurements” on [page 302](ch09.xhtml#ch09lev1sec20)),
    providing macros to assist in setting up problems that use Gillespie’s algorithm
    (a method for attacking stochastic differential equations) in the simulation of
    models of infectious disease propagation and problems with a similar structure.
  prefs: []
  type: TYPE_NORMAL
- en: '**Simulating Evolution with Agent-Based Modeling**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Agent-based modeling (ABM)* is a simulation technique using a community of
    computational entities, the *agents*, interacting with each other and their environment
    through a set of *rules*. The agents may be representations of life forms, vehicles,
    or something more abstract, such as information. The rules can depend on time,
    the distance between agents, their movement, the state of the environment near
    the agent, or nearly anything else we can imagine. Agents may move, store data,
    die, and be born. The environment itself can change as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Researchers have used ABM to simulate traffic flow, the progress of infectious
    diseases, the collective behavior of social animals, the spread of opinions, and
    much more. See “Further Reading” on [page 380](ch11.xhtml#fur11) for some links
    to background information about this approach, and to documentation of the main
    packages used in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Our project will be the simulation of evolution through natural selection in
    a population of two types of simple creatures representing predators and prey.
    We will see how the prey creatures, when allowed to inherit their “genes” from
    their parents, evolve to be better at evading their predators. This evolution
    results from random mutations in the inherited characteristics combined with the
    selection pressure from the predators eating the less evasive prey before they
    have a chance to reproduce.
  prefs: []
  type: TYPE_NORMAL
- en: The `Agents` package provides a framework for a wide variety of ABM calculations.
    It attends to the lower-level details, such as calculating the motions of agents,
    enforcing boundary conditions, and searching for neighbors, allowing us to concentrate
    on programming the rules for agent interaction at a fairly high level.
  prefs: []
  type: TYPE_NORMAL
- en: The space in which the agents live can be a continuous physical space (the one
    we will use here); a grid space on which agents can only occupy discrete positions;
    a more abstract tree space, in which agents are not located physically, but within
    a tree data structure; and even a space defined on an actual road map, using OpenStreetMap
    data. The space can become an environment containing spatially and temporally
    varying conditions affecting the agents.
  prefs: []
  type: TYPE_NORMAL
- en: The agents have position and velocity properties and a unique ID. We can endow
    them, as well, with any data structures convenient for our simulation. We can
    create or destroy agents, or change any of their properties, based on their proximity
    to other agents, on time, or on environmental conditions. Agent proximity—nearest
    neighbors or neighbors within a given radius—is returned by a simple function
    call.
  prefs: []
  type: TYPE_NORMAL
- en: Any particular project typically will make use of only a small subset of `Agents`’s
    capabilities, and this section’s project is no exception.
  prefs: []
  type: TYPE_NORMAL
- en: '**Overview of the Simulation Problem**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our universe will contain two types of creatures: predators and prey. Each
    type has a simple behavior. Predators chase prey. If a predator manages to get
    very close to its target, it vanishes from the simulation, devoured by its pursuer.
    The predators choose their targets from among all those within their detection
    range, but they are polite: they won’t chase prey that one of their colleagues
    is already chasing. Predators have only one speed, which is somewhat faster than
    the one speed with which the prey are able to run. They turn toward their prey
    as they chase them, but their superior speed is offset by limited agility: they
    can turn only through some maximum angle at every simulation step. Like some actual
    predator species, our simulated predators adjust their reproductive rate to maintain
    a certain ratio of predator population to prey population.'
  prefs: []
  type: TYPE_NORMAL
- en: The prey make turns at regular intervals according to a list of angles; each
    prey creature has its own list. When it reaches the end of the list, it goes back
    to the top. Prey don’t react to predators, they simply run around making their
    prescribed turns. One can imagine that their environment is rich with uniformly
    distributed food, as a property (which is called `mojo` in the program) gets incremented
    by a fixed amount at every step. If a prey creature manages to reach a predetermined
    amount of `mojo` without getting eaten, it reproduces. Reproduction is fatal;
    the creature is replaced by two descendants. Each descendant inherits a copy of
    its parent’s table of angles, with some random mutations.
  prefs: []
  type: TYPE_NORMAL
- en: The only property that distinguishes different prey individuals, aside from
    their locations and velocities, is the list of angles. We initialize the agents
    with a random list, uniformly distributed from –*π* to *π*. Some lists of turns
    will, by chance, be slightly better than others in allowing the agent to survive
    longer, as they will, on average, make it more difficult for the predators, with
    their limited agility, to catch it. These agents will be more likely to reproduce,
    as will their children. Through mutation, some of these children may be even more
    likely to survive to reproduce. We hope to observe an evolution in the distribution
    of angles in the prey population, and an average increase in the ability to evade
    predation, as a result of this selection pressure.
  prefs: []
  type: TYPE_NORMAL
- en: The foregoing is an overview of the structure and aims of the project. In the
    next few sections, we’ll put together all the components of our simulation, in
    the order in which they appear in the complete program, which is assembled for
    convenience in the code section of the web supplement for this chapter at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org).
    When turning these ideas into a program, we’ll have to make everything concrete.
    For example, we’ll decide to make the list of angles contain eight elements. Many
    of these details are, within limits, arbitrary, and the reader might experiment
    with altering all or some of them, and perhaps improve upon the experiment described
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Predator and Prey Agents**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Agents` package provides a convenient macro for defining our agents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: First we import the needed packages. In addition to `Agents`, we need `StatsBase`
    for creating histograms of the angle distributions, `JLD2` for saving and loading
    simulation data (see [Listing 9-4](ch09.xhtml#ch9lis4) on [page 289](ch09.xhtml#ch9lis4)),
    and `Random` for random numbers (see “Random Numbers in Julia” on [page 307](ch10.xhtml#ch10lev2)).
  prefs: []
  type: TYPE_NORMAL
- en: The `@agent` macro defines the agents as composite types. After executing the
    macros in the listing, we have an agent type called `Prey` and another called
    `Predator`. The `ContinuousAgent{2}` notation means that the agents are destined
    to live in a continuous, two-dimensional space, where their positions are defined
    by a tuple of two floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each instance of `Prey` is endowed with two properties: `mojo`, the float that
    will determine when it’s ready to reproduce; and `moves`, its vector of angles
    that determines the path it takes as it wanders blindly through the environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A predator has only one property: `victim` will be the ID of the individual
    prey that it’s chasing. If this is 0, it’s sitting still and waiting for a potential
    victim to wander within range.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Constants Defining Model Behavior***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Certain parameters determining model behavior are defined in a list of constants,
    shown in [Listing 11-1](ch11.xhtml#ch11lis1). We can alter these constants to
    experiment with evolution under different conditions without making changes to
    the program. These are declared `const`, a declaration we should apply to all
    global quantities in the interests of performance. In general, a program should
    not use non-`const` global variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-1: Constants defining the model*'
  prefs: []
  type: TYPE_NORMAL
- en: The predator population adjusts itself at every step to maintain the `PPR`,
    adding predators if needed and eliminating them if the ratio is more than 5 percent
    too large.
  prefs: []
  type: TYPE_NORMAL
- en: The parameter `M` is the length of the vector of angles that amounts to the
    prey’s genome. The prey will proceed in a straight line for `SBT` steps before
    turning through the next angle in the angle vector.
  prefs: []
  type: TYPE_NORMAL
- en: A predator can “see” a prey creature if it’s closer than the distance `TAD`.
    It begins chasing the first such prey that it sees that is not already being chased.
    If a predator manages to close the distance to its target to within `KD`, the
    target is eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: When a prey creature reproduces, it replaces itself with `LS` descendants.
  prefs: []
  type: TYPE_NORMAL
- en: The prey creatures eat continuously as they run, increasing their `mojo` by
    `MIPS` every step. The `mojo` is really just a measure of how long a creature
    has survived. Once a prey creature’s `mojo` has reached `MNFR`, it reproduces.
  prefs: []
  type: TYPE_NORMAL
- en: The predator’s straight-line speed is `SPEEDR` times the prey’s speed. The predator’s
    ability to corner is limited by `LAA`. It turns in the direction of the prey,
    adjusting its heading at every step, but can turn no more than `LAA` radians each
    time.
  prefs: []
  type: TYPE_NORMAL
- en: The `Agents` integration routine (a simple Euler step) uses a timestep of `dt`.
    This constant serves as an overall scale for agent speeds.
  prefs: []
  type: TYPE_NORMAL
- en: In order to be able to repeat simulations using identical sequences of random
    numbers, and to create ensembles of simulations when desired, we’ll use a random
    number generator with a seed that we can control (see “Random Numbers in Julia”
    on [page 307](ch10.xhtml#ch10lev2)). This is the purpose of `SEED` and the `rng`.
    Also, the `rand()` functions are somewhat more efficient when passed an `rng`,
    although this concern is not as acute as it has been in some past versions of
    Julia and the `Random` package.
  prefs: []
  type: TYPE_NORMAL
- en: '***Utility Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’d like to have a few functions to make the code that orients the predators
    and changes the direction of the prey more concise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We’re going to need to normalize velocity vectors, which means adjusting their
    lengths to unity. This is what `vnorm()` does. The `angle_between()` function
    returns the angle between two vectors. The predators need this to calculate where
    to turn when chasing their food. And turning, both of predators and prey, relies
    on `turn()`, which, when supplied with a starting vector and an angle, returns
    the vector rotated through the angle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we need a function to mutate the `moves` table. Without this,
    no evolution takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This makes a random change to a specified number of the angles in the table
    by an angle uniformly distributed from –*π*/4 to *π*/4.
  prefs: []
  type: TYPE_NORMAL
- en: '***Model Initialization***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every `Agents` simulation requires, in addition to the agents themselves, three
    data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `arena` is the space in which the agents live and interact. Our space will
    be continuous, have coordinates running from 0 to 1 along each dimension, and
    have periodic boundary conditions. This makes the space infinite in the sense
    that an agent running off the right side will reemerge on the left side.
  prefs: []
  type: TYPE_NORMAL
- en: The `properties` is a dictionary of quantities relating to the simulation as
    a whole. In our simulation we use it just to keep track of how many steps have
    passed. For keeping track of when it’s time for the prey to make a turn, we use
    `stepno` and increment `total_step` at each step. The former could be derived
    from the latter, but maintaining the two counters can be convenient when restarting
    a simulation from a saved state. We initialize both counters to 0.
  prefs: []
  type: TYPE_NORMAL
- en: With these two objects in place we can initialize the `model`, which maintains
    the whole simulation state. Checkpointing and restarting the simulation requires
    merely saving the `model` to disk. The two positional arguments of its constructor
    are the agent types and the space. If we had only one type of agent, the call
    would look like `ABM(Prey, arena; properties)`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: We choose `properties` for the name of the property dictionary because that
    name is used for a keyword in the model constructor, which makes the call to `ABM`
    simpler (see “Concise Syntax for Keyword Arguments” on [page 154](ch06.xhtml#ch06lev1sec1)).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*With the version of* Agents *used at the time of writing, we get a warning
    after constructing the model this way. The message warns us about a potential
    inefficiency when using a* Union *of agent types. This is an area of ongoing development
    effort, and the warning will probably disappear in future versions. The inefficiency
    doesn’t actually become a problem unless we use more than three agent types.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `model` defined, we can initialize it by adding the agents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add_agent!()` function is named using an exclamation point to remind us
    that it mutates one of its arguments: it alters `model` by adding agents to it.
    This function creates an agent at a random position within the `arena`. It expects
    an agent type as a first argument, the model in the second position, and a tuple
    giving the agent’s initial *x* and *y* velocities. Positional arguments following
    the third are passed to the agent constructor. Therefore, in the first loop, each
    `add_agent!()` call will create a `Prey` instance using `Prey(0.0, moves)`. The
    initial `mojo` is set to 0, and the starting vector of angles is randomly set
    ➊.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions to Extract Information from the Model**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s look at some more short utility functions that accept the `model` as an
    argument and return information about its current state. We’ll use some of them
    in the calculation and others to extract data that we’ll store and use later when
    we analyze the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we’ll need functions to give us a vector of all the prey or predators
    in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Inside the list comprehensions we use the `allagents()` function, which creates
    an iterator over the agents of a model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following suggestively named functions simply call the ones just shown
    and return the lengths of the agent vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the predators do not compete for prey with their colleagues, they need
    to know if a potential meal is already under pursuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This function returns a vector of all the `ID`s of prey creatures that are marked
    as victims by some predator. In order to determine if a potential meal is not
    already being chased, a predator checks whether its `ID` is in this list.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, we expect the vectors of angles to evolve. One way to
    get an overview of this process is to observe the evolution of the distribution
    of angles in the population (see “Distributions” on [page 321](ch10.xhtml#ch10lev7)
    for an overview of the concept of a distribution).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function gathers all the angles in all the `moves` vectors from
    all the prey creatures and returns a `Histogram` data structure representing a
    binning of the distribution into 40 equal buckets. We can then normalize and plot
    the results at various timesteps to analyze one aspect of the simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This function, and its use of `fit()` and the `Histogram` data structure, are
    the reason we imported the `StatsBase` package. The pattern in the comprehension
    in the second line, with its two `for` loops, is a common way to flatten a collection
    of collections.
  prefs: []
  type: TYPE_NORMAL
- en: '***Stepping Through the Simulation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `agent_step!()` and `model_step!()` functions are at the core of any `Agents`
    simulation. At every timestep, the `agent_step!()` function updates each agent
    as it’s selected by the *scheduler*. This update can include moving the agent,
    changing its velocity, altering the values of its properties, or anything else
    that makes sense to apply to individual agents. The scheduler is the component
    of the calculation that selects which agents to update and in what order. In most
    `Agents` simulations, we can leave the order unspecified; allowing the scheduler
    to update the agents in an arbitrary order is the fastest option.
  prefs: []
  type: TYPE_NORMAL
- en: After the `agent_step!()` function comes (by default) the `model_step!()` function,
    which makes updates that apply to the model as a whole. This includes updates
    that require access to the entire agent population, including those that search
    for near neighbors.
  prefs: []
  type: TYPE_NORMAL
- en: The `agent_step!()` function is required, but `model_step!()` is optional; our
    calculation uses both. Also, there is an option to perform `model_step!()` before
    `agent_step!()` if the calculation needs that.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stepping the Agents**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following shows the entire function for updating both predator and `Prey`
    agents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `agent_step!()` function (which can be named anything, but we’ve used the
    conventional name) must accept `agent` and `model` as arguments. The scheduler
    passes each agent in turn to the function as it cycles through them.
  prefs: []
  type: TYPE_NORMAL
- en: The first line moves the agent by an amount determined through the timestep,
    `dt`.
  prefs: []
  type: TYPE_NORMAL
- en: We then kill off any `Prey` agents that have been caught by the predators that
    are chasing them, where “caught” means that the distance between them has become
    less than `KD`. We use `euclidean_distance()`, a function built into the package,
    to measure this distance.
  prefs: []
  type: TYPE_NORMAL
- en: After the meal, the predator waits, stationary ➊, for another available prey
    to come within range.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the prey is too far away to eat, we continue the chase by turning toward
    it. The first step is finding the current angle between the predator’s velocity
    vector and the vector between the positions of the predator and its prey. Fortunately,
    `Agents` comes with a function just for this: `get_direction()`. In calling this
    function, we use two additional features of the `model`: an agent’s position tuple
    is available as `agent.pos`, and `model[i]` returns the agent with `ID i`. Although
    `model`s aren’t arrays, the `Agents` package defines a `getindex()` method that
    enables this. After limiting the turning angle ➋ to the predator’s agility, set
    with the constant `LAA`, we update its velocity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then check for any sufficiently close eligible prey: any `Prey` agent within
    a distance `TAD` that’s not already being chased. If we find one, we set the predator’s
    velocity vector to point toward the prey, again using `get_direction()` ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: Turning to the prey creatures, first we check if they have accumulated enough
    `mojo` to reproduce. Those who have enough give birth to `LS` copies, which are
    then mutated. We kill off the parent using the `kill_agent!()` function ➍, which
    is part of the `Agents` package.
  prefs: []
  type: TYPE_NORMAL
- en: When it’s time to make a turn, we rotate the velocity using our `turn()` function.
    We need to convert the result to a `Tuple` ➎ because the package uses those to
    store agent velocities.
  prefs: []
  type: TYPE_NORMAL
- en: 'After making the turn, we rotate the agent’s private turn table with a function
    that we’re using for the first time: `circshift()`, which rotates an array. This
    invocation rotates the `moves` vector to the left, so its second element becomes
    its first and its first becomes its last. The outcome is that the prey makes the
    `M` turns stored in `moves` repeatedly (if it survives long enough to do so).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stepping the Model**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'After the scheduler updates all the agents, it calls this function, passing
    the model as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First we increment `model_step`, using modular arithmetic to maintain a cycle
    of length `SBT`; then we increment the total step. Since `total_step`, as well
    as its other properties, is stored along with the model, we can checkpoint and
    seamlessly restart the simulation by using `JLD2` to save and reload the model,
    and `total_step` will keep track of how long it’s been run.
  prefs: []
  type: TYPE_NORMAL
- en: 'We maintain the predator/prey ratio specified with `PPR` by adding or removing
    predators as needed. The `add_agent()` function from `Agents` adds an agent at
    a random position. The tuple in the argument list is its initial velocity, and
    subsequent arguments are passed to the agent constructor. In this case, there
    is only one such argument: the initial `victim` property is set to 0.'
  prefs: []
  type: TYPE_NORMAL
- en: We remove agents by passing a random agent to `kill_agent()` using the function
    `random_agent()` ➊. This `Agents` function takes, in its optional second argument,
    a function expressing a condition that the potentially doomed agent must satisfy.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the routine maintains a logfile, writing an entry every `LI` steps.
    We `flush()` the logfile so that we can take a look at it while the simulation
    is running. Without this call, the file may not be written until the calculation
    ends.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Simulation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `run!()` function is `Agents`’s basic facility for stepping through a model,
    as shown in [Listing 11-2](ch11.xhtml#ch11lis2). Its four positional arguments
    are the model, the function for updating the agents, the optional function for
    updating the model, and the total number of steps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-2: Running the simulation*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It returns two dataframes (see “CSV Files” on [page 332](ch10.xhtml#ch10lev1sec6)):
    one for the agents and one for the model. The `adata` keyword argument is a `Vector`
    of quantities to include in the agent dataframe, and the `mdata` keyword argument
    is for the model dataframe. These quantities can be agent or model properties,
    which become symbols, or functions of the `model`. In the value for `mdata`, we’re
    using three functions that we defined with this in mind: we’re keeping track of
    the two population sizes and the angle distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve wrapped `run!()` in a function that calls it `nruns` times, each time
    asking it to run the model for `nsteps_per_run` steps, and uses the save function
    from `JLD2` to store the model dataframe and the entire model to disk.
  prefs: []
  type: TYPE_NORMAL
- en: To load the model from its saved version on disk, we can enter
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: where the string argument specifies the variable to be loaded from the file.
  prefs: []
  type: TYPE_NORMAL
- en: '***Visualizing System Behavior***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The most convenient way to get a snapshot of the model at any time, or to create
    an animation of its progress, is to use two functions provided by the `InteractiveDynamics`
    package, which needs a separate import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We need to import a `Makie` library as well because `InteractiveDynamics` uses
    it for drawing. `Makie` is a graphics framework along more or less the same lines
    as the current standard, `Plots`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we plan to create visualizations of our model with its two agent types,
    let’s create functions that map the agent types to two distinct colors and shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These functions, when used together, will render prey creatures as blue dots
    and predators as circles with dots inside them. Predators on the chase will be
    red, while idle predators will be green.
  prefs: []
  type: TYPE_NORMAL
- en: 'After evolving the model to any step using `run!()`, we can create and save
    a picture of its state with the following calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The plotting function, `abmplot()`, returns two values, of which we only need
    the first. The agent color (`ac`) and agent shape (`am`) use our functions defined
    earlier, and we set the agent marker size (`as`) to a value that worked well in
    the visualization. [Figure 11-1](ch11.xhtml#ch11fig1) shows the result after 10,000
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch11fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: The model configuration at step 10,000*'
  prefs: []
  type: TYPE_NORMAL
- en: At the moment shown in [Figure 11-1](ch11.xhtml#ch11fig1), there are 139 total
    agents. None of the predators happen to be idle at this moment, so they are all
    rendered in the same color.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create an animation of the model using `abmvideo()`, which is supplied
    by `InteractiveDynamics` as well. It actually runs the model, beginning with the
    initial state supplied in its second argument, stepping through it using the same
    step functions that we supply to `run!()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The run stops after the number of steps given in the `frames` keyword argument,
    and the video file is saved with the name given in the first argument. We can
    use constants or, as we did here, functions for agent shapes and colors, as in
    `abmplot()`. You can view some animations made with this method in the online
    supplement for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Animations are excellent devices for verifying that an ABM simulation is working
    as intended and for communicating the results when the dynamic behavior is interesting.
    However, running the model through `abmvideo()` is much slower than running it
    with `run!()` because, in addition to the model calculations, the function renders
    an image at each step using `abmplot()` and assembles a video file. A strategy
    for long-running agent simulations, therefore, may be to run the calculation using
    `run!()` and then render subsets of steps as animations. This strategy requires
    periodically saving the model, as we do in our example within `agent_step!()`,
    so we have various saved states available to start from.
  prefs: []
  type: TYPE_NORMAL
- en: Two additional quirks to note about `abmvideo()` are that it doesn’t use the
    convention of the exclamation point in its name, despite mutating the model, and
    that it cannot generate dataframes directly as can `run!()`. We can get around
    this last issue by putting data recording into `model_step!()`, as we did in our
    example with logging. This is a more flexible approach in any case, as it allows
    us more control over the recorded data. For example, we might decide to add a
    row to the dataframes less frequently than every step.
  prefs: []
  type: TYPE_NORMAL
- en: The `CairoMakie` graphics library is appropriate for making high-quality plots
    and animations saved in files. For more immediate feedback, we can import `GLMakie`
    instead. If both are imported, the calls `GLMakie.activate!()` and `CairoMakie.activate!()`
    switch between them. When `GLMakie` is active, `abmplot()` and `abmvideo()` open
    a dedicated graphics window when using the REPL, or they can insert graphics into
    a computational notebook.
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyzing the Results**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The call to run the simulation in [Listing 11-2](ch11.xhtml#ch11lis2) stores
    the distribution of angles in the prey angle tables in the model dataframe at
    every timestep. These angles are initially uniformly distributed, so if the distribution
    changes over time, we know that some form of evolution is occurring. The angle
    distribution over the population doesn’t tell us everything about its character,
    but if we reach a point where the distribution has stopped evolving, this suggests
    that the population may have achieved some form of optimum in response to the
    selection pressure exerted by the predators.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can plot a histogram of the distribution at any step by extracting `moves_dist_data`
    from the model dataframe. The dataframe for the 20th run looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the call to plot the histogram from the last row in this dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We need the `LinearAlgebra` package for the `normalize()` function, which rescales
    the histogram of raw counts into one that can be interpreted as a probability
    density function (see “Probability Density Functions” on [page 325](ch10.xhtml#ch10lev1sec4)).
    This allows us to compare distributions from populations of different sizes directly.
    At this stage, there are 5,069 `Prey` agents, as can be read off from the dataframe,
    and comparing the distribution at earlier times shows that it seems to have converged
    to the shape shown in [Figure 11-2](ch11.xhtml#ch11fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch11fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: Evolved angle distribution*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit of reflection reveals why the prey creatures may have evolved such a
    distribution. The predators are significantly faster than their prey (`SPEEDR`
    `= 1.5`) but they have severely limited agility: `LAA =` π`/128`, which means
    that they can turn no more than 1.4° in any step. If the prey try to run in a
    straight line, the predators are likely to catch them before they have a chance
    to reproduce. This fact produces the pronounced dip in the distribution near 0°.
    Making sharp turns of close to 180° buys the most time, and that’s where we find
    the peaks in the distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: If this idea, that the prey have “learned” to avoid predators with these particular
    attributes, is correct, then a different species of predator with different attributes
    should give rise to a different angle distribution.
  prefs: []
  type: TYPE_NORMAL
- en: To test this idea, we need simply to change the `LAA` and `SPEEDR` constants
    and run the simulation again. After trying this with `SPEEDR = 1.05` and `LAA`
    = π`/16`, we observe the distribution shown in [Figure 11-3](ch11.xhtml#ch11fig3)
    after 13,000 steps.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch11fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Evolved angle distribution with slower but more agile predators*'
  prefs: []
  type: TYPE_NORMAL
- en: This result is distinctly different and admits a clear intuitive explanation.
    These predators can only travel 5 percent faster than the prey, so their potential
    victims can often survive long enough to reproduce by simply continuing in something
    close to a straight line. Although slow, they are far more agile than the predators
    in the previous simulation, able to turn through 11.25° at each step, so prey
    who make many large turns are more likely to be caught. Hence we see a distribution
    with a broad peak near 0°, falling off at larger angles.
  prefs: []
  type: TYPE_NORMAL
- en: The distribution evolution is suggestive, but let’s see if we can confirm the
    idea that the prey have evolved to be better predator avoiders. We’ll do this
    by comparing the evolved population to unevolved populations with uniform distributions
    of angles in their `moves` tables. Since we use a seeded random number generator,
    we can create ensembles of populations by running the simulation multiple times
    while varying the `SEED`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability of a population to survive in an environment with predators of
    a particular type is its *fitness*. The predators’ type in our model is defined
    by two parameters: `SPEEDR` and `LAA`, their speed and agility.'
  prefs: []
  type: TYPE_NORMAL
- en: To test the fitness of the initial, unevolved population, we start with 200
    `Prey` agents and 100 `Predator` agents, and turn off the `Prey` agents’ ability
    to reproduce. In such a situation, the prey population should decay roughly exponentially,
    eventually dwindling to zero. We perform this experiment 10 times.
  prefs: []
  type: TYPE_NORMAL
- en: To test the fitness of the evolved population, we load the model after 20,000
    steps and extract a random sample of 200 `Prey` agents from it. We put that sample
    into the arena with 100 predators and observe the population decay, repeating
    this experiment 10 times as well. Each experiment uses a different random seed,
    so we’ll get a different random sample each time.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-4](ch11.xhtml#ch11fig4) shows the results: the evolved population
    performs distinctly better than the initial population.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch11fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Comparing fitness*'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the evolved population becomes extinct as well, as it must without
    the ability to reproduce. But the comparison shows that the sharpturn strategy
    suggested by [Figure 11-2](ch11.xhtml#ch11fig2) is effective, as this population
    decays more slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, I presented a complete, detailed example of a research problem:
    we began with some curiosity about whether we could simulate natural selection
    acting on specific attributes of a population. Then we made the question concrete
    by devising a scenario where behavior was codified by a list of eight numbers.
    Next, we constructed a simulation capturing the mechanisms we wanted to study
    and observed that the simulation displayed evolution of the population, apparently
    converging to some optimum. Lastly, we tested the evolved population and found
    that it did have increased fitness.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Agents` package, and Julia’s expressiveness and efficiency, dramatically
    streamlined the path from initial speculation to a verifiable, quantitative, and
    easily visualized result. The ability to try out a variety of scenarios and analyze
    and view the results, all within a unified interactive environment, and with no
    compromise in performance, is an unprecedented boon for the researcher.
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on BioJulia, the “bioinformatics infrastructure for the
    Julia language,” see [*https://biojulia.dev*](https://biojulia.dev).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The article “Julia for Biologists” provides an overview of the use of the language
    in biology: [*https://arxiv.org/abs/2109.09973*](https://arxiv.org/abs/2109.09973).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details on `Agents.jl` is available at [*https://juliadynamics.github.io/Agents.jl/stable/*](https://juliadynamics.github.io/Agents.jl/stable/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Watch a video about `Agents.jl` here: [*https://youtu.be/Iaco6v6TVXk*](https://youtu.be/Iaco6v6TVXk).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A detailed survey of the field of artificial life is available at [*https://www.ais.uni-bonn.de/SS09/skript_artif_life_pfeifer_unizh.pdf*](https://www.ais.uni-bonn.de/SS09/skript_artif_life_pfeifer_unizh.pdf).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For interesting anecdotes about artificial life simulations, visit [*https://direct.mit.edu/artl/article/26/2/274/93255/The-Surprising-Creativity-of-Digital-Evolution-A*](https://direct.mit.edu/artl/article/26/2/274/93255/The-Surprising-Creativity-of-Digital-Evolution-A).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
