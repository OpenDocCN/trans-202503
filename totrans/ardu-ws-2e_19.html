<html><head></head><body>
		<section>&#13;
			<header>&#13;
				<h1 class="chapter"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_351" title="351"/>20</span><br/><span class="ChapterTitle">Real-Time Clocks</span></h1>&#13;
			</header>&#13;
			<p class="ChapterIntro">In this chapter you will</p>&#13;
			<ul>&#13;
				<li>Set and retrieve the time and date from a real-time clock module</li>&#13;
				<li>Discover new ways to connect devices to an Arduino</li>&#13;
				<li>Create a digital clock</li>&#13;
				<li>Build an employee RFID time clock</li>&#13;
			</ul>&#13;
			<p>&#13;
				A <em>real-time clock (RTC)</em> IC module is a small timekeeping device that opens up all sorts of possibilities for Arduino projects. Once set with the current time and date, an RTC provides accurate time and date data on request.</p>&#13;
			<p>&#13;
				You’ll find many different RTC ICs on the market, some more accurate than others. In this chapter, we’ll use the Maxim DS3231; it doesn’t require any external circuitry other than a backup battery, and it’s incredibly accurate and quite robust in module form. The DS3231 is available as a breakout board from various retailers, including the version from PMD Way (part number 883422) that is shown in <a href="#figure20-1" id="figureanchor20-1">Figure 20-1</a>.</p>&#13;
				<span epub:type="pagebreak" id="Page_352" title="352"/>&#13;
				<figure>&#13;
				<img alt="f20001" src="image_fi/500587c20/f20001.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure20-1">Figure 20-1</a>: A real-time clock IC module</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h2 id="h1-500587c20-0001">Connecting the RTC Module</h2>&#13;
			<p class="BodyFirst">It’s easy to connect the RTC module to an Arduino, because it uses the I<sup>2</sup>C bus (discussed in <span class="xref" itemid="xref_target_Chapter 19">Chapter 19</span>). All you need are four wires: GND and VCC go to Arduino GND and 5 V, respectively; SDA and SCL go to Arduino A4 and A5, respectively. We will not use the other pins in our examples. Due to the module’s design, no extra pull-up resistors are required on the I<sup>2</sup>C bus.</p>&#13;
			<p>For convenience, consider mounting the module on a blank ProtoShield so it can be integrated easily with other hardware for other projects. And make sure you have the backup battery installed, or your time data will be lost when you turn off the project!</p>&#13;
			<h2 class="HeadProject" id="h1-500587c20-0002"><span>Project #57: Adding and Displaying Time and Date with an RTC</span></h2>&#13;
			<p class="BodyFirst">In this project, you’ll learn how to set the time and date on the RTC and then retrieve and display it in the Serial Monitor. Time and date information can be useful for various types of projects, such as temperature loggers and alarm clocks.</p>&#13;
			<h3 id="h2-500587c20-0001">The Hardware</h3>&#13;
			<p class="BodyFirst">Here’s what you’ll need to create this project:</p>&#13;
			<ul>&#13;
				<li>Arduino and USB cable</li>&#13;
				<li>Various connecting wires</li>&#13;
				<li>One CR2032 battery (if not included with the DS3231 module)</li>&#13;
				<li>One Maxim DS3231 RTC module</li>&#13;
			</ul>&#13;
			<h3 id="h2-500587c20-0002"><span epub:type="pagebreak" id="Page_353" title="353"/>The Sketch</h3>&#13;
			<p class="BodyFirst">Connect the module to the Arduino as described earlier in the chapter and then enter but <em>do not upload</em> the following sketch:</p>&#13;
			<pre><code>// Project 57 - Adding and Displaying Time and Date with an RTC<span aria-label="annotation1" class="CodeAnnotationHang">1</span> #include "Wire.h" &#13;
#define DS3231_I2C_ADDRESS 0x68 &#13;
// Convert normal decimal numbers to binary coded decimal<span aria-label="annotation2" class="CodeAnnotationHang">2</span> byte decToBcd(byte val) &#13;
{ return( (val/10*16) + (val%10) );&#13;
}&#13;
// Convert binary coded decimal to normal decimal numbers&#13;
byte bcdToDec(byte val) &#13;
{ return( (val/16*10) + (val%16) );&#13;
}<span aria-label="annotation3" class="CodeAnnotationHang">3</span> void setDS3231time(byte second, byte minute, byte hour, byte dayOfWeek, byte&#13;
dayOfMonth, byte month, byte year) &#13;
{ // sets time and date data in the DS3231 Wire.beginTransmission(DS3231_I2C_ADDRESS);   Wire.write(0); // set next input to start at the seconds register Wire.write(decToBcd(second));     // set seconds Wire.write(decToBcd(minute));     // set minutes Wire.write(decToBcd(hour));       // set hours Wire.write(decToBcd(dayOfWeek));  // set day of week (1=Sunday, 7=Saturday) Wire.write(decToBcd(dayOfMonth)); // set date (1 to 31) Wire.write(decToBcd(month));      // set month Wire.write(decToBcd(year));       // set year (0 to 99) Wire.endTransmission();&#13;
}<span aria-label="annotation4" class="CodeAnnotationHang">4</span> void readDS3231time(byte *second, &#13;
byte *minute, &#13;
byte *hour, &#13;
byte *dayOfWeek, &#13;
byte *dayOfMonth, &#13;
byte *month, &#13;
byte *year)&#13;
{ Wire.beginTransmission(DS3231_I2C_ADDRESS); Wire.write(0); // set DS3231 register pointer to 00h Wire.endTransmission();   Wire.requestFrom(DS3231_I2C_ADDRESS, 7);  // request seven bytes of data from DS3231 starting from register 00h *second     = bcdToDec(Wire.read() &amp; 0x7f); *minute     = bcdToDec(Wire.read());<span epub:type="pagebreak" id="Page_354" title="354"/>  *hour       = bcdToDec(Wire.read() &amp; 0x3f);   *dayOfWeek  = bcdToDec(Wire.read()); *dayOfMonth = bcdToDec(Wire.read()); *month      = bcdToDec(Wire.read()); *year       = bcdToDec(Wire.read());&#13;
}&#13;
void displayTime()&#13;
{ byte second, minute, hour, dayOfWeek, dayOfMonth, month, year;   // retrieve data from DS3231 <span aria-label="annotation5" class="CodeAnnotationHang">5</span>   readDS3231time(&amp;second, &amp;minute, &amp;hour, &amp;dayOfWeek, &amp;dayOfMonth, &amp;month,  &amp;year);  // send it to the Serial Monitor Serial.print(hour, DEC); // convert the byte variable to a decimal number when displayed Serial.print(":"); if (minute&lt;10) { Serial.print("0"); } Serial.print(minute, DEC); Serial.print(":"); if (second&lt;10) { Serial.print("0"); } Serial.print(second, DEC); Serial.print("  "); Serial.print(dayOfMonth, DEC); Serial.print("/"); Serial.print(month, DEC); Serial.print("/"); Serial.print(year, DEC); Serial.print("  Day of week: "); switch(dayOfWeek){ case 1: Serial.println("Sunday"); break; case 2: Serial.println("Monday"); break; case 3: Serial.println("Tuesday"); break; case 4: Serial.println("Wednesday"); break; case 5: Serial.println("Thursday"); break; case 6:<span epub:type="pagebreak" id="Page_355" title="355"/>    Serial.println("Friday"); break; case 7: Serial.println("Saturday"); break; }&#13;
}&#13;
void setup()&#13;
{ Wire.begin();  Serial.begin(9600); // set the initial time here:  // DS3231 seconds, minutes, hours, day, date, month, year<span aria-label="annotation6" class="CodeAnnotationHang">6</span>   setDS3231time(0, 56, 23, 6, 30, 10, 21); &#13;
}&#13;
void loop()&#13;
{ displayTime(); // display the real-time clock data in the Serial Monitor, delay(1000);   // every second&#13;
}</code></pre>&#13;
			<h3 id="h2-500587c20-0003">Understanding and Running the Sketch</h3>&#13;
			<p class="BodyFirst">This sketch might look complex, but it’s really not so difficult. At <span aria-label="annotation1" class="CodeAnnotation">1</span>, we import the I<sup>2</sup>C library and set the bus address of the RTC in the sketch as <code>0x68</code>. This is the default bus address for the DS3231 and is found in the data sheet. At <span aria-label="annotation2" class="CodeAnnotation">2</span>, two custom functions convert decimal numbers to binary coded decimal (BCD) values and return those values. We perform these conversions because the DS3231 stores values in BCD format.</p>&#13;
			<p>&#13;
				At <span aria-label="annotation6" class="CodeAnnotation">6</span>, we use the function <code>setDS3231time()</code> to pass the time and date information to the RTC IC like this:</p>&#13;
			<pre><code>setDS3231time(<var>second</var>, <var>minute</var>, <var>hour</var>, <var>dayOfWeek</var>, <var>dayOfMonth</var>, <var>month</var>, <var>year</var>)</code></pre>&#13;
			<p>&#13;
				To use this function, simply insert the required data into the various parameters. The <var>dayOfWeek</var> parameter is a number between 1 and 7 representing Sunday through Saturday, respectively. (The RTC doesn’t have the ability to check whether <var>dayOfWeek</var> actually matches the date you enter, so take extra care to ensure everything lines up.) The information for <var>year</var> is only two digits—for example, you’d use <code>21</code> for the year 2021. (The 20 is assumed.) You can insert either fixed values (as in this sketch) or byte variables that contain the parameters.</p>&#13;
			<p>&#13;
				Thus, to set the time in the RTC, we enter the current date and time values into the <code>setDS3231time()</code> function at <span aria-label="annotation3" class="CodeAnnotation">3</span>. Now we can upload the sketch. Having done that once, we comment out the function by placing <code>//</code> in front of the <code>setDS3231time()</code> function at <span aria-label="annotation3" class="CodeAnnotation">3</span>, and then we re-upload the sketch to ensure that the time isn’t reset to the original value every time the sketch starts!</p>&#13;
			<p><span epub:type="pagebreak" id="Page_356" title="356"/>Finally, the function <code>readDS3231time()</code> at <span aria-label="annotation4" class="CodeAnnotation">4</span> reads the time and date from the RTC and inserts the data into byte variables. This data is used at <span aria-label="annotation5" class="CodeAnnotation">5</span> inside the function <code>displayTime()</code>, which simply retrieves the data and displays it in the Serial Monitor by printing the contents of the time variables.</p>&#13;
			<p>&#13;
				Once you’ve uploaded your sketch, open the Serial Monitor. The results should look similar to those shown in <a href="#figure20-2" id="figureanchor20-2">Figure 20-2</a>, but they will vary to reflect the current time and date when you run the sketch.</p>&#13;
			<figure>&#13;
				<img alt="f20002" src="image_fi/500587c20/f20002.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure20-2">Figure 20-2</a>: Results from Project 57</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				You can use the contents of the sketch for Project 57 as the basis for other time-related projects. The functions <code>decToBcd()</code>, <code>bcdToDec()</code>, <code>readDS3231time()</code>, and <code>setDS3231time()</code> can be inserted and thus reused in future projects. That’s one of the benefits of using the Arduino platform: once you write a useful procedure, it can often be reused later with little or no modification.</p>&#13;
			<h2 class="HeadProject" id="h1-500587c20-0003"><span>Project #58: Creating a Simple Digital Clock</span></h2>&#13;
			<p class="BodyFirst">In this project, we’ll use the functions from Project 57 to display the time and date on a standard character LCD, similar to the one used in the GPS receiver in Project 43 in <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span>.</p>&#13;
			<h3 id="h2-500587c20-0004">The Hardware</h3>&#13;
			<p class="BodyFirst">Here’s what you’ll need to create this project:</p>&#13;
			<ul>&#13;
				<li>Arduino and USB cable</li>&#13;
				<li>Various connecting wires</li>&#13;
				<li>One breadboard</li>&#13;
				<li>One Proto-ScrewShield or similar product</li>&#13;
				<li>One LCD module or LCD shield</li>&#13;
				<li>One real-time clock module (shown earlier in the chapter)</li>&#13;
			</ul>&#13;
			<p><span epub:type="pagebreak" id="Page_357" title="357"/>First, re-create the hardware used in Project 57. If you connected the RTC module with wires into the Arduino, use a Proto-ScrewShield instead to interface with the RTC. Then insert your LCD shield on top of the other shields.</p>&#13;
			<h3 id="h2-500587c20-0005">The Sketch</h3>&#13;
			<p class="BodyFirst">Enter but <em>do not upload</em> the following sketch:</p>&#13;
			<pre><code>// Project 58 - Creating a Simple Digital Clock&#13;
#include "Wire.h"<span aria-label="annotation1" class="CodeAnnotationHang">1</span> #include &lt;LiquidCrystal.h&gt; &#13;
#define DS3231_I2C_ADDRESS 0x68&#13;
LiquidCrystal lcd( 8, 9, 4, 5, 6, 7 );&#13;
// Convert normal decimal numbers to binary coded decimal&#13;
byte decToBcd(byte val)&#13;
{ return( (val/10*16) + (val%10) );&#13;
}&#13;
// Convert binary coded decimal to normal decimal numbers&#13;
byte bcdToDec(byte val)&#13;
{ return( (val/16*10) + (val%16) );&#13;
}&#13;
void setDS3231time(byte second, byte minute, byte hour, byte dayOfWeek, byte dayOfMonth, byte month, byte year)&#13;
{ // sets time and date data in the DS3231 Wire.beginTransmission(DS3231_I2C_ADDRESS);   Wire.write(0);  // set next input to start at the seconds register Wire.write(decToBcd(second));     // set seconds Wire.write(decToBcd(minute));     // set minutes Wire.write(decToBcd(hour));       // set hours Wire.write(decToBcd(dayOfWeek));  // set day of week (1=Sunday, 7=Saturday) Wire.write(decToBcd(dayOfMonth)); // set date (1 to 31) Wire.write(decToBcd(month));      // set month Wire.write(decToBcd(year));       // set year (0 to 99) Wire.endTransmission();&#13;
}&#13;
void readDS3231time(byte *second, &#13;
byte *minute, &#13;
byte *hour, &#13;
byte *dayOfWeek, &#13;
byte *dayOfMonth, &#13;
byte *month, &#13;
byte *year)&#13;
{ Wire.beginTransmission(DS3231_I2C_ADDRESS); Wire.write(0); // set DS3231 register pointer to 00h Wire.endTransmission(); <span epub:type="pagebreak" id="Page_358" title="358"/>  Wire.requestFrom(DS3231_I2C_ADDRESS, 7);  // request seven bytes of data from DS3231 starting from register 00h *second     = bcdToDec(Wire.read() &amp; 0x7f); *minute     = bcdToDec(Wire.read()); *hour       = bcdToDec(Wire.read() &amp; 0x3f);   *dayOfWeek  = bcdToDec(Wire.read()); *dayOfMonth = bcdToDec(Wire.read()); *month      = bcdToDec(Wire.read()); *year       = bcdToDec(Wire.read());&#13;
}&#13;
void displayTime()&#13;
{ byte second, minute, hour, dayOfWeek, dayOfMonth, month, year; // retrieve data from DS3231 readDS3231time(&amp;second, &amp;minute, &amp;hour, &amp;dayOfWeek, &amp;dayOfMonth, &amp;month,  &amp;year); // send the data to the LCD shield lcd.clear(); lcd.setCursor(4,0); lcd.print(hour, DEC); lcd.print(":"); if (minute&lt;10) { lcd.print("0"); } lcd.print(minute, DEC); lcd.print(":"); if (second&lt;10) { lcd.print("0"); } lcd.print(second, DEC); lcd.setCursor(0,1); switch(dayOfWeek){ case 1: lcd.print("Sun"); break; case 2: lcd.print("Mon"); break; case 3: lcd.print("Tue"); break; case 4: lcd.print("Wed"); break; case 5: lcd.print("Thu"); break; case 6:<span epub:type="pagebreak" id="Page_359" title="359"/>    lcd.print("Fri"); break; case 7: lcd.print("Sat"); break; } lcd.print(" "); lcd.print(dayOfMonth, DEC); lcd.print("/"); lcd.print(month, DEC); lcd.print("/"); lcd.print(year, DEC);&#13;
}&#13;
void setup()&#13;
{ Wire.begin();<span aria-label="annotation2" class="CodeAnnotationHang">2</span>   lcd.begin(16, 2);   // set the initial time here:  // DS3231 seconds, minutes, hours, day, date, month, year<span aria-label="annotation3" class="CodeAnnotationHang">3</span>   // setDS3231time(0, 27, 0, 5, 15, 11, 20); &#13;
}&#13;
void loop()&#13;
{ displayTime(); // display the real-time clock time on the LCD, delay(1000);   // every second&#13;
}</code></pre>&#13;
			<h3 id="h2-500587c20-0006">Understanding and Running the Sketch</h3>&#13;
			<p class="BodyFirst">The operation of this sketch is similar to that of Project 57, except in this case, we’ve altered the function <code>displayTime()</code> to send time and date data to the LCD instead of to the Serial Monitor, and we’ve added the setup lines required for the LCD at <span aria-label="annotation1" class="CodeAnnotation">1</span> and <span aria-label="annotation2" class="CodeAnnotation">2</span>. (For a refresher on using the LCD module, see <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>.)</p>&#13;
			<p>&#13;
				Don’t forget to upload the sketch first with the time and date data entered at <span aria-label="annotation3" class="CodeAnnotation">3</span>, and then re-upload the sketch with that code commented out. After uploading the sketch, your results should be similar to those shown in <a href="#figure20-3" id="figureanchor20-3">Figure 20-3</a>.</p>&#13;
			<figure>&#13;
				<img alt="f20003" src="image_fi/500587c20/f20003.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure20-3">Figure 20-3</a>: Display from Project 58</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>Now that you’ve worked through Projects 57 and 58, you should have a sense of how to read and write data from and to the RTC IC in your sketches. Next, you’ll use what you’ve learned so far to create something really useful.</p>&#13;
			<h2 class="HeadProject" id="h1-500587c20-0004"><span><span epub:type="pagebreak" id="Page_360" title="360"/>Project #59: Creating an RFID Time-Clock System</span></h2>&#13;
			<p class="BodyFirst">In this project, we’ll create a time-clock system. You’ll see how Arduino shields can work together and how the Proto-ScrewShield helps you introduce electronic parts that aren’t mounted on a shield. This system can be used by two people who are assigned an RFID card or tag that they’ll swipe over an RFID reader when they enter or leave an area (such as the workplace or a home). The time and card details will be recorded to a microSD card for later analysis.</p>&#13;
			<p>&#13;
				We covered logging data to a microSD card in <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span>, reading RFID tags in <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span>, and connecting to the RTC module earlier in this chapter. Now we’ll put the pieces together.</p>&#13;
			<h3 id="h2-500587c20-0007">The Hardware</h3>&#13;
			<p class="BodyFirst">Here’s what you’ll need to create this project:</p>&#13;
			<ul>&#13;
				<li>Arduino and USB cable</li>&#13;
				<li>Various connecting wires</li>&#13;
				<li>One real-time clock module (shown earlier in the chapter)</li>&#13;
				<li>One LCD module or Freetronics LCD shield</li>&#13;
				<li>&#13;
					One microSD card shield and card (from <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span>)</li>&#13;
				<li>One Proto-ScrewShield or similar product</li>&#13;
				<li>&#13;
					One RFID reader module and two tags (from <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span>)</li>&#13;
			</ul>&#13;
			<p>&#13;
				To assemble the system, start with the Arduino Uno at the bottom and then add your Proto-ScrewShield, the microSD card shield atop the ProtoScrewShield, and the LCD shield on top of the microSD card shield. Connect the RFID reader as you did in <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span> and connect the RTC module as described earlier in this chapter. Depending on the exact hardware used, the assembly should look similar to that shown in <a href="#figure20-4" id="figureanchor20-4">Figure 20-4</a>.</p>&#13;
			<figure>&#13;
				<img alt="f20004" src="image_fi/500587c20/f20004.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure20-4">Figure 20-4</a>: The time clock assembly</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c20-0008"><span epub:type="pagebreak" id="Page_361" title="361"/>The Sketch</h3>&#13;
			<p class="BodyFirst">Now enter and upload the following sketch. Remember that when you’re uploading sketches to an RFID-connected Arduino, you need to ensure that you remove the wire between the RFID reader’s RX and Arduino pin D0, then reconnect it once the sketch has been uploaded successfully.</p>&#13;
			<pre><code>// Project 59 - Creating an RFID Time-Clock System<span aria-label="annotation1" class="CodeAnnotationHang">1</span> #include "Wire.h" // for RTC <span aria-label="annotation2" class="CodeAnnotationHang">2</span> #include "SD.h"   // for SD card &#13;
#include &lt;LiquidCrystal.h&gt;&#13;
#define DS3231_I2C_ADDRESS 0x68 &#13;
LiquidCrystal lcd( 8, 9, 4, 5, 6, 7 );&#13;
int data1 = 0;<span aria-label="annotation3" class="CodeAnnotationHang">3</span> // Use Listing 18-1 to find your tag numbers &#13;
int Mary[14] = {  2, 52, 48, 48, 48, 56, 54, 67, 54, 54, 66, 54, 66, 3}; &#13;
int John[14] = {  2, 52, 48, 48, 48, 56, 54, 66, 49, 52, 70, 51, 56, 3}; &#13;
int newtag[14] = {  0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // used for read comparisons&#13;
// Convert normal decimal numbers to binary coded decimal&#13;
byte decToBcd(byte val) &#13;
{ return( (val/10*16) + (val%10) );&#13;
}&#13;
// Convert binary coded decimal to normal decimal numbers&#13;
byte bcdToDec(byte val) &#13;
{ return( (val/16*10) + (val%16) );&#13;
}&#13;
void setDS3231time(byte second, byte minute, byte hour, byte dayOfWeek, byte dayOfMonth, byte month, byte year) &#13;
{ // Sets time and date data in the DS3231 Wire.beginTransmission(DS3231_I2C_ADDRESS);   Wire.write(0);  // set next input to start at the seconds register Wire.write(decToBcd(second));     // set seconds Wire.write(decToBcd(minute));     // set minutes Wire.write(decToBcd(hour));       // set hours Wire.write(decToBcd(dayOfWeek));  // set day of week (1=Sunday, 7=Saturday) Wire.write(decToBcd(dayOfMonth)); // set date (1 to 31) Wire.write(decToBcd(month));      // set month Wire.write(decToBcd(year));       // set year (0 to 99) Wire.endTransmission();&#13;
}&#13;
void readDS3231time(byte *second, <span epub:type="pagebreak" id="Page_362" title="362"/>byte *minute, &#13;
byte *hour, &#13;
byte *dayOfWeek, &#13;
byte *dayOfMonth, &#13;
byte *month, &#13;
byte *year) &#13;
{ Wire.beginTransmission(DS3231_I2C_ADDRESS); Wire.write(0); // set DS3231 register pointer to 00h Wire.endTransmission();   Wire.requestFrom(DS3231_I2C_ADDRESS, 7);  // Request seven bytes of data from DS3231 starting from register 00h *second     = bcdToDec(Wire.read() &amp; 0x7f); *minute     = bcdToDec(Wire.read()); *hour       = bcdToDec(Wire.read() &amp; 0x3f);   *dayOfWeek  = bcdToDec(Wire.read()); *dayOfMonth = bcdToDec(Wire.read()); *month      = bcdToDec(Wire.read()); *year       = bcdToDec(Wire.read());&#13;
}&#13;
// Compares two arrays and returns true if identical.&#13;
// This is good for comparing tags.&#13;
boolean comparetag(int aa[14], int bb[14]) &#13;
{ boolean ff=false; int fg=0; for (int cc=0; cc&lt;14; cc++) { if (aa[cc]==bb[cc]) { fg++; } } if (fg==14) { ff=true;      // all 14 elements in the array match each other } return ff;&#13;
}&#13;
void wipeNewTag() &#13;
{ for (int i=0; i&lt;=14; i++) { newtag[i]=0; }&#13;
}&#13;
void setup()&#13;
{ Serial.flush(); // need to flush serial buffer Serial.begin(9600);<span epub:type="pagebreak" id="Page_363" title="363"/>  Wire.begin();  lcd.begin(16, 2); // set the initial time here:  // DS3231 seconds, minutes, hours, day, date, month, year // setDS3231time(0, 27, 0, 5, 15, 11, 12);  // Check that the microSD card exists and can be used <span aria-label="annotation4" class="CodeAnnotationHang">4</span>   if (!SD.begin(8))    { lcd.print("uSD card failure"); // stop the sketch return; } lcd.print("uSD card OK"); delay(1000); lcd.clear(); &#13;
}&#13;
}&#13;
void loop()&#13;
{ byte second, minute, hour, dayOfWeek, dayOfMonth, month, year; if (Serial.available() &gt; 0) // if a read has been attempted { // read the incoming number on serial RX delay(100);  // allow time for the data to come in from the serial buffer  for (int z=0; z&lt;14; z++)  // read the rest of the tag { data1=Serial.read(); newtag[z]=data1; } Serial.flush(); // stops multiple reads // retrieve data from DS3231  readDS3231time(&amp;second, &amp;minute, &amp;hour, &amp;dayOfWeek, &amp;dayOfMonth, &amp;month,  &amp;year); } // now do something based on the tag type<span aria-label="annotation5" class="CodeAnnotationHang">5</span>   if (comparetag(newtag, Mary) == true)  { lcd.print("Hello Mary "); File dataFile = SD.open("DATA.TXT", FILE_WRITE); if (dataFile)   { dataFile.print("Mary "); dataFile.print(hour); dataFile.print(":"); if (minute&lt;10) { dataFile.print("0"); } dataFile.print(minute); dataFile.print(":"); if (second&lt;10) { dataFile.print("0"); } dataFile.print(second); dataFile.print(" "); dataFile.print(dayOfMonth);<span epub:type="pagebreak" id="Page_364" title="364"/>      dataFile.print("/"); dataFile.print(month); dataFile.print("/"); dataFile.print(year); dataFile.println(); dataFile.close();  } delay(1000); lcd.clear(); wipeNewTag();    } if (comparetag(newtag, John)==true)  { lcd.print("Hello John "); File dataFile = SD.open("DATA.TXT", FILE_WRITE); if (dataFile)   { dataFile.print("John ");    dataFile.print(hour); dataFile.print(":");       if (minute&lt;10) { dataFile.print("0"); } dataFile.print(minute); dataFile.print(":");     if (second&lt;10) { dataFile.print("0"); } dataFile.print(second); dataFile.print(" "); dataFile.print(dayOfMonth); dataFile.print("/"); dataFile.print(month); dataFile.print("/"); dataFile.print(year); dataFile.println(); dataFile.close();  } delay(1000); lcd.clear(); wipeNewTag();    }&#13;
}</code></pre>&#13;
			<h3 id="h2-500587c20-0009">Understanding the Sketch</h3>&#13;
			<p class="BodyFirst">In this sketch, the system first waits for an RFID card to be presented to the reader. If the RFID card is recognized, then the card owner’s name, the time, and the date are appended to a text file stored on the microSD card.</p>&#13;
			<p>&#13;
				At <span aria-label="annotation1" class="CodeAnnotation">1</span> are the functions required for the I<sup>2</sup>C bus and the real-time clock, and at <span aria-label="annotation2" class="CodeAnnotation">2</span> is the line required to set up the microSD card shield. At <span aria-label="annotation4" class="CodeAnnotation">4</span>, we check and report on the status of the microSD card. At <span aria-label="annotation5" class="CodeAnnotation">5</span>, the card just read is compared against the stored card numbers for two people—in this case, John and Mary. If there is a match, the data is written to the microSD card. <span epub:type="pagebreak" id="Page_365" title="365"/>With some modification, you could add more cards to the system simply by adding the cards’ serial numbers below the existing numbers at <span aria-label="annotation3" class="CodeAnnotation">3</span> and then adding other comparison functions like those at <span aria-label="annotation5" class="CodeAnnotation">5</span>.</p>&#13;
			<p>&#13;
				When the time comes to review the logged data, copy the file <em>data.txt</em> from the microSD card. Then view the data with a text editor or import it into a spreadsheet for further analysis. The data is laid out so that it’s easy to read, as shown in <a href="#figure20-5" id="figureanchor20-5">Figure 20-5</a>.</p>&#13;
			<figure>&#13;
				<img alt="f20005" src="image_fi/500587c20/f20005.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure20-5">Figure 20-5</a>: Example data generated by Project 59</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h2 id="h1-500587c20-0005">Looking Ahead</h2>&#13;
			<p class="BodyFirst">In this chapter, you learned how to work with time and date data via the RTC IC. The RFID system described in Project 59 gives you the framework you need to create your own access systems or even track when, for example, your children arrive home. In the final two chapters, we’ll create projects that will use the Arduino to communicate over the internet and a cellular phone network.</p>&#13;
		</section>&#13;
	</body></html>