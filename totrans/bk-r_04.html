<html><head></head><body>
<h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_39"/><span class="big"><strong>3</strong></span><br/><strong>MATRICES AND ARRAYS</strong></h2>&#13;
<div class="image"><img src="../images/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">By now, you have a solid handle on using vectors in R. A <em>matrix</em> is simply several vectors stored together. Whereas the size of a vector is described by its length, the size of a matrix is specified by a number of rows and a number of columns. You can also create higher-dimensional structures that are referred to as <em>arrays</em>. In this chapter, we’ll begin by looking at how to work with matrices before increasing the dimension to form arrays.</p>&#13;
<h3 class="h3" id="ch03lev1sec12"><strong>3.1 Defining a Matrix</strong></h3>&#13;
<p class="noindent">The matrix is an important mathematical construct, and it’s essential to many statistical methods. You typically describe a matrix <em>A</em> as an <em>m</em> × <em>n</em> matrix; that is, <em>A</em> will have exactly <em>m</em> rows and <em>n</em> columns. This means <em>A</em> will have a total of <em>mn</em> entries, with each entry <em>a<sub>i,j</sub></em> having a unique position given by its specific row (<em>i</em> = 1,2, ..., <em>m</em>) and column (<em>j</em> = 1, 2, ..., <em>n</em>).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_40"/>You can therefore express a matrix as follows:</p>&#13;
<div class="imagec"><img src="../images/f0040-01.jpg" alt="image"/></div>&#13;
<p class="indent">To create a matrix in R, use the aptly named <code>matrix</code> command, providing the entries of the matrix to the <code>data</code> argument as a vector:</p>&#13;
<pre>R&gt; A &lt;- matrix(data=c(-3,2,893,0.17),nrow=2,ncol=2)<br/>R&gt; A<br/>     [,1]   [,2]<br/>[1,]   -3 893.00<br/>[2,]    2   0.17</pre>&#13;
<p class="indent">You must make sure that the length of this vector matches exactly with the number of desired rows (<code>nrow</code>) and columns (<code>ncol</code>). You can elect not to supply <code>nrow</code> and <code>ncol</code> when calling <code>matrix</code>, in which case R’s default behavior is to return a single-column matrix of the entries in <code>data</code>. For example, <code>matrix(data=c(-3,2,893,0.17))</code> would be identical to <code>matrix(data=c(-3,2,893,0.17),nrow=4,ncol=1)</code>.</p>&#13;
<h4 class="h4" id="ch03lev2sec24"><strong><em>3.1.1 Filling Direction</em></strong></h4>&#13;
<p class="noindent">It’s important to be aware of how R fills up the matrix using the entries from <code>data</code>. Looking at the previous example, you can see that the 2 × 2 matrix <code>A</code> has been filled in a <em>column-by-column</em> fashion when reading the <code>data</code> entries from left to right. You can control how R fills in data using the argument <code>byrow</code>, as shown in the following examples:</p>&#13;
<pre>R&gt; matrix(data=c(1,2,3,4,5,6),nrow=2,ncol=3,byrow=FALSE)<br/>     [,1] [,2] [,3]<br/>[1,]    1    3    5<br/>[2,]    2    4    6</pre>&#13;
<p class="indent">Here, I’ve instructed R to provide a 2 × 3 matrix containing the digits 1 through 6. By using the optional argument <code>byrow</code> and setting it to <code>FALSE</code>, you explicitly tell R to fill this 2 × 3 structure in a column-wise fashion, by filling each column before moving to the next, reading the <code>data</code> argument vector from left to right. This is R’s default handling of the <code>matrix</code> function, so if the <code>byrow</code> argument isn’t supplied, the software will assume <code>byrow=FALSE</code>. <a href="ch03.xhtml#ch3fig1">Figure 3-1</a> illustrates this behavior.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_41"/><img src="../images/f03-01.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch3fig1"/>Figure 3-1: Filling a 2</em> × <em>3 matrix in a column-wise fashion with</em> <code>byrow=FALSE</code> <em>(R default)</em></p>&#13;
<p class="indent">Now, let’s repeat the same line of code but set <code>byrow=TRUE</code>.</p>&#13;
<pre>R&gt; matrix(data=c(1,2,3,4,5,6),nrow=2,ncol=3,byrow=TRUE)<br/>     [,1] [,2] [,3]<br/>[1,]    1    2    3<br/>[2,]    4    5    6</pre>&#13;
<p class="indent">The resulting 2 × 3 structure has now been filled in a row-wise fashion, as shown in <a href="ch03.xhtml#ch3fig2">Figure 3-2</a>.</p>&#13;
<div class="image"><img src="../images/f03-02.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch3fig2"/>Figure 3-2: Filling a 2</em> × <em>3 matrix in a row-wise fashion with</em> <code>byrow=TRUE</code></p>&#13;
<h4 class="h4" id="ch03lev2sec25"><strong><em>3.1.2 Row and Column Bindings</em></strong></h4>&#13;
<p class="noindent">If you have multiple vectors of equal length, you can quickly build a matrix by binding together these vectors using the built-in R functions, <code>rbind</code> and <code>cbind</code>. You can either treat each vector as a row (by using the command <code>rbind</code>) or treat each vector as a column (using the command <code>cbind</code>). Say you have the two vectors <code>1:3</code> and <code>4:6</code>. You can reconstruct the 2 × 3 matrix in <a href="ch03.xhtml#ch3fig2">Figure 3-2</a> using <code>rbind</code> as follows:</p>&#13;
<pre>R&gt; rbind(1:3,4:6)<br/>     [,1] [,2] [,3]<br/>[1,]    1    2    3<br/>[2,]    4    5    6</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_42"/>Here, <code>rbind</code> has bound together the vectors as two rows of a matrix, with the top-to-bottom order of the rows matching the order of the vectors supplied to <code>rbind</code>. The same matrix could be constructed as follows, using <code>cbind</code>:</p>&#13;
<pre>R&gt; cbind(c(1,4),c(2,5),c(3,6))<br/>     [,1] [,2] [,3]<br/>[1,]    1    2    3<br/>[2,]    4    5    6</pre>&#13;
<p class="indent">Here, you have three vectors each of length 2. You use <code>cbind</code> to glue together these three vectors in the order they were supplied, and each vector becomes a column of the resulting matrix.</p>&#13;
<h4 class="h4" id="ch03lev2sec26"><strong><em>3.1.3 Matrix Dimensions</em></strong></h4>&#13;
<p class="noindent">Another useful function, <code>dim</code>, provides the dimensions of a matrix stored in your workspace.</p>&#13;
<pre>R&gt; mymat &lt;- rbind(c(1,3,4),5:3,c(100,20,90),11:13)<br/>R&gt; mymat<br/>     [,1] [,2] [,3]<br/>[1,]    1    3    4<br/>[2,]    5    4    3<br/>[3,]  100   20   90<br/>[4,]   11   12   13<br/><br/>R&gt; dim(mymat)<br/>[1] 4 3<br/>R&gt; nrow(mymat)<br/>[1] 4<br/>R&gt; ncol(mymat)<br/>[1] 3<br/>R&gt; dim(mymat)[2]<br/>[1] 3</pre>&#13;
<p class="indent">Having defined a matrix <code>mymat</code> using <code>rbind</code>, you can confirm its dimensions with <code>dim</code>, which returns a vector of length 2; <code>dim</code> always supplies the number of rows first, followed by the number of columns. You can also use two related functions: <code>nrow</code> (which provides the number of rows only) and <code>ncol</code> (which provides the number of columns only). In the last command shown, you use <code>dim</code> and your knowledge of vector subsetting to extract the same result that <code>ncol</code> would give you.</p>&#13;
<h3 class="h3" id="ch03lev1sec13"><strong>3.2 Subsetting</strong></h3>&#13;
<p class="noindent">Extracting and subsetting elements from matrices in R is much like extracting elements from vectors. The only complication is that you now have an additional dimension. Element extraction still uses the square-bracket <span epub:type="pagebreak" id="page_43"/>operator, but now it must be performed with both a row <em>and</em> a column position, given strictly in the order of <code>[<span class="codeitalic">row</code>,<span class="codeitalic">column</span>]</span>. Let’s start by creating a 3 × 3 matrix, which I’ll use for the examples in this section.</p>&#13;
<pre>R&gt; A &lt;- matrix(c(0.3,4.5,55.3,91,0.1,105.5,-4.2,8.2,27.9),nrow=3,ncol=3)<br/>R&gt; A<br/>     [,1]  [,2] [,3]<br/>[1,]  0.3  91.0 -4.2<br/>[2,]  4.5   0.1  8.2<br/>[3,] 55.3 105.5 27.9</pre>&#13;
<p class="indent">To tell R to “look at the third row of <code>A</code> and give me the element from the second column,” you execute the following:</p>&#13;
<pre>R&gt; A[3,2]<br/>[1] 105.5</pre>&#13;
<p class="indent">As expected, you’re given the element at position <code>[3,2]</code>.</p>&#13;
<h4 class="h4" id="ch03lev2sec27"><strong><em>3.2.1 Row, Column, and Diagonal Extractions</em></strong></h4>&#13;
<p class="noindent">To extract an entire row or column from a matrix, you simply specify the desired row or column number and leave the other value blank. It’s important to note that <em>you must still include</em> the comma that separates the row and column numbers—this is how R distinguishes between a request for a row and a request for a column. The following returns the second column of <code>A</code>:</p>&#13;
<pre>R&gt; A[,2]<br/>[1]  91.0    0.1 105.5</pre>&#13;
<p class="indent">The following examines the first row:</p>&#13;
<pre>R&gt; A[1,]<br/>[1]  0.3 91.0 -4.2</pre>&#13;
<p class="indent">Note that whenever an extraction (or deletion, covered in a moment) results in a single value, single row, or single column, R will always return stand-alone vectors comprised of the requested values. You can also perform more complicated extractions, for example requesting whole rows or columns, or multiples rows or columns, where the result must be returned as a new matrix of the appropriate dimensions. Consider the following subsets:</p>&#13;
<pre>R&gt; A[2:3,]<br/>     [,1]  [,2] [,3]<br/>[1,]  4.5   0.1  8.2<br/>[2,] 55.3 105.5 27.9<br/><br/>R&gt; A[,c(3,1)]<br/>     [,1] [,2]<br/><span epub:type="pagebreak" id="page_44"/>[1,] -4.2  0.3<br/>[2,]  8.2  4.5<br/>[3,] 27.9 55.3<br/><br/>R&gt; A[c(3,1),2:3]<br/>      [,1] [,2]<br/>[1,] 105.5 27.9<br/>[2,]  91.0 -4.2</pre>&#13;
<p class="indent">The first command returns the second and third rows of <code>A</code>, and the second command returns the third and first columns of <code>A</code>. The last command accesses the third and first rows of <code>A</code>, in that order, and from those rows it returns the second and third column elements.</p>&#13;
<p class="indent">You can also identify the values along the diagonal of a square matrix (that is, a matrix with an equal number of rows and columns) using the <code>diag</code> command.</p>&#13;
<pre>R&gt; diag(x=A)<br/>[1]  0.3  0.1 27.9</pre>&#13;
<p class="indent">This returns a vector with the elements along the diagonal of <code>A</code>, starting at <code>A[1,1]</code>.</p>&#13;
<h4 class="h4" id="ch03lev2sec28"><strong><em>3.2.2 Omitting and Overwriting</em></strong></h4>&#13;
<p class="noindent">To delete or omit elements from a matrix, you again use square brackets, but this time with negative indexes. The following provides <code>A</code> without its second column:</p>&#13;
<pre>R&gt; A[,-2]<br/>     [,1] [,2]<br/>[1,]  0.3 -4.2<br/>[2,]  4.5  8.2<br/>[3,] 55.3 27.9</pre>&#13;
<p class="indent">The following removes the first row from <code>A</code> and retrieves the third and second column values, in that order, from the remaining two rows:</p>&#13;
<pre>R&gt; A[-1,3:2]<br/>     [,1]  [,2]<br/>[1,]  8.2   0.1<br/>[2,] 27.9 105.5</pre>&#13;
<p class="indent">The following produces <code>A</code> without its first row and second column:</p>&#13;
<pre>R&gt; A[-1,-2]<br/>     [,1] [,2]<br/>[1,]  4.5  8.2<br/>[2,] 55.3 27.9</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_45"/>Lastly, this deletes the first row and then deletes the second and third columns from the result:</p>&#13;
<pre>R&gt; A[-1,-c(2,3)]<br/>[1]  4.5 55.3</pre>&#13;
<p class="indent">Note that this final operation leaves you with only the last two elements of the first column of <code>A</code>, so this result is returned as a stand-alone vector rather than a matrix.</p>&#13;
<p class="indent">To overwrite particular elements, or entire rows or columns, you identify the elements to be replaced and then assign the new values, as you did with vectors in <a href="ch02.xhtml#ch02lev2sec22">Section 2.3.3</a>. The new elements can be a single value, a vector of the same length as the number of elements to be replaced, or a vector whose length evenly divides the number of elements to be replaced. To illustrate this, let’s first create a copy of <code>A</code> and call it <code>B</code>.</p>&#13;
<pre>R&gt; B &lt;- A<br/>R&gt; B<br/>     [,1]  [,2] [,3]<br/>[1,]  0.3  91.0 -4.2<br/>[2,]  4.5   0.1  8.2<br/>[3,] 55.3 105.5 27.9</pre>&#13;
<p class="indent">The following overwrites the second row of <code>B</code> with the sequence <code>1</code>, <code>2</code>, and <code>3</code>:</p>&#13;
<pre>R&gt; B[2,] &lt;- 1:3<br/>R&gt; B<br/>     [,1]  [,2] [,3]<br/>[1,]  0.3  91.0 -4.2<br/>[2,]  1.0   2.0  3.0<br/>[3,] 55.3 105.5 27.9</pre>&#13;
<p class="indent">The following overwrites the second column elements of the first and third rows with <code>900</code>:</p>&#13;
<pre>R&gt; B[c(1,3),2] &lt;- 900<br/>R&gt; B<br/>     [,1] [,2] [,3]<br/>[1,]  0.3  900 -4.2<br/>[2,]  1.0    2  3.0<br/>[3,] 55.3  900 27.9</pre>&#13;
<p class="indent">Next, you replace the third column of <code>B</code> with the values in the third <em>row</em> of <code>B</code>.</p>&#13;
<pre>R&gt; B[,3] &lt;- B[3,]<br/>R&gt; B<br/>     [,1] [,2]  [,3]<br/><span epub:type="pagebreak" id="page_46"/>[1,]  0.3  900  55.3<br/>[2,]  1.0    2 900.0<br/>[3,] 55.3  900  27.9</pre>&#13;
<p class="indent">To try R’s vector recycling, let’s now overwrite the first and third column elements of rows 1 and 3 (a total of four elements) with the two values <code>-7</code> and <code>7</code>.</p>&#13;
<pre>R&gt; B[c(1,3),c(1,3)] &lt;- c(-7,7)<br/>R&gt; B<br/>     [,1] [,2] [,3]<br/>[1,]   -7  900   -7<br/>[2,]    1    2  900<br/>[3,]    7  900    7</pre>&#13;
<p class="indent">The vector of length 2 has replaced the four elements <em>in a column-wise fashion</em>. The replacement vector <code>c(-7,7)</code> overwrites the elements at positions (1,1) and (3,1), in that order, and is then repeated to overwrite (1,3) and (3,3), in that order.</p>&#13;
<p class="indent">To highlight the role of index order on matrix element replacement, consider the following example:</p>&#13;
<pre>R&gt; B[c(1,3),2:1] &lt;- c(65,-65,88,-88)<br/>R&gt; B<br/>     [,1] [,2] [,3]<br/>[1,]   88   65   -7<br/>[2,]    1    2  900<br/>[3,]  -88  -65    7</pre>&#13;
<p class="indent">The four values in the replacement vector have overwritten the four specified elements, again in a column-wise fashion. In this case, because I specified the first and second columns in reverse order, the overwriting proceeded accordingly, filling the second column before moving to the first. Position (1,2) is matched with <code>65</code>, followed by (3,2) with <code>-65</code>; then (1,1) becomes <code>88</code>, and (3,1) becomes <code>-88</code>.</p>&#13;
<p class="indent">If you just want to replace the diagonal of a square matrix, you can avoid explicit indexes and directly overwrite the values using the <code>diag</code> command.</p>&#13;
<pre>R&gt; diag(x=B) &lt;- rep(x=0,times=3)<br/>R&gt; B<br/>     [,1] [,2] [,3]<br/>[1,]    0   65   -7<br/>[2,]    1    0  900<br/>[3,]  -88  -65    0</pre>&#13;
<div class="ex">&#13;
<p class="ext"><span epub:type="pagebreak" id="page_47"/><a id="ch3exc1"/><strong>Exercise 3.1</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Construct and store a 4 × 2 matrix that’s filled row-wise with the values 4.3, 3.1, 8.2, 8.2, 3.2, 0.9, 1.6, and 6.5, in that order.</p></li>&#13;
<li><p class="noindents">Confirm the dimensions of the matrix from (a) are 3 × 2 if you remove any one row.</p></li>&#13;
<li><p class="noindents">Overwrite the second column of the matrix from (a) with that same column sorted from smallest to largest.</p></li>&#13;
<li><p class="noindents">What does R return if you delete the fourth row and the first column from (c)? Use <code>matrix</code> to ensure the result is a single-column matrix, rather than a vector.</p></li>&#13;
<li><p class="noindents">Store the bottom four elements of (c) as a new 2 × 2 matrix.</p></li>&#13;
<li><p class="noindents">Overwrite, in this order, the elements of (c) at positions (4,2), (1,2), (4,1), and (1,1) with –<img class="middle" src="../images/1by2.jpg" alt="image"/> of the two values on the diagonal of (e).</p></li>&#13;
</ol>&#13;
</div>&#13;
<h3 class="h3" id="ch03lev1sec14"><strong>3.3 Matrix Operations and Algebra</strong></h3>&#13;
<p class="noindent">You can think of matrices in R from two perspectives. First, you can use these structures purely as a computational tool in programming to store and operate on results, as you’ve seen so far. Alternatively, you can use matrices for their mathematical properties in relevant calculations, such as the use of matrix multiplication for expressing regression model equations. This distinction is important because the mathematical behavior of matrices is not always the same as the more generic data handling behavior. Here I’ll briefly describe some special matrices, as well as some of the most common mathematical operations involving matrices, and the corresponding functionality in R. If the mathematical behavior of matrices isn’t of interest to you, you can skip this section for now and refer to it later as needed.</p>&#13;
<h4 class="h4" id="ch03lev2sec29"><strong><em>3.3.1 Matrix Transpose</em></strong></h4>&#13;
<p class="noindent">For any <em>m</em> × <em>n</em> matrix <em>A</em>, its <em>transpose</em>, <em>A</em><sup><span class="ent">⊤</span></sup>, is the <em>n</em> × <em>m</em> matrix obtained by writing either its columns as rows or its rows as columns.</p>&#13;
<p class="indent">Here’s an example:</p>&#13;
<div class="imagec"><img src="../images/f0047-01.jpg" alt="image"/></div>&#13;
<p class="indent">In <code>R</code>, the transpose of a matrix is found with the function <code>t</code>. Let’s create a new matrix and then transpose it.</p>&#13;
<pre><span epub:type="pagebreak" id="page_48"/>R&gt; A &lt;- rbind(c(2,5,2),c(6,1,4))<br/>R&gt; A<br/>     [,1] [,2] [,3]<br/>[1,]    2    5    2<br/>[2,]    6    1    4<br/>R&gt; t(A)<br/>     [,1] [,2]<br/>[1,]    2    6<br/>[2,]    5    1<br/>[3,]    2    4</pre>&#13;
<p class="indent">If you “transpose the transpose” of <em>A</em>, you’ll recover the original matrix.</p>&#13;
<pre>R&gt; t(t(A))<br/>     [,1] [,2] [,3]<br/>[1,]    2    5    2<br/>[2,]    6    1    4</pre>&#13;
<h4 class="h4" id="ch03lev2sec30"><strong><em>3.3.2 Identity Matrix</em></strong></h4>&#13;
<p class="noindent">The <em>identity matrix</em> written as <em>I</em><sub><em>m</em></sub> is a particular kind of matrix used in mathematics. It’s a square <em>m</em> × <em>m</em> matrix with ones on the diagonal and zeros elsewhere.</p>&#13;
<p class="indent">Here’s an example:</p>&#13;
<div class="imagec"><img src="../images/f0048-01.jpg" alt="image"/></div>&#13;
<p class="indent">You can create an identity matrix of any dimension using the standard <code>matrix</code> function, but there’s a quicker approach using <code>diag</code>. Earlier, I used <code>diag</code> on an existing matrix to extract or overwrite its diagonal elements. You can also use it as follows:</p>&#13;
<pre>R&gt; A &lt;- diag(x=3)<br/>R&gt; A<br/>     [,1] [,2] [,3]<br/>[1,]    1    0    0<br/>[2,]    0    1    0<br/>[3,]    0    0    1</pre>&#13;
<p class="indent">Here you see <code>diag</code> can be used to easily produce an identity matrix. To clarify, the behavior of <code>diag</code> depends on what you supply to it as its argument <code>x</code>. If, as earlier, <code>x</code> is a matrix, <code>diag</code> will retrieve the diagonal elements of the matrix. If <code>x</code> is a single positive integer, as is the case here, then <code>diag</code> will produce the identity matrix of the corresponding dimension. You can find more uses of <code>diag</code> on its help page.</p>&#13;
<h4 class="h4" id="ch03lev2sec31"><span epub:type="pagebreak" id="page_49"/><strong><em>3.3.3 Scalar Multiple of a Matrix</em></strong></h4>&#13;
<p class="noindent">A scalar value is just a single, univariate value. Multiplication of any matrix <em>A</em> by a scalar value <em>a</em> results in a matrix in which every individual element is multiplied by <em>a</em>.</p>&#13;
<p class="indent">Here’s an example:</p>&#13;
<div class="imagec"><img src="../images/f0049-01.jpg" alt="image"/></div>&#13;
<p class="indent">R will perform this multiplication in an element-wise manner, as you might expect. Scalar multiplication of a matrix is carried out using the standard arithmetic <code>*</code> operator.</p>&#13;
<pre>R&gt; A &lt;- rbind(c(2,5,2),c(6,1,4))<br/>R&gt; a &lt;- 2<br/>R&gt; a*A<br/>     [,1] [,2] [,3]<br/>[1,]    4   10    4<br/>[2,]   12    2    8</pre>&#13;
<h4 class="h4" id="ch03lev2sec32"><strong><em>3.3.4 Matrix Addition and Subtraction</em></strong></h4>&#13;
<p class="noindent">Addition or subtraction of two matrices of equal size is also performed in an element-wise fashion. Corresponding elements are added or subtracted from one another, depending on the operation.</p>&#13;
<p class="indent">Here’s an example:</p>&#13;
<div class="imagec"><img src="../images/f0049-02.jpg" alt="image"/></div>&#13;
<p class="indent">You can add or subtract any two equally sized matrices with the standard <code>+</code> and <code>-</code> symbols.</p>&#13;
<pre>R&gt; A &lt;- cbind(c(2,5,2),c(6,1,4))<br/>R&gt; A<br/>     [,1] [,2]<br/>[1,]    2    6<br/>[2,]    5    1<br/>[3,]    2    4<br/>R&gt; B &lt;- cbind(c(-2,3,6),c(8.1,8.2,-9.8))<br/>R&gt; B<br/>     [,1] [,2]<br/>[1,]   -2  8.1<br/>[2,]    3  8.2<br/>[3,]    6 -9.8<br/>R&gt; A-B<br/><span epub:type="pagebreak" id="page_50"/>     [,1] [,2]<br/>[1,]    4 -2.1<br/>[2,]    2 -7.2<br/>[3,]   -4 13.8</pre>&#13;
<h4 class="h4" id="ch03lev2sec33"><strong><em>3.3.5 Matrix Multiplication</em></strong></h4>&#13;
<p class="noindent">In order to <em>multiply</em> two matrices <em>A</em> and <em>B</em> of size <em>m</em> × <em>n</em> and <em>p</em> × <em>q</em>, it must be true that <em>n</em> = <em>p</em>. The resulting matrix <em>A</em> · <em>B</em> will have the size <em>m</em> × <em>q</em>. The elements of the product are computed in a row-by-column fashion, where the value at position (<em>AB</em>)<sub><em>i,j</em></sub> is computed by element-wise multiplication of the entries in row <em>i</em> of <em>A</em> by the entries in column <em>j</em> of <em>B</em>, summing the result.</p>&#13;
<p class="indent">Here’s an example:</p>&#13;
<div class="imagei"><img src="../images/f0050-01.jpg" alt="image"/></div>&#13;
<p class="indent">Note that, in general, multiplication of appropriately sized matrices (denoted, say, with <em>C</em> and <em>D</em>) is not commutative; that is, <em>CD</em> ≠ <em>DC</em>.</p>&#13;
<p class="indent">Unlike addition, subtraction, and scalar multiplication, matrix multiplication is not a simple element-wise calculation, and the standard <code>*</code> operator cannot be used. Instead, you must use R’s matrix product operator, written with percent symbols as <code>%*%</code>. Before you try this operator, let’s first store the two example matrices and check to make sure the number of columns in the first matrix matches the number of rows in the second matrix using <code>dim</code>.</p>&#13;
<pre>R&gt; A &lt;- rbind(c(2,5,2),c(6,1,4))<br/>R&gt; dim(A)<br/>[1] 2 3<br/>R&gt; B &lt;- cbind(c(3,-1,1),c(-3,1,5))<br/>R&gt; dim(B)<br/>[1] 3 2</pre>&#13;
<p class="indent">This confirms the two matrices are compatible for multiplication, so you can proceed.</p>&#13;
<pre>R&gt; A%*%B<br/>     [,1] [,2]<br/>[1,]    3    9<br/>[2,]   21    3</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_51"/>You can show that matrix multiplication is noncommutative using the same two matrices. Switching the order of multiplication gives you an entirely different result.</p>&#13;
<pre>R&gt; B%*%A<br/>     [,1] [,2] [,3]<br/>[1,]  -12   12   -6<br/>[2,]    4   -4    2<br/>[3,]   32   10   22</pre>&#13;
<h4 class="h4" id="ch03lev2sec34"><strong><em>3.3.6 Matrix Inversion</em></strong></h4>&#13;
<p class="noindent">Some square matrices can be <em>inverted</em>. The inverse of a matrix <em>A</em> is denoted <em>A</em><sup>–1</sup>. An invertible matrix satisfies the following equation:</p>&#13;
<p class="center"><em>AA</em><sup>–1</sup> = <em>I</em><sub><em>m</em></sub></p>&#13;
<p class="indent">Here’s an example of a matrix and its inverse:</p>&#13;
<div class="imagec"><img src="../images/f0051-01.jpg" alt="image"/></div>&#13;
<p class="indent">Matrices that are not invertible are referred to as <em>singular</em>. Inverting a matrix is often necessary when solving equations with matrices and has important practical ramifications. There are several different approaches to matrix inversion, and these calculations can become extremely computationally expensive as you increase the size of a matrix. We won’t go into too much detail here, but if you’re interested, see Golub and Van Loan (<a href="ref.xhtml#ref26">1989</a>) for formal discussions.</p>&#13;
<p class="indent">For now, I’ll just show you the R function solve as one option for inverting a matrix.</p>&#13;
<pre>R&gt; A &lt;- matrix(data=c(3,4,1,2),nrow=2,ncol=2)<br/>R&gt; A<br/>     [,1] [,2]<br/>[1,]    3    1<br/>[2,]    4    2<br/>R&gt; solve(A)<br/>     [,1] [,2]<br/>[1,]    1 -0.5<br/>[2,]   -2  1.5</pre>&#13;
<p class="indent">You can also verify that the product of these two matrices (using matrix multiplication rules) results in the 2 × 2 identity matrix.</p>&#13;
<pre><span epub:type="pagebreak" id="page_52"/>R&gt; A%*%solve(A)<br/>     [,1] [,2]<br/>[1,]    1    0<br/>[2,]    0    1</pre>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch3exc2"/><strong>Exercise 3.2</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Calculate the following:</p>&#13;
<div class="imagec"><img src="../images/f0052-01.jpg" alt="image"/></div></li>&#13;
<li><p class="noindents">Store these two matrices:</p>&#13;
<div class="imagec"><img src="../images/f0052-02.jpg" alt="image"/></div>&#13;
<p class="indent">Which of the following multiplications are possible? For those that are, compute the result.</p>&#13;
<ol type="i">&#13;
<li><p class="noindent"><em>A</em> · <em>B</em></p></li>&#13;
<li><p class="noindent"><em>A</em> <sup><span class="ent">⊤</span></sup> · <em>B</em></p></li>&#13;
<li><p class="noindent"><em>B</em> <sup><span class="ent">⊤</span></sup> · (<em>A</em> · <em>A</em> <sup><span class="ent">⊤</span></sup>)</p></li>&#13;
<li><p class="noindent">(<em>A</em> · <em>A</em> <sup><span class="ent">⊤</span></sup>) · <em>B</em> <sup><span class="ent">⊤</span></sup></p></li>&#13;
<li><p class="noindent">[(<em>B</em> · <em>B</em> <sup><span class="ent">⊤</span></sup>) + (<em>A</em> · <em>A</em> <sup><span class="ent">⊤</span></sup>) − 100<em>I</em><sub>3</sub>]<sup>−1</sup></p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">For</p>&#13;
<div class="imagec"><img src="../images/f0052-03.jpg" alt="image"/></div>&#13;
<p class="noindent">confirm that <em>A</em><sup>–1</sup> · <em>A</em> − <em>I<sub>4</sub></em> provides a 4 × 4 matrix of zeros.</p></li>&#13;
</ol>&#13;
</div>&#13;
<h3 class="h3" id="ch03lev1sec15"><strong>3.4 Multidimensional Arrays</strong></h3>&#13;
<p class="noindent">Just as a matrix (a “rectangle” of elements) is the result of increasing the dimension of a vector (a “line” of elements), the dimension of a matrix can be increased to get more complex data structures. In R, vectors and matrices can be considered special cases of the more general <em>array</em>, which is how I’ll refer to these types of structures when they have more than two dimensions.</p>&#13;
<p class="indent">So, what’s the next step up from a matrix? Well, just as a matrix is considered to be a collection of vectors of equal length, a three-dimensional array can be considered to be a collection of equally dimensioned matrices, <span epub:type="pagebreak" id="page_53"/>providing you with a rectangular prism of elements. You still have a fixed number of rows and a fixed number of columns, as well as a new third dimension called a <em>layer</em>. <a href="ch03.xhtml#ch3fig3">Figure 3-3</a> illustrates a three-row, four-column, two-layer (3 × 4 × 2) array.</p>&#13;
<div class="image"><img src="../images/f03-03.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch3fig3"/>Figure 3-3: A conceptual diagram of a 3</em> × <em>4</em> × <em>2 array. The index of each element is given at the corresponding position. These indexes are provided in the strict order of</em> <code>[row,column,layer]</code>.</p>&#13;
<h4 class="h4" id="ch03lev2sec35"><strong><em>3.4.1 Definition</em></strong></h4>&#13;
<p class="noindent">To create these data structures in R, use the <code>array</code> function and specify the individual elements in the <code>data</code> argument as a vector. Then specify size in the <code>dim</code> argument as another vector with a length corresponding to the number of dimensions. Note that <code>array</code> fills the entries of each layer with the elements in <code>data</code> in a strict column-wise fashion, starting with the first layer. Consider the following example:</p>&#13;
<pre>R&gt; AR &lt;- array(data=1:24,dim=c(3,4,2))<br/>R&gt; AR<br/>, , 1<br/><br/>     [,1] [,2] [,3] [,4]<br/>[1,]    1    4    7   10<br/>[2,]    2    5    8   11<br/>[3,]    3    6    9   12<br/><br/>, , 2<br/><span epub:type="pagebreak" id="page_54"/>     [,1] [,2] [,3] [,4]<br/>[1,]   13   16   19   22<br/>[2,]   14   17   20   23<br/>[3,]   15   18   21   24</pre>&#13;
<p class="indent">This gives you an array of the same size as in <a href="ch03.xhtml#ch3fig3">Figure 3-3</a>—each of the two layers constitutes a 3 × 4 matrix. In this example, note the order of the dimensions supplied to <code>dim</code>: <code>c(<span class="codeitalic">rows</code>,<span class="codeitalic">columns</span>,<span class="codeitalic">layers</span>)</span>. Just like a single matrix, the product of the dimension sizes of an array will yield the total number of elements. As you increase the dimension further, the <code>dim</code> vector must be extended accordingly. For example, a four-dimensional array is the next step up and can be thought of as <em>blocks</em> of three-dimensional arrays. Suppose you had a four-dimensional array comprised of three copies of <code>AR</code>, the three-dimensional array just defined. This new array can be stored in R as follows (once again, the array is filled column-wise):</p>&#13;
<pre>R&gt; BR &lt;- array(data=rep(1:24,times=3),dim=c(3,4,2,3))<br/>R&gt; BR<br/>, , 1, 1<br/><br/>     [,1] [,2] [,3] [,4]<br/>[1,]    1    4    7   10<br/>[2,]    2    5    8   11<br/>[3,]    3    6    9   12<br/><br/>, , 2, 1<br/><br/>     [,1] [,2] [,3] [,4]<br/>[1,]   13   16   19   22<br/>[2,]   14   17   20   23<br/>[3,]   15   18   21   24<br/><br/>, , 1, 2<br/><br/>     [,1] [,2] [,3] [,4]<br/>[1,]    1    4    7   10<br/>[2,]    2    5    8   11<br/>[3,]    3    6    9   12<br/><br/>, , 2, 2<br/><br/>     [,1] [,2] [,3] [,4]<br/>[1,]   13   16   19   22<br/>[2,]   14   17   20   23<br/>[3,]   15   18   21   24<br/><br/>, , 1, 3<br/><br/><span epub:type="pagebreak" id="page_55"/>     [,1] [,2] [,3] [,4]<br/>[1,]    1    4    7   10<br/>[2,]    2    5    8   11<br/>[3,]    3    6    9   12<br/><br/>, , 2, 3<br/><br/>     [,1] [,2] [,3] [,4]<br/>[1,]   13   16   19   22<br/>[2,]   14   17   20   23<br/>[3,]   15   18   21   24</pre>&#13;
<p class="indent">With <code>BR</code> you now have three copies of <code>AR</code>. Each of these copies is split into its two layers so R can print the object to the screen. As before, the rows are indexed by the first digit, the columns by the second digit, and the layers by the third digit. The new fourth digit indexes the blocks.</p>&#13;
<h4 class="h4" id="ch03lev2sec36"><strong><em>3.4.2 Subsets, Extractions, and Replacements</em></strong></h4>&#13;
<p class="noindent">Even though high-dimensional objects can be difficult to conceptualize, R indexes them consistently. This makes extracting elements from these structures straightforward now that you know how to subset matrices—you just have to keep using commas in the square brackets as separators of the dimensions being accessed. This is highlighted in the examples that follow.</p>&#13;
<p class="indent">Suppose you want the second row of the second layer of the previously created array <code>AR</code>. You just enter these exact dimensional locations of <code>AR</code> in square brackets.</p>&#13;
<pre>R&gt; AR[2,,2]<br/>[1] 14 17 20 23</pre>&#13;
<p class="indent">The desired elements have been extracted as a vector of length 4. If you want specific elements from this vector, say the third and first, in that order, you can call the following:</p>&#13;
<pre>R&gt; AR[2,c(3,1),2]<br/>[1] 20 14</pre>&#13;
<p class="indent">Again, this literal method of subsetting makes dealing with even highdimensional objects in R manageable.</p>&#13;
<p class="indent">An extraction that results in multiple vectors will be presented as columns in the returned matrix. For example, to extract the first rows of both layers of <code>AR</code>, you enter this:</p>&#13;
<pre>R&gt; AR[1,,]<br/>     [,1] [,2]<br/>[1,]    1   13<br/>[2,]    4   16<br/>[3,]    7   19<br/>[4,]   10   22</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_56"/>The returned object has the first rows of each of the two matrix layers. However, it has returned each of these vectors as a <em>column</em> of the single returned matrix. As this example shows, when multiple vectors are extracted from an array, they will be returned as columns by default. This means extracted rows will not necessarily be returned as rows.</p>&#13;
<p class="indent">Turning to the object <code>BR</code>, the following gives you the single element of the second row and first column of the matrix in the first layer of the three-dimensional array located in the third block.</p>&#13;
<pre>R&gt; BR[2,1,1,3]<br/>[1] 2</pre>&#13;
<p class="indent">Again, you just need to look at the position of the index in the square brackets to know which values you are asking R to return from the array. The following examples highlight this:</p>&#13;
<pre>R&gt; BR[1,,,1]<br/>     [,1] [,2]<br/>[1,]    1   13<br/>[2,]    4   16<br/>[3,]    7   19<br/>[4,]   10   22</pre>&#13;
<p class="indent">This returns all the values in the first row of the first block. Since I left the column and layer indexes blank in this subset <code>[1,,,1]</code>, the command has returned values for all four columns and both layers in that block of <code>BR</code>.</p>&#13;
<p class="indent">Next, the following line returns all the values in the second layer of the array <code>BR</code>, composed of three matrices:</p>&#13;
<pre>R&gt; BR[,,2,]<br/>, , 1<br/><br/>     [,1] [,2] [,3] [,4]<br/>[1,]   13   16   19   22<br/>[2,]   14   17   20   23<br/>[3,]   15   18   21   24<br/><br/>, , 2<br/><br/>     [,1] [,2] [,3] [,4]<br/>[1,]   13   16   19   22<br/>[2,]   14   17   20   23<br/>[3,]   15   18   21   24<br/><br/>, , 3<br/><br/>     [,1] [,2] [,3] [,4]<br/>[1,]   13   16   19   22<br/>[2,]   14   17   20   23<br/>[3,]   15   18   21   24</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_57"/>This last example highlights a feature noted earlier, where multiple vectors from <code>AR</code> were returned as a matrix. Broadly speaking, if you have an extraction that results in multiple <em>d</em>-dimensional arrays, the result will be an array of the next-highest dimension, <em>d</em> + 1. In the last example, you extracted multiple (two-dimensional) matrices, and they were returned as a three-dimensional array. This is demonstrated again in the next example:</p>&#13;
<pre>R&gt; BR[3:2,4,,]<br/>, , 1<br/><br/>     [,1] [,2]<br/>[1,]   12   24<br/>[2,]   11   23<br/><br/>, , 2<br/><br/>     [,1] [,2]<br/>[1,]   12   24<br/>[2,]   11   23<br/><br/>, , 3<br/><br/>     [,1] [,2]<br/>[1,]   12   24<br/>[2,]   11   23</pre>&#13;
<p class="indent">This extracts the elements at rows 3 and 2 (in that order), column 4, for all layers and for all array blocks. Consider the following final example:</p>&#13;
<pre>R&gt; BR[2,,1,]<br/>     [,1] [,2] [,3]<br/>[1,]    2    2    2<br/>[2,]    5    5    5<br/>[3,]    8    8    8<br/>[4,]   11    11  11</pre>&#13;
<p class="indent">Here you’ve asked R to return the entire second rows of the first layers of all the arrays stored in <code>BR</code>.</p>&#13;
<p class="indent">Deleting and overwriting elements in high-dimensional arrays follows the same rules as for stand-alone vectors and matrices. You specify the <span epub:type="pagebreak" id="page_58"/>dimension positions the same way, using negative indexes (for deletion) or using the assignment operator for overwriting.</p>&#13;
<p class="indent">You can use the <code>array</code> function to create one-dimensional arrays (vectors) and two-dimensional arrays (matrices) should you want to (by setting the <code>dim</code> argument to be of length 1 or 2, respectively). Note, though, that vectors in particular may be treated differently by some functions if created with <code>array</code> instead of <code>c</code> (see the help file <code>?array</code> for technical details). For this reason, and to make large sections of code more readable, it’s more conventional in R programming to use the specific vector- and matrix-creation functions <code>c</code> and <code>matrix</code>.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch3exc3"/><strong>Exercise 3.3</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Create and store a three-dimensional array with six layers of a 4 × 2 matrix, filled with a decreasing sequence of values between 4.8 and 0.1 of the appropriate length.</p></li>&#13;
<li><p class="noindents">Extract and store as a new object the fourth- and first-row elements, in that order, of the second column only of all layers of (a).</p></li>&#13;
<li><p class="noindents">Use a fourfold repetition of the second row of the matrix formed in (b) to fill a new array of dimensions 2 × 2 × 2 × 3.</p></li>&#13;
<li><p class="noindents">Create a new array comprised of the results of deleting the sixth layer of (a).</p></li>&#13;
<li><p class="noindents">Overwrite the second and fourth row elements of the second column of layers 1, 3, and 5 of (d) with −99.</p></li>&#13;
</ol>&#13;
</div>&#13;
<h5 class="h5" id="ch03lev3sec10"><strong>Important Code in This Chapter</strong></h5>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function/operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Brief description</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>First occurrence</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>matrix</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Create a matrix</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch03.xhtml#ch03lev1sec12">Section 3.1</a>, <a href="ch03.xhtml#page_40">p. 40</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>rbind</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Create a matrix (bind rows)</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch03.xhtml#ch03lev2sec25">Section 3.1.2</a>, <a href="ch03.xhtml#page_41">p. 41</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>cbind</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Create a matrix (bind columns)</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch03.xhtml#ch03lev2sec25">Section 3.1.2</a>, <a href="ch03.xhtml#page_42">p. 42</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>dim</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Get matrix dimensions</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch03.xhtml#ch03lev2sec26">Section 3.1.3</a>, <a href="ch03.xhtml#page_42">p. 42</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>nrow</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Get number of rows</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch03.xhtml#ch03lev2sec26">Section 3.1.3</a>, <a href="ch03.xhtml#page_42">p. 42</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>ncol</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Get number of columns</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch03.xhtml#ch03lev2sec26">Section 3.1.3</a>, <a href="ch03.xhtml#page_42">p. 42</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>[ , ]</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Matrix/array subsetting</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch03.xhtml#ch03lev1sec13">Section 3.2</a>, <a href="ch03.xhtml#page_43">p. 43</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>diag</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Diagonal elements/identity matrix</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch03.xhtml#ch03lev2sec27">Section 3.2.1</a>, <a href="ch03.xhtml#page_44">p. 44</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>t</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Matrix transpose</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch03.xhtml#ch03lev2sec29">Section 3.3.1</a>, <a href="ch03.xhtml#page_47">p. 47</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>*</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Scalar matrix multiple</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch03.xhtml#ch03lev2sec31">Section 3.3.3</a>, <a href="ch03.xhtml#page_49">p. 49</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>+</code>, <code>-</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Matrix addition/subtraction</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch03.xhtml#ch03lev2sec32">Section 3.3.4</a>, <a href="ch03.xhtml#page_49">p. 49</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>%*%</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Matrix multiplication</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch03.xhtml#ch03lev2sec33">Section 3.3.5</a>, <a href="ch03.xhtml#page_50">p. 50</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>solve</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Matrix inversion</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch03.xhtml#ch03lev2sec34">Section 3.3.6</a>, <a href="ch03.xhtml#page_51">p. 51</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>array</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Create an array</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch03.xhtml#ch03lev2sec35">Section 3.4.1</a>, <a href="ch03.xhtml#page_53">p. 53</a></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</body></html>