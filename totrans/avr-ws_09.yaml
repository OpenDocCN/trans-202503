- en: '[9](nsp-boxall502581-0008.xhtml#rch09)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the Internal EEPROM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/nsp-boxall502581-ct.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you define and use a variable in your AVR code, the stored data only lasts
    until the hardware is reset or the power is turned off. But what if you need to
    keep some values for future use? That’s where we turn to the microcontroller’s
    *electrically erasable programmable read-only memory (EEPROM)* , a special type
    of memory that holds information even when power is disconnected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: • Learn how to store byte, word, and floating-point variables in the microcontroller’s
    EEPROM, and retrieve them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Build an ATtiny85 EEPROM storage and retrieval unit and a simple EEPROM datalogger
    with an ATmega328P-PU.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Create a program to log temperatures to the ATmega328P-PU EEPROM for later
    retrieval.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Storing Bytes in EEPROM](nsp-boxall502581-0008.xhtml#rah1101)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An EEPROM is a microcontroller component that doesn’t need electricity to retain
    the contents of its memory. The concept originates from read-only memory (ROM)
    ICs, such as those found in gaming console cartridges, where the game code stays
    in the IC even when it’s not connected to the console. Taking this concept further,
    an EEPROM lets the host controller write over old information with new information,
    which the EEPROM can still remember when the power is disconnected—that’s what
    “electrically erasable” signifies.
  prefs: []
  type: TYPE_NORMAL
- en: Different AVR microcontrollers have EEPROMs of various sizes. For example, our
    ATtiny85 can store 512 bytes of data, while the ATmega328P-PU can store 1,024
    bytes. In this chapter I’ll show you how to store and retrieve data in both microcontrollers’
    EEPROMs so you can do so for your own projects. There are several different methods
    of storing data in the EEPROM, depending on the type of data. We’ll begin by discussing
    how to store bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go any further, however, there are two things you’ll need to keep
    in mind. First, the EEPROM has a lifespan of around 100,000 read/write cycles.
    Tests have shown that they may last longer, but be aware of the approximate lifespan
    when building your own projects. Second, remember that when you upload new code
    to your AVR, the data in the EEPROM is erased.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the EEPROM in our code for either microcontroller, we first include
    the EEPROM library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to write a byte of data (for example, a number between 0 and 255), we
    use the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: where `a` is the location inside the EEPROM—between 0 and 511 for the ATtiny85,
    and between 0 and 1023 for the ATmega328P-PU—and `b` is the byte of data to store,
    between 0 and 255\. We prefix the location variable `a` with `(uint8_t*)` as the
    EEPROM functions require the parameter to be an 8-bit integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also *update* an EEPROM location to change the value stored in it,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: where again `a` is the location inside the EEPROM—between 0 and 511 for the
    ATtiny85, and between 0 and 1023 for the ATmega328P-PU—and `b` is the byte of
    data to store, between 0 and 255\. Before writing a byte of data to a location,
    an update command first checks the value currently at that location. If the value
    to be written is the same as the current value, no write occurs. Though this check
    adds processing time, it saves unnecessarily writing to the EEPROM, thus extending
    its lifespan.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve the byte of data stored in a location, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This allocates the value stored in EEPROM location `a` to the variable `i` .
    You’ll test a few of these functions out in the [next project](nsp-boxall502581-0019.xhtml#pro38)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 38: Experimenting with the ATtiny85’s EEPROM](nsp-boxall502581-0008.xhtml#rpro38)'
  prefs: []
  type: TYPE_NORMAL
- en: This project will demonstrate writing and retrieving bytes of data from the
    ATtiny85’s EEPROM. It uses four LEDs as a quick way to display the numbers 0 to
    15 in binary form, with diode D1 being the least significant bit (for 0) and diode
    D4 being the most significant bit (for 15).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATtiny85–20PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Four LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Four 560 Ω resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 9-1](nsp-boxall502581-0019.xhtml#f09001)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 38](images/nsp-boxall502581-f09001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-1: Schematic for [Project 38](nsp-boxall502581-0019.xhtml#pro38)'
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 38* subfolder of this book’s
    *Chapter 9* folder, and enter the command `make flash` . After a moment, the LEDs
    should display the numbers 0 to 15 in binary and then repeat.
  prefs: []
  type: TYPE_NORMAL
- en: To see how this works, take a look at the *main.c* file for [Project 38](nsp-boxall502581-0019.xhtml#pro38)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, we need to include the EEPROM library ❶ to take advantage
    of the functions to update and read bytes in the EEPROM. The first `for` loop
    repeats 16 times, updating the values in EEPROM locations 0 . . . 15 to 0 . . .
    15 ❷. The second loop retrieves the data from EEPROM locations 0 . . . 15 and
    sets the PORTB register to the number retrieved from the EEPROM ❸. This activates
    the LEDs connected to the matching pins of PORTB, thus displaying each value in
    binary.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to store small numbers in the microcontroller’s EEPROM,
    I’ll show you how to store larger numbers using words of data.
  prefs: []
  type: TYPE_NORMAL
- en: '[Storing Words](nsp-boxall502581-0008.xhtml#rah1102)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *word* of data uses 16 bits, or 2 bytes, to represent 16-bit signed or unsigned
    integers. As you learned in [Chapter 2](nsp-boxall502581-0012.xhtml#ch02) , these
    can be in the range of −32,768 to 32,767 for signed integers or 0 to 65,535 for
    unsigned integers. For example, a word could represent 12,345 or −23,567\. To
    write words, we again use functions from the EEPROM library, which we include
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To write a word of data, we use the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: where `a` is the location inside the EEPROM and `b` is the word of data to store.
    While a word of data is 2 bytes in size, an EEPROM location is 1 byte in size.
    This means that when you write a word of data it will fill two EEPROM locations.
    Consequently, if you want to write two words of data at the start of the EEPROM,
    you’ll need to write the first word to location 0 and the second word to location
    2.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with bytes, you can also update words. You do this with the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve the word of data stored in a location, use one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This allocates the value stored in EEPROM location `a` to the variable `i` .
    Note that `a` should be the first of the two locations where the word is stored, not
    the second (so, 0 or 2 in our previous example). You’ll test these functions out
    in the [next project](nsp-boxall502581-0019.xhtml#pro39) .
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 39: A Simple EEPROM Datalogger](nsp-boxall502581-0008.xhtml#rpro39)'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll create a basic data-logging device. It not only demonstrates
    writing words of data to and reading them from the ATmega328P-PU’s EEPROM but
    also incorporates the USART and custom functions. Instead of writing arbitrary
    numbers to the EEPROM, this project repeatedly reads the status of digital input
    pin PORTB0, writing a 0 or 1 to the specified EEPROM location (for low or high,
    respectively). We’ll use the USART to create a basic text-based interface control
    system to log, retrieve, and erase EEPROM data.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1101)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • USB-to-serial converter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 9-2](nsp-boxall502581-0019.xhtml#f09002)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 39](images/nsp-boxall502581-f09002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-2: Schematic for [Project 39](nsp-boxall502581-0019.xhtml#pro39)'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to connect the USB-to-serial converter as demonstrated in [Chapter
    4](nsp-boxall502581-0014.xhtml#ch04) . The positive and negative points shown
    in the schematic are used to log the low and high signals. To experiment, you
    could run tests connecting only the positive to 5 V or GND (the negative must
    always go to GND).
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh1102)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 39* subfolder of this book’s
    *Chapter 9* folder, and enter the command `make flash` . Then open the terminal
    software you installed in [Chapter 4](nsp-boxall502581-0014.xhtml#ch04) . After
    a moment you will be prompted to “Enter 1 to start, 2 to dump, 3 to erase.” Press
    **1** on your computer’s keyboard to run the data-logging function, **2** for
    the microcontroller to read the EEPROM and send the data back to the terminal
    window, or **3** to erase the data by writing all the EEPROM locations back to
    0.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-3](nsp-boxall502581-0019.xhtml#f09003) shows an example of this sequence.
    (In the interest of saving space, I’ve altered the code that produced this figure
    to use only the first 10 EEPROM locations. When you run the code, your sequences
    will be much longer.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the terminal software showing Project 39 in operation (capture
    and playback of logged data)](images/nsp-boxall502581-f09003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-3: Example output for [Project 39](nsp-boxall502581-0019.xhtml#pro39)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First we import all the required libraries and set the data speed for the USART,
    as usual. We also set `logDelay` to 1,000 ❶, specifying the delay in milliseconds
    between each logging event (you can change this value to suit your own needs).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare the functions required to initialize the USART ❷, send bytes
    from the USART to the computer ❸ and receive bytes coming in the other direction
    ❹, and send strings to the terminal emulator ❺. When needed, the user can call
    the data-logging function `logData()` ❻. This function reads the value of PORTB0
    and writes a 1 for high or 0 for low to the EEPROM locations from 0 to 1,022 in
    turn. The function skips writing to every second location, as we need two locations
    per byte. If you want to increase the time between logging events, you can adjust
    the speed, as mentioned earlier, by altering the value of `logDelay` ❶.
  prefs: []
  type: TYPE_NORMAL
- en: The function `dumpData()` ❼ sends the value of each EEPROM location to the USART
    and thus the PC for viewing. As with the `logData()` function, it skips every
    second location, since we use two locations per word. Before running this function,
    you can set the terminal software to capture output for further analysis with
    a spreadsheet, as demonstrated in [Project 19](nsp-boxall502581-0014.xhtml#pro19)
    in [Chapter 4](nsp-boxall502581-0014.xhtml#ch04) .
  prefs: []
  type: TYPE_NORMAL
- en: The `eraseData()` function ❽ writes a 0 in every EEPROM location, thus writing
    over any previously stored data. While not really necessary here, this function
    might be useful in your own future projects that require erasing data in the EEPROM.
  prefs: []
  type: TYPE_NORMAL
- en: The main code loop provides a user interface of sorts, by prompting the user
    for their selection ❾ and then calling the required function using the `switch...case`
    statement, following the displayed menu options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you can store and retrieve bytes and words of data in the EEPROM,
    we’ll move on to our final type of data: floating-point variables.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Storing Floating-Point Variables](nsp-boxall502581-0008.xhtml#rah1103)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *floating-point variable* represents a floating-point number (as described
    in [Chapter 3](nsp-boxall502581-0013.xhtml#ch03) ) that falls in the range of
    −3.39 × 10 ^(38) to 3.39 × 10 ^(38) . These variables require 32 bits of storage,
    or 4 bytes. To write a floating-point (float) variable, we again need to include
    the EEPROM library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the following function to write a word of data (for example, a
    number between 0 and 65,535):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: where `a` is the location inside the EEPROM and `b` is the float of data to
    store.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update a float stored in the EEPROM, we use this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As a float takes up 4 bytes and an EEPROM location can contain only 1 byte,
    you’ll need to allocate four EEPROM locations when storing a float. For example,
    if you were writing two floats of data at the start of the EEPROM, you’d write
    the first one to location 0 and the second to location 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve a float stored in a given location, use the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This allocates the value stored in EEPROM location `a` to the variable `i` .
    Remember that you always need to use the first location when using words. In the
    [next project](nsp-boxall502581-0019.xhtml#pro40) , you’ll put the ability to
    store floats in EEPROM to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 40: Temperature Logger with EEPROM](nsp-boxall502581-0008.xhtml#rpro40)'
  prefs: []
  type: TYPE_NORMAL
- en: This project combines your knowledge of capturing data with a TMP36 temperature
    sensor (introduced in [Chapter 3](nsp-boxall502581-0013.xhtml#ch03) ) and writing
    floating-point variable data to and reading it from the EEPROM, again using the
    USART and custom functions. The project code samples and stores the temperature
    in the EEPROM 256 times, so you can retrieve and view the readings with your terminal
    software or capture the data for spreadsheet analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh1103)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 5 V breadboard power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One TMP36 temperature sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 0.1 μF ceramic capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • USB-to-serial converter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 9-4](nsp-boxall502581-0019.xhtml#f09004)
    , using the external power supply and wiring up the USB-to-serial converter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 40](images/nsp-boxall502581-f09004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-4: Schematic for [Project 40](nsp-boxall502581-0019.xhtml#pro40)'
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 40* subfolder of this book’s
    *Chapter 9* folder, and enter the command `make flash` . Next, open the terminal
    application, just as you did for the [previous project](nsp-boxall502581-0019.xhtml#pro39)
    . After a moment you should be presented with the option to enter 1 to start,
    2 to dump, or 3 to erase. Pressing 1 on your computer’s keyboard should run the
    temperature data logging function; pressing 2 tells the microcontroller to read
    the EEPROM and send the temperature data back to the terminal software for display,
    and pressing 3 should erase the data by writing all the EEPROM locations back
    to 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-5](nsp-boxall502581-0019.xhtml#f09005) shows an example of this sequence.
    (Again, to save space, I’ve altered the code to use only the first six EEPROM
    locations.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the terminal software showing Project 40 in operation (capture
    and playback of logged temperatures)](images/nsp-boxall502581-f09005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-5: Example output for [Project 40](nsp-boxall502581-0019.xhtml#pro40)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the code to see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This project again pulls together knowledge from previous chapters to bring
    a new idea to life. First we import all the required libraries and set the data
    speed for the USART, as usual. I’ve again set the delay in milliseconds between
    each logging event to 1,000, but you can adjust the speed by altering the `logDelay`
    value ❶. Next, we provide the functions required to initialize and operate the
    ADC ❷ and the USART ❸, as in the [previous project](nsp-boxall502581-0019.xhtml#pro39)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The `readTemperature()` function ❹ takes the temperature readings from the TMP36;
    we’ll call this from the `logData()` function ❺, which stores these readings in
    the EEPROM locations from 0 to 1020 in turn, skipping three each time as we need
    four locations per float variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `dumpData()` function ❻ sends the value of each EEPROM location to the USART
    and thus to the PC for viewing. Like `logData()` , this function skips to every
    fourth EEPROM location so that we have space to store our float variables. Before
    running this function, you can set the terminal software to capture the output
    in a text file, which you can open in a spreadsheet; see [Project 19](nsp-boxall502581-0014.xhtml#pro19)
    in [Chapter 4](nsp-boxall502581-0014.xhtml#ch04) if you need a refresher on this.
  prefs: []
  type: TYPE_NORMAL
- en: The `eraseData()` function ❼ writes a 0 in every EEPROM location, thus erasing
    any previously stored data. As mentioned in [Project 39](nsp-boxall502581-0019.xhtml#pro39)
    , you may find it useful in your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: The main code loop provides a user interface of sorts, prompting the user to
    choose whether to log, dump, or erase the data ❽ and then calling the required
    function using the `switch...case` statement, following the displayed menu options.
  prefs: []
  type: TYPE_NORMAL
- en: Along with learning these EEPROM functions, in this chapter you’ve taken one
    step further toward developing complex projects that could inspire your own projects
    later in your microcontroller journey. In the [next chapter](nsp-boxall502581-0020.xhtml#ch10)
    , you’ll learn how to make your own libraries to save time and write more useful
    code.
  prefs: []
  type: TYPE_NORMAL
