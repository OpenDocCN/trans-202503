- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BASIC BINARY ANALYSIS IN LINUX
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Even in the most complex binary analysis, you can accomplish surprisingly advanced
    feats by combining a set of basic tools in the right way. This can save you hours
    of work implementing equivalent functionality on your own. In this chapter, you’ll
    learn the fundamental tools you’ll need to perform binary analysis on Linux.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Instead of simply showing you a list of tools and explaining what they do, I’ll
    use a *Capture the Flag (CTF)* challenge to illustrate how they work. In computer
    security and hacking, CTF challenges are often played as contests, where the goal
    is typically to analyze or exploit a given binary (or a running process or server)
    until you manage to capture a flag hidden in the binary. The flag is usually a
    hexadecimal string, which you can use to prove that you completed the challenge
    as well as unlock new challenges.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this CTF, you start with a mysterious file called *payload*, which you can
    find on the VM in the directory for this chapter. The goal is to figure out how
    to extract the hidden flag from *payload*. In the process of analyzing *payload*
    and looking for the flag, you’ll learn to use a wide range of basic binary analysis
    tools that are available on virtually any Linux-based system (most of them as
    part of GNU `coreutils` or `binutils`). I encourage you to follow along.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Most of the tools you’ll see have a number of useful options, but there are
    far too many to cover exhaustively in this chapter. Thus, it’s a good idea to
    check out the man page for every tool using the command `man` *tool* on the VM.
    At the end of the chapter, you’ll use the recovered flag to unlock a new challenge,
    which you can complete on your own!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Resolving Identity Crises Using file
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because you received absolutely no hints about the contents of *payload*, you
    have no idea what to do with this file. When this happens (for instance, in reverse
    engineering or forensics scenarios), a good first step is to figure out what you
    can about the file type and its contents. The `file` utility was designed for
    this purpose; it takes a number of files as input and then tells you what type
    each file is. You may remember it from [Chapter 2](ch02.xhtml#ch02), where I used
    `file` to find out the type of an ELF file.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'The nice thing about `file` is that it isn’t fooled by extensions. Instead,
    it searches for other telltale patterns in the file, such as magic bytes like
    the `0x7f ELF` sequence at the start of ELF files, to find out the file type.
    This is perfect here because the *payload* file doesn’t have an extension. Here’s
    what `file` tells you about *payload*:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, *payload* contains ASCII text. To examine the text in detail,
    you can use the `head` utility, which dumps the first few lines (10 by default)
    of a text file to `stdout`. There’s also an analogous utility called `tail`, which
    shows you the last few lines of a file. Here’s what the `head` utility’s output
    shows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That definitely doesn’t look human-readable. Taking a closer look at the alphabet
    used in the file, you can see that it consists of only alphanumeric characters
    and the characters + and /, organized in neat rows. When you see a file that looks
    like this, it’s usually safe to assume that it’s a *Base64* file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不像是人类可读的内容。仔细观察文件中使用的字母表，你会发现它只由字母数字字符和字符 + 与 / 组成，并且按整齐的行排列。当你看到这样的文件时，通常可以安全地假设它是一个*Base64*文件。
- en: Base64 is a widely used method of encoding binary data as ASCII text. Among
    other things, it’s commonly used in email and on the web to ensure that binary
    data transmitted over a network isn’t accidentally malformed by services that
    can handle only text. Conveniently, Linux systems come with a tool called `base64`
    (typically as part of GNU `coreutils`) that can encode and decode Base64\. By
    default, `base64` will encode any files or `stdin` input given to it. But you
    can use the `-d` flag to tell `base64` to decode instead. Let’s decode *payload*
    to see what you get!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Base64是一种广泛使用的将二进制数据编码为ASCII文本的方法。除其他外，它常用于电子邮件和网络上，以确保通过网络传输的二进制数据不会因只能处理文本的服务而被意外损坏。方便的是，Linux系统自带了一个名为`base64`的工具（通常是GNU
    `coreutils`的一部分），可以进行Base64编码和解码。默认情况下，`base64`会编码任何传递给它的文件或`stdin`输入。但你可以使用`-d`标志告诉`base64`进行解码。让我们解码*payload*看看会得到什么！
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command decodes *payload* and then stores the decoded contents in a new
    file called `decoded_payload`. Now that you’ve decoded *payload*, let’s use `file`
    again to check the type of the decoded file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令解码*payload*，然后将解码后的内容存储在一个名为`decoded_payload`的新文件中。现在你已经解码了*payload*，让我们再次使用`file`来检查解码后的文件类型。
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now you’re getting somewhere! It turns out that behind the layer of Base64
    encoding, the mysterious file is actually just a compressed archive that uses
    `gzip` as the outer compression layer. This is an opportunity to introduce another
    handy feature of `file`: the ability to peek inside zipped files. You can pass
    the `-z` option to `file` to see what’s inside the archive without extracting
    it. Here’s what you should see:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了进展！事实证明，在Base64编码层背后，神秘的文件实际上只是一个压缩归档文件，使用`gzip`作为外部压缩层。这是介绍`file`的另一个实用功能的好机会：能够窥视压缩文件内部。你可以通过为`file`传递`-z`选项，查看归档中的内容而无需解压。你应该会看到如下内容：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see that you’re dealing with multiple layers that you need to extract,
    because the outer layer is a `gzip` compression layer and inside that is a `tar`
    archive, which typically contains a bundle of files. To reveal the files stored
    inside, you use `tar` to unzip and extract `decoded_payload`, like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到你正在处理多个需要提取的层，因为最外层是一个`gzip`压缩层，而里面是一个`tar`归档文件，通常包含一组文件。为了查看存储在其中的文件，你可以使用`tar`解压并提取`decoded_payload`，像这样：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As shown in the `tar` log, there are two files extracted from the archive:
    *ctf* and *67b8601*. Let’s use `file` again to see what kinds of files you’re
    dealing with.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如`tar`日志所示，从归档中提取了两个文件：*ctf*和*67b8601*。让我们再次使用`file`，看看你正在处理哪些类型的文件。
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first file, *ctf*, is a dynamically linked 64-bit stripped ELF executable.
    The second file, called *67b8601*, is a bitmap (BMP) file of 512 × 512 pixels.
    Again, you can see this using `file` as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个文件，*ctf*，是一个动态链接的 64 位精简 ELF 可执行文件。第二个文件，名为*67b8601*，是一个 512 × 512 像素的位图（BMP）文件。你可以通过如下命令使用`file`看到这一点：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This BMP file depicts a black square, as you can see in [Figure 5-1a](ch05.xhtml#ch05fig1).
    If you look carefully, you should see some irregularly colored pixels at the bottom
    of the figure. [Figure 5-1b](ch05.xhtml#ch05fig1) shows an enlarged snippet of
    these pixels.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个BMP文件展示了一个黑色方块，正如你在[图5-1a](ch05.xhtml#ch05fig1)中看到的那样。如果你仔细观察，你应该能看到图底部有一些颜色不规则的像素。[图5-1b](ch05.xhtml#ch05fig1)显示了这些像素的放大片段。
- en: Before exploring what this all means, let’s first take a closer look at *ctf*,
    the ELF file you just extracted.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索这些含义之前，让我们先仔细看一下你刚刚提取的*ctf* ELF文件。
- en: '![image](Images/f092-01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f092-01.jpg)'
- en: '*Figure 5-1: The extracted BMP file, 67b8601*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：提取的 BMP 文件，67b8601*'
- en: 5.2 Using ldd to Explore Dependencies
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2 使用 ldd 探索依赖关系
- en: Although it’s not wise to run unknown binaries, since you’re working in a VM,
    let’s try running the extracted *ctf* binary. When you try to run the file, you
    don’t get far.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管运行未知的二进制文件并不明智，但由于你在虚拟机中工作，我们还是尝试运行提取的*ctf*二进制文件。当你尝试运行该文件时，你并没有走得太远。
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Before any of the application code is even executed, the dynamic linker complains
    about a missing library called *lib5ae9b7f.so*. That doesn’t sound like a library
    you normally find on any system. Before searching for this library, it makes sense
    to check whether *ctf* has any more unresolved dependencies.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux systems come with a program called `ldd`, which you can use to find out
    on which shared objects a binary depends and where (if anywhere) these dependencies
    are on your system. You can even use `ldd` along with the `-v` flag to find out
    which library versions the binary expects, which can be useful for debugging.
    As mentioned in the `ldd man` page, `ldd` may run the binary to figure out the
    dependencies, so it’s not safe to use on untrusted binaries unless you’re running
    it in a VM or another isolated environment. Here’s the `ldd` output for the *ctf*
    binary:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Luckily, there are no unresolved dependencies besides the missing library identified
    earlier, *lib5ae9b7f.so*. Now you can focus on figuring out what this mysterious
    library is and how you can obtain it in order to capture the flag!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Because it’s obvious from the library name that you won’t find it in any standard
    repository, it must reside somewhere in the files you’ve been given so far. Recall
    from [Chapter 2](ch02.xhtml#ch02) that all ELF binaries and libraries begin with
    the magic sequence `0x7f ELF`. This is a handy string to look for in search of
    your missing library; as long as the library is not encrypted, you should be able
    to find the ELF header this way. Let’s try a simple `grep` for the string `'ELF'`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As expected, the string `'ELF'` appears in *ctf*, which is not surprising because
    you already know it’s an ELF binary. But you can see that this string is also
    in *67b8601*, which at first glance appeared to be an innocent bitmap file. Could
    there be a shared library hidden within the bitmap’s pixel data? It would certainly
    explain those strangely colored pixels you saw in [Figure 5-1b](ch05.xhtml#ch05fig1)!
    Let’s examine the contents of *67b8601* in more detail to find out.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Quickly Looking Up ASCII Codes
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'When interpreting raw bytes as ASCII, you’ll often need a table that maps byte
    values in various representations to ASCII symbols. You can use a special man
    page called `man ascii` for quick access to such a table. Here’s an excerpt of
    the table from `man ascii`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '| `Oct` | `Dec` | `Hex` | `Char` | `Oct` | `Dec` | `Hex` | `Char` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| `000` | `0` | `00` | `NUL ''\0'' (null character)` | `100` | `64` | `40`
    | `@` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| `001` | `1` | `01` | `SOH (start of heading)` | `101` | `65` | `41` | `A`
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| `002` | `2` | `02` | `STX (start of text)` | `102` | `66` | `42` | `B` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| `003` | `3` | `03` | `ETX (end of text)` | `103` | `67` | `43` | `C` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| `004` | `4` | `04` | `EOT (end of transmission)` | `104` | `68` | `44` |
    `D` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| `005` | `5` | `05` | `ENQ (enquiry)` | `105` | `69` | `45` | `E` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| `006` | `6` | `06` | `ACK (acknowledge)` | `106` | `70` | `46` | `F` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `006` | `6` | `06` | `ACK (acknowledge)` | `106` | `70` | `46` | `F` |'
- en: '| `007` | `7` | `07` | `BEL ''\a'' (bell)` | `107` | `71` | `47` | `G` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `007` | `7` | `07` | `BEL ''\a'' (bell)` | `107` | `71` | `47` | `G` |'
- en: '| `...` |  |  |  |  |  |  |  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `...` |  |  |  |  |  |  |  |'
- en: As you can see, this is an easy way to look up the mappings from octal, decimal,
    and hexadecimal encodings to ASCII characters. This is much faster than googling
    for an ASCII table!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一种快速查找从八进制、十进制和十六进制编码到 ASCII 字符映射的方法。比起在 Google 上查找 ASCII 表，这要快得多！
- en: 5.3 Viewing File Contents with xxd
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3 使用 xxd 查看文件内容
- en: To discover exactly what’s in a file without being able to rely on any standard
    assumptions about the file contents, you’ll have to analyze it at the byte level.
    To do this, you can use any numeric system to display bits and bytes on the screen.
    For instance, you could use the binary system, displaying all the ones and zeros
    individually. But because that makes for some tedious analysis, it’s better to
    use the *hexadecimal system*. In the hexadecimal system (also known as *base 16*,
    or *hex* for short), digits range from 0 to 9 (with the usual meaning) and then
    from *a* to *f* (where *a* represents the value 10 and *f* represents 15). In
    addition, because a byte has 256 = 16 × 16 possible values, it fits exactly in
    two hexadecimal digits, making this a convenient encoding for compactly displaying
    bytes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要发现文件中究竟包含什么内容，而又不能依赖于关于文件内容的任何标准假设，你必须在字节级别进行分析。为此，你可以使用任何数字系统来显示屏幕上的位和字节。例如，你可以使用二进制系统，逐个显示所有的
    1 和 0。但由于这种方法分析起来非常繁琐，最好使用*十六进制系统*。在十六进制系统中（也称为*基数 16*，简称*hex*），数字从 0 到 9（含普通意义）开始，接着是
    *a* 到 *f*（其中 *a* 表示值 10，*f* 表示值 15）。此外，由于一个字节有 256 = 16 × 16 种可能的值，它正好可以用两位十六进制数字表示，这使得它成为一个方便的编码方式，用于紧凑地显示字节。
- en: To display the bytes of a file in hexadecimal representation, you use a *hex-dumping*
    program. A *hex editor* is a program that can also edit the bytes in the file.
    I’ll get back to hex editing in [Chapter 7](ch07.xhtml#ch07), but for now let’s
    use a simple hex-dumping program called `xxd`, which is installed on most Linux
    systems by default.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要以十六进制表示文件的字节，你可以使用*十六进制转储*程序。*十六进制编辑器*是一个也可以编辑文件字节的程序。我将在[第 7 章](ch07.xhtml#ch07)中详细讲解十六进制编辑，但现在我们先使用一个简单的十六进制转储程序叫做`xxd`，它默认安装在大多数
    Linux 系统中。
- en: 'Here are the first 15 lines of output from `xxd` for the bitmap file you’re
    analyzing:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你正在分析的位图文件通过`xxd`命令输出的前 15 行内容：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the first output column shows the offset into the file in hexadecimal
    format. The next eight columns show hexadecimal representations of the bytes in
    the file, and on the rightmost side of the output, you can see an ASCII representation
    of the same bytes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，第一列输出显示了文件的偏移量，以十六进制格式表示。接下来的八列显示文件中字节的十六进制表示，在输出的最右侧，你可以看到相同字节的 ASCII
    表示。
- en: You can change the number of bytes displayed per line using the `xxd` program’s
    `-c` option. For instance, `xxd -c 32` will display 32 bytes per line. You can
    also use `-b` to display binary instead of hexadecimal, and you can use `-i` to
    output a C-style array containing the bytes, which you can directly include in
    your C or C++ source. To output only some of the bytes, you can use the `-s` (seek)
    option to specify a file offset at which to start, and you can use the `-l` (length)
    option to specify the number of bytes to dump.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `xxd` 程序的 `-c` 选项来更改每行显示的字节数。例如，`xxd -c 32` 会每行显示 32 个字节。你还可以使用 `-b` 选项显示二进制而不是十六进制，并且可以使用
    `-i` 选项输出一个包含字节的 C 风格数组，你可以直接将其包含在 C 或 C++ 源代码中。要仅输出文件中的部分字节，你可以使用 `-s`（寻址）选项指定开始的位置，并可以使用
    `-l`（长度）选项指定要转储的字节数。
- en: In the `xxd` output for the bitmap file, the ELF magic bytes appear at offset
    `0x34` ➊, which corresponds to 52 in the decimal system. This tells you where
    in the file the suspected ELF library begins. Unfortunately, finding out where
    it ends is not so trivial because there are no magic bytes delimiting the end
    of an ELF file. Thus, before you try to extract the complete ELF file, begin by
    extracting only the ELF header instead. This is easier since you know that 64-bit
    ELF headers contain exactly 64 bytes. You can then examine the ELF header to figure
    out how large the complete file is.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: To extract the header, you use `dd` to copy 64 bytes from the bitmap file, starting
    at offset 52, into a new output file called *elf_header*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using `dd` is incidental here, so I won’t explain it in detail. However, `dd`
    is an extremely versatile^([1](footnote.xhtml#ch05fn_1)) tool, so it’s worth reading
    its man page if you aren’t already familiar with it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use `xxd` again to see whether it worked.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That looks like an ELF header! You can clearly see the magic bytes at the start
    ➊, and you can also see that the `e_ident` array and other fields look reasonable
    (refer to [Chapter 2](ch02.xhtml#ch02) for a description of these fields).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Parsing the Extracted ELF with readelf
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To view the details of the ELF header you just extracted, it would be great
    if you could use `readelf`, like you did in [Chapter 2](ch02.xhtml#ch02). But
    will `readelf` work on a broken ELF file that contains nothing but a header? Let’s
    find out in [Listing 5-1](ch05.xhtml#ch05list1)!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-1: The* readelf *output for the extracted ELF header*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `-h` option ➊ tells `readelf` to print only the executable header. It still
    complains that the offsets to the section header table and program header table
    point outside the file, but that’s okay. What matters is that you now have a convenient
    representation of the extracted ELF header.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how can you figure out the size of the complete ELF using nothing but
    the executable header? In [Figure 2-1](ch02.xhtml#ch02fig1) of [Chapter 2](ch02.xhtml#ch02),
    you learned that the last part of an ELF file is typically the section header
    table and that the offset to the section header table is given in the executable
    header ➋. The executable header also tells you the size of each section header
    ➌ and the number of section headers in the table ➍. This means you can calculate
    the size of the complete ELF library hidden in your bitmap file as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f096-01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: In this equation, *size* is the size of the complete library, *e*_*shoff* is
    the offset to the section header table, *e*_*shnum* is the number of section headers
    in the table, and *e*_*shentsize* is the size of each section header.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know that the size of the library should be 10,296 bytes, you
    can use `dd` to extract it completely, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `dd` command calls the extracted file *lib5ae9b7f.so* ➊ because that’s the
    name of the missing library the *ctf* binary expects. After running this command,
    you should now have a fully functioning ELF shared object. Let’s use `readelf`
    to see whether all went well, as shown in [Listing 5-2](ch05.xhtml#ch05list2).
    To keep the output brief, let’s only print the executable header (`-h`) and symbol
    tables (`-s`). The latter should give you an idea of the functionality that the
    library provides.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`dd`命令调用提取的文件*lib5ae9b7f.so* ➊，因为这是*ctf*二进制文件期望的缺失库的名称。运行此命令后，你现在应该拥有一个完全功能的ELF共享对象。让我们使用`readelf`来查看是否一切顺利，如[清单
    5-2](ch05.xhtml#ch05list2)所示。为了简洁起见，我们只打印可执行文件头（`-h`）和符号表（`-s`）。后者应能帮助你了解库所提供的功能。'
- en: '*Listing 5-2: The* readelf *output for the extracted library,* lib5ae9b7f.so'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-2：提取的库的*readelf*输出，*lib5ae9b7f.so*'
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As hoped, the complete library seems to have been extracted correctly. Although
    it’s stripped, the dynamic symbol table does reveal some interesting exported
    functions (➊ through ➎). However, there seems to be some gibberish around the
    names, making them difficult to read. Let’s see if that can be fixed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如期望的那样，完整的库似乎已经被正确提取。尽管它被剥离了，但动态符号表确实显示了一些有趣的导出函数（➊到➎）。然而，函数名周围似乎有一些乱码，导致它们难以阅读。让我们看看是否可以解决这个问题。
- en: 5.5 Parsing Symbols with nm
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5 使用nm解析符号
- en: C++ allows functions to be *overloaded*, which means there may be multiple functions
    with the same name, as long as they have different signatures. Unfortunately for
    the linker, it doesn’t know anything about C++. For example, if there are multiple
    functions with the name `foo`, the linker has no idea how to resolve references
    to `foo`; it simply doesn’t know which version of `foo` to use. To eliminate duplicate
    names, C++ compilers emit *mangled* function names. A mangled name is essentially
    a combination of the original function name and an encoding of the function parameters.
    This way, each version of the function gets a unique name, and the linker has
    no problems disambiguating the overloaded functions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许函数*重载*，这意味着可能有多个同名函数，只要它们具有不同的签名。对于链接器来说，这却是个问题，因为它对C++一无所知。例如，如果有多个名为`foo`的函数，链接器不知道如何解决对`foo`的引用；它根本不知道使用哪个版本的`foo`。为了消除重复的名称，C++编译器会生成*破坏*的函数名。破坏的函数名本质上是原始函数名和函数参数的编码组合。这样，每个版本的函数都会有一个唯一的名称，链接器就能够轻松区分重载的函数。
- en: For binary analysts, mangled function names are a mixed blessing. On the one
    hand, mangled names are more difficult to read, as you saw in the `readelf` output
    for *lib5ae9b7f.so* ([Listing 5-2](ch05.xhtml#ch05list2)), which is programmed
    in C++. On the other hand, mangled function names essentially provide free type
    information by revealing the expected parameters of the function, and this information
    can be useful when reverse engineering a binary.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二进制分析师来说，名称被“破坏”（mangled）的函数名是一种复杂的祝福。一方面，破坏后的函数名更难以阅读，正如你在`readelf`输出中看到的*lib5ae9b7f.so*（见[清单
    5-2](ch05.xhtml#ch05list2)）所示，它是用C++编写的。另一方面，破坏后的函数名实际上通过揭示函数的预期参数提供了免费的类型信息，这在逆向工程二进制文件时非常有用。
- en: Fortunately, the benefits of mangled names outweigh the downsides because mangled
    names are relatively easy to *demangle*. There are several standard tools you
    can use to demangle mangled names. One of the best known is `nm`, which lists
    symbols in a given binary, object file, or shared object. When given a binary,
    `nm` by default attempts to parse the static symbol table.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，破坏后的函数名带来的好处大于缺点，因为它们相对容易被*还原*。有几个标准工具可以用来还原破坏的函数名。其中最著名的工具之一是`nm`，它可以列出给定二进制文件、目标文件或共享对象的符号。当给定一个二进制文件时，`nm`默认尝试解析静态符号表。
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Unfortunately, as this example shows, you can’t use `nm`’s default configuration
    on *lib5ae9b7f.so* because it has been stripped. You have to explicitly ask `nm`
    to parse the dynamic symbol table instead, using the `-D` switch, as shown in
    [Listing 5-3](ch05.xhtml#ch05list3). In this listing, “`...`” indicates that I’ve
    truncated a line and continued it on the next line (mangled names can be quite
    long).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，正如这个例子所示，你不能在*lib5ae9b7f.so*上使用`nm`的默认配置，因为它已经被剥离。你必须显式地要求`nm`解析动态符号表，使用`-D`开关，如[清单
    5-3](ch05.xhtml#ch05list3)所示。在这个清单中，"`...`"表示我已经截断了一行并将其继续到下一行（破坏的函数名可能非常长）。
- en: '*Listing 5-3: The* nm *output for* lib5ae9b7f.so'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-3：*nm*输出，*lib5ae9b7f.so*'
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This looks better; this time you see some symbols. But the symbol names are
    still mangled. To demangle them, you have to pass the `--demangle` switch to `nm`,
    as shown in [Listing 5-4](ch05.xhtml#ch05list4).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这样看起来好多了，这次你看到了一些符号。但符号名称仍然是混淆的。要去混淆它们，你需要将 `--demangle` 选项传递给 `nm`，如 [清单 5-4](ch05.xhtml#ch05list4)
    所示。
- en: '*Listing 5-4: Demangled* nm *output for* lib5ae9b7f.so'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-4：* lib5ae9b7f.so 的 *nm* 输出（已去除混淆）'
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, the function names appear human-readable. You can see five interesting
    functions, which appear to be cryptographic functions implementing the well-known
    RC4 encryption algorithm.^([2](footnote.xhtml#ch05fn_2)) There’s a function called
    `rc4_init`, which takes as input a data structure of type `rc4_state_t`, as well
    as an unsigned character string and an integer ➎. The first parameter is presumably
    a data structure where the cryptographic state is kept, while the next two are
    probably a string representing a key and an integer specifying the length of the
    key, respectively. You can also see several encryption and decryption functions,
    each of which takes a pointer to the cryptographic state, as well as parameters
    specifying strings (both C and C++ strings) to encrypt or decrypt (➊ through ➍).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，函数名称变得易于阅读。你可以看到五个有趣的函数，它们似乎是实现了著名的 RC4 加密算法的加密函数。^([2](footnote.xhtml#ch05fn_2))
    有一个名为 `rc4_init` 的函数，它接受一个类型为 `rc4_state_t` 的数据结构作为输入，以及一个无符号字符字符串和一个整数 ➎。第一个参数可能是一个存储加密状态的数据结构，而接下来的两个参数分别可能是表示密钥的字符串和指定密钥长度的整数。你还可以看到几个加密和解密函数，每个函数都接受指向加密状态的指针，并且有参数指定要加密或解密的字符串（包括
    C 和 C++ 字符串）（➊ 到 ➍）。
- en: 'As an alternative way of demangling function names, you can use a specialized
    utility called `c++filt`, which takes a mangled name as the input and outputs
    the demangled equivalent. The advantage of `c++filt` is that it supports several
    mangling formats and automatically detects the correct mangling format for the
    given input. Here’s an example using `c++filt` to demangle the function name `_Z8rc4_initP11rc4_state_tPhi`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为去混淆函数名称的另一种方法，你可以使用名为 `c++filt` 的专用工具，它接受混淆过的名称作为输入并输出去混淆后的等效名称。`c++filt`
    的优势在于它支持多种混淆格式，并自动检测给定输入的正确混淆格式。以下是使用 `c++filt` 去混淆函数名称 `_Z8rc4_initP11rc4_state_tPhi`
    的示例：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At this point, let’s briefly recap the progress so far. You extracted the mysterious
    payload and found a binary called *ctf* that depends on a file called *lib5ae9b7f.so*.
    You found *lib5ae9b7f.so* hidden in a bitmap file and successfully extracted it.
    You also have a rough idea of what it does: it’s a cryptographic library. Now
    let’s try running *ctf* again, this time with no missing dependencies.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要回顾一下迄今为止的进展。你提取了神秘的有效负载，并找到了一个名为 *ctf* 的二进制文件，它依赖于一个名为 *lib5ae9b7f.so*
    的文件。你找到了隐藏在位图文件中的 *lib5ae9b7f.so* 并成功提取出来。你也大致了解了它的功能：它是一个加密库。现在，让我们再次尝试运行 *ctf*，这次不再缺少任何依赖项。
- en: When you run a binary, the linker resolves the binary’s dependencies by searching
    a number of standard directories for shared libraries, such as */lib*. Because
    you extracted *lib5ae9b7f.so* to a nonstandard directory, you need to tell the
    linker to search that directory too by setting an environment variable called
    `LD_LIBRARY_PATH`. Let’s set this variable to contain the current working directory
    and then try launching *ctf* again.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行一个二进制文件时，链接器通过搜索多个标准目录中的共享库来解析二进制文件的依赖项，例如 */lib*。由于你将 *lib5ae9b7f.so* 提取到了一个非标准目录，你需要告诉链接器也去该目录搜索，通过设置一个名为
    `LD_LIBRARY_PATH` 的环境变量。让我们将该变量设置为当前工作目录，然后再次尝试启动 *ctf*。
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Success! The *ctf* binary still doesn’t appear to do anything useful, but it
    runs without complaining about any missing libraries. The exit status of *ctf*
    contained in the `$?` variable is 1, indicating an error. Now that you have all
    the required dependencies, you can continue your investigation and see whether
    you can coax *ctf* into getting past the error so that you can reach the flag
    you’re trying to capture.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！*ctf* 二进制文件看起来仍然没有做任何有用的事情，但它能够运行，并且没有抱怨缺少任何库文件。*ctf* 的退出状态（保存在 `$?` 变量中）是
    1，表示发生了错误。现在你已经拥有了所有必需的依赖项，可以继续调查并看看你是否能够让 *ctf* 克服错误，从而达到你要捕捉的标志。
- en: 5.6 Looking for Hints with strings
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6 使用 strings 寻找线索
- en: To figure out what a binary does and what kinds of inputs it expects, you can
    check whether the binary contains any helpful strings that can reveal its purpose.
    For instance, if you see strings containing parts of HTTP requests or URLs, you
    can safely guess that the binary is doing something web related. When you’re dealing
    with malware such as a bot, you might be able to find strings containing the commands
    that the bot accepts, if they’re not obfuscated. You might even find strings left
    over from debugging that the programmer forgot to remove, which has been known
    to happen in real-world malware!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了弄清楚一个二进制文件的功能以及它期望的输入类型，你可以检查该二进制文件是否包含任何有助于揭示其目的的字符串。例如，如果你看到包含HTTP请求或URL的字符串，你可以安全地猜测该二进制文件正在执行与Web相关的操作。当你处理恶意软件（如bot）时，如果这些字符串没有被混淆，你可能会找到包含bot接受的命令的字符串。你甚至可能会发现一些调试时留下的字符串，程序员忘记删除这些字符串，这种情况在实际的恶意软件中也曾发生过！
- en: You can use a utility called `strings` to check for strings in a binary (or
    any other file) on Linux. The `strings` utility takes one or more files as input
    and then prints any printable character strings found in those files. Note that
    `strings` doesn’t check whether the found strings were really intended to be human
    readable, so when used on binary files, the `strings` output may include some
    bogus strings as a result of binary sequences that just happen to be printable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个名为`strings`的工具来检查Linux上二进制文件（或其他任何文件）中的字符串。`strings`工具接受一个或多个文件作为输入，然后打印出这些文件中找到的所有可打印字符字符串。请注意，`strings`并不会检查所找到的字符串是否真的被设计为可读的，所以当它用于二进制文件时，`strings`的输出可能会包含一些虚假的字符串，这些字符串可能是二进制序列偶然变得可打印的结果。
- en: You can tweak the behavior of `strings` using options. For example, you can
    use the `-d` switch with `strings` to print only strings found in data sections
    in a binary instead of printing all sections. By default, `strings` prints only
    strings of four characters or more, but you can specify another minimum string
    length using the `-n` option. For our purposes, the default options will suffice;
    let’s see what you can find in the *ctf* binary using `strings`, as shown in [Listing
    5-5](ch05.xhtml#ch05list5).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用选项来调整`strings`的行为。例如，你可以使用`-d`选项与`strings`一起使用，以仅打印出在二进制文件的数据部分中找到的字符串，而不是打印所有部分。默认情况下，`strings`只打印四个字符或更多的字符串，但你可以使用`-n`选项指定其他最小字符串长度。就我们的目的而言，默认选项就足够了；让我们看看你能在*ctf*二进制文件中使用`strings`找到什么，如[列表
    5-5](ch05.xhtml#ch05list5)所示。
- en: '*Listing 5-5: Character strings found in the* ctf *binary*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：在* ctf *二进制文件中找到的字符字符串*'
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, you can see some strings that you’ll encounter in most ELF files. For
    example, there’s the name of the program interpreter ➊, as found in the `.interp`
    section, and some symbolic names found in `.dynstr` ➋. At the end of the `strings`
    output, you can see all the section names as found in the `.shstrtab` section
    ➐. But none of these strings is very interesting for the purposes here.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到一些在大多数ELF文件中都会遇到的字符串。例如，程序解释器的名称➊，可以在`.interp`部分找到，以及一些在`.dynstr`部分找到的符号名称➋。在`strings`的输出末尾，你可以看到所有在`.shstrtab`部分找到的节名称➐。但这些字符串在此并没有什么特别有趣的地方。
- en: Fortunately, there are also some more useful strings. For example, there is
    what appears to be a debug message, which suggests that the program expects a
    command line option ➌. There are also checks of some sort, presumably performed
    on an input string ➍. You don’t yet know what the value of the command line option
    should be, but you could try some of the other interesting-looking strings, such
    as `show_me_the_flag` ➎, that might work. There’s also a mysterious string ➏ that
    contains a message whose purpose is unclear. You don’t know what the message means
    at this point, but you do know from your investigation of *lib5ae9b7f.so* that
    the binary uses RC4 encryption. Perhaps the message is used as an encryption key?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，还有一些更有用的字符串。例如，似乎有一条调试信息，暗示程序期望一个命令行选项➌。还有一些检查，可能是针对输入字符串执行的检查➍。你现在还不知道命令行选项的值应该是什么，但你可以尝试一些其他看起来有趣的字符串，例如`show_me_the_flag`➎，它可能有效。还有一个神秘的字符串➏，它包含一条含义不明的消息。你现在不知道这条消息的意思，但你从对*lib5ae9b7f.so*的调查中知道，二进制文件使用了RC4加密。也许这条消息是用作加密密钥？
- en: 'Now that you know that the binary expects a command line option, let’s see
    whether adding an arbitrary option gets you any closer to revealing the flag.
    For lack of a better guess, let’s simply use the string `foobar`, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了二进制文件期望一个命令行选项，让我们看看添加一个任意选项是否能让你更接近揭示旗标。为了没有更好的猜测，我们就简单地使用字符串`foobar`，如下所示：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The binary now does something new. It tells you that it’s checking the input
    string you gave it. But the check doesn’t succeed because the binary still exits
    with an error code after the check. Let’s take a gamble and try one of the other
    interesting-looking strings that you found, such as the string `show_me_the_flag`,
    which looks promising.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That did it! The check now appears to succeed. Unfortunately, the exit status
    is still 1, so there must be something else missing. To make things worse, the
    `strings` results don’t provide any more hints. Let’s take a more detailed look
    at *ctf* ’s behavior to determine what to do next, starting with the system and
    library calls *ctf* makes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 5.7 Tracing System Calls and Library Calls with strace and ltrace
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make forward progress, let’s investigate the reason that *ctf* exits with
    an error code by looking at *ctf* ’s behavior just before it exits. There are
    many ways that you could do this, but one way is to use two tools called `strace`
    and `ltrace`. These tools show the system calls and library calls, respectively,
    executed by a binary. Knowing the system and library calls that a binary makes
    can often give you a good high-level idea of what the program is doing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by using `strace` to investigate *ctf* ’s system call behavior.
    In some cases, you may want to attach `strace` to a running process. To do this,
    you need to use the `-p` *pid* option, where *pid* is the process ID of the process
    you want to attach to. However, in this case, it suffices to run *ctf* with `strace`
    from the start. [Listing 5-6](ch05.xhtml#ch05list6) shows the `strace` output
    for the *ctf* binary (some parts are truncated with “`...`”).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-6: System calls executed by the* ctf *binary*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When tracing a program from the start, `strace` includes all the system calls
    used by the program interpreter to set up the process, making the output quite
    verbose. The first system call in the output is `execve`, which is called by your
    shell to launch the program ➊. After that, the program interpreter takes over
    and starts setting up the execution environment. This involves setting up memory
    regions and setting the correct memory access permissions using `mprotect`. Additionally,
    you can see the system calls used to look up and load the required dynamic libraries.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Recall that in [Section 5.5](ch05.xhtml#ch05_5), you set the `LD_LIBRARY_PATH`
    environment variable to tell the dynamic linker to add your current working directory
    to its search path. This is why you can see the dynamic linker searching for the
    *lib5ae9b7f.so* library in a number of standard subfolders in your current working
    directory, until it finally finds the library in the root of your working directory
    ➋. When the library is found, the dynamic linker reads it and maps it into memory
    ➌. The setup process is repeated for other required libraries, such as *libstdc++.so.6*
    ➍, and it accounts for the vast majority of the `strace` output.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: It isn’t until the last three system calls that you finally see application-specific
    behavior. The first system call used by *ctf* itself is `write`, which is used
    to print `checking 'show_me_the_flag'` to the screen ➎. You see another `write`
    call to print the string `ok` ➏, and finally, there’s a call to `exit_group`,
    which leads to the exit with status code 1 ➐.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: That’s all interesting, but how does it help you figure out how to extract the
    flag from *ctf* ? The answer is that it doesn’t! In this case, `strace` didn’t
    reveal anything helpful, but I still wanted to show you how it works because it
    can be useful for understanding a program’s behavior. For instance, observing
    the system calls executed by a program is useful not only for binary analysis
    but also for debugging.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Looking at *ctf* ’s system call behavior didn’t help much, so let’s try library
    calls. To view the library calls executed by *ctf*, you use `ltrace`. Because
    `ltrace` is a close relative of `strace`, it takes many of the same command line
    options, including `-p` to attach to an existing process. Here, let’s use the
    `-i` option to print the instruction pointer at every library call (this will
    be useful later). We’ll use `-C` to automatically demangle C++ function names.
    Let’s run *ctf* with `ltrace` from the start, as shown in [Listing 5-7](ch05.xhtml#ch05list7).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-7: Library calls made by the* ctf *binary*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, this output from `ltrace` is a lot more readable than the `strace`
    output because it isn’t polluted by all the process setup code. The first library
    call is `__libc_start_main` ➊, which is called from the `_start` function to transfer
    control to the program’s `main` function. Once `main` is started, its first library
    call prints the now familiar `checking ...` string to the screen ➋. The actual
    check turns out to be a string comparison, which is implemented using `strcmp`,
    and verifies that the argument given to *ctf* is equal to `show_me_the_flag` ➌.
    If this is the case, `ok` is printed to the screen ➍.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, this is mostly behavior you’ve seen before. But now you see something
    new: the RC4 cryptography is initialized through a call to `rc4_init`, which is
    located in the library you extracted earlier ➎. After that, you see an `assign`
    to a C++ string, presumably initializing it with an encrypted message ➏. This
    message is then decrypted with a call to `rc4_decrypt` ➐, and the decrypted message
    is assigned to a new C++ string ➑.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there’s a call to `getenv`, which is a standard library function used
    to look up environment variables ➒. You can see that *ctf* expects an environment
    variable called `GUESSME`! The name of this variable may well be the string that
    was decrypted earlier. Let’s see whether *ctf* ’s behavior changes when you set
    a dummy value for the `GUESSME` environment variable as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Setting `GUESSME` results in an additional line of output that says `guess again!`.
    It seems that *ctf* expects `GUESSME` to be set to another specific value. Perhaps
    another `ltrace` run, as shown in [Listing 5-8](ch05.xhtml#ch05list8), will reveal
    what the expected value is.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-8: Library calls made by the* ctf *binary after setting the* GUESSME
    *environment variable*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After the call to `getenv`, *ctf* goes on to assign ➊ and decrypt ➋ another
    C++ string. Unfortunately, between the decryption and the moment that `guess again`
    is printed to the screen ➌, you don’t see any hints regarding the expected value
    of `GUESSME`. This tells you that the comparison of `GUESSME` to its expected
    value is implemented without the use of any library functions. You’ll need to
    take another approach.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 5.8 Examining Instruction-Level Behavior Using objdump
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because you know that the value of the `GUESSME` environment variable is checked
    without using any well-known library functions, a logical next step is to use
    `objdump` to examine *ctf* at the instruction level to find out what’s going on.^([3](footnote.xhtml#ch05fn_3))
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: From the `ltrace` output in [Listing 5-8](ch05.xhtml#ch05list8), you know that
    the `guess again` string is printed to the screen by a call to `puts` at address
    `0x400dd7`. Let’s focus the `objdump` investigation around this address. It will
    also help to know the address of the string to find the first instruction that
    loads it. To find this address, you can look at the `.rodata` section of the *ctf*
    binary using `objdump -s` to print the full section contents, as shown in [Listing
    5-9](ch05.xhtml#ch05list9).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-9: The contents of* ctf*’s* .rodata *section as shown by* objdump'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using `objdump` to examine *ctf* ’s `.rodata` section, you can see the `guess
    again` string at address `0x4011af` ➊. Now let’s take a look at [Listing 5-10](ch05.xhtml#ch05list10),
    which shows the instructions around the `puts` call, to find out what input *ctf*
    expects for the `GUESSME` environment variable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-10: Instructions checking the value of* GUESSME'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `guess again` string is loaded by the instruction at `0x400dcd` ➍ and is
    then printed using `puts` ➎. This is the failure case; let’s work our way backward
    from here.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The failure case is reached from a loop that starts at address `0x400dc0`. In
    each iteration of the loop, it loads a byte from an array (probably a string)
    into `edx` ➊. The `rbx` register points to the base of this array, while `rax`
    indexes it. If the loaded byte turns out to be `NULL`, then the `je` instruction
    at `0x400dc6` jumps to the failure case ➋. This comparison to `NULL` is a check
    for the end of the string. If the end of the string is reached here, then it’s
    too short to be a match. If the byte is not `NULL`, the `je` falls through to
    the next instruction, at address `0x400dc8`, which compares the byte in `edx`
    against a byte in another string, based at `rcx` and indexed by `rax` ➌.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: If the two compared bytes match up, then the program jumps to address `0x400de0`,
    where it increases the string index ➏, and checks whether the string index is
    equal to `0x15`, the length of the string ➐. If it is, then the string comparison
    is complete; if not, the program jumps into another iteration of the loop ➑.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: From this analysis, you now know that the string based at the `rcx` register
    is used as a ground truth. The program compares the environment string taken from
    the `GUESSME` variable against this ground truth. This means that if you can dump
    the ground truth string, you can find the expected value for `GUESSME`! Because
    the string is decrypted at runtime and isn’t available statically, you’ll need
    to use dynamic analysis to recover it instead of using `objdump`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 5.9 Dumping a Dynamic String Buffer Using gdb
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Probably the most used dynamic analysis tool on GNU/Linux is `gdb`, or the GNU
    Debugger. As the name suggests, `gdb` is mainly for debugging, but it can be used
    for a variety of dynamic analysis purposes. In fact, it’s an extremely versatile
    tool, and there’s no way to cover all of its functionality in this chapter. However,
    I’ll go over some of the most-used features of `gdb` you can use to recover the
    expected value of `GUESSME`. The best place to look up information on `gdb` is
    not the man page but *[http://www.gnu.org/software/gdb/documentation/](http://www.gnu.org/software/gdb/documentation/)*,
    where you’ll find an extensive manual covering all the supported `gdb` commands.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `strace` and `ltrace`, `gdb` has the ability to attach to a running process.
    However, because *ctf* is not a long-running process, you can simply run it with
    `gdb` from the start. Because `gdb` is an interactive tool, when you start a binary
    under `gdb`, it’s not immediately executed. After printing a startup message with
    some usage instructions, `gdb` pauses and waits for a command. You can tell that
    `gdb` is waiting for a command by the command prompt: `(gdb)`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-11](ch05.xhtml#ch05list11) shows the sequence of `gdb` commands
    needed to find the expected value of the `GUESSME` environment variable. I’ll
    explain each of these commands as I discuss the listing.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-11: Finding the expected value of* GUESSME *using* gdb'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: One of the most basic functions of any debugger is setting a *breakpoint*, which
    is simply an address or a function name at which the debugger will “break” execution.
    Whenever the debugger reaches a breakpoint, it pauses execution and returns control
    to the user, waiting for a command. To dump the “magic” string against which the
    `GUESSME` environment variable is compared, you set a breakpoint at address `0x400dc8`
    ➊ where the comparison happens. In `gdb`, the command for setting a breakpoint
    at an address is `b` **address* (`b` is a short version of the command `break`).
    If symbols are available (they aren’t in this case), you can set a breakpoint
    at the entry point of a function using the function’s name. For instance, to set
    a breakpoint at the start of `main`, you would use the command `b main`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: After setting the breakpoint, you need to do one more thing before you can start
    the execution of *ctf* . You still need to set a value for the `GUESSME` environment
    variable to prevent *ctf* from exiting prematurely. In `gdb`, you can set the
    `GUESSME` environment variable using the command `set env GUESSME=foobar` ➋. Now,
    you can begin the execution of *ctf* by issuing the command `run show_me_the_flag`
    ➌. As you can see, you can pass arguments to the `run` command, which it then
    automatically passes on to the binary you’re analyzing (in this case, *ctf* ).
    Now, *ctf* begins executing normally, and it should continue doing so until it
    hits your breakpoint.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: When *ctf* hits the breakpoint, `gdb` halts the execution of *ctf* and returns
    control to you, informing you that a breakpoint was hit ➍. At this point, you
    can use the `display/i $pc` command to display the instruction at the current
    program counter (`$pc`), just to make sure you’re at the expected instruction
    ➎. As expected, `gdb` informs you that the next instruction to be executed is
    `cmp (%rcx,%rax,1),%dl`, which is indeed the comparison instruction you’re interested
    in (in AT&T format).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve reached the point in *ctf* ’s execution where `GUESSME` is compared
    against the expected string, you need to find out the base address of the string
    so that you can dump it. To view the base address contained in the `rcx` register,
    use the command `info registers rcx`➏. You can also view the contents of `rax`,
    just to ensure that the loop counter is zero, as expected ➐. It’s also possible
    to use the command `info registers` without specifying any register name. In that
    case, `gdb` will show the contents of all general-purpose registers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: You now know the base address of the string you want to dump; it starts at address
    `0x615050`. The only thing left to do is to dump the string at that address. The
    command to dump memory in `gdb` is `x`, which is capable of dumping memory in
    many granularities and encodings. For instance, `x/d` dumps a single byte in decimal
    representation, `x/x` dumps a byte in hexadecimal representation, and `x/4xw`
    dumps four hexadecimal words (which are 4-byte integers). In this case, the most
    useful version of the command is `x/s`, which dumps a C-style string, continuing
    until it encounters a `NULL` byte. When you issue the command `x/s 0x615050` to
    dump the string you’re interested in ➑, you can see that the expected value of
    `GUESSME` is `Crackers Don't Matter`. Let’s exit `gdb` using the `quit` command
    ➒ to try it!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As this listing shows, you’ve finally completed all the necessary steps to
    coax *ctf* into giving you the secret flag! On the VM in the directory for this
    chapter, you’ll find a program called *oracle*. Go ahead and feed the flag to
    *oracle*, like this: `./oracle 84b34c124b2ba5ca224af8e33b077e9e`. You’ve now unlocked
    the next challenge, which you can complete on your own using your new skills.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 5.10 Summary
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I introduced you to all the essential Linux binary analysis
    tools you need to be an effective binary analyst. While most of these tools are
    simple enough, you can combine them to implement powerful binary analyses in no
    time! In the next chapter, you’ll explore some of the major disassembly tools
    and other, more advanced analysis techniques.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 1\. A New CTF Challenge
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Complete the new CTF challenge unlocked by the *oracle* program! You can complete
    the entire challenge using only the tools discussed in this chapter and what you
    learned in [Chapter 2](ch02.xhtml#ch02). After completing the challenge, don’t
    forget to give the flag you found to the oracle to unlock the next challenge.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
