- en: '5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BASIC BINARY ANALYSIS IN LINUX
  prefs: []
  type: TYPE_NORMAL
- en: Even in the most complex binary analysis, you can accomplish surprisingly advanced
    feats by combining a set of basic tools in the right way. This can save you hours
    of work implementing equivalent functionality on your own. In this chapter, you’ll
    learn the fundamental tools you’ll need to perform binary analysis on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of simply showing you a list of tools and explaining what they do, I’ll
    use a *Capture the Flag (CTF)* challenge to illustrate how they work. In computer
    security and hacking, CTF challenges are often played as contests, where the goal
    is typically to analyze or exploit a given binary (or a running process or server)
    until you manage to capture a flag hidden in the binary. The flag is usually a
    hexadecimal string, which you can use to prove that you completed the challenge
    as well as unlock new challenges.
  prefs: []
  type: TYPE_NORMAL
- en: In this CTF, you start with a mysterious file called *payload*, which you can
    find on the VM in the directory for this chapter. The goal is to figure out how
    to extract the hidden flag from *payload*. In the process of analyzing *payload*
    and looking for the flag, you’ll learn to use a wide range of basic binary analysis
    tools that are available on virtually any Linux-based system (most of them as
    part of GNU `coreutils` or `binutils`). I encourage you to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the tools you’ll see have a number of useful options, but there are
    far too many to cover exhaustively in this chapter. Thus, it’s a good idea to
    check out the man page for every tool using the command `man` *tool* on the VM.
    At the end of the chapter, you’ll use the recovered flag to unlock a new challenge,
    which you can complete on your own!
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Resolving Identity Crises Using file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because you received absolutely no hints about the contents of *payload*, you
    have no idea what to do with this file. When this happens (for instance, in reverse
    engineering or forensics scenarios), a good first step is to figure out what you
    can about the file type and its contents. The `file` utility was designed for
    this purpose; it takes a number of files as input and then tells you what type
    each file is. You may remember it from [Chapter 2](ch02.xhtml#ch02), where I used
    `file` to find out the type of an ELF file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nice thing about `file` is that it isn’t fooled by extensions. Instead,
    it searches for other telltale patterns in the file, such as magic bytes like
    the `0x7f ELF` sequence at the start of ELF files, to find out the file type.
    This is perfect here because the *payload* file doesn’t have an extension. Here’s
    what `file` tells you about *payload*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, *payload* contains ASCII text. To examine the text in detail,
    you can use the `head` utility, which dumps the first few lines (10 by default)
    of a text file to `stdout`. There’s also an analogous utility called `tail`, which
    shows you the last few lines of a file. Here’s what the `head` utility’s output
    shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That definitely doesn’t look human-readable. Taking a closer look at the alphabet
    used in the file, you can see that it consists of only alphanumeric characters
    and the characters + and /, organized in neat rows. When you see a file that looks
    like this, it’s usually safe to assume that it’s a *Base64* file.
  prefs: []
  type: TYPE_NORMAL
- en: Base64 is a widely used method of encoding binary data as ASCII text. Among
    other things, it’s commonly used in email and on the web to ensure that binary
    data transmitted over a network isn’t accidentally malformed by services that
    can handle only text. Conveniently, Linux systems come with a tool called `base64`
    (typically as part of GNU `coreutils`) that can encode and decode Base64\. By
    default, `base64` will encode any files or `stdin` input given to it. But you
    can use the `-d` flag to tell `base64` to decode instead. Let’s decode *payload*
    to see what you get!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command decodes *payload* and then stores the decoded contents in a new
    file called `decoded_payload`. Now that you’ve decoded *payload*, let’s use `file`
    again to check the type of the decoded file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you’re getting somewhere! It turns out that behind the layer of Base64
    encoding, the mysterious file is actually just a compressed archive that uses
    `gzip` as the outer compression layer. This is an opportunity to introduce another
    handy feature of `file`: the ability to peek inside zipped files. You can pass
    the `-z` option to `file` to see what’s inside the archive without extracting
    it. Here’s what you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that you’re dealing with multiple layers that you need to extract,
    because the outer layer is a `gzip` compression layer and inside that is a `tar`
    archive, which typically contains a bundle of files. To reveal the files stored
    inside, you use `tar` to unzip and extract `decoded_payload`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the `tar` log, there are two files extracted from the archive:
    *ctf* and *67b8601*. Let’s use `file` again to see what kinds of files you’re
    dealing with.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first file, *ctf*, is a dynamically linked 64-bit stripped ELF executable.
    The second file, called *67b8601*, is a bitmap (BMP) file of 512 × 512 pixels.
    Again, you can see this using `file` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This BMP file depicts a black square, as you can see in [Figure 5-1a](ch05.xhtml#ch05fig1).
    If you look carefully, you should see some irregularly colored pixels at the bottom
    of the figure. [Figure 5-1b](ch05.xhtml#ch05fig1) shows an enlarged snippet of
    these pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Before exploring what this all means, let’s first take a closer look at *ctf*,
    the ELF file you just extracted.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f092-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: The extracted BMP file, 67b8601*'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Using ldd to Explore Dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it’s not wise to run unknown binaries, since you’re working in a VM,
    let’s try running the extracted *ctf* binary. When you try to run the file, you
    don’t get far.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Before any of the application code is even executed, the dynamic linker complains
    about a missing library called *lib5ae9b7f.so*. That doesn’t sound like a library
    you normally find on any system. Before searching for this library, it makes sense
    to check whether *ctf* has any more unresolved dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux systems come with a program called `ldd`, which you can use to find out
    on which shared objects a binary depends and where (if anywhere) these dependencies
    are on your system. You can even use `ldd` along with the `-v` flag to find out
    which library versions the binary expects, which can be useful for debugging.
    As mentioned in the `ldd man` page, `ldd` may run the binary to figure out the
    dependencies, so it’s not safe to use on untrusted binaries unless you’re running
    it in a VM or another isolated environment. Here’s the `ldd` output for the *ctf*
    binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Luckily, there are no unresolved dependencies besides the missing library identified
    earlier, *lib5ae9b7f.so*. Now you can focus on figuring out what this mysterious
    library is and how you can obtain it in order to capture the flag!
  prefs: []
  type: TYPE_NORMAL
- en: Because it’s obvious from the library name that you won’t find it in any standard
    repository, it must reside somewhere in the files you’ve been given so far. Recall
    from [Chapter 2](ch02.xhtml#ch02) that all ELF binaries and libraries begin with
    the magic sequence `0x7f ELF`. This is a handy string to look for in search of
    your missing library; as long as the library is not encrypted, you should be able
    to find the ELF header this way. Let’s try a simple `grep` for the string `'ELF'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the string `'ELF'` appears in *ctf*, which is not surprising because
    you already know it’s an ELF binary. But you can see that this string is also
    in *67b8601*, which at first glance appeared to be an innocent bitmap file. Could
    there be a shared library hidden within the bitmap’s pixel data? It would certainly
    explain those strangely colored pixels you saw in [Figure 5-1b](ch05.xhtml#ch05fig1)!
    Let’s examine the contents of *67b8601* in more detail to find out.
  prefs: []
  type: TYPE_NORMAL
- en: Quickly Looking Up ASCII Codes
  prefs: []
  type: TYPE_NORMAL
- en: 'When interpreting raw bytes as ASCII, you’ll often need a table that maps byte
    values in various representations to ASCII symbols. You can use a special man
    page called `man ascii` for quick access to such a table. Here’s an excerpt of
    the table from `man ascii`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Oct` | `Dec` | `Hex` | `Char` | `Oct` | `Dec` | `Hex` | `Char` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `000` | `0` | `00` | `NUL ''\0'' (null character)` | `100` | `64` | `40`
    | `@` |'
  prefs: []
  type: TYPE_TB
- en: '| `001` | `1` | `01` | `SOH (start of heading)` | `101` | `65` | `41` | `A`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `002` | `2` | `02` | `STX (start of text)` | `102` | `66` | `42` | `B` |'
  prefs: []
  type: TYPE_TB
- en: '| `003` | `3` | `03` | `ETX (end of text)` | `103` | `67` | `43` | `C` |'
  prefs: []
  type: TYPE_TB
- en: '| `004` | `4` | `04` | `EOT (end of transmission)` | `104` | `68` | `44` |
    `D` |'
  prefs: []
  type: TYPE_TB
- en: '| `005` | `5` | `05` | `ENQ (enquiry)` | `105` | `69` | `45` | `E` |'
  prefs: []
  type: TYPE_TB
- en: '| `006` | `6` | `06` | `ACK (acknowledge)` | `106` | `70` | `46` | `F` |'
  prefs: []
  type: TYPE_TB
- en: '| `007` | `7` | `07` | `BEL ''\a'' (bell)` | `107` | `71` | `47` | `G` |'
  prefs: []
  type: TYPE_TB
- en: '| `...` |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: As you can see, this is an easy way to look up the mappings from octal, decimal,
    and hexadecimal encodings to ASCII characters. This is much faster than googling
    for an ASCII table!
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 Viewing File Contents with xxd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To discover exactly what’s in a file without being able to rely on any standard
    assumptions about the file contents, you’ll have to analyze it at the byte level.
    To do this, you can use any numeric system to display bits and bytes on the screen.
    For instance, you could use the binary system, displaying all the ones and zeros
    individually. But because that makes for some tedious analysis, it’s better to
    use the *hexadecimal system*. In the hexadecimal system (also known as *base 16*,
    or *hex* for short), digits range from 0 to 9 (with the usual meaning) and then
    from *a* to *f* (where *a* represents the value 10 and *f* represents 15). In
    addition, because a byte has 256 = 16 × 16 possible values, it fits exactly in
    two hexadecimal digits, making this a convenient encoding for compactly displaying
    bytes.
  prefs: []
  type: TYPE_NORMAL
- en: To display the bytes of a file in hexadecimal representation, you use a *hex-dumping*
    program. A *hex editor* is a program that can also edit the bytes in the file.
    I’ll get back to hex editing in [Chapter 7](ch07.xhtml#ch07), but for now let’s
    use a simple hex-dumping program called `xxd`, which is installed on most Linux
    systems by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the first 15 lines of output from `xxd` for the bitmap file you’re
    analyzing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first output column shows the offset into the file in hexadecimal
    format. The next eight columns show hexadecimal representations of the bytes in
    the file, and on the rightmost side of the output, you can see an ASCII representation
    of the same bytes.
  prefs: []
  type: TYPE_NORMAL
- en: You can change the number of bytes displayed per line using the `xxd` program’s
    `-c` option. For instance, `xxd -c 32` will display 32 bytes per line. You can
    also use `-b` to display binary instead of hexadecimal, and you can use `-i` to
    output a C-style array containing the bytes, which you can directly include in
    your C or C++ source. To output only some of the bytes, you can use the `-s` (seek)
    option to specify a file offset at which to start, and you can use the `-l` (length)
    option to specify the number of bytes to dump.
  prefs: []
  type: TYPE_NORMAL
- en: In the `xxd` output for the bitmap file, the ELF magic bytes appear at offset
    `0x34` ➊, which corresponds to 52 in the decimal system. This tells you where
    in the file the suspected ELF library begins. Unfortunately, finding out where
    it ends is not so trivial because there are no magic bytes delimiting the end
    of an ELF file. Thus, before you try to extract the complete ELF file, begin by
    extracting only the ELF header instead. This is easier since you know that 64-bit
    ELF headers contain exactly 64 bytes. You can then examine the ELF header to figure
    out how large the complete file is.
  prefs: []
  type: TYPE_NORMAL
- en: To extract the header, you use `dd` to copy 64 bytes from the bitmap file, starting
    at offset 52, into a new output file called *elf_header*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using `dd` is incidental here, so I won’t explain it in detail. However, `dd`
    is an extremely versatile^([1](footnote.xhtml#ch05fn_1)) tool, so it’s worth reading
    its man page if you aren’t already familiar with it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use `xxd` again to see whether it worked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That looks like an ELF header! You can clearly see the magic bytes at the start
    ➊, and you can also see that the `e_ident` array and other fields look reasonable
    (refer to [Chapter 2](ch02.xhtml#ch02) for a description of these fields).
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Parsing the Extracted ELF with readelf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To view the details of the ELF header you just extracted, it would be great
    if you could use `readelf`, like you did in [Chapter 2](ch02.xhtml#ch02). But
    will `readelf` work on a broken ELF file that contains nothing but a header? Let’s
    find out in [Listing 5-1](ch05.xhtml#ch05list1)!
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-1: The* readelf *output for the extracted ELF header*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `-h` option ➊ tells `readelf` to print only the executable header. It still
    complains that the offsets to the section header table and program header table
    point outside the file, but that’s okay. What matters is that you now have a convenient
    representation of the extracted ELF header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how can you figure out the size of the complete ELF using nothing but
    the executable header? In [Figure 2-1](ch02.xhtml#ch02fig1) of [Chapter 2](ch02.xhtml#ch02),
    you learned that the last part of an ELF file is typically the section header
    table and that the offset to the section header table is given in the executable
    header ➋. The executable header also tells you the size of each section header
    ➌ and the number of section headers in the table ➍. This means you can calculate
    the size of the complete ELF library hidden in your bitmap file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f096-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this equation, *size* is the size of the complete library, *e*_*shoff* is
    the offset to the section header table, *e*_*shnum* is the number of section headers
    in the table, and *e*_*shentsize* is the size of each section header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know that the size of the library should be 10,296 bytes, you
    can use `dd` to extract it completely, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `dd` command calls the extracted file *lib5ae9b7f.so* ➊ because that’s the
    name of the missing library the *ctf* binary expects. After running this command,
    you should now have a fully functioning ELF shared object. Let’s use `readelf`
    to see whether all went well, as shown in [Listing 5-2](ch05.xhtml#ch05list2).
    To keep the output brief, let’s only print the executable header (`-h`) and symbol
    tables (`-s`). The latter should give you an idea of the functionality that the
    library provides.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-2: The* readelf *output for the extracted library,* lib5ae9b7f.so'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As hoped, the complete library seems to have been extracted correctly. Although
    it’s stripped, the dynamic symbol table does reveal some interesting exported
    functions (➊ through ➎). However, there seems to be some gibberish around the
    names, making them difficult to read. Let’s see if that can be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 Parsing Symbols with nm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ allows functions to be *overloaded*, which means there may be multiple functions
    with the same name, as long as they have different signatures. Unfortunately for
    the linker, it doesn’t know anything about C++. For example, if there are multiple
    functions with the name `foo`, the linker has no idea how to resolve references
    to `foo`; it simply doesn’t know which version of `foo` to use. To eliminate duplicate
    names, C++ compilers emit *mangled* function names. A mangled name is essentially
    a combination of the original function name and an encoding of the function parameters.
    This way, each version of the function gets a unique name, and the linker has
    no problems disambiguating the overloaded functions.
  prefs: []
  type: TYPE_NORMAL
- en: For binary analysts, mangled function names are a mixed blessing. On the one
    hand, mangled names are more difficult to read, as you saw in the `readelf` output
    for *lib5ae9b7f.so* ([Listing 5-2](ch05.xhtml#ch05list2)), which is programmed
    in C++. On the other hand, mangled function names essentially provide free type
    information by revealing the expected parameters of the function, and this information
    can be useful when reverse engineering a binary.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the benefits of mangled names outweigh the downsides because mangled
    names are relatively easy to *demangle*. There are several standard tools you
    can use to demangle mangled names. One of the best known is `nm`, which lists
    symbols in a given binary, object file, or shared object. When given a binary,
    `nm` by default attempts to parse the static symbol table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, as this example shows, you can’t use `nm`’s default configuration
    on *lib5ae9b7f.so* because it has been stripped. You have to explicitly ask `nm`
    to parse the dynamic symbol table instead, using the `-D` switch, as shown in
    [Listing 5-3](ch05.xhtml#ch05list3). In this listing, “`...`” indicates that I’ve
    truncated a line and continued it on the next line (mangled names can be quite
    long).
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-3: The* nm *output for* lib5ae9b7f.so'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This looks better; this time you see some symbols. But the symbol names are
    still mangled. To demangle them, you have to pass the `--demangle` switch to `nm`,
    as shown in [Listing 5-4](ch05.xhtml#ch05list4).
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-4: Demangled* nm *output for* lib5ae9b7f.so'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the function names appear human-readable. You can see five interesting
    functions, which appear to be cryptographic functions implementing the well-known
    RC4 encryption algorithm.^([2](footnote.xhtml#ch05fn_2)) There’s a function called
    `rc4_init`, which takes as input a data structure of type `rc4_state_t`, as well
    as an unsigned character string and an integer ➎. The first parameter is presumably
    a data structure where the cryptographic state is kept, while the next two are
    probably a string representing a key and an integer specifying the length of the
    key, respectively. You can also see several encryption and decryption functions,
    each of which takes a pointer to the cryptographic state, as well as parameters
    specifying strings (both C and C++ strings) to encrypt or decrypt (➊ through ➍).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative way of demangling function names, you can use a specialized
    utility called `c++filt`, which takes a mangled name as the input and outputs
    the demangled equivalent. The advantage of `c++filt` is that it supports several
    mangling formats and automatically detects the correct mangling format for the
    given input. Here’s an example using `c++filt` to demangle the function name `_Z8rc4_initP11rc4_state_tPhi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, let’s briefly recap the progress so far. You extracted the mysterious
    payload and found a binary called *ctf* that depends on a file called *lib5ae9b7f.so*.
    You found *lib5ae9b7f.so* hidden in a bitmap file and successfully extracted it.
    You also have a rough idea of what it does: it’s a cryptographic library. Now
    let’s try running *ctf* again, this time with no missing dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: When you run a binary, the linker resolves the binary’s dependencies by searching
    a number of standard directories for shared libraries, such as */lib*. Because
    you extracted *lib5ae9b7f.so* to a nonstandard directory, you need to tell the
    linker to search that directory too by setting an environment variable called
    `LD_LIBRARY_PATH`. Let’s set this variable to contain the current working directory
    and then try launching *ctf* again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Success! The *ctf* binary still doesn’t appear to do anything useful, but it
    runs without complaining about any missing libraries. The exit status of *ctf*
    contained in the `$?` variable is 1, indicating an error. Now that you have all
    the required dependencies, you can continue your investigation and see whether
    you can coax *ctf* into getting past the error so that you can reach the flag
    you’re trying to capture.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6 Looking for Hints with strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To figure out what a binary does and what kinds of inputs it expects, you can
    check whether the binary contains any helpful strings that can reveal its purpose.
    For instance, if you see strings containing parts of HTTP requests or URLs, you
    can safely guess that the binary is doing something web related. When you’re dealing
    with malware such as a bot, you might be able to find strings containing the commands
    that the bot accepts, if they’re not obfuscated. You might even find strings left
    over from debugging that the programmer forgot to remove, which has been known
    to happen in real-world malware!
  prefs: []
  type: TYPE_NORMAL
- en: You can use a utility called `strings` to check for strings in a binary (or
    any other file) on Linux. The `strings` utility takes one or more files as input
    and then prints any printable character strings found in those files. Note that
    `strings` doesn’t check whether the found strings were really intended to be human
    readable, so when used on binary files, the `strings` output may include some
    bogus strings as a result of binary sequences that just happen to be printable.
  prefs: []
  type: TYPE_NORMAL
- en: You can tweak the behavior of `strings` using options. For example, you can
    use the `-d` switch with `strings` to print only strings found in data sections
    in a binary instead of printing all sections. By default, `strings` prints only
    strings of four characters or more, but you can specify another minimum string
    length using the `-n` option. For our purposes, the default options will suffice;
    let’s see what you can find in the *ctf* binary using `strings`, as shown in [Listing
    5-5](ch05.xhtml#ch05list5).
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-5: Character strings found in the* ctf *binary*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see some strings that you’ll encounter in most ELF files. For
    example, there’s the name of the program interpreter ➊, as found in the `.interp`
    section, and some symbolic names found in `.dynstr` ➋. At the end of the `strings`
    output, you can see all the section names as found in the `.shstrtab` section
    ➐. But none of these strings is very interesting for the purposes here.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are also some more useful strings. For example, there is
    what appears to be a debug message, which suggests that the program expects a
    command line option ➌. There are also checks of some sort, presumably performed
    on an input string ➍. You don’t yet know what the value of the command line option
    should be, but you could try some of the other interesting-looking strings, such
    as `show_me_the_flag` ➎, that might work. There’s also a mysterious string ➏ that
    contains a message whose purpose is unclear. You don’t know what the message means
    at this point, but you do know from your investigation of *lib5ae9b7f.so* that
    the binary uses RC4 encryption. Perhaps the message is used as an encryption key?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know that the binary expects a command line option, let’s see
    whether adding an arbitrary option gets you any closer to revealing the flag.
    For lack of a better guess, let’s simply use the string `foobar`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The binary now does something new. It tells you that it’s checking the input
    string you gave it. But the check doesn’t succeed because the binary still exits
    with an error code after the check. Let’s take a gamble and try one of the other
    interesting-looking strings that you found, such as the string `show_me_the_flag`,
    which looks promising.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That did it! The check now appears to succeed. Unfortunately, the exit status
    is still 1, so there must be something else missing. To make things worse, the
    `strings` results don’t provide any more hints. Let’s take a more detailed look
    at *ctf* ’s behavior to determine what to do next, starting with the system and
    library calls *ctf* makes.
  prefs: []
  type: TYPE_NORMAL
- en: 5.7 Tracing System Calls and Library Calls with strace and ltrace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make forward progress, let’s investigate the reason that *ctf* exits with
    an error code by looking at *ctf* ’s behavior just before it exits. There are
    many ways that you could do this, but one way is to use two tools called `strace`
    and `ltrace`. These tools show the system calls and library calls, respectively,
    executed by a binary. Knowing the system and library calls that a binary makes
    can often give you a good high-level idea of what the program is doing.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by using `strace` to investigate *ctf* ’s system call behavior.
    In some cases, you may want to attach `strace` to a running process. To do this,
    you need to use the `-p` *pid* option, where *pid* is the process ID of the process
    you want to attach to. However, in this case, it suffices to run *ctf* with `strace`
    from the start. [Listing 5-6](ch05.xhtml#ch05list6) shows the `strace` output
    for the *ctf* binary (some parts are truncated with “`...`”).
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-6: System calls executed by the* ctf *binary*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When tracing a program from the start, `strace` includes all the system calls
    used by the program interpreter to set up the process, making the output quite
    verbose. The first system call in the output is `execve`, which is called by your
    shell to launch the program ➊. After that, the program interpreter takes over
    and starts setting up the execution environment. This involves setting up memory
    regions and setting the correct memory access permissions using `mprotect`. Additionally,
    you can see the system calls used to look up and load the required dynamic libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that in [Section 5.5](ch05.xhtml#ch05_5), you set the `LD_LIBRARY_PATH`
    environment variable to tell the dynamic linker to add your current working directory
    to its search path. This is why you can see the dynamic linker searching for the
    *lib5ae9b7f.so* library in a number of standard subfolders in your current working
    directory, until it finally finds the library in the root of your working directory
    ➋. When the library is found, the dynamic linker reads it and maps it into memory
    ➌. The setup process is repeated for other required libraries, such as *libstdc++.so.6*
    ➍, and it accounts for the vast majority of the `strace` output.
  prefs: []
  type: TYPE_NORMAL
- en: It isn’t until the last three system calls that you finally see application-specific
    behavior. The first system call used by *ctf* itself is `write`, which is used
    to print `checking 'show_me_the_flag'` to the screen ➎. You see another `write`
    call to print the string `ok` ➏, and finally, there’s a call to `exit_group`,
    which leads to the exit with status code 1 ➐.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all interesting, but how does it help you figure out how to extract the
    flag from *ctf* ? The answer is that it doesn’t! In this case, `strace` didn’t
    reveal anything helpful, but I still wanted to show you how it works because it
    can be useful for understanding a program’s behavior. For instance, observing
    the system calls executed by a program is useful not only for binary analysis
    but also for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at *ctf* ’s system call behavior didn’t help much, so let’s try library
    calls. To view the library calls executed by *ctf*, you use `ltrace`. Because
    `ltrace` is a close relative of `strace`, it takes many of the same command line
    options, including `-p` to attach to an existing process. Here, let’s use the
    `-i` option to print the instruction pointer at every library call (this will
    be useful later). We’ll use `-C` to automatically demangle C++ function names.
    Let’s run *ctf* with `ltrace` from the start, as shown in [Listing 5-7](ch05.xhtml#ch05list7).
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-7: Library calls made by the* ctf *binary*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this output from `ltrace` is a lot more readable than the `strace`
    output because it isn’t polluted by all the process setup code. The first library
    call is `__libc_start_main` ➊, which is called from the `_start` function to transfer
    control to the program’s `main` function. Once `main` is started, its first library
    call prints the now familiar `checking ...` string to the screen ➋. The actual
    check turns out to be a string comparison, which is implemented using `strcmp`,
    and verifies that the argument given to *ctf* is equal to `show_me_the_flag` ➌.
    If this is the case, `ok` is printed to the screen ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, this is mostly behavior you’ve seen before. But now you see something
    new: the RC4 cryptography is initialized through a call to `rc4_init`, which is
    located in the library you extracted earlier ➎. After that, you see an `assign`
    to a C++ string, presumably initializing it with an encrypted message ➏. This
    message is then decrypted with a call to `rc4_decrypt` ➐, and the decrypted message
    is assigned to a new C++ string ➑.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there’s a call to `getenv`, which is a standard library function used
    to look up environment variables ➒. You can see that *ctf* expects an environment
    variable called `GUESSME`! The name of this variable may well be the string that
    was decrypted earlier. Let’s see whether *ctf* ’s behavior changes when you set
    a dummy value for the `GUESSME` environment variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Setting `GUESSME` results in an additional line of output that says `guess again!`.
    It seems that *ctf* expects `GUESSME` to be set to another specific value. Perhaps
    another `ltrace` run, as shown in [Listing 5-8](ch05.xhtml#ch05list8), will reveal
    what the expected value is.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-8: Library calls made by the* ctf *binary after setting the* GUESSME
    *environment variable*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After the call to `getenv`, *ctf* goes on to assign ➊ and decrypt ➋ another
    C++ string. Unfortunately, between the decryption and the moment that `guess again`
    is printed to the screen ➌, you don’t see any hints regarding the expected value
    of `GUESSME`. This tells you that the comparison of `GUESSME` to its expected
    value is implemented without the use of any library functions. You’ll need to
    take another approach.
  prefs: []
  type: TYPE_NORMAL
- en: 5.8 Examining Instruction-Level Behavior Using objdump
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because you know that the value of the `GUESSME` environment variable is checked
    without using any well-known library functions, a logical next step is to use
    `objdump` to examine *ctf* at the instruction level to find out what’s going on.^([3](footnote.xhtml#ch05fn_3))
  prefs: []
  type: TYPE_NORMAL
- en: From the `ltrace` output in [Listing 5-8](ch05.xhtml#ch05list8), you know that
    the `guess again` string is printed to the screen by a call to `puts` at address
    `0x400dd7`. Let’s focus the `objdump` investigation around this address. It will
    also help to know the address of the string to find the first instruction that
    loads it. To find this address, you can look at the `.rodata` section of the *ctf*
    binary using `objdump -s` to print the full section contents, as shown in [Listing
    5-9](ch05.xhtml#ch05list9).
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-9: The contents of* ctf*’s* .rodata *section as shown by* objdump'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using `objdump` to examine *ctf* ’s `.rodata` section, you can see the `guess
    again` string at address `0x4011af` ➊. Now let’s take a look at [Listing 5-10](ch05.xhtml#ch05list10),
    which shows the instructions around the `puts` call, to find out what input *ctf*
    expects for the `GUESSME` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-10: Instructions checking the value of* GUESSME'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `guess again` string is loaded by the instruction at `0x400dcd` ➍ and is
    then printed using `puts` ➎. This is the failure case; let’s work our way backward
    from here.
  prefs: []
  type: TYPE_NORMAL
- en: The failure case is reached from a loop that starts at address `0x400dc0`. In
    each iteration of the loop, it loads a byte from an array (probably a string)
    into `edx` ➊. The `rbx` register points to the base of this array, while `rax`
    indexes it. If the loaded byte turns out to be `NULL`, then the `je` instruction
    at `0x400dc6` jumps to the failure case ➋. This comparison to `NULL` is a check
    for the end of the string. If the end of the string is reached here, then it’s
    too short to be a match. If the byte is not `NULL`, the `je` falls through to
    the next instruction, at address `0x400dc8`, which compares the byte in `edx`
    against a byte in another string, based at `rcx` and indexed by `rax` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: If the two compared bytes match up, then the program jumps to address `0x400de0`,
    where it increases the string index ➏, and checks whether the string index is
    equal to `0x15`, the length of the string ➐. If it is, then the string comparison
    is complete; if not, the program jumps into another iteration of the loop ➑.
  prefs: []
  type: TYPE_NORMAL
- en: From this analysis, you now know that the string based at the `rcx` register
    is used as a ground truth. The program compares the environment string taken from
    the `GUESSME` variable against this ground truth. This means that if you can dump
    the ground truth string, you can find the expected value for `GUESSME`! Because
    the string is decrypted at runtime and isn’t available statically, you’ll need
    to use dynamic analysis to recover it instead of using `objdump`.
  prefs: []
  type: TYPE_NORMAL
- en: 5.9 Dumping a Dynamic String Buffer Using gdb
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Probably the most used dynamic analysis tool on GNU/Linux is `gdb`, or the GNU
    Debugger. As the name suggests, `gdb` is mainly for debugging, but it can be used
    for a variety of dynamic analysis purposes. In fact, it’s an extremely versatile
    tool, and there’s no way to cover all of its functionality in this chapter. However,
    I’ll go over some of the most-used features of `gdb` you can use to recover the
    expected value of `GUESSME`. The best place to look up information on `gdb` is
    not the man page but *[http://www.gnu.org/software/gdb/documentation/](http://www.gnu.org/software/gdb/documentation/)*,
    where you’ll find an extensive manual covering all the supported `gdb` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `strace` and `ltrace`, `gdb` has the ability to attach to a running process.
    However, because *ctf* is not a long-running process, you can simply run it with
    `gdb` from the start. Because `gdb` is an interactive tool, when you start a binary
    under `gdb`, it’s not immediately executed. After printing a startup message with
    some usage instructions, `gdb` pauses and waits for a command. You can tell that
    `gdb` is waiting for a command by the command prompt: `(gdb)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-11](ch05.xhtml#ch05list11) shows the sequence of `gdb` commands
    needed to find the expected value of the `GUESSME` environment variable. I’ll
    explain each of these commands as I discuss the listing.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-11: Finding the expected value of* GUESSME *using* gdb'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: One of the most basic functions of any debugger is setting a *breakpoint*, which
    is simply an address or a function name at which the debugger will “break” execution.
    Whenever the debugger reaches a breakpoint, it pauses execution and returns control
    to the user, waiting for a command. To dump the “magic” string against which the
    `GUESSME` environment variable is compared, you set a breakpoint at address `0x400dc8`
    ➊ where the comparison happens. In `gdb`, the command for setting a breakpoint
    at an address is `b` **address* (`b` is a short version of the command `break`).
    If symbols are available (they aren’t in this case), you can set a breakpoint
    at the entry point of a function using the function’s name. For instance, to set
    a breakpoint at the start of `main`, you would use the command `b main`.
  prefs: []
  type: TYPE_NORMAL
- en: After setting the breakpoint, you need to do one more thing before you can start
    the execution of *ctf* . You still need to set a value for the `GUESSME` environment
    variable to prevent *ctf* from exiting prematurely. In `gdb`, you can set the
    `GUESSME` environment variable using the command `set env GUESSME=foobar` ➋. Now,
    you can begin the execution of *ctf* by issuing the command `run show_me_the_flag`
    ➌. As you can see, you can pass arguments to the `run` command, which it then
    automatically passes on to the binary you’re analyzing (in this case, *ctf* ).
    Now, *ctf* begins executing normally, and it should continue doing so until it
    hits your breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: When *ctf* hits the breakpoint, `gdb` halts the execution of *ctf* and returns
    control to you, informing you that a breakpoint was hit ➍. At this point, you
    can use the `display/i $pc` command to display the instruction at the current
    program counter (`$pc`), just to make sure you’re at the expected instruction
    ➎. As expected, `gdb` informs you that the next instruction to be executed is
    `cmp (%rcx,%rax,1),%dl`, which is indeed the comparison instruction you’re interested
    in (in AT&T format).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve reached the point in *ctf* ’s execution where `GUESSME` is compared
    against the expected string, you need to find out the base address of the string
    so that you can dump it. To view the base address contained in the `rcx` register,
    use the command `info registers rcx`➏. You can also view the contents of `rax`,
    just to ensure that the loop counter is zero, as expected ➐. It’s also possible
    to use the command `info registers` without specifying any register name. In that
    case, `gdb` will show the contents of all general-purpose registers.
  prefs: []
  type: TYPE_NORMAL
- en: You now know the base address of the string you want to dump; it starts at address
    `0x615050`. The only thing left to do is to dump the string at that address. The
    command to dump memory in `gdb` is `x`, which is capable of dumping memory in
    many granularities and encodings. For instance, `x/d` dumps a single byte in decimal
    representation, `x/x` dumps a byte in hexadecimal representation, and `x/4xw`
    dumps four hexadecimal words (which are 4-byte integers). In this case, the most
    useful version of the command is `x/s`, which dumps a C-style string, continuing
    until it encounters a `NULL` byte. When you issue the command `x/s 0x615050` to
    dump the string you’re interested in ➑, you can see that the expected value of
    `GUESSME` is `Crackers Don't Matter`. Let’s exit `gdb` using the `quit` command
    ➒ to try it!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As this listing shows, you’ve finally completed all the necessary steps to
    coax *ctf* into giving you the secret flag! On the VM in the directory for this
    chapter, you’ll find a program called *oracle*. Go ahead and feed the flag to
    *oracle*, like this: `./oracle 84b34c124b2ba5ca224af8e33b077e9e`. You’ve now unlocked
    the next challenge, which you can complete on your own using your new skills.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.10 Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I introduced you to all the essential Linux binary analysis
    tools you need to be an effective binary analyst. While most of these tools are
    simple enough, you can combine them to implement powerful binary analyses in no
    time! In the next chapter, you’ll explore some of the major disassembly tools
    and other, more advanced analysis techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs: []
  type: TYPE_NORMAL
- en: 1\. A New CTF Challenge
  prefs: []
  type: TYPE_NORMAL
- en: Complete the new CTF challenge unlocked by the *oracle* program! You can complete
    the entire challenge using only the tools discussed in this chapter and what you
    learned in [Chapter 2](ch02.xhtml#ch02). After completing the challenge, don’t
    forget to give the flag you found to the oracle to unlock the next challenge.
  prefs: []
  type: TYPE_NORMAL
