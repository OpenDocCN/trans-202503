["```\n#!/usr/bin/env python\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nfrom binascii import hexlify as hexa\nfrom os import urandom\n\n# pick a random 16-byte key using Python's crypto PRNG\nk = urandom(16)\nprint \"k = %s\" % hexa(k)\n# create an instance of AES-128 to encrypt a single block\ncipher = Cipher(algorithms.AES(k), modes.ECB(), backend = default_backend())\naes_encrypt = cipher.encryptor()\n\n# set plaintext block p to the all-zero string\np = '\\x00'*16\n# encrypt plaintext p to ciphertext c\nc = aes_encrypt.update(p) + aes_encrypt.finalize()\nprint \"enc(%s) = %s\" % (hexa(p), hexa(c))\n# decrypt ciphertext c to plaintext p\naes_decrypt = cipher.decryptor()\np = aes_decrypt.update(c) + aes_decrypt.finalize()\nprint \"dec(%s) = %s\" % (hexa(c), hexa(p))\n```", "```\n$ ./aes_block.py\nk = 2c6202f9a582668aa96d511862d8a279\nenc(00000000000000000000000000000000) = 12b620bb5eddcde9a07523e59292a6d7\ndec(12b620bb5eddcde9a07523e59292a6d7) = 00000000000000000000000000000000\n```", "```\nPXOR       %xmm5,  %xmm0\nAESENC     %xmm6,  %xmm0\nAESENC     %xmm7,  %xmm0\nAESENC     %xmm8,  %xmm0\nAESENC     %xmm9,  %xmm0\nAESENC     %xmm10, %xmm0\nAESENC     %xmm11, %xmm0\nAESENC     %xmm12, %xmm0\nAESENC     %xmm13, %xmm0\nAESENC     %xmm14, %xmm0\nAESENCLAST %xmm15, %xmm0\n```", "```\n#!/usr/bin/env python\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nfrom binascii import hexlify as hexa\nfrom os import urandom\n\nBLOCKLEN = 16\ndef blocks(data):\n    split = [hexa(data[i:i+BLOCKLEN]) for i in range(0, len(data), BLOCKLEN)]\n    return ' '.join(split)\n\nk = urandom(16)\nprint 'k = %s' % hexa(k)\n\n# create an instance of AES-128 to encrypt and decrypt\ncipher = Cipher(algorithms.AES(k), modes.ECB(), backend=default_backend())\naes_encrypt = cipher.encryptor()\n# set plaintext block p to the all-zero string\np = '\\x00'*BLOCKLEN*2\n\n# encrypt plaintext p to ciphertext c\nc = aes_encrypt.update(p) + aes_encrypt.finalize()\nprint 'enc(%s) = %s' % (blocks(p), blocks(c))\n```", "```\n$ ./aes_ecb.py\nk = 50a0ebeff8001250e87d31d72a86e46d\nenc(00000000000000000000000000000000 00000000000000000000000000000000) =\n5eb4b7af094ef7aca472bbd3cd72f1ed 5eb4b7af094ef7aca472bbd3cd72f1ed\n```", "```\n$ ./aes_cbc.py\nk = 9cf0d31ad2df24f3cbbefc1e6933c872\niv = 0a75c4283b4539c094fc262aff0d17af\nenc(00000000000000000000000000000000 00000000000000000000000000000000) =\n370404dcab6e9ecbc3d24ca5573d2920 3b9e5d70e597db225609541f6ae9804a\niv = a6016a6698c3996be13e8739d9e793e2\nenc(00000000000000000000000000000000 00000000000000000000000000000000) =\n655e1bb3e74ee8cf9ec1540afd8b2204 b59db5ac28de43b25612dfd6f031087a\n```", "```\n#!/usr/bin/env python\n\nfrom Crypto.Cipher import AES\nfrom Crypto.Util import Counter\nfrom binascii import hexlify as hexa\nfrom os import urandom\nfrom struct import unpack\n\nk = urandom(16)\nprint 'k = %s' % hexa(k)\n\n# pick a starting value for the counter\nnonce = unpack('<Q', urandom(8))[0]\n# instantiate a counter function\nctr = Counter.new(128, initial_value=nonce)\n\n# pick an instance of AES in CTR mode, using ctr as counter\naes = AES.new(k, AES.MODE_CTR, counter=ctr)\n\n# no need for an entire block with CTR\np = '\\x00\\x01\\x02\\x03'\n\n# encrypt p\nc = aes.encrypt(p)\nprint 'enc(%s) = %s' % (hexa(p), hexa(c))\n# decrypt using the encrypt function\nctr = Counter.new(128, initial_value=nonce)\naes = AES.new(k, AES.MODE_CTR, counter=ctr)\np = aes.encrypt(c)\nprint 'enc(%s) = %s' % (hexa(c), hexa(p))\n```", "```\n$ ./aes_ctr.py\nk = 130a1aa77fa58335272156421cb2a3ea\nenc(00010203) = b23d284e\nenc(b23d284e) = 00010203\n```"]