- en: '**9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SECURE FIRMWARE UPDATE**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Security updates are annoying, for consumers, for administrators, and especially
    for manufacturers. The latter constantly need to watch out for possible vulnerabilities
    in their products and react to corresponding notifications, while users and administrators
    have to apply published patches in a timely manner. Since we can regard a device’s
    security as a volatile state that might change tomorrow, having a solid update
    strategy is imperative.
  prefs: []
  type: TYPE_NORMAL
- en: However, software update handling is not a trivial process. Only authorized
    entities should be able to supply updates to devices, and they shouldn’t break
    device functionality or turn it into an expensive brick. In addition, safety experts
    are often rather reluctant to introduce patches to their certified devices, while
    corresponding certification bodies increasingly recognize the importance of security
    updates even in safety-critical areas.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter walks through the options for secure update approaches and the
    reasoning behind them. A central consideration is the secure implementation of
    update verification and its reliable application on the device itself. The chapter
    concludes with a practical case study for firmware updates based on the popular
    SWUpdate framework and a Yocto-based toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Inevitability of Updates**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some software and product development communities, a *perpetual beta* phase
    is common: a product never leaves its beta status, and new features are continuously
    added, even if the software or device is already in the field and in productive
    use by customers. This concept is sometimes also described as the *banana principle*,
    because those fruits are harvested when still green and continue to ripen on their
    way to customers and even after purchase. In such cases, it’s blatantly obvious
    that the delivered product isn’t completely finished and requires several software
    updates to develop its full potential. A secure update approach is essential.'
  prefs: []
  type: TYPE_NORMAL
- en: If we look at industrial systems and critical infrastructures, the situation
    is very different. Although these systems usually have a long lifetime, their
    manufacturers and operators may not have seen a need for patch management in the
    past. However, the increase in connectivity and digitalization in this field,
    along with the continuous discovery of vulnerabilities in industrial products,
    forces vendors and users to act and prepare for secure update processes. This
    situation is especially challenging because manufacturer support for security
    updates and operational patch management processes for industrial components usually
    have to run for decades.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you work in an industry that has a strong security focus and your development
    processes yield highly secure and robust products, you can’t guarantee that your
    software, your firmware, and your hardware components are free of bugs. Also,
    you don’t know whether new attack methodologies—not even invented at the time
    of product development—will cause security issues for your devices and may demand
    the replacement of crypto algorithms or the further enhancement of security features.
    In a nutshell: no product is perfect. Prepare it to be updatable.'
  prefs: []
  type: TYPE_NORMAL
- en: Some prominent cases stress the need for secure update support in embedded and
    IoT devices. The vulnerability collections *Urgent/11* from 2019 and *Ripple20*
    from 2020 showed that fundamental software components like TCP/IP stacks and OSs
    may exhibit severe weaknesses. Millions, if not billions, of devices were affected,
    and many are assumed not to be patchable because they don’t provide the necessary
    means. In the end, that inability forces customers to replace those devices or
    leaves them with insecure systems. At this scale, it might even pose a risk to
    society as a whole because malicious actors know how to invite those IoT products
    to their botnets. The bottom line is that every digital device sold in the 2020s
    should have a secure update mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I’m not the only one stressing the need for secure update strategies. IEC
    62443 for industrial cybersecurity, United Nations (UN) Regulation 156 for the
    automotive industry, and the cybersecurity part of the US FD&C Act for medical
    devices also agree, just to name a few.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security Requirements**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with every concept that has the term *secure* in its title, the obvious question
    is which (protection) goals are associated with it in this specific context. The
    following sections describe requirements you must consider for a secure firmware
    update.
  prefs: []
  type: TYPE_NORMAL
- en: '***Authenticity***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is essential that a firmware update can cryptographically prove its authenticity,
    which ensures that it originates from the original manufacturer of the given device.
    This prohibits the installation of maliciously crafted updates and should be mandatory
    for all secure update procedures. This goal is typically achieved by digitally
    signing an update package.
  prefs: []
  type: TYPE_NORMAL
- en: '***Confidentiality***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Firmware images are regularly used by people to reverse engineer devices for
    the enumeration of software libraries, to identify weaknesses, or to analyze proprietary
    applications for intellectual property and secrets. Confidentiality protection
    can be achieved by the encryption of the update contents as a whole or in parts.
  prefs: []
  type: TYPE_NORMAL
- en: However, make sure you understand there is a risk because the corresponding
    decryption key needs to be stored on the device, so attackers might either be
    able to extract that key from the device or the plain firmware update after on-device
    decryption.
  prefs: []
  type: TYPE_NORMAL
- en: '***Secure Distribution Channel***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first two requirements, authenticity and confidentiality, impose requirements
    on the update file itself. However, the distribution channel also might be worth
    protecting (for example, with TLS).
  prefs: []
  type: TYPE_NORMAL
- en: A mutually authenticated and encrypted communication between a device and an
    update server might even be a replacement for the confidentiality protection of
    the update file.
  prefs: []
  type: TYPE_NORMAL
- en: '***Rollback Option***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This one is tricky. Rolling back the software version of a device to an older
    state is sometimes absolutely helpful—for example, if an update introduces severe
    issues that haven’t existed before. On the other hand, attackers might use this
    feature to revert a device’s software to a version containing known vulnerabilities
    that later patches have fixed. In that case, the operation of vulnerable devices
    and their exploitation becomes possible, although the manufacturer provided security
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to implement rollback protection, you need corresponding hardware
    support, such as a monotonic, nonvolatile version counter within your main CPU.
  prefs: []
  type: TYPE_NORMAL
- en: '***Version Distribution Monitoring***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Monitoring the adoption of security updates in the field can be highly valuable,
    because doing so gives you an overview of the situation and the corresponding
    threat landscape for your devices and your customers. You could implement this
    monitoring with a confirmation notice for each device after a new firmware version
    has been successfully installed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Distribution and Deployment of Updates**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A central question regarding firmware updates is, “How does the update file
    find its way into the device?” Answers to that question have a significant impact
    on usability, processes, and reaction speed for your device’s patch management.
  prefs: []
  type: TYPE_NORMAL
- en: '***Local vs. Remote Updates***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since the 1990s, devices that implement an update mechanism offer some kind
    of interface to upload or to store a firmware file that was previously downloaded
    from the manufacturer’s website. The update file might even be restricted to be
    loaded at a local interface, such as via USB media. While local presence for updating
    can be a security feature, this approach provides pretty poor scalability for
    IoT scenarios. Millions of devices would require millions of customers with security
    awareness and millions of manual update installations, which is hardly feasible
    and results in few updates actually being applied.
  prefs: []
  type: TYPE_NORMAL
- en: The automotive industry is an interesting example regarding firmware updates.
    For many years, it was common for a recall to be issued if cars had a significant
    software bug or vulnerability. The owners had to bring their vehicles to an auto
    repair shop, where mechanics installed the software update provided by the corresponding
    car manufacturer that received it from the suppliers of the specific control unit.
    Nowadays, modern cars can receive software updates through their connection to
    mobile networks. This approach is called an *over-the-air (OTA) update*.
  prefs: []
  type: TYPE_NORMAL
- en: OTA updates are not restricted to cars. They can be applied to all sorts of
    IoT devices, and even if the term suggests that updates are applied over wireless
    channels, update transmission over wired networks is clearly not forbidden. The
    main advantage of this concept is that devices have a connection to an update
    management backend, usually operated by the device’s manufacturer, that provides
    information about new updates. This approach provides decent scalability because
    the update rollout process can be automated and scheduled by manufacturers. However,
    such a system exposes backend servers and devices listening for updates to remote
    attackers and network-based attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In some industrial scenarios, manual local update procedures are still the
    default. I’ve heard from a person who personally visits hundreds of industrial
    robots, plugs in a USB stick, and then waits for the update to complete before
    he continues his journey, which might take weeks for a single update. Crazy!*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Pull vs. Push Strategy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s no doubt that a direct connection between devices and an update server
    in the backend is a reasonable solution for professional update management, but
    one question remains: Who is in control of the update procedure?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, devices follow a *pull strategy* for update management: a client application
    on the device periodically checks for new updates and downloads newly available
    images. Afterward, depending on the owner’s configuration, the device might automatically
    install the update (for example, within a predefined maintenance window) or prompt
    a user or an administrator to approve installation. After a successful update,
    the new software state might be reported to a manufacturer’s server. In this case,
    operators control when and which updates are installed on their devices, which
    is usually the preferred solution for business scenarios, but they also take responsibility
    for regular update schedules.'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, manufacturers might opt for a *push strategy* that gives them
    more power over the update process. They might even force devices into an update
    mode. This method could be reasonable if the manufacturer is involved and responsible
    for timely device updates, maybe even by legal obligations. Further, the security
    of specific customer target groups like private users can benefit significantly
    if updates are enforced automatically and they don’t have to organize the process
    themselves. On the other hand, some customers deliberately choose to operate devices
    with old firmware versions, and if they deny those devices access to the update
    server, manufacturers are powerless. However, if such cases are part of your challenges,
    it makes sense to focus on software state monitoring whenever devices connect
    to your online services and deny access if device firmware is too old, keeping
    a large portion of devices in the field in a secure state.
  prefs: []
  type: TYPE_NORMAL
- en: Strategies that mix pull and push aspects are possible in practice. You might
    even leave the decision to your customers by providing corresponding configuration
    options for your device. This enables operators to perfectly integrate your device
    into their specific asset and patch-management processes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Update Granularity and Format**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The terms *software update* and *firmware update* are often used interchangeably
    and for a broad range of update scenarios, from rewriting all memory contents
    within a device to the change of few configuration parameters within a single
    file. Therefore, for your specific device, it’s absolutely necessary to define
    which parts of your device firmware should be replaceable and in which format
    you would like to distribute that data.
  prefs: []
  type: TYPE_NORMAL
- en: '***Firmware Parts***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the PC context, *firmware* is the software programmed to the onboard nonvolatile
    memory of the motherboard, installed daughterboards, and further peripheral devices.
    OSs, software applications, and user data, usually stored on hard disks, are not
    regarded as firmware. In the embedded system context, however, almost everything
    can be regarded as firmware:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bootloader**    Modern embedded devices contain at least one boot-loader,
    usually more.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Coprocessor firmware**    Recent SoCs include a heterogeneous set of processors
    within one package. Some of these coprocessors might require their own firmware.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Controller firmware**    On the PCB scale, a single embedded system might
    have several microcontrollers that execute dedicated firmware.'
  prefs: []
  type: TYPE_NORMAL
- en: '**FPGA bitstream**    As part of an SoC or as a discrete component, FPGAs are
    integrated into a multitude of embedded devices. Their configuration, called the
    *bitstream*, might be read directly from flash memory or loaded by a bootloader
    or an OS application.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bare-metal software**    In devices running without an OS, bare-metal software
    is the main application.'
  prefs: []
  type: TYPE_NORMAL
- en: '**OS kernel**    If your device comes with an OS or an RTOS, the corresponding
    OS kernel is the central software component.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Device tree**    The hardware components and their parameters for a specific
    embedded system are often described in a device-tree file that’s loaded by the
    OS kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Root filesystem**    The basic filesystem on top of which all other filesystems
    and overlays are mounted contains data that’s crucial for the correct functioning
    of an OS.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application software**    Application software might be part of the root
    filesystem but could also be located in one or multiple manufacturer-specific
    partitions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the firmware parts on that list might share a common nonvolatile memory;
    others might come with their own discrete memory component. Make sure you are
    aware of all relevant firmware components when developing a secure update concept.
    However, don’t forget that your device probably carries unique data that must
    not be affected by a software update:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unique cryptographic keys**    Data corresponding to your device’s unique
    identity, probably provisioned during production, is essential for trustworthy
    device authentication. Additionally, secrets, like SSH keys that are generated
    at first boot, should survive a software update.'
  prefs: []
  type: TYPE_NORMAL
- en: '**User-dependent system data**    Customers rely on additional user accounts
    and corresponding credentials as well as custom device configuration files.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Runtime data partitions**    Your device might collect and store user-specific
    runtime data, like sensor-value histories for data analytics applications, but
    it might also log data that might be relevant for maintenance and repair cases.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Update Formats***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As mentioned previously, the granularity of software components that need to
    be covered by updates varies greatly and doesn’t directly suggest a specific format
    for update distribution. Several requirements should be considered before deciding:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Comprehensive coverage**    The chosen format should have the ability to
    update as many of a device’s software components as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Efficiency**    Since the size of firmware is constantly increasing, it should
    be possible to reduce a firmware update to the parts that are actually new.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Atomicity**    The installation of an update should be an *indivisible* operation
    allowing only two final states: successfully updated firmware or, upon failure,
    the original firmware before the update process started.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list provides possible update format solutions based on the previously
    posed requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files**    A trivial update format would be to supply a device with a set
    of updated files that can be written to their specific paths in a filesystem.
    While this would enable updates for all components available in the device’s filesystem,
    and small, efficient update packages could be created, atomicity is complex. Every
    file created, written, or deleted requires its own operation that might fail or
    succeed. In case of an error, the firmware might end up in an unknown state.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Containers**    Containerized applications have become increasingly popular
    in larger embedded systems. The replacement of whole container images could be
    effective for their update management, but relying only on container-based updates
    would neglect important software components like the host OS running the container
    management.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Images**    Updating entire partition images enables updates for many software
    components in an embedded system and has advantages regarding atomicity. This
    approach might lead to larger firmware updates than other formats, but some implementations
    also support compressed update files or differential updates to overcome this
    issue.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Firmware parts that aren’t reachable by filesystem access, such as ICs that
    have to be updated based on a proprietary protocol, require customized treatment.
    Consider the pros and cons and make a conscious decision regarding the targeted
    update capabilities for your device.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Issues with Package Managers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You might wonder why Linux-based embedded devices in most cases don’t rely on
    established package manager applications like `apt-get` or `opkg` that are used
    back and forth on desktop and server systems. The reason lies in the testing complexity
    of systems that are updated on a package basis. Such an approach requires the
    management of *dependencies* among all possible packages in a system, and it multiplies
    the possible software configurations that have to be tested.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, since embedded devices often operate in critical applications or
    industries, comprehensive testing is a must. Therefore, many manufacturers refrain
    from using package managers and choose an atomic, image-based updating approach
    instead, restricting the interplay of software components to be tested to the
    specific versions in a certain software release.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to go down that road, you probably need a partner that offers automated
    and reliable testing services that handle all the mentioned issues, for example,
    as provided by Canonical for their Ubuntu Core OS.
  prefs: []
  type: TYPE_NORMAL
- en: '**Device Partitioning Strategies**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A robust update procedure is possible only if the memory partitioning of your
    device supports it. Depending on available memory and willingness to take risks,
    various approaches can be used to design a system’s partition layout to support
    updating processes.
  prefs: []
  type: TYPE_NORMAL
- en: '***Update/Recovery Partition***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can enhance robustness against failed firmware updates by introducing an
    additional *recovery partition*. This partition contains tools to download and
    update the main system partition, including the OS kernel and the corresponding
    root filesystem, as shown in [Figure 9-1](ch09.xhtml#ch09fig01).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: The recovery partition to perform system updates*'
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this approach is the low memory footprint of the extra partition,
    which should be feasible for many devices. However, on the downside, the device
    has to be rebooted to enter the update or recovery mode. If the update process
    fails, the main partition is corrupted and can’t be booted anymore, so the recovery
    partition is booted again, and a fresh update process can be initiated.
  prefs: []
  type: TYPE_NORMAL
- en: '***A/B System Approach***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For devices providing plenty of nonvolatile memory, the *A/B system* approach
    can be an interesting candidate. [Figure 9-2](ch09.xhtml#ch09fig02) depicts the
    basic partition layout and update procedure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2: Two identical system image copies—A and B*'
  prefs: []
  type: TYPE_NORMAL
- en: In this layout, two copies, A and B, of the system partition exist, both holding
    at least the OS kernel and the root filesystem. At boot, the partition marked
    as “bootable” (partition A in [Figure 9-2](ch09.xhtml#ch09fig02)) is used to load
    the OS and the basic filesystem. This includes an update client that’s able to
    receive firmware updates, verify them, and write them to the currently unused
    partition ➊ (B in [Figure 9-2](ch09.xhtml#ch09fig02)). Afterward, the bootloader
    is configured to swap the boot partition from A to B (or vice versa) ➋ before
    rebooting to the new firmware version.
  prefs: []
  type: TYPE_NORMAL
- en: In case of an update failure or partition corruption, the old version is still
    available in its original state and can be booted again. A significant advantage
    compared to using a recovery partition is that the standard device operation is
    not interrupted during the update download and installation. In addition, the
    newly downloaded firmware can be directly stored on the inactive partition instead
    of requiring an additional storage location for update caching. On Android devices,
    this concept is called *seamless system updates*, and it’s increasingly implemented
    by phone vendors.
  prefs: []
  type: TYPE_NORMAL
- en: For devices of even higher criticality, both approaches can be combined, as
    shown in [Figure 9-3](ch09.xhtml#ch09fig03).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-3: The A/B architecture with an additional recovery partition*'
  prefs: []
  type: TYPE_NORMAL
- en: This design aims for protection against cases in which both system partitions,
    A and B, are corrupted for whatever reason. For such architectures, it makes sense
    to store the recovery partition within a different physical memory than the system
    partitions. Even if the recovery partition can’t successfully reinstall the system
    partitions, it can still report the system failure and perform diagnostics.
  prefs: []
  type: TYPE_NORMAL
- en: '***A Note on Updating Bootloaders***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bootloaders are used on many embedded systems. They handle basic system initialization,
    select a boot medium, and subsequently load an OS kernel. In many cases, these
    binaries are regarded as an “immutable” firmware part.
  prefs: []
  type: TYPE_NORMAL
- en: However, these days, bootloaders like U-Boot and GRUB are complex software components
    with a variety of features and capabilities. As a consequence, bootloaders also
    may exhibit bugs or even security vulnerabilities that require updates.
  prefs: []
  type: TYPE_NORMAL
- en: From a security point of view, you also might need to replace public keys or
    outdated cryptographic algorithms used for a secure boot process, as described
    in [Chapter 8](ch08.xhtml#ch08). On the functional side, you might come to a point
    when you’d like to update hardware initialization settings, kernel boot parameters,
    or boot configurations. All these reasons render updating boot-loaders and their
    configuration data a valid consideration.
  prefs: []
  type: TYPE_NORMAL
- en: In most systems, however, only a single copy per bootloader is available, which
    means that updating it comes with the risk of breaking the device—for example,
    in the case of power loss or other failures during the bootloader update. Only
    a few SoCs and microcontrollers provide support for additional bootloader instances
    that can be run when the main bootloader fails. Therefore, updating a bootloader
    is always a critical and risky procedure that can well lead to a situation where
    physical access to a device is necessary for repair.
  prefs: []
  type: TYPE_NORMAL
- en: A compromise solution could be a multistage bootloader approach, splitting the
    functionality in two parts. The first stage is considered immutable and has minimal
    functionality, but provides support for multiple bootloader copies in the next
    stage, which carries the fully fledged bootloader. In such a system, security
    issues in the early stage still remain a problem and would require physical access
    or a risky update procedure, but the second stage can be stored redundantly, which
    allows for low-risk updating. However, this approach isn’t standard and would
    require further development efforts and customizations.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Interplay Between Development, Backend, and Device**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After clarifying all the details influencing your update strategy, it’s time
    to talk about the necessary operational processes for reliable and secure firmware
    updates. As described in [Chapter 1](ch01.xhtml#ch01), it’s the manufacturer’s
    responsibility to monitor device vulnerabilities exploited in the field and take
    vulnerability reports seriously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume you have that covered already and your development team is able
    to provide fixes in a short time frame. An operational question still remains:
    Should security updates and functional enhancements be merged with firmware updates,
    or should each be available separately?'
  prefs: []
  type: TYPE_NORMAL
- en: Some customers have to perform comprehensive testing of your device within their
    given infrastructure and, therefore, avoid upgrading devices with new functionalities
    that might require retests. However, they’re probably interested in security fixes
    that contribute to the robustness and security of their systems. In such scenarios,
    a split between functional and protective updates is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, imagine that a new firmware version leads to complications and
    customers have to downgrade to the previous version. If security updates are included
    in this update file, your customers would have to live with known vulnerabilities
    in your devices, at least until the functional issues are fixed. However, taking
    this separation seriously leads to more possible software configurations and more
    testing on the manufacturer side.
  prefs: []
  type: TYPE_NORMAL
- en: No matter the content of a firmware update, it has to be provided and packaged
    by the development team and corresponding build pipelines. If necessary, the firmware
    has to be encrypted, usually with a symmetric encryption scheme like AES. To achieve
    authenticity and integrity protection, the final firmware image has to be digitally
    signed by appropriate algorithms like RSA or ECDSA.
  prefs: []
  type: TYPE_NORMAL
- en: Both tasks include two components that have to match. On the manufacturer side,
    the firmware artifacts yielded by the build system have to be encrypted and signed
    to generate the actual firmware update files to be distributed. On the device
    itself, the signature verification and decryption has to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several image-based update systems perform those tasks for you: Mender, SWUpdate,
    and RAUC. Mender provides the whole infrastructure, including device client software
    and backend server. SWUpdate and RAUC generate and apply firmware update files,
    but the update distribution and monitoring is typically performed by the Eclipse
    hawkBit backend framework. Further candidates include OSTree and swupd, which
    follow a “Git-like” revision-based approach for firmware updates.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case Study: Secure Firmware Updates with SWUpdate**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This case study provides an example of the necessary practical steps to bring
    a secure firmware update architecture to life. It’s based on the Yocto tool-chain
    delivered by ST for the STM32MP157F-DK2 board.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve chosen SWUpdate as the central software component for this implementation.
    The desired outcome is an update process that verifies the authenticity of updates
    based on digital signatures and guarantees a reliable update procedure taking
    an A/B system approach.
  prefs: []
  type: TYPE_NORMAL
- en: '***SD Card Layout Customization***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Yocto build system compiles and packages all relevant software for my device’s
    firmware image and provides it in formats like *.ext4* and *.tar.gz*. This is
    useful for further processing, such as for generating an SD card image and creating
    an update file, but let’s take it one step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The STM32 Cube Programmer tool from ST as well as the handy shell script *create_sdcard_from_flashlayout.sh*
    use flash memory layout files in a Tab-Separated Values (TSV) format. Among other
    things, such a TSV file contains a list of partitions, their offset, and the files
    required to populate them. Selected columns of the default flash layout for the
    STM32MP157FDK2 board are shown in [Listing 9-1](ch09.xhtml#ch09list01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-1: The default flash layout for the STM32MP157F-DK2 board*'
  prefs: []
  type: TYPE_NORMAL
- en: The TSV file contains many lines concerning bootloaders and trusted firmware
    artifacts that are of minor interest at this point. The last three lines, however,
    reveal two important facts. First, a dedicated `bootfs` partition contains U-Boot
    configuration files, device-tree blobs, and the Linux kernel as a `uImage`. Second,
    the `rootfs` partition is a perfect candidate for duplication for an A/B system
    approach. [Listing 9-2](ch09.xhtml#ch09list02) shows the changes I made to the
    TSV file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-2: An adjusted partition layout for the A/B update approach*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The original `rootfs` partition was cloned, resulting in two new partitions:
    `rootfs-a` and `rootfs-b`. Also, a `userfs` partition, already available in the
    toolchain provided by ST, was added to store data that should “survive” an update
    of the root filesystem.'
  prefs: []
  type: TYPE_NORMAL
- en: For SD card image generation with the new parameters, the *create_sdcard _from_flashlayout.sh*
    shell script also had to be adapted to correctly handle the newly introduced partitions
    `rootfs-a` and `rootfs-b`. The SD card image size was set to 2,048MB, while both
    root partitions were configured to occupy 768MB, as already indicated by the offset
    of `0x30000000` in the flash layout file.
  prefs: []
  type: TYPE_NORMAL
- en: An important setting in the image creation script is the allocation of individual
    partition UUIDs for partitions `rootfs-a` and `rootfs-b`, as shown in [Listing
    9-3](ch09.xhtml#ch09list03).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-3: The individual UUIDs for both copies of the root filesystem*'
  prefs: []
  type: TYPE_NORMAL
- en: I reused the UUID of the original `rootfs` partition for `rootfs-a` and randomly
    created a new one for `rootfs-b`. These UUIDs are relevant because they are used
    in U-Boot’s *extlinux.conf* configuration file located in the `bootfs` partition
    to determine the partition to be mounted as the root filesystem by the Linux kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, the basic partition architecture for this case study is ready to
    support A/B system updates.
  prefs: []
  type: TYPE_NORMAL
- en: '***SWUpdate Installation and Configuration***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SWUpdate, a feature-rich firmware update tool for embedded systems, provides
    the corresponding `meta-swupdate` layer for Yocto. This layer can be cloned from
    its Git repository and added to the STM32MP1 Yocto project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Addition of Security Features**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One of the first tasks is to create a recipe that patches the configuration
    of SWUpdate to enable signed and encrypted images. [Listing 9-4](ch09.xhtml#ch09list04)
    shows the three lines that have to be explicitly activated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-4: Activating important security features of SWUpdate*'
  prefs: []
  type: TYPE_NORMAL
- en: The two options `CONFIG_HASH_VERIFY` and `CONFIG_SIGNED_IMAGES` add capabilities
    to SWUpdate that allow it to verify hashes and digital signatures of images included
    in a software update. The `CONFIG_ENCRYPTED_IMAGES` option enables support for
    AES-encrypted images, which we don’t implement at the moment, but it might be
    a valuable option for the future.
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Generation**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As explained in [Chapter 2](ch02.xhtml#ch02), digital signatures are an asymmetric
    crypto primitive that allow for verification of integrity and authenticity of
    signed data. SWUpdate can generate signatures based on plain RSA keys or certificates.
    For this case study, I chose to use 4,096-bit RSA keys. Their generation can be
    split into three steps, as shown in [Listing 9-5](ch09.xhtml#ch09list05).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-5: The RSA key generation for update signing and verification*'
  prefs: []
  type: TYPE_NORMAL
- en: First, the file *passphrase* is created that should contain a strong password.
    Afterward, the RSA key can be generated (for example, with 4,096-bit length).
    The resulting private key is encrypted based on the given passphrase file and
    stored as *swu_signing_key.pem*. Note that this is the RSA private key used for
    signing a firmware update after the build process. The corresponding public key
    is extracted and saved as *swu_verification_key.pem* in the third line of the
    listing. This is necessary to make that key available in the final device firmware
    because it’s required for update signature verification.
  prefs: []
  type: TYPE_NORMAL
- en: '**Software Collection**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next, SWUpdate needs to know which Yocto build artifacts should be included
    in the firmware update. This information is stored in the *sw-description* file,
    which is used for update generation, but it’s also included in the firmware update
    package itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-6](ch09.xhtml#ch09list06) shows the software collection I defined
    for this use case.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-6: The software collection defined in the* sw-description *file*'
  prefs: []
  type: TYPE_NORMAL
- en: The first point you might stumble upon is the `hardware-compatibility` parameter
    ➊. I set it to `C02` because it’s the hardware and assembly revision of my STM32MP157F-DK2
    board. At runtime, this parameter has to match the data given in */etc/hwrevision*
    (for example, `stm32mp157f-dk2 C02` in my case).
  prefs: []
  type: TYPE_NORMAL
- en: Second, both partitions `rootfs-a` ➋ and `rootfs-b` ➐ are represented in this
    software collection, although only one will be used for updating at runtime. Both
    contain the same filename of the artifact to update ➌—in this case, the root filesystem
    generated by Yocto. The `compressed` parameter ➍ indicates whether the data is
    available in compressed form, while `sha256` ➏ integrates the SHA-256 hash value
    of the provided artifact into the *sw-description* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two images differ in only one property: the partition indicated by the
    `device` parameter ➎. This determines where the SWUpdate client writes the update
    to. In this case, */dev/mmcblk0p10* and */dev/mmcblk0p11* are the device names
    under which the earlier created partitions `rootfs-a` and `rootfs-b` are available
    within Linux. If */dev/mmcblk0p10* is the active partition, the update has to
    be written to */dev/mmcblk0p11*, and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recipe for Update File Generation**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: SWUpdate’s firmware update files have the *.swu* extension. The `meta-swupdate`
    layer comes with a class that supports SWU filegeneration by Yocto based on artifacts
    previously built and stored in Yocto’s *deploy* directory. [Listing 9-7](ch09.xhtml#ch09list07)
    shows the corresponding code for a Yocto recipe that automatically generates a
    valid and digitally signed SWU file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-7: The recipe code that generates an SWU update file*'
  prefs: []
  type: TYPE_NORMAL
- en: The recipe adds the *sw-description* file created earlier and states the dependency
    on the `st-image-core` image. Within Yocto’s *deploy* directory, the desired update
    content (the device’s root filesystem) can be found in files starting with *st-image-core-openstlinux-eglfs*,
    while the target machine is added automatically by SWUpdate.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to SD card image creation, where the file with the *.ext4* extension
    is used (as shown in [Listing 9-2](ch09.xhtml#ch09list02)), the firmware update
    should be as small as possible to optimize transfer times. Therefore, the compressed
    artifact with *.ext4.gz* is used for the SWU file. Finally, to enable firmware
    update signing, I set `SWUPDATE_SIGNING` to `"RSA"` and provided the paths to
    the private RSA signing key and its corresponding passphrase file.
  prefs: []
  type: TYPE_NORMAL
- en: Running this recipe ensures that the `st-image-core` image is built and then
    yields the *swupdate-swu-gen-openstlinux-eglfs-stm32mp1.swu* file within the *deploy*
    directory. This file is actually a copy-in-and-out (CPIO) archive that contains
    the *sw-description* file and its signature *sw-description.sig* file. Additionally,
    the compressed *st-image-core-openstlinux-eglfs-stm32mp1.ext4.gz* file is shipped
    within this archive, which contains the root filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you wonder why there isn’t any signature file for the root filesystem,
    remember that the* sw-description *file contains the hash of this image, which
    would change if anyone had tampered with it. The signature of the description
    file also protects the authenticity and integrity of the root filesystem.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Device-Specific Customization***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s turn to the device, the update client, and the necessary customizations
    to make SWUpdate work properly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Update Daemon**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To install SWUpdate’s device client and its web server components, `swupdate`
    and `swupdate-www` have to be added to ST’s core image. For configuration, the
    first consideration on the device side is which update methods it should support.
    In general, SWUpdate provides three typical ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mongoose mode**    This daemon provides a simple web interface to allow for
    manual updates over a network.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Suricatta mode**    In conjunction with Eclipse’s hawkBit, SWUpdate supports
    comprehensive OTA update setups that can be managed and controlled by a central
    server instance.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local install**    If the SWU file is locally available (for example, on
    a USB flash drive), the update can be directly installed without requiring a network
    connection.'
  prefs: []
  type: TYPE_NORMAL
- en: For this case study, I’ve chosen the mongoose daemon. As the system at hand
    uses `systemd` for Linux service configuration and management, a service file
    (*swupdate.service*) can be created as shown in [Listing 9-8](ch09.xhtml#ch09list08)
    and installed in the */etc/systemd/system/* directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-8: A basic service file to start* swupdate *in mongoose mode after
    boot*'
  prefs: []
  type: TYPE_NORMAL
- en: SWUpdate’s binary is located at */usr/bin/swupdate*. It can be started in mongoose
    daemon mode at system boot with the `-w` command line parameter. The `-r /www`
    and `-p 8080` arguments following in single quotes tell it to use the default
    web application located at */www* and to bind its web server to port 8080.
  prefs: []
  type: TYPE_NORMAL
- en: The string provided after the `-e` option defines which part of the expected
    software collection should be installed in the case of an update. In the default
    scenario, where `rootfs-a` is the active partition, the daemon should be started
    with `-e 'stable,rootfs-b'` to make sure that a potential update is written to
    `rootfs-b`, the inactive partition.
  prefs: []
  type: TYPE_NORMAL
- en: Besides setting configuration options with command line arguments, you could
    also provide the *swupdate.cfg* configuration file at a path matching the client’s
    compile-time configuration—for example, */etc/swupdate/*. As shown in [Listing
    9-9](ch09.xhtml#ch09list09), logging parameters, paths to keys, and post-update
    shell scripts are typical settings you might want to place here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-9: An example configuration file for* swupdate'
  prefs: []
  type: TYPE_NORMAL
- en: However, whether you use command line arguments or a configuration file is mainly
    a matter of taste.
  prefs: []
  type: TYPE_NORMAL
- en: '**Post-Update Tasks**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Every device, its architecture, and its update strategy is different. Therefore,
    a general tool like SWUpdate can’t automatically derive what to do before and
    after a firmware update is written to its corresponding memory device or partition.
    On the command line, the `-p` and `-P` parameters allow for defining paths to
    *post-update* and *pre-update* commands, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In my case, only a post-update routine was necessary to prepare the device for
    booting the new firmware version. [Listing 9-10](ch09.xhtml#ch09list010) shows
    the contents of the *postupdate.sh* shell script that’s executed after the update
    installation, as defined in *swupdate.cfg*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-10: A script to prepare a device for booting the updated firmware*'
  prefs: []
  type: TYPE_NORMAL
- en: The first `if` statement ➊ checks whether the board’s U-Boot configuration file,
    *stm32mp157f-dk2_extlinux.conf*, located at */boot/mmc0_extlinux/*, contains the
    default partition UUID `e91c4e10-16e6-4c0e-bd0e-77becf4a3582`. If so, `rootfs-a`
    is the active partition, and the update was just written to `rootfs-b`. Therefore,
    the *swupdate.service* configuration file on the new partition has to be set to
    update the soon-to-be-inactive partition, `rootfs-a` ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, the partition UUID in U-Boot’s configuration file is replaced by
    the one representing `rootfs-b` ➌. This ensures that U-Boot starts the Linux kernel
    with the new root filesystem. If anything fails before this operation or a power
    loss occurs, the device will just boot into the existing firmware. But if everything
    goes well, the partition for the root filesystem is swapped and the device is
    deliberately rebooted ➍. Of course, the same procedure works the opposite way
    if the script detects that `rootfs-b` is the active partition.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this is just one possible implementation of a post-update script
    that works for the specific architecture in this case study. Your device might
    require completely different reconfigurations before or after installing a firmware
    update.
  prefs: []
  type: TYPE_NORMAL
- en: '***Update Process Evaluation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To conclude this case study, I flashed the previously created 2GB image to a
    16GB microSD card and booted my STM32MP157F-DK2 board from it. First, I checked
    which root filesystem partition was currently active. [Listing 9-11](ch09.xhtml#ch09list011)
    shows that both copies A (`mmcblk0p10`) and B (`mmcblk0p11`) are available and
    correctly sized. The slash at the right end of the line indicates that `rootfs-a`
    is currently mounted as the root filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-11: The* mmcblk0p10 *partition mounted as the root filesystem*'
  prefs: []
  type: TYPE_NORMAL
- en: As a second step, I printed the logs of the installed `swupdate` daemon. [Listing
    9-12](ch09.xhtml#ch09list012) shows selected lines of the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-12: The* swupdate *service logs*'
  prefs: []
  type: TYPE_NORMAL
- en: The result indicates that the daemon started ➊ and the board as well, as the
    hardware revision was read correctly ➋. Further, the configuration that a potential
    update should be written to `rootfs-b` ➌ is shown as desired. In addition, the
    start of the included web server with the configured port and given directory
    is confirmed ➍.
  prefs: []
  type: TYPE_NORMAL
- en: I used a common browser to connect to the device’s IP address on port 8080,
    and it immediately showed the default web interface of SWUpdate. There, the SWU
    file created by Yocto could be uploaded to the device, and a progress bar showed
    the percentage of update completion. Shortly after reaching 100 percent, the device
    rebooted as expected, and a second look at `lsblk`, as shown in [Listing 9-13](ch09.xhtml#ch09list013),
    indicated that the swapping from copy A to copy B succeeded. The second update
    attempt also worked successfully and swapped the root filesystem back to `mmcblk0p10`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-13: The* mmcblk0p11 *partition mounted as the root filesystem after
    the update*'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to test digital signature verification, I also tried to maliciously
    modify the firmware update file by extracting the original files, changing the
    target partition of `rootfs-a` to `/dev/mmcblk0p9`, and combining the modified
    files into a valid CPIO archive again. However, when uploading over the web interface,
    it soon responds with the message `Update failed`. Looking at the log data on
    the device shows that the signature verification failed as expected ([Listing
    9-14](ch09.xhtml#ch09list014)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-14: The signature verification fails for the modified firmware update.*'
  prefs: []
  type: TYPE_NORMAL
- en: Testing software update verification routines for their correct *rejection behavior*
    is not only valuable during development. It also makes absolute sense to integrate
    similar test cases into release or production testing, because it wouldn’t be
    the first time that verification got switched off by accident.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Providing software and firmware updates for devices doesn’t seem like a very
    difficult task at first glance. However, if all requirements regarding security,
    scalability, and reliability are considered, it becomes a complex topic that impacts
    development pipelines, nonvolatile memory layouts, backend services, and customer
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter stressed the inevitable need to provide secure update mechanisms
    for all kinds of IoT devices because none of them is perfect, and at some point,
    manufacturers as well as customers will demand firmware updates that have to be
    distributed and applied securely and must not break the device. To achieve these
    requirements, manufacturers have to ensure authenticity and integrity protection,
    they have to discuss update formats and granularity, and the memory partitioning
    has to support atomic and fail-safe update procedures. Also, backend servers that
    schedule, distribute, and monitor update deployments in the field have to be operated.
  prefs: []
  type: TYPE_NORMAL
- en: If you still think it’s all too much for you to handle, and maybe your devices
    will never need any updates because that was the case during past decades, pull
    out the risk analysis for your networked device and reconsider the impact ratings
    in the event that you wouldn’t be able to fix vulnerabilities. Also, make sure
    you add “update misuse” to your list of threats if you’re going with an update
    mechanism that resembles an invitation for adversaries to install their custom
    software.
  prefs: []
  type: TYPE_NORMAL
