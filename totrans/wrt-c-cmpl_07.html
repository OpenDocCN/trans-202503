<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_116" aria-label="116"/>&#13;
<figure class="co-img"><img id="fig-pg116" class="img60" src="../images/pg117.jpg" alt="" width="687" height="1576"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-14.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_117" aria-label="117"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch6">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">IF STATEMENTS AND CONDITIONAL EXPRESSIONS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">In the last chapter, you learned how to compile programs that execute a list of statements. But most C programs have a more complicated execution path; they often need to decide what statements to execute at runtime based on the current state of the program. The order in which a program executes statements is its <i>control flow</i>, and the language constructs that let you change a program’s control flow are called <i>control structures</i>.</p>&#13;
<p class="TX">In this chapter, you’ll implement your first control structure: <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements. You’ll also implement <i>conditional expressions</i>. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements, conditional expressions let you control what code to run. For example, the conditional expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0) ? 3 : 4</samp> evaluates to 3 if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> and 4 otherwise. We laid a lot of the groundwork for <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements and conditional expressions when we implemented the short-circuiting <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operators in <span class="Xref-1"><a href="chapter4.xhtml">Chapter 4</a></span>. We already have TACKY constructs that let us <span role="doc-pagebreak" epub:type="pagebreak" id="pg_118" aria-label="118"/>conditionally run or skip over code, so we don’t need to change any stages after TACKY generation. Let’s get started!</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-52"/><samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp></h3>&#13;
<p class="TNI">You’ll add four tokens in this chapter:</p>&#13;
<table class="Basic-Table-ind">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table" scope="col"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">if</samp></p></th>&#13;
<th class="Basic-Table" scope="col"><p class="TB2">A keyword indicating the start of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement</p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">else</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">A keyword indicating the start of the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">?</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">A question mark, the delimiter between the first and second operands in a conditional expression</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">:</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">A colon, the delimiter between the second and third operands in a conditional expression</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Once your lexer supports these four tokens, you can test it out.</p>&#13;
<aside class="box" aria-label="box-99"><p class="BoxTitle" id="box-99"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE LEXER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your lexer, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 6 --stage lex</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">It should be able to process every test case in this chapter without errors.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-53"/><samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp></h3>&#13;
<p class="TNI">Now we’ll update the parser to support <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements and conditional expressions. Because these are two distinct language constructs, we’ll handle them one at a time, beginning with <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-41"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing if Statements</samp></h4>&#13;
<p class="TNI">We’ll start by extending the <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp> AST node to support <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements. <a href="chapter6.xhtml#list6-1">Listing 6-1</a> gives the updated definition of this node.</p>&#13;
<a id="list6-1"/>&#13;
<pre><code>statement = Return(exp)&#13;
          | Expression(exp)&#13;
          <b>| If(exp condition, statement then, statement? else)</b>&#13;
          | Null</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-1: The definition for the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">AST node, including</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp></p>&#13;
<p class="TX">The new <samp class="SANS_TheSansMonoCd_W5Regular_11">If</samp> constructor takes three arguments. The <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp> expression, sometimes called the <i>controlling expression</i>, determines whether the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_119" aria-label="119"/>body of the statement is executed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp> statement is the first clause of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, which executes when the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp> is nonzero. The second clause, the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> statement, is optional. If it’s present, it executes when the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp> is 0.</p>&#13;
<p class="TX">As I mentioned in the previous chapter, each clause in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement is itself a single statement. Although it may look like multiple statements, the body of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement like the one in <a href="chapter6.xhtml#list6-2">Listing 6-2</a> is really a single compound statement.</p>&#13;
<a id="list6-2"/>&#13;
<pre><code>if (a == 3) {&#13;
    a = a + 1;&#13;
    int b = a * 4;&#13;
    return a &amp;&amp; b;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-2: An</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement whose body is a compound statement</samp></p>&#13;
<p class="TX">We haven’t implemented compound statements yet, so at this point we can’t compile code like <a href="chapter6.xhtml#list6-2">Listing 6-2</a>. <a href="chapter6.xhtml#list6-3">Listing 6-3</a> gives an example of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement that we can compile.</p>&#13;
<a id="list6-3"/>&#13;
<pre><code>if (a == 3)&#13;
    return a;&#13;
else&#13;
    b = 8;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-3: An</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement that doesn’t contain any compound statements</samp></p>&#13;
<p class="TX">We can also compile <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements nested inside other <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements, like <a href="chapter6.xhtml#list6-4">Listing 6-4</a>.</p>&#13;
<a id="list6-4"/>&#13;
<pre><code>if (a)&#13;
    if (a &gt; 10)&#13;
        return a;&#13;
    else&#13;
        return 10 - a;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-4: An</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement nested inside another</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp></p>&#13;
<p class="TX">Note that the AST definition in <a href="chapter6.xhtml#list6-1">Listing 6-1</a> doesn’t have an <samp class="SANS_TheSansMonoCd_W5Regular_11">else if</samp> construct, because an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement can have at most one <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause. An <samp class="SANS_TheSansMonoCd_W5Regular_11">else if</samp> clause is really just an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause that contains another <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement. Take <a href="chapter6.xhtml#list6-5">Listing 6-5</a> as an example.</p>&#13;
<a id="list6-5"/>&#13;
<pre><code>if (a &gt; 100)&#13;
    return 0;&#13;
else if (a &gt; 50)&#13;
    return 1;&#13;
else&#13;
    return 2;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-5: An</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement nested inside an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">else</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">clause</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_120" aria-label="120"/>Let’s reformat this in a way that better reflects how it will be parsed:</p>&#13;
<pre><code>if (a &gt; 100)&#13;
    return 0;&#13;
else&#13;
    if (a &gt; 50)&#13;
        return 1;&#13;
    else&#13;
        return 2;</code></pre>&#13;
<p class="TX">The AST for <a href="chapter6.xhtml#list6-5">Listing 6-5</a> will look like this:</p>&#13;
<pre><code>If(&#13;
    condition=Binary(GreaterThan, Var("a"), Constant(100)),&#13;
    then=Return(Constant(0)),&#13;
    else=If(&#13;
        condition=Binary(GreaterThan, Var("a"), Constant(50)),&#13;
        then=Return(Constant(1)),&#13;
        else=Return(Constant(2))&#13;
    )&#13;
)</code></pre>&#13;
<p class="TX"><a href="chapter6.xhtml#list6-6">Listing 6-6</a> shows the changes to the grammar, which exactly mirror the changes to the AST.</p>&#13;
<a id="list6-6"/>&#13;
<pre><code>&lt;statement&gt; ::= "return" &lt;exp&gt; ";"&#13;
              | &lt;exp&gt; ";"&#13;
<b>              | "if" "(" &lt;exp&gt; ")" &lt;statement&gt; ["else" &lt;statement&gt;]</b>&#13;
              | ";"</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-6: The grammar rules for statements, including</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp></p>&#13;
<p class="TX">We can handle this new production rule with straightforward recursive descent parsing. Interestingly, this rule is ambiguous, but that ambiguity won’t pose any problems for our parser. Let’s take another look at <a href="chapter6.xhtml#list6-4">Listing 6-4</a>:</p>&#13;
<pre><code>if (a)&#13;
    if (a &gt; 10)&#13;
        return a;&#13;
    else&#13;
        return 10 - a;</code></pre>&#13;
<p class="TX">There are two ways to parse this listing that both follow our new grammar rule: we could group the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause with either the first or the second <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement. In other words, we could parse this listing like this:</p>&#13;
<pre><code>if (a) {&#13;
    if (a &gt; 10)&#13;
        return a;&#13;
    else&#13;
        return 10 - a;&#13;
}</code></pre>&#13;
<p class="BodyContinued"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_121" aria-label="121"/>Or we could parse it like this:</p>&#13;
<pre><code>if (a) {&#13;
    if (a &gt; 10)&#13;
        return a;&#13;
}&#13;
else&#13;
    return 10 - a;</code></pre>&#13;
<p class="TX">The C standard clarifies that the first of these alternatives is correct; an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause should always be grouped with the closest <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement. However, the grammar by itself doesn’t tell us which of these options to choose. This quirk of the grammar is called the <i>dangling else</i> ambiguity, and it can cause problems for parser generators that automatically convert formal grammars into parsing code.</p>&#13;
<p class="TX">Luckily, the dangling else ambiguity isn’t an issue for handwritten recursive descent parsers like ours. Whenever we parse an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, we’ll look for an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> keyword right after the statement body; if we find one, we’ll go ahead and parse the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause. In cases like <a href="chapter6.xhtml#list6-4">Listing 6-4</a>, this means that we’ll end up parsing the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause as part of the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, which is the correct behavior.</p>&#13;
<p class="TX">Go ahead and implement this production rule now; then, we’ll move on to conditional expressions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-42"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing Conditional Expressions</samp></h4>&#13;
<p class="TNI">The conditional <samp class="SANS_TheSansMonoCd_W5Regular_11">: ?</samp> operator is a <i>ternary</i> operator, which takes three operands. In <a href="chapter6.xhtml#list6-7">Listing 6-7</a>, we add this operator to the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node.</p>&#13;
<a id="list6-7"/>&#13;
<pre><code>exp = Constant(int)&#13;
    | Var(identifier)&#13;
    | Unary(unary_operator, exp)&#13;
    | Binary(binary_operator, exp, exp)&#13;
<b>    </b>| Assignment(exp, exp)&#13;
<b>    | Conditional(exp condition, exp, exp)</b></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-7: The definition for the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">AST node, including conditional expressions</samp></p>&#13;
<p class="TX">In <a href="chapter6.xhtml#list6-8">Listing 6-8</a>, we add it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp> grammar rule.</p>&#13;
<a id="list6-8"/>&#13;
<pre><code>&lt;exp&gt; ::= &lt;factor&gt; | &lt;exp&gt; &lt;binop&gt; &lt;exp&gt; | <b>&lt;exp&gt; "?" &lt;exp&gt; ":" &lt;exp&gt;</b></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-8: The grammar rule for expressions, including conditional expressions</samp></p>&#13;
<p class="TX">Now we need to figure out its precedence and associativity. It’s not immediately obvious how precedence and associativity work for a ternary expression. The trick is to think of it as a binary expression where the operator in the middle is <samp class="SANS_TheSansMonoCd_W5Regular_11">"?" &lt;exp&gt; ":"</samp>. The “operator” is easy to parse because it’s delimited by <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> tokens; it just happens to include an entire subexpression. (You should think of it this way only during parsing, not during later stages. We can <i>parse</i> this like a binary expression, but we’ll <i>evaluate</i> it <span role="doc-pagebreak" epub:type="pagebreak" id="pg_122" aria-label="122"/>completely differently!) This lets us define the conditional operator’s precedence relative to other binary operators: it has higher precedence than assignment and lower precedence than everything else. For example, the expression</p>&#13;
<pre><code>a = 1 ? 2 : 3</code></pre>&#13;
<p class="BodyContinued">is parsed as</p>&#13;
<pre><code>a = (1 ? 2 : 3)</code></pre>&#13;
<p class="BodyContinued">but</p>&#13;
<pre><code>a || b ? 2 : 3</code></pre>&#13;
<p class="BodyContinued">is parsed as:</p>&#13;
<pre><code>(a || b) ? 2 : 3</code></pre>&#13;
<p class="TX">The same logic applies for the third operand. We parse</p>&#13;
<pre><code>1 ? 2 : 3 || 4</code></pre>&#13;
<p class="BodyContinued">as</p>&#13;
<pre><code>1 ? 2 : (3 || 4)</code></pre>&#13;
<p class="BodyContinued">but we parse</p>&#13;
<pre><code>1 ? 2 : a = 5</code></pre>&#13;
<p class="BodyContinued">as:</p>&#13;
<pre><code>(1 ? 2 : a) = 5</code></pre>&#13;
<p class="TX">The semantic analysis pass will reject this last expression, since <samp class="SANS_TheSansMonoCd_W5Regular_11">1 ? 2 : a</samp> isn’t a valid lvalue. However, any expression can appear between the <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> tokens, even an assignment expression. Those tokens act like parentheses, delimiting where an expression starts and ends. So, the conditional expression</p>&#13;
<pre><code>x ? x = 1 : 2</code></pre>&#13;
<p class="BodyContinued">is equivalent to:</p>&#13;
<pre><code>x ? (x = 1) : 2</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_123" aria-label="123"/>The same logic applies when you nest one conditional expression inside another, meaning</p>&#13;
<pre><code>a ? b ? 1 : 2 : 3</code></pre>&#13;
<p class="BodyContinued">is parsed as:</p>&#13;
<pre><code>a ? (b ? 1 : 2) : 3</code></pre>&#13;
<p class="TX">Next, let’s look at associativity. The conditional operator is right-associative, so</p>&#13;
<pre><code>a ? 1 : b ? 2 : 3</code></pre>&#13;
<p class="BodyContinued">is parsed as:</p>&#13;
<pre><code>a ? 1 : (b ? 2 : 3)</code></pre>&#13;
<p class="TX">Since conditional expressions can be parsed like weird binary expressions, we can (almost) handle them with our existing precedence climbing code. First, we’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> to our precedence table; <a href="chapter6.xhtml#tab6-1">Table 6-1</a> lists all our precedence values.</p>&#13;
<p class="TT" id="tab6-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 6-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Precedence Values of Binary and Ternary Operators</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Precedence</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">50</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">50</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">50</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">45</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">45</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">35</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">35</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">35</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;=</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">35</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">30</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">30</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">5</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">?</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">3</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">We look at only the first token of the <samp class="SANS_TheSansMonoCd_W5Regular_11">? &lt;exp&gt; :</samp> “operator” during precedence climbing, so <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> goes in the table but <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> doesn’t.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_124" aria-label="124"/>Next, we’ll update our precedence climbing code again. In the previous chapter, we handled assignment as a special case so we could use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp> AST node for it. Now we’ll treat conditional expressions as a special case too. <a href="chapter6.xhtml#list6-9">Listing 6-9</a> shows the updated precedence climbing pseudocode. Changes from the previous version of this algorithm, in <span class="Xref-1"><a href="chapter5.xhtml#list5-8">Listing 5-8</a></span>, are bolded.</p>&#13;
<a id="list6-9"/>&#13;
<pre><code>parse_exp(tokens, min_prec):&#13;
    left = parse_factor(tokens)&#13;
    next_token = peek(tokens)&#13;
    while next_token is a binary operator and precedence(next_token) &gt;= min_prec:&#13;
        if next_token is "=":&#13;
            take_token(tokens) // remove "=" from list of tokens&#13;
            right = parse_exp(tokens, precedence(next_token))&#13;
            left = Assignment(left, right)&#13;
        <b>else if next_token is "?":</b>&#13;
            <b>middle = parse_conditional_middle(tokens)</b>&#13;
            <b>right = parse_exp(tokens, precedence(next_token))</b>&#13;
            <b>left = Conditional(left, middle, right)</b>&#13;
        else:&#13;
            operator = parse_binop(tokens)&#13;
            right = parse_exp(tokens, precedence(next_token) + 1)&#13;
            left = Binary(operator, left, right)&#13;
        next_token = peek(tokens)&#13;
    return left</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-9: Precedence climbing with support for conditional expressions</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_conditional_middle</samp> function, which I haven’t included code for here, should just consume the <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> token, then parse an expression (with the minimum precedence reset to 0), then consume the <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> token. Next, we parse the third operand the same way we parse the right-hand side of any other expression: by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> recursively. Since the conditional operator is right-associative, like assignment, we set the minimum precedence on the recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence(next_token)</samp>, not <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence(next_token)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. Finally, we construct a <samp class="SANS_TheSansMonoCd_W5Regular_11">Conditional</samp> AST node from our three operands.</p>&#13;
<p class="TX"><a href="chapter6.xhtml#list6-10">Listing 6-10</a> gives the complete AST definition, with the changes to support <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements and conditional expressions bolded. These are the same changes we introduced earlier in this section; I’ve pulled them all together here for easier reference.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_125" aria-label="125"/>&#13;
<a id="list6-10"/>&#13;
<pre><code>program = Program(function_definition)&#13;
function_definition = Function(identifier name, block_item* body)&#13;
block_item = S(statement) | D(declaration)&#13;
declaration = Declaration(identifier name, exp? init)&#13;
statement = Return(exp)&#13;
          | Expression(exp)&#13;
          <b>| If(exp condition, statement then, statement? else)</b>&#13;
          | Null&#13;
exp = Constant(int)&#13;
<b>    </b>| Var(identifier)&#13;
    | Unary(unary_operator, exp)&#13;
    | Binary(binary_operator, exp, exp)&#13;
<b>    </b>| Assignment(exp, exp)&#13;
<b>    | Conditional(exp condition, exp, exp)</b>&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or&#13;
                | Equal | NotEqual | LessThan |<b> </b>LessOrEqual&#13;
                | GreaterThan | GreaterOrEqual</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-10: The abstract syntax tree with conditional expressions and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp></p>&#13;
<p class="TX"><a href="chapter6.xhtml#list6-11">Listing 6-11</a> shows the corresponding changes to the grammar.</p>&#13;
<a id="list6-11"/>&#13;
<pre><code>&lt;program&gt; ::= &lt;function&gt;&#13;
&lt;function&gt; ::= "int" &lt;identifier&gt; "(" "void" ")" "{" {&lt;block-item&gt;} "}"&#13;
&lt;block-item&gt; ::= &lt;statement&gt; | &lt;declaration&gt;&#13;
&lt;declaration&gt; ::= "int" &lt;identifier&gt; ["=" &lt;exp&gt;] ";"&#13;
&lt;statement&gt; ::= "return" &lt;exp&gt; ";"&#13;
              | &lt;exp&gt; ";"&#13;
<b>              | "if" "(" &lt;exp&gt; ")" &lt;statement&gt; ["else" &lt;statement&gt;]</b>&#13;
              | ";"&#13;
&lt;exp&gt; ::= &lt;factor&gt; | &lt;exp&gt; &lt;binop&gt; &lt;exp&gt; <b>| &lt;exp&gt; "?" &lt;exp&gt; ":" &lt;exp&gt;</b>&#13;
&lt;factor&gt; ::= &lt;int&gt; | &lt;identifier&gt; | &lt;unop&gt; &lt;factor&gt; | "(" &lt;exp&gt; ")"&#13;
&lt;unop&gt; ::= "-" | "~" | "!"&#13;
&lt;binop&gt; ::= "-" | "+" | "*" | "/" | "%" | "&amp;&amp;" | "||"&#13;
          | "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | "="&#13;
&lt;identifier&gt; ::= ? An identifier token ?&#13;
&lt;int&gt; ::= ? A constant token ?</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-11: The grammar with conditional expressions and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp></p>&#13;
<p class="TX">Once you’ve implemented these changes, you’re ready to test your parser.</p>&#13;
<aside class="box" aria-label="box-100"><p class="BoxTitle" id="box-100"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE PARSER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Your parser should succeed on every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_6/valid</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_6/invalid_semantics</samp> <samp class="SANS_Futura_Std_Book_11">and fail on the test cases in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_6/invalid_parse</samp><samp class="SANS_Futura_Std_Book_11">. To test the parser, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 6 --stage parse</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">You may want to write additional tests to verify that your parser handles conditional expressions correctly.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h1-54"/><samp class="SANS_Futura_Std_Bold_B_11">Variable Resolution</samp></h3>&#13;
<p class="TNI">The changes to this pass are minor. You’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> to handle the new constructs we added in this chapter, traversing their substatements and subexpressions. That will update variable <span role="doc-pagebreak" epub:type="pagebreak" id="pg_126" aria-label="126"/>names in <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements and conditional expressions in exactly the same way as variables that appear in other constructs.</p>&#13;
<aside class="box" aria-label="box-101"><p class="BoxTitle" id="box-101"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE VARIABLE RESOLUTION PASS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test the variable resolution pass, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 6 --stage validate</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">This pass should succeed on every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_6/valid</samp> <samp class="SANS_Futura_Std_Book_11">and fail on every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_6/invalid_semantics</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h1-55"/><samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp></h3>&#13;
<p class="TNI">We can implement <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements and conditional expressions with our existing TACKY instructions. We’ll use the same basic approach here as for the short-circuiting <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operators in <span class="Xref-1"><a href="chapter4.xhtml">Chapter 4</a></span>: first we’ll evaluate the controlling expression, then we’ll use conditional jumps to go to the appropriate clause of the statement or expression. Let’s implement <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements first.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-43"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting if Statements to TACKY</samp></h4>&#13;
<p class="TNI">A statement of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">if (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;condition&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">) then</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;statement&gt;</samp> should translate to the TACKY in <a href="chapter6.xhtml#list6-12">Listing 6-12</a>.</p>&#13;
<a id="list6-12"/>&#13;
<pre><code><var>&lt;instructions for condition&gt;</var>&#13;
c = <var>&lt;result of condition&gt;</var>&#13;
JumpIfZero(c, end)&#13;
<var>&lt;instructions for statement&gt;</var>&#13;
Label(end)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-12: The TACKY for an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp></p>&#13;
<p class="TX">That’s it! First, we evaluate the controlling expression, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;condition&gt;</samp>. If the result is 0, we jump to the end of the whole <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement. Otherwise, we execute the instructions for <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;statement&gt;</samp>. If the statement also has an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause, the resulting TACKY is only a tiny bit more complicated. The statement <samp class="SANS_TheSansMonoCd_W5Regular_11">if (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;condition&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">) then</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;statement1&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;statement2&gt;</samp> translates to the TACKY in <a href="chapter6.xhtml#list6-13">Listing 6-13</a>.</p>&#13;
<a id="list6-13"/>&#13;
<pre><code><var>&lt;instructions for condition&gt;</var>&#13;
c = <var>&lt;result of condition&gt;</var>&#13;
JumpIfZero(c, else_label)&#13;
<var>&lt;instructions for statement1&gt;</var>&#13;
Jump(end)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_127" aria-label="127"/>Label(else_label)&#13;
<var>&lt;instructions for statement2&gt;</var>&#13;
Label(end)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-13: The TACKY for an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement with an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">else</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">clause</samp></p>&#13;
<p class="TX">Just like in <a href="chapter6.xhtml#list6-12">Listing 6-12</a>, we evaluate the controlling expression, then perform a conditional jump if the result is 0. But instead of jumping to the end of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, in this case we jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">else_label</samp>, then execute <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;statement2&gt;</samp>. If the controlling expression evaluates to a nonzero value, we execute <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;statement1&gt;</samp>, then jump to the end of the entire statement. We can handle conditional expressions in a similar way; we’ll look at those next.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-44"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Conditional Expressions to TACKY</samp></h4>&#13;
<p class="TNI">For conditional expressions, like short-circuiting expressions, the C standard provides guarantees about which subexpressions are executed and when. To evaluate the expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;condition&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;clause1&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;clause2&gt;</samp>, you have to evaluate <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;condition&gt;</samp> first, then evaluate either <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;clause1&gt;</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;clause2&gt;</samp>, depending on the result of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;condition&gt;</samp>. You can’t, for example, evaluate both clauses, then evaluate <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;condition&gt;</samp> to decide which result to use, since that might produce unexpected side effects. The upshot is that we’ll handle conditional expressions very similarly to <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements. The only difference is that an expression, unlike a statement, produces a result that we need to store in the right destination. The expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;condition&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;e1&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;e2&gt;</samp> will produce the TACKY in <a href="chapter6.xhtml#list6-14">Listing 6-14</a>.</p>&#13;
<a id="list6-14"/>&#13;
<pre><code><var>&lt;instructions for condition&gt;</var>&#13;
c = <var>&lt;result of condition&gt;</var>&#13;
JumpIfZero(c, e2_label)&#13;
<var>&lt;instructions to calculate e1&gt;</var>&#13;
v1 = <var>&lt;result of e1&gt;</var>&#13;
result = v1&#13;
Jump(end)&#13;
Label(e2_label)&#13;
<var>&lt;instructions to calculate e2&gt;</var>&#13;
v2 = <var>&lt;result of e2&gt;</var>&#13;
result = v2&#13;
Label(end)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-14: The TACKY for a conditional expression</samp></p>&#13;
<p class="TX">This looks almost exactly like the TACKY in <a href="chapter6.xhtml#list6-13">Listing 6-13</a>. The only difference is that we end each clause by copying the result into the temporary <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> variable.</p>&#13;
<p class="TX">As usual, all the labels and temporary variable names you generate while handling <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements and conditional expressions should be unique. Once your TACKY generation stage is working, you’ll be able to compile this chapter’s test cases.</p>&#13;
<aside class="box" aria-label="box-102"><p class="BoxTitle" id="box-102"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_128" aria-label="128"/><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">You’re now ready to test out your whole compiler. To compile and execute this chapter’s test cases, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 6</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h1-56"/><samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: Labeled Statements and goto</samp></h3>&#13;
<p class="TNI">Now that you have some practice adding new kinds of statements, you have the option to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>, the statement everyone loves to hate. You’ll also need to add support for labeled statements so that <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> has somewhere to go to. You can implement these two statements without changing anything after the TACKY generation stage; however, you’ll need to detect a few new error cases, like using the same label for two labeled statements in the same function. I recommend writing a new semantic analysis pass to catch these errors, rather than trying to catch them in the variable resolution stage.</p>&#13;
<p class="TX">To test out this feature, run the test script with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--goto</samp> flag:</p>&#13;
<pre><code>$ <b>./test_compiler </b><var><b>/path/to/your_compiler</b></var><b> --chapter 6 --goto</b></code></pre>&#13;
<p class="TX">If you’ve implemented the extra credit features in the previous chapters as well, you can test all of them at once by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp> flag instead.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h1-57"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">You’ve just implemented your first control structures! All your work in the early chapters is starting to pay off. The basic TACKY instructions you added to support <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> let you easily implement the more complex features in this chapter. You also built on the parsing techniques you learned earlier, extending your precedence climbing code to handle ternary operators. But the sorts of <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements you can compile are still very limited; you can’t declare variables or execute longer blocks of code in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement body. In the next chapter, you’ll remove those limitations by adding support for compound statements. The most exciting changes will be in the semantic analysis stage, where you’ll learn how to deal with nested scopes.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>