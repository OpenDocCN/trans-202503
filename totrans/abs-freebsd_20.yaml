- en: '**20'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**20'
- en: SMALL SYSTEM SERVICES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 小型系统服务**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Even a server with a very narrowly defined role, such as a dedicated web server,
    needs a variety of small “helper” services to handle basic administrative issues.
    In this chapter, we’ll discuss some of those services, such as time synchronization,
    sending mail, DHCP services, scheduling tasks, and so on. We’ll start by securing
    your remote connections to your FreeBSD server with SSH.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是角色定义非常狭窄的服务器，例如专用的 web 服务器，也需要多种小型“辅助”服务来处理基本的管理问题。在本章中，我们将讨论其中一些服务，例如时间同步、发送邮件、DHCP
    服务、任务调度等等。我们将从使用 SSH 加固远程连接到 FreeBSD 服务器开始。
- en: '**Secure Shell**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安全外壳**'
- en: One of Unix’s great strengths is its ease of remote administration. Whether
    the server is in front of you or in a remote, barricaded laboratory in a subterranean,
    maximum-security installation surrounded by vicious guard dogs mentored by a megalomaniacal
    weasel named Ivan, if you have network access to the machine, you can control
    it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 的一个伟大优势是它的远程管理的便捷性。无论服务器是在你面前，还是位于一个远程的、被围栏隔离的实验室，或者在一个地下的、最高安全级别的设施中，周围环绕着由一个名叫
    Ivan 的自大鼬鼠训练的凶猛守卫犬，只要你能访问网络，就可以控制它。
- en: 'For many years, telnet(1) was the standard way to access a remote server. As
    a remote administration protocol, however, telnet has one crushing problem: everything
    sent over most versions of telnet is unencrypted. Anyone with a packet sniffer,
    attached anywhere along your connection, can steal your username, your password,
    and any information you view in your telnet session. When you use telnet, the
    best password-selection scheme in the world can’t protect your username and password.
    Intruders place illicit packet sniffers anywhere they can; I’ve seen them on small
    local networks and global enterprise networks, in law firms handling sensitive
    government work, on home PCs, and on internet backbones. The only defense against
    a packet sniffer is to handle your authentication credentials and data in such
    a way that a packet sniffer can’t make sense of them. That’s where SSH, or secure
    shell, comes in.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，telnet(1) 一直是访问远程服务器的标准方式。然而，作为远程管理协议，telnet 有一个致命的缺陷：大多数版本的 telnet 发送的数据是未加密的。任何在你的连接路途中放置数据包嗅探器的人，都可以窃取你的用户名、密码和你在
    telnet 会话中查看的任何信息。当你使用 telnet 时，世界上最好的密码选择方案也无法保护你的用户名和密码。入侵者可以将非法的数据包嗅探器放置在任何他们能接触到的地方；我见过它们出现在小型局域网、全球企业网络、处理敏感政府工作的律师事务所、家庭电脑以及互联网骨干网络中。对抗数据包嗅探器的唯一防御手段是以一种嗅探器无法理解的方式处理你的认证凭据和数据。这就是
    SSH（安全外壳）的作用所在。
- en: SSH behaves much like telnet in that it provides a highly configurable terminal
    window on a remote host. But unlike telnet, SSH encrypts everything you send across
    the network. SSH ensures not only that your passwords can’t be sniffed but also
    that the commands you enter and their output are encrypted. While telnet does
    have a few minor advantages over SSH in that it requires less CPU time and is
    simpler to configure, SSH’s security advantages utterly outweigh them. SSH also
    has many features that telnet doesn’t have, such as the ability to tunnel arbitrary
    protocols through the encrypted session. SSH runs on every modern variant of Unix
    and even on Microsoft Windows.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 的行为与 telnet 非常相似，因为它提供了一个高度可配置的终端窗口用于远程主机。但是与 telnet 不同，SSH 会加密你通过网络发送的所有内容。SSH
    不仅确保你的密码不会被嗅探，还确保你输入的命令及其输出被加密。虽然 telnet 在某些方面对比 SSH 具有一些小的优势，例如需要更少的 CPU 时间和配置更简单，但
    SSH 在安全性上的优势完全压倒了这些小优点。SSH 还具有 telnet 所不具备的许多功能，例如通过加密会话隧道传输任意协议。SSH 可以在所有现代的
    Unix 变种上运行，甚至在微软的 Windows 上也能运行。
- en: SSH encrypts and authenticates remote connections via public-key cryptography.
    The SSH daemon offers the server’s public key to clients and keeps the private
    key to itself. The client and server use the cryptographic key to negotiate a
    cryptographically secure channel between them. Since both public and private keys
    are necessary to complete this transaction, your data is secure; even if someone
    captures your SSH traffic, they can see only encrypted garbage.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 通过公钥加密技术加密和认证远程连接。SSH 守护进程提供服务器的公钥给客户端，并将私钥保留给自己。客户端和服务器使用加密密钥协商一个加密安全通道。由于公钥和私钥都在此交易中起作用，因此你的数据是安全的；即使有人捕获了你的
    SSH 流量，他们也只能看到加密的垃圾数据。
- en: To use SSH, you must run an SSH server on your FreeBSD machine and an SSH client
    on your workstation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 SSH，必须在 FreeBSD 机器上运行 SSH 服务器，并在工作站上运行 SSH 客户端。
- en: '***The SSH Server: sshd(8)***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SSH 服务器：sshd(8)***'
- en: 'The sshd(8) daemon listens for SSH requests coming in from the network on TCP
    port 22\. To enable sshd at boot, add the following line to */etc/rc.conf*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: sshd(8) 守护进程监听来自网络的 SSH 请求，端口为 TCP 22。要在启动时启用 sshd，请将以下行添加到 */etc/rc.conf*：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once this is set, you can use the */etc/rc.d/sshd* script or `service sshd`
    subcommands to start and stop SSH. Stopping the SSH daemon doesn’t terminate SSH
    sessions that are already in use; it only prevents the daemon from accepting new
    connections.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，你可以使用 */etc/rc.d/sshd* 脚本或 `service sshd` 子命令来启动和停止 SSH。停止 SSH 守护进程不会终止已经在使用的
    SSH 会话；它只会阻止守护进程接受新的连接。
- en: Unlike unencrypted protocols we look at, sshd is difficult to test by hand.
    One thing you can do is confirm that sshd is running by using nc(1) to connect
    to the SSH TCP port.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们查看的未加密协议不同，sshd 很难手动测试。你可以做的一件事是通过使用 nc(1) 连接到 SSH TCP 端口来确认 sshd 是否正在运行。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We connect to port 22, and get an SSH banner back. We can see that the daemon
    listening on this port calls itself SSH version 2, implemented in OpenSSH 7.2,
    on FreeBSD, version 20160310\. You can get all this information from a simple
    nc(1) connection, but it’s the last free information sshd offers. Unless you’re
    capable of encrypting packets by hand, on the fly, this is about as far as you
    can go. Press CTRL-C to leave nc(1) and return to the command prompt.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们连接到端口 22，并收到一个 SSH 横幅信息。我们可以看到监听该端口的守护进程将自己称为 SSH 版本 2，基于 OpenSSH 7.2 实现，运行在
    FreeBSD 上，版本为 20160310。你可以通过一个简单的 nc(1) 连接获取这些信息，但这也是 sshd 提供的最后一条免费信息。除非你能够手动加密数据包，否则这就是你能做到的极限了。按
    CTRL-C 离开 nc(1)，返回命令提示符。
- en: '***SSH Keys and Fingerprints***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SSH 密钥和指纹***'
- en: 'The first time you start sshd(8), the program realizes that it has no encryption
    keys and automatically creates them. The initializing sshd process creates three
    pairs of keys: an RSA key, an ECDSA key, and an ED25519 key.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次启动 sshd(8) 时，程序会意识到它没有加密密钥，并自动创建它们。初始化的 sshd 进程会创建三对密钥：一个 RSA 密钥，一个 ECDSA
    密钥和一个 ED25519 密钥。
- en: The key files ending in *.pub* contain the public keys for each type of key.
    These are the keys that sshd hands to connecting clients. This gives the connecting
    user the ability to verify that the server he’s connecting to is really the server
    he thinks it is. (Intruders have tricked users into logging into bogus machines
    in order to capture their usernames and passwords.) Take a look at one of these
    public-key files; it’s pretty long. Even when a user is offered the chance to
    confirm that the server is offering the correct key, it’s so long that even the
    most paranoid users won’t bother to verify every single character.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以 *.pub* 结尾的密钥文件包含每种类型的公钥。这些是 sshd 提供给连接客户端的密钥。这使得连接的用户能够验证他连接的服务器是否真的是他认为的那台服务器。（入侵者曾通过诱使用户登录虚假的机器来窃取他们的用户名和密码。）看看其中一个公钥文件；它非常长。即使用户被提供确认服务器提供的密钥是否正确的机会，由于密钥长度过长，即使是最警觉的用户也不会逐一验证每个字符。
- en: Fortunately, SSH allows you to generate a *key fingerprint*, which is a much
    shorter representation of a key. You can’t encrypt traffic or negotiate connections
    with the fingerprint, but the chances of two unrelated keys having the same fingerprint
    are negligible. To generate a fingerprint for a public key, enter the command
    `ssh-keygen -lf` keyfile.pub.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，SSH 允许你生成一个 *密钥指纹*，这是密钥的一个简短表示。你不能用指纹加密流量或协商连接，但两个不相关的密钥具有相同指纹的机会可以忽略不计。要为公钥生成指纹，输入命令
    `ssh-keygen -lf` keyfile.pub。
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first number, `2048`, shows the number of bits in the key. 2048 is standard
    for an RSA key in 2018, but as computing power increases, I expect this number
    to increase. The string starting with `tEcB` and ending with `wwE` is the fingerprint
    of the public key. While it’s long, it’s much shorter and much more readable than
    the actual key. Copy this key fingerprint from the original server to a place
    where you can access it from your client machines. If a human needs to verify
    the fingerprint, try a web page or a paper list. If your SSH clients support SSHFP
    records and your DNS zones support DNSSEC, you can use DNS instead. Use this key
    to confirm your server’s identity the first time you connect, or use one of the
    other key distribution methods.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数字`2048`表示密钥的位数。2048是2018年RSA密钥的标准，但随着计算能力的提高，我预计这个数字会增加。以`tEcB`开头，以`wwE`结尾的字符串是公钥的指纹。虽然它很长，但比实际的密钥短得多，也更易读。将这个密钥指纹从原始服务器复制到你可以从客户端机器访问的地方。如果需要人工验证指纹，可以尝试使用网页或纸质列表。如果你的SSH客户端支持SSHFP记录，并且你的DNS区域支持DNSSEC，可以改为使用DNS。在第一次连接时，使用此密钥确认你的服务器身份，或者使用其他密钥分发方法之一。
- en: '***Configuring the SSH Daemon***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置SSH守护进程***'
- en: While sshd comes with a perfectly usable configuration, you might want to tweak
    the settings once you learn all the features sshd(8) offers. The configuration
    file */etc/ssh/sshd_config* lists all the default settings, commented out with
    a hash mark (`#`). If you want to change the value for a setting, uncomment the
    entry and change its value.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管sshd自带的配置文件已经可以正常使用，但一旦你了解了sshd(8)提供的所有功能，你可能会想调整设置。配置文件*/etc/ssh/sshd_config*列出了所有默认设置，并用井号（`#`）注释掉。如果你想更改某个设置的值，只需取消注释并修改其值。
- en: We won’t discuss all the available sshd options; that would take a rather large
    book of its own. Moreover, OpenSSH advances quickly enough to make that book obsolete
    before it hits the shelves. Instead, we’ll focus on some of the more common desirable
    configuration changes people make.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会讨论所有可用的sshd选项；那样会需要一本相当大的书。此外，OpenSSH的更新速度非常快，以至于那本书在出版之前就会过时。相反，我们将重点讨论一些人们常做的、更常见的配置更改。
- en: After changing the SSH daemon’s configuration, restart the daemon with `/etc/rc.d/sshd
    restart` or `service sshd restart`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更改SSH守护进程的配置后，使用`/etc/rc.d/sshd restart`或`service sshd restart`重启守护进程。
- en: '**VersionAddendum FreeBSD-20170902**'
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**VersionAddendum FreeBSD-20170902**'
- en: The `VersionAddendum` appears in the server name when you connect to sshd’s
    TCP port. Some people recommend changing this to disguise the operating system
    version. Identifying a computer’s operating system is simple enough, however,
    by using fingerprinting techniques on packets exchanged with the host, so this
    isn’t generally worth the time. (On the other hand, if changing `VersionAddendum`
    to `DrunkenBadgerSoftware` amuses you, proceed.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`VersionAddendum`会出现在你连接到sshd的TCP端口时的服务器名称中。有人建议更改它以掩盖操作系统版本。然而，通过使用指纹识别技术分析与主机交换的数据包，识别计算机的操作系统是非常简单的，因此通常不值得花时间做这件事。（另一方面，如果将`VersionAddendum`更改为`DrunkenBadgerSoftware`让你觉得好玩，那就继续吧。）'
- en: '**Port 22**'
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Port 22**'
- en: 'sshd(8) defaults to listening to TCP port 22\. If you want, you can change
    this to a nonstandard port. If you want sshd to listen to multiple ports (for
    example, port 443 in addition to port 22), you can include multiple `Port` entries
    on separate lines:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: sshd(8)默认监听TCP端口22。如果你愿意，可以将其更改为非标准端口。如果你希望sshd监听多个端口（例如，除了端口22外，还监听端口443），可以在不同的行上包含多个`Port`条目：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Changing the port isn’t useful as a security measure. It can be useful to reduce
    log chatter. I freely admit to having a small SSH server that listens on a variety
    of popular TCP ports specifically to bypass useless network security devices.
    But it doesn’t make SSH any more *secure*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 更改端口并不作为一种安全措施有用。它可能有助于减少日志的杂音。我坦白承认，我有一个小型SSH服务器，监听多个流行的TCP端口，专门用来绕过无用的网络安全设备。但这并不会使SSH变得更加*安全*。
- en: '**ListenAddress 0.0.0.0**'
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**ListenAddress 0.0.0.0**'
- en: 'sshd defaults to listening for incoming requests on all IP addresses on the
    machine. If you need to restrict the range of addresses to listen on (for example,
    on a jail server), you can specify it here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: sshd默认监听机器上的所有IP地址的传入请求。如果你需要限制监听的地址范围（例如，在一个监禁服务器上），可以在此处指定：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you want sshd to listen on multiple addresses, use multiple `ListenAddress`
    lines.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望sshd监听多个地址，可以使用多个`ListenAddress`行。
- en: '**SyslogFacility AUTH and LogLevel INFO**'
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**SyslogFacility AUTH 和 LogLevel INFO**'
- en: These two settings control how sshd(8) logs connection information. See [Chapter
    21](ch21.xhtml#ch21) for more information on logging.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个设置控制 sshd(8) 如何记录连接信息。有关日志记录的更多信息，请参见 [第 21 章](ch21.xhtml#ch21)。
- en: '**LoginGraceTime 2m**'
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**LoginGraceTime 2m**'
- en: This controls how long a user has to log in after getting connected. If an incoming
    user connects but doesn’t successfully log in within this time window, sshd drops
    the connection.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该选项控制用户在连接后必须多长时间内完成登录。如果有用户连接但未在此时间窗口内成功登录，sshd 会断开连接。
- en: '**PermitRootLogin no**'
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**PermitRootLogin no**'
- en: Do not let people log into your server as root. Instead, they should SSH in
    as a regular user and become root with su(1). Allowing direct root logins eliminates
    any hope you have of identifying who misconfigured your system and allows intruders
    to cover their tracks much more easily.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让人们直接以 root 用户身份登录到你的服务器。相反，他们应该以普通用户身份通过 SSH 登录，并通过 su(1) 切换为 root 用户。允许直接的
    root 登录会让你失去识别是谁错误配置了你的系统的机会，并且让入侵者更容易掩盖他们的痕迹。
- en: '**MaxAuthTries 6**'
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**MaxAuthTries 6**'
- en: This is the number of times a user may attempt to enter a password during a
    single connection. After this number of unsuccessful attempts to log in, the user
    is disconnected.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用户在单次连接过程中可以尝试输入密码的次数。超过这个次数后，用户将被断开连接。
- en: '**AllowTcpForwarding yes**'
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**AllowTcpForwarding yes**'
- en: SSH allows users to forward arbitrary TCP/IP ports to a remote system. If your
    users have shell access, they can install their own port forwarders, so there’s
    little reason to disable this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 允许用户将任意的 TCP/IP 端口转发到远程系统。如果用户有 shell 访问权限，他们可以安装自己的端口转发器，因此没有理由禁用这个功能。
- en: '**X11Forwarding yes**'
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**X11Forwarding yes**'
- en: Unix-like operating systems use the X11 (or X) protocol to display graphical
    programs. In X, the display is separated from the physical machine. You can run,
    say, a web browser on one machine and display the results on another.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 类 Unix 操作系统使用 X11（或 X）协议来显示图形化程序。在 X 中，显示与物理机器是分开的。你可以在一台机器上运行，比如说一个网页浏览器，并将结果显示在另一台机器上。
- en: As X has had a checkered security history, many admins reflexively disable X
    forwarding. Denying X forwarding over SSH doesn’t disable X forwarding in general,
    however. Most users, if denied SSH-based X forwarding, just forward X over unencrypted
    TCP/IP using either X’s built-in network awareness or a third-party forwarder,
    which in most circumstances is far worse than allowing X over SSH. If your sshd
    server has the X libraries and client programs installed, a user can forward X
    one way or another; it’s best to let SSH handle the forwarding for you. If you
    don’t have the X software installed, then `X11Forwarding` has no effect.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 X 在安全性方面有过波折，许多管理员下意识地禁用 X 转发。然而，禁用 SSH 的 X 转发并不意味着完全禁用 X 转发。大多数用户如果无法通过
    SSH 转发 X，就会使用 X 自带的网络功能或第三方转发工具，在未加密的 TCP/IP 上转发 X，这通常比允许通过 SSH 转发 X 更糟。如果你的 sshd
    服务器已安装 X 库和客户端程序，用户可以通过某种方式转发 X；最好让 SSH 来处理转发。如果没有安装 X 软件，那么 `X11Forwarding` 将无效。
- en: '**Banner /some/path**'
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Banner /some/path**'
- en: The banner is a message that’s displayed before authentication occurs. The most
    common use for this option is to display legal warnings. The default is not to
    use a banner.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 横幅是认证发生前显示的消息。这个选项最常用的场景是显示法律警告。默认情况下不使用横幅。
- en: '**Subsystem sftp /usr/libexec/sftp-server**'
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Subsystem sftp /usr/libexec/sftp-server**'
- en: SSH allows you to securely copy files from one system to another with scp(1).
    While scp works well, it’s not very user-friendly. The sftp server provides an
    FTP-like interface to file transfer, reducing the amount of time you must spend
    on user education but still maintaining solid security.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 允许你通过 scp(1) 安全地将文件从一台系统复制到另一台系统。尽管 scp 工作得很好，但它的用户友好性差。sftp 服务器提供了类似 FTP
    的文件传输接口，减少了你在用户教育上的时间，同时仍保持了坚实的安全性。
- en: '***Managing SSH User Access***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***管理 SSH 用户访问***'
- en: By default, anyone with a legitimate shell can log into the server. Using the
    configuration variables `AllowGroups`, `DenyGroups`, `AllowUsers`, and `DenyUsers`,
    sshd(8) lets you define particular users and groups that may or may not access
    your machine.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，任何拥有合法 shell 的用户都可以登录到服务器。通过使用配置变量 `AllowGroups`、`DenyGroups`、`AllowUsers`
    和 `DenyUsers`，sshd(8) 允许你定义哪些用户和组可以或不可以访问你的机器。
- en: When you explicitly list users who may SSH into a machine, any user who isn’t
    listed can’t SSH in.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你明确列出可以通过 SSH 登录机器的用户时，任何未列出的用户都无法通过 SSH 登录。
- en: 'For example, the `AllowGroups` option lets you restrict SSH access to users
    in specified groups defined in */etc/group* (see [Chapter 9](ch09.xhtml#ch09)).
    If this option is set and a user isn’t in any of the allowed groups, he can’t
    log in. Separate multiple groups with spaces:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`AllowGroups` 选项允许你限制只有在指定组中的用户才能访问 SSH，这些组在 */etc/group* 中定义（见 [第9章](ch09.xhtml#ch09)）。如果设置了此选项，并且用户不属于任何允许的组，他将无法登录。多个组之间用空格分隔：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you don’t want to give a whole group SSH access, you can list individual
    users with `AllowUsers`. By using `AllowUsers`, you disallow SSH access for everyone
    except the listed users.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想给整个组提供 SSH 访问权限，可以使用 `AllowUsers` 列出单个用户。通过使用 `AllowUsers`，你禁止了除了列出的用户之外的所有人访问
    SSH。
- en: The `DenyGroups` list is the opposite of `AllowGroups`. Users in the specified
    system groups can’t log in. The listed group must be their primary group, meaning
    it must be listed in */etc/master.passwd* and not just */etc/group*. This limitation
    makes `DenyGroups` less useful than it seems at first; you can’t define a general
    group called *nossh* and just add users to it, unless you make it their primary
    group as well. Explicitly listing allowed groups is a much more useful policy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`DenyGroups` 列表与 `AllowGroups` 相反。指定的系统组中的用户无法登录。列出的组必须是他们的主组，这意味着它必须列在 */etc/master.passwd*
    中，而不仅仅是 */etc/group* 中。这个限制使得 `DenyGroups` 没有看起来那么有用；除非你将它设置为用户的主组，否则无法定义一个叫做
    *nossh* 的通用组并将用户添加进去。显式列出允许的组是一个更有用的策略。'
- en: Finally, the `DenyUsers` variable lists users who may not log in. You can use
    this to explicitly forbid certain users who are in a group that is otherwise allowed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`DenyUsers` 变量列出了不允许登录的用户。你可以使用它显式禁止那些虽然属于允许组但被列为禁止的特定用户。
- en: 'These four different settings make it possible for a user to be in multiple
    groups simultaneously. For example, one user might be in a group listed in `AllowGroups`
    and a group listed in `DenyGroups`. What then? The SSH daemon checks these values
    in the order: `DenyUsers`, `AllowUsers`, `DenyGroups`, and `AllowGroups`. The
    first rule that matches wins. For example, suppose Bert is a member of the wheel
    group. Here’s a snippet of *sshd_config* :'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个不同的设置使得一个用户可以同时属于多个组。例如，一个用户可能同时属于 `AllowGroups` 列出的组和 `DenyGroups` 列出的组。那么该怎么办呢？SSH
    守护进程按以下顺序检查这些值：`DenyUsers`、`AllowUsers`、`DenyGroups` 和 `AllowGroups`。第一个匹配的规则生效。例如，假设
    Bert 是 wheel 组的成员。这里是 *sshd_config* 的一部分：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Bert can’t SSH into this machine because `DenyUsers` is checked before `AllowGroups`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Bert 无法通过 SSH 登录这台机器，因为 `DenyUsers` 在 `AllowGroups` 之前进行检查。
- en: '***SSH Clients***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SSH 客户端***'
- en: Of course, FreeBSD comes with the SSH client, as do most Unix-like operating
    systems. If possible, use the included SSH client—it’s part of OpenSSH, developed
    by a subset of the OpenBSD team, and it’s not only the most popular implementation
    but also the best. If you’ve been sentenced to run a Microsoft operating system,
    I recommend PuTTY, which is free for commercial or noncommercial purposes and
    has excellent terminal emulation. Microsoft is integrating a fork of OpenSSH into
    Windows, but it’s still in beta as I write this.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，FreeBSD 自带 SSH 客户端，像大多数类 Unix 操作系统一样。如果可能，使用包含的 SSH 客户端——它是 OpenSSH 的一部分，由
    OpenBSD 团队的一个子集开发，不仅是最流行的实现，而且是最好的。如果你被迫使用微软的操作系统，我推荐 PuTTY，它对商业或非商业用途都是免费的，并且有出色的终端仿真。微软正在将
    OpenSSH 的一个分支集成到 Windows 中，但在我写这篇文章时，它仍处于测试版。
- en: This is a FreeBSD book, so we’ll focus on FreeBSD’s OpenSSH client. You can
    configure the client in a variety of ways, but the most common configuration choices
    available simply disable the functions offered by the server. If you’re really
    interested in tweaking your client’s behavior, read ssh_config(5).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本 FreeBSD 的书，所以我们将重点介绍 FreeBSD 的 OpenSSH 客户端。你可以通过多种方式配置客户端，但最常见的配置选项仅仅是禁用服务器提供的功能。如果你真的有兴趣调整客户端的行为，阅读
    ssh_config(5)。
- en: 'To connect to another host with SSH, type `ssh` hostname. In response, you’ll
    see something like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到另一台主机进行 SSH 登录，输入 `ssh` 主机名。你将看到类似这样的响应：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Your client immediately retrieves the public key from the host you’re connecting
    to and checks its own internal list of SSH keys for a matching key for that host.
    If the key offered by the server matches the key the client has in its list, the
    client assumes you’re talking to the correct host. If the client doesn’t have
    the host key in its list of known hosts, it presents the key fingerprint for your
    approval.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您的客户端会立即从您连接的主机获取公钥，并检查其内部 SSH 密钥列表中是否存在与该主机匹配的密钥。如果服务器提供的密钥与客户端列表中的密钥匹配，客户端就会认为您连接到了正确的主机。如果客户端在其已知主机列表中没有该主机的密钥，它将呈现密钥指纹供您确认。
- en: The fingerprint presented by the SSH client should be identical to the fingerprint
    you generated on your server. If the fingerprint isn’t identical, you’re connecting
    to the wrong host and you need to immediately disconnect. If it matches, accept
    the key and continue. Once you accept the fingerprint, the key is saved under
    your home directory in *.ssh/known_hosts*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 客户端提供的指纹应与您在服务器上生成的指纹完全相同。如果指纹不相同，则说明您连接到了错误的主机，需要立即断开连接。如果指纹匹配，则接受该密钥并继续。一旦您接受了指纹，密钥将保存在您的主目录下的*.ssh/known_hosts*中。
- en: If you’re building a new server on your local network for your private use,
    perhaps you don’t have to manually compare the key fingerprints. You should still
    copy the key fingerprint, however, since you’ll eventually want to connect from
    a remote location and will need to verify the key. If many people will connect
    to a server, it’s generally okay to put the fingerprint on a web page. You must
    decide how much security you need. I strongly encourage you to err on the side
    of caution.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在为个人使用在本地网络上搭建新服务器，也许您不需要手动比较密钥指纹。不过，您仍然应该复制密钥指纹，因为您最终会希望从远程位置连接，并且需要验证密钥。如果许多人将连接到该服务器，通常可以将指纹放在网页上。您必须决定需要多少安全性。我强烈建议您在安全性上采取谨慎态度。
- en: Accept the host key, and you’ll be allowed to log into the server. While using
    a private key with a passphrase is preferable to using passwords, a password with
    SSH is still better than telnet.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接受主机密钥，您将被允许登录服务器。虽然使用带有密码短语的私钥比使用密码更好，但在 SSH 中使用密码仍然比使用 telnet 更安全。
- en: '**Copying Files over SSH**'
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通过 SSH 复制文件**'
- en: 'The SSH client is fine for command line access, but what about moving files
    from one system to another? SSH includes two tools for moving files across the
    network: scp(1) and sftp(1).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 客户端适用于命令行访问，但如果要将文件从一个系统移动到另一个系统呢？SSH 包含两个用于通过网络移动文件的工具：scp(1) 和 sftp(1)。
- en: 'scp(1) is “secure copy” and is ideal for moving individual files. scp takes
    two arguments: first, the file’s current location; then, the desired location.
    The desired location is specified as *<username>@<hostname>:<filename>*. Suppose
    I want to copy the file *bookbackup.tgz* from my local system to the remote server
    *mwl.io*, giving the remote copy a different name. I’d run:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: scp(1) 是“安全复制”，非常适合移动单个文件。scp 需要两个参数：第一个是文件的当前所在位置；第二个是目标位置。目标位置的格式为 *<用户名>@<主机名>:<文件名>*。假设我想将本地系统上的文件
    *bookbackup.tgz* 复制到远程服务器 *mwl.io*，并为远程副本指定不同的名称。我会运行：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you want to give the new copy the same name, you can leave off the filename
    in the second argument:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想让新复制的文件保持相同的名称，可以省略第二个参数中的文件名：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'scp(1) also lets you copy files from a remote system to your local system:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: scp(1) 还允许您将文件从远程系统复制到本地系统：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you don’t want to change the filename on the local system, you can use a
    single dot as the destination name:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想更改本地系统上的文件名，您可以使用一个点作为目标名称：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, if your username on the remote system is the same as your local username,
    you can delete the username and the `@` sign. For example, to back up my work,
    I just use:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您在远程系统上的用户名与本地用户名相同，您可以删除用户名和 `@` 符号。例如，要备份我的工作，我只需使用：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: While this looks complicated, it’s quite useful for quickly moving individual
    files around the network.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来有些复杂，但它对于快速在网络上移动单个文件非常有用。
- en: 'If you like interactive systems or if you don’t know the precise name of the
    file you want to grab from a remote server, sftp(1) is your friend. sftp(1) takes
    a single argument, the username and server name, using scp’s syntax for a remote
    server:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢交互式系统，或者如果您不确定想从远程服务器抓取的文件的准确名称，那么 sftp(1) 是您的朋友。sftp(1) 需要一个参数，使用 scp
    的语法来指定远程服务器的用户名和服务器名：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The sftp(1) client looks much like a standard command line FTP client; it supports
    the usual FTP commands, such as `ls` (list), `cd` (change directory), `get` (download
    a file), and `put` (upload a file). One important difference is that sftp(1) doesn’t
    require a choice between ASCII and binary transfers; it just transfers the file
    as is.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: sftp(1)客户端看起来非常像标准的命令行FTP客户端；它支持常见的FTP命令，如`ls`（列出）、`cd`（更改目录）、`get`（下载文件）和`put`（上传文件）。一个重要的区别是，sftp(1)不需要在ASCII和二进制传输之间做出选择；它只是按原样传输文件。
- en: With SSH, scp, and sftp, you can completely eliminate cleartext passwords from
    your network.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSH、scp和sftp，你可以完全消除网络中的明文密码。
- en: '**OPENSSH PASSWORDS AND KEYS**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**OPENSSH 密码和密钥**'
- en: To truly secure your system, use key-based SSH authentication. Creating keys
    isn’t hard, but deploying them in a way that best suits your environment is more
    complicated than I can fit in here. Eliminating SSH passwords is the single greatest
    security improvement you can make in your network.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正保护你的系统，请使用基于密钥的SSH认证。创建密钥并不困难，但以最适合你的环境的方式部署它们，比我在这里能讲的要复杂得多。消除SSH密码是你可以在网络中做出的最重要的安全改进。
- en: While SSH is the most common sysadmin tool, we’ve just brushed its surface.
    Time you spend mastering SSH will pay itself back several fold. You can find several
    good tutorials online and a few decent books, including my own *SSH Mastery* (Tilted
    Windmill Press, 2018).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SSH是最常见的系统管理员工具，但我们只触及了它的表面。你花时间精通SSH，将会得到多倍的回报。你可以在网上找到一些很好的教程和几本不错的书籍，包括我自己的*SSH
    Mastery*（Tilted Windmill Press，2018）。
- en: '**Email**'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**电子邮件**'
- en: 'Running an email server has become vastly more complicated in the last few
    years. Coping with the spam, viruses, and random crud that arrives on a mail server
    requires a specialized skill set, and the amount of that crud balloons every year.
    Think carefully before you deploy a mail server. Every host needs some sort of
    mail client, however. FreeBSD includes two software suites that can be used for
    managing local mail and forwarding mail to the mail server: Sendmail and the Dragonfly
    Mail Agent.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，运行邮件服务器变得异常复杂。应对垃圾邮件、病毒以及随机的无用信息需要专门的技能，并且这些垃圾信息的数量每年都在激增。在你部署邮件服务器之前请仔细考虑。然而，每个主机都需要某种形式的邮件客户端。FreeBSD
    包含两个可以用于管理本地邮件并将邮件转发到邮件服务器的软件套件：Sendmail 和 Dragonfly Mail Agent。
- en: '*Sendmail* is the great-granddaddy of mail programs. It can be a server, a
    client, a filter, and an arbitrary mail spindler. If you want to exchange mail
    with sites so isolated that they communicate once a day over UUCP over a dialup
    line, and also exchange mail with the latest commercial mail servers, Sendmail
    is a solid choice. For most of us, though, the Swiss Army Car Crusher of Email
    is overkill.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*Sendmail* 是邮件程序的鼻祖。它可以是服务器、客户端、过滤器，也可以是任意的邮件处理程序。如果你想与那些隔绝在外、仅通过拨号线路的UUCP每天交换一次邮件的网站进行通信，同时也与最新的商业邮件服务器交换邮件，Sendmail是一个可靠的选择。然而对于大多数人来说，这个被称为电子邮件的瑞士军刀过于复杂。'
- en: The *Dragonfly Mail Agent (DMA)* comes from Dragonfly BSD. It’s a very minimal
    mail client that can deliver mail on the local host or forward it to a mail server.
    It’s exactly what your average host needs to forward daily status mails to the
    minion tasked with reading them, to send reports from your application to the
    application administrator, and to forward all those annoying reports your WordPress
    security plugin wants you to read.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dragonfly Mail Agent (DMA)* 来自 Dragonfly BSD。它是一个非常简洁的邮件客户端，可以在本地主机上发送邮件，或将邮件转发到邮件服务器。它正是你需要的那种工具，用来将每日状态邮件转发给负责读取这些邮件的下属，将你的应用程序的报告发送给应用管理员，并转发所有那些让你
    WordPress 安全插件希望你阅读的烦人报告。'
- en: We’ll spend some time with DMA. Before we can go there, though, let’s talk about
    how FreeBSD copes with the world’s multiplicity of mail servers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将花一些时间了解DMA。然而，在此之前，让我们先谈谈FreeBSD如何应对全球各种各样的邮件服务器。
- en: '***mailwrapper(8)***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***mailwrapper(8)***'
- en: For decades, Sendmail was the only mail server available for Unix-like systems.
    As such, huge amounts of software expects every server to have */usr/sbin/sendmail*
    and expects it to behave exactly like Sendmail. What makes matters worse, Sendmail
    behaves differently when called by different names. The program mailq(1) is a
    hard link to sendmail(8), but as it has a different name, it behaves differently.
    So do newaliases(1), send-mail(8), hoststat(8), and purgestat(8).^([1](footnote.xhtml#ch20fn1))
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，Sendmail 是类 Unix 系统中唯一可用的邮件服务器。因此，大量软件都期望每个服务器都有 */usr/sbin/sendmail*，并且期望它的行为与
    Sendmail 完全相同。更糟糕的是，当通过不同名称调用时，Sendmail 的行为会有所不同。程序 mailq(1) 是 sendmail(8) 的硬链接，但由于它的名称不同，因此行为也不同。newaliases(1)、send-mail(8)、hoststat(8)
    和 purgestat(8) 也是如此。^([1](footnote.xhtml#ch20fn1))
- en: As clients expect to find Sendmail, any replacement mail server must precisely
    emulate Sendmail, down to this multiname behavior. Using a different mail server
    isn’t as easy as erasing the Sendmail binaries and replacing them with something
    else. But people try.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于客户端期望找到 Sendmail，任何替代的邮件服务器必须精确模拟 Sendmail，包括这种多重名称行为。使用不同的邮件服务器并不像删除 Sendmail
    二进制文件并替换为其他东西那么简单。但人们总是试图这么做。
- en: As a result, sysadmins exploring unfamiliar Unix systems might have no idea
    what */usr/sbin/sendmail* really is! If someone previously installed several different
    mail servers in an effort to find something less ghastly than Sendmail, you’ll
    have to resort to detective work and dogged persistence to identify your so-called
    sendmail(8).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，探索不熟悉的 Unix 系统的系统管理员可能完全不知道 */usr/sbin/sendmail* 真实是什么！如果有人曾经安装过多个不同的邮件服务器，试图找到比
    Sendmail 更易用的替代品，那么你就得通过侦探工作和坚持不懈的努力来识别所谓的 sendmail(8)。
- en: FreeBSD does an end-run around all this confusion by using a separate mailwrapper(8)
    program. The mail wrapper directs requests for Sendmail to the preferred mail
    server, installed elsewhere.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 通过使用一个独立的 mailwrapper(8) 程序绕过了所有这些混乱。邮件包装器将对 Sendmail 的请求引导到首选的邮件服务器，邮件服务器安装在其他地方。
- en: 'Configure mailwrapper(8) in */etc/mail/mailer.conf*. This file contains a list
    of program names, along with the paths to the actual programs to be called. Here’s
    the default *mailer.conf* directing everything to good old sendmail(8):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 */etc/mail/mailer.conf* 中配置 mailwrapper(8)。这个文件包含了程序名称的列表，以及实际程序的路径。以下是默认的
    *mailer.conf*，它将所有请求指向老旧的 sendmail(8)：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each of these six “programs” in the left column is a name that other programs
    might use for Sendmail. The right column gives the path to the program that should
    be called instead. Here, we see that Sendmail is installed as */usr/libexec/sendmail/sendmail*.
    If you use an alternative mailer, you must edit *mailer.conf* to point to the
    proper path to the mailer programs. Most alternative mailers use separate programs
    for each of these functions because the cost of disk space has plunged since Sendmail’s
    birth. When you install an alternative mailer from a package or port, the post-install
    message usually provides instructions on exactly how to update *mailer.conf* for
    your installation. Follow those instructions if you want the new mail server to
    work. If you install a different mail server without using a package, you need
    to edit *mailer.conf* yourself.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 左栏中的这六个“程序”名称是其他程序可能用来指代 Sendmail 的名称。右栏给出了应该调用的程序路径。在这里，我们看到 Sendmail 安装在 */usr/libexec/sendmail/sendmail*
    路径下。如果你使用的是替代邮件服务器，必须编辑 *mailer.conf* 来指向正确的邮件程序路径。大多数替代邮件服务器为每个功能使用单独的程序，因为自
    Sendmail 出现以来，磁盘空间的成本已经大幅下降。当你从软件包或端口安装替代邮件服务器时，安装后的消息通常会提供如何更新 *mailer.conf*
    的具体说明。如果你希望新邮件服务器正常工作，请按照这些说明操作。如果你没有使用软件包而是安装了不同的邮件服务器，你需要自己编辑 *mailer.conf*。
- en: '***The Dragonfly Mail Agent***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Dragonfly Mail Agent***'
- en: The Dragonfly Mail Agent (DMA) can deliver mail locally and send mail to another
    server. It can’t receive mail over the network. Where most mail servers bind to
    TCP port 25 on the local host, dma(8) does not. It delivers mail only for programs
    that can call */usr/sbin/sendmail* or one of its counterparts.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Dragonfly Mail Agent (DMA) 可以本地投递邮件并将邮件发送到另一台服务器，但它无法通过网络接收邮件。大多数邮件服务器会绑定到本地主机的
    TCP 端口 25，而 dma(8) 则不会。它只为那些可以调用 */usr/sbin/sendmail* 或其对等程序的程序投递邮件。
- en: Before activating DMA, configure it in */etc/dma/dma.conf*. This file contains
    variables you can uncomment and set to a specific value. While DMA has several
    configurable settings, you should leave most of them at the default.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用 DMA 之前，需在 */etc/dma/dma.conf* 中进行配置。这个文件包含了一些变量，你可以取消注释并设置为特定值。虽然 DMA 有多个可配置的设置，但你应该保持大多数设置为默认值。
- en: '**Smart Host**'
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**智能主机**'
- en: A smart host is the actual mail server, the host this client should relay mail
    through. Use the hostname or IP address.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 智能主机是实际的邮件服务器，是客户端应该通过其转发邮件的主机。使用主机名或IP地址。
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**TCP Port**'
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**TCP端口**'
- en: 'If your mail administrator is a madman that runs the smart host’s email on
    a nonstandard port, or if you’re trying to evade your ISP’s block port 25 outbound,
    set the TCP port here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的邮件管理员是个疯狂的人，给智能主机的邮件设置了非标准端口，或者你正在尝试绕过ISP封锁的25端口，可以在此设置TCP端口：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you don’t set a smart host but do set a port, you’ll break mail delivery.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有设置智能主机但设置了端口，邮件投递将会中断。
- en: '**False Hostname and Usernames**'
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**虚假主机名和用户名**'
- en: You might want your server to claim to be a different host when it sends mail.
    Maybe your cloud provider has given this system a hostname composed of random
    digits and numbers, but you want it to send mail as *www.example.com*. Use the
    MAILNAME to set a fake hostname.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望服务器在发送邮件时自称为另一个主机。也许你的云服务提供商给这个系统分配了一个由随机数字和字母组成的主机名，但你希望它以*www.example.com*发送邮件。使用MAILNAME来设置一个假主机名。
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you give MAILNAME the full path to a file, dma(8) will use the first line
    of that file as the hostname.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为MAILNAME提供了文件的完整路径，dma(8)将使用该文件的第一行作为主机名。
- en: Some mail servers very strictly inspect relayed mail and reject inadequately
    forged messages. For those hosts, you’ll need to use the MASQUERADE option. Masquerading
    gives you a couple different options for changing messages. If you use an entire
    email address, all mail sent via dma(8) is rewritten so it comes from that address.
    If you use a username with an @ sign, such as `bert@`, all email appears to be
    coming from that user at the host. A hostname on its own leaves the sending username
    untouched but changes the hostname.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一些邮件服务器会非常严格地检查转发的邮件，并拒绝不充分伪造的消息。对于这些主机，你需要使用MASQUERADE选项。伪装提供了几种更改邮件的方式。如果你使用完整的电子邮件地址，所有通过dma(8)发送的邮件都会被重写，使其看起来来自该地址。如果你使用带有@符号的用户名，例如`bert@`，所有邮件看起来都来自该主机上的该用户。仅使用主机名将保留发送者的用户名不变，但会更改主机名。
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Any messages sent from this host appear to be from Bert. Any replies will go
    to him. All is as it should be.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个主机发送的任何邮件看起来都是Bert发送的，所有的回复也会发给他。一切都按预期进行。
- en: '**Disable Local Delivery**'
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**禁用本地投递**'
- en: Some hosts should never receive mail. No account on the host should ever get
    mail, not even from other local accounts. Totally disable local mail delivery
    by uncommenting the NULLCLIENT option.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一些主机不应该接收邮件。该主机上的任何账户都不应接收邮件，甚至是来自其他本地账户的邮件。通过取消注释NULLCLIENT选项完全禁用本地邮件投递。
- en: '**Secure Transport**'
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**安全传输**'
- en: Over the decades, the email protocol has had a whole bunch of different security
    measures wedged into it. Your mail server might use any or all of them. Speak
    to your email administrator about what your smart host requires and supports.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几十年里，电子邮件协议加入了许多不同的安全措施。你的邮件服务器可能会使用其中的某些或全部措施。请与邮件管理员沟通，了解你的智能主机需要和支持哪些安全措施。
- en: Enable TLS (or SSL, if your mail server is notably awful) by uncommenting the
    SECURETRANSFER option. You don’t need to set this to a value; its mere presence
    turns on TLS. If your mail server needs STARTTLS, also uncomment that option.
    If you want to send mail even if TLS negotiation fails, also uncomment OPPORTUNISTIC_TLS.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过取消注释SECURETRANSFER选项启用TLS（如果你的邮件服务器特别糟糕，也可以使用SSL）。你不需要设置该值，单纯的存在即可启用TLS。如果你的邮件服务器需要STARTTLS，也需要取消注释该选项。如果你希望即使TLS协商失败也能发送邮件，还需要取消注释OPPORTUNISTIC_TLS。
- en: These three options all require the previous options. You can use SECURETRANSFER
    on its own, STARTTLS and SECURETRANSFER together, or all three. STARTTLS and SECURETRANSFER
    without their preceding options don’t work.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个选项都需要前面的选项。你可以单独使用SECURETRANSFER，或者同时使用STARTTLS和SECURETRANSFER，或者全部使用。没有前导选项的STARTTLS和SECURETRANSFER无法正常工作。
- en: If you need a local TLS certificate, set it with the CERTFILE option.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要本地TLS证书，可以通过CERTFILE选项进行设置。
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These options should let you connect to just about any smart host.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项应该让你能够连接到几乎任何智能主机。
- en: '**Username and Password**'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**用户名和密码**'
- en: 'Some smart hosts require clients authenticate with a username and password.
    Put authentication credentials in the file */etc/dma/auth.conf*. Each entry needs
    the format:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一些智能主机要求客户端使用用户名和密码进行身份验证。将身份验证凭据放入文件*/etc/dma/auth.conf*中。每个条目需要以下格式：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Suppose my smart host is *mail.mwl.io*. The username is *www1*, and the password
    is *BatteryHorseStapleCorrect*. My *auth.conf* would contain:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我的智能主机是*mail.mwl.io*。用户名是*www1*，密码是*BatteryHorseStapleCorrect*。我的*auth.conf*文件将包含：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: DMA will use this to log into your host.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: DMA将使用这个来登录到你的主机。
- en: If you want to use a username and password over an unencrypted connection, you
    must set the INSECURE variable. Sending unencrypted authentication information
    over the network is a bad idea, but many mail servers are full of bad ideas.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想通过未加密的连接使用用户名和密码，你必须设置 INSECURE 变量。通过网络发送未加密的身份验证信息是个不好的主意，但许多邮件服务器充满了不好的主意。
- en: '**Enabling DMA**'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**启用 DMA**'
- en: Using DMA requires shutting down any existing Sendmail processes and enabling
    dma(8) in *mailer.conf*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DMA 需要关闭任何现有的 Sendmail 进程，并在 *mailer.conf* 中启用 dma(8)。
- en: Sendmail runs as a daemon even when it only handles local delivery. Shut down
    Sendmail with service(8) or the */etc/rc.d/sendmail* script.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 Sendmail 仅处理本地投递，它仍作为一个守护进程运行。使用 service(8) 或 */etc/rc.d/sendmail* 脚本关闭 Sendmail。
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Make sure it never starts again.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 确保它永远不会再次启动。
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, go to */etc/mail/mailer.conf* and point every mail program to dma(8).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往 */etc/mail/mailer.conf* 并将每个邮件程序指向 dma(8)。
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: DMA has no persistent daemon, so it doesn’t need a startup script.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: DMA 没有持久的守护进程，因此不需要启动脚本。
- en: Congratulations, you now have a small, simple, effective client mail agent.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，现在你拥有一个小型、简单且有效的客户端邮件代理。
- en: '***The Aliases File and DMA***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***别名文件和DMA***'
- en: The */etc/mail/aliases* file contains redirections for email sent to specific
    accounts or usernames. Even mail clients and mail agents like DMA use the aliases
    file. Adding an entry to the aliases file is a good way to locally redirect email.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/mail/aliases* 文件包含发送到特定账户或用户名的电子邮件的重定向。即使是像 DMA 这样的邮件客户端和邮件代理也使用别名文件。向别名文件添加条目是本地重定向邮件的好方法。'
- en: While the aliases file has a whole bunch of features, DMA can exercise only
    a few of them. Features like redirecting email to an arbitrary file don’t work.
    We’ll discuss the basic functions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然别名文件具有许多功能，但 DMA 仅能使用其中的一部分。像将邮件重定向到任意文件这样的功能是不可用的。我们将讨论其基本功能。
- en: Open up the aliases file and look around. Each line starts with an alias name
    or address, followed by a colon and a list of real users to send the email to.
    We’ll illustrate how aliases work by example.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 打开别名文件并查看。每一行都以别名名称或地址开始，后面跟着冒号和一个真实用户列表，用于接收邮件。我们将通过示例来说明别名是如何工作的。
- en: '**Forwarding Email from One User to Another**'
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将邮件从一个用户转发到另一个用户**'
- en: Someone should always read email sent to the root account. Rather than having
    that someone log onto every server to read the messages, forward all of root’s
    email to another email address.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 应该总有人读取发送到 root 账户的邮件。与其让某个人登录每一台服务器去读取这些信息，不如将所有 root 的邮件转发到另一个邮件地址。
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: I’ve assigned Bert the job of reading all the mail from all the machines.^([2](footnote.xhtml#ch20fn2))
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将 Bert 指派为读取所有机器上所有邮件的工作。^([2](footnote.xhtml#ch20fn2))
- en: Many email addresses don’t have accounts associated with them. For example,
    the required postmaster address often doesn’t have an account. You can use an
    alias to forward this to a real account.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 许多电子邮件地址没有与之关联的账户。例如，通常要求的 postmaster 地址并没有账户。你可以使用别名将其转发到一个真实账户。
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So, postmaster forwards to root, which forwards to Bert. Bert gets all the email
    for these two addresses.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，postmaster 转发到 root，然后转发到 Bert。Bert 获取这两个地址的所有邮件。
- en: The default aliases file contains a variety of standard addresses for internet
    services, as well as aliases for all of the default FreeBSD service accounts.
    They all go to root by default. By defining a real address as a destination for
    your root email, you’ll automatically get all system administration email.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的别名文件包含各种标准地址，用于互联网服务，以及所有默认 FreeBSD 服务账户的别名。默认情况下，它们都指向 root。通过为 root 邮件定义一个真实地址作为目标，你将自动接收到所有系统管理邮件。
- en: '**Aliased Mailing Lists**'
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**别名邮件列表**'
- en: You can list multiple users to create small mailing lists. This doesn’t scale
    for dynamic lists, but it’s sufficient for quick and dirty lists.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以列出多个用户来创建小型邮件列表。对于动态列表来说，这并不适用，但对于快速和简便的列表来说足够了。
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The moment you find yourself creating an aliased mailing list is the moment
    you need to start considering which mailing list solution you’re going to deploy.
    You’ll need it sooner than you think.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你发现自己正在创建一个别名邮件列表，那就是你需要开始考虑要部署哪个邮件列表解决方案的时候。你会比你想象的更早需要它。
- en: '**Network Time**'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络时间**'
- en: 'If a database starts entering dates three hours behind, or if emails arrive
    dated tomorrow, you’ll hear about it pretty quickly. Time is *important*.^([3](footnote.xhtml#ch20fn3))
    You have two tools to manage system time: tzsetup(8) to control the time zone
    and ntpd(8) to adjust the clock. Start by setting your time zone manually, and
    then use network time protocol.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数据库开始录入比实际时间滞后三小时的日期，或者如果电子邮件的日期显示是明天，你很快就会听到相关反馈。时间是*重要的*。^([3](footnote.xhtml#ch20fn3))
    你有两个工具来管理系统时间：tzsetup(8) 来控制时区，ntpd(8) 来调整时钟。首先手动设置你的时区，然后使用网络时间协议。
- en: '***Setting the Time Zone***'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置时区***'
- en: Time zone is easy to manage with tzsetup(8), a menu-driven program that makes
    the appropriate changes on your system for each time zone. Global organizations
    might use the default of UTC (Universal Time Clock, previously known as Greenwich
    Mean Time, currently known as Coordinated Universal Time, soon to be known by
    Yet Another Name) on their systems, while others use their own local time. Enter
    `tzsetup`, follow the geographic prompts, and choose the appropriate time zone
    for your location. If you know your time zone’s official name, you can set it
    at the command prompt without going through the prompts.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 tzsetup(8) 管理时区非常简单，它是一个菜单驱动的程序，可以为每个时区在系统上做出相应的更改。全球性组织可能在他们的系统上使用 UTC（协调世界时，之前称为格林尼治标准时间，当前称为协调世界时，很快将改名为另一种名称），而其他组织则使用他们自己的本地时间。输入
    `tzsetup`，按照地理提示操作，选择适合你所在位置的时区。如果你知道你时区的官方名称，可以直接在命令行中设置，而无需经过提示。
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The tzsetup(8) program copies the relevant time zone file from */usr/share/zoneinfo*
    to */etc/localtime*. This is a binary file, and you can’t edit with your average
    text editor. If the characteristics of your time zone change—for example, the
    day Daylight Saving Time begins changes—you must upgrade FreeBSD to get the new
    time zone files and then rerun tzsetup(8) to correctly reconfigure time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: tzsetup(8) 程序将相关的时区文件从 */usr/share/zoneinfo* 复制到 */etc/localtime*。这是一个二进制文件，你不能使用普通的文本编辑器进行编辑。如果你的时区特性发生变化——例如夏令时开始的日期改变——你必须升级
    FreeBSD 来获取新的时区文件，然后重新运行 tzsetup(8) 来正确地重新配置时间。
- en: Users can use the `TZ` environment variable to set their personal time zone.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用 `TZ` 环境变量来设置个人时区。
- en: '***Network Time Protocol***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***网络时间协议***'
- en: '*Network time protocol (NTP)* is a method to synchronize time across a network.
    You can make your local computer’s clock match the atomic clock at your government’s
    research lab or the time on your main server. Computers that offer time synchronization
    are called *time servers* and are roughly lumped into two groups: Tier 1 and Tier
    2.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*网络时间协议 (NTP)* 是一种在网络中同步时间的方法。你可以让本地计算机的时钟与政府研究实验室的原子钟或主服务器的时间保持一致。提供时间同步的计算机被称为
    *时间服务器*，大致分为两组：Tier 1 和 Tier 2。'
- en: Tier 1 NTP servers are directly connected to a highly accurate timekeeping device.
    If you really need this sort of accuracy, then what you really need is your own
    atomic clock. A USB radio clock such as that found on an inexpensive GPS might
    look very nice, but USB turns out to be a lousy medium for transferring timing
    data. Go price a dedicated non-USB GPS receiver, and then choose a Tier 1 NTP
    server instead.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Tier 1 NTP 服务器直接连接到高精度的时间保持设备。如果你真的需要这种精度，那么你真正需要的是你自己的原子钟。像在廉价 GPS 上找到的 USB
    无线电钟看起来可能很不错，但 USB 证明不是传输时间数据的理想介质。去查看一个专用的非 USB GPS 接收器的价格，然后选择一个 Tier 1 NTP
    服务器。
- en: Tier 2 NTP servers feed off the Tier 1 NTP servers, providing time service as
    a public service. Their service is accurate to within a fraction of a second and
    is sufficient for almost all non–life sustaining applications. Some digging will
    even lead you to Tier 3 time servers, which feed off of Tier 2 servers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Tier 2 NTP 服务器从 Tier 1 NTP 服务器获取时间，提供作为公共服务的时间服务。它们的服务精度达到毫秒级，对于几乎所有非生命支持应用都足够了。进一步的调查甚至会让你找到
    Tier 3 时间服务器，它们从 Tier 2 服务器获取时间。
- en: The best source of time servers is the list at *[http://www.pool.ntp.org/](http://www.pool.ntp.org/)*.
    This group has collected public NTP servers into round-robin DNS pools, allowing
    easy NTP configuration. These NTP servers are arranged first in a global list,
    then by continent, and then by country. For example, if you’re in Canada, a brief
    search on that site leads you to *0.ca.pool.ntp.org*, *1.ca.pool.ntp.org*, and
    *2.ca.pool.ntp.org*. We’ll use these servers in the following examples, but look
    up the proper servers for your country and use those instead when setting up your
    own time service.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的时间服务器来源是 *[http://www.pool.ntp.org/](http://www.pool.ntp.org/)* 上的列表。这个组织将公共
    NTP 服务器收集成循环 DNS 池，方便进行 NTP 配置。NTP 服务器首先按全球列表排列，然后按大陆排序，再按国家排列。例如，如果你在加拿大，简单搜索该站点会找到
    *0.ca.pool.ntp.org*、*1.ca.pool.ntp.org* 和 *2.ca.pool.ntp.org*。我们在以下示例中将使用这些服务器，但在设置您自己的时间服务时，请查找适合您国家的服务器并使用它们。
- en: '**Configuring ntpd(8)**'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**配置 ntpd(8)**'
- en: 'ntpd(8) checks the system clock against a list of time servers. It takes a
    reasonable average of the times provided by the time servers, discarding any servers
    too far away from the consensus, and gradually adjusts the system time to match
    the average. This gives the most accurate system time possible, without demanding
    too much from any one server, and helps keep errant hardware in check. Configure
    NTP in */etc/ntpd.conf*. Here’s a sample that uses Canadian time servers:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ntpd(8) 会将系统时钟与一组时间服务器进行对比。它取这些时间服务器提供的时间的合理平均值，舍弃任何与共识相差过远的服务器，并逐渐调整系统时间以匹配平均值。这提供了最精确的系统时间，而不会对任何一个服务器要求过多，并帮助保持错误硬件的检查。NTP
    配置文件在 */etc/ntpd.conf* 中。以下是一个使用加拿大时间服务器的示例：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This system checks three time servers for updates. If you list only one server,
    ntpd(8) slaves its clock to that one server and shares any time problems that
    server experiences. Using two time servers guarantees that your system won’t know
    what time it is; remember, NTP takes an average of its time servers but throws
    out any values too far out of range of the others. How can NTP decide whether
    one server is wrong when it has only two values to choose from? Using three time
    servers is optimal; if one server runs amok, ntpd recognizes that the time offered
    by that server doesn’t make sense against the time offered by the other two servers.
    (Think of this as a “tyranny of the majority”; the one guy whose opinion differs
    from the rest doesn’t get any voice at all.)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统检查三个时间服务器的更新时间。如果只列出一个服务器，ntpd(8) 会将其时钟与该服务器同步，并共享该服务器遇到的任何时间问题。使用两个时间服务器会导致系统无法正确判断时间；请记住，NTP
    会取时间服务器的平均值，但会丢弃任何与其他服务器的时间差异过大的值。当只有两个值时，NTP 如何判断一个服务器是否错误？使用三个时间服务器是最优的；如果其中一个服务器出现问题，ntpd
    会发现该服务器提供的时间与另外两个服务器提供的时间不一致。（可以把它看作是“多数人的暴政”；唯一与其他人意见不同的人根本没有发言权。）
- en: '**ntpd(8) at Boot Time**'
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**ntpd(8) 在启动时**'
- en: 'To have ntpd perform a one-time clock synchronization at boot and then continually
    adjust the clock afterward, set the following in */etc/rc.conf*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要让 ntpd 在启动时执行一次性时钟同步，然后持续调整时钟，请在 */etc/rc.conf* 中设置以下内容：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Ntpd will force correct time immediately on boot and then gently keep the clock
    synchronized.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Ntpd 在启动时会立即强制校正时间，然后轻柔地保持时钟同步。
- en: '**Instant Time Correction**'
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**即时时间校正**'
- en: ntpd(8) is great at keeping the system clock accurate over time, but it adjusts
    the local clock only gradually. If your time is off by hours or days (which isn’t
    unlikely at install time or after a long power outage), you probably want to set
    your clock correctly before letting any time-sensitive applications start. ntpd(8)
    includes that functionality as well, with `ntpd -q`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ntpd(8) 非常擅长长期保持系统时钟的准确性，但它只会逐渐调整本地时钟。如果您的时间差错达到小时或天数（例如安装时或长时间断电后发生的情况），您可能希望在启动任何时间敏感的应用程序之前，先正确设置时钟。ntpd(8)
    也包含此功能，可以使用 `ntpd -q` 来实现。
- en: To perform a single brute-force correction of your clock, use `ntpd -q`. This
    connects to your NTP servers, gets the correct time, sets your system clock, and
    exits.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要对时钟执行一次强制校正，请使用`ntpd -q`。这会连接到您的 NTP 服务器，获取正确的时间，设置系统时钟，并退出。
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This system’s time was off by about 77 seconds but is now synchronized with
    the NTP servers.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的时间大约落后了77秒，但现在已与 NTP 服务器同步。
- en: Do not change the clock arbitrarily on a production system. Time-sensitive software,
    such as many database-driven applications, has problems if time suddenly moves
    forward or backward.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在生产系统中随意更改时钟。许多数据库驱动的应用程序等时间敏感型软件，如果时间突然向前或向后移动，会遇到问题。
- en: If you have really good hardware with an excellent oscillator, using `ntpd -q`
    at boot handles all of your time problems. Very few people have that sort of hardware,
    however. Most of us have to make do with commodity hardware with notoriously poor
    clocks. The best way to ensure you have accurate time is to run ntpd(8) to gently
    adjust your clock on an ongoing basis.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有非常好的硬件并且配备了优质的振荡器，使用`ntpd -q`在启动时可以解决所有时间问题。然而，实际上很少有人拥有这种硬件。我们大多数人都得忍受廉价硬件，后者通常有着极差的时钟。确保时间准确的最佳方式是运行ntpd(8)，以持续轻微调整时钟。
- en: '**Redistributing Time**'
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**时间重新分配**'
- en: While ntpd doesn’t use a large amount of network bandwidth, having every server
    on your network query the public NTP servers is a waste of network resources—both
    yours and that of the time-server donors. It can also lead to very slight (subsecond)
    variances in time on your own network.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ntpd不会使用大量网络带宽，但让你网络中的每个服务器查询公共NTP服务器是浪费网络资源——既是你自己的资源，也是时间服务器捐赠者的资源。这还可能导致你自己网络中的时间出现非常微小（亚秒级）的波动。
- en: Reliable time servers aren’t virtual machines. Tier 1 NTP servers are all run
    on real hardware specifically to avoid the clock jittering virtual machines can
    suffer.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠的时间服务器不是虚拟机。Tier 1 NTP服务器都运行在真实硬件上，专门避免虚拟机可能遇到的时钟抖动问题。
- en: I recommend setting up three authoritative time servers for your network. Have
    these servers synchronize their clock with the global NTP pool. Configure each
    server on your network to point to these servers for NTP updates. That way, every
    clock on your network will be perfectly synchronized. You won’t have to trawl
    through NTP logs to try to determine whether a particular server in the global
    time server pool has somehow messed up your system clock. It’s best to enforce
    this policy via firewall rules at your network border; allowing only your time
    server to communicate with outside NTP servers eliminates one common source of
    temporal chaos.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议为你的网络设置三个权威的时间服务器。让这些服务器与全球NTP池同步它们的时钟。配置你网络中的每个服务器指向这些服务器进行NTP更新。这样，你网络中的每个时钟都会完美同步。你无需翻遍NTP日志，试图判断全球时间服务器池中的某个特定服务器是否以某种方式破坏了你的系统时钟。最好通过网络边界的防火墙规则强制执行这一策略；只允许你的时间服务器与外部NTP服务器通信，这样可以消除一个常见的时间混乱源。
- en: '**Name Service Switching**'
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**名称服务切换**'
- en: Any Unix-like system performs innumerable checks of many different name services.
    We’ve already talked about the Domain Name System that maps hostnames to IP addresses
    (see [Chapter 7](ch07.xhtml#ch07)), but there’s also a password entry lookup service,
    a TCP/IP port number and name lookup service, an IP protocol name and number lookup
    service, and so on. You can use */etc/nsswitch.conf* to configure how your FreeBSD
    system makes these queries and what information sources it uses through nsswitch
    (name service switching).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类Unix系统都会进行无数次对不同名称服务的检查。我们已经讨论过将主机名映射到IP地址的域名系统（请参见[第7章](ch07.xhtml#ch07)），但还有密码条目查找服务、TCP/IP端口号和名称查找服务、IP协议名称和编号查找服务等。你可以使用*/etc/nsswitch.conf*来配置你的FreeBSD系统如何进行这些查询以及它通过nsswitch（名称服务切换）使用哪些信息来源。
- en: Each name service has an *nsswitch.conf* entry including the type of the service
    and the information sources it uses. We previously saw an example of name service
    switching in [Chapter 8](ch08.xhtml#ch08). Remember this entry for host lookups?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个名称服务都有一个*nsswitch.conf*条目，包含该服务的类型以及它所使用的信息来源。我们之前在[第8章](ch08.xhtml#ch08)中看到过一个名称服务切换的示例。记得这个主机查找的条目吗？
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This means, “Look for IP addresses in the local files first, and then query
    DNS.” The other information sources work similarly. FreeBSD, like most other Unix-like
    operating systems, supports name service switching for the information sources
    listed in [Table 20-1](ch20.xhtml#ch20tab1).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，“首先在本地文件中查找IP地址，然后查询DNS。”其他信息来源也类似工作。像大多数其他类Unix操作系统一样，FreeBSD支持[表20-1](ch20.xhtml#ch20tab1)中列出的信息来源的名称服务切换。
- en: '**Table 20-1:** Lookups Supporting Name Service Switching'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**表20-1：** 支持名称服务切换的查找'
- en: '| **Lookup** | **Function** |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **查找** | **功能** |'
- en: '| --- | --- |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `groups` | Group membership checks (*/etc/group*) |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `groups` | 用户组成员资格检查（*/etc/group*） |'
- en: '| `hosts` | Hostname and IP checks (DNS and */etc/hosts*) |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `hosts` | 主机名和IP检查（DNS和*/etc/hosts*） |'
- en: '| `networks` | Network entries (*/etc/networks*) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `networks` | 网络条目（*/etc/networks*） |'
- en: '| `passwd` | Password entries (*/etc/passwd*) |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `passwd` | 密码条目（*/etc/passwd*） |'
- en: '| `shells` | Checks for valid shells (*/etc/shells*) |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `shells` | 有效Shell的检查（*/etc/shells*） |'
- en: '| `services` | TCP and UDP services (*/etc/services*) |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `services` | TCP 和 UDP 服务 (*/etc/services*) |'
- en: '| `rpc` | Remote procedure calls (*/etc/rpc)* |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `rpc` | 远程过程调用 (*/etc/rpc*) |'
- en: '| `proto` | TCP/IP network protocols (*/etc/protocols*) |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `proto` | TCP/IP 网络协议 (*/etc/protocols*) |'
- en: Most of these you don’t want to muck with, unless you like breaking system functionality.
    If you have a Kerberos or an NIS domain, for example, you might want to have your
    FreeBSD box attach to them for user and group information—but if you don’t, reconfiguring
    the password lookups would make your system slow at best or entirely stop working
    at worst!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你不希望去修改这些，除非你喜欢破坏系统功能。例如，如果你有一个 Kerberos 或 NIS 域，你可能希望将你的 FreeBSD 机器连接到它们，以获取用户和组信息——但如果没有，重新配置密码查找会让系统运行得很慢，甚至在最坏的情况下完全无法工作！
- en: For each name service, you must specify one or more sources of information.
    Many of these name services are very simple and default to having a single authoritative
    source of information—a file. Others, such as the host’s name service, are more
    complicated and have multiple sources. A few are very complicated simply because
    of the vast array of information available and the many possible ways to get that
    information. As this book doesn’t cover Kerberos, NIS, or any other enterprise-level
    user management systems, we won’t cover changing password, group, and shell information
    sources. If you’re in such an environment, read nsswitch.conf(5) for details.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个名称服务，你必须指定一个或多个信息来源。许多名称服务非常简单，默认只有一个权威信息来源——一个文件。其他服务，如主机的名称服务，则更为复杂，有多个来源。一些服务非常复杂，仅仅是因为可用的信息种类繁多，并且获取这些信息的方式多种多样。由于本书没有涉及
    Kerberos、NIS 或其他企业级用户管理系统，因此我们不会讨论更改密码、组和 shell 信息来源。如果你在这样的环境中，阅读 nsswitch.conf(5)
    获取详细信息。
- en: Most common services have specific valid information sources. *Files* are the
    standard text files containing information for the service. For example, network
    protocols are traditionally stored in */etc/protocols*, network services in */etc/services*,
    and passwords in */etc/passwd* and friends. A source of *dns* means that the information
    is available on a DNS server, as is typical for the hosts service responsible
    for mapping hostnames to IP addresses. The password service often uses *compat*,
    which grants compatibility with */etc/passwd* and NIS but could also use *files*.
    You might add information sources to the system—for example, enabling LDAP authentication
    adds the *ldap* information source.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的服务有特定的有效信息来源。*文件*是包含服务信息的标准文本文件。例如，网络协议通常存储在*/etc/protocols*，网络服务存储在*/etc/services*，密码存储在*/etc/passwd*及其相关文件中。*dns*来源意味着信息可通过
    DNS 服务器获取，这对于负责将主机名映射到 IP 地址的主机服务来说是典型的。密码服务通常使用*compat*，它与*/etc/passwd*和 NIS
    兼容，但也可以使用*files*。你可能会将信息源添加到系统中——例如，启用 LDAP 身份验证会添加*ldap*信息源。
- en: List each desired information source in the order you want them to be tried.
    Our `hosts` entry tells the name service lookup to try the local file first and
    then query the DNS server.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 按照你希望它们被尝试的顺序列出每个所需的信息来源。我们的 `hosts` 条目告诉名称服务查找首先尝试本地文件，然后查询 DNS 服务器。
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you deploy a central authentication scheme like LDAP, you’ll need to add
    an appropriate entry to tell the host to look up passwords and groups in LDAP.
    The important question is, should hosts use their local password file and then
    fall back to LDAP or start with LDAP and fall back to the password file?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你部署了像 LDAP 这样的集中身份验证方案，你需要添加适当的条目，告诉主机从 LDAP 查找密码和组。关键问题是，主机应该先使用本地密码文件，然后再回退到
    LDAP，还是从 LDAP 开始，再回退到密码文件？
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we start with LDAP but fall back to the password file if LDAP isn’t available.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先使用 LDAP，但如果 LDAP 不可用，则回退到密码文件。
- en: '**inetd**'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**inetd**'
- en: The inetd(8) daemon handles incoming network connections for less frequently
    used network services. Most systems don’t have a steady stream of incoming FTP
    requests, so why have the FTP daemon running all the time? Instead, inetd listens
    to the network for incoming FTP requests. When an FTP request arrives, inetd(8)
    starts the FTP server and hands off the request. Other common programs that rely
    on inetd are telnet, tftp, and POP3.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: inetd(8) 守护进程处理不常用网络服务的传入网络连接。大多数系统没有持续不断的 FTP 请求流量，那么为什么要让 FTP 守护进程一直运行呢？相反，inetd
    监听网络上的传入 FTP 请求。当 FTP 请求到达时，inetd(8) 启动 FTP 服务器并交接请求。其他依赖 inetd 的常见程序有 telnet、tftp
    和 POP3。
- en: Inetd also handles functions so small and rarely used that they’re easier to
    implement within inetd, rather than route them through a separate program. This
    includes discard (which dumps any data received into the black hole of */dev/null*),
    chargen (which pours out a stream of characters), and other functions. These days,
    most of these services are not only not required but often considered harmful.
    The chargen service, for example, is mostly useful for denial-of-service attacks.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Inetd 还处理一些非常小且不常用的功能，这些功能实现起来比通过独立程序更容易。包括 discard（将接收到的任何数据丢弃到黑洞 */dev/null*）、chargen（输出一串字符）以及其他功能。现在，这些服务大多不仅不再需要，反而被认为是有害的。例如，chargen
    服务主要用于拒绝服务攻击。
- en: '**INETD SECURITY**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**INETD 安全性**'
- en: 'Some sysadmins think of inetd as a single service with a monolithic security
    profile. Others say that inetd has a bad security history. Neither is exactly
    true. The inetd server itself is fairly secure, but it absorbs a certain amount
    of blame for the programs it forwards requests to. Some services that inetd can
    support, such as ftp, telnet, and so on, are inherently insecure, while others
    have had a troubled childhood and act out as a result (for example, popper). Treat
    inetd as you would any other network server program: do not run inetd unless you
    need it, and then confirm that it offers only trusted and secure programs!'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一些系统管理员将 inetd 看作是一个具有单一安全配置文件的服务，另一些则认为 inetd 有不好的安全历史。两者都不完全正确。inetd 服务器本身是相当安全的，但它要为转发请求到的程序承担一定的责任。一些
    inetd 支持的服务，比如 ftp、telnet 等，本身就不安全，而其他一些则有过不良的历史并因此出现问题（例如 popper）。像对待任何其他网络服务器程序一样对待
    inetd：除非需要，否则不要运行 inetd，并确认它仅提供受信任且安全的程序！
- en: '***/etc/inetd.conf***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***/etc/inetd.conf***'
- en: Take a look at */etc/inetd.conf*. Most daemons have separate IPv4 and IPv6 configurations,
    but if you’re not running IPv6, you can ignore the IPv6 entries. Let’s look at
    one entry, the FTP server configuration.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下 */etc/inetd.conf*。大多数守护进程有独立的 IPv4 和 IPv6 配置，但如果你没有运行 IPv6，可以忽略 IPv6 条目。我们来看一个条目——FTP
    服务器的配置。
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first field is the service name ➊, which must match a name in */etc/services*.
    inetd performs a service name lookup to identify which TCP port it should listen
    to. If you want to change the TCP/IP port your FTP server runs on, change the
    port for FTP in */etc/services*. (You could also change the first field to match
    the service that runs on the desired port, but I find that this makes the entry
    slightly confusing.)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字段是服务名称 ➊，必须与 */etc/services* 中的名称匹配。inetd 会执行服务名称查找，以确定它应该监听哪个 TCP 端口。如果你想改变
    FTP 服务器运行的 TCP/IP 端口，可以在 */etc/services* 中更改 FTP 的端口。（你也可以将第一个字段改为匹配所需端口上运行的服务，但我发现这样会让条目稍微有些混乱。）
- en: The socket type ➋ dictates what sort of connection this is. All TCP connections
    are of type `stream`, while UDP connections are of type `dgram`. While you might
    find other possible values, if you’re considering using them, either you’re reading
    the documentation for a piece of software that tells you what to use, or you’re
    just wrong.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字类型 ➋ 决定了这是什么类型的连接。所有的 TCP 连接都是 `stream` 类型，而 UDP 连接是 `dgram` 类型。虽然你可能会发现其他可能的值，但如果你正在考虑使用它们，要么是你在阅读一个告诉你应该使用什么的文档，要么就是你理解错了。
- en: The protocol ➌ is the layer 4 network protocol, either `tcp` (IPv4 TCP), `udp`
    (IPv4 UDP), `tcp6` (IPv6 TCP), or `udp6` (IPv6 UDP). If your server accepts both
    IPv4 and IPv6 connections, use the entries `tcp46` or `udp46`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 协议 ➌ 是第4层网络协议，可以是 `tcp`（IPv4 TCP）、`udp`（IPv4 UDP）、`tcp6`（IPv6 TCP）或 `udp6`（IPv6
    UDP）。如果你的服务器同时接受IPv4和IPv6连接，可以使用 `tcp46` 或 `udp46`。
- en: 'The next field indicates whether inetd should wait for the server program to
    close the connection or just start the program and go away ➍. As a general rule,
    TCP daemons use `nowait` while UDP daemons need `wait`. (There are exceptions
    to this, but they’re rare.) inetd(8) starts a new instance of the network daemon
    for each incoming request. If a service uses `nowait`, you can control the maximum
    number of connections inetd accepts per second by adding a slash and a number
    directly after `nowait`, like this: `nowait/5`. One way intruders (usually script
    kiddies) try to knock servers off the internet is by opening more requests for
    a service than the server can handle. By rate-limiting incoming connections, you
    can stop this. On the other hand, this means that your intruder can stop other
    people from using the service at all. Choose your poison carefully!'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个字段指示inetd是否应该等待服务器程序关闭连接，还是只启动程序然后退出 ➍。一般来说，TCP守护进程使用`nowait`，而UDP守护进程需要`wait`。（虽然有一些例外，但它们很少见。）inetd(8)会为每个传入请求启动一个新的网络守护进程。如果服务使用`nowait`，你可以通过在`nowait`后面直接添加斜杠和数字（例如：`nowait/5`）来控制inetd每秒接受的最大连接数。一种入侵者（通常是脚本小子）尝试将服务器从互联网上击倒的方式是为某个服务打开比服务器能够处理的更多的请求。通过限制传入连接的速率，你可以阻止这种情况。另一方面，这意味着你的入侵者可以完全阻止其他人使用该服务。小心选择你的“毒药”！
- en: We then have the user ➎ that the server daemon runs as. The FTP server ftpd(8)
    runs as root, as it must service requests for many system users, but other servers
    run as dedicated users.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是服务器守护进程运行的用户 ➎。FTP服务器ftpd(8)以root身份运行，因为它必须为多个系统用户提供服务，但其他服务器则以专用用户身份运行。
- en: The sixth field is the full path to the server program inetd runs when a connection
    request arrives ➏. Services integrated with inetd(8) appear as internal.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 第六个字段是连接请求到达时，inetd运行的服务器程序的完整路径 ➏。与inetd(8)集成的服务作为内部服务出现。
- en: The last field gives the command to start the external program, including any
    desired command line arguments ➐.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个字段给出了启动外部程序的命令，包括任何所需的命令行参数 ➐。
- en: '***Configuring inetd Servers***'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置inetd服务器***'
- en: While */etc/inetd.conf* seems to use a lot of information, adding a program
    is actually pretty simple. The easiest way to learn about inetd(8) is to implement
    a simple service with it. For example, let’s implement a Quote of the Day (qotd)
    service. When you connect to the qotd port, the server sends back a random quote
    and disconnects. FreeBSD includes a random quote generator, fortune(1), in its
    games collection. This random quote generator is all we need to implement an inetd-based
    network program. We must specify a port number, a network protocol, a user, a
    path, and a command line.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*/etc/inetd.conf*似乎使用了很多信息，但添加一个程序实际上是相当简单的。了解inetd(8)的最简单方法是实现一个简单的服务。例如，我们来实现一个每日名言（qotd）服务。当你连接到qotd端口时，服务器会返回一个随机名言并断开连接。FreeBSD在其游戏集合中包含了一个随机名言生成器fortune(1)。这个随机名言生成器就是我们实现基于inetd的网络程序所需要的全部内容。我们必须指定端口号、网络协议、用户、路径和命令行。
- en: '**port number**'
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**端口号**'
- en: The */etc/services* file lists qotd on port 17.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/services*文件将qotd列在17端口。'
- en: '**network protocol**'
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**网络协议**'
- en: The qotd service requires that you connect to a network port and get something
    back, so it needs to run over TCP. Remember, UDP is connectionless—a reply isn’t
    required. We must specify `tcp` in our inetd configuration, which means that we
    must specify `nowait` in the fourth field.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: qotd服务要求你连接到网络端口并获取回应，因此它需要通过TCP运行。记住，UDP是无连接的——不需要回复。我们必须在inetd配置中指定`tcp`，这意味着我们必须在第四个字段中指定`nowait`。
- en: '**user**'
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**用户**'
- en: Best practice says to create an unprivileged user to run the qotd service, as
    discussed in [Chapter 19](ch19.xhtml#ch19). For this example, we’ll just use the
    general unprivileged user nobody, but if you were implementing this in production,
    you’d want to create an unprivileged user qotd.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践建议创建一个没有特权的用户来运行qotd服务，如[第19章](ch19.xhtml#ch19)中讨论的那样。对于这个例子，我们将使用一般的无特权用户nobody，但如果你在生产环境中实现这一点，你应该创建一个无特权用户qotd。
- en: '**path**'
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**路径**'
- en: Find fortune at */usr/bin/fortune*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在*/usr/bin/fortune*中找到fortune。
- en: '**Running the Command**'
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**运行命令**'
- en: fortune(6) doesn’t require any command line arguments, but you can add them
    if you like.^([4](footnote.xhtml#ch20fn4)) On FreeBSD 11, believers in Murphy’s
    Law can use `fortune murphy`, while *Star Trek* fans can get quotes with `fortune
    startrek`. (The latter correctly includes only the One True *Star Trek*, not any
    of the wannabe followups.) Those interested in education could use `fortune freebsd-tips`.
    FreeBSD 12 removes many of the fortune databases, sadly.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: fortune(6) 不需要任何命令行参数，但如果你愿意，可以添加它们。^([4](footnote.xhtml#ch20fn4)) 在 FreeBSD
    11 上，信奉墨菲定律的人可以使用 `fortune murphy`，而 *星际迷航* 的粉丝可以通过 `fortune startrek` 获取引用。（后者正确地只包括唯一的
    *星际迷航*，而不包括任何跟风的续集。）那些对教育感兴趣的人可以使用 `fortune freebsd-tips`。遗憾的是，FreeBSD 12 删除了许多
    fortune 数据库。
- en: '**Sample inetd.conf Configuration**'
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**inetd.conf 配置示例**'
- en: 'Putting this all together, the entry for qotd in */etc/inetd.conf* looks like
    this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些内容结合起来，qotd 在 */etc/inetd.conf* 中的条目如下所示：
- en: '[PRE36]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You might think this example trivial, but providing other services out of inetd(8)
    is no more difficult.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能觉得这个例子很简单，但通过 inetd(8) 提供其他服务并不更加困难。
- en: '***Starting inetd(8)***'
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启动 inetd(8)***'
- en: 'First, enable inetd(8) at boot by adding the following entry to */etc/rc.conf*:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过将以下条目添加到 */etc/rc.conf* 中来在启动时启用 inetd(8)：
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With this set, start inetd by hand with `/etc/rc.d/inetd start`. Now that inetd
    is running, telnet to port 17 to test our new service:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完毕后，手动启动 inetd，命令为 `/etc/rc.d/inetd start`。现在 inetd 已经在运行，使用 telnet 连接到 17
    端口来测试我们的新服务：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It works! We have the usual TCP/IP connection information ➊ and our random fortune
    ➋. (As an added bonus, you also know why I don’t write for television.)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 它工作了！我们得到了常见的 TCP/IP 连接信息 ➊ 和我们的随机格言 ➋。（额外的奖励是，你也知道为什么我不为电视写作。）
- en: '***Changing inetd’s Behavior***'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更改 inetd 的行为***'
- en: inetd behaves differently depending on the flags you set for it. The default
    flags turn on TCP wrappers, as configured in */etc/hosts.allow* (see [Chapter
    19](ch19.xhtml#ch19)). [Table 20-2](ch20.xhtml#ch20tab2) lists some of the useful
    flags.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: inetd 根据你设置的标志表现不同。默认标志启用 TCP 包装器，按照 */etc/hosts.allow* 中的配置（见 [第19章](ch19.xhtml#ch19)）。[表
    20-2](ch20.xhtml#ch20tab2) 列出了一些有用的标志。
- en: '**Table 20-2:** inetd(8) Flags'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 20-2:** inetd(8) 标志'
- en: '| **Flag** | **Description** |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| **标志** | **描述** |'
- en: '| --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-l` | Log every successful connection. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `-l` | 记录每个成功的连接。 |'
- en: '| `-c` | Set the maximum number of connections per second that can be made
    to any service. By default, there’s no limit. Note that “unlimited” isn’t the
    same as “infinite”—your hardware only handles so many connections. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `-c` | 设置每秒钟最多可以连接到任何服务的次数。默认情况下没有限制。注意，“无限制”并不等同于“无限”——你的硬件只处理这么多连接。 |'
- en: '| `-C` | Set the number of times one IP address can connect to a single service
    in one minute. This connection rate is unlimited by default, but using this can
    be useful against people trying to monopolize your bandwidth or resources. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `-C` | 设置一个 IP 地址每分钟最多可以连接某个服务的次数。默认情况下，连接速率是无限制的，但使用此选项可以防止有人试图独占你的带宽或资源。
    |'
- en: '| `-R` | Set the maximum number of times any one service can be started in
    one minute. The default is 256\. If you use `-R 0`, you allow an unlimited number
    of connections to any one service. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `-R` | 设置任何服务每分钟最大可启动的次数。默认值是 256。如果使用 `-R 0`，则允许对任何服务进行无限次连接。 |'
- en: '| `-a` | Set the IP address inetd(8) attaches to. By default, inetd listens
    on all IP addresses attached to the system. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `-a` | 设置 inetd(8) 绑定的 IP 地址。默认情况下，inetd 会监听系统上所有附加的 IP 地址。 |'
- en: '| `-w` | Use TCP wrappers for programs started by inetd(8), as per *hosts.allow*
    (see [Chapter 19](ch19.xhtml#ch19)). |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `-w` | 按照 *hosts.allow* 中的配置，使用 TCP 包装器来启动 inetd(8) 启动的程序（见 [第19章](ch19.xhtml#ch19)）。
    |'
- en: '| `-W` | Use TCP wrappers for services integrated with inetd(8), as per *hosts.allow*
    (see [Chapter 19](ch19.xhtml#ch19)). |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `-W` | 按照 *hosts.allow* 中的配置，使用 TCP 包装器为与 inetd(8) 集成的服务提供保护（见 [第19章](ch19.xhtml#ch19)）。
    |'
- en: 'As an extreme example, if you want to use TCP wrappers, allow only two connections
    per second from any single host, allow an unlimited number of service invocations
    per minute, and listen only on the IP address 203.0.113.2, then you’d set the
    following in */etc/rc.conf*:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个极端的例子，如果你想使用 TCP 包装器，每秒钟只允许单一主机连接两次，允许每分钟无限次调用服务，并且仅监听 IP 地址 203.0.113.2，那么你需要在
    */etc/rc.conf* 中设置如下内容：
- en: '[PRE39]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With inetd(8), almost anything can be a network service.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 inetd(8)，几乎任何东西都可以是网络服务。
- en: '**DHCP**'
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**DHCP**'
- en: '*Dynamic Host Configuration Protocol (DHCP)* is the standard method for handing
    out IP addresses to client computers. While DHCP services aren’t integrated with
    FreeBSD out of the box, they’re commonly required to implement such services as
    diskless workstations. We’ll cover the basics of DHCP configuration here so you
    can set up your own network.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态主机配置协议（DHCP）* 是为客户端计算机分配 IP 地址的标准方法。虽然 FreeBSD 默认没有集成 DHCP 服务，但它通常是实现如无盘工作站等服务所必需的。我们将在这里介绍
    DHCP 配置的基本内容，帮助你设置自己的网络。'
- en: These days, every firewall and embedded device has a DHCP server. Why would
    you need a separate DHCP server? Most of the embedded DHCP servers lack functions
    needed to run diskless clients, such as network-booted servers and VoIP phones.
    When they do support such functions, those DHCP servers are often difficult to
    manage. Services are meant to run on actual servers. We’ll cover enough of DHCP
    to let you configure your own network clients, including diskless hosts.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，几乎每个防火墙和嵌入式设备都有一个 DHCP 服务器。那么为什么还需要单独的 DHCP 服务器呢？大多数嵌入式 DHCP 服务器缺少运行无盘客户端所需的功能，如网络启动的服务器和
    VoIP 电话。当它们支持这些功能时，往往很难管理。这些服务应该运行在真正的服务器上。我们将在此介绍足够的 DHCP 内容，帮助你配置自己的网络客户端，包括无盘主机。
- en: FreeBSD packages include several DHCP servers. The two I like are OpenBSD’s
    dhcpd and ISC DHCP server. The *ISC DHCP server* is an industry standard and supports
    every feature you could possibly want. For small deployments, I recommend OpenBSD’s
    *dhcpd*. The OpenBSD folks took ISC DHCP, ripped out all the rarely used features,
    and made a smaller, simpler server. The configuration file is still one-way compatible;
    you can run an OpenBSD dhcpd configuration on ISC’s DHCP server without trouble.
    (The reverse is also true if you’re not using any of the features OpenBSD ripped
    out of the server.) If you want to run diskless FreeBSD clients, or if you need
    LDAP integration, switching to the more complex ISC server is fairly straightforward.
    You can install only one of the two servers.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 包含了几种 DHCP 服务器。我比较喜欢 OpenBSD 的 dhcpd 和 ISC 的 DHCP 服务器。*ISC DHCP 服务器*
    是行业标准，支持你可能需要的每一个功能。对于小规模部署，我推荐使用 OpenBSD 的 *dhcpd*。OpenBSD 的开发者在 ISC DHCP 的基础上，去掉了所有那些不常用的功能，制作了一个更小、更简单的服务器。配置文件仍然是单向兼容的；你可以在
    ISC 的 DHCP 服务器上运行 OpenBSD 的 dhcpd 配置文件，不会有任何问题。（反之亦然，如果你没有使用 OpenBSD 去掉的那些功能。）如果你想运行无盘的
    FreeBSD 客户端，或者需要 LDAP 集成，切换到更复杂的 ISC 服务器也是相对简单的。你只能安装这两者中的一个服务器。
- en: The package for either server includes dhcpd(8), the configuration file */usr/local/etc/dhcpd.conf*,
    and extensive man pages.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这两款服务器的包都包含 dhcpd(8)，配置文件 */usr/local/etc/dhcpd.conf*，以及详尽的 man 页。
- en: '**ROGUE DHCP SERVERS**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**流氓 DHCP 服务器**'
- en: Each network should have one and only one set of authoritative DHCP information.
    If you set up your own DHCP server on a network that already has one, such as
    in your company office, you’ll probably break a whole bunch of clients and trigger
    a whole bunch of phone calls to the network team. Setting up a “rogue” DHCP server
    is a great way to have the network team ignore all of your help requests from
    now until forever.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网络应当只有一组权威的 DHCP 信息。如果你在已经有 DHCP 服务器的网络上设置自己的 DHCP 服务器，比如在公司办公室，可能会导致大量客户端无法正常工作，并引发一堆电话打到网络团队那里。设置一个“流氓”DHCP
    服务器是让网络团队从此忽视你所有求助请求的绝佳方式。
- en: '***How DHCP Works***'
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***DHCP 工作原理***'
- en: DHCP can be terribly complicated in a large network where we are relaying DHCP
    requests between offices, but it’s rather simple on a local Ethernet. Each DHCP
    client sends a broadcast across the local Ethernet asking for someone—anyone—to
    provide network configuration information. If your DHCP server is on that local
    Ethernet, it answers directly. If your DHCP server is on another network segment,
    the router for that network segment needs to know which IP address to forward
    the DHCP request to. The DHCP server then loans configuration information to the
    client and tracks which clients have been assigned which IP addresses. A configuration
    issued to a client is called a *lease*. Like the lease you pay on a home or auto,
    DHCP leases expire and must be renewed occasionally.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个需要在各个办公室之间转发 DHCP 请求的大型网络中，DHCP 可能会变得非常复杂，但在本地以太网上，它相对简单。每个 DHCP 客户端会向本地以太网广播请求，寻找任何人来提供网络配置信息。如果你的
    DHCP 服务器在本地以太网上，它会直接做出响应。如果你的 DHCP 服务器在另一个网络段，那个网络段的路由器需要知道该将 DHCP 请求转发到哪个 IP
    地址。DHCP 服务器会将配置文件借给客户端，并追踪哪些客户端被分配了哪些 IP 地址。分配给客户端的配置文件叫做 *租约*。就像你为房屋或汽车支付的租金一样，DHCP
    租约会到期，并且需要定期续租。
- en: The client can request certain features—for example, Microsoft clients ask for
    the IP address of the WINS server, while diskless systems ask where to find a
    kernel. You can set all these options as necessary.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以请求某些功能——例如，Microsoft客户端请求WINS服务器的IP地址，而无盘系统请求查找内核的位置。你可以根据需要设置这些选项。
- en: Each client is uniquely identified by the MAC address of the network card used
    to connect to the network. ISC dhcpd tracks MAC and IP addresses, as well as leases,
    in the file */var/db/dhcpd.leases*. In this file, you can identify which hosts
    have which IP addresses. If a host disappears from the network for a time and
    returns, dhcpd(8) reissues the same IP to that client if that IP is still available.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 每个客户端通过用于连接网络的网卡的MAC地址唯一标识。ISC dhcpd在文件*/var/db/dhcpd.leases*中跟踪MAC地址和IP地址，以及租约。在这个文件中，你可以识别出哪些主机拥有哪些IP地址。如果一个主机暂时离开网络并重新连接，dhcpd(8)会重新分配相同的IP地址给该客户端，如果该IP地址仍然可用。
- en: '***Configuring dhcpd(8)***'
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置 dhcpd(8)***'
- en: The file */usr/local/etc/dhcpd.conf* contains all the configuration for dhcpd.
    While ISC dhcpd(8) can and does fill entire books on its own, we’ll focus on the
    functions needed for a basic small office as well as those used in the examples
    later in this book. The default *dhcpd.conf* is well commented and includes still
    more examples, while dhcpd.conf(5) is painfully exhaustive. We’re going to assume
    that you’re running a single DHCP server on your network, and that your server
    should answer all requests for DHCP services. (It’s entirely possible to cluster
    dhcpd for fault tolerance, but that’s beyond our scope here.)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*/usr/local/etc/dhcpd.conf*包含了所有关于dhcpd的配置。虽然ISC dhcpd(8)本身就可以写成完整的书籍，我们将在这里重点关注适用于基本小型办公室的功能以及本书后续示例中使用的功能。默认的*dhcpd.conf*文件注释齐全，还包括更多的示例，而dhcpd.conf(5)则详细到令人痛苦的程度。我们假设你在网络上运行一个单独的DHCP服务器，且该服务器应答所有DHCP服务请求。（当然，也可以为容错集群化dhcpd，但这超出了我们的讨论范围。）
- en: '**Global Settings**'
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**全局设置**'
- en: Start your *dhcpd.conf* with a few general rules for client configuration. These
    rules apply to all DHCP clients unless specifically overridden.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 从一些客户端配置的通用规则开始你的*dhcpd.conf*文件。这些规则适用于所有DHCP客户端，除非被明确覆盖。
- en: '[PRE40]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Each DHCP client registers its hostname with the DHCP server, but the client
    must learn the local domain name from the server. (It’s also possible for the
    DHCP server to set the client’s hostname.) Set this with the `domain-name` option
    ➊. You can give your DHCP clients any domain name you like; they don’t need to
    share the server’s domain name. You can include multiple domains if you separate
    them with spaces, but not all operating systems will recognize additional domain
    names.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 每个DHCP客户端会向DHCP服务器注册其主机名，但客户端必须从服务器学习本地域名。（也可以让DHCP服务器设置客户端的主机名。）使用`domain-name`选项
    ➊来设置这个。你可以给你的DHCP客户端任何你喜欢的域名；它们不需要与服务器的域名相同。如果用空格分隔，你可以包含多个域名，但并非所有操作系统都会识别额外的域名。
- en: Every TCP/IP client needs a DNS server or two. Specify them with the option
    `domain-name-servers` ➋. Separate multiple DNS servers with commas.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 每个TCP/IP客户端需要一个或多个DNS服务器。使用`domain-name-servers`选项 ➋来指定它们。多个DNS服务器用逗号分隔。
- en: It’s a good idea to set a default subnet mask ➌. Individual networks can override
    this, but a global default is useful.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 设置默认子网掩码 ➌是一个好主意。各个网络可以覆盖此设置，但全局默认值非常有用。
- en: The normal duration of a lease is given (in seconds) by the `default-lease-time`
    option ➍. After the lease time runs out, the client requests a new DHCP lease
    from the DHCP server. DHCP servers commonly default to a small number of minutes,
    but if your network is fairly stable you can extend this to hours or a couple
    days. If the client can’t reach the DHCP server, it continues to use the old lease
    for a number of minutes equal to the maximum life of the lease, specified with
    `max-lease-time` ➎. You can think of the maximum lease time as “if my DHCP server
    fails, this is how long I have to replace it before the phone starts ringing.”
    Give yourself time to fix the issue.^([5](footnote.xhtml#ch20fn5))
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 租约的正常持续时间由`default-lease-time`选项➍（以秒为单位）给出。租约时间到期后，客户端会向DHCP服务器请求新的DHCP租约。DHCP服务器通常默认设置为几分钟，但如果你的网络相对稳定，你可以将其延长至几个小时或几天。如果客户端无法连接到DHCP服务器，它将继续使用旧的租约，直到达到租约的最大有效时间，该时间由`max-lease-time`
    ➎指定。你可以将最大租约时间理解为“如果我的DHCP服务器失败了，这是我在电话开始响起之前，必须更换它的时间。”给自己足够的时间来解决问题。^([5](footnote.xhtml#ch20fn5))
- en: Now define subnets.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在定义子网。
- en: '**Subnet Settings**'
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**子网设置**'
- en: 'Each subnet on your network needs a `subnet` statement to identify configuration
    information for DHCP clients on that subnet. For example, here’s a network statement
    for a single small office network:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上的每个子网都需要一个 `subnet` 声明来识别该子网上 DHCP 客户端的配置信息。例如，这是一个单个小型办公室网络的网络声明：
- en: '[PRE41]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Each subnet declaration starts by identifying the network number and netmask
    ➊ of the subnet. Here, we have a subnet using the IP network number 198.51.100.0
    with the netmask 255.255.255.0, or the IP addresses 198.51.100.1 through 198.51.100.255\.
    The information that follows in braces all pertains to hosts on that particular
    subnet.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子网声明开始时会标识该子网的网络号和子网掩码 ➊。在这里，我们有一个使用 IP 网络号 198.51.100.0 和子网掩码 255.255.255.0
    的子网，或 IP 地址 198.51.100.1 到 198.51.100.255。随后的信息都与该子网上的主机有关。
- en: The `range` keyword ➋ identifies the IP addresses that dhcpd(8) may issue to
    clients. In this example, we have 50 IP addresses available for clients. If 51
    DHCP clients connect before any leases expire, the last host won’t get an address.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`range` 关键字 ➋ 用于标识 dhcpd(8) 可以分配给客户端的 IP 地址。在这个例子中，我们有 50 个可供客户端使用的 IP 地址。如果在任何租约到期之前有
    51 个 DHCP 客户端连接，最后一个主机将无法获得地址。'
- en: Define a default route with the `routers` option ➌. Note that you can’t define
    additional routes with dhcpd(8); instead, your local network router needs to have
    the proper routes to reach the destination. If you have multiple gateways on your
    local network, your gateway transmits an ICMP redirect to the DHCP client to give
    it an updated route. (If you have no idea what this means, that’s all right. When
    you need it, you’ll abruptly comprehend what I’m talking about, and if you never
    need it, you’ve just wasted the two seconds it took to read this aside.)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `routers` 选项 ➌ 定义默认路由。请注意，您不能通过 dhcpd(8) 定义额外的路由；相反，您的本地网络路由器需要有适当的路由来到达目标。如果您的本地网络上有多个网关，您的网关会向
    DHCP 客户端发送 ICMP 重定向，告知它更新后的路由。（如果您不知道这是什么意思，没关系。当您需要时，您会突然理解我在说什么，如果您永远不需要它，那么您刚刚浪费了两秒钟的时间去读这句话。）
- en: If you have multiple subnets, create multiple subnet statements. Some of those
    subnets might need settings different than the global defaults, such as a netmask
    or DNS servers. If so, use those same keywords to define those values for that
    subnet.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个子网，创建多个子网声明。一些子网可能需要不同于全局默认值的设置，例如子网掩码或 DNS 服务器。如果是这样，请使用相同的关键字为该子网定义这些值。
- en: Dhcpd lets you set anything from the subnet mask, boot servers, and even WINS
    servers for antediluvian Windows clients. We’ll use some of these less common
    settings to manage diskless clients in [Chapter 23](ch23.xhtml#ch23). See dhcpd.conf(5)
    for an exhaustive list.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Dhcpd 允许您设置从子网掩码、启动服务器到甚至为古老 Windows 客户端配置 WINS 服务器的所有内容。我们将在[第 23 章](ch23.xhtml#ch23)中使用这些不太常见的设置来管理无磁盘客户端。有关详细信息，请参阅
    dhcpd.conf(5)。
- en: '***Managing dhcpd(8)***'
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***管理 dhcpd(8)***'
- en: Dhcpd defaults to listening to all network interfaces to catch DHCP request
    broadcasts. I’ve run many DHCP servers with multiple network cards, however, and
    usually want dhcpd to listen only to a single interface. Give the desired interface
    as a command line argument.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Dhcpd 默认监听所有网络接口以捕捉 DHCP 请求广播。然而，我曾运行过许多带有多个网络卡的 DHCP 服务器，通常我只希望 dhcpd 监听单个接口。将所需的接口作为命令行参数提供。
- en: '[PRE42]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now enable dhcpd(8) itself.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启用 dhcpd(8) 本身。
- en: '[PRE43]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can now fire up dhcpd with `service dhcpd start`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过 `service dhcpd start` 启动 dhcpd。
- en: Congratulations, you’re ready to go!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您已经准备好了！
- en: '**Printing and Print Servers**'
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**打印和打印服务器**'
- en: Printing on Unix-like operating systems is a topic that makes new sysadmins
    cry and seasoned sysadmins ramble on about the good old days when printers were
    TTY devices and about the younger generation not knowing how good they have it.^([6](footnote.xhtml#ch20fn6))
    The most common printing situations are printers directly attached to a computer
    via a USB port and printers attached to a network print server.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 Unix 操作系统上，打印是一个让新手系统管理员哭泣的主题，而经验丰富的系统管理员则会喋喋不休地谈论过去打印机作为 TTY 设备的时代，以及年轻一代不懂得自己有多幸运。^([6](footnote.xhtml#ch20fn6))
    最常见的打印情境是通过 USB 端口直接连接到计算机的打印机和连接到网络打印服务器的打印机。
- en: If you have a printer attached directly to your FreeBSD machine, such as by
    a USB cable, I suggest using the *Common Unix Printing System (CUPS)*. This suite
    of software manages many popular consumer-grade and commercial printers, from
    lowly inkjets to web-scale laser printers. I’m not going into any detail about
    CUPS, as it’s complicated and varies by printer model. Learn more about CUPS at
    *[http://www.cups.org/](http://www.cups.org/)*. Many brands of printers have special
    setup programs in CUPS, such as HP’s `hp-setup`. If your printer supports a network
    connection, though, try to avoid CUPS and use network printing instead.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一台直接连接到 FreeBSD 机器的打印机，比如通过 USB 电缆连接，我建议使用 *Common Unix Printing System
    (CUPS)*。这套软件管理许多流行的消费级和商用打印机，从普通的喷墨打印机到大规模的激光打印机。我不会详细讲解 CUPS，因为它很复杂，并且根据打印机型号有所不同。你可以在
    *[http://www.cups.org/](http://www.cups.org/)* 上了解更多关于 CUPS 的信息。许多品牌的打印机在 CUPS
    中有专门的设置程序，比如 HP 的 `hp-setup`。不过，如果你的打印机支持网络连接，建议避免使用 CUPS，而改用网络打印。
- en: Accessing a remote print server or network printer via the *Line Printer Spooler
    Daemon (LPD)* is simple in comparison. LPD takes in PostScript and produces printouts.
    Most office print servers run LPD. The lpd(8) daemon manages LPD. Most modern
    networked printers also support LPD and can act as their own print server.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 *Line Printer Spooler Daemon (LPD)* 访问远程打印服务器或网络打印机相比之下更为简单。LPD 接收 PostScript
    文件并生成打印输出。大多数办公打印服务器都运行 LPD。lpd(8) 守护进程管理着 LPD。大多数现代网络打印机也支持 LPD，并且可以作为独立的打印服务器使用。
- en: Test for LPD support by connecting to TCP port 515; if you get a connection,
    the device speaks LPD.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过连接到 TCP 端口 515 来测试是否支持 LPD；如果能够连接，说明设备支持 LPD。
- en: '[PRE44]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This device supports LPD. We can send print jobs to it by configuring */etc/printcap*.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备支持 LPD。我们可以通过配置 */etc/printcap* 将打印任务发送到它。
- en: '***/etc/printcap***'
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***/etc/printcap***'
- en: Every printer your system knows about needs an entry in */etc/printcap*, the
    printer capability database. This file is, by modern standards, in a rather obtuse
    format and will look very unfamiliar to anyone who hasn’t previously worked with
    termcap(5). Fortunately, to access a print server you don’t need to understand
    printcap(5); you just need to use the following template.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统已知的打印机都需要在 */etc/printcap* 中有一个条目，即打印机能力数据库。这个文件按照现代标准来看，格式相当晦涩，且对于没有接触过
    termcap(5) 的人来说，可能显得非常陌生。幸运的是，要访问打印服务器，你并不需要理解 printcap(5)，你只需要使用以下模板。
- en: To connect to a printer on a print server, you must have the print server’s
    hostname or IP address and its name for the printer you want to access. Make an
    entry in */etc/printcap* following this template. Pay special attention to the
    colons and backslashes—they’re absolutely vital.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到打印服务器上的打印机，你必须知道打印服务器的主机名或 IP 地址，以及你想访问的打印机名称。根据以下模板在 */etc/printcap* 中创建条目。特别注意冒号和反斜杠——它们至关重要。
- en: '[PRE45]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Our first line shows the printer’s name ➊. If you print from LibreOffice or
    a graphical web browser, these names will show up as printer options. Each printer
    can have any number of names, separated by the pipe symbol (`|`). The default
    printer on any Unix-like system is called *lp*, so list that as one of the names
    for your preferred printer. One other name should be the name used by the print
    server for your printer (for example, *3rdFloorPrinter*). Be warned, Microsoft
    print servers frequently share one printer under several different names and use
    different names to handle printing differently. If you find this to be the case
    on your network, be sure to choose the PostScript name.^([7](footnote.xhtml#ch20fn7))
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一行显示了打印机的名称 ➊。如果你从 LibreOffice 或图形化的网页浏览器中打印，这些名称会显示为打印机选项。每台打印机可以有多个名称，用管道符号（`|`）分隔。任何类
    Unix 系统上的默认打印机都叫 *lp*，因此将其列为你首选打印机的名称之一。另一个名称应该是打印服务器为你的打印机设置的名称（例如，*3rdFloorPrinter*）。需要注意的是，微软的打印服务器经常将一台打印机共享为多个不同的名称，并且通过不同的名称处理打印任务。如果你在网络上发现这种情况，请确保选择
    PostScript 名称。^([7](footnote.xhtml#ch20fn7))
- en: By default, lpd(8) precedes each print job with a page listing the job name,
    number, host, and other information. Unless you’re in an environment with a single
    massive shared printer, this is probably a waste of paper. The `:sh:\` entry ➋
    suppresses this page.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，lpd(8) 会在每个打印任务前打印一页，列出任务名称、编号、主机及其他信息。除非你处于一个只有一个共享打印机的环境，否则这可能是浪费纸张。`：sh:\`
    条目 ➋ 会抑制此页面的打印。
- en: The `rm` (remote machine) variable ➌ provides the hostname of the print server.
    You must be able to ping this server by the name you give here. If the print server
    is part of the printer, give the printer’s hostname here.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`rm`（远程机器）变量 ➌ 提供打印服务器的主机名。你必须能够通过你在这里指定的名称 ping 到该服务器。如果打印服务器是打印机的一部分，请在此处提供打印机的主机名。'
- en: Each printer requires a unique spool directory ➍, where the local print daemon
    can store documents in transit to the print server. This directory must be owned
    by user *root* and group *daemon*.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 每台打印机都需要一个唯一的打印队列目录 ➍，打印守护进程可以在此目录中存储传输到打印服务器的文档。此目录必须由 *root* 用户和 *daemon*
    组拥有。
- en: Unlike spool directories, which must be different, printers can share a common
    log file ➎.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 与必须不同的打印队列目录不同，打印机可以共享一个公共日志文件 ➎。
- en: Finally, specify the remote printer name ➏, as the print server identifies it.
    If you’re connecting directly to a printer, not to a central print server, you
    can skip this entry—but you must get rid of the trailing slash on the previous
    line.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，指定远程打印机名称 ➏，因为打印服务器是通过该名称识别的。如果你直接连接到打印机，而不是连接到中央打印服务器，可以跳过此项—but 你必须删除前一行中的尾部斜杠。
- en: Be sure you end */etc/printcap* with a new line; don’t just terminate the file
    immediately after the printer name. Also, note that unlike every other entry in
    this template, the last line doesn’t require a trailing backslash.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在 */etc/printcap* 文件末尾添加新行；不要在打印机名称后立即终止文件。另外，请注意，和模板中的其他条目不同，最后一行不需要尾部的反斜杠。
- en: Printers have dozens and dozens of options, from the cost per page to manually
    setting a string to feed a new sheet of paper. Most of these are obsolete today.
    If you have an older printer or special needs, though, consult printcap(5) for
    enough glorious detail to choke on.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 打印机有许多选项，从每页的费用到手动设置字符串以进纸新的纸张。大多数这些选项今天已经过时。然而，如果你有一台较老的打印机或有特殊需求，可以查阅 printcap(5)
    文档，获取足够的详细信息，甚至让人应接不暇。
- en: '***Enabling LPD***'
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启用 LPD***'
- en: Set `lpd_enable` to `YES` in */etc/rc.conf* to have lpd(8) start at boot. Any
    time you edit */etc/printcap* you must restart lpd(8). View the print queue with
    lpq(1) and watch for any problems in */var/log/lpd-errs*.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在 */etc/rc.conf* 中将 `lpd_enable` 设置为 `YES`，以便在启动时启动 lpd(8)。每次编辑 */etc/printcap*
    时，必须重启 lpd(8)。使用 lpq(1) 查看打印队列，并在 */var/log/lpd-errs* 中查看是否有任何问题。
- en: '**TFTP**'
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**TFTP**'
- en: Let’s end our discussion of small network services with perhaps the smallest
    network service still used, the *Trivial File Transfer Protocol (TFTP)*. TFTP
    lets you transfer files from machine to machine without any authentication whatsoever.
    It’s also much less flexible than file copy protocols, such as SCP or FTP. TFTP
    is still used by makers of embedded devices, such as Cisco, to load system configurations
    and operating system updates. We cover it here only because diskless clients use
    TFTP to download their operating system kernel and get their initial configuration
    information. Run tftpd(8) out of inetd(8) on TCP port 69.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们结束关于小型网络服务的讨论，也许是仍然使用的最小网络服务——*简单文件传输协议（TFTP）*。TFTP 允许你在机器之间传输文件，而无需任何身份验证。它的灵活性也远不如文件复制协议，如
    SCP 或 FTP。然而，TFTP 仍然被嵌入式设备制造商（如思科）用来加载系统配置和操作系统更新。我们在这里提到它，仅仅是因为无盘客户端使用 TFTP 下载操作系统内核并获取初始配置信息。在
    TCP 端口 69 上通过 inetd(8) 运行 tftpd(8)。
- en: '**TFTP SECURITY**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**TFTP 安全**'
- en: TFTP isn’t suitable for use on the public internet. Anyone can read or write
    files on a TFTP server! Only use TFTP behind a firewall or at least protect it
    tightly with TCP wrappers (see [Chapter 19](ch19.xhtml#ch19)).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: TFTP 不适合在公共互联网中使用。任何人都可以在 TFTP 服务器上读取或写入文件！仅应在防火墙后使用 TFTP，或者至少使用 TCP 包裹器（参见
    [第19章](ch19.xhtml#ch19)）保护它。
- en: 'Setting up a tftpd(8) server involves four steps: choosing a root directory
    for your server, creating files for the server, choosing an owner for your files,
    and running the server process.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 tftpd(8) 服务器包括四个步骤：为服务器选择根目录、为服务器创建文件、选择文件的所有者，以及运行服务器进程。
- en: '***Root Directory***'
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***根目录***'
- en: 'The tftpd(8) daemon defaults to using the directory */tftpboot*. This might
    be suitable if you have only a couple files that you rarely access, but the root
    partition is best reserved for files that don’t change often. You don’t want a
    TFTP upload to crash your system by filling the root partition! If you’re running
    ZFS, create a tftp dataset. On UFS, I usually put my tftpd(8) root directory in
    */var/tftpboot* and add a symlink to */tftpboot*:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: tftpd(8) 守护进程默认使用目录 */tftpboot*。如果您只有几个很少访问的文件，这可能是合适的选择，但最好将根分区保留给那些不常更改的文件。您不希望通过
    TFTP 上传文件导致根分区填满，从而崩溃系统！如果您使用的是 ZFS，可以创建一个 tftp 数据集。在 UFS 中，我通常将 tftpd(8) 的根目录放在
    */var/tftpboot*，并添加一个指向 */tftpboot* 的符号链接：
- en: '[PRE46]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now you can create files for access via TFTP.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以创建文件并通过 TFTP 进行访问。
- en: '***tftpd and Files***'
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***tftpd 和文件***'
- en: 'Users can both read and write files via TFTP. If you want tftpd(8) users to
    be able to read a file, the file must be world-readable:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过 TFTP 进行文件的读取和写入。如果您希望 tftpd(8) 用户能够读取某个文件，该文件必须是全局可读的：
- en: '[PRE47]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Similarly, tftpd(8) won’t allow anyone to upload a file unless a file of that
    name already exists and is world-writable. Remember, programs and regular files
    have different permissions. A program must have execute permissions in addition
    to read and write permissions, so you must set permissions differently for programs
    and files. You can use touch(1) to precreate files that you’ll want to upload
    via TFTP.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，tftpd(8) 不允许任何人上传文件，除非该文件名已经存在且是全局可写的。请记住，程序和常规文件具有不同的权限。程序必须具备执行权限，除了读取和写入权限，因此您需要为程序和文件设置不同的权限。您可以使用
    touch(1) 命令预先创建您希望通过 TFTP 上传的文件。
- en: '[PRE48]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Yes, this means that anyone who knows a file’s name can overwrite the contents
    of that file. Make vital files read-only.^([8](footnote.xhtml#ch20fn8)) This also
    means you don’t have to worry about someone uploading a big file and filling your
    hard drive.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这意味着任何知道文件名的人都可以覆盖该文件的内容。请将重要文件设置为只读。^([8](footnote.xhtml#ch20fn8)) 这也意味着您无需担心有人上传大文件并占满您的硬盘。
- en: '***File Ownership***'
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件所有权***'
- en: Files in a TFTP server should be owned by a user with the least possible privilege.
    If you run a TFTP server only intermittently, you can use the nobody user. For
    example, if you need the TFTP server only to perform the occasional embedded device
    upgrade, let the nobody user own your files and just turn tftpd(8) off when it’s
    not needed. If you run a permanent TFTP server, however, it’s best to have a dedicated
    tftp unprivileged user to own the files. The tftp user doesn’t need to own the
    *tftproot* directory and, in fact, should have an entirely different home directory.
    He needs ownership only of the files available to users.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: TFTP 服务器中的文件应该由具有最低权限的用户拥有。如果您只偶尔运行 TFTP 服务器，可以使用 nobody 用户。例如，如果您只需要 TFTP 服务器执行偶尔的嵌入式设备升级，可以让
    nobody 用户拥有您的文件，并在不需要时关闭 tftpd(8)。然而，如果您运行的是永久性的 TFTP 服务器，最好让专门的 tftp 无权限用户拥有文件。tftp
    用户不需要拥有 *tftproot* 目录，实际上，应该有一个完全不同的主目录。他只需要拥有可供用户访问的文件的所有权。
- en: '***tftpd(8) Configuration***'
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***tftpd(8) 配置***'
- en: tftpd(8) is configured entirely through command line arguments, and there aren’t
    many of them. For a full list, read tftpd(8), but here are the most commonly used
    ones.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: tftpd(8) 完全通过命令行参数进行配置，且参数不多。有关完整列表，请阅读 tftpd(8)，以下是最常用的几个。
- en: If you create a user just to run tftpd(8), specify that user with the `-u` argument.
    If you don’t specify a user, tftpd(8) runs as nobody. Create an unprivileged user.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仅为运行 tftpd(8) 创建用户，请使用 `-u` 参数指定该用户。如果不指定用户，tftpd(8) 将以 nobody 身份运行。请创建一个无权限用户。
- en: I recommend logging all requests to your TFTP daemon. The `-l` argument turns
    on logging. tftpd(8) uses the `FTP` facility, which you must enable in *syslog.conf*
    (see [Chapter 21](ch21.xhtml#ch21)).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议记录所有对 TFTP 守护进程的请求。`-l` 参数会启用日志记录功能。tftpd(8) 使用 `FTP` 功能，您需要在 *syslog.conf*
    中启用该功能（请参见 [第 21 章](ch21.xhtml#ch21)）。
- en: Tftpd supports chrooting with the `-s` flag. This lets you confine tftpd(8)
    to your selected directory. You don’t want users to TFTP world-readable files
    such as */etc/passwd*, or even */boot/kernel/kernel*, just on general principle!
    Always chroot your tftpd(8) installation.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: tftpd 支持使用 `-s` 标志进行 chroot 限制。这可以让您将 tftpd(8) 限制在您选择的目录中。您可不希望用户通过 TFTP 上传诸如
    */etc/passwd* 或 */boot/kernel/kernel* 这样全局可读的文件，这是出于一般原则的考虑！始终对您的 tftpd(8) 安装进行
    chroot 限制。
- en: You can chroot TFTP clients by IP address with the `-c` argument. In this case,
    you must create a directory for every client permitted to connect. For example,
    suppose the only host you want to give TFTP access to is your router, with the
    IP address of 192.168.1.1\. You could create a directory */var/tftproot/192.168.1.1*
    and use `-c`. You must also use `-s` to define the base directory of */var/tftproot*.
    This is a good compromise when you must offer TFTP to only one or two hosts, but
    you don’t want the world to have access to your TFTP server.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `-c` 参数按 IP 地址为 TFTP 客户端设置 chroot。在这种情况下，你必须为每个允许连接的客户端创建一个目录。例如，假设你只想允许你的路由器通过
    IP 地址 192.168.1.1 访问 TFTP。你可以创建一个目录 */var/tftproot/192.168.1.1* 并使用 `-c`。你还必须使用
    `-s` 来定义 */var/tftproot* 的基本目录。这是一种不错的折衷方法，当你只想为一两个主机提供 TFTP 服务时，但又不希望让全球用户都能访问你的
    TFTP 服务器。
- en: You can choose to allow a client to write new files to your TFTP server. This
    is a bad idea because it lets remote users fill up your hard disks with arbitrary
    files. If you must have this functionality, use the `-w` flag.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择允许客户端向 TFTP 服务器写入新文件。这是一个不好的主意，因为它允许远程用户用任意文件填满你的硬盘。如果你确实需要这个功能，请使用 `-w`
    标志。
- en: 'For example, suppose you want to log all requests to tftpd, chroot to */var/tftpboot*,
    run the server as the user tftpd, and chroot clients by IP address. The command
    to run tftpd would look like this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想记录所有对 tftpd 的请求，将根目录改为 */var/tftpboot*，以 tftpd 用户身份运行服务器，并按 IP 地址为客户端设置
    chroot。运行 tftpd 的命令可能是这样的：
- en: '[PRE49]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Enter this into *inetd.conf* as described earlier this chapter, restart inetd(8),
    and you’re in business!
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章前面描述的方式，将此内容输入到*inetd.conf*中，重启inetd(8)，然后就可以开始使用了！
- en: '**Scheduling Tasks**'
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**调度任务**'
- en: The FreeBSD job scheduler, cron(8), allows the administrator to have the system
    run any command on a regular basis. Combined with the system maintenance scheduling
    system, periodic(8), you can schedule almost anything.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 的作业调度器 cron(8) 允许管理员定期运行任何命令。结合系统维护调度系统 periodic(8)，你几乎可以调度任何任务。
- en: '***cron(8)***'
  id: totrans-359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***cron(8)***'
- en: If you need to back up your database nightly or reload the nameserver four times
    a day, cron is your friend. cron(8) configuration files are called *crontabs*
    and are managed with crontab(1). Every user has a separate crontab stored in */var/cron/tabs*,
    and the global crontab file is */etc/crontab*. Global cron entries can also be
    placed in */etc/cron.d* and will be run as if they were part of */etc/crontab*.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要每天夜间备份数据库，或者一天四次重新加载 DNS 服务器，cron 是你的好帮手。cron(8) 的配置文件称为 *crontabs*，并通过
    crontab(1) 进行管理。每个用户都有一个单独的 crontab 文件，存储在 */var/cron/tabs* 中，全局 crontab 文件是 */etc/crontab*。全局
    cron 条目也可以放在 */etc/cron.d* 中，并将像 */etc/crontab* 中的一部分那样运行。
- en: '**User Crontabs vs. /etc/crontab**'
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**用户 Crontab 与 /etc/crontab**'
- en: The purpose of */etc/crontab* is different from that of individual users’ crontabs.
    With */etc/crontab*, root may specify which user will run a particular command.
    For example, in */etc/crontab*, the sysadmin can say, “Run this job at 10 PM Tuesdays
    as root, and run this other job at 7 AM as *www*.” Other users can run jobs only
    as themselves. Of course, root can also edit a user’s crontab.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/crontab* 的目的与各个用户的 crontab 不同。使用 */etc/crontab* 时，root 用户可以指定某个命令由哪个用户执行。例如，在
    */etc/crontab* 中，系统管理员可以指定，“在每周二晚上 10 点以 root 用户身份运行此任务，在早上 7 点以 *www* 用户身份运行另一个任务。”其他用户只能以自己的身份运行任务。当然，root
    用户也可以编辑其他用户的 crontab。'
- en: Also, any system user can view */etc/crontab*. If you have a scheduled job that
    you don’t want users to know about, place it in a user crontab. For example, if
    you have an unprivileged user for your database, use that unprivileged user’s
    crontab to run database maintenance jobs.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，任何系统用户都可以查看 */etc/crontab*。如果你有一个不希望用户知道的定时任务，可以将其放在用户的 crontab 中。例如，如果你为数据库创建了一个非特权用户，可以使用该用户的
    crontab 来运行数据库维护任务。
- en: '*/etc/crontab* is considered a FreeBSD system file. Don’t overwrite it when
    you upgrade! One way to simplify upgrading */etc/crontab* is to set your custom
    entries at the end of the file, marked off with a few lines of hash marks (`#`).
    The */etc/crontab* file must end with a new line, or the last line won’t get parsed
    and run. That’s fine if your last entry is a comment, but not so good if it’s
    a command.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/crontab* 被认为是一个 FreeBSD 系统文件。在升级时不要覆盖它！简化升级*/etc/crontab*的一种方法是将自定义条目放在文件末尾，并用几行井号（`#`）标记。*/etc/crontab*
    文件必须以新行结尾，否则最后一行将不会被解析并执行。如果最后一行是注释，这样没有问题，但如果它是命令，则可能会出现问题。'
- en: Finally, while you edit */etc/crontab* with a text editor, edit a user crontab
    with `crontab -e`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你使用文本编辑器编辑*/etc/crontab*时，使用`crontab -e`来编辑用户的crontab。
- en: '**cron and Environment**'
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**cron 和环境**'
- en: 'Crontabs run in a shell, and programs might require environment variables to
    run correctly. You can also specify environment variables on the command line
    for each command you run from cron. cron doesn’t inherit any environment variables
    from anywhere; any environment variables a program needs must be specified in
    the crontab. For example, here’s the environment from */etc/crontab* on a FreeBSD
    12 system:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Crontab在一个shell中运行，程序可能需要环境变量才能正确运行。你还可以在命令行中为每个从cron运行的命令指定环境变量。cron不会从任何地方继承环境变量；程序需要的任何环境变量必须在crontab中指定。例如，以下是FreeBSD
    12系统中*/etc/crontab*的环境：
- en: '[PRE50]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Yes, this is extremely minimal! Feel free to add environment variables as needed
    to user crontabs, but be conservative when changing */etc/crontab*. If you need
    a custom environment variable, it’s safest to use a user crontab rather than */etc/crontab*
    because many of the commands in */etc/crontab* are for core system maintenance.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这确实是非常简洁！可以根据需要在用户crontab中添加环境变量，但在更改*/etc/crontab*时要谨慎。如果需要自定义环境变量，最好使用用户crontab而不是*/etc/crontab*，因为*/etc/crontab*中的许多命令是用于核心系统维护的。
- en: '**Crontab Format**'
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Crontab格式**'
- en: Beneath the environment statements, a user crontab is divided into six columns.
    The first five columns represent the time the command should run, as minute, hour,
    day of the month, month of the year, and day of the week, in that order. An asterisk
    (`*`) in any column means *every one*, while a number means *at this exact time*.
    Minutes, hours, and days of the week begin with 0, and days of the month and months
    begin with 1\. Also, thanks to an ancient disagreement between AT&T and BSD, Sunday
    can be represented by either 7 or 0\. After the time, list the command to be run
    at that time.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在环境声明下面，用户的crontab分为六列。前五列表示命令应运行的时间，依次是分钟、小时、日期、月份和星期几。如果某列为星号（`*`），表示*每一个*，而数字则表示*在此精确时刻*。分钟、小时和星期几从0开始，日期和月份从1开始。此外，由于AT&T和BSD之间的历史分歧，星期天可以用7或0表示。在时间之后，列出在该时间运行的命令。
- en: 'The */etc/crontab* file, and files under */etc/cron.d*, have one extra column:
    the user under which to run the command. It goes between the time specification
    and the command itself. Check out the many examples in */etc/crontab* if you like.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/crontab*文件和*/etc/cron.d*下的文件有一个额外的列：指定以哪个用户身份运行命令。这个用户列位于时间说明和命令之间。如果你愿意，可以查看*/etc/crontab*中的许多示例。'
- en: '**Sample Crontabs**'
  id: totrans-373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例Crontab**'
- en: 'Assume that we’re editing the crontab of an unprivileged user to schedule maintenance
    of a program. As */etc/crontab* has column headings at the top, we’ll demonstrate
    user crontabs here. (To use these examples in */etc/crontab*, just add the user
    before the command.) Here, we want to run the program */usr/local/bin/maintenance.sh*
    at 55 minutes after each hour, every single hour:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在编辑一个无权限用户的crontab，以安排程序的维护。由于*/etc/crontab*文件顶部有列标题，这里我们将展示用户crontab。（如果要在*/etc/crontab*中使用这些示例，只需在命令前加上用户即可。）在这里，我们希望每小时的第55分钟运行程序*/usr/local/bin/maintenance.sh*：
- en: '[PRE51]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Asterisks tell cron to run this job every hour, on every day of the month, every
    month, and on every weekday. The `55` tells cron to run this job only at minute
    55.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 星号告诉cron每小时、每个月的每一天以及每个工作日运行这个作业。`55`告诉cron仅在第55分钟运行这个作业。
- en: 'To run the same job at 1:55 PM every day, use the following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 要每天在下午1:55运行相同的作业，可以使用以下配置：
- en: '[PRE52]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, `13` represents 1:00 PM on the 24-hour clock, and `55` is the number of
    minutes past that hour.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`13`表示24小时制下的下午1:00，`55`表示该小时的第55分钟。
- en: 'One common mistake people make when using cron is specifying a large unit of
    time but missing the small one. For example, suppose you want to run the job every
    day at 8 AM:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 使用cron时，人们常犯的一个错误是指定了较大的时间单位，却漏掉了较小的单位。例如，假设你想每天上午8点运行作业：
- en: '[PRE53]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is wrong. Yes, the job will run at 8:00 AM. It will also run at 8:01,
    8:02, 8:03, and so on, until 9 AM. If your job takes more than one minute to run,
    you’ll quickly bring your system to its knees. The correct way to specify 8:00
    AM, and only 8:00 AM, is this:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这是错误的。是的，作业将在上午8:00运行。它也会在8:01、8:02、8:03等时间运行，一直到上午9:00。如果你的作业运行超过一分钟，你很快就会让系统崩溃。指定仅在上午8:00运行的方法是这样的：
- en: '[PRE54]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To specify ranges of time, such as running the program once an hour, every
    hour, between 8 AM and 6 PM, Monday through Friday, use something like this:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定时间范围，例如每小时、每天在上午8点到下午6点之间的某个时间运行程序，可以使用类似这样的语法：
- en: '[PRE55]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To specify multiple exact times, separate them with commas:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定多个精确的时间，使用逗号分隔：
- en: '[PRE56]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'More interestingly, you can specify fractions of time, or *steps*. For example,
    to run a program every 5 minutes, use:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can combine ranges with steps. To run the program every 5 minutes, but
    1 minute after the previous example, use this:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Control the day a job runs with two fields: the day of the month and the day
    of the week. If you specify both, the job will run whenever *either* condition
    is met. For example, tell cron to run a job on the 1st and the 15th of every month,
    plus every Monday, as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If your job has a nonstandard environment, set the environment on the command
    line just as you would in the shell. For example, if your program requires a `LD_LIBRARY_PATH`
    environment variable, you can set it thus:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'cron also supports special scheduling, such as *annually* or *daily*, with
    the `@` symbol. Most of these terms are best not used, as they can be ambiguous.
    While the machine knows exactly what they mean, humans tend to misunderstand!
    One useful crontab entry is for *whenever the system boots*, which is `@``reboot`.
    This lets an unprivileged user run jobs when the system boots. Use the `@reboot`
    label instead of the time fields:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Crontabs and cron(8) let you schedule your work any way you like, eliminating
    the human being from many routine maintenance tasks.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '***periodic(8)***'
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some system maintenance jobs should be run only on particular systems, but the
    way they should be run is identical across all hosts. That’s where periodic(8)
    comes in.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'The periodic(8) command runs system functions on schedule, as cron(8) determines.
    Periodic checks a directory for a set of scripts to run. FreeBSD includes several
    directories for periodic tasks: */etc/periodic/daily*, */etc/periodic/weekly*,
    */etc/periodic/monthly*, and */etc/periodic/security*. Depending on which packages
    you install, you might have corresponding directories in */usr/local/etc/periodic*.
    When cron runs, say, periodic daily, periodic(8) checks each script in each *periodic/daily*
    directory to see whether it should be run.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: When you have spare time, I recommend perusing the periodic(8) scripts. You
    might find disabled maintenance scripts useful for your environment.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Which scripts should be run? The default settings are listed in */etc/defaults/periodic.conf*,
    but you can override them in */etc/periodic.conf*.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Once periodic(8) runs, it mails the results of the scripts to root on the local
    machine. Forward root’s mail to someone who will actually read it.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Why use periodic(8)? It’s all for system maintenance. */etc/crontab* is for
    configuring your own system administration jobs. Using separate scripts allows
    the system upgrade process to replace tasks and packages to add and remove them.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: All periodic(8) jobs run as root, though. If you have scheduled jobs that should
    be run by less privileged users, run them from the user’s crontab.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a decent understanding of the common small services provided
    by FreeBSD, let’s go on to performance.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
