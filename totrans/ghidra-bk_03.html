<html><head></head><body><div id="sbo-rt-content"><span epub:type="pagebreak" id="page_15"/>
<h2 class="h2" id="ch02"><strong><span class="big">2</span><br/>REVERSING AND DISASSEMBLY TOOLS</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindent">With some disassembly background under our belts, and before we begin our dive into the specifics of Ghidra, it will be useful to understand some of the other tools that are used for reverse engineering binaries. Many of these tools predate Ghidra and continue to be useful for quick glimpses into files as well as for double-checking the work that Ghidra does. As we will see, Ghidra rolls many of the capabilities of these tools into its user interface to provide a single, integrated environment for reverse engineering.</p>
<h3 class="h3" id="ch02lev29"><strong>Classification Tools</strong></h3>
<p class="noindent">When first confronted with an unknown file, it is often useful to answer simple questions such as, “What is this thing?” The first rule of thumb when attempting to answer that question is to <em>never</em> rely on a file extension to determine what a file actually is. That is also the second, third, and fourth <span epub:type="pagebreak" id="page_16"/>rules of thumb. Once you have become an adherent of the <em>file extensions are meaningless</em> line of thinking, you may wish to familiarize yourself with one or more of the following utilities.</p>
<h4 class="h4" id="ch02lev30"><strong><em>file</em></strong></h4>
<p class="noindent">The <span class="literal">file</span> command is a standard utility, included with most *nix-style operating systems as well as the Windows Subsystem for Linux (WSL).<sup><a id="ch02fn1a" href="footnotes.xhtml#ch02fn1">1</a></sup> This command is also available to Windows users by installing either Cygwin or MinGW.<sup><a id="ch02fn2a" href="footnotes.xhtml#ch02fn2">2</a></sup> The <span class="literal">file</span> command attempts to identify a file’s type by examining specific fields within the file.</p>
<span epub:type="pagebreak" id="page_17"/>
<p class="indent">In some cases, <span class="literal">file</span> recognizes common strings such as <span class="literal">#!/bin/sh</span> (a shell script) and <span class="literal">&lt;html&gt;</span> (an HTML document).</p>
<p class="indent">Files containing non-ASCII content present somewhat more of a challenge. In such cases, <span class="literal">file</span> attempts to determine whether the content appears to be structured according to a known file format. In many cases, it searches for specific tag values (often referred to as <em>magic numbers</em>)<sup><a id="ch02fn3a" href="footnotes.xhtml#ch02fn3">3</a></sup> known to be unique to specific file types. The following hex listings show several examples of magic numbers used to identify some common file types.</p>
<p class="programs">Windows PE executable file<br/>
  00000000 <span class="codestrong1">4D 5A</span> 90 00 03 00 00 00 04 00 00 00 FF FF 00 00 <span class="codestrong1">MZ</span>..............<br/>
  00000010 B8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 ........@.......<br/>
Jpeg image file<br/>
  00000000 <span class="codestrong1">FF D8</span> FF E0 00 10 <span class="codestrong1">4A 46 49 46</span> 00 01 01 01 00 60 ......<span class="codestrong1">JFIF</span>.....`<br/>
  00000010 00 60 00 00 FF DB 00 43 00 0A 07 07 08 07 06 0A .`.....C........<br/>
Java .class file<br/>
  00000000 <span class="codestrong1">CA FE BA BE</span> 00 00 00 32 00 98 0A 00 2E 00 3E 08 .......2......&gt;.<br/>
  00000010 00 3F 09 00 40 00 41 08 00 42 0A 00 43 00 44 0A .?..@.A..B..C.D.</p>
<p class="indent">The <span class="literal">file</span> command has the capability to identify many file formats, including several types of ASCII text files and various executable and data file formats. The magic number checks performed by <span class="literal">file</span> are governed by rules contained in a <em>magic file</em>. The default magic file varies by operating system, but common locations include <em>/usr/share/file/magic</em>, <em>/usr/share/misc/magic</em>, and <em>/etc/magic</em>. Please refer to the documentation for <span class="literal">file</span> for more information concerning magic files.</p>
<p class="indent">In some cases, <span class="literal">file</span> can distinguish variations within a given file type. The following listing demonstrates <span class="literal">file</span>’s ability to identify not only several variations of ELF binaries but also information pertaining to how the binary was linked (statically or dynamically) and whether the binary was stripped.</p>
<p class="programs">ghidrabook# <span class="codestrong1">file ch2_ex_*</span><br/>
  ch2_ex_x64:        ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), <br/>
                     dynamically linked, interpreter /lib64/l, for GNU/Linux <br/>
                     3.2.0, not stripped<br/>
  ch2_ex_x64_dbg:    ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), <br/>
                     dynamically linked, interpreter /lib64/l, for GNU/Linux <br/>
                     3.2.0, with debug_info, not stripped<br/>
  ch2_ex_x64_static: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), <br/>
                     statically linked, for GNU/Linux 3.2.0, not stripped<br/>
  ch2_ex_x64_strip:  ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), <br/>
                     dynamically linked, interpreter /lib64/l, for GNU/Linux <br/>
                     3.2.0, stripped<br/>
  ch2_ex_x86:        ELF 32-bit LSB shared object, Intel 80386, version 1 <br/>
                     (SYSV), dynamically linked, interpreter /lib/ld-, for <br/>
                     GNU/Linux 3.2.0, not stripped<br/>
  ch2_ex_x86_dbg:    ELF 32-bit LSB shared object, Intel 80386, version 1 <br/>
                     (SYSV), dynamically linked, interpreter /lib/ld-, for <br/>
                     GNU/Linux 3.2.0, with debug_info, not stripped<br/>
  ch2_ex_x86_static: ELF 32-bit LSB executable, Intel 80386, version 1 <br/>
                     (GNU/Linux), statically linked, for GNU/Linux 3.2.0, <br/>
                     not stripped<br/>
  ch2_ex_x86_strip:  ELF 32-bit LSB shared object, Intel 80386, version 1 <br/>
                     (SYSV), dynamically linked, interpreter /lib/ld-, for <br/>
                     GNU/Linux 3.2.0, stripped<br/>
  ch2_ex_Win32:      PE32 executable (console) Intel 80386, for MS Windows<br/>
  ch2_ex_x64:        PE32+ executable (console) x86-64, for MS Windows</p>
<div class="box5">
<p class="boxtitle-c"><strong>THE WSL ENVIRONMENT</strong></p>
<p class="noindent">The Windows Subsystem for Linux provides a GNU/Linux command line environment directly within Windows without the need to create a virtual machine. During WSL installation, users choose a Linux distribution and can then run it on the WSL. This provides access to common command line free software (<span class="literal">grep</span>, <span class="literal">awk</span>), compilers (<span class="literal">gcc</span>, <span class="literal">g++</span>), interpreters (Perl, Python, Ruby), networking utilities (<span class="literal">nc</span>, <span class="literal">ssh</span>), and many others. Once WSL has been installed, many programs written for use with Linux can be compiled and executed on Windows systems.</p>
</div>
<span epub:type="pagebreak" id="page_18"/>
<p class="indent">The <span class="literal">file</span> utility and similar utilities are not foolproof. It is quite possible for a file to be misidentified simply because it happens to bear the identifying marks of a particular file format. You can see this for yourself by using a hex editor to modify the first 4 bytes of any file to the Java magic number sequence: <span class="literal">CA FE BA BE</span>. The <span class="literal">file</span> utility will incorrectly identify the newly modified file as <em>compiled Java class data</em>. Similarly, a text file containing only the two characters <span class="literal">MZ</span> will be identified as an <em>MS-DOS executable</em>. A good approach to take in any reverse engineering effort is to never fully trust the output of any tool until you have correlated that output with several tools and manual analysis.</p>
<div class="box5">
<p class="boxtitle-c"><strong>STRIPPING BINARY EXECUTABLE FILES</strong></p>
<p class="noindent"><em>Stripping</em> a binary is the process of removing symbols from the binary file. Binary object files contain symbols as a result of the compilation process. Some of these symbols are utilized during the linking process to resolve references between files when creating the final executable file or library. In other cases, symbols may be present to provide additional information for use with debuggers. Following the linking process, many of the symbols are no longer required. Options passed to the linker can cause the linker to remove the unnecessary symbols at build time. Alternatively, a utility named <span class="literal">strip</span> may be used to remove symbols from existing binary files. While a stripped binary will be smaller than its unstripped counterpart, the behavior of the stripped binary will remain unchanged.</p>
</div>
<h4 class="h4" id="ch02lev31"><strong><em>PE Tools</em></strong></h4>
<p class="noindent">PE Tools is a collection of tools useful for analyzing both running processes and executable files on Windows systems.<sup><a id="ch02fn4a" href="footnotes.xhtml#ch02fn4">4</a></sup> <a href="ch02.xhtml#fig2_1">Figure 2-1</a> shows the primary interface offered by PE Tools, which displays a list of active processes and provides access to all of the PE Tools utilities.</p>
<p class="indent">From the process list, users can dump a process’s memory image to a file or utilize the PE Sniffer utility to determine what compiler was used to build the executable or whether the executable was processed by any known obfuscation utilities. The Tools menu offers similar options for analysis of disk files. Users can view a file’s PE header fields by using the embedded PE Editor utility, which also allows for easy modification of any header values. Modification of PE headers is often required when attempting to reconstruct a valid PE from an obfuscated version of that file.</p>
<span epub:type="pagebreak" id="page_19"/>
<div class="image"><img src="Images/fig2-1.jpg" alt="image" width="694" height="413"/></div>
<p class="figcap" id="fig2_1"><em>Figure 2-1: The PE Tools utility</em></p>
<div class="box5">
<p class="boxtitle-c"><strong>BINARY FILE OBFUSCATION</strong></p>
<p class="noindent"><em>Obfuscation</em> is any attempt to obscure the true meaning of something. When applied to executable files, obfuscation is any attempt to hide the true behavior of a program. Programmers may employ obfuscation for a number of reasons. Commonly cited examples include protecting proprietary algorithms and obscuring malicious intent. Nearly all forms of malware utilize obfuscation in an effort to hinder analysis. Tools are widely available to assist program authors in generating obfuscated programs. Obfuscation tools and techniques and their associated impact on the reverse engineering process are discussed further in <a href="ch21.xhtml#ch21">Chapter 21</a>.</p>
</div>
<h4 class="h4" id="ch02lev32"><strong><em>PEiD</em></strong></h4>
<p class="noindent">PEiD is another Windows tool whose primary purposes are to identify the compiler used to build a particular Windows PE binary and to identify any tools used to obfuscate a Windows PE binary.<sup><a id="ch02fn5a" href="footnotes.xhtml#ch02fn5">5</a></sup> <a href="ch02.xhtml#fig2_2">Figure 2-2</a> shows the use of PEiD to identify the tool (ASPack in this case) used to obfuscate a variant of the Gaobot worm.<sup><a id="ch02fn6a" href="footnotes.xhtml#ch02fn6">6</a></sup></p>
<span epub:type="pagebreak" id="page_20"/>
<div class="image"><img src="Images/fig2-2.jpg" alt="image" width="523" height="299"/></div>
<p class="figcap" id="fig2_2"><em>Figure 2-2: The PEiD utility</em></p>
<p class="indent">Many additional capabilities of PEiD overlap those of PE Tools, including the ability to summarize PE file headers, collect information on running processes, and perform basic disassembly.</p>
<h3 class="h3" id="ch02lev33"><strong>Summary Tools</strong></h3>
<p class="noindent">Since our goal is to reverse engineer binary program files, we are going to need more sophisticated tools to extract detailed information following initial classification of a file. The tools discussed in this section, by necessity, are far more aware of the formats of the files that they process. In most cases, these tools understand a very specific file format, and the tools are utilized to parse input files to extract very specific information.</p>
<h4 class="h4" id="ch02lev34"><strong><em>nm</em></strong></h4>
<p class="noindent">When source files are compiled to object files, compilers must embed information regarding the location of any global (external) symbols so that the linker will be able to resolve references to those symbols when it combines object files to create an executable. Unless instructed to strip symbols from the final executable, the linker generally carries symbols from the object files over into the resulting executable. According to the man page, the <span class="literal">nm</span> utility “lists symbols from object files.”</p>
<p class="indent">When <span class="literal">nm</span> is used to examine an intermediate object file (a <em>.o</em> file rather than an executable), the default output yields the names of any functions and global variables declared in the file. Sample output of the <span class="literal">nm</span> utility is shown next:</p>
<p class="programs">ghidrabook# <span class="codestrong1">gcc -c ch2_nm_example.c</span><br/>
ghidrabook# <span class="codestrong1">nm ch2_nm_example.o</span><br/>
                   U exit<br/>
                   U fwrite<br/>
  000000000000002e t get_max<br/>
                   U _GLOBAL_OFFSET_TABLE_<br/>
                   U __isoc99_scanf<br/>
<span epub:type="pagebreak" id="page_21"/>
  00000000000000a6 T main<br/>
  0000000000000000 D my_initialized_global<br/>
  0000000000000004 C my_uninitialized_global<br/>
                   U printf<br/>
                   U puts<br/>
                   U rand<br/>
                   U srand<br/>
                   U __stack_chk_fail<br/>
                   U stderr<br/>
                   U time<br/>
  0000000000000000 T usage<br/>
ghidrabook#</p>
<p class="indent">Here we see that <span class="literal">nm</span> lists each symbol, along with information about the symbol. The letter codes are used to indicate the type of symbol being listed. In this example, we see the following letter codes:</p>
<p class="uln-indent"><span class="codestrong">U</span> An undefined symbol (usually an external symbol reference).</p>
<p class="uln-indent"><span class="codestrong">T</span> A symbol defined in the text section (usually a function name).</p>
<p class="uln-indent"><span class="codestrong">t</span> A local symbol defined in the text section. In a C program, this usually equates to a static function.</p>
<p class="uln-indent"><span class="codestrong">D</span> An initialized data value.</p>
<p class="uln-indent"><span class="codestrong">C</span> An uninitialized data value.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Uppercase letter codes are used for global symbols, whereas lowercase letter codes are used for local symbols. More information, including a full explanation of the letter codes, can be found in the man page for</em> <span class="codeitalic">nm</span>.</p>
</div>
<p class="indent">Somewhat more information is displayed when <span class="literal">nm</span> is used to display symbols from an executable file. During linking, symbols are resolved to virtual addresses (when possible), which results in more information being available when <span class="literal">nm</span> is run. Truncated sample output from <span class="literal">nm</span> used on an executable is shown here:</p>
<p class="programs">ghidrabook# <span class="codestrong1">gcc -o ch2_nm_example ch2_nm_example.c</span><br/>
ghidrabook# <span class="codestrong1">nm ch2_nm_example</span><br/>
  ...<br/>
                   U fwrite@@GLIBC_2.2.5<br/>
  0000000000000938 t get_max<br/>
  0000000000201f78 d _GLOBAL_OFFSET_TABLE_<br/>
                   w __gmon_start__<br/>
  0000000000000c5c r __GNU_EH_FRAME_HDR<br/>
  0000000000000730 T _init<br/>
  0000000000201d80 t __init_array_end<br/>
  0000000000201d78 t __init_array_start<br/>
  0000000000000b60 R _IO_stdin_used<br/>
                   U __isoc99_scanf@@GLIBC_2.7<br/>
                   w _ITM_deregisterTMCloneTable<br/>
                   w _ITM_registerTMCloneTable<br/>
  0000000000000b50 T __libc_csu_fini<br/>
  0000000000000ae0 T __libc_csu_init<br/>
<span epub:type="pagebreak" id="page_22"/>
                   U __libc_start_main@@GLIBC_2.2.5<br/>
  00000000000009b0 T main<br/>
  0000000000202010 D my_initialized_global<br/>
  000000000020202c B my_uninitialized_global<br/>
                   U printf@@GLIBC_2.2.5<br/>
                   U puts@@GLIBC_2.2.5<br/>
                   U rand@@GLIBC_2.2.5<br/>
  0000000000000870 t register_tm_clones<br/>
                   U srand@@GLIBC_2.2.5<br/>
                   U __stack_chk_fail@@GLIBC_2.4<br/>
  0000000000000800 T _start<br/>
  0000000000202020 B stderr@@GLIBC_2.2.5<br/>
                   U time@@GLIBC_2.2.5<br/>
  0000000000202018 D __TMC_END__<br/>
  000000000000090a T usage<br/>
ghidrabook#</p>
<p class="indent">At this point, some of the symbols (<span class="literal">main</span>, for example) have been assigned virtual addresses, new ones (<span class="literal">__libc_csu_init</span>) have been introduced as a result of the linking process, some (<span class="literal">my_unitialized_global</span>) have had their symbol type changed, and others remain undefined as they continue to reference external symbols. In this case, the binary we are examining is dynamically linked, and the undefined symbols are defined in the shared C library.</p>
<h4 class="h4" id="ch02lev35"><strong><em>ldd</em></strong></h4>
<p class="noindent">When an executable is created, the location of any library functions referenced by that executable must be resolved. The linker has two methods for resolving calls to library functions: <em>static linking</em> and <em>dynamic linking</em>. Command line arguments provided to the linker determine which of the two methods is used. An executable may be statically linked, dynamically linked, or both.<sup><a id="ch02fn7a" href="footnotes.xhtml#ch02fn7">7</a></sup></p>
<p class="indent">When static linking is requested, the linker combines an application’s object files with a copy of the required library to create an executable file. At runtime, there is no need to locate the library code because it is already contained within the executable. Advantages of static linking are that (1) it results in slightly faster function calls and (2) distribution of binaries is easier because no assumptions need be made regarding the availability of library code on users’ systems. Disadvantages of static linking include (1) larger resulting executables and (2) greater difficulty upgrading programs when library components change. Programs are more difficult to update because they must be relinked every time a library is changed. From a reverse engineering perspective, static linking complicates matters somewhat. If we are faced with the task of analyzing a statically linked binary, there is no easy way to answer the questions “Which libraries are linked into this binary?” and “Which of these functions is a library function?” <a href="ch13.xhtml#ch13">Chapter 13</a> discusses the challenges encountered while reverse engineering statically linked code.</p>
<span epub:type="pagebreak" id="page_23"/>
<p class="indent">Dynamic linking differs from static linking in that the linker has no need to make a copy of any required libraries. Instead, the linker simply inserts references to any required libraries (often <em>.so</em> or <em>.dll</em> files) into the final executable, usually resulting in much smaller executable files. Upgrading library code is much easier when dynamic linking is utilized. Since a single copy of a library is maintained and that copy is referenced by many binaries, replacing the single outdated library with a new version results in any new process based on a binary that dynamically links to that library using the updated version. One of the disadvantages of using dynamic linking is that it requires a more complicated loading process. All of the necessary libraries must be located and loaded into memory, as opposed to loading one statically linked file that happens to contain all of the library code. Another disadvantage of dynamic linking is that vendors must distribute not only their own executable file but also all library files upon which that executable depends. Attempting to execute a program on a system that does not contain all the required library files will result in an error.</p>
<p class="indent">The following output demonstrates the creation of dynamically and statically linked versions of a program, the size of the resulting binaries, and the manner in which <span class="literal">file</span> identifies those binaries:</p>
<p class="programs">ghidrabook# <span class="codestrong1">gcc -o ch2_example_dynamic ch2_example.c</span><br/>
ghidrabook# <span class="codestrong1">gcc -o ch2_example_static ch2_example.c -static</span><br/>
ghidrabook# <span class="codestrong1">ls -l ch2_example_*</span><br/>
  -rwxrwxr-x 1 ghidrabook ghidrabook  12944 Nov  7 10:07 ch2_example_dynamic<br/>
  -rwxrwxr-x 1 ghidrabook ghidrabook 963504 Nov  7 10:07 ch2_example_static<br/>
ghidrabook# <span class="codestrong1">file ch2_example_*</span><br/>
  ch2_example_dynamic: ELF 64-bit LSB executable, x86-64, version 1 (SYSV),<br/>
  dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0,<br/>
  BuildID[sha1]=e56ed40012accb3734bde7f8bca3cc2c368455c3, not stripped<br/>
  ch2_example_static:  ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux),<br/>
  statically linked, for GNU/Linux 3.2.0,<br/>
  BuildID[sha1]=430996c6db103e4fe76aea7d578e636712b2b4b0, not stripped<br/>
ghidrabook#</p>
<p class="indent">In order for dynamic linking to function properly, dynamically linked binaries must indicate which libraries they depend on, along with the specific resources required from each of those libraries. As a result, unlike statically linked binaries, it is quite simple to determine the libraries on which a dynamically linked binary depends. The <span class="literal">ldd</span> (<em>list dynamic dependencies</em>) utility is a tool used to list the dynamic libraries required by any executable. In the following example, <span class="literal">ldd</span> is used to determine the libraries on which the Apache web server depends:</p>
<p class="programs">ghidrabook# <span class="codestrong1">ldd /usr/sbin/apache2</span><br/>
  linux-vdso.so.1 =&gt;  (0x00007fffc1c8d000)<br/>
  libpcre.so.3 =&gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007fbeb7410000)<br/>
  libaprutil-1.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libaprutil-1.so.0 (0x00007fbeb71e0000)<br/>
  libapr-1.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libapr-1.so.0 (0x00007fbeb6fa0000)<br/>
  libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fbeb6d70000)<br/>
  libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbeb69a0000)<br/>
  libcrypt.so.1 =&gt; /lib/x86_64-linux-gnu/libcrypt.so.1 (0x00007fbeb6760000)<br/>
<span epub:type="pagebreak" id="page_24"/>
  libexpat.so.1 =&gt; /lib/x86_64-linux-gnu/libexpat.so.1 (0x00007fbeb6520000)<br/>
  libuuid.so.1 =&gt; /lib/x86_64-linux-gnu/libuuid.so.1 (0x00007fbeb6310000)<br/>
  libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fbeb6100000)<br/>
  /lib64/ld-linux-x86-64.so.2 (0x00007fbeb7a00000)<br/>
ghidrabook#</p>
<p class="indent">The <span class="literal">ldd</span> utility is available on Linux and BSD systems. On macOS systems, similar functionality is available using the <span class="literal">otool</span> utility with the <span class="literal">-L</span> option: <span class="literal">otool -L</span> <span class="codeitalic">filename</span>. On Windows systems, the <span class="literal">dumpbin</span> utility, part of the Visual Studio tool suite, can be used to list dependent libraries: <span class="literal">dumpbin /dependents</span> <span class="codeitalic">filename</span>.</p>
<div class="box5">
<p class="boxtitle-c"><strong>BEWARE YOUR TOOLS!</strong></p>
<p class="noindent">While <span class="literal">ldd</span> may appear to be a simple tool, the <span class="literal">ldd</span> man page states that “you should never employ <span class="literal">ldd</span> on an untrusted executable, since this may result in the execution of arbitrary code.” While this is unlikely in most cases, it provides a reminder that running even apparently simple software reverse engineering (SRE) tools may have unintended consequences when examining untrusted input files. While it is hopefully obvious that executing untrusted binaries is unlikely to be safe, it is wise to take precautions even when statically analyzing untrusted binaries, and to assume that the computer on which you perform SRE tasks, along with any data on it or other hosts connected to it, may be compromised as a result of SRE activities.</p>
</div>
<h4 class="h4" id="ch02lev36"><strong><em>objdump</em></strong></h4>
<p class="noindent">Whereas <span class="literal">ldd</span> is fairly specialized, <span class="literal">objdump</span> is extremely versatile. The purpose of <span class="literal">objdump</span> is to “display information from object files.”<sup><a id="ch02fn8a" href="footnotes.xhtml#ch02fn8">8</a></sup> This is a fairly broad goal, and to accomplish it, <span class="literal">objdump</span> responds to more than 30 command line options tailored to extract various pieces of information from object files. The <span class="literal">objdump</span> tool can be used to display the following data (and much more) related to object files:</p>
<p class="uln-indent"><strong>Section headers</strong> Summary information for each of the sections in the program file.</p>
<p class="uln-indent"><strong>Private headers</strong> Program memory layout information and other information required by the runtime loader, including a list of required libraries, such as that produced by <span class="literal">ldd</span>.</p>
<span epub:type="pagebreak" id="page_25"/>
<p class="uln-indent"><strong>Debugging information</strong> Any debugging information embedded in the program file.</p>
<p class="uln-indent"><strong>Symbol information</strong> Symbol table information, dumped in a manner similar to the <span class="literal">nm</span> utility.</p>
<p class="uln-indent"><strong>Disassembly listing</strong> The <span class="literal">objdump</span> tool performs a linear sweep disassembly of sections of the file marked as code. When disassembling x86 code, <span class="literal">objdump</span> can generate either AT&amp;T or Intel syntax, and the disassembly can be captured as a text file. Such a text file is called a disassembly <em>dead listing</em>, and while these files can certainly be used for reverse engineering, they are difficult to navigate effectively and even more difficult to modify in a consistent and error-free manner.</p>
<p class="indent">The <span class="literal">objdump</span> tool is available as part of the GNU binutils tool suite and can be found on Linux, FreeBSD, and Windows (via WSL or Cygwin).<sup><a id="ch02fn9a" href="footnotes.xhtml#ch02fn9">9</a></sup> Note that <span class="literal">objdump</span> relies on the <em>Binary File Descriptor library (libbfd)</em>, a component of binutils, to access object files and thus is capable of parsing file formats supported by libbfd (ELF and PE among others). For ELF-specific parsing, a utility named <span class="literal">readelf</span> is also available. The <span class="literal">readelf</span> utility offers most of the same capabilities as <span class="literal">objdump</span>, and the primary difference between the two is that <span class="literal">readelf</span> does not rely upon libbfd.</p>
<h4 class="h4" id="ch02lev37"><strong><em>otool</em></strong></h4>
<p class="noindent">The <span class="literal">otool</span> utility is most easily described as an <span class="literal">objdump</span>-like option for macOS, and it is useful for parsing information about macOS Mach-O binaries. The following listing demonstrates how <span class="literal">otool</span> displays the dynamic library dependencies for a Mach-O binary, thus performing a function similar to <span class="literal">ldd</span>:</p>
<p class="programs">ghidrabook# <span class="codestrong1">file osx_example</span><br/>
  osx_example: Mach-O 64-bit executable x86_64<br/>
ghidrabook# <span class="codestrong1">otool -L osx_example</span><br/>
  osx_example:<br/>
    /usr/lib/libstdc++.6.dylib (compatibility version 7.0.0, current version 7.4.0)<br/>
    /usr/lib/libgcc_s.1.dylib (compatibility version 1.0.0, current version 1.0.0)<br/>
    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1281.0.0)</p>
<p class="indent">The <span class="literal">otool</span> utility can be used to display information related to a file’s headers and symbol tables and to perform disassembly of the file’s code section. For more information regarding the capabilities of <span class="literal">otool</span>, please refer to the associated man page.</p>
<h4 class="h4" id="ch02lev38"><strong><em>dumpbin</em></strong></h4>
<p class="noindent">The <span class="literal">dumpbin</span> command line utility is included with Microsoft’s Visual Studio suite of tools. Like <span class="literal">otool</span> and <span class="literal">objdump</span>, <span class="literal">dumpbin</span> is capable of displaying a wide range of information related to Windows PE files. The following listing <span epub:type="pagebreak" id="page_26"/>shows how <span class="literal">dumpbin</span> displays the dynamic dependencies of the Windows notepad program in a manner similar to <span class="literal">ldd</span>:</p>
<p class="programs">$ <span class="codestrong1">dumpbin /dependents C:\Windows\System32\notepad.exe</span><br/>
Microsoft (R) COFF/PE Dumper<br/>
Copyright (C) Microsoft Corporation.  All rights reserved.<br/><br/>
Dump of file notepad.exe<br/><br/>
File Type: EXECUTABLE IMAGE<br/><br/>
  Image has the following delay load dependencies:<br/><br/>
    ADVAPI32.dll<br/>
    COMDLG32.dll<br/>
    PROPSYS.dll<br/>
    SHELL32.dll<br/>
    WINSPOOL.DRV<br/>
    urlmon.dll<br/><br/>
  Image has the following dependencies:<br/><br/>
    GDI32.dll<br/>
    USER32.dll<br/>
    msvcrt.dll<br/>
    ...</p>
<p class="indent">Additional <span class="literal">dumpbin</span> options offer the ability to extract information from various sections of a PE binary, including symbols, imported function names, exported function names, and disassembled code. Additional information related to the use of <span class="literal">dumpbin</span> is available via the Microsoft website.<sup><a id="ch02fn10a" href="footnotes.xhtml#ch02fn10">10</a></sup></p>
<h4 class="h4" id="ch02lev39"><strong><em>c++filt</em></strong></h4>
<p class="noindent">Languages that allow function overloading must have a mechanism for distinguishing among the many overloaded versions of a function since each version has the same name. The following C++ example shows the prototypes for several overloaded versions of a function named <span class="literal">demo</span>:</p>
<p class="programs">void demo(void);<br/>
void demo(int x);<br/>
void demo(double x);<br/>
void demo(int x, double y);<br/>
void demo(double x, int y);<br/>
void demo(char* str);</p>
<p class="indent">As a general rule, it is not possible to have two functions with the same name in an object file. To allow overloading, compilers derive unique names for overloaded functions by incorporating information describing the type sequence of the function arguments. The process of deriving unique names <span epub:type="pagebreak" id="page_27"/>for functions with identical names is called <em>name mangling</em>.<sup><a id="ch02fn11a" href="footnotes.xhtml#ch02fn11">11</a></sup> If we use <span class="literal">nm</span> to dump the symbols from the compiled version of the preceding C++ code, we might see something like the following (filtered to focus on versions of <span class="literal">demo</span>):</p>
<p class="programs">ghidrabook# <span class="codestrong1">g++ -o ch2_cpp_example ch2_cpp_example.cc</span><br/>
ghidrabook# <span class="codestrong1">nm ch2_cpp_example | grep demo</span><br/>
  000000000000060b T _Z4demod<br/>
  0000000000000626 T _Z4demodi<br/>
  0000000000000601 T _Z4demoi<br/>
  0000000000000617 T _Z4demoid<br/>
  0000000000000635 T _Z4demoPc<br/>
  00000000000005fa T _Z4demov</p>
<p class="indent">The C++ standard does not define a standard name mangling scheme, leaving compiler designers to develop their own. To decipher the mangled variants of <span class="literal">demo</span> shown here, we need a tool that understands our compiler’s (<span class="literal">g++</span> in this case) name mangling scheme. This is precisely the purpose of <span class="literal">c++filt</span>. This utility treats each input word as if it were a mangled name and then attempts to determine the compiler that was used to generate that name. If the name appears to be a valid mangled name, it outputs the demangled version of the name. When <span class="literal">c++filt</span> does not recognize a word as a mangled name, it simply outputs the word with no changes.</p>
<p class="indent">If we pass the results of <span class="literal">nm</span> from the preceding example through <span class="literal">c++filt</span>, it is possible to recover the demangled function names, as seen here:</p>
<p class="programs">ghidrabook# <span class="codestrong1">nm ch2_cpp_example | grep demo | c++filt</span><br/>
  000000000000060b T demo(double)<br/>
  0000000000000626 T demo(double, int)<br/>
  0000000000000601 T demo(int)<br/>
  0000000000000617 T demo(int, double)<br/>
  0000000000000635 T demo(char*)<br/>
  00000000000005fa T demo()</p>
<p class="indent">It is important to note that mangled names contain additional information about functions that <span class="literal">nm</span> does not normally provide. This information can be extremely helpful in reverse engineering situations, and in more complex cases, this extra information may include data regarding class names or function-calling conventions.</p>
<h3 class="h3" id="ch02lev40"><strong>Deep Inspection Tools</strong></h3>
<p class="noindent">So far, we have discussed tools that perform a cursory analysis of files based on minimal knowledge of those files’ internal structure. We have also seen tools capable of extracting specific pieces of data from files based on very detailed knowledge of a file’s structure. In this section, we discuss tools <span epub:type="pagebreak" id="page_28"/>designed to extract specific types of information independently of the type of file being analyzed.</p>
<h4 class="h4" id="ch02lev41"><strong><em>strings</em></strong></h4>
<p class="noindent">It is occasionally useful to ask more generic questions regarding file content—<br/>questions that don’t necessarily require any specific knowledge of a file’s structure. One such question is “Does this file contain any embedded strings?” Of course, we must first answer the question “What exactly constitutes a string?” Let’s loosely define a <em>string</em> as a consecutive sequence of printable characters. This definition is often augmented to specify a minimum length and a specific character set. Thus, we could specify a search for all sequences of at least four consecutive ASCII printable characters and print the results to the console. Searches for such strings are generally not limited in any way by the structure of a file. You can search for strings in an ELF binary just as easily as you can search for strings in a Microsoft Word document.</p>
<p class="indent">The <span class="literal">strings</span> utility is designed specifically to extract string content from files, often without regard for the format of those files. Using <span class="literal">strings</span> with its default settings (7-bit ASCII sequences of at least four characters) might yield something like the following:</p>
<p class="programs">ghidrabook# <span class="codestrong1">strings ch2_example</span><br/>
  /lib64/ld-linux-x86-64.so.2<br/>
  libc.so.6<br/>
  exit<br/>
  srand<br/>
  __isoc99_scanf<br/>
  puts<br/>
  time<br/>
  __stack_chk_fail<br/>
  printf<br/>
  stderr<br/>
  fwrite<br/>
  __libc_start_main<br/>
  GLIBC_2.7<br/>
  GLIBC_2.4<br/>
  GLIBC_2.2.5<br/>
  _ITM_deregisterTMCloneTable<br/>
  __gmon_start__<br/>
  _ITM_registerTMCloneTable<br/>
  usage: ch4_example [max]<br/>
  A simple guessing game!<br/>
  Please guess a number between 1 and %d.<br/>
  Invalid input, quitting!<br/>
  Congratulations, you got it in %d attempt(s)!<br/>
  Sorry too low, please try again<br/>
  Sorry too high, please try again<br/>
  GCC: (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0<br/>
  ...</p>
<span epub:type="pagebreak" id="page_29"/>
<div class="box5">
<p class="boxtitle-c"><strong>WHY DID STRINGS CHANGE?</strong></p>
<p class="noindent">Historically, when <span class="literal">strings</span> was used on executable files, it would, by default, search only for character sequences in the loadable, initialized data sections of the binary file. This required that <span class="literal">strings</span> parse the binary file to find those sections, using libraries such as libbfd. When it was used for parsing untrusted binaries, vulnerabilities in libraries could potentially result in arbitrary code execution.<sup><a id="ch02fn12a" href="ch02.xhtml#ch02fn12">12</a></sup> As a result, the default behavior for <span class="literal">strings</span> was changed to examine the entire binary file without parsing for loadable initialized data sections (synonymous with the use of the <span class="literal">-a</span> flag.) The historical behavior can be invoked using the <span class="literal">-d</span> flag.</p>
<p class="footnote"><a id="ch02fn12" href="ch02.xhtml#ch02fn12a">12</a>. See CVE-2014-8485 and <em><a href="https://lcamtuf.blogspot.com/2014/10/psa-dont-run-strings-on-untrusted-files.html">https://lcamtuf.blogspot.com/2014/10/psa-dont-run-strings-on-untrusted-files.html</a></em>.</p>
</div>
<p class="indent">Unfortunately, while we see some strings that look like they might be output by the program, other strings appear to be function names and library names. We should be careful not to jump to any conclusions regarding the behavior of the program. Analysts often fall into the trap of attempting to deduce the behavior of a program based on the output of <span class="literal">strings</span>. Remember, the presence of a string within a binary in no way indicates that the string is ever used in any manner by that binary.</p>
<p class="indent">Here are some final notes on the use of <span class="literal">strings</span>:</p>
<ul>
<li class="noindent">By default, <span class="literal">strings</span> gives no indication of where, within a file, a string is located. Use the <span class="literal">-t</span> command line argument to have <span class="literal">strings</span> print file offset information for each string found.</li>
<li class="noindent">Many files utilize alternate character sets. Utilize the <span class="literal">-e</span> command line argument to cause <span class="literal">strings</span> to search for wide characters such as 16-bit Unicode.</li>
</ul>
<h4 class="h4" id="ch02lev42"><strong><em>Disassemblers</em></strong></h4>
<p class="noindent">As mentioned earlier, tools are available to generate dead listing–style disassemblies of binary object files. PE, ELF, and Mach-O binaries can be disassembled using <span class="literal">dumpbin</span>, <span class="literal">objdump</span>, and <span class="literal">otool</span>, respectively. None of those, however, can deal with arbitrary blocks of binary data. You will occasionally be confronted with a binary file that does not conform to a widely used file format, in which case you will need tools capable of beginning the disassembly process at user-specified offsets.</p>
<p class="indent">Two examples of such <em>stream disassemblers</em> for the x86 instruction set are <span class="literal">ndisasm</span> and <span class="literal">diStorm</span>.<sup><a id="ch02fn13a" href="footnotes.xhtml#ch02fn13">13</a></sup> The utility <span class="literal">ndisasm</span> is included with the NASM.<sup><a id="ch02fn14a" href="footnotes.xhtml#ch02fn14">14</a></sup> <span epub:type="pagebreak" id="page_30"/>The following example illustrates the use of <span class="literal">ndisasm</span> to disassemble a piece of shellcode generated using the Metasploit framework:<sup><a id="ch02fn15a" href="footnotes.xhtml#ch02fn15">15</a></sup></p>
<p class="programs">ghidrabook#  <span class="codestrong1">msfvenom -p linux/x64/shell_find_port -f raw &gt; findport</span><br/>
ghidrabook#  <span class="codestrong1">ndisasm –b 64 findport</span><br/>
  00000000  4831FF            xor rdi,rdi<br/>
  00000003  4831DB            xor rbx,rbx<br/>
  00000006  B314              mov bl,0x14<br/>
  00000008  4829DC            sub rsp,rbx<br/>
  0000000B  488D1424          lea rdx,[rsp]<br/>
  0000000F  488D742404        lea rsi,[rsp+0x4]<br/>
  00000014  6A34              push byte +0x34<br/>
  00000016  58                pop rax<br/>
  00000017  0F05              syscall<br/>
  00000019  48FFC7            inc rdi<br/>
  0000001C  66817E024A67      cmp word [rsi+0x2],0x674a<br/>
  00000022  75F0              jnz 0x14<br/>
  00000024  48FFCF            dec rdi<br/>
  00000027  6A02              push byte +0x2<br/>
  00000029  5E                pop rsi<br/>
  0000002A  6A21              push byte +0x21<br/>
  0000002C  58                pop rax<br/>
  0000002D  0F05              syscall<br/>
  0000002F  48FFCE            dec rsi<br/>
  00000032  79F6              jns 0x2a<br/>
  00000034  4889F3            mov rbx,rsi<br/>
  00000037  BB412F7368        mov ebx,0x68732f41<br/>
  0000003C  B82F62696E        mov eax,0x6e69622f<br/>
  00000041  48C1EB08          shr rbx,byte 0x8<br/>
  00000045  48C1E320          shl rbx,byte 0x20<br/>
  00000049  4809D8            or rax,rbx<br/>
  0000004C  50                push rax<br/>
  0000004D  4889E7            mov rdi,rsp<br/>
  00000050  4831F6            xor rsi,rsi<br/>
  00000053  4889F2            mov rdx,rsi<br/>
  00000056  6A3B              push byte +0x3b<br/>
  00000058  58                pop rax<br/>
  00000059  0F05              syscall<br/>
ghidrabook#</p>
<p class="indent">The flexibility of stream disassembly is useful in many situations. One scenario involves the analysis of computer network attacks in which network packets may contain shellcode. Stream disassemblers can be used to disassemble the portions of the packet that contain shellcode in order to analyze the behavior of the malicious payload. Another situation involves the analysis of ROM images for which no layout reference can be located. Portions of the ROM will contain data, while other portions will contain code. Stream disassemblers can be used to disassemble just those portions of the image thought to be code.</p>
<span epub:type="pagebreak" id="page_31"/>
<h3 class="h3" id="ch02lev43"><strong>Summary</strong></h3>
<p class="noindent">The tools discussed in this chapter are not necessarily the best of their breed. They do, however, represent tools commonly available for anyone who wishes to reverse engineer binary files. More important, they represent the types of tools that motivated much of the development of Ghidra. In future chapters, we occasionally highlight stand-alone tools that provide functionality similar to that integrated into Ghidra. An awareness of these tools will greatly enhance your understanding of the Ghidra user interface and the many informational displays that Ghidra offers.</p>
<span epub:type="pagebreak" id="page_32"/>
</div>



  </body></html>