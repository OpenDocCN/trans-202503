- en: '![Image](../images/pg017-01.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg017-01.jpg)'
- en: '2'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: 'Herding Cats: Your First PuzzleScript Game'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 牧猫游戏：你的第一个 PuzzleScript 游戏
- en: In this chapter, we’ll make our own PuzzleScript game. Specifically, it will
    be a game about herding cats. (You can never have too many games about cats. Remember
    that when you’re a famous game designer.) You can play it at *[https://w.itch.io/herding-cats/](https://w.itch.io/herding-cats/)*.
    After you’ve played the game, we’ll go over how to make it!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将制作我们自己的 PuzzleScript 游戏。具体来说，它将是一个关于牧猫的游戏。（关于猫的游戏永远不会太多。记住这一点，当你成为一位著名的游戏设计师时。）你可以在
    *[https://w.itch.io/herding-cats/](https://w.itch.io/herding-cats/)* 玩这个游戏。玩完游戏后，我们将讲解如何制作它！
- en: '![Image](../images/pg018-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg018-01.jpg)'
- en: In *Herding Cats*, your goal is to make friends with all the different cats
    in each level. Press **X** on your keyboard to start, and then use the arrow keys
    on your keyboard to move around. You can use the **Z** key to rewind time if you
    make a mistake and want to redo your moves. Press **R** to restart the level you’re
    on. (Most PuzzleScript games use the same keys to play a game.)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *牧猫游戏* 中，你的目标是与每一关中的不同猫咪成为朋友。按键盘上的 **X** 键开始，然后使用键盘上的箭头键进行移动。如果你犯了错误并想重做动作，可以按
    **Z** 键倒回时间。按 **R** 键重新开始当前关卡。（大多数 PuzzleScript 游戏都使用相同的按键来玩游戏。）
- en: At the start of each level, all the cats will be sleeping. When you wake up
    a cat, it’ll start following you. A woken cat will follow you everywhere, but
    it can make it hard to fit through some spots.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一关的开始时，所有的猫都会在睡觉。当你叫醒一只猫时，它会开始跟着你走。一只被叫醒的猫会跟随你到处走，但这可能会让你在某些地方卡住。
- en: The game can get tricky. You don’t have to solve every level to read the rest
    of the chapter! Just get a feel for how the game works.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏可能会变得棘手。你不必解决每一关才能继续阅读章节！只要对游戏的运作方式有个大致了解即可。
- en: Opening a Blank Project
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开一个空白项目
- en: Let’s start with a blank game. Navigate to *[https://www.puzzlescript.net/](https://www.puzzlescript.net/)*
    and click **Make A Game**. Clear your PuzzleScript work area by clicking the **Load
    Example** drop-down menu at the top of PuzzleScript and selecting **Blank Project**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个空白游戏开始。前往 *[https://www.puzzlescript.net/](https://www.puzzlescript.net/)*
    并点击 **制作游戏**。通过点击 PuzzleScript 顶部的 **加载示例** 下拉菜单并选择 **空白项目** 来清除你的 PuzzleScript
    工作区。
- en: '![Image](../images/pg019-01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg019-01.jpg)'
- en: You should see a totally blank PuzzleScript project like this.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个完全空白的 PuzzleScript 项目，像这样。
- en: '![Image](../images/pg019-02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg019-02.jpg)'
- en: 'Next, you’ll add a game title and your name at the top of the script, above
    `OBJECTS`. Click at the start of the very first line and press ENTER three times
    to move the `OBJECTS` section down to make room, and then add these lines:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将在脚本的顶部，`OBJECTS` 之前添加游戏标题和你的名字。点击第一行的开头，按三次 ENTER 键，将 `OBJECTS` 部分向下移动腾出空间，然后添加以下几行：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The result should look something like this.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该像这样。
- en: '![Image](../images/pg020-01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg020-01.jpg)'
- en: If you make a mistake and need to undo it, hold down the CTRL key and press
    **Z**. CTRL-Z is almost universally the undo shortcut in the tools you’ll work
    with.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你犯了错误并需要撤销，按住 CTRL 键并按 **Z**。在你将使用的工具中，CTRL-Z 几乎是通用的撤销快捷键。
- en: Now let’s look at how to create objects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何创建物体。
- en: Creating Objects
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建物体
- en: Every object in your game has to look like something. An object’s appearance
    gives the player important information about what it does. For example, in the
    *Simple Block Pushing Game*, all the pushable objects look like boxes with flat,
    easy-to-push sides. The player has arms, showing that they can push objects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的每个物体都必须看起来像某种东西。物体的外观给玩家提供了关于它作用的重要信息。例如，在 *简单推箱子游戏* 中，所有可推动的物体看起来像是有平坦且易于推动的侧面的盒子。玩家有手臂，表示他们可以推动物体。
- en: PuzzleScript lets you use pixels to draw objects. A *pixel* (a combination of
    the words *picture element*) is just a single dot of color. PuzzleScript objects
    are 5 pixels wide by 5 pixels tall—25 pixels in total. For example, here’s a door
    I drew.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: PuzzleScript 让你使用像素来绘制物体。*像素*（由*picture element*一词组成）只是一个单独的颜色点。PuzzleScript
    中的物体宽度为 5 像素，高度为 5 像素，总共 25 像素。例如，这是我绘制的一个门。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The pictures you draw are made up of numbers; each number represents a single
    pixel. Which number the pixel is corresponds to the color you want the pixel to
    be.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你画出的图片是由数字组成的；每个数字代表一个像素。像素对应的数字与我们想要该像素显示的颜色有关。
- en: From top to bottom, you see the name of the object on the first line (`Door`),
    the colors I want on the second line, and then numbers for the 25 pixels below
    that. Because I want a brown door with a white frame and a blue doorknob, I enter
    those colors on the second line as `Brown White Blue`. These words should display
    in their colors as you type them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从上到下，你会看到第一行是物体的名称（`Door`），第二行是我想要的颜色，然后是下方的25个像素的数字。因为我想要一扇棕色的门、一个白色的框架和一个蓝色的门把手，所以我在第二行输入这些颜色为`Brown
    White Blue`。当你输入这些单词时，它们应该显示为对应的颜色。
- en: Next, I use the numbers representing each color to enter where the colors go,
    one pixel at a time. Computers start counting at 0, so the first color I enter,
    `Brown`, is color `0`, `White` is color `1`, and `Blue` is color `2`. The numbers
    representing each color will also display in those colors, so you can imagine
    what your rendered drawing will look like as you enter the colors. (Keep in mind
    that in this `Door` example, if you try to enter a number higher than 2, such
    as 3 or 4, the number will display as white because you’ve defined the colors
    using only the numbers 0, 1, and 2.)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我使用表示每种颜色的数字逐个像素地输入颜色的位置。计算机从0开始计数，所以我输入的第一个颜色`Brown`是颜色`0`，`White`是颜色`1`，`Blue`是颜色`2`。每种颜色所代表的数字也会显示为相应的颜色，因此你可以想象当你输入颜色时，渲染出来的图像是什么样子。（请记住，在这个`Door`示例中，如果你尝试输入大于2的数字，比如3或4，数字将显示为白色，因为你只用0、1和2来定义颜色。）
- en: '**NOTE:** If you have a hard time remembering that computers start counting
    at 0, think of a bunch of people standing in line for the bathroom. If I’m at
    the front of the line, how many people are in front of me? Zero! If I’m right
    behind the person at the front of the line, how many people are in front of me?
    One! The next person is 2, the next is 3, and the next is 4\. Five people in line
    would be numbered 0, 1, 2, 3, and 4.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** 如果你很难记住计算机从0开始计数，可以想象一群人排队等厕所。如果我站在队伍最前面，前面有多少人？零！如果我站在队伍前面那个人后面，前面有多少人？一个！接下来是2，3，再接下来是4。排队的五个人编号为0、1、2、3和4。'
- en: '*Herding Cats* needs some objects, so let’s draw them now!'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*Herding Cats*需要一些物体，现在让我们开始绘制它们！'
- en: Drawing the Background
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制背景
- en: 'To draw objects in *Herding Cats*, we first need a `Background`. Every PuzzleScript
    game must have a background. Let’s draw one that looks like grass at the beginning
    of the `OBJECTS` section:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Herding Cats*中绘制物体时，我们首先需要一个`Background`。每个PuzzleScript游戏必须有一个背景。让我们在`OBJECTS`部分开始绘制一个看起来像草的背景：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The zeros are dark green and the ones are regular green. I’ve scattered them
    around like little blades of grass because I’m trying to create an image that,
    when repeated, will just create a big field strewn here and there with grass.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 零是深绿色，一是普通绿色。我把它们分散开，像小草一样，因为我想创建一个图像，当它重复时，会呈现出一个到处散布着草的小田野。
- en: Remember that with this code we’re drawing just one square of grass that is
    five pixels wide by five pixels tall. But we’ll never see just one square of grass
    in the game; instead, we’ll see a bunch of these background squares, like this.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在这段代码中，我们只画了一个宽5像素、高5像素的草地方块。但在游戏中我们永远不会只看到一个草地方块，而是会看到许多这样的背景方块，就像这样。
- en: '![Image](../images/pg023-01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg023-01.jpg)'
- en: Now we’ll add some walls in the `OBJECTS` section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在`OBJECTS`部分添加一些墙壁。
- en: Drawing Walls
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制墙壁
- en: 'To draw the walls with a stacked brick pattern and make them look more like
    brick walls, use `Red` for the bricks and `DarkBrown` for the mortar between them.
    Then fill out the pixels so the brown mortar crisscrosses the red bricks:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了画出带有堆叠砖块图案的墙壁，并让它们看起来更像砖墙，可以使用`Red`作为砖块的颜色，`DarkBrown`作为砖缝的颜色。然后填充像素，使棕色的砂浆交错于红色砖块之间：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Mine has four bricks, but you can make your wall look however you want. When
    there are a bunch of these chunks onscreen, it’ll look like one big, continuous
    brick wall.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我的墙有四块砖，但你可以让你的墙看起来任何你想要的样子。当这些块出现在屏幕上时，它会看起来像是一面连续的砖墙。
- en: Before we can see what our walls actually look like in the game, we need to
    add a few more requirements to the `LEGEND` section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际看到墙壁在游戏中的样子之前，我们需要在`LEGEND`部分添加更多的要求。
- en: Adding the Background and Wall to the Legend
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将背景和墙壁添加到图例中
- en: 'Any object we want to appear at the start of a level needs to have a symbol
    in the `LEGEND` section. For now, add a symbol for the background and the walls:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 任何我们希望在关卡开始时出现的物体都需要在`LEGEND`部分有一个符号。现在，为背景和墙壁添加符号：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I chose the **.** as the symbol for background tiles because it has a lot of
    empty space around it. Conversely, I picked the `#` to represent walls because
    it’s dense, square, and wall-like. Try to choose symbols that remind you of the
    objects they represent so you can tell at a glance what a level looks like.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择**.**作为背景瓦片的符号，因为它周围有很多空白空间。相反，我选择了`#`来表示墙壁，因为它密集、方正，像墙壁一样。尽量选择让你联想到对象的符号，这样你一眼就能看出关卡的样子。
- en: Creating the Collision Layers
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建碰撞层
- en: 'Whenever we add an object to our game, we have to remember to add it to the
    `COLLISIONLAYERS` section as well! Let’s add our wall object like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们向游戏中添加一个对象时，记得也要将它添加到`COLLISIONLAYERS`部分！让我们这样添加我们的墙对象：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Each line in the `COLLISIONLAYERS` section represents a separate layer. The
    `Background` gets its own layer. Everything else—the walls, the player, and the
    cats—will be on a second collision layer. If walls and cats weren’t on the same
    layer, cats could walk through walls. That would be impressive, even for a cat.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`COLLISIONLAYERS`部分中的每一行代表一个独立的层。`Background`有自己的层。其他所有东西——墙壁、玩家和猫——将位于第二个碰撞层。如果墙壁和猫不在同一层，猫就能穿过墙壁。那样的话，猫也太厉害了，甚至可以惊艳。'
- en: '![Image](../images/pg025-01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg025-01.jpg)'
- en: Creating a Sample Level
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个示例关卡
- en: 'Now that we’ve added the wall to the `LEGEND` and the `COLLISIONLAYERS` sections,
    let’s make a sample level in the `LEVELS` section just to see what our `Background`
    and `Wall` objects look like. Use the symbols for the background and wall to create
    a level:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将墙壁添加到`LEGEND`和`COLLISIONLAYERS`部分，让我们在`LEVELS`部分创建一个示例关卡，看看我们的`Background`和`Wall`对象是什么样子。使用背景和墙壁的符号来创建一个关卡：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Click **Run** and then press the **X** on your keyboard to see the level we
    just drew. I made my wall very squiggly so I can really get an idea of how my
    walls look in use.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**运行**，然后按下键盘上的**X**键，查看我们刚刚绘制的关卡。我将我的墙画得非常弯曲，这样我就能真正了解墙在使用中的样子。
- en: '![Image](../images/pg026-01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg026-01.jpg)'
- en: Now that you can see what your background and walls look like, you might want
    to change them. When you make changes to any object’s appearance and then click
    **Rebuild**, your sample level will update to show the new look. This is a great
    way to keep track of what your objects look like as you work on them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到背景和墙壁的样子了，你可能想要更改它们。每当你更改任何对象的外观后，点击**重建**，你的示例关卡会更新并展示新外观。这是跟踪你在工作中修改的对象外观的好方法。
- en: Drawing the Player
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制玩家
- en: Now we need a player character. In the `OBJECTS` section, I drew a player with
    pink hair, a white dress, and two little hands. (That’s what I was trying to draw,
    anyway.) You can make your player look the way you want by choosing colors and
    filling pixels with those colors. But notice the gray periods (`.`) in the drawing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个玩家角色。在`OBJECTS`部分，我画了一个有粉色头发、白色裙子和两只小手的玩家（反正我是这么画的）。你可以通过选择颜色并用这些颜色填充像素来让你的玩家看起来像你想要的样子。但注意图中灰色的点（`.`）。
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When you’re drawing objects in PuzzleScript, a period (`.`) in the code means
    that a pixel is transparent. Where there’s a period, you’ll see through that part
    of the object to whatever is behind it (which is usually the background).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在PuzzleScript中绘制对象时，代码中的点（`.`）表示一个像素是透明的。在点所在的位置，你将能够看到透过该部分的背景（通常是背景）。
- en: We don’t need to have see-through pixels on the background, because there’s
    nothing behind it. Also, we don’t really need to see through the walls because
    the walls can be square. But the player isn’t square, so we fill in the unused
    parts of their picture with see-through pixels.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 背景上不需要有透明像素，因为背景后面没有东西。而且，我们也不需要看到墙壁后面的内容，因为墙壁本身是方形的。但玩家不是方形的，所以我们会用透明像素填充他们图像中未使用的部分。
- en: '![Image](../images/pg027-01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg027-01.jpg)'
- en: Whenever something moves around (like the player), it’s a good idea to give
    it a see-through background so we can tell what it’s moving around on. Earlier
    I mentioned trying to show what objects can do by using their appearance. For
    example, a player standing on top of the grass looks like it can move, whereas
    the rigid, square walls that don’t share any space with the background look fixed
    in place.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每当某个物体移动时（比如玩家），给它一个透明的背景是个好主意，这样我们就能知道它在什么地方移动。之前我提到过，通过物体的外观来显示它们可以做什么。例如，玩家站在草地上看起来可以移动，而那些与背景没有任何重叠的僵硬方形墙壁看起来像是固定不动的。
- en: Drawing Cats
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制猫
- en: 'Last and most important, we need to add our cats. Let’s think about the cats
    in *Herding Cats*. What do they do? Well, when they’re awake, they follow the
    player around, but when they’re asleep, they just sleep until someone wakes them
    up. To make *Herding Cats* work the way we want it to, we need two different kinds
    of cats: one that stays in place, which we’ll call `SleepingCat`, and another
    that follows the player, which we’ll call `AwakeCat`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后也是最重要的，我们需要添加我们的猫。让我们思考一下 *Herding Cats* 中的猫。它们做什么？当它们清醒时，它们会跟着玩家走，而当它们睡觉时，它们就睡着，直到有人把它们叫醒。为了让
    *Herding Cats* 按照我们想要的方式运作，我们需要两种不同类型的猫：一种是固定不动的，我们称之为 `SleepingCat`，另一种是跟随玩家的，我们称之为
    `AwakeCat`。
- en: '![Image](../images/pg028-01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg028-01.jpg)'
- en: We’ll start by drawing two different objects in the `OBJECTS` section to create
    the two basic types of cats.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `OBJECTS` 部分绘制两个不同的对象，创建两种基本类型的猫。
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The sleeping cat is lying down. As with most sleeping cats, you can’t see its
    legs because they’re tucked underneath. This cat looks stationary. But the awake
    cat is standing up, ready to follow the player.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 睡觉的猫躺着。和大多数睡觉的猫一样，你看不见它的腿，因为它们都藏在下面。这只猫看起来是静止的。但清醒的猫站立着，准备跟随玩家。
- en: '![Image](../images/pg029-01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg029-01.jpg)'
- en: Click **Save** at the top of the screen to save your work so far. It’s a good
    idea to save often in case you accidentally close the window, your computer crashes,
    or your cat jumps on your keyboard. (If you’ve saved your game, you can click
    the **Load** menu next to the Save button to load the saved version of your game.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 点击屏幕顶部的 **保存** 按钮保存目前为止的工作。建议经常保存，以防你不小心关闭了窗口，或者电脑崩溃，或者猫跳到键盘上。（如果你已经保存了游戏，可以点击
    **加载** 菜单，在保存按钮旁边加载已保存的游戏版本。）
- en: This would be a good time to take another break, pet another cat, or make another
    sandwich. See you in a minute!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是休息一下、抚摸另一只猫或做个三明治的好时机。待会见！
- en: Using Your Objects
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用你的对象
- en: 'Before we can use our new objects, we need to tell PuzzleScript what to do
    with them by adding them to the `LEGEND` and `COLLISIONLAYERS` sections of our
    code. Go to the legend and pick a symbol for the player and the sleeping cat objects,
    as shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用新对象之前，我们需要告诉 PuzzleScript 如何处理这些对象，通过将它们添加到代码的 `LEGEND` 和 `COLLISIONLAYERS`
    部分。进入图例，为玩家和睡觉的猫对象选择一个符号，如下所示：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Image](../images/pg030-01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg030-01.jpg)'
- en: There’s no symbol for the `AwakeCat` object because the legend gives PuzzleScript
    a list of all the objects we want to build our levels from. I picked `m` for the
    `SleepingCat` because it looks like a little cat sitting down with its legs tucked
    under. (Cute, right?) Because all the levels start with all the cats asleep, we
    have only sleeping cats at the beginning of a level. The awake cats appear only
    when a sleeping cat awakens!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`AwakeCat` 对象没有符号，因为图例为 PuzzleScript 提供了我们希望用来构建关卡的所有对象列表。我为 `SleepingCat`
    选择了 `m`，因为它看起来像是一只小猫坐着，腿弯曲在下面。（很可爱，对吧？）由于所有关卡一开始猫都在睡觉，所以在关卡开始时只有睡觉的猫。只有当一只睡觉的猫醒来时，清醒的猫才会出现！'
- en: Adding More Collision Layers
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加更多的碰撞层
- en: 'We’ll need only two collision layers for our objects: the `Background` and
    everything else. Add the following lines to the `COLLISIONLAYERS` section. Next,
    we’ll want to add the player and both kinds of cats to the `COLLISIONLAYERS` section.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要为我们的物体设置两个碰撞层：`Background` 和其他所有物体。将以下几行添加到 `COLLISIONLAYERS` 部分。接下来，我们要将玩家和两种猫添加到
    `COLLISIONLAYERS` 部分。
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The background is on its own layer, and everything else moves around on top
    of it. The player, sleeping cat, awake cat, and wall are on the same layer so
    they can bump into each other and get in each other’s way. Otherwise, they wouldn’t
    be able to bump into each other. Walls aren’t really walls if you can walk right
    through them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 背景位于单独的图层上，其他所有物体都在它上面移动。玩家、睡觉的猫、清醒的猫和墙壁都在同一图层上，这样它们才能互相碰撞并妨碍彼此。否则，它们将无法相互碰撞。如果你可以直接穿过墙壁，那么墙壁就不算真正的墙壁了。
- en: Next, we need to update our test level. But before we do, save your work!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新我们的测试关卡。但是在此之前，先保存你的工作！
- en: Creating a Test Level
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个测试关卡
- en: 'Let’s create a test level to make sure everything in our game works the way
    we expect it to. Enter something similar to the following code in the `LEVELS`
    section, making sure the level contains every object in the legend: `Wall` (`#`),
    `SleepingCat` (`m`), one `Player` (`p`), and `Background` spaces (`.`). Be sure
    to add a wall somewhere in the middle, too, not just around the edges!'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个测试关卡，以确保我们游戏中的一切都按预期工作。在`LEVELS`部分输入类似以下的代码，确保关卡包含图例中的每个对象：`Wall`（`#`）、`SleepingCat`（`m`）、一个`Player`（`p`）和`Background`空间（`.`）。一定要在中间添加一堵墙，而不仅仅是在边缘！
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Click **Save** and then click **Run**. You should see the game’s title screen
    appear in the window at the right side of the screen, as shown here.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**Save**，然后点击**Run**。你应该能看到游戏的标题屏幕出现在屏幕右侧的窗口中，如图所示。
- en: '![Image](../images/pg031-01.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg031-01.jpg)'
- en: Now press **X** on your keyboard to start the game. You should see the test
    level that you created.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按下键盘上的**X**键开始游戏。你应该能看到你创建的测试关卡。
- en: '![Image](../images/pg032-01.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg032-01.jpg)'
- en: Cool! Now test your level by moving the player with the arrow keys. The player
    should move but not through walls or cats. Make sure that all objects are working
    correctly. The cats will just sit there because we haven’t added rules to tell
    them what to do yet.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 酷！现在通过箭头键移动玩家来测试你的关卡。玩家应该能够移动，但不能穿过墙壁或猫。确保所有物体都正常工作。猫会待在那里，因为我们还没有添加规则告诉它们该做什么。
- en: Creating Rules for Cats
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为猫创建规则
- en: 'Now we’ll add a rule that states when a `Player` object touches a `SleepingCat`
    object, the sleeping cat should wake up and become an `AwakeCat` object. Add this
    rule to the `RULES` section of your code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加一条规则，声明当`Player`对象接触到`SleepingCat`对象时，沉睡的猫应该醒来并变成`AwakeCat`对象。将此规则添加到你的代码的`RULES`部分：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This rule means if the `Player` is next to a `SleepingCat`, change them to a
    `Player` next to an `AwakeCat`. Click **Rebuild** at the top of the PuzzleScript
    screen to make PuzzleScript add everything you changed to the game you’re already
    playing. Then try to move the player next to the cats to see if they wake up.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则意味着如果`Player`在`SleepingCat`旁边，它就会变成一个在`AwakeCat`旁边的`Player`。点击PuzzleScript屏幕顶部的**Rebuild**，让PuzzleScript将你所做的所有更改添加到你正在玩的游戏中。然后尝试将玩家移到猫旁边，看看它们是否会醒来。
- en: 'The cats should wake up, but they’re a little late in doing so: instead of
    waking up when you touch them, they wake up on the next move. To see what I mean,
    walk up to a cat and then walk away from it. The cat wakes up after the next move
    the player makes, not right when the player walks up to it. We want the cats to
    perk up as soon as they see the player! What’s the deal, cats?'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 猫应该醒来了，但它们有点迟：它们不是在你碰到它们的时候醒来，而是在下一个移动时才醒来。为了让你明白我的意思，走近一只猫然后走开。猫会在玩家下一次移动后才醒来，而不是玩家走到它旁边时就醒来。我们希望猫在看到玩家时就马上警觉起来！猫，你们怎么回事？
- en: 'To understand the issue with the game play so far, think about how rules work:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解目前游戏玩法中的问题，想一想规则是如何工作的：
- en: The player decides in which direction to move.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家决定要向哪个方向移动。
- en: PuzzleScript checks all the rules and makes any changes the rules tell it to.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PuzzleScript检查所有规则，并根据规则所指示的内容进行任何更改。
- en: Everything that wants to move finally moves.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切想要移动的东西最终都会移动。
- en: You press an arrow key to move the player next to a cat, and the player becomes
    a moving `> Player`. Next, PuzzleScript checks the rules to see whether the player
    is next to any cats. Because they’re not next to any cats yet, the cats stay asleep
    and the `> Player` finally moves. Then PuzzleScript waits for the next arrow keypress,
    and the cat remains asleep! When you press an arrow key again, the player becomes
    a `> Player` again, and PuzzleScript checks the rules again. This time it sees
    that the player is next to a cat, so the cat becomes an awake cat, and the player
    moves away.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你按下箭头键，将玩家移动到猫旁边，玩家变成了一个移动中的`> Player`。接着，PuzzleScript检查规则，看看玩家是否在猫旁边。因为玩家还没有接近任何猫，猫保持沉睡，`>
    Player`终于移动了。然后PuzzleScript等待下一次箭头键按下，猫仍然保持沉睡！当你再次按下箭头键时，玩家再次变成`> Player`，PuzzleScript再次检查规则。这一次它发现玩家在猫旁边，所以猫变成了醒着的猫，玩家也移开了。
- en: 'To fix this hiccup in the game play, we add the keyword `late` to the rule
    so it will check whether the player is next to a cat right after the player moves
    instead of right before the player’s next move. The new rule looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决游戏中的这一问题，我们向规则中添加了关键字`late`，这样它将在玩家移动后立即检查玩家是否在猫旁边，而不是在玩家下一次移动之前。新的规则如下所示：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Adding `late` to the start of a rule tells PuzzleScript to check the rule after
    objects have moved instead of before. Essentially, we’ve added another step to
    the way PuzzleScript processes our rule, so this happens:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在规则前面加上`late`告诉PuzzleScript在物体移动后检查规则，而不是在移动之前。实际上，我们为PuzzleScript处理规则的方式添加了另一个步骤，因此会发生以下情况：
- en: The player decides in which direction to move.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家决定移动的方向。
- en: PuzzleScript checks all the rules and makes any changes the rules tell it to.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PuzzleScript检查所有规则，并根据规则的指示进行任何更改。
- en: Everything that wants to move finally moves.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有想要移动的物体最终都会移动。
- en: PuzzleScript checks all the `late` rules and makes any changes they tell it
    to.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PuzzleScript检查所有`late`规则，并根据它们的指示进行任何更改。
- en: Now the cats should wake up right after the player moves instead of waiting
    until the next cycle! Test this code. (You might need to click Run to start a
    new game if all your cats are already awake.) Your cats should perk up as soon
    as the player gets close.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，猫咪应该在玩家移动后立即醒来，而不是等到下一个周期再醒来！测试一下这段代码。（如果你的猫咪已经醒着，可能需要点击“运行”来开始一个新游戏。）当玩家靠近时，你的猫咪应该立刻警觉起来。
- en: Making Cats Follow the Player
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让猫咪跟随玩家
- en: 'Now let’s add this rule to make the awake cats follow the player:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加这个规则，让醒着的猫咪跟随玩家：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are no vertical bars (`|`) in this rule because `[ > Player | AwakeCat
    ]` would mean that the player and the cat would have to be next to each other
    for the cat to move. But we want the cats to move with the group regardless of
    what shape the group is in. So the easiest thing to do is to just have the cats
    make the same movements no matter where or how far from the player they are. As
    long as a cat is awake, it should move however the player does. To do that, we
    enclose the `Player` and the `AwakeCat` objects in separate square brackets, meaning
    they don’t have to be right next to each other. The player and the cat can be
    anywhere, and the rule will still trigger. Essentially, this new rule states that
    if a player is trying to move, every awake cat will try to move in the same direction.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则中没有竖线符号（`|`），因为`[ > Player | AwakeCat ]`意味着玩家和猫咪必须相邻，猫咪才能移动。但我们希望猫咪能和整个小组一起移动，无论小组是什么形状。因此，最简单的方法是让猫咪无论离玩家多远，都做相同的动作。只要猫咪是醒着的，它就应该跟着玩家一起移动。为了实现这一点，我们将`Player`和`AwakeCat`对象分别用方括号括起来，这意味着它们不需要紧挨着。玩家和猫咪可以处于任何位置，规则仍然会触发。实质上，这个新规则表明，如果玩家试图移动，每只醒着的猫都会尝试朝同一方向移动。
- en: Click **Rebuild** and try it out! Wake up the cats and get them moving! Pretend
    you’re a morning aerobics instructor for cats! Let’s get those tails shaking!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**重建**并试试看！唤醒猫咪并让它们开始移动！假装你是猫咪的晨间操教练！让我们把尾巴摇起来！
- en: '![Image](../images/pg035-01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg035-01.jpg)'
- en: The game still doesn’t work exactly like it should. Right now, groups don’t
    stick together. For example, if you’re blocked by a wall but a cat friend is not,
    the cat will keep walking and the group will break up. To make the shape of the
    group important, we need to make sure the group stays together.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏仍然没有完全按照预期工作。现在，小组并没有保持在一起。例如，如果你被墙壁挡住了，但猫咪朋友却没有，猫咪会继续走，结果小组会散开。为了让小组的形状变得重要，我们需要确保小组保持在一起。
- en: If we make the group stay together, we need to make sure that cats outside the
    group can add other cats to the group, too. Otherwise, once the player has woken
    up a few cats, they would be stuck in the middle of the cats and unable to reach
    any new ones!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们让小组保持在一起，我们还需要确保小组外的猫咪能够将其他猫咪加入小组。否则，一旦玩家唤醒了几只猫，它们就会被困在猫群中间，无法接触到任何新的猫咪！
- en: 'We have two challenges: we want the player and the cats to move as a group,
    and we want to allow cats already in the group to awaken other cats, just as the
    player does. Fortunately, these two problems have the same solution.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面临两个挑战：我们希望玩家和猫咪一起移动，并且希望允许已经在组内的猫咪唤醒其他猫咪，就像玩家一样。幸运的是，这两个问题有相同的解决方法。
- en: Defining Properties of Objects
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义对象的属性
- en: To address both problems with our game play, we need the same rules to apply
    to the player and the cat objects. We could write two versions of every rule—one
    for the player and another for the cats—but then if we ever wanted to change that
    rule, we’d have to change it twice. Also, if we wanted to add a new rule, we’d
    have to write it twice! One characteristic of programmers is that we’re lazy.
    Why do extra work when we can play with our real cat instead? Let’s make our code
    clean and efficient the first time.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决游戏玩法中的两个问题，我们需要让同样的规则适用于玩家和猫对象。我们本可以为每条规则写两个版本——一个给玩家，一个给猫咪——但这样一来，如果我们想改变规则，就得改两次。而且如果我们想添加新规则，也得写两次！程序员有一个特点，就是我们比较懒。为什么要做多余的工作，当我们可以和自己真实的猫咪玩呢？让我们第一次就让代码干净高效。
- en: We’ll use the `LEGEND` section to tell PuzzleScript to treat different kinds
    of objects in the same way. The `LEGEND` section doesn’t just let us tell PuzzleScript
    what symbols refer to which objects. It also lets us tell PuzzleScript which words
    refer to which objects, so we can use one word to include the player and cats
    in a group.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`LEGEND`部分告诉PuzzleScript以相同方式对待不同类型的对象。`LEGEND`部分不仅允许我们告诉PuzzleScript哪些符号代表哪些对象，它还允许我们告诉PuzzleScript哪些单词代表哪些对象，这样我们就可以用一个词将玩家和猫咪包括在同一个小组里。
- en: Allowing Cats to Wake Up Other Cats
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 允许猫咪叫醒其他猫咪
- en: Let’s add an entry to the legend to describe any object that can be a member
    of the player’s group, whether that’s the player or the cats following them around.
    That way, anyone in the group (player or cats) can wake up sleeping cats. We’ll
    call this type of object a `WakerUpper`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在传说中添加一项条目，描述任何可以作为玩家小组成员的对象，无论是玩家还是跟着他们的猫咪。这样，组中的任何成员（玩家或猫咪）都可以叫醒睡着的猫咪。我们将把这种类型的对象称为`WakerUpper`。
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now in our rules, instead of checking whether the player is next to a sleeping
    cat, we check whether any `WakerUpper` is next to a sleeping cat. Keep in mind
    that the player and any cat that has already joined their group count as `WakerUpper`s.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们的规则中，我们不再检查玩家是否靠近睡着的猫咪，而是检查任何`WakerUpper`是否靠近睡着的猫咪。记住，玩家和任何已经加入他们小组的猫咪都算作`WakerUpper`。
- en: 'We’ll add `WakerUpper` to our current `late` rule by changing this line:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过修改这一行，将`WakerUpper`添加到我们当前的`late`规则中：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'to this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now the cats in the game should be able to wake up other cats. The current rule
    looks for any objects marked as `WakerUpper`, and the legend defines the player
    and awakened cats as `WakerUpper`. Try playing the game, and then save your work!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏中的猫咪应该能够叫醒其他猫咪了。当前的规则会查找任何被标记为`WakerUpper`的对象，传说中将玩家和已醒来的猫咪定义为`WakerUpper`。试着玩玩看游戏，然后保存你的进度！
- en: Keeping Cats Together
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 保持猫咪在一起
- en: 'We’ve solved the first problem: cats can wake up other cats. Next, we have
    to figure out how to stop the group from splitting apart when it moves.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解决了第一个问题：猫咪可以叫醒其他猫咪。接下来，我们需要弄清楚如何在移动时防止小组分裂。
- en: 'First, let’s determine why the group splits apart. Remember that the `>` symbol
    means that something is *trying* to move. Because of the following rule, whenever
    the player tries to move, all the cats try to move in the same direction:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们确定为什么小组会分裂。记住，`>`符号表示某物*正在尝试*移动。由于以下规则，每当玩家尝试移动时，所有的猫都会尝试朝同一方向移动：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: But if the player tries to move again and their way is blocked, every cat still
    tries to move anyway and the group splits up.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果玩家再次尝试移动且被阻挡，每只猫仍然会尝试移动，导致小组分裂。
- en: 'To keep the player and cats together as a group, we need to stop everyone in
    the group from moving if any one member of the group is blocked. We can do this
    by adding another rule and using the keyword `cancel`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持玩家和猫咪作为一个小组，我们需要在小组中的任何成员被阻挡时，停止小组中所有人的移动。我们可以通过添加另一个规则并使用关键字`cancel`来实现：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This rule states that “if a `WakerUpper` tries to move into a wall, stop everyone
    from moving.” Everyone stays where they are. Because we used `WakerUpper`, this
    rule will check the player and all the awake cats, and the group should stay together.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则声明：“如果一个`WakerUpper`尝试移动到墙壁里，停止所有人的移动。”每个人都会停留在原地。因为我们使用了`WakerUpper`，这个规则会检查玩家和所有醒着的猫，确保小组保持在一起。
- en: '![Image](../images/pg038-01.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg038-01.jpg)'
- en: Keep in mind that PuzzleScript reads all your scripting from top to bottom,
    the same as you do. PuzzleScript applies your rules in the order they’re listed,
    starting at the top and working its way to the bottom. We want the “if a `WakerUpper`
    tries to move into a wall” rule to happen at the very end, after all the `WakerUpper`
    members decide where they’re moving. So make sure this last rule is at the very
    bottom of your `RULES` section!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，PuzzleScript 会从上到下读取你编写的所有脚本，就像你读书一样。PuzzleScript 按照它们的顺序执行你的规则，从最上面开始，直到最底部。我们希望“如果一个
    `WakerUpper` 尝试移动到墙壁中”这一规则发生在最后，所有 `WakerUpper` 成员决定好它们的移动位置之后。所以，请确保这个最后的规则位于
    `RULES` 部分的最底部！
- en: Save your work, and then try to play the game. Do the player and cats stay in
    a group?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的工作，然后尝试玩一下游戏。玩家和猫咪会保持在同一个队伍中吗？
- en: Winning the Game
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 赢得游戏
- en: Earlier, we decided that the goal of the game would be to wake up all the cats
    and have them join your group. Well, we’ve woken up all the cats in the level.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们决定游戏的目标是唤醒所有的猫，并让它们加入你的队伍。好吧，我们已经唤醒了关卡中的所有猫。
- en: But the level still hasn’t ended because we haven’t added a win condition for
    PuzzleScript to check for yet.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但是关卡仍然没有结束，因为我们还没有为 PuzzleScript 添加检查获胜条件的内容。
- en: 'Some games can go on forever, but not this one. To win *Herding Cats*, we need
    to add a win condition. What win condition would make sense? Well, the goal in
    *Herding Cats* is simply to have all cats join the group. To accomplish that,
    we need to wake up all the cats! Okay then, let’s try this as our win condition:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有些游戏可以永无止境，但这个游戏不是。要想赢得 *Herding Cats*，我们需要添加一个获胜条件。什么样的获胜条件才合适呢？好吧，*Herding
    Cats* 的目标就是让所有的猫都加入你的队伍。为了实现这一目标，我们需要唤醒所有的猫！那么，试试看这个作为我们的获胜条件：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You win if there are no more sleeping cats, and all the cats are now awake cats.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有更多的睡觉猫，并且所有猫都已经醒来，你就赢了。
- en: Add the `No SleepingCat` line to the `WINCONDITIONS` section, and then run your
    game to see whether you can win your level. You should see the message `Win Condition
    Satisfied` when the last cat wakes up, as shown here.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `No SleepingCat` 这一行添加到 `WINCONDITIONS` 部分，然后运行你的游戏，看看你是否能赢得关卡。当最后一只猫醒来时，你应该看到“Win
    Condition Satisfied”这一信息，如下所示。
- en: '![Image](../images/pg039-01.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg039-01.jpg)'
- en: And you’re back at the title screen.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你会回到标题画面。
- en: '![Image](../images/pg040-01.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg040-01.jpg)'
- en: Adding Sounds
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加音效
- en: To make the game more interesting and fun, let’s add sound effects to your game.
    See these little buttons beneath the game screen? Try clicking each of them!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让游戏更加有趣和好玩，我们来为游戏添加一些音效。看到游戏屏幕下方的这些小按钮了吗？试着点击其中的每一个！
- en: '![Image](../images/pg040-02.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg040-02.jpg)'
- en: 'These buttons produce different sound effects like jump sounds, pew pew sounds,
    and bird tweets. The random sound button at the far right gives you a completely
    random sound, and the X on the far left clears the information panel below the
    game screen, along with any sounds you’ve added! Be careful with the X button:
    you don’t want to accidentally erase any sounds that you like and might still
    want to use!'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些按钮会产生不同的音效，比如跳跃声、激光射击声和鸟鸣声。最右侧的随机音效按钮会给你一个完全随机的音效，最左侧的 X 按钮则会清空游戏屏幕下方的信息面板，并删除你添加的任何音效！使用
    X 按钮时要小心：你可不希望不小心删除掉一些你喜欢的音效，可能还会继续用到哦！
- en: 'Each time you click a button, such as the bird button, a line like `birdSound:
    40166309` appears. That number is the sound effect in a form that PuzzleScript
    understands. When you click a number, you should hear the sound. When you find
    a sound you like, write down its number.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '每次点击一个按钮，比如鸟按钮时，都会出现类似 `birdSound: 40166309` 的一行。这个数字是 PuzzleScript 可以理解的音效格式。当你点击一个数字时，你应该能听到那个声音。当你找到喜欢的声音时，记下它的编号。'
- en: '![Image](../images/pg041-01.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg041-01.jpg)'
- en: 'Try to find a sound you could play that would indicate in an exciting way that
    you won the level! The powerup sound button with the + on it might be a good one.
    Keep clicking it until you get to a sound you like. Then enter the number of the
    sound into the `SOUNDS` section of your game, like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试找一个音效，能够激动人心地表示你赢得了这一关！带有加号的能量增强音效按钮可能是一个不错的选择。不断点击它，直到你找到一个喜欢的声音。然后将这个音效的编号输入到游戏的
    `SOUNDS` 部分，如下所示：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Image](../images/pg041-02.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg041-02.jpg)'
- en: The keyword `Endlevel` tells PuzzleScript to play this sound when the level
    ends. Now run your game again and try to win the level. Do you hear your cool
    sound when you win?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 关键词 `Endlevel` 告诉 PuzzleScript 在关卡结束时播放这个音效。现在再次运行你的游戏，尝试赢得这一关。当你获胜时，你能听到那个酷炫的音效吗？
- en: 'How about adding a sound to the cats when they wake up? Find a sound effect
    that sounds meowy, and then add it to your list of sounds, like so:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何在猫咪醒来时加入一个声音呢？找到一个听起来像“喵”的音效，然后将它添加到你的声音列表中，就像这样：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code `sfx0` stands for “sound effects 0.” If you add another sound effect,
    you would call it `sfx1`, then `sfx2`, and so on. (Remember that 0 is always the
    number of the person in the front of the bathroom line!)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 代码`sfx0`代表“音效 0”。如果你添加另一个音效，你就会用`sfx1`，然后是`sfx2`，依此类推。（记住，0总是排队在厕所前面的人编号！）
- en: 'You can make the `sfx0` sound play whenever you want it to by putting it at
    the end of a rule, like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时通过将它放在规则的末尾来让`sfx0`声音播放，就像这样：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This line tells PuzzleScript to play `sfx0` every time the rule for waking up
    a cat runs, meaning every time a cat wakes up.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码告诉PuzzleScript在每次执行唤醒猫咪的规则时播放`sfx0`，也就是说，每次猫咪醒来时都会播放。
- en: Save your game and test it out. Listen to the beautiful symphony of weird video
    game sounds your game has now. *Magnificent!*
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的游戏并进行测试。聆听你游戏现在拥有的奇异视频游戏音效的美妙交响曲。*宏伟！*
- en: '![Image](../images/pg042-01.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg042-01.jpg)'
- en: What You Learned
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: Now you know all the parts that make up a PuzzleScript game. You know how to
    draw the objects that make up your game, add the rules that tell the game what
    to do with those objects, and set up the collision layers that tell the game which
    objects interact with which objects. You also know that the `LEGEND` section tells
    PuzzleScript what words and symbols refer to which objects. You learned about
    adding a win condition to be able to finish the game and adding sounds to make
    the game more fun and communicative.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了构成PuzzleScript游戏的所有部分。你知道如何绘制构成游戏的对象，添加规则来告诉游戏如何处理这些对象，并设置碰撞层来告诉游戏哪些对象与哪些对象交互。你还知道`LEGEND`部分告诉PuzzleScript哪些单词和符号代表哪些对象。你学到了如何添加胜利条件来完成游戏，并添加声音使游戏更有趣且更具表现力。
- en: The one important part of a PuzzleScript game we haven’t talked a lot about
    yet is levels. In the next chapter, you’ll learn how to use PuzzleScript’s handy,
    built-in level editor to make puzzles for your game. You’ll also learn how to
    use level design to tell your game’s story. Take another break, and we’ll meet
    again in [Chapter 3](ch03.xhtml)!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有深入讨论的一个重要部分是关卡。在下一章中，你将学习如何使用PuzzleScript内置的便捷关卡编辑器为你的游戏制作关卡。你还将学习如何利用关卡设计讲述你的游戏故事。休息一下，我们将在[第3章](ch03.xhtml)再见！
