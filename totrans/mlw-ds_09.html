<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_155"/><strong><span class="big">9</span></strong><br/><strong>VISUALIZING MALWARE TRENDS</strong></h2>
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>
<p class="noindent">Sometimes the best way to analyze malware collections is to visualize them. Visualizing security data allows us to quickly recognize trends in malware and within the threat landscape at large. These visualizations are often far more intuitive than nonvisual statistics, and they can help communicate insights to diverse audiences. For example, in this chapter, you see how visualization can help us identify the types of malware prevalent in a dataset, the trends within malware datasets (the emergence of ransomware as a trend in 2016, for example), and the relative efficacy of commercial antivirus systems at detecting malware.</p>
<p class="indent">Working through these examples, you come away understanding how to create your own visualizations that can lead to valuable insights by using the Python data analysis package <span class="literal">pandas</span>, as well as the Python data visualization packages <span class="literal">seaborn</span> and <span class="literal">matplotlib</span>. The <span class="literal">pandas</span> package is used mostly for loading and manipulating data and doesn’t have much to do with data visualization itself, but it’s very useful for preparing data for visualization.</p>
<h3 class="h3" id="lev151"><span epub:type="pagebreak" id="page_156"/><strong>Why Visualizing Malware Data Is Important</strong></h3>
<p class="noindent">To see how visualizing malware data can be helpful, let’s go through two examples. The first visualization addresses the following question: is the antivirus industry’s ability to detect ransomware improving? The second visualization asks which malware types have trended over the period of a year. Let’s look at the first example shown in <a href="ch09.xhtml#ch09fig1">Figure 9-1</a>.</p>
<div class="image"><a id="ch09fig1"/><img alt="image" src="../images/f0156-01.jpg"/></div>
<p class="figcap"><em>Figure 9-1: Visualization of ransomware detections over time</em></p>
<p class="indent">I created this ransomware visualization using data collected from thousands of ransomware malware samples. This data contains the results of running 57 separate antivirus engines against each file. Each circle represents a malware sample. The y-axis represents how many detections, or positives, each malware sample received from the antivirus engines when it was scanned. Keep in mind that while this y-axis stops at 60, the maximum count for a given scan is 57, the total number of scanners. The x-axis represents when each malware sample was first seen on the malware analysis site <em><a href="http://VirusTotal.com">VirusTotal.com</a></em> and scanned.</p>
<p class="indent">In this plot, we can see the antivirus community’s ability to detect these malicious files started off relatively strong in June 2016, dipped around July 2016, and then steadily rose over the rest of the year. By the end of 2016, <span epub:type="pagebreak" id="page_157"/>ransomware files were still missed by an average of about 25 percent of antivirus engines, so we can conclude that the security community remained somewhat weak at detecting these files during this time.</p>
<p class="indent">To extend this investigation, you could create a visualization that shows <em>which</em> antivirus engines are detecting ransomware and at what rate, and how they are improving over time. Or you could look at some other category of malware (for example, Trojan horses). Such plots are useful in deciding which antivirus engines to purchase, or deciding which kinds of malware you might want to design custom detection solutions for—perhaps to supplement a commercial antivirus detection system (for more on building custom detection systems, see <a href="ch08.xhtml#ch08">Chapter 8</a>).</p>
<p class="indent">Now let’s look at <a href="ch09.xhtml#ch09fig2">Figure 9-2</a>, which is another sample visualization, created using the same dataset used for <a href="ch09.xhtml#ch09fig1">Figure 9-1</a>.</p>
<div class="image"><a id="ch09fig2"/><img alt="image" src="../images/f0157-01.jpg"/></div>
<p class="figcap"><em>Figure 9-2: Visualization of per-family malware detections over time</em></p>
<p class="indent"><a href="ch09.xhtml#ch09fig2">Figure 9-2</a> shows the top 20 most common malware families and how frequently they occurred relative to one another over a 150-day period. The plot reveals some key insights: whereas the most popular malware family, Allaple.A, occurred consistently over the 150-day span, other malware families, like Nemucod.FG, were prevalent for shorter spans of time and then went silent. A plot like this, generated using malware detected on your own workplace’s network, can reveal helpful trends showing what types of malware are involved in attacks against your organization over time. Without the creation of a comparison figure such as this one, understanding and comparing the relative peaks and volumes of these malware types over time would be difficult and time consuming.</p>
<p class="indent"><span epub:type="pagebreak" id="page_158"/>These two examples show how useful malware visualization can be. The rest of this chapter shows how to create your own visualizations. We start by discussing the sample dataset used in this chapter and then we use the <span class="literal">pandas</span> package to analyze the data. Finally, we use the <span class="literal">matplotlib</span> and <span class="literal">seaborn</span> packages to visualize the data.</p>
<h3 class="h3" id="lev152"><strong>Understanding Our Malware Dataset</strong></h3>
<p class="noindent">The dataset we use contains data describing 37,000 unique malware binaries collected by VirusTotal, a malware detection aggregation service. Each binary is labeled with four fields: the number of antivirus engines (out of 57) that flagged the binary as malicious (I call this the number of <em>positives</em> associated with each sample), the size of each binary, the binary’s <em>type</em> (bitcoin miner, keylogger, ransomware, trojan, or worm), and the date on which the binary was first seen. We’ll see that even with this fairly limited amount of metadata for each binary, we can analyze and visualize the data in ways that reveal important insights into the dataset.</p>
<h4 class="h4" id="lev153"><strong><em>Loading Data into pandas</em></strong></h4>
<p class="noindent">The popular Python data analysis library <span class="literal">pandas</span> makes it easy to load data into analysis objects called <span class="literal">DataFrame</span>s, and then provides methods to slice, transform, and analyze that repackaged data. We use <span class="literal">pandas</span> to load and analyze our data and prep it for easy visualization. Let’s use <a href="ch09.xhtml#ch09list1">Listing 9-1</a> to define and load some sample data into the Python interpreter.</p>
<p class="programs">In [135]: import pandas<br/><br/>In [136]: example_data = [<span class="ent">➊</span>{'column1': 1, 'column2': 2},<br/>    ...:  {'column1': 10, 'column2': 32},<br/>    ...:  {'column1': 3, 'column2': 58}]<br/><br/>In [137]: <span class="ent">➋</span>pandas.DataFrame(example_data)<br/>Out[137]:<br/>  column1  column2<br/>0        1        2<br/>1       10       32<br/>2        3       58</p>
<p class="listing" id="ch09list1"><em>Listing 9-1: Loading data into</em> <span class="codeitalic">pandas</span> <em>directly</em></p>
<p class="indent">Here we define some data, which we call <span class="literal">example_data</span>, as a list of Python dictionaries <span class="ent">➊</span>. Once we have created this list of <span class="literal">dicts</span>, we pass it to the <span class="literal">DataFrame</span> constructor <span class="ent">➋</span> to get the corresponding <span class="literal">pandas</span> <span class="literal">DataFrame</span>. Each of these <span class="literal">dicts</span> becomes a row in the resulting <span class="literal">DataFrame</span>. The keys in the <span class="literal">dicts</span> (<span class="literal">column1</span> and <span class="literal">column2</span>) become columns. This is one way to load data into <span class="literal">pandas</span> directly.</p>
<p class="indent">You can also load data from external CSV files. Let’s use the code in <a href="ch09.xhtml#ch09list2">Listing 9-2</a> to load this chapter’s dataset (available on the virtual machine or in the data and code archive that accompany this book).</p>
<p class="programs"><span epub:type="pagebreak" id="page_159"/>import pandas<br/>malware = pandas.read_csv("malware_data.csv")</p>
<p class="listing" id="ch09list2"><em>Listing 9-2: Loading data into</em> <span class="codeitalic">pandas</span> <em>from an external CSV file</em></p>
<p class="indent">When you import <em>malware_data.csv</em>, the resulting <span class="literal">malware</span> object should look something like this:</p>
<p class="programs">      positives      size        type            fs_bucket<br/>0             45    251592      trojan  2017-01-05 00:00:00<br/>1             32    227048      trojan  2016-06-30 00:00:00<br/>2             53    682593        worm  2016-07-30 00:00:00<br/>3             39    774568      trojan  2016-06-29 00:00:00<br/>4             29    571904      trojan  2016-12-24 00:00:00<br/>5             31    582352      trojan  2016-09-23 00:00:00<br/>6             50   2031661        worm  2017-01-04 00:00:00</p>
<p class="indent">We now have a <span class="literal">pandas</span> <span class="literal">DataFrame</span> composed of our malware dataset. It has four columns: <span class="literal">positives</span> (the number of antivirus detections out of 57 antivirus engines for that sample), <span class="literal">size</span> (the number of bytes that malware binary takes up on disk), <span class="literal">type</span> (the type of malware, such as Trojan horse, worm, and so on), and <span class="literal">fs_bucket</span> (the date on which this malware was first seen).</p>
<h4 class="h4" id="lev154"><strong><em>Working with a pandas DataFrame</em></strong></h4>
<p class="noindent">Now that we have our data in a <span class="literal">pandas</span> <span class="literal">DataFrame</span>, let’s look at how to access and manipulate it by calling the <span class="literal">describe()</span> method, as shown in <a href="ch09.xhtml#ch09list3">Listing 9-3</a>.</p>
<p class="programs">In [51]: malware.describe()<br/>Out[51]:<br/>         positives          size<br/>count  37511.000000  3.751100e+04<br/>mean      39.446536  1.300639e+06<br/>std       15.039759  3.006031e+06<br/>min        3.000000  3.370000e+02<br/>25%       32.000000  1.653960e+05<br/>50%       45.000000  4.828160e+05<br/>75%       51.000000  1.290056e+06<br/>max       57.000000  1.294244e+08</p>
<p class="listing" id="ch09list3"><em>Listing 9-3: Calling the</em> <span class="codeitalic">describe()</span> <em>method</em></p>
<p class="indent">As shown in <a href="ch09.xhtml#ch09list3">Listing 9-3</a>, calling the <span class="literal">describe()</span> method shows some useful statistics about our <span class="literal">DataFrame</span>. The first line, <span class="literal">count</span>, counts the total number of non-null <span class="literal">positives</span> rows, and the total number of non-null rows. The second line gives the <span class="literal">mean</span>, or average number of positives per sample, and the mean size of the malware samples. Next comes the standard deviation for both <span class="literal">positives</span> and <span class="literal">size</span>, and the minimum value of each column in all the samples in the dataset. Finally, we see percentile values for each of the columns and the maximum value for the columns.</p>
<p class="indent"><span epub:type="pagebreak" id="page_160"/>Suppose we’d like to retrieve the data for one of the columns in the malware <span class="literal">DataFrame</span>, such as the <span class="literal">positives</span> column (to view the average number of detections each file has, for example, or plot a histogram showing the distribution of positives over the dataset). To do this, we simply write <span class="literal">malware['positives']</span>, which returns the <span class="literal">positives</span> column as a list of numbers, as shown in <a href="ch09.xhtml#ch09list4">Listing 9-4</a>.</p>
<p class="programs">In [3]: malware['positives']<br/>Out[3]:<br/>0        45<br/>1        32<br/>2        53<br/>3        39<br/>4        29<br/>5        31<br/>6        50<br/>7        40<br/>8        20<br/>9        40<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="listing" id="ch09list4"><em>Listing 9-4: Returning the</em> <span class="codeitalic">positives</span> <em>column</em></p>
<p class="indent">After retrieving a column, we can compute statistics on it directly. For example, <span class="literal">malware['positives'].mean()</span> computes the mean of the column, <span class="literal">malware['positives'].max()</span> computes the maximum value, <span class="literal">malware['positives'].min()</span> computes the minimum value, and <span class="literal">malware['positives'].std()</span> computes the standard deviation. <a href="ch09.xhtml#ch09list5">Listing 9-5</a> shows examples of each.</p>
<p class="programs">In [7]: malware['positives'].mean()<br/>Out[7]: 39.446535682866362<br/><br/>In [8]: malware['positives'].max()<br/>Out[8]: 57<br/><br/>In [9]: malware['positives'].min()<br/>Out[9]: 3<br/><br/>In [10]: malware['positives'].std()<br/>Out[10]: 15.039759380778822</p>
<p class="listing" id="ch09list5"><em>Listing 9-5: Calculating the mean, maximum, and minimum values and the standard deviation</em></p>
<p class="indent">We can also slice and dice the data to do more detailed analysis. For example, <a href="ch09.xhtml#ch09list6">Listing 9-6</a> computes the mean positives for the trojan, bitcoin, and worm types of malware.</p>
<p class="programs">In [67]: malware[malware['type'] == 'trojan']['positives'].mean()<br/>Out[67]: 33.43822473365119<br/><br/>In [68]: malware[malware['type'] == 'bitcoin']['positives'].mean()<br/>Out[68]: 35.857142857142854<br/><br/><span epub:type="pagebreak" id="page_161"/>In [69]: malware[malware['type'] == 'worm']['positives'].mean()<br/>Out[69]: 49.90857904874796</p>
<p class="listing" id="ch09list6"><em>Listing 9-6: Calculating the average detection rates of different malwares</em></p>
<p class="indent">We first select the rows of the <span class="literal">DataFrame</span> where <span class="literal">type</span> is set to <span class="literal">trojan</span> using the following notation: <span class="literal">malware[malware['type'] == 'trojan']</span>. To select the <span class="literal">positives</span> column of the resulting data and compute the mean, we extend this expression as follows: <span class="literal">malware[malware['type'] == 'trojan']['positives'].mean()</span>. <a href="ch09.xhtml#ch09list6">Listing 9-6</a> yields an interesting result, which is that worms get detected more frequently than bitcoin mining and Trojan horse malware. Because 49.9 &gt; 35.8 and 33.4, on average, malicious <span class="literal">worm</span> samples (49.9) are detected by more vendors than malicious <span class="literal">bitcoin</span> and <span class="literal">trojan</span> samples (35.8, 33.4).</p>
<h4 class="h4" id="lev155"><strong><em>Filtering Data Using Conditions</em></strong></h4>
<p class="noindent">We can select a subset of the data using other conditions as well. For example, we can use “greater than” and “less than” style conditions on numerical data like malware file size to filter the data, and then compute statistics on the resulting subsets. This can be useful if we’re interested in finding out whether the effectiveness of the antivirus engines is related to file size. We can check this using the code in <a href="ch09.xhtml#ch09list7">Listing 9-7</a>.</p>
<p class="programs">In [84]: malware[malware['size'] &gt; 1000000]['positives'].mean()<br/>Out[84]: 33.507073192162373<br/><br/>In [85]: malware[malware['size'] &gt; 2000000]['positives'].mean()<br/>Out[85]: 32.761442050415432<br/><br/>In [86]: malware[malware['size'] &gt; 3000000]['positives'].mean()<br/>Out[86]: 27.20672682526661<br/><br/>In [87]: malware[malware['size'] &gt; 4000000]['positives'].mean()<br/>Out[87]: 25.652548725637182<br/><br/>In [88]: malware[malware['size'] &gt; 5000000]['positives'].mean()<br/>Out[88]: 24.411069317571197</p>
<p class="listing" id="ch09list7"><em>Listing 9-7: Filtering the results by malware file size</em></p>
<p class="indent">Take the first line in the preceding code: first, we subset our <span class="literal">DataFrame</span> by only samples that have a size over one million (<span class="literal">malware[malware['size'] &gt; 1000000]</span>). Then we grab the <span class="literal">positives</span> column and calculate the mean (<span class="literal">['positives'].mean()</span>), which is about 33.5. As we do this for higher and higher file sizes, we see that the average number of detections for each group goes down. This means we’ve discovered that there is indeed a relationship between malware file size and the average number of antivirus engines that detect those malware samples, which is interesting and merits further investigation. We explore this visually next by using <span class="literal">matplotlib</span> and <span class="literal">seaborn</span>.</p>
<h3 class="h3" id="lev156"><span epub:type="pagebreak" id="page_162"/><strong>Using matplotlib to Visualize Data</strong></h3>
<p class="noindent">The go-to library for Python data visualization is <span class="literal">matplotlib</span>; in fact, most other Python visualization libraries are essentially convenience wrappers around <span class="literal">matplotlib</span>. It’s easy to use <span class="literal">matplotlib</span> with <span class="literal">pandas</span>: we use <span class="literal">pandas</span> to get, slice, and dice the data we want to plot, and we use <span class="literal">matplotlib</span> to plot it. The most useful <span class="literal">matplotlib</span> function for our purposes is the <span class="literal">plot</span> function. <a href="ch09.xhtml#ch09fig3">Figure 9-3</a> shows what the <span class="literal">plot</span> function can do.</p>
<div class="image"><a id="ch09fig3"/><img alt="image" src="../images/f0162-01.jpg"/></div>
<p class="figcap"><em>Figure 9-3: A plot of malware samples’ sizes and the number of antivirus detections</em></p>
<p class="indent">Here, I plot the <span class="literal">positives</span> and <span class="literal">size</span> attributes of our malware dataset. An interesting result emerges, as foreshadowed by our discussion of <span class="literal">pandas</span> in the previous section. It shows that small files and very large files are rarely detected by most of the 57 antivirus engines that scanned these files. Files of middling size (around 10<sup>4.5</sup>–10<sup>7</sup>) are detected by most engines, however. This may be because small files don’t contain enough information to allow engines to determine they are malicious, and big files are too slow to scan, causing many antivirus systems to punt on scanning them at all.</p>
<h4 class="h4" id="lev157"><strong><em>Plotting the Relationship Between Malware Size and Vendor Detections</em></strong></h4>
<p class="noindent">Let’s walk through how to make the plot shown in <a href="ch09.xhtml#ch09fig3">Figure 9-3</a> by using the code in <a href="ch09.xhtml#ch09list8">Listing 9-8</a>.</p>
<p class="programs"><span epub:type="pagebreak" id="page_163"/><span class="ent">➊</span> import pandas<br/>   from matplotlib import pyplot<br/>   malware = <span class="ent">➋</span>pandas.read_csv("malware_data.csv")<br/>   pyplot.plot(<span class="ent">➌</span>malware['size'], <span class="ent">➍</span>malware['positives'],<br/>               <span class="ent">➎</span>'bo', <span class="ent">➏</span>alpha=0.01)<br/>   pyplot.xscale(<span class="ent">➐</span>"log")<br/><span class="ent">➑</span> pyplot.ylim([0,57])<br/>   pyplot.xlabel("File size in bytes (log base-10)")<br/>   pyplot.ylabel("Number of detections")<br/>   pyplot.title("Number of Antivirus Detections Versus File Size")<br/><span class="ent">➒</span> pyplot.show()</p>
<p class="listing" id="ch09list8"><em>Listing 9-8: Visualizing data using the</em> <span class="codeitalic">plot()</span> <em>function</em></p>
<p class="indent">As you can see, it doesn’t take much code to render this plot. Let’s walk through what each line does. First, we import <span class="ent">➊</span> the necessary libraries, including <span class="literal">pandas</span> and the <span class="literal">matplotlib</span> library’s <span class="literal">pyplot</span> module. Then we call the <span class="literal">read_csv</span> function <span class="ent">➋</span>, which, as you learned earlier, loads our malware dataset into a <span class="literal">pandas DataFrame</span>.</p>
<p class="indent">Next we call the <span class="literal">plot()</span> function. The first argument to the function is the malware <span class="literal">size</span> data <span class="ent">➌</span>, and the next argument is the malware <span class="literal">positives</span> data <span class="ent">➍</span>, or the number of positive detections for each malware sample. These arguments define the data that <span class="literal">matplotlib</span> will plot, with the first argument representing the data to be shown on the x-axis and the second representing the data to be shown on the y-axis. The next argument, <span class="literal">'bo'</span> <span class="ent">➎</span>, tells <span class="literal">matplotlib</span> what color and shape to use to represent the data. Finally, we set <span class="literal">alpha</span>, or the transparency of the circles, to <span class="literal">0.1</span> <span class="ent">➏</span>, so we can see how dense the data is within different regions of the plot, even when the circles completely overlap each other.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The</em> b <em>in</em> <span class="literal">bo</span> <em>stands for</em> blue<em>, and the</em> o <em>stands for</em> circle<em>, meaning that we’re telling</em> <span class="codeitalic">matplotlib</span> <em>to plot blue circles to represent our data. Other colors you can try are green (</em><span class="codeitalic">g</span><em>), red (</em><span class="codeitalic">r</span><em>), cyan (</em><span class="codeitalic">c</span><em>), magenta (</em><span class="codeitalic">m</span><em>), yellow (</em><span class="codeitalic">y</span><em>), black (</em><span class="codeitalic">k</span><em>), and white (</em><span class="codeitalic">w</span><em>). Other shapes you can try are a point (</em><span class="codeitalic">.</span><em>), a single pixel per data point (</em><span class="codeitalic">,</span><em>), a square (</em><span class="codeitalic">s</span><em>), and a pentagon (</em><span class="codeitalic">p</span><em>). For complete details, see the</em> <span class="codeitalic">matplotlib</span> <em>documentation at</em> <a href="http://matplotlib.org">http://matplotlib.org</a>.</p>
</div>
<p class="indent">After we call the <span class="literal">plot()</span> function, we set the scale of the x-axis to be logarithmic <span class="ent">➐</span>. This means that we’ll be viewing the malware size data in terms of powers of 10, making it easier to see the relationships between very small and very large files.</p>
<p class="indent">Now that we’ve plotted our data, we label our axes and title our plot. The x-axis represents the size of the malware file <span class="literal">("File size in bytes (log</span> <span class="literal">base-10)</span><span class="literal">")</span>, and the y-axis represents the number of detections <span class="literal">("Number of detections")</span>. Because there are 57 antivirus engines we’re analyzing, we set the y-axis scale to the range 0 to 57 at <span class="ent">➑</span>. Finally, we call the <span class="literal">show()</span> function <span class="ent">➒</span> to display the plot. We could replace this call with <span class="literal">pyplot.savefig("myplot.png")</span> if we wanted to save the plot as an image instead.</p>
<p class="indent">Now that we’ve gone through an initial example, let’s do another.</p>
<h4 class="h4" id="lev158"><span epub:type="pagebreak" id="page_164"/><strong><em>Plotting Ransomware Detection Rates</em></strong></h4>
<p class="noindent">This time, let’s try reproducing <a href="ch09.xhtml#ch09fig1">Figure 9-1</a>, the ransomware detection plot I showed at the beginning of this chapter. <a href="ch09.xhtml#ch09list9">Listing 9-9</a> presents the entire code that plots our ransomware detections over time.</p>
<p class="programs">import dateutil<br/>import pandas<br/>from matplotlib import pyplot<br/><br/>malware = pandas.read_csv("malware_data.csv")<br/>malware['fs_date'] = [dateutil.parser.parse(d) for d in malware['fs_bucket']]<br/>ransomware = malware[malware['type'] == 'ransomware']<br/>pyplot.plot(ransomware['fs_date'], ransomware['positives'], 'ro', alpha=0.05)<br/>pyplot.title("Ransomware Detections Over Time")<br/>pyplot.xlabel("Date")<br/>pyplot.ylabel("Number of antivirus engine detections")<br/>pyplot.show()</p>
<p class="listing" id="ch09list9"><em>Listing 9-9: Plotting ransomware detection rates over time</em></p>
<p class="indent">Some of the code in <a href="ch09.xhtml#ch09list9">Listing 9-9</a> should be familiar from what I’ve explained thus far, and some won’t be. Let’s walk through the code, line by line:</p>
<p class="programs">import dateutil</p>
<p class="indent">The helpful Python package <span class="literal">dateutil</span> enables you to easily parse dates from many different formats. We import <span class="literal">dateutil</span> because we’ll be parsing dates so we can visualize them.</p>
<p class="programs">import pandas<br/>from matplotlib import pyplot</p>
<p class="indent">We also import the <span class="literal">matplotlib</span> library’s <span class="literal">pyplot</span> module as well as <span class="literal">pandas</span>.</p>
<p class="programs">malware = pandas.read_csv("malware_data.csv")<br/>malware['fs_date'] = [dateutil.parser.parse(d) for d in malware['fs_bucket']]<br/>ransomware = malware[malware['type'] == 'ransomware']</p>
<p class="indent">These lines read in our dataset and create a filtered dataset called <span class="literal">ransomware</span> that contains only ransomware samples, because that’s the type of data we’re interested in plotting here.</p>
<p class="programs">pyplot.plot(ransomware['fs_date'], ransomware['positives'], 'ro', alpha=0.05)<br/>pyplot.title("Ransomware Detections Over Time")<br/>pyplot.xlabel("Date")<br/><span epub:type="pagebreak" id="page_165"/>pyplot.ylabel("Number of antivirus engine detections")<br/>pyplot.show()</p>
<p class="indent">These five lines of code mirror the code in <a href="ch09.xhtml#ch09list8">Listing 9-8</a>: they plot the data, title the plot, label its x- and y-axes, and then render everything to the screen (see <a href="ch09.xhtml#ch09fig4">Figure 9-4</a>). Again, if we wanted to save this plot to disk, we could replace the <span class="literal">pyplot.show()</span> call with <span class="literal">pyplot.savefig("myplot.png")</span>.</p>
<div class="image"><a id="ch09fig4"/><img alt="image" src="../images/f0165-01.jpg"/></div>
<p class="figcap"><em>Figure 9-4: Visualization of ransomware detections over time</em></p>
<p class="indent">Let’s try one more plot using the <span class="literal">plot()</span> function.</p>
<h4 class="h4" id="lev159"><strong><em>Plotting Ransomware and Worm Detection Rates</em></strong></h4>
<p class="noindent">This time, instead of just plotting ransomware detections over time, let’s also plot worm detections in the same graph. What becomes clear in <a href="ch09.xhtml#ch09fig5">Figure 9-5</a> is that the antivirus industry is better at detecting worms (an older malware trend) than ransomware (a newer malware trend).</p>
<p class="indent">In this plot, we see how many antivirus engines detected malware samples (y-axis) over time (x-axis). Each red dot represents a <span class="literal">type="ransomware"</span> malware sample, whereas each blue dot represents a <span class="literal">type="worm"</span> sample. We can see that on average, more engines detect worm samples than ransomware samples. However, the number of engines detecting both samples has been trending slowly up over time.</p>
<div class="image"><span epub:type="pagebreak" id="page_166"/><a id="ch09fig5"/><img alt="image" src="../images/f0166-01.jpg"/></div>
<p class="figcap"><em>Figure 9-5: Visualization of ransomware and worm malware detections over time</em></p>
<p class="indent"><a href="ch09.xhtml#ch09list10">Listing 9-10</a> shows the code for making this plot.</p>
<p class="programs">import dateutil<br/>import pandas<br/>from matplotlib import pyplot<br/><br/>malware = pandas.read_csv("malware_data.csv")<br/>malware['fs_date'] = [dateutil.parser.parse(d) for d in malware['fs_bucket']]<br/><br/>ransomware = malware[malware['type'] == 'ransomware']<br/>worms = malware[malware['type'] == 'worm']<br/><br/>pyplot.plot(ransomware['fs_date'], ransomware['positives'],<br/>            'ro', label="Ransomware", markersize=3, alpha=0.05)<br/>pyplot.plot(worms['fs_date'], worms['positives'],<br/>            'bo', label="Worm", markersize=3, alpha=0.05)<br/>pyplot.legend(framealpha=1, markerscale=3.0)<br/>pyplot.xlabel("Date")<br/>pyplot.ylabel("Number of detections")<br/>pyplot.ylim([0, 57])<br/>pyplot.title("Ransomware and Worm Vendor Detections Over Time")<br/>pyplot.show()</p>
<p class="listing" id="ch09list10"><em>Listing 9-10: Plotting ransomware and worm detection rates over time</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_167"/>Let’s walk through the code by looking at the first part of <a href="ch09.xhtml#ch09list10">Listing 9-10</a>:</p>
<p class="programs">   import dateutil<br/>   import pandas<br/>   from matplotlib import pyplot<br/><br/>   malware = pandas.read_csv("malware_data.csv")<br/>   malware['fs_date'] = [dateutil.parser.parse(d) for d in malware['fs_bucket']]<br/><br/>   ransomware = malware[malware['type'] == 'ransomware']<br/><span class="ent">➊</span> worms = malware[malware['type'] == "worm"]<br/>   --<span class="codeitalic1">snip</span>--</p>
<p class="indent">The code is similar to the previous example. The difference thus far is that we create the <span class="literal">worm</span> filtered version of our data <span class="ent">➊</span> using the same method with which we create the <span class="literal">ransomware</span> filtered data. Now let’s take a look at the rest of the code:</p>
<p class="programs">   --<span class="codeitalic1">snip</span>--<br/><span class="ent">➊</span> pyplot.plot(ransomware['fs_date'], ransomware['positives'],<br/>               'ro', label="Ransomware", markersize=3, alpha=0.05)<br/><span class="ent">➋</span> pyplot.plot(worms['fs_bucket'], worms['positives'],<br/>               'bo', label="Worm", markersize=3, alpha=0.05)<br/><span class="ent">➌</span> pyplot.legend(framealpha=1, markerscale=3.0)<br/>   pyplot.xlabel("Date")<br/>   pyplot.ylabel("Number of detections")<br/>   pyplot.ylim([0,57])<br/>   pyplot.title("Ransomware and Worm Vendor Detections Over Time")<br/>   pyplot.show()<br/>   pyplot.gcf().clf()</p>
<p class="indent">The main difference between this code and <a href="ch09.xhtml#ch09list9">Listing 9-9</a> is that we call the <span class="literal">plot()</span> function twice: once for the ransomware data using the <span class="literal">ro</span> selector <span class="ent">➊</span> to create red circles, and once more on the worm data using the <span class="literal">bo</span> selector <span class="ent">➋</span> to create blue circles for the worm data. Note that if we wanted to plot a third dataset, we could do this too. Also, unlike <a href="ch09.xhtml#ch09list9">Listing 9-9</a>, here, at <span class="ent">➌</span>, we create a legend for our figure showing that the blue marks stand for worm malware and the red marks stand for ransomware. The parameter <span class="literal">framealpha</span> determines how translucent the background of the legend is (by setting it to 1, we make it completely opaque), and the parameter <span class="literal">markerscale</span> scales the size of the markers in the legend (in this case, by a factor of three).</p>
<p class="indent">In this section, you’ve learned how to make some simple plots in <span class="literal">matplotlib</span>. However, let’s be honest—they’re not gorgeous. In the next section, we’re going to use another plotting library that should allow us to give our plots a more professional look, and help us implement more complex visualizations quickly.</p>
<h3 class="h3" id="lev160"><span epub:type="pagebreak" id="page_168"/><strong>Using seaborn to Visualize Data</strong></h3>
<p class="noindent">Now that we’ve discussed <span class="literal">pandas</span> and <span class="literal">matplotlib</span>, let’s move on to <span class="literal">seaborn</span>, which is a visualization library actually built on top of <span class="literal">matplotlib</span> but wrapped up in a slicker container. It includes built-in themes to style our graphics as well as premade higher-level functions that save time in performing more complicated analyses. These features make it simple and easy to produce sophisticated, beautiful plots.</p>
<p class="indent">To explore <span class="literal">seaborn</span>, let’s start by making a bar chart showing how many examples of each malware type we have in our dataset (see <a href="ch09.xhtml#ch09fig6">Figure 9-6</a>).</p>
<div class="image"><a id="ch09fig6"/><img alt="image" src="../images/f0168-01.jpg"/></div>
<p class="figcap"><em>Figure 9-6: Bar chart plot of the different kinds of malware in this chapter’s dataset</em></p>
<p class="indent"><a href="ch09.xhtml#ch09list11">Listing 9-11</a> shows the code to make this plot.</p>
<p class="programs">   import pandas<br/>   from matplotlib import pyplot<br/>   import seaborn<br/><br/><span class="ent">➊</span> malware = pandas.read_csv("malware_data.csv")<br/><span class="ent">➋</span> seaborn.countplot(x='type', data=malware)<br/><span class="ent">➌</span> pyplot.show()</p>
<p class="listing" id="ch09list11"><em>Listing 9-11: Creating a bar chart of malware counts by type</em></p>
<p class="indent">In this code, we first read in our data via <span class="literal">pandas.read_csv</span> <span class="ent">➊</span> and then use <span class="literal">seaborn</span>’s <span class="literal">countplot</span> function to create a barplot of the <span class="literal">type</span> column in our <span class="literal">DataFrame</span> <span class="ent">➋</span>. Finally, we make the plot appear by calling <span class="literal">pyplot</span>’s <span class="literal">show()</span> <span epub:type="pagebreak" id="page_169"/>method at <span class="ent">➌</span>. Recall that <span class="literal">seaborn</span> wraps <span class="literal">matplotlib</span>, which means we need to ask <span class="literal">matplotlib</span> to display our <span class="literal">seaborn</span> figures. Now let’s move on to a more complex sample plot.</p>
<h4 class="h4" id="lev161"><strong><em>Plotting the Distribution of Antivirus Detections</em></strong></h4>
<p class="noindent">The premise for the following plot is as follows: suppose we want to understand the distribution (frequency) of antivirus detections across malware samples in our dataset to understand what percentage of malware is missed by most antivirus engines, and what percentage is detected by most engines. This information gives us a view of the efficacy of the commercial antivirus industry. We can do this by plotting a bar chart (a histogram) showing, for each number of detections, the proportion of malware samples that had that number of detections, as shown in <a href="ch09.xhtml#ch09fig7">Figure 9-7</a>.</p>
<div class="image"><a id="ch09fig7"/><img alt="image" src="../images/f0169-01.jpg"/></div>
<p class="figcap"><em>Figure 9-7: Visualization of distribution of antivirus detections (positives)</em></p>
<p class="indent">The x-axis of this figure represents categories of malware samples, sorted by how many out of 57 total antivirus engines detected them. If a sample was detected as malicious by 50 of 57 engines, it is placed at 50, if it was only detected by 10 engines out of 57, it goes in the 10 category. The height of each bar is proportional to how many total samples ended up in that category.</p>
<p class="indent"><span epub:type="pagebreak" id="page_170"/>The plot makes it clear that many malware samples are detected by most of our 57 antivirus engines (shown by the big bump in frequencies in the upper-rightmost region of the plot) but also that a substantial minority of samples are detected by a small number of engines (shown in the leftmost region of the plot). We don’t show samples that were detected by fewer than five engines because of the methodology I used to construct this dataset: I define malware as samples that five or more antivirus engines detect. This plotted result, with substantial numbers of samples receiving just 5–30 detections, indicates that there is still significant disagreement between engines in malware detection. A sample that was detected as malware by 10 out of 57 engines either indicates that 47 engines failed to detect it, or that 10 made a mistake and issued a false positive on a benign file. The latter possibility is very unlikely, because antivirus vendors’ products have very low false-positive rates: it’s much more likely that most engines missed these samples.</p>
<p class="indent">Making this plot requires just a few lines of plotting code, as shown in <a href="ch09.xhtml#ch09list12">Listing 9-12</a>.</p>
<p class="programs">   import pandas<br/>   import seaborn<br/>   from matplotlib import pyplot<br/>   malware = pandas.read_csv("malware_data.csv")<br/><span class="ent">➊</span> axis = seaborn.distplot(malware['positives'])<br/><span class="ent">➋</span> axis.set(xlabel="Number of engines detecting each sample (out of 57)",<br/>            ylabel="Amount of samples in the dataset",<br/>            title="Commercial Antivirus Detections for Malware")<br/>   pyplot.show()</p>
<p class="listing" id="ch09list12"><em>Listing 9-12: Plotting distribution of positives</em></p>
<p class="indent">The <span class="literal">seaborn</span> package has a built-in function to create distribution plots (histograms), and so all we’ve done is pass the <span class="literal">distplot</span> function the data we wanted to display, which is <span class="literal">malware['positives']</span> <span class="ent">➊</span>. Then we use the axis object returned by <span class="literal">seaborn</span> to configure the plot title, x-axis label, and y-axis label to describe our plot <span class="ent">➋</span>.</p>
<p class="indent">Now let’s try a <span class="literal">seaborn</span> plot with two variables: the number of positive detections for malware (files with five or more detections) and their file sizes. We created this plot before with <span class="literal">matplotlib</span> in <a href="ch09.xhtml#ch09fig3">Figure 9-3</a>, but we can achieve a more attractive and informative result using <span class="literal">seaborn</span>’s <span class="literal">jointplot</span> function. The resulting plot, shown in <a href="ch09.xhtml#ch09fig8">Figure 9-8</a>, is richly informative but takes a bit of effort to understand at first, so let’s walk through it.</p>
<p class="indent">This plot is similar to the histogram we made in <a href="ch09.xhtml#ch09fig7">Figure 9-7</a>, but instead of displaying the distribution of a single variable via bar heights, this plot shows the distributions of <em>two</em> variables (the size of a malware file, on the x-axis, and the number of detections, on the y-axis) via color intensity. The darker the region, the more data is in that region. For example, we can see that files most commonly have a size of about 10<sup>5.5</sup> and a positives value of about 53. The subplots on the top and right of the main plots show a smoothed version of the frequencies of the size and detections data, which reveal the distribution of detections (as we saw in the previous plot) and file sizes.</p>
<div class="image"><span epub:type="pagebreak" id="page_171"/><a id="ch09fig8"/><img alt="image" src="../images/f0171-01.jpg"/></div>
<p class="figcap"><em>Figure 9-8: Visualization of the distribution of malware file sizes versus positive detections</em></p>
<p class="indent">The center plot is the most interesting, because it shows the relationship between size and positives. Instead of showing individual data points, like in <a href="ch09.xhtml#ch09fig3">Figure 9-3</a> with <span class="literal">matplotlib</span>, it shows the overall trend in a way that’s much clearer. This shows that very large malware files (size 10<sup>6</sup> and greater) are less commonly detected by antivirus engines, which tells us we might want to custom-build a solution that specializes in detecting such malware.</p>
<p class="indent">Creating this plot just requires one plotting call to <span class="literal">seaborn</span>, as shown in <a href="ch09.xhtml#ch09list13">Listing 9-13</a>.</p>
<p class="programs">   import pandas<br/>   import seaborn<br/>   import numpy<br/>   from matplotlib import pyplot<br/><br/>   malware = pandas.read_csv("malware_data.csv")<br/><span class="ent">➊</span> axis=seaborn.jointplot(x=numpy.log10(malware['size']),<br/>                          y=malware['positives'],<br/>                          kind="kde")<br/><span class="ent">➋</span> axis.set_axis_labels("Bytes in malware file (log base-10)",<br/>                        "Number of engines detecting malware (out of 57)")<br/>   pyplot.show()</p>
<p class="listing" id="ch09list13"><em>Listing 9-13: Plotting the distribution of malware file sizes vs. positive detections</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_172"/>Here, we use <span class="literal">seaborn</span>’s <span class="literal">jointplot</span> function to create a joint distribution plot of the <span class="literal">positives</span> and <span class="literal">size</span> columns in our <span class="literal">DataFrame</span> <span class="ent">➊</span>. Also, somewhat confusingly, for <span class="literal">seaborn</span>’s <span class="literal">jointplot</span> function, we have to call a different function than in <a href="ch09.xhtml#ch09list11">Listing 9-11</a> to label our axes: the <span class="literal">set_axis_labels()</span> function <span class="ent">➋</span>, whose first argument is the x-axis label and whose second argument is the y-axis label.</p>
<h4 class="h4" id="lev162"><strong><em>Creating a Violin Plot</em></strong></h4>
<p class="noindent">The last plot type we explore in this chapter is the <span class="literal">seaborn</span> violin plot. This plot allows us to elegantly explore the distribution of a given variable across several malware types. For example, suppose we’re interested in seeing the distribution of file sizes per malware type in our dataset. In this case, we can create a plot like <a href="ch09.xhtml#ch09fig9">Figure 9-9</a>.</p>
<div class="image"><a id="ch09fig9"/><img alt="image" src="../images/f0172-01.jpg"/></div>
<p class="figcap"><em>Figure 9-9: Visualization of file sizes by malware type</em></p>
<p class="indent">On the y-axis of this plot are file sizes, represented as powers of 10. On the x-axis we enumerate each malware type. As you can see, the thickness of the bars representing each file type varies at different size levels, which show how much of the data for that malware type is of that size. For example, you can see that there’s a substantial number of very large ransomware files, and that worms tend to have smaller file sizes—probably because worms aim to spread rapidly across a network, and worm authors thus tend to minimize their file sizes. Knowing these patterns could potentially help us to classify unknown files better (a larger file being more likely to be ransomware and less likely to be a worm), or teach us what file sizes we should focus on in a defensive tool targeted at a specific type of malware.</p>
<p class="indent"><span epub:type="pagebreak" id="page_173"/>Making the violin plot takes one plotting call, as shown in <a href="ch09.xhtml#ch09list14">Listing 9-14</a>.</p>
<p class="programs">   import pandas<br/>   import seaborn<br/>   from matplotlib import pyplot<br/><br/>   malware = pandas.read_csv("malware_data.csv")<br/><br/><span class="ent">➊</span> axis = seaborn.violinplot(x=malware['type'], y=malware['size'])<br/><span class="ent">➋</span> axis.set(xlabel="Malware type", ylabel="File size in bytes (log base-10)",<br/>            title="File Sizes by Malware Type", yscale="log")<br/><span class="ent">➌</span> pyplot.show()</p>
<p class="listing" id="ch09list14"><em>Listing 9-14: Creating a violin plot</em></p>
<p class="indent">In <a href="ch09.xhtml#ch09list14">Listing 9-14</a>, first we create the violin plot <span class="ent">➊</span>. Next we tell <span class="literal">seaborn</span> to set the axis labels and title and to set the y-axis to log-scale <span class="ent">➋</span>. Finally, we make the plot appear <span class="ent">➌</span>. We can also make an analogous plot showing the number of positives for each malware type, as shown in <a href="ch09.xhtml#ch09fig10">Figure 9-10</a>.</p>
<div class="image"><a id="ch09fig10"/><img alt="image" src="../images/f0173-01.jpg"/></div>
<p class="figcap"><em>Figure 9-10: Visualization of the number of antivirus positives (detections) per malware type</em></p>
<p class="indent">The only difference between <a href="ch09.xhtml#ch09fig9">Figure 9-9</a> and <a href="ch09.xhtml#ch09fig10">Figure 9-10</a> is that instead of looking at file size on the y-axis, we’re looking at the number of positives each file received. The results show some interesting trends. For example, ransomware is almost always detected by more than 30 scanners. The bitcoin, trojan, and keylogger malware types, in contrast, are detected by less than 30 scanners a substantial portion of the time, meaning more of these types <span epub:type="pagebreak" id="page_174"/>are slipping past the security industry’s defenses (folks who don’t have the scanners that detect these files installed are likely getting infected by these samples). <a href="ch09.xhtml#ch09list15">Listing 9-15</a> shows how to create the plot shown in <a href="ch09.xhtml#ch09fig10">Figure 9-10</a>.</p>
<p class="programs">import pandas<br/>import seaborn<br/>from matplotlib import pyplot<br/><br/>malware = pandas.read_csv("malware_data.csv")<br/><br/>axis = seaborn.violinplot(x=malware['type'], y=malware['positives'])<br/>axis.set(xlabel="Malware type", ylabel="Number of vendor detections",<br/>         title="Number of Detections by Malware Type")<br/>pyplot.show()</p>
<p class="listing" id="ch09list15"><em>Listing 9-15: Visualizing antivirus detections per malware type</em></p>
<p class="indent">The only differences in this code and the previous are that we pass the <span class="literal">violinplot</span> function different data (<span class="literal">malware['positives</span><span class="literal">']</span> instead of <span class="literal">malware['size']</span>), we label the axes differently, we set the title differently, and we omit setting the y-axis scale to log-10.</p>
<h3 class="h3" id="lev163"><strong>Summary</strong></h3>
<p class="noindent">In this chapter, you learned how visualization of malware data allows you to get macroscopic insights into trending threats and the efficacy of security tools. You used <span class="literal">pandas</span>, <span class="literal">matplotlib</span>, and <span class="literal">seaborn</span> to create your own visualizations and gain insight into sample datasets.</p>
<p class="indent">You also learned how to use methods like <span class="literal">describe()</span> in <span class="literal">pandas</span> to show useful statistics and how to extract subsets of your dataset. You then used these subsets of data to create your own visualizations to assess improvements in antivirus detections, analyze trending malware types, and answer other broader questions.</p>
<p class="indent">These are powerful tools that transform the security data you have into actionable intelligence that can inform the development of new tools and techniques. I hope you’ll learn more about data visualizations and incorporate them into your malware and security analysis workflow.</p>
</body></html>