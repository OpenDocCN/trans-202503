["```\nfive := x x x x x\n\nall: ; @echo $(words $(five))\n```", "```\ndecode = $(words $1)\n```", "```\nfive := x x x x x\n\nall: ; @echo $(call decode,$(five))\n```", "```\nplus = $1 $2\nincrement = x $1\ndecrement = $(wordlist 2,$(words $1),$1)\n```", "```\ntwo := x x\nthree := x x x\nfour := x x x x\nfive := x x x x x\nsix := x x x x x x\n\nall: ; @echo $(call decode,$(call plus,$(five),$(six)))\n```", "```\ndouble = $1 $1\n```", "```\nmax = $(subst xx,x,$(join $1,$2))\nmin = $(subst xx,x,$(filter xx,$(join $1,$2)))\n```", "```\n$(call max,$(five),$(six))\n→  $(call max,x x x x x,x x x x x x)\n→  $(subst xx,x,$(join x x x x x,x x x x x x))\n→  $(subst xx,x,xx xx xx xx xx x)\n→  x x x x x x\n```", "```\n$(call min,$(five),$(six))\n→  $(call min,x x x x x,x x x x x x)\n→  $(subst xx,x,$(filter xx,$(join x x x x x,x x x x x x)))\n→  $(subst xx,x,$(filter xx,xx xx xx xx xx x))\n→  $(subst xx,x,xx xx xx xx xx)\n→  x x x x x\n```", "```\nsubtract = $(if $(call gte,$1,$2),          \\\n       $(filter-out xx,$(join $1,$2)),      \\\n       $(warning Subtraction underflow))\n```", "```\n$(filter-out xx,$(join $(six),$(five)))\n→  $(filter-out xx,$(join x x x x x x,x x x x x))\n→  $(filter-out xx,xx xx xx xx xx x)\n→  x\n```", "```\ngt = $(filter-out $(words $2),$(words $(call max,$1,$2)))\neq = $(filter $(words $1),$(words $2))\ngte = $(call gt,$1,$2)$(call eq,$1,$2)\n```", "```\n$(call eq,$(five),$(five))\n→  $(call eq,x x x x x,x x x x x)\n→  $(filter $(words x x x x x),$(words x x x x x))\n→  $(filter 5,5)\n→  5\n```", "```\n$(call eq,$(five),$(six))\n→  $(call eq,x x x x x,x x x x x x)\n→  $(filter $(words x x x x x),$(words x x x x x x))\n→  $(filter 5,6)\n```", "```\n$(call gt,$(six),$(five))\n→  $(call gt,x x x x x x,x x x x x)\n→  $(filter-out $(words x x x x x),\n   $(words $(call max,x x x x x x,x x x x x)))\n→  $(filter-out $(words x x x x x),$(words x x x x x x))\n→  $(filter-out 5,6)\n→  6\n```", "```\n$(call gt,$(five),$(six))\n→  $(call gt,x x x x x,x x x x x x)\n→  $(filter-out $(words x x x x x x),\n   $(words $(call max,x x x x x x,x x x x x)))\n→  $(filter-out $(words x x x x x x),$(words x x x x x x))\n→  $(filter-out 6,6)\n```", "```\nlt = $(filter-out $(words $1),$(words $(call max,$1,$2)))\nne = $(filter-out $(words $1),$(words $2))\nlte = $(call lt,$1,$2)$(call eq,$1,$2)\n```", "```\nmultiply = $(foreach a,$1,$2)\n```", "```\n$(call multiply,$(two),$(three))\n→  $(call multiply,x x,x x x)\n→  $(foreach a,x x,x x x)\n→  x x x x x x\n```", "```\ndivide = $(if $(call gte,$1,$2),             \\\n    x $(call divide,$(call subtract,$1,$2),$2),)\n```", "```\n$(call divide,$(three),$(two))\n→  $(call divide,x x x,x x)\n→  $(if $(call gte,x x x,x x),\n   x $(call divide,$(call subtract,x x x,x x),x x),)\n\n→  x $(call divide,$(call subtract,x x x,x x),x x)\n→  x $(call divide,x,x x)\n→  x $(if $(call gte,x,x x),\n   x $(call divide,$(call subtract,x,x x),x x),)\n\n→  x\n```", "```\nhalve = $(subst xx,x,      \\\n   $(filter-out xy x y,    \\\n     $(join $1,$(foreach a,$1,y x))))\n```", "```\n16 := x x x x x x x x x x x x x x x x\ninput_int := $(foreach a,$(16),      \\\n       $(foreach b,$(16),            \\\n        $(foreach c,$(16),$(16)))))\n\nencode = $(wordlist 1,$1,$(input_int))\n```", "```\nstack :=\n\npush = $(eval stack := $$1 $(stack))\npop = $(word 1,$(stack))$(eval stack := $(wordlist 2,$(words $(stack)),$(stack)))\npope = $(call encode,$(call pop))\npushd = $(call push,$(call decode,$1))\ncomma := ,\ncalculate = $(foreach t,$(subst $(comma), ,$1),$(call handle,$t))$(stack)\nseq = $(filter $1,$2)\nhandle = $(call pushd,                            \\\n    $(if $(call seq,+,$1),                        \\\n      $(call plus,$(call pope),$(call pope)),     \\\n      $(if $(call seq,-,$1),                      \\\n      $(call subtract,$(call pope),$(call pope)), \\\n        $(if $(call seq,*,$1),                    \\\n     $(call multiply,$(call pope),$(call pope)),  \\\n        $(if $(call seq,/,$1),                    \\\n       $(call divide,$(call pope),$(call pope)),  \\\n           $(call encode,$1))))))\n\n.PHONY: calc\ncalc: ; @echo $(call calculate,$(calc))\n```", "```\n$ **make calc=\"3,1,-,3,21,5,*,+,/\"**\n54\n```", "```\n# input_int consists of 65536 x's built from the 16 x's in 16\n\n16 := x x x x x x x x x x x x x x x x\ninput_int := $(foreach a,$(16),$(foreach b,$(16),$(foreach c,$(16),$(16)))))\n\n# decode turns a number in x's representation into an integer for human\n# consumption\n\ndecode = $(words $1)\n\n# encode takes an integer and returns the appropriate x's\n# representation of the number by chopping $1 x's from the start of\n# input_int\n\nencode = $(wordlist 1,$1,$(input_int))\n\n# plus adds its two arguments, subtract subtracts its second argument\n# from its first if and only if this would not result in a negative result\n\nplus = $1 $2\n\nsubtract = $(if $(call gte,$1,$2),     \\\n       $(filter-out xx,$(join $1,$2)), \\\n       $(warning Subtraction underflow))\n\n# multiply multiplies its two arguments and divide divides its first\n# argument by its second\n\nmultiply = $(foreach a,$1,$2)\ndivide = $(if $(call gte,$1,$2),x $(call divide,$(call subtract,$1,$2),$2),)\n\n# max returns the maximum of its arguments and min the minimum\n\nmax = $(subst xx,x,$(join $1,$2))\nmin = $(subst xx,x,$(filter xx,$(join $1,$2)))\n\n# The following operators return a non-empty string if their result is true:\n#\n# gt First argument is greater than second argument\n# gte First argument is greater than or equal to second argument\n# lt First argument is less than second argument\n\n# lte First argument is less than or equal to second argument\n# eq First argument is numerically equal to the second argument\n# ne First argument is not numerically equal to the second argument\n\ngt = $(filter-out $(words $2),$(words $(call max,$1,$2)))\nlt = $(filter-out $(words $1),$(words $(call max,$1,$2)))\neq = $(filter $(words $1),$(words $2))\nne = $(filter-out $(words $1),$(words $2))\ngte = $(call gt,$1,$2)$(call eq,$1,$2)\nlte = $(call lt,$1,$2)$(call eq,$1,$2)\n\n# increment adds 1 to its argument, decrement subtracts 1\\. Note that\n# decrement does not range check and hence will not underflow, but\n# will incorrectly say that 0 - 1 = 0\n\nincrement = $1 x\ndecrement = $(wordlist 2,$(words $1),$1)\n\n# double doubles its argument, and halve halves it\n\ndouble = $1 $1\nhalve = $(subst xx,x,$(filter-out xy x y,$(join $1,$(foreach a,$1,y x))))\n\n# This code implements a Reverse Polish Notation calculator by\n# transforming a comma-separated list of operators (+ - * /) and\n# numbers stored in the calc variable into the appropriate calls to\n# the arithmetic functions defined in this makefile.\n\n# This is the current stack of numbers entered into the calculator. The push\n# function puts an item onto the top of the stack (the start of the list), and\n# pop removes the top item.\n\nstack :=\n\npush = $(eval stack := $$1 $(stack))\npop = $(word 1,$(stack))$(eval stack := $(wordlist 2,$(words $(stack)),$(stack)))\n\n# pope pops a number off the stack and encodes it\n# and pushd pushes a number onto the stack after decoding\n\npope = $(call encode,$(call pop))\npushd = $(call push,$(call decode,$1))\n\n# calculate runs through the input numbers and operations and either\n# pushes a number on the stack or pops two numbers off and does a\n# calculation followed by pushing the result back. When calculate is\n# finished, there will be one item on the stack, which is the result.\n\ncomma := ,\ncalculate=$(foreach t,$(subst $(comma), ,$1),$(call handle,$t))$(stack)\n\n# seq is a string equality operator that returns true (a non-empty\n# string) if the two strings are equal\n\nseq = $(filter $1,$2)\n\n# handle is used by calculate to handle a single token. If it's an\n# operator, the appropriate operator function is called; if it's a\n# number, it is pushed.\n\nhandle = $(call pushd,                            \\\n      $(if $(call seq,+,$1),                      \\\n        $(call plus,$(call pope),$(call pope)),   \\\n        $(if $(call seq,-,$1),                    \\\n      $(call subtract,$(call pope),$(call pope)), \\\n          $(if $(call seq,*,$1),                  \\\n      $(call multiply,$(call pope),$(call pope)), \\\n            $(if $(call seq,/,$1),                \\\n       $(call divide,$(call pope),$(call pope)),  \\\n              $(call encode,$1))))))\n\n.PHONY: calc\ncalc: ; @echo $(call calculate,$(calc))\n```", "```\nall: foo bar\n→  @echo Making $@\n\nfoo: baz\n→  @echo Making $@\n\nbar:\n→  @echo Making $@\n\nbaz:\n→  @echo Making $@\n```", "```\n$ **make**\nMaking baz\nMaking foo\nMaking bar\nMaking all\n```", "```\n<rule target=\"all\">\n<prereq>\n <rule target=\"foo\">\n  <prereq>\n   <rule target=\"baz\" />\n  </prereq>\n </rule>\n <rule target=\"bar\" />\n</prereq>\n</rule>\n```", "```\n➊ PARENT_MAKEFILE := $(word $(words $(MAKEFILE_LIST)),x $(MAKEFILE_LIST))\n➋ bom-file := $(PARENT_MAKEFILE).xml\n\n➌ bom-old-shell := $(SHELL)\n➍ SHELL = $(bom-run)$(bom-old-shell)\n\n   bom-%: %\n➎ → @$(shell rm -f $(bom-file))$(call bom-dump,$*)\n   bom-write = $(shell echo '$1' >> $(bom-file))\n➏ bom-dump = $(if $(bom-prereq-$1),$(call bom-write,<rule target=\"$1\">)      \\\n   $(call bom-write,<prereq>)$(foreach p,$(bom-prereq-$1),                    \\\n   $(call bom-dump,$p))$(call bom-write,</prereq>)$(call bom-write,</rule>),  \\\n   $(call bom-write,<rule target=\"$1\" />))\n\n➐ bom-run = $(if $@,$(eval bom-prereq-$@ := $^))\n```", "```\nbom-%: %\n→  @$(shell rm -f $(bom-file))$(call bom-write,<bom>)$(call bom-dump,$*)$(call bom-write,</bom>)\n\nbom-write = $(shell echo '$1' >> $(bom-file))\n\nbom-dump = $(if $(bom-prereq-$1),$(call bom-write,<rule target=\"$1\">) \\\n$(call bom-write,<prereq>)$(foreach p,$(bom-prereq-$1),               \\\n$(call bom-write,<rule target=\"$p\" />))$(call bom-write,</prereq>)    \\\n$(call bom-write,</rule>),$(call bom-write,<rule target=\"$1\" />))     \\\n$(foreach p,$(bom-prereq-$1),$(call bom-dump,$p))$(eval bom-prereq-$1 := )\n```", "```\n<bom>\n<rule target=\"all\">\n <prereq>\n  <rule target=\"foo\" />\n  <rule target=\"bar\" />\n </prereq>\n</rule>\n<rule target=\"foo\">\n <prereq>\n  <rule target=\"baz\" />\n </prereq>\n</rule>\n<rule target=\"baz\" />\n<rule target=\"bar\" />\n</bom>\n```", "```\nall: foo bar\n→ @echo Making $@\n\nfoo: baz\n\nbar:\n→ @echo Making $@\n\nbaz:\n→ @echo Making $@\n```", "```\n<bom>\n<rule target=\"all\">\n <prereq>\n  <rule target=\"foo\" />\n  <rule target=\"bar\" />\n </prereq>\n</rule>\n<rule target=\"foo\" />\n<rule target=\"bar\" />\n</bom>\n```", "```\nfoo: baz ; @true\n```", "```\n$ **cd make-3.81**\n$ **./configure**\n$ **make**\n```", "```\n$ **./make -v**\nGNU Make 3.81\nCopyright (C) 2006 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE.\n\nThis program built for i386-apple-darwin9.2.0\n```", "```\n/* Print version information. */\n\nstatic void\nprint_version (void)\n{\nstatic int printed_version = 0;\n\nchar *precede = print_data_base_flag ? \"# \" : \"\";\n\nif (printed_version)\n /* Do it only once. */\n return;\n\n/* Print this untranslated. The coding standards recommend translating the\n  (C) to the copyright symbol, but this string is going to change every\n  year, and none of the rest of it should be translated (including the\n  word \"Copyright\", so it hardly seems worth it. */\n\nprintf (\"%sGNU Make %s\\n\\\n%sCopyright (C) 2006 Free Software Foundation, Inc.\\n\",\n    precede, version_string, precede);\n\nprintf (_(\"%sThis is free software; see the source for copying conditions.\\n\\\n%sThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\\n\\\n%sPARTICULAR PURPOSE.\\n\"),\n     precede, precede, precede);\n\nif (!remote_description || *remote_description == '\\0')\n printf (_(\"\\n%sThis program built for %s\\n\"), precede, make_host);\nelse\n printf (_(\"\\n%sThis program built for %s (%s)\\n\"),\n     precede, make_host, remote_description);\n\nprinted_version = 1;\n\n/* Flush stdout so the user doesn't have to wait to see the\n  version information while things are thought about. */\nfflush (stdout);\n}\n```", "```\nprintf (\"%sGNU Make %s (with jgc's modifications)\\n\\\n%sCopyright (C) 2006 Free Software Foundation, Inc.\\n\",\n    precede, version_string, precede);\n```", "```\n$ **./make -v**\nGNU Make 3.81 (with jgc's modifications)\nCopyright (C) 2006 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE.\n\nThis program built for i386-apple-darwin9.2.0\n```", "```\nstatic struct function_table_entry function_table_init[] =\n{\n/* Name/size */          /* MIN MAX EXP? Function */\n{ STRING_SIZE_TUPLE(\"abspath\"),    0, 1, 1, func_abspath},\n{ STRING_SIZE_TUPLE(\"addprefix\"),   2, 2, 1,\nfunc_addsuffix_addprefix},\n{ STRING_SIZE_TUPLE(\"addsuffix\"),   2, 2, 1,\nfunc_addsuffix_addprefix},\n{ STRING_SIZE_TUPLE(\"basename\"),   0, 1, 1, func_basename_dir},\n{ STRING_SIZE_TUPLE(\"dir\"),      0, 1, 1, func_basename_dir},\n--*snip*--\n\n{ STRING_SIZE_TUPLE(\"value\"),     0, 1, 1, func_value},\n{ STRING_SIZE_TUPLE(\"eval\"),     0, 1, 1, func_eval},\n#ifdef EXPERIMENTAL\n{ STRING_SIZE_TUPLE(\"eq\"),      2, 2, 1, func_eq},\n{ STRING_SIZE_TUPLE(\"not\"),      0, 1, 1, func_not},\n#endif\n};\n```", "```\n{ STRING_SIZE_TUPLE(\"findstring\"), 2, 2, 1, func_findstring},\n```", "```\nstatic char*\nfunc_findstring (char *o, char **argv, const char *funcname UNUSED)\n{\n/* Find the first occurrence of the first string in the second. */\nif (strstr (argv[1], argv[0]) != 0)\n o = variable_buffer_output (o, argv[0], strlen (argv[0]));\n\nreturn o;\n}\n```", "```\n{ STRING_SIZE_TUPLE(\"reverse\"), 1, 1, 1, func_reverse},\n```", "```\nstatic char*\nfunc_reverse(char *o, char **argv, const char *funcname UNUSED)\n{\nint len = strlen(argv[0]);\nif (len > 0) {\n char * p = argv[0];\n int left = 0;\n int right = len - 1;\n while (left < right) {\n  char temp = *(p + left);\n  *(p + left) = *(p + right);\n  *(p + right) = temp;\n  left++;\n  right--;\n }\n\n o = variable_buffer_output(o, p, len);\n}\n\nreturn o;\n}\n```", "```\nEMPTY :=\n\n$(info Empty string: [$(reverse $(EMPTY))]);\n\nEVEN := 1234\n$(info Even length string: [$(reverse $(EVEN))]);\n\nODD := ABCDE\n$(info Odd length string: [$(reverse $(ODD))]);\n```", "```\n$ **./make**\nEmpty string: []\nEven length string: [4321]\nOdd length string: [EDCBA]\n```", "```\n   #include <string.h>\n   #include <gnumake.h>\n\n➊ int plugin_is_GPL_compatible;\n\n   char* func_reverse(const char *nm, unsigned int argc, char **argv)\n   {\n     int len = strlen(argv[0]);\n     if (len > 0) {\n➋     char * p = gmk_alloc(len+1);\n       *(p+len) = '\\0';\n       int i;\n       for (i = 0; i < len; i++) {\n         *(p+i) = *(argv[0]+len-i-1);\n       }\n       return p;\n     }\n\n     return NULL;\n   }\n\n   int reverse_gmk_setup()\n   {\n➌   gmk_add_function(\"reverse\", func_reverse, 1, 1, 1);\n     return 1;\n   }\n```", "```\n   all:\n   --*snip*--\n   load reverse.so\n➍ reverse.so: reverse.c ; @$(CC) -shared -fPIC -o $@ $<\n```", "```\nA_PALINDROME := $(reverse saippuakivikauppias)\n```", "```\n   NAMES := liesl friedrich louisa kurt brigitta marta gretl\n\n➊ $(info $(guile (reverse '($(NAMES)))))\n```", "```\n$ make\ngretl marta brigitta kurt louisa friedrich liesl\n```", "```\n$(info $(guile (reverse '(liesl friedrich louisa kurt brigitta marta gretl))))\n```", "```\nfile-exists = $(guile (access? \"$1\" R_OK))\n```", "```\ndefine setup\n(use-modules (web uri))\n(use-modules (web client))\n(use-modules (ice-9 receive))\nendef\n\n$(guile $(setup))\n\nUA := \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_0) \\\nAppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.115 \\\nSafari/537.36\"\n\ndefine get-url\n(receive (headers body)\n  (http-get\n    (string->uri \"$1\")\n    #:headers '((User-Agent . $(UA))))\n  body)\nendef\nutc-time = $(guile $(call get-url,http://www.timeapi.org/utc/now))\n\n$(info $(utc-time))\n```", "```\ninclude help-system.mk\n\nall: $(call print-help,all,Build all modules in Banana Wumpus system)\n→ ...commands for building all ...\n\nclean: $(call print-help,clean,Remove all object and library files)\n→ ...commands for doing a clean ...\n\npackage: $(call print-help,package,Package application-must run all target first)\n→ ...commands for doing package step ...\n```", "```\n$ **make**\nType 'make help' to get help\n```", "```\n$ **make help**\nMakefile:11: all -- Build all modules in Banana Wumpus system\nMakefile:17: clean -- Remove all object and library files\nMakefile:23: package -- Package application-must run all target first\n```", "```\ndefine print-help\n$(if $(need-help),$(warning $1 -- $2))\nendef\n```", "```\nneed-help := $(filter help,$(MAKECMDGOALS))\n```", "```\nhelp: ; @echo $(if $(need-help),,Type \\'$(MAKE)$(dash-f) help\\' to get help)\n```", "```\ndash-f := $(if $(filter-out Makefile makefile GNUmakefile, \\\n$(parent-makefile)), -f $(parent-makefile))\n```", "```\nthis-makefile := $(call last-element,$(MAKEFILE_LIST))\n```", "```\nother-makefiles := $(filter-out $(this-makefile),$(MAKEFILE_LIST))\n```", "```\nparent-makefile := $(call last-element,$(other-makefiles))\n```", "```\ndefine last-element\n$(word $(words $1),$1)\nendef\n```", "```\nhelp: ; @echo $(if $(need-help),,Type \\'$(MAKE)$(dash-f) help\\' to get help)\n\nneed-help := $(filter help,$(MAKECMDGOALS))\n\ndefine print-help\n$(if $(need-help),$(warning $1 -- $2))\nendef\n\ndefine last-element\n$(word $(words $1),$1)\nendef\n\nthis-makefile := $(call last-element,$(MAKEFILE_LIST))\nother-makefiles := $(filter-out $(this-makefile),$(MAKEFILE_LIST))\nparent-makefile := $(call last-element,$(other-makefiles))\n\ndash-f := $(if $(filter-out Makefile makefile GNUmakefile, \\\n$(parent-makefile)), -f $(parent-makefile))\n```"]