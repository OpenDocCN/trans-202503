- en: Chapter 10. Texture Baking
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章. 纹理烘焙
- en: Having modeled, sculpted, retopologized, and UV unwrapped our models, we’re
    now ready to create textures and materials for them and then move on to lighting
    and rendering. In this chapter, we’ll focus on baking textures—creating procedural
    textures using the geometry, lighting, and materials of objects in our scene.
    For example, we’ll bake the normals of a high-poly sculpted mesh into a texture
    map or bake the shadows that a mesh receives in the cracks and grooves of its
    surface into a texture to mimic dirt and dust. Textures like these can then be
    used to aid in texturing and creating materials later.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在对我们的模型进行建模、雕刻、重拓扑和UV展开后，我们现在准备为它们创建纹理和材质，然后继续进行灯光和渲染。在本章中，我们将重点讨论纹理烘焙——利用场景中的几何体、灯光和材质来创建程序化纹理。例如，我们将把高细分雕刻网格的法线烘焙成一个纹理贴图，或者将网格表面裂缝和凹槽中收到的阴影烘焙成一个纹理，以模拟污垢和灰尘。像这样的纹理随后可以用于辅助纹理绘制和材质创建。
- en: In this chapter, we’ll discuss the various types of procedural texture maps
    that Blender is able to bake, their uses, and how to bake them. In [Chapter 11](ch11.html
    "Chapter 11. Texture Painting"), we’ll move on to combining these baked textures
    with hand painting and other techniques in GIMP and Blender, cleaning them up
    and combining them with other texture sources, such as photos. Then, in [Chapter 12](ch12.html
    "Chapter 12. Materials"), we’ll cover how to plug all these kinds of maps into
    Blender’s materials system to create realistic materials for rendering our models
    with.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论Blender能够烘焙的各种类型的程序化纹理贴图，它们的用途以及如何烘焙它们。在[第11章](ch11.html "第11章. 纹理绘制")中，我们将继续将这些烘焙的纹理与手绘和Blender以及GIMP中的其他技术相结合，进行清理并与其他纹理源（如照片）合并。接着，在[第12章](ch12.html
    "第12章. 材质")中，我们将讲解如何将这些不同类型的贴图与Blender的材质系统结合，以创建真实的材质用于渲染我们的模型。
- en: Images and Textures
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像和纹理
- en: 'First, a little terminology: The terms *image* and *texture* are often used
    interchangeably. In most circumstances, this is fine, but I shall try to avoid
    confusion here by explaining my terminology. An *image*, for our purposes, is
    a picture, perhaps in the form of an image file, like a *.jpg* or *.tiff* file
    or a file generated within Blender’s UV Image editor with no specific file type
    assigned to it yet.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一些术语：*图像*和*纹理*这两个术语经常互换使用。在大多数情况下，这没有问题，但我将在这里尽量避免混淆，并解释我的术语。对于我们的目的来说，*图像*是指一张图片，可能是一个图像文件，比如*.jpg*或*.tiff*文件，或者是通过Blender的UV图像编辑器生成的文件，但尚未分配特定的文件类型。
- en: A *texture* in Blender can be any kind of input used to affect the look of a
    material applied to an object. A texture can be an image, but a texture may also
    be procedurally generated or taken from a video, point cloud data, or something
    even more obscure. But because we frequently use images as the input for textures,
    it’s often convenient to refer to “an image used to affect a material’s diffuse
    color” as a *diffuse texture* for short.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blender中，*纹理*可以是任何影响物体上材质外观的输入。纹理可以是图像，但也可以是程序生成的，或来自视频、点云数据，甚至是更为特殊的内容。但因为我们经常使用图像作为纹理的输入，所以通常方便将“用于影响材质漫反射颜色的图像”简称为*漫反射纹理*。
- en: In general, when I refer to baking textures, I mean an image *used* as a texture.
    As this would rapidly become tedious to read, I’ll often instead use the term
    *texture* more loosely—particularly as the process of baking images is so frequently
    referred to as *texture baking*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当我提到烘焙纹理时，我指的是作为纹理使用的图像。因为这样写会变得冗长，所以我通常会更宽泛地使用*纹理*这个术语——尤其是在烘焙图像的过程中，它通常被称为*纹理烘焙*。
- en: The term *map* when used in the context of textures (such as *texture map*,
    *diffuse map*, and *displacement map*) refers to an image used for a UV unwrapped
    object—one in which each point on the object can be mapped to a point on the image.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在纹理的上下文中使用的术语*贴图*（如*纹理贴图*、*漫反射贴图*和*位移贴图*）指的是用于UV展开物体的图像——其中物体上的每个点都可以映射到图像上的一个点。
- en: In this book, I often talk about *assigning* an image or texture to an object.
    Assigning an image to an object is different from assigning a texture.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我经常提到*分配*图像或纹理给物体。将图像分配给物体与将纹理分配给物体是不同的。
- en: Assigning an Image
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分配图像
- en: When I assign an image to an object, I link that image with the object’s active
    UV coordinate set. This causes the image to be displayed on the object when using
    the *Textured Solid* shading option in the 3D Viewport (found under Display in
    the 3D Viewport Properties region). It also means that when baking images, this
    will be the image that is baked to.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我为一个对象分配图像时，我将该图像与对象的活动 UV 坐标集链接。这样，当在 3D 视口中使用*纹理实心*阴影选项时，图像将显示在对象上（该选项位于
    3D 视口属性区域的显示下）。这也意味着在烘焙图像时，烘焙到的将是这个图像。
- en: To assign an image to an object’s UV coordinates, select the object in the 3D
    Viewport and press TAB to enter Edit mode. Hit **A** to select all, then in the
    UV Image editor (I’m assuming here that the object has already been unwrapped),
    use the dropdown menu in the Editors header to select an image to assign to the
    active UV set.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要为对象的 UV 坐标分配图像，首先在 3D 视口中选择该对象，然后按 TAB 进入编辑模式。按 **A** 选择所有内容，然后在 UV 图像编辑器中（假设该对象已经展开），使用编辑器头部的下拉菜单选择一个图像，并将其分配给活动的
    UV 集。
- en: To create a new image and assign that instead, use **Image**▸**New Image** to
    create a new image to bake to with the size and properties you specify.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 若要创建一个新的图像并将其指定为烘焙目标，使用**图像**▸**新建图像**来创建一个新的图像并设置其大小和属性。
- en: Assigning Textures
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分配纹理
- en: '*Textures* are assigned to materials, which are then assigned to objects or
    parts of objects. Textures are used to affect how an object will be rendered and
    also as inputs for some modifiers. To assign a material to an object, go to the
    Materials tab of the Properties editor to choose a material from the drop-down
    menu at the top of the tab or create a new material with the **+New** button.
    You can then assign textures to this material in the Textures tab in the same
    way.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*纹理* 被分配给材质，然后这些材质被分配给对象或对象的某部分。纹理用于影响对象的渲染效果，也可以作为某些修改器的输入。要为对象分配材质，请进入属性编辑器中的材质标签，从标签顶部的下拉菜单中选择一个材质，或者使用**+新建**按钮创建一个新材质。然后，你可以在纹理标签中以相同的方式为该材质分配纹理。'
- en: Texture-Baking Controls
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纹理烘焙控制
- en: 'To bake a texture (technically, an image—from here on I will use the two terms
    less rigorously) in Blender, use the Bake panel in the Render tab of the Properties
    editor (shown in [Figure 10-1](ch10.html#texture-baking_controls_while_working_in
    "Figure 10-1. Texture-baking controls while working in the UV editing layout we
    created in Chapter 8\. The UV editing layout is useful because it allows us to
    access our baking controls through the Properties editor, the baked images through
    the UV Image editor, and the objects in our scene through the 3D Viewport, all
    in one layout.")). This contains all of Blender’s settings and tools for baking
    texture maps, including the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Blender 中烘焙一个纹理（技术上说是一个图像——从这里开始我会不那么严格地使用这两个术语），请使用属性编辑器中的渲染标签下的烘焙面板（如[图
    10-1](ch10.html#texture-baking_controls_while_working_in "图 10-1. 在 UV 编辑布局中工作时的纹理烘焙控制，该布局有助于我们通过属性编辑器访问烘焙控制，使用
    UV 图像编辑器查看烘焙图像，并通过 3D 视口查看场景中的对象，所有这些都可以在一个布局中完成。")所示）。该面板包含了 Blender 所有的纹理烘焙设置和工具，包括以下内容：
- en: '****Bake****. This button bakes images for the currently selected objects,
    using the bake settings you’ve defined.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '****烘焙****。此按钮根据你定义的烘焙设置，为当前选定的对象烘焙图像。'
- en: '****Bake mode****. These settings are used to set what kind of map you are
    baking.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '****烘焙模式****。这些设置用于设置你正在烘焙的地图类型。'
- en: '****Clear****. This option clears the texture and replaces it with black before
    baking.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '****清除****。此选项在烘焙之前清除纹理并将其替换为黑色。'
- en: '****Margin****. This option extends the baked textures out beyond the edges
    of the UV islands by the number of pixels you set to prevent seams showing on
    the mesh.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '****边距****。此选项通过你设置的像素数量，将烘焙纹理延伸到 UV 岛的边缘之外，以防止网格上出现接缝。'
- en: '****Selected to Active****. This option enables baking from one mesh to another.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '****从选定到活动****。此选项启用从一个网格到另一个网格的烘焙。'
- en: '****Distance and Bias****. These settings determine how far Blender will look
    for the surface of the other mesh when baking from Selected to Active.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '****距离和偏差****。这些设置决定了在从选定对象烘焙到活动对象时，Blender 会寻找另一个网格表面的距离。'
- en: 'In order to bake a texture, Blender needs two inputs:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要烘焙一个纹理，Blender 需要两个输入：
- en: A mesh with UV coordinates that you want to bake textures for. This must be
    selected as the active object, and the UV coordinates you want to bake to must
    be the active set.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有 UV 坐标的网格，你想要为其烘焙纹理。该网格必须被选为活动对象，且你想要烘焙到的 UV 坐标集必须是活动集。
- en: An image to bake the texture to, assigned to the object’s active UV coordinate
    set.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用来烘焙纹理的图像，分配给对象的活动 UV 坐标集。
- en: 'With these inputs in place, click **Bake** in the Bake panel to have Blender
    render the texture. Blender should render the map type dictated by the Bake Mode
    setting (see [Figure 10-1](ch10.html#texture-baking_controls_while_working_in
    "Figure 10-1. Texture-baking controls while working in the UV editing layout we
    created in Chapter 8\. The UV editing layout is useful because it allows us to
    access our baking controls through the Properties editor, the baked images through
    the UV Image editor, and the objects in our scene through the 3D Viewport, all
    in one layout.")) and take the following into account when baking:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好这些输入后，点击烘焙面板中的**烘焙**按钮，让 Blender 渲染纹理。Blender 应该根据烘焙模式设置渲染相应的地图类型（参见[图 10-1](ch10.html#texture-baking_controls_while_working_in
    "图 10-1. 在我们创建的 UV 编辑布局中工作时的纹理烘焙控制。UV 编辑布局很有用，因为它让我们通过属性编辑器访问烘焙控制，通过 UV 图像编辑器访问烘焙图像，并通过
    3D 视口访问场景中的对象，所有这些都在一个布局中。")），并在烘焙时考虑以下内容：
- en: '****Selected objects****. Blender will bake textures for any selected objects
    that have UV coordinates with an image assigned to them. You can bake multiple
    textures at once, as well as baking multiple objects.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '****选定对象****。Blender 会为任何选定的对象烘焙纹理，只要它们的 UV 坐标分配了图像。你可以一次性烘焙多个纹理，也可以烘焙多个对象。'
- en: '****Other objects on currently visible layers****. Unselected objects will
    not be baked, but when baking lighting or other maps that are affected by the
    selected object’s surroundings, Blender will take into account the other objects
    (meshes, lights, and so on) that are on the currently visible layers. To bake
    the lighting for an object in isolation, place it temporarily on its own layer,
    along with the lights you want to affect it.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '****当前可见层上的其他对象****。未选择的对象将不会被烘焙，但在烘焙灯光或其他受选定对象周围环境影响的图像时，Blender 会考虑当前可见层上的其他对象（如网格、光源等）。要单独烘焙一个对象的灯光，请暂时将它放置在自己的层上，并且放置你希望影响它的光源。'
- en: '![Texture-baking controls while working in the UV editing layout we created
    in . The UV editing layout is useful because it allows us to access our baking
    controls through the Properties editor, the baked images through the UV Image
    editor, and the objects in our scene through the 3D Viewport, all in one layout.](httpatomoreillycomsourcenostarchimages1538628.png.jpg)Figure 10-1. Texture-baking
    controls while working in the UV editing layout we created in [Chapter 8](ch08.html
    "Chapter 8. UV Unwrapping"). The UV editing layout is useful because it allows
    us to access our baking controls through the Properties editor, the baked images
    through the UV Image editor, and the objects in our scene through the 3D Viewport,
    all in one layout.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![在我们创建的 UV 编辑布局中工作时的纹理烘焙控制。UV 编辑布局很有用，因为它让我们通过属性编辑器访问烘焙控制，通过 UV 图像编辑器访问烘焙图像，并通过
    3D 视口访问场景中的对象，所有这些都在一个布局中。](httpatomoreillycomsourcenostarchimages1538628.png.jpg)图
    10-1. 在我们创建的 [第 8 章](ch08.html "第 8 章. UV 展开")的 UV 编辑布局中工作时的纹理烘焙控制。UV 编辑布局很有用，因为它让我们通过属性编辑器访问烘焙控制，通过
    UV 图像编辑器访问烘焙图像，并通过 3D 视口访问场景中的对象，所有这些都在一个布局中。'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Baking is currently supported only when you use the Blender Internal renderer.
    If you don’t see any baking options, make sure that you have Blender Internal
    selected as your render engine from the Info Editor header (see [Figure 10-1](ch10.html#texture-baking_controls_while_working_in
    "Figure 10-1. Texture-baking controls while working in the UV editing layout we
    created in Chapter 8\. The UV editing layout is useful because it allows us to
    access our baking controls through the Properties editor, the baked images through
    the UV Image editor, and the objects in our scene through the 3D Viewport, all
    in one layout.")).*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*烘焙目前仅在使用 Blender Internal 渲染器时受支持。如果你没有看到任何烘焙选项，请确保在信息编辑器头部选择了 Blender Internal
    作为渲染引擎（参见[图 10-1](ch10.html#texture-baking_controls_while_working_in "图 10-1.
    在我们创建的 UV 编辑布局中工作时的纹理烘焙控制。UV 编辑布局很有用，因为它让我们通过属性编辑器访问烘焙控制，通过 UV 图像编辑器访问烘焙图像，并通过
    3D 视口访问场景中的对象，所有这些都在一个布局中。")）。*'
- en: Texture Map Types
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纹理映射类型
- en: 'You can bake several different map types, some of which are more important
    than others. Here’s what Blender has to offer:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以烘焙几种不同的地图类型，其中一些比其他的更重要。以下是 Blender 提供的选项：
- en: '****Full Render****. This does a full render, including textures and lighting
    of your surface. The resulting texture is exactly how your model will look in
    your final render, mapped to the object’s UV coordinates.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '****完整渲染****。这会进行完整的渲染，包括表面的纹理和光照。得到的纹理正是模型在最终渲染中呈现的效果，贴图到物体的UV坐标上。'
- en: '****Ambient Occlusion****. This renders ambient occlusion for the object, taking
    into account any other visible, renderable objects on the currently active layers.
    Ambient occlusion is a selfshadowing effect that creates dark areas in the corners
    and crevices of objects. It’s useful both for mimicking the effect of more complex
    lighting, as well as for creating a rough map of areas where dirt and dust are
    likely to accumulate. This kind of map is often very useful when creating textures
    and materials (see [Figure 10-2](ch10.html#ambient_occlusion_mapcomma_baked_and_app
    "Figure 10-2. An ambient occlusion map, baked and applied to the mesh as a texture
    (the eyes here have been left black)")).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '****环境光遮蔽****。这会为物体渲染环境光遮蔽，考虑到当前活动层中的任何其他可见且可渲染的物体。环境光遮蔽是一种自阴影效果，在物体的角落和缝隙处创建暗区。它既有助于模拟更复杂的光照效果，也有助于创建脏污和灰尘可能积聚的区域的粗略地图。这种贴图在创建纹理和材质时非常有用（参见[图
    10-2](ch10.html#ambient_occlusion_mapcomma_baked_and_app "图 10-2. 一个环境光遮蔽贴图，已经烘焙并作为纹理应用到网格上（这里的眼睛被留空为黑色）")）。'
- en: '****Shadow****. This renders the shadows from lights in the scene into a map.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '****阴影****。这会将场景中的光源阴影渲染到一个贴图中。'
- en: '****Normals****. This takes the normal vector of the object’s surface at each
    point and records it as an RGB value. This is done in a variety of ways, depending
    on the normal space option you choose. Different normal spaces record the normals
    of the mesh relative to different coordinate systems. For example, the *Camera*
    option records them relative to the camera; *World*, according to world space;
    *Object*, according to the object’s local coordinates; and *Tangent*, according
    to the surface normal of the baked object itself.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '****法线****。这会获取物体表面每个点的法线向量，并将其记录为RGB值。这可以通过多种方式进行，具体取决于你选择的法线空间选项。不同的法线空间记录网格的法线相对于不同的坐标系统。例如，*相机*选项相对于相机记录法线；*世界*，根据世界空间记录；*物体*，根据物体的局部坐标记录；而*Tangent*，则根据被烘焙物体本身的表面法线记录。'
- en: '![An ambient occlusion map, baked and applied to the mesh as a texture (the
    eyes here have been left black)](httpatomoreillycomsourcenostarchimages1538630.png.jpg)Figure 10-2. An
    ambient occlusion map, baked and applied to the mesh as a texture (the eyes here
    have been left black)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![一个环境光遮蔽贴图，已经烘焙并作为纹理应用到网格上（这里的眼睛被留空为黑色）](httpatomoreillycomsourcenostarchimages1538630.png.jpg)图
    10-2。一个环境光遮蔽贴图，已经烘焙并作为纹理应用到网格上（这里的眼睛被留空为黑色）'
- en: Of these, Tangent is probably the most important; it lets you bake the normals
    of one mesh to the surface of another by enabling the Selected to Active setting,
    selecting your source mesh (or meshes) and the target, and then baking. This renders
    the normals of the source mesh relative to the selected target mesh. This map
    can then be used to distort the surface normals of the mesh when it is rendered,
    giving the impression (when the map is applied as part of the object’s material)
    of having a lot of detail in the surface when in fact the underlying geometry
    can be much simpler. (See [Figure 10-3](ch10.html#normal_mapping_vsdot_displacement_mappin
    "Figure 10-3. Normal mapping vs. displacement mapping") for an example of this
    effect.) Tangent space normal maps are particularly useful because the normals
    are recorded relative to the surface of the mesh itself, so they work even when
    the mesh is distorted from its original shape by modifiers or further editing,
    so long as the UV coordinates remain the same.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些选项中，Tangent可能是最重要的；它通过启用“从选中到活动”设置、选择源网格（或多个网格）和目标网格，然后进行烘焙，允许你将一个网格的法线烘焙到另一个网格的表面。这会根据选定的目标网格渲染源网格的法线。然后可以使用这个贴图来扭曲网格表面的法线，给人一种表面细节丰富的印象（当该贴图作为物体材质的一部分应用时），尽管底层几何形状可能要简单得多。（参见[图
    10-3](ch10.html#normal_mapping_vsdot_displacement_mappin "图 10-3. 法线贴图与位移贴图")了解这种效果的示例。）Tangent空间法线贴图尤其有用，因为法线是相对于网格表面记录的，因此即使网格经过修改器或进一步编辑而发生形变，只要UV坐标保持不变，它们仍然有效。
- en: '****Textures****. This bakes the diffuse color of any materials and colors
    applied to the mesh. This can be useful for baking procedural colors and textures
    into a UV map.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '****纹理****。这会烘焙应用到网格上的任何材质和颜色的漫反射颜色。这对于将程序生成的颜色和纹理烘焙到UV贴图中非常有用。'
- en: '****Displacement****. This converts the distance between two meshes into a
    black-and-white image. Black represents negative displacement, mid-gray represents
    zero displacement, and white represents positive displacement. Use the Selected
    to Active option to bake from a source mesh (or meshes) to the active mesh.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '****位移****。这个功能将两个网格之间的距离转换为黑白图像。黑色表示负位移，中灰表示零位移，白色表示正位移。使用“选择到活动”选项，可以从源网格（或多个网格）烘焙到活动网格。'
- en: The Displacement map is generally used as an alternative to normal maps, and
    this map can then be used as the input for the Displace modifier or the Displace
    setting of a material to deform a mesh into the shape of the source mesh (see
    [Figure 10-3](ch10.html#normal_mapping_vsdot_displacement_mappin "Figure 10-3. Normal
    mapping vs. displacement mapping")). Alternatively, a baked displacement map can
    be used as a *bump map* for a material. (Bump maps work like normal maps, giving
    the impression of surface detail by altering the shading of the surface, but they
    require only black and white input.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 位移贴图通常作为法线贴图的替代方法，之后可以将该贴图用作位移修改器的输入或材质的位移设置，以将网格变形为源网格的形状（见[图 10-3](ch10.html#normal_mapping_vsdot_displacement_mappin
    "图 10-3. 法线贴图与位移贴图")）。另外，烘焙的位移贴图可以用作材质的*凹凸贴图*。（凹凸贴图像法线贴图一样，通过改变表面的阴影来产生表面细节的印象，但它们仅需要黑白输入。）
- en: Normal maps are a very efficient way to give the impression of detail, but they
    don’t affect the silhouette of the mesh or the casting of shadows because no *real*
    geometry is displaced. Displacement mapping creates real detail by deforming the
    mesh but requires you to subdivide the mesh to provide sufficient geometry to
    deform. In [Figure 10-3](ch10.html#normal_mapping_vsdot_displacement_mappin "Figure 10-3. Normal
    mapping vs. displacement mapping"), a group of spheres has been baked to a normal
    map (8 bit) and a displacement map (32 bit). These maps have then been applied
    to a plane and a cylinder. The normalmapped objects capture a lot of the shading
    with much lower polycounts, but they don’t affect the actual shape of the mesh
    or cast shadows. The displacement-mapped objects are much more realistic, but
    they have to be subdivided in order to capture all the details.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 法线贴图是一种非常高效的方式来给网格带来细节的印象，但它们不会影响网格的轮廓或阴影的投射，因为没有*真实*的几何体被位移。位移贴图通过变形网格来创建真实的细节，但它要求你细分网格，以提供足够的几何体来进行变形。在[图
    10-3](ch10.html#normal_mapping_vsdot_displacement_mappin "图 10-3. 法线贴图与位移贴图")中，一组球体已经烘焙成法线贴图（8位）和位移贴图（32位）。这些贴图随后应用于一个平面和一个圆柱体。法线贴图的对象通过较低的多边形数捕捉了大量的阴影，但它们不会影响网格的实际形状或投射阴影。位移贴图的对象更加真实，但它们必须进行细分，以捕捉所有细节。
- en: '![Normal mapping vs. displacement mapping](httpatomoreillycomsourcenostarchimages1538632.png.jpg)Figure 10-3. Normal
    mapping vs. displacement mapping'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![法线贴图与位移贴图](httpatomoreillycomsourcenostarchimages1538632.png.jpg)图 10-3.
    法线贴图与位移贴图'
- en: '****Alpha****. This bakes the alpha transparency of the mesh to a texture.
    It’s useful for baking procedural values to an image texture.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '****透明度****。这个功能将网格的透明度（Alpha通道）烘焙到纹理中。对将过程生成的值烘焙到图像纹理中非常有用。'
- en: '****Emission****. This bakes the emission color and amount of a material into
    a texture. As with the texture map, this can be useful in baking procedural emission
    colors into an image texture.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '****发射****。这个功能将材质的发射颜色和强度烘焙到纹理中。与纹理图一样，这在将过程生成的发射颜色烘焙到图像纹理中时非常有用。'
- en: '****Mirror Colors****. This bakes the color of ray-traced reflections for a
    material into a texture. It’s useful for baking procedural values to an image
    texture.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '****镜面反射颜色****。这个功能将光线追踪反射的颜色烘焙到材质的纹理中。它对于将过程生成的值烘焙到图像纹理中非常有用。'
- en: '****Mirror Intensity****. This bakes the amount of ray-traced reflection for
    a material into a texture and is useful for baking procedural values to an image
    texture.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '****镜面反射强度****。这个功能将材质的光线追踪反射强度烘焙到纹理中，对将过程生成的值烘焙到图像纹理中非常有用。'
- en: '****Specular Colors****. This bakes the color of specular reflections of a
    material into a texture and is useful for baking procedural values to an image
    texture.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '****镜面反射颜色****。这个功能将材质的镜面反射颜色烘焙到纹理中，并且对将过程生成的值烘焙到图像纹理中非常有用。'
- en: '****Specular Intensity****. This bakes the amount of specular reflection of
    a material into a texture. It’s useful for baking procedural values to an image
    texture.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '****镜面反射强度****。这个功能将材质的镜面反射强度烘焙到纹理中。对将过程生成的值烘焙到图像纹理中非常有用。'
- en: Each kind of texture map has a purpose from time to time, but in this chapter,
    we’ll focus on ambient occlusion, texture, normal, and displacement maps most
    often. Of the texture maps, these maps are the most useful for use with painted
    textures and for rendering detailed final models.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每种纹理贴图偶尔都会有其特定用途，但在本章中，我们将重点讨论环境光遮蔽、纹理、法线和位移贴图。对于纹理贴图来说，这些贴图最常用于与绘制的纹理配合使用，以及渲染详细的最终模型。
- en: Baking Textures for the Bat Creature
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为蝙蝠生物烘焙纹理
- en: In the case of the Bat Creature, my aim was to create textures for the skin
    and to bake a displacement map for rendering the final model with a Displace modifier
    in order to capture all the details I sculpted earlier. In this section I’ll discuss
    how I baked maps for ambient occlusion and displacement to help with this. I’ll
    also cover baking a normal map as an alternative to displacement maps, one that
    renders a lot more quickly though at the cost of some accuracy in representing
    the fine details.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于蝙蝠生物，我的目标是为皮肤创建纹理，并烘焙一个位移贴图，用于通过位移修改器渲染最终模型，以捕捉我之前雕刻的所有细节。在这一部分，我将讨论如何烘焙环境光遮蔽（ambient
    occlusion）和位移贴图来帮助完成这一任务。我还会介绍烘焙法线贴图作为位移贴图的替代方案，虽然法线贴图渲染速度更快，但在细节表现上会牺牲一些准确性。
- en: Baking Displacement from Sculpt to Final Mesh
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从雕刻到最终网格的位移烘焙
- en: Because I continued sculpting on the retopologized mesh, I could just render
    the final mesh directly. But this isn’t always desirable, because the Multires
    modifier can sometimes get corrupted and displaying its effects in the 3D Viewport
    can be slow and unwieldy. A better solution would be to bake a displacement map
    using either the high-poly sculpt, which can then be applied as part of a material,
    or the Subdivision Surface and Displace modifiers to reconstitute the high-poly
    details of the mesh only when it is rendered, leaving it simple and quick to work
    on in the 3D Viewport.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我在重新拓扑后的网格上继续雕刻，所以我可以直接渲染最终的网格。但这并不总是理想的，因为多重细分（Multires）修改器有时会损坏，而且在3D视口中显示其效果可能会变得缓慢且难以操作。一个更好的解决方案是，使用高多边形雕刻烘焙位移贴图，然后可以将其作为材质的一部分应用，或者使用细分曲面（Subdivision
    Surface）和位移（Displace）修改器，只有在渲染时才恢复网格的高多边形细节，从而使其在3D视口中保持简单且易于操作。
- en: To bake the displacement for the Bat Creature, I first selected the body of
    the creature (the high-poly sculpt), duplicated it, and then applied the Multires
    modifier at level 3\. This is the mesh I’ll use as the final body mesh for rendering.
    (I’ll add the hair that I created in [Chapter 9](ch09.html "Chapter 9. Hair and
    Particle Systems") to the final scene as a separate object.) This captures most
    of the detail already, but I’ll use a displacement map to capture the highest
    resolution detail.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为蝙蝠生物烘焙位移，我首先选择了生物的身体（高多边形雕刻），将其复制，然后在级别3应用多重细分修改器。这就是我将用作最终身体网格进行渲染的网格。（我将在[第9章](ch09.html
    "第9章：毛发和粒子系统")中创建的毛发作为单独的物体添加到最终场景中。）这已经捕捉到了大部分细节，但我将使用位移贴图来捕捉最高分辨率的细节。
- en: Next I needed to add a Subdivision Surface modifier to match the level of subdivision
    between the top level of the multires mesh and the new, soon-to-be displaced mesh.
    I added the modifier and set the number of subdivisions to 2.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我需要添加一个细分曲面修改器，以匹配多重细分网格的最高级别与即将被位移的网格之间的细分级别。我添加了该修改器，并将细分数设置为2。
- en: Then, in Edit mode, I selected the whole mesh, and in the UV Image editor, I
    added a new image for the displacement map to be baked to. This image needed to
    be a 32-bit float image in order to capture all of the details of the displacement
    without creating artifacts. I set its size to 4096×4096 pixels, more than enough
    to capture all the details of the sculpt. I selected the original multires mesh
    and my new final mesh. As shown in [Figure 10-4](ch10.html#settings_for_baking_the_displacement_map
    "Figure 10-4. Settings for baking the displacement map for the Bat Creature"),
    I made sure that Selected to Active was enabled and Normalize was unchecked, and
    I set the Margin setting to 4 to give a 4-pixel border around the UV islands,
    reducing the chance of artifacts around UV seams. (The other settings were left
    at their defaults.)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在编辑模式下，我选择了整个网格，并在UV图像编辑器中添加了一个新的图像，以便将位移贴图烘焙到这个图像中。这个图像需要是32位浮动图像，以便捕捉位移的所有细节，而不会产生伪影。我将其大小设置为4096×4096像素，足以捕捉雕刻的所有细节。我选择了原始的多分辨率网格和我的新最终网格。如[图
    10-4](ch10.html#settings_for_baking_the_displacement_map "图 10-4. 烘焙Bat Creature位移贴图的设置")所示，我确保启用了“从选中到激活”（Selected
    to Active）选项，且取消勾选了“归一化”（Normalize），同时将边距（Margin）设置为4，以在UV岛屿周围留出4像素的边框，从而减少UV接缝周围出现伪影的机会。（其他设置保持默认）
- en: At this point I was ready to bake my texture, so I clicked Bake in the Bake
    panel and set Blender to work baking my texture. This baked the displacement between
    my high-poly sculpt and my subdivided final mesh into a displacement map holding
    all of the detail of the high-poly sculpt. Once finished, I saved this as a 32-bit
    OpenEXR image to preserve all the information present in the displacement map
    by pressing F3 while in the UV Image editor and setting the format (in the bottom
    left of the file browser editor) to EXR (see [Figure 10-5](ch10.html#saving_the_displacement_map_as_a_32-bit
    "Figure 10-5. Saving the displacement map as a 32-bit OpenEXR image")). You can
    choose Float (Full) to use 32-bit values. Setting the Codec to ZIP will keep the
    file size a bit smaller.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我准备好烘焙我的纹理了，所以我点击了烘焙面板中的“烘焙”按钮，开始让Blender工作，烘焙我的纹理。这一步将我高多边形雕刻和细分后的最终网格之间的位移信息烘焙到了一个位移贴图中，保存了高多边形雕刻的所有细节。烘焙完成后，我按F3在UV图像编辑器中保存了这个32位OpenEXR图像，以便保留位移贴图中的所有信息，并在文件浏览器编辑器的左下角将格式设置为EXR（见[图
    10-5](ch10.html#saving_the_displacement_map_as_a_32-bit "图 10-5. 保存为32位OpenEXR图像的位移贴图")）。你可以选择使用Float（Full）来使用32位值。将编解码器（Codec）设置为ZIP将使文件大小稍微变小。
- en: Bit Depth and Textures
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位深度与纹理
- en: I’ve touched on bit depth briefly, but now I’ll explain it a bit further. *Bit
    depth* refers to the number of bits (that is, the length of a number in binary)
    that is used to store the red, green, blue, and alpha (RGBA) values for each pixel
    in an image. The more bits used to store each number, the more distinct levels
    there are, and the greater the range and subtlety of colors and brightnesses that
    can be stored in an image.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前简要提到过位深度，现在我将进一步解释。*位深度*指的是用于存储图像中每个像素的红、绿、蓝和透明度（RGBA）值的位数（即二进制数的长度）。用于存储每个数字的位数越多，表示的等级就越多，图像中可以存储的颜色和亮度的范围和细微程度也就越大。
- en: Most image formats (such as *.jpg* and *.png*) use 8-bit color, which is fine
    for simply displaying pictures on screen or even for storing simple diffuse textures.
    But if you plan on performing more complex manipulations on your images, such
    as using them for displacement maps or altering their colors and exposure, you’ll
    start to see artifacts appear.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数图像格式（如*.jpg*和*.png*）使用8位颜色，这对于简单的屏幕显示图片或者存储简单的漫反射纹理来说是足够的。但如果你打算对图像进行更复杂的处理，比如用它们做位移贴图或修改颜色和曝光度，就会开始看到伪影的出现。
- en: For such demanding use cases, you can use higher bit depths (either 16 or 32
    bit) for images, which give you a greater range of values to work with. Using
    higher bit depths will prevent ugly artifacts from appearing in your renders and
    displaced meshes. The OpenEXR (*.exr*) format is a good choice for saving high-bit-depth
    images. For low-bit-depth images, I generally use the Targa (*.tga*) format.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样要求较高的使用场景，你可以使用更高位深度的图像（16位或32位），这会提供更大的值范围供你使用。使用更高位深度可以防止渲染图像和位移网格中出现难看的伪影。OpenEXR（*.exr*）格式是保存高位深度图像的好选择。对于低位深度图像，我通常使用Targa（*.tga*）格式。
- en: '![Settings for baking the displacement map for the Bat Creature](httpatomoreillycomsourcenostarchimages1538634.png.jpg)Figure 10-4. Settings
    for baking the displacement map for the Bat Creature![Saving the displacement
    map as a 32-bit OpenEXR image](httpatomoreillycomsourcenostarchimages1538636.png.jpg)Figure 10-5. Saving
    the displacement map as a 32-bit OpenEXR image'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![蝙蝠生物的位移贴图烘焙设置](httpatomoreillycomsourcenostarchimages1538634.png.jpg)图10-4.
    蝙蝠生物的位移贴图烘焙设置![将位移贴图保存为32位OpenEXR图像](httpatomoreillycomsourcenostarchimages1538636.png.jpg)图10-5.
    将位移贴图保存为32位OpenEXR图像'
- en: 'During the baking of texture maps, most types of textures can be saved in 8-bit
    formats. That said, displacement maps should almost always be saved as 32-bit
    images to avoid stepping artifacts when applying them to your models. Stepping
    artifacts can be seen in [Figure 10-6](ch10.html#displacement_maps_usually_need_to_be_sav
    "Figure 10-6. Displacement maps usually need to be saved in a high-bit-depth image
    format because lower bit depths don’t store enough information and can result
    in stepping artifacts. (Here the effect has been exaggerated significantly.) Left:
    A cloud texture, the original source of our displacement map. Center: Using an
    8-bit displacement map, showing stepping. Right: Using a 32-bit displacement map,
    no stepping."); the input for a Displacement modifier has been baked in Blender
    and saved as both an 8-bit *.tga* file (applied using a displacement modifier,
    center) and a 32-bit OpenEXR image (right). The center image shows the artifacts
    that can result from using a displacement texture with insufficient bit depth.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在贴图烘焙过程中，大多数类型的纹理可以保存为8位格式。不过，位移贴图几乎总是需要保存为32位图像，以避免在将其应用到模型时出现阶梯伪影。阶梯伪影可以在[图10-6](ch10.html#displacement_maps_usually_need_to_be_sav
    "图10-6. 位移贴图通常需要保存为高位深图像格式，因为较低位深度无法存储足够的信息，可能导致阶梯伪影。（此处效果已被显著放大。）左：云纹理，作为位移贴图的原始来源。中：使用8位位移贴图，出现阶梯效果。右：使用32位位移贴图，无阶梯效果。")中看到；位移修饰符的输入已经在Blender中烘焙，并保存为8位*.tga*文件（通过位移修饰符应用，中间）和32位OpenEXR图像（右侧）。中间的图像显示了使用位移纹理时，由于位深度不足而导致的伪影。
- en: '![Displacement maps usually need to be saved in a high-bit-depth image format
    because lower bit depths don’t store enough information and can result in stepping
    artifacts. (Here the effect has been exaggerated significantly.) Left: A cloud
    texture, the original source of our displacement map. Center: Using an 8-bit displacement
    map, showing stepping. Right: Using a 32-bit displacement map, no stepping.](httpatomoreillycomsourcenostarchimages1538638.png.jpg)Figure 10-6. Displacement
    maps usually need to be saved in a high-bit-depth image format because lower bit
    depths don’t store enough information and can result in stepping artifacts. (Here
    the effect has been exaggerated significantly.) Left: A cloud texture, the original
    source of our displacement map. Center: Using an 8-bit displacement map, showing
    stepping. Right: Using a 32-bit displacement map, no stepping.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![位移贴图通常需要保存为高位深图像格式，因为较低位深度无法存储足够的信息，可能导致阶梯伪影。（此处效果已被显著放大。）左：云纹理，作为位移贴图的原始来源。中：使用8位位移贴图，出现阶梯效果。右：使用32位位移贴图，无阶梯效果。](httpatomoreillycomsourcenostarchimages1538638.png.jpg)图10-6.
    位移贴图通常需要保存为高位深图像格式，因为较低位深度无法存储足够的信息，可能导致阶梯伪影。（此处效果已被显著放大。）左：云纹理，作为位移贴图的原始来源。中：使用8位位移贴图，出现阶梯效果。右：使用32位位移贴图，无阶梯效果。'
- en: Applying the Displacement Map
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用位移贴图
- en: To make sure that the displacement map worked correctly (and to apply it to
    our model for use in our final renders), we can apply it to our duplicated model
    using the Displacement modifier. Having added a Subdivision Surface modifier to
    the duplicated body object, we have the geometry we need, so we can simply add
    a Displacement modifier to the object as well.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保位移贴图正确应用（并将其应用到我们的模型中以供最终渲染使用），我们可以通过位移修饰符将其应用到我们复制的模型上。添加了细分曲面修饰符到复制的物体后，我们已经拥有了所需的几何体，因此可以简单地将位移修饰符添加到物体上。
- en: To assign the displacement map, we use the *image* we baked as input for a *texture*;
    this texture can then be assigned as the input for the displacement modifier.
    (Here, I’m using the more rigorous definitions that I discussed at the beginning
    of this chapter.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定位移贴图，我们使用我们烘焙的*图像*作为*纹理*的输入；然后可以将该纹理指定为位移修饰符的输入。（在这里，我使用的是本章开头讨论的更严格的定义。）
- en: The easiest way to create and modify a texture block is to add a material to
    the model, if you haven’t already (we created a MatCap material in [Chapter 6](ch06.html
    "Chapter 6. Sculpting") that we no longer require; we can either use this or create
    a new one), and then add a new texture to this material using the Textures tab
    of the Properties editor by clicking the **+New** button with an empty texture
    slot selected. Give the texture a useful name like *Body_Displacement*, then set
    the type of this texture to **Image** or **Movie**. In the Image panel that appears,
    open your displacement map.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和修改纹理块的最简单方法是为模型添加一个材质（如果你还没有的话）（我们在[第6章](ch06.html "第6章. 雕刻")中创建了一个MatCap材质，现在不再需要它；我们可以使用这个材质或创建一个新的材质），然后通过属性编辑器的纹理标签页，点击选择空的纹理槽，点击**+新建**按钮，为这个材质添加一个新的纹理。在弹出的图像面板中，打开你的位移贴图，并给纹理取一个有用的名字，例如*Body_Displacement*，然后将这个纹理的类型设置为**图像**或**视频**。
- en: Now return to the Modifiers tab and, in the Displacement modifier, use the texture
    dropdown menu to select the texture you just created. Leave Direction set to **Normal**
    and set Texture Coordinates to **UV**. A strength of **1.0** should give the correct
    amount of displacement. Adjusting the View Subdivision Levels setting on the Subdivision
    Surface modifier will let you see more or less of the detail generated by the
    displacement map.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在返回到修改器标签页，在位移修改器中，使用纹理下拉菜单选择你刚刚创建的纹理。将方向设置为**法线**，并将纹理坐标设置为**UV**。设置强度为**1.0**应该能给出正确的位移量。调整细分曲面修改器中的视图细分级别设置，将让你看到更多或更少由位移贴图生成的细节。
- en: Baking Normal Maps
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 烘焙法线贴图
- en: While we won’t use one for our final renders, normal maps are a useful and quick-to-render
    alternative to displacement maps. They are frequently used in game engines because
    they are fast enough to use in real-time applications. They can also be used with
    the Blender Internal renderer to give the impression of extra detail without requiring
    such dense geometry.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们最终渲染时不会使用法线贴图，但法线贴图是一个有用的、渲染速度快的替代位移贴图的方法。它们在游戏引擎中经常使用，因为它们足够快，可以在实时应用程序中使用。它们也可以与Blender
    Internal渲染器一起使用，给人一种额外细节的感觉，而不需要如此密集的几何体。
- en: The process of baking a normal map is very similar to baking a displacement
    map. First, you assign a new blank image to your duplicated mesh (it doesn’t need
    to be 32 bit). Then, select the sculpt first and then the duplicate. We don’t
    need to apply a Subdivision Surface modifier to the duplicate this time because
    the silhouette of our character is broadly fine and normal mapping doesn’t require
    extra geometry (it doesn’t physically displace the mesh). Next, from the Render
    tab of the Properties editor, set the Bake mode to **Normals** and Normal Space
    to **Tangent**, enable **Selected to Active**, and click **Bake** (see [Figure 10-7](ch10.html#baking_a_normal_mapdot_normal_space_is_s
    "Figure 10-7. Baking a normal map. Normal Space is set to Tangent, and the normals
    are baked from the sculpted mesh to our final model—this time without subdivision.
    Some artifacts are present in the bake, but these can be corrected later in GIMP
    (see Chapter 11).")).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 烘焙法线贴图的过程与烘焙位移贴图非常相似。首先，为你的复制网格分配一个新的空白图像（它不需要是32位）。然后，先选择雕刻，再选择复制网格。这次我们不需要给复制网格应用细分曲面修改器，因为我们角色的轮廓大致合适，法线贴图不需要额外的几何体（它不会物理性地位移网格）。接下来，在属性编辑器的渲染标签页中，将烘焙模式设置为**法线**，法线空间设置为**切线**，启用**选择到活动**，然后点击**烘焙**（见[图10-7](ch10.html#baking_a_normal_mapdot_normal_space_is_s
    "图10-7. 烘焙法线贴图。法线空间设置为切线，法线从雕刻网格烘焙到最终模型——这次没有细分。烘焙中有一些伪影，但可以稍后在GIMP中修正（见第11章）。")）。
- en: The resulting map will be a bluish texture, with other colors denoting areas
    of the sculpt that face in different directions relative to the normals of the
    unsubdivided duplicate mesh. This texture may later be applied as part of the
    object’s material to give the effect of mimicking the surface forms of the sculpted
    mesh (see [Figure 10-8](ch10.html#normal_map_applied_as_part_of_the_materi "Figure 10-8. The
    normal map applied as part of the material, previewed in the 3D Viewport using
    GLSL shading. The artifacts from the bake can be seen on the wing as black areas,
    but this can be fixed later in GIMP simply by painting over them.")). See [Adding
    a Normal Map](ch12.html#adding_a_normal_map "Adding a Normal Map") to learn how
    to apply normal maps as part of a material.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最终得到的贴图将是一种带有蓝色调的纹理，其他颜色表示雕塑的不同方向面相对于未细分副本网格法线的朝向。此纹理可以稍后作为物体材质的一部分应用，以模拟雕塑网格的表面形态效果（见[图10-8](ch10.html#normal_map_applied_as_part_of_the_materi
    "图10-8. 作为材质一部分应用的法线贴图，使用GLSL着色器在3D视口中预览。烘焙过程中的伪影可以在翅膀上看到，黑色区域可以通过在GIMP中涂抹来修复。")）。请参阅[添加法线贴图](ch12.html#adding_a_normal_map
    "添加法线贴图")，学习如何将法线贴图作为材质的一部分应用。
- en: Baking Ambient Occlusion
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 烘焙环境光遮蔽
- en: 'In addition to the displacement map, we also want to bake our ambient occlusion
    map from our high-poly sculpt onto the final mesh. This process is simpler than
    producing the displacement map:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了位移贴图，我们还希望将高多边形雕塑的环境光遮蔽贴图烘焙到最终网格上。这个过程比制作位移贴图要简单：
- en: Select the sculpt and then the final mesh. Set the Bake mode to **Ambient Occlusion**.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择雕塑对象，然后选择最终网格。将烘焙模式设置为**环境光遮蔽**。
- en: Select **Normalize** to ensure that the ambient occlusion map uses the whole
    range between black and white to store the occlusion.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**归一化**，以确保环境光遮蔽贴图使用黑白之间的整个范围来存储遮蔽效果。
- en: To get the best-quality ambient occlusion map, adjust Blender’s world lighting
    settings in the World tab of the Properties editor, which contains all the settings
    for ambient occlusion and environment lighting (see [Figure 10-9](ch10.html#ambient_occlusion_settings_for_baking_am
    "Figure 10-9. Ambient occlusion settings for baking ambient occlusion maps.")).
    (See [Chapter 13](ch13.html "Chapter 13. Lighting") for more on these settings.)
    Enable **Ambient Occlusion** (set to **Multiply**) from the Ambient Occlusion
    panel.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获得最佳质量的环境光遮蔽贴图，调整Blender的世界光照设置，位于属性编辑器的世界选项卡中，里面包含了所有关于环境光遮蔽和环境光照的设置（见[图10-9](ch10.html#ambient_occlusion_settings_for_baking_am
    "图10-9. 环境光遮蔽设置用于烘焙环境光遮蔽贴图。")）。(更多设置细节请参见[第13章](ch13.html "第13章. 光照")。) 在环境光遮蔽面板中启用**环境光遮蔽**（设置为**乘法**）。
- en: In the Gather panel, turn the Attenuation Distance down to **0.2** and enable
    **Falloff** and set it to **1.0**. This causes only close-together geometry to
    cause shadowing and speeds up rendering.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在聚集面板中，将衰减距离调低至**0.2**，并启用**衰减**，设置为**1.0**。这将导致只有接近的几何体才会产生阴影，并加速渲染。
- en: Set the samples to **24** to reduce the noise in the results.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将样本数设置为**24**，以减少结果中的噪声。
- en: Having saved a displacement map externally, you can simply bake over the displacement
    map image, remembering to save it as something different once the ambient occlusion
    map is baked. Click **Bake** and let the ambient occlusion map render (see [Figure 10-10](ch10.html#baked_ambient_occlusion_mapdot_this_cont
    "Figure 10-10. The baked ambient occlusion map. This contains some artifacts from
    baking that we’ll remove later by hand.")).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部保存了位移贴图后，你可以直接在位移贴图图像上进行烘焙，记得在烘焙完环境光遮蔽贴图后将其另存为不同的文件。点击**烘焙**并等待环境光遮蔽贴图渲染完成（见[图10-10](ch10.html#baked_ambient_occlusion_mapdot_this_cont
    "图10-10. 烘焙后的环境光遮蔽贴图。图中包含了一些烘焙过程中的伪影，稍后我们将手动去除它们。")）。
- en: '![Baking a normal map. Normal Space is set to Tangent, and the normals are
    baked from the sculpted mesh to our final model—this time without subdivision.
    Some artifacts are present in the bake, but these can be corrected later in GIMP
    (see ).](httpatomoreillycomsourcenostarchimages1538640.png.jpg)Figure 10-7. Baking
    a normal map. Normal Space is set to Tangent, and the normals are baked from the
    sculpted mesh to our final model—this time without subdivision. Some artifacts
    are present in the bake, but these can be corrected later in GIMP (see [Chapter 11](ch11.html
    "Chapter 11. Texture Painting")).![The normal map applied as part of the material,
    previewed in the 3D Viewport using GLSL shading. The artifacts from the bake can
    be seen on the wing as black areas, but this can be fixed later in GIMP simply
    by painting over them.](httpatomoreillycomsourcenostarchimages1538642.png.jpg)Figure 10-8. The
    normal map applied as part of the material, previewed in the 3D Viewport using
    GLSL shading. The artifacts from the bake can be seen on the wing as black areas,
    but this can be fixed later in GIMP simply by painting over them.![Ambient occlusion
    settings for baking ambient occlusion maps.](httpatomoreillycomsourcenostarchimages1538644.png.jpg)Figure 10-9. Ambient
    occlusion settings for baking ambient occlusion maps.![The baked ambient occlusion
    map. This contains some artifacts from baking that we’ll remove later by hand.](httpatomoreillycomsourcenostarchimages1538646.png.jpg)Figure 10-10. The
    baked ambient occlusion map. This contains some artifacts from baking that we’ll
    remove later by hand.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![烘焙法线贴图。法线空间设置为切线，并将法线从雕刻网格烘焙到最终模型—这次没有细分。烘焙结果中有一些伪影，但可以在后续的GIMP中修正（见[第11章](ch11.html
    "第11章：纹理绘制")）。](httpatomoreillycomsourcenostarchimages1538640.png.jpg)图10-7. 烘焙法线贴图。法线空间设置为切线，并将法线从雕刻网格烘焙到最终模型—这次没有细分。烘焙结果中有一些伪影，但可以在后续的GIMP中修正（见[第11章](ch11.html
    "第11章：纹理绘制")）。![作为材质一部分应用的法线贴图，在3D视口中使用GLSL阴影预览。烘焙结果中的伪影可以在机翼上看到，表现为黑色区域，但这可以在后续的GIMP中通过涂抹去除。](httpatomoreillycomsourcenostarchimages1538642.png.jpg)图10-8.
    作为材质一部分应用的法线贴图，在3D视口中使用GLSL阴影预览。烘焙结果中的伪影可以在机翼上看到，表现为黑色区域，但这可以在后续的GIMP中通过涂抹去除。![烘焙环境光遮蔽贴图的设置。](httpatomoreillycomsourcenostarchimages1538644.png.jpg)图10-9.
    烘焙环境光遮蔽贴图的设置。![烘焙出的环境光遮蔽贴图。这个贴图包含一些烘焙伪影，稍后我们将手动去除。](httpatomoreillycomsourcenostarchimages1538646.png.jpg)图10-10.
    烘焙出的环境光遮蔽贴图。这个贴图包含一些烘焙伪影，稍后我们将手动去除。'
- en: To make sure that the ambient occlusion map came out okay, turn on **Textured
    Solid** in the Display panel of the Properties region in the 3D Viewport. This
    displays the texture assigned to the mesh on the model, allowing you to see the
    effect of the ambient occlusion map. When you’re happy with the bake, save it
    as a *.tga* image. (You don’t need to use a high-bit-depth format this time, as
    the ambient occlusion map will work fine with 8-bit color.) There may be one or
    two artifacts, but you can paint these out later in GIMP once you begin texturing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保环境光遮蔽贴图正确生成，请在3D视口的属性区域的显示面板中启用**Textured Solid**。这会显示模型网格上分配的纹理，帮助你查看环境光遮蔽贴图的效果。当你对烘焙结果满意时，将其保存为*.tga*图像。（这次不需要使用高位深度格式，因为环境光遮蔽贴图在8位颜色下也能正常工作。）可能会出现一两个伪影，但当你开始进行纹理绘制时，可以在GIMP中将其去除。
- en: Baking Textures for the Spider Bot
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蜘蛛机器人纹理烘焙
- en: For the Spider Bot project, I didn’t need to bake displacement or normal maps;
    the point of retopology in this case was to eliminate the roughness from the sculpts
    and end up with the smooth forms the retopologized model now has. The model would
    still benefit from an ambient occlusion map, though, which will be useful during
    the texturing process. To save time when painting colors for the textures, it
    will also help to assign some basic materials with different colors to the parts
    of the model and then bake these colors into an image to serve as a guide when
    painting textures.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于蜘蛛机器人项目，我不需要烘焙位移或法线贴图；这次进行重拓扑的目的在于消除雕刻网格的粗糙度，最终得到现在这个平滑的重拓扑模型。尽管如此，模型仍然需要一个环境光遮蔽贴图，这将在纹理绘制过程中发挥作用。为了节省为纹理绘制颜色的时间，还可以为模型的各个部分分配一些不同颜色的基础材质，然后将这些颜色烘焙成图像，作为绘制纹理时的指南。
- en: Baking Maps for Multiple Objects
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多物体烘焙贴图
- en: In [Chapter 8](ch08.html "Chapter 8. UV Unwrapping"), I packed the UV coordinates
    for most of the Spider Bot model onto a single UV grid so that I’d require fewer
    texture images later on. Next I needed to bake the maps for all of the objects
    together. To do this, first make sure they all have the same image assigned to
    their UV coordinates. If so, you could simply select all of the objects for the
    Spider Bot that share the same UV coordinates and click Bake to bake all of the
    selected objects at once.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 8 章](ch08.html "第 8 章 UV 展开")中，我将大部分 Spider Bot 模型的 UV 坐标打包到一个单一的 UV 网格上，这样我以后就需要更少的纹理图像。接下来，我需要将所有物体的地图一起烘焙。为此，首先确保它们的
    UV 坐标都分配了相同的图像。如果是这样，你只需选择所有具有相同 UV 坐标的 Spider Bot 物体，点击烘焙即可一次性烘焙所有选定物体。
- en: But what if you want to be selective about which parts of the model are visible
    when baking different objects? Or if you wish to be able to correct parts without
    rebaking the entire model? By default, Blender will clear the texture every time
    you click Bake, preventing you from baking multiple times with different objects
    selected. To prevent this, turn off the Clear setting in the Bake panel, and Blender
    will replace only the parts of the image assigned to the selected objects. This
    will allow you to bake objects one at a time, in groups, or all at once, adding
    to the texture map as we go along.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你希望在烘焙不同物体时选择性地控制模型的哪些部分可见呢？或者如果你希望能够修正某些部分而无需重新烘焙整个模型呢？默认情况下，每次点击烘焙时，Blender
    会清除纹理，这会阻止你在选择不同物体时多次烘焙。为避免这种情况，请在烘焙面板中关闭“清除”设置，Blender 将仅替换分配给选定物体的图像部分。这样，你就可以一次烘焙一个物体、分组烘焙，或者一次性烘焙所有物体，在过程中不断添加到纹理图上。
- en: This selective technique comes in handy for pieces like the legs. Because some
    of the leg components overlap slightly, if they were baked together, the overlapping
    areas would come out black when we bake our ambient occlusion map. And if we were
    to later re-pose the legs, these black regions might show through.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种选择性技术在处理像腿部这样的部件时非常有用。因为一些腿部组件略有重叠，如果它们一起烘焙，重叠区域会在烘焙环境光遮蔽图时变黑。如果后来我们重新摆姿势，这些黑色区域可能会显示出来。
- en: 'To avoid baking in shadows from overlapping objects that may not always be
    there, use Blender’s layers. Blender bakes objects only on the currently visible
    layers, so we can isolate the parts we want to include each time on a single layer
    and then bake them. To do so, take the following steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免烘焙重叠物体的阴影，这些物体可能并不总是在场，使用 Blender 的图层功能。Blender 只会在当前可见的图层上烘焙物体，因此我们可以每次将想要包含的部分单独放置在一个图层上，然后烘焙它们。操作步骤如下：
- en: Select the objects you wish to bake and press **M** to bring up a menu that
    allows you to pick which layers the object should be visible on.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要烘焙的物体，并按 **M** 打开一个菜单，允许你选择物体应在哪些图层上可见。
- en: Select a new empty layer (check the layers icons in the 3D Viewport header to
    see which ones are occupied) and press ENTER to put the object on that layer.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个新的空图层（检查 3D 视口头部的图层图标，查看哪些图层已被占用），然后按 ENTER 将物体放置到该图层。
- en: Jump to the selected layer in the 3D Viewport, either with the selector in the
    header or using the keyboard shortcuts (1 through 0 on the keyboard for layers
    1 to 10, ALT-1 through ALT-0 for layers 11 through 20).
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到 3D 视口中的选定层，可以通过头部的选择器或使用键盘快捷键（键盘上的 1 至 0 对应层 1 至 10，ALT-1 至 ALT-0 对应层 11
    至 20）。
- en: '![Baking the ambient occlusion map for the head and body segments of the Spider
    Bot. Only selected objects are baked, and only objects on layers that are currently
    visible are taken into account by the baking process.](httpatomoreillycomsourcenostarchimages1538648.png.jpg)Figure 10-11. Baking
    the ambient occlusion map for the head and body segments of the Spider Bot. Only
    selected objects are baked, and only objects on layers that are currently visible
    are taken into account by the baking process.'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![为 Spider Bot 的头部和身体部分烘焙环境光遮蔽图。只有选定的物体被烘焙，且仅当前可见图层上的物体会被烘焙过程考虑。](httpatomoreillycomsourcenostarchimages1538648.png.jpg)
    图 10-11. 为 Spider Bot 的头部和身体部分烘焙环境光遮蔽图。只有选定的物体被烘焙，且仅当前可见图层上的物体会被烘焙过程考虑。'
- en: Now select the mesh and bake the ambient occlusion map for that object alone,
    as shown in [Figure 10-11](ch10.html#baking_the_ambient_occlusion_map_for_the
    "Figure 10-11. Baking the ambient occlusion map for the head and body segments
    of the Spider Bot. Only selected objects are baked, and only objects on layers
    that are currently visible are taken into account by the baking process.").
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选择网格，并仅为该对象烘焙环境光遮蔽贴图，如[图 10-11](ch10.html#baking_the_ambient_occlusion_map_for_the
    "图 10-11. 为蜘蛛机器人头部和身体部分烘焙环境光遮蔽贴图。只有选中的对象会被烘焙，且烘焙过程中仅考虑当前可见图层上的对象。")所示。
- en: This selective process allows you to progress through each object in the model,
    baking the ambient occlusion as you see fit, whether for a single component or
    for small groups. For example, for the head section of the Spider Bot, I baked
    the antenna and extra parts of the head along with the head mesh and kept the
    wires at the back of the head/body segment on the same layer while baking (though
    I baked these separately). I baked the legs as individual pieces, isolating each
    type of leg part on its own layer before baking. The final bake after progressing
    over the whole model is shown in [Figure 10-12](ch10.html#final_baked_ambient_occlusion_texture_fo
    "Figure 10-12. The final baked ambient occlusion texture for the Spider Bot").
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选择性过程让你可以逐个对象地处理模型，按照需要烘焙环境光遮蔽贴图，不论是为单一组件还是小组分配。例如，对于蜘蛛机器人头部部分，我将天线和额外的头部部件与头部网格一起烘焙，并在烘焙过程中将头部/身体段后面的电线保持在同一图层上（尽管我单独烘焙了这些）。我将腿部作为单独的部分来烘焙，在烘焙之前将每种类型的腿部零件单独放置在不同的图层上。对整个模型进行处理后的最终烘焙结果显示在[图
    10-12](ch10.html#final_baked_ambient_occlusion_texture_fo "图 10-12. 蜘蛛机器人最终烘焙的环境光遮蔽贴图")中。
- en: For areas like the joints on the underside of the Spider Bot’s body, which share
    the same UV space, I couldn’t bake a proper UV map. Instead, I just filled that
    area with white in GIMP after I saved the image. (See the top right corner of
    the ambient occlusion map in [Figure 10-12](ch10.html#final_baked_ambient_occlusion_texture_fo
    "Figure 10-12. The final baked ambient occlusion texture for the Spider Bot").)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于蜘蛛机器人身体底部的关节区域，这些区域共享相同的UV空间，我无法烘焙出合适的UV贴图。相反，我在保存图像后，直接在GIMP中将该区域填充为白色。（请参见[图
    10-12](ch10.html#final_baked_ambient_occlusion_texture_fo "图 10-12. 蜘蛛机器人最终烘焙的环境光遮蔽贴图")的右上角的环境光遮蔽贴图。）
- en: '![The final baked ambient occlusion texture for the Spider Bot](httpatomoreillycomsourcenostarchimages1538650.png.jpg)Figure 10-12. The
    final baked ambient occlusion texture for the Spider Bot'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![蜘蛛机器人最终烘焙的环境光遮蔽贴图](httpatomoreillycomsourcenostarchimages1538650.png.jpg)图
    10-12. 蜘蛛机器人最终烘焙的环境光遮蔽贴图'
- en: Baking Diffuse Colors and Textures
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 烘焙漫反射颜色和纹理
- en: In order to get a rough feel for the colors I wanted the Spider Bot to have
    and to bake these into a map to serve as a guide for the texture painting process,
    I needed to create some basic materials and assign them to the different parts
    of my model. These materials didn’t need to be complex; in fact, I needed only
    to adjust the diffuse color setting. (I’ll discuss more complex materials in [Chapter 12](ch12.html
    "Chapter 12. Materials").)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了大致了解蜘蛛机器人所需的颜色，并将这些颜色烘焙成贴图，以作为纹理绘制过程的指南，我需要创建一些基础材质并将它们分配到模型的不同部件上。这些材质不需要复杂；实际上，我只需要调整漫反射颜色设置。（关于更复杂的材质内容，我将在[第12章](ch12.html
    "第12章. 材质")中进行讨论。）
- en: 'To create a few basic materials:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一些基础材质：
- en: Go to the **Materials** tab of the Properties editor (with an object selected)
    and click the **+New** button to create a new material.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到属性编辑器的**材质**标签（选中一个对象），点击**+新建**按钮以创建一个新材质。
- en: Click the name *Material* to rename it something more useful, like *Basic_Fill_01*,
    and then set the diffuse color to a mid-gray color.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击*Material*名称，将其重命名为更有用的名称，如*Basic_Fill_01*，然后将漫反射颜色设置为中灰色。
- en: Create more materials by duplicating this first one (click the + icon next to
    the material’s name) and set these to different colors.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制第一个材质来创建更多材质（点击材质名称旁的+图标），并将其设置为不同的颜色。
- en: 'When working with the new materials, I began by choosing three colors: one
    principal color for most of the model, a secondary color, and a highlight color
    for small details. I then started assigning these materials to the different objects
    that made up the Spider Bot using the Materials tab of the Properties editor,
    though it’s even easier to accomplish using an add-on called Material Utils.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用新材质时，我从选择三种颜色开始：一种主要颜色用于大部分模型，第二种颜色作为辅助色，第三种颜色用于小细节的高光。我然后开始使用属性编辑器的材质标签将这些材质分配给构成蜘蛛机器人不同部件的物体，虽然使用一个名为Material
    Utils的插件可以更轻松地完成这项任务。
- en: Material Utils Add-On
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Material Utils 插件
- en: The Material Utils add-on is a quick way to modify materials assigned to your
    models. It’s particularly useful for working with scenes that use a lot of materials
    or ones with multiple objects that share the same materials.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Material Utils 插件是一个快速修改分配给模型材质的工具。它特别适用于处理那些使用大量材质的场景，或者有多个共享相同材质的物体的场景。
- en: To enable the add-on, open Blender’s User Preferences Editor (you can bring
    this up by going to **File**▸**User Preferences)** and under Add-Ons, search for
    and enable **Material Utils**. This adds a new keyboard shortcut (**Q**), which
    brings up a menu that you can use in either Object or Edit mode to assign materials
    to meshes (see [Figure 10-13](ch10.html#assigning_materials_with_the_material_ut
    "Figure 10-13. Assigning materials with the Material Utils add-on (Q) greatly
    speeds up adding materials to your scene, particularly for scenes with a lot of
    objects.")). In Object mode, the add-on allows you to assign materials to an entire
    object (or to multiple objects if more than one is selected), while in Edit mode,
    it will assign a material only to the part of the mesh you have selected.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用该插件，打开Blender的用户偏好设置编辑器（可以通过点击**文件**▸**用户偏好设置**来打开），然后在插件列表下搜索并启用**Material
    Utils**。这会添加一个新的快捷键（**Q**），可以通过它在物体模式或编辑模式下打开一个菜单，用来为网格分配材质（见[图10-13](ch10.html#assigning_materials_with_the_material_ut
    "图10-13. 使用Material Utils插件（Q）为场景添加材质，特别是在有很多物体的场景中，显著加快材质添加速度。")）。在物体模式下，该插件允许你为整个物体（如果选中了多个物体，则为多个物体）分配材质，而在编辑模式下，它只会为你选择的网格部分分配材质。
- en: '![Assigning materials with the Material Utils add-on (Q) greatly speeds up
    adding materials to your scene, particularly for scenes with a lot of objects.](httpatomoreillycomsourcenostarchimages1538652.png.jpg)Figure 10-13. Assigning
    materials with the Material Utils add-on (Q) greatly speeds up adding materials
    to your scene, particularly for scenes with a lot of objects.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用Material Utils插件（Q）为场景添加材质，特别是在有很多物体的场景中，显著加快材质添加速度。](httpatomoreillycomsourcenostarchimages1538652.png.jpg)图10-13.
    使用Material Utils插件（Q）为场景添加材质，特别是在有很多物体的场景中，显著加快材质添加速度。'
- en: For the Spider Bot, I quickly applied the same material to every object in the
    model by selecting them all with **A** and then using Material Utils (**Q**) to
    assign one of my basic materials to all of them. Then, I began selecting individual
    pieces (and also dropping into Edit mode with TAB to select parts of meshes, as
    in [Figure 10-13](ch10.html#assigning_materials_with_the_material_ut "Figure 10-13. Assigning
    materials with the Material Utils add-on (Q) greatly speeds up adding materials
    to your scene, particularly for scenes with a lot of objects.")) and assigning
    other materials from the three I created. My overall goal was to keep one main
    color, one secondary color, and a highlight color for small or interesting parts
    of the model. For certain objects, like the wires and eyes, I created unique materials
    by first making the existing material datablock for that object unique (by clicking
    the number next to the materials name at the top of the Materials tab) and then
    adjusting it as necessary. After assigning materials, I began changing the diffuse
    colors of my materials in search of a combination that worked, as shown in [Figure 10-14](ch10.html#after_iterating_through_different_color
    "Figure 10-14. After iterating through different color ideas for the Spider Bot,
    I eventually settled on a white, gray, and green version.").
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于蜘蛛机器人，我通过按**A**选择所有物体，然后使用材质工具（**Q**）将我创建的基础材质应用到所有物体上，迅速给模型中的每个物体应用了相同的材质。然后，我开始选择个别部件（并通过TAB键进入编辑模式，选择网格的部分，就像在[图
    10-13](ch10.html#assigning_materials_with_the_material_ut "图 10-13. 使用材质工具插件（Q）显著加速了将材质添加到场景中的过程，尤其是对于物体较多的场景。")中一样）并从我创建的三个材质中为它们分配其他材质。我的整体目标是为模型保持一个主色、一个次色和一个突出的小部件的高亮色。对于某些物体，比如电线和眼睛，我通过首先使该物体的现有材质数据块唯一（点击材质名称旁边的数字）来创建独特的材质，然后根据需要调整它。分配完材质后，我开始调整材质的漫反射颜色，寻找一个合适的组合，如[图
    10-14](ch10.html#after_iterating_through_different_color "图 10-14. 在为蜘蛛机器人尝试了不同颜色搭配后，我最终选择了白色、灰色和绿色的版本。")所示。
- en: Baking a Texture Map
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 烘焙纹理贴图
- en: Having established my color scheme, I was able to bake the colors to a texture
    map. Using a texture to define the color of the objects, rather than different
    materials, allowed me to use fewer materials to render my model and simplified
    the process of tweaking materials later on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了我的配色方案之后，我能够将颜色烘焙到纹理贴图中。使用纹理来定义物体的颜色，而不是不同的材质，使我能够使用更少的材质来渲染模型，并简化了后续调整材质的过程。
- en: To bake the texture map, I returned to the Bake panel of the Render tab in the
    Properties editor, set the Bake mode to Texture, and then clicked Bake. This baked
    the colors of the various materials I assigned into a single texture (see [Figure 10-15](ch10.html#baking_simple_materials_into_a_texture_m
    "Figure 10-15. Baking simple materials into a texture map")). Because there is
    no interaction between the meshes to consider this time (as there was when rendering
    ambient occlusion), I can bake the meshes all at once by selecting them all before
    baking.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了烘焙纹理贴图，我回到属性编辑器中的渲染标签页的烘焙面板，将烘焙模式设置为纹理（Texture），然后点击烘焙（Bake）。这将我分配给不同材质的颜色烘焙成一个单一的纹理（参见[图
    10-15](ch10.html#baking_simple_materials_into_a_texture_m "图 10-15. 将简单材质烘焙到纹理贴图中")））。因为这次不需要考虑网格之间的相互作用（就像渲染环境光遮蔽时那样），我可以在烘焙之前选择所有网格，将它们一次性烘焙。
- en: It’s worth pointing out here that you can bake more complex material colors
    and textures as well. For example, you can bake image textures into the UV unwrapped
    texture for an object or bake procedural materials into images. [Figure 10-16](ch10.html#baking_a_zebra-striped_pattern_into_the
    "Figure 10-16. Baking a zebra-striped pattern into the texture for the Spider
    Bot using a procedural wood texture") shows the result of adding a procedural
    wood texture to one of the flat materials for the Spider Bot before baking, which
    gives it a zebra-striped pattern.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得指出的是，你也可以烘焙更复杂的材质颜色和纹理。例如，你可以将图像纹理烘焙到物体的UV展开纹理中，或者将程序生成的材质烘焙到图像中。[图 10-16](ch10.html#baking_a_zebra-striped_pattern_into_the
    "图 10-16. 将程序生成的木纹纹理烘焙到蜘蛛机器人纹理中的斑马条纹图案")显示了在烘焙之前，将程序生成的木纹纹理添加到蜘蛛机器人一个平面材质中的结果，从而给它添加了斑马条纹图案。
- en: Texturing the Jungle Temple
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给丛林神庙纹理化
- en: In the case of the Jungle Temple, most of my textures were tileable to some
    degree, or they were repeated on meshes in multiple locations. This meant that
    baking maps for things like ambient occlusion would be less effective because
    a map baked for a mesh in one location may not have quite the right effect when
    repeated in another. In the end, the only mesh I baked maps for was the statue
    (see [Figure 10-17](ch10.html#baking_the_ambient_occlusion_map-id00017 "Figure 10-17. Baking
    the ambient occlusion map for the statue in the Jungle Temple scene")), for which
    I created an ambient occlusion map for the object by itself. I did this by putting
    the statue on its own layer while baking, just as I did for the parts of the Spider
    Bot model above.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在丛林神庙的案例中，我的大多数贴图都有一定程度的可平铺性，或者它们在多个位置的网格上重复出现。这意味着像环境光遮蔽这样的贴图会效果较差，因为为一个位置的网格烘焙的贴图，在其他位置重复时可能效果不太合适。最终，我只为雕像网格烘焙了贴图（见[图
    10-17](ch10.html#baking_the_ambient_occlusion_map-id00017 "图 10-17。烘焙丛林神庙场景中雕像的环境光遮蔽贴图")），为该物体单独创建了一个环境光遮蔽贴图。我通过将雕像放在自己的图层上进行烘焙，就像我之前为蜘蛛机器人模型的部件所做的那样。
- en: '![After iterating through different color ideas for the Spider Bot, I eventually
    settled on a white, gray, and green version.](httpatomoreillycomsourcenostarchimages1538654.png.jpg)Figure 10-14. After
    iterating through different color ideas for the Spider Bot, I eventually settled
    on a white, gray, and green version.![Baking simple materials into a texture map](httpatomoreillycomsourcenostarchimages1538656.png.jpg)Figure 10-15. Baking
    simple materials into a texture map![Baking a zebra-striped pattern into the texture
    for the Spider Bot using a procedural wood texture](httpatomoreillycomsourcenostarchimages1538658.png.jpg)Figure 10-16. Baking
    a zebra-striped pattern into the texture for the Spider Bot using a procedural
    wood texture![Baking the ambient occlusion map for the statue in the Jungle Temple
    scene](httpatomoreillycomsourcenostarchimages1538660.png.jpg)Figure 10-17. Baking
    the ambient occlusion map for the statue in the Jungle Temple scene'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![在为蜘蛛机器人尝试不同颜色方案后，我最终决定使用白色、灰色和绿色的版本。](httpatomoreillycomsourcenostarchimages1538654.png.jpg)图
    10-14。 在为蜘蛛机器人尝试不同颜色方案后，我最终决定使用白色、灰色和绿色的版本。![将简单材质烘焙成贴图](httpatomoreillycomsourcenostarchimages1538656.png.jpg)图
    10-15。将简单材质烘焙成贴图![将斑马条纹图案烘焙进蜘蛛机器人的贴图中，使用了程序化木纹贴图](httpatomoreillycomsourcenostarchimages1538658.png.jpg)图
    10-16。将斑马条纹图案烘焙进蜘蛛机器人的贴图中，使用了程序化木纹贴图![烘焙丛林神庙场景中雕像的环境光遮蔽贴图](httpatomoreillycomsourcenostarchimages1538660.png.jpg)图
    10-17。烘焙丛林神庙场景中雕像的环境光遮蔽贴图'
- en: General Tips for Baking Maps
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 烘焙贴图的一般建议
- en: Baking larger textures will allow you to capture more detail but will also take
    more time. When deciding what size textures to bake, consider how much detail
    your model has and how much will be present in the bake beforehand in order to
    optimize the resolution of the texture you use.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 烘焙较大的贴图可以让你捕捉到更多的细节，但也会花费更多时间。在决定烘焙多大尺寸的贴图时，考虑模型的细节程度以及在烘焙前需要保留的细节量，以便优化所使用贴图的分辨率。
- en: In general, a good rule of thumb to follow for displacement maps is that the
    size of the map in pixels need not be much bigger than the polycount of the mesh.
    So if you are baking about a 1M poly sculpt, a 1024×1024 pixel map will probably
    suffice. For other texture maps, consider the size that an object will appear
    in the final render. If an object will appear only a few hundred pixels high in
    the final render, its texture map should be about the same size. On the other
    hand, if an object appears close-up at a high resolution, then bigger textures
    will be needed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，对于位移贴图的一个好经验法则是，贴图的像素大小不需要比网格的多边形数大太多。因此，如果你正在烘焙一个约 1M 多边形的雕刻模型，1024×1024
    像素的贴图应该就足够了。对于其他类型的贴图，考虑物体在最终渲染中的大小。如果一个物体在最终渲染中只会显示几百像素高，那么它的贴图大小应该大致相同。另一方面，如果一个物体是近距离以高分辨率显示的，那么就需要更大的贴图。
- en: In the case of particularly simple textures, like the flat colors we baked for
    the Spider Bot, you can make the image much smaller while baking and scale it
    up in an image editing program like GIMP later (making sure to increase the margin
    setting to prevent seams).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特别简单的材质，比如我们为蜘蛛机器人烘焙的平面颜色，你可以在烘焙时将图像做得更小，之后在像 GIMP 这样的图像编辑程序中放大（确保增加边距设置，以防止接缝）。
- en: When creating images to bake to, set bit depths appropriately. Displacement
    maps require 32-bit images, while other texture types typically only require 8-bit
    (or 16-bit if you plan to manipulate them heavily). Blender can bake either 8-
    or 32-bit images, but remember the bit depth you end up with is also determined
    by the file format you save to. Use OpenEXR for high-bit-depth images and *.tga*
    or *.png* files for 8-bit images. Additionally, remember that GIMP can only edit
    8-bit images (for now, that is—future versions are likely to incorporate support
    for high-bit-depth images), so if you plan on painting textures in GIMP, the extra
    depth is of little help.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建烘焙图像时，适当设置位深度。位移贴图需要32位图像，而其他类型的纹理通常只需要8位（或者如果你打算进行大量操作，使用16位）。Blender可以烘焙8位或32位图像，但请记住，你最终得到的位深度也取决于你保存的文件格式。对于高位深图像，使用OpenEXR，而对于8位图像，使用*.tga*或*.png*文件。另外，请记住，GIMP目前只能编辑8位图像（现在是这样——未来的版本可能会支持高位深图像），因此如果你打算在GIMP中绘制纹理，额外的位深度并没有太大帮助。
- en: When baking ambient occlusion or lighting, consider isolating the pieces you
    are baking on one layer to get more control over the results. And finally, it
    can be helpful to change the world settings (or settings for lamps if you’re baking
    lighting) to achieve higher-quality baked textures. (See [Chapter 13](ch13.html
    "Chapter 13. Lighting") for more on world and lighting settings.)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在烘焙环境遮蔽或光照时，考虑将你要烘焙的部分隔离到一个单独的图层，以便更好地控制结果。最后，调整世界设置（或者如果你在烘焙光照，调整灯光设置）也有助于获得更高质量的烘焙纹理。（有关世界和光照设置的更多内容，请参见[第13章](ch13.html
    "第13章. 光照")。）
- en: In Review
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we’ve discussed baking textures into images using Blender’s
    baking tools and the kinds of maps Blender will allow you to bake. I used these
    techniques to bake maps for my various projects: For the Bat Creature, I baked
    displacement and ambient occlusion maps, and for the Spider Bot, I baked ambient
    occlusion and some block colors to aid with texturing later. While I didn’t need
    to do a lot of texture baking for the Jungle Temple scene, I did create an ambient
    occlusion map for the statue.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用Blender的烘焙工具将纹理烘焙到图像中，以及Blender允许你烘焙的各种贴图类型。我使用这些技巧为我的多个项目烘焙贴图：对于蝙蝠生物，我烘焙了位移贴图和环境遮蔽贴图；对于蜘蛛机器人，我烘焙了环境遮蔽贴图和一些块状颜色，以便稍后进行纹理处理。虽然我在丛林寺庙场景中并不需要进行大量的纹理烘焙，但我确实为雕像创建了一个环境遮蔽贴图。
- en: In the next chapter, we’ll combine the textures we’ve baked with other ways
    of creating textures, from painting and cloning textures directly in Blender to
    painting in GIMP and combining photo textures to synthesize new ones.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将结合我们烘焙的纹理与其他创建纹理的方法，从在Blender中直接绘制和克隆纹理，到在GIMP中绘制并结合照片纹理以合成新纹理。
