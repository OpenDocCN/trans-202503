- en: Chapter 3. Fundamentals
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三章 基础知识
- en: In the previous chapter, you learned how F# Interactive can enhance your workflow
    through rapid feedback and task automation. Now we’ll put that knowledge to work
    as we explore some basic language features. The concepts introduced in this chapter
    apply regardless of whether you’re programming primarily in an imperative, object-oriented,
    or functional style.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何通过快速反馈和任务自动化来提升 F# Interactive 的工作流程。现在，我们将把这些知识付诸实践，探索一些基本的语言特性。本章介绍的概念无论你主要使用命令式、面向对象还是函数式编程风格，都是适用的。
- en: Most of this chapter focuses on how F# handles concepts central to the .NET
    Framework, like the core data types, enumerations, flow control, generics, and
    exception handling. You’ll also learn how F# can help you write more predictable
    code through controlling side effects, default immutability, type inference, and
    option types. Regardless of the subject, though, you should start seeing how F#
    distinguishes itself as a compelling alternative to C# and Visual Basic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章大部分内容集中于 F# 如何处理与 .NET Framework 中核心概念相关的内容，如核心数据类型、枚举、流程控制、泛型和异常处理。你还将学习如何通过控制副作用、默认不可变性、类型推断和选项类型来帮助你编写更可预测的代码。无论主题如何，你应该开始看到
    F# 如何作为 C# 和 Visual Basic 的一种有力替代方案脱颖而出。
- en: Immutability and Side Effects
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性与副作用
- en: If you’re coming to F# from a primarily object-oriented background, the feature
    you may find the most challenging to adjust to is *default immutability*. This
    is a radical departure from traditional .NET languages that place few restrictions
    on what can change and when. Programs written in languages without default immutability
    can be unpredictable because system state (program data) can change at almost
    any time. We refer to these changes as *side effects*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是从主要使用面向对象编程的背景转到 F#，你可能会发现最难适应的特性是*默认不可变性*。这是与传统 .NET 语言的根本区别，因为传统的语言对可以更改的内容和时间几乎没有限制。在没有默认不可变性的语言中编写的程序可能是不可预测的，因为系统状态（程序数据）几乎可以随时改变。我们将这些变化称为*副作用*。
- en: 'Some side effects, like writing to the console, are relatively benign, but
    what about when they affect shared resources? What if invoking a function changes
    a value that’s used elsewhere? Will a function always yield the same result regardless
    of when it’s called? Consider this C# example that references a public field for
    some multiplication:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一些副作用，如写入控制台，相对来说是无害的，但如果它们影响共享资源呢？如果调用一个函数改变了在其他地方使用的值呢？无论何时调用，函数是否总是会产生相同的结果？考虑下面这个
    C# 示例，它引用了一个公共字段进行乘法运算：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the `Multiply` method ① has a side effect where the `multiplier`
    is incremented ②. As long as nothing changes anywhere else in the program it’s
    somewhat predictable, but as soon as you change the order of calls to the `Multiply`
    method, introduce another call to the `Multiply` method, or change the `multiplier`
    field through some other mechanism, all future results are brought into question.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Multiply` 方法①有一个副作用，即`multiplier`会被递增②。只要程序中的其他部分没有变化，它是相对可预测的，但一旦你改变
    `Multiply` 方法调用的顺序，增加另一个 `Multiply` 方法的调用，或者通过其他机制更改 `multiplier` 字段，所有后续结果就会变得不可预测。
- en: 'To further complicate the issue, consider what happens when multiple calls
    to `Multiply` are made in parallel, in this revision of the `Main` method:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步复杂化问题，考虑当多次并行调用 `Multiply` 时会发生什么，以下是 `Main` 方法的修改版本：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There’s no guarantee as to which operation will execute first when running in
    parallel, so running this 10 times is likely to give you 10 different results.
    The unpredictability that comes from using mutable values is why *global state*
    (values accessible from anywhere within your application) is generally considered
    harmful. Properly managing global state requires discipline that can be increasingly
    difficult to enforce as teams and projects grow.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行运行时，无法保证哪个操作会先执行，因此运行这段代码 10 次可能会得到 10 种不同的结果。使用可变值所带来的不可预测性就是为什么*全局状态*（在应用程序中任何地方都可以访问的值）通常被认为是有害的原因。正确管理全局状态需要一种纪律，而随着团队和项目的扩大，这种纪律的执行可能变得越来越困难。
- en: Functional Purity
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式纯粹性
- en: Functional languages like F# are often described in terms of their mathematical
    purity. In *purely* functional languages like Haskell, programs are composed entirely
    of deterministic *expressions* that always return a value, and side effects are
    expressly forbidden except in certain specific circumstances. In contrast, F#
    is an *impure* functional language. As such, it takes an important step toward
    improving predictability by making values immutable by default.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 像 F# 这样的函数式语言通常用其数学纯度来描述。在 *纯粹的* 函数式语言（如 Haskell）中，程序完全由确定性的 *表达式* 组成，这些表达式总是返回一个值，并且除非在某些特定情况下，副作用是明确禁止的。相比之下，F#
    是一种 *不纯* 的函数式语言。因此，它通过默认将值设为不可变，朝着提高可预测性迈出了重要的一步。
- en: That’s not to say that F# can’t use variables in the traditional sense; it just
    means that in order to change a value, you must explicitly allow it and should
    restrict the value’s scope as much as possible. By keeping the scope narrow, you
    can code in a primarily functional style but switch to a more imperative or object-oriented
    style in isolated fragments as appropriate.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说 F# 不能像传统意义上的变量那样使用变量；这只是意味着，为了改变一个值，你必须明确允许它，并应尽可能限制该值的作用范围。通过保持范围狭窄，你可以主要以函数式风格编写代码，但在适当的情况下在独立片段中切换到更具命令式或面向对象的风格。
- en: By managing side effects through default immutability, F# code is more naturally
    suited for execution in parallel and concurrent environments. In many cases, carefully
    controlling what can change reduces, if not eliminates, the need to lock shared
    resources and ensures that multiple processes don’t attempt to make potentially
    conflicting or behavior-altering changes to the overall system state. This added
    safety is increasingly important as software development evolves to take advantage
    of the multiprocessor or multicore systems that are so ubiquitous in modern computing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过通过默认的不变性来管理副作用，F# 代码更自然地适用于并行和并发环境。在许多情况下，仔细控制哪些内容可以更改，减少了（如果不是消除了的话）对共享资源加锁的需求，并确保多个进程不会试图对整体系统状态做出可能冲突或改变行为的更改。随着软件开发演变，越来越多地利用现代计算中普遍存在的多处理器或多核心系统，这种额外的安全性变得愈加重要。
- en: Bindings
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定
- en: '*Bindings* are F#’s primary way of identifying values or executable code. There
    are three types of bindings—`let`, `use`, and `do`—and each has a specific purpose.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*绑定* 是 F# 用于标识值或可执行代码的主要方式。共有三种类型的绑定——`let`、`use` 和 `do`——每种都有其特定用途。'
- en: let Bindings
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让绑定
- en: '`let` bindings simply associate names with values. They are the most common
    and versatile binding type. (I briefly introduced `let` bindings in [Chapter 2](ch02.html
    "Chapter 2. F# Interactive").) You create a `let` binding with the `let` keyword.
    For example, to bind an integer value you would use something like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 绑定只是将名称与值关联。它们是最常见和最通用的绑定类型。（我在[第 2 章](ch02.html "第 2 章 F# 交互式")中简要介绍了
    `let` 绑定。）你可以使用 `let` 关键字创建一个 `let` 绑定。例如，绑定一个整数值，你可以使用如下代码：'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Similarly, to bind a string you could use:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，绑定一个字符串，你可以使用如下代码：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But `let` bindings aren’t restricted to simple assignments. You can also use
    them to identify functions or other expressions:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`let` 绑定并不限于简单的赋值。你也可以用它们来标识函数或其他表达式：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Literals
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字面量
- en: Although the `let` bindings we’ve seen so far are immutable, they can’t be considered
    constant values in the traditional .NET sense. Bindings are more like `readonly`
    variables in C# (`ReadOnly` in Visual Basic) than they are constants, in that
    their values are resolved at run time rather than replaced inline at compile time.
    You can define a true .NET constant value, called a *literal* in F#, by decorating
    a binding with the `Literal` attribute. (F# follows the same convention as other
    .NET languages by making the `Attribute` suffix optional, so in this example both
    `Literal` and `LiteralAttribute` are acceptable.)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们迄今看到的 `let` 绑定是不可变的，但它们不能像传统 .NET 中的常量值那样被视为常量。绑定更像是 C# 中的 `readonly` 变量（Visual
    Basic 中的 `ReadOnly`），而不是常量，因为它们的值是在运行时解析的，而不是在编译时内联替换。你可以通过使用 `Literal` 特性来定义一个真正的
    .NET 常量值，F# 中称之为 *字面量*。（F# 遵循与其他 .NET 语言相同的约定，使得 `Attribute` 后缀是可选的，因此在此示例中，`Literal`
    和 `LiteralAttribute` 都是可以接受的。）
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This causes the compiler to treat the definition the same as a `const` in C#
    (`Const` in Visual Basic), meaning that the value will be compiled inline wherever
    it is used. As such, bindings decorated as `Literal` must be a full constructed
    value type, string, or null.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得编译器将定义视为 C# 中的 `const`（Visual Basic 中的 `Const`），意味着该值将在使用的地方内联编译。因此，作为 `Literal`
    装饰的绑定必须是完全构造的值类型、字符串或 null。
- en: Mutable Bindings
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可变绑定
- en: If you try to change the value of a default binding with the assignment operator
    (`<-`), the compiler will tell you that you can’t.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用赋值操作符（`<-`）更改默认绑定的值，编译器会告诉你这是不允许的。
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To make a binding mutable, simply include the `mutable` keyword in its definition.
    Once a mutable binding is defined, you can change its value at will.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要使一个绑定变为可变，只需在其定义中包含 `mutable` 关键字。一旦定义了可变绑定，你就可以随意更改它的值。
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There is, of course, a caveat: Mutable bindings don’t play nicely with *closures*
    (inline functions that can access bindings visible within the scope where they’re
    defined).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里有一个警告：可变绑定与 *闭包*（可以访问在其定义作用域内可见的绑定的内联函数）不太兼容。
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, the mutable binding, `sum`①, is captured by the `add` closure
    ②. If you try to compile this code, the compiler politely informs you of the error
    and instructs you to either eliminate the mutation or use another mutable construct,
    a *reference cell*, instead.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，可变绑定 `sum`① 被 `add` 闭包 ② 捕获。如果你尝试编译这段代码，编译器会礼貌地告诉你错误，并建议你要么消除这个变更，要么使用另一个可变结构——*引用单元格*。
- en: Reference Cells
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 引用单元格
- en: Reference cells are like mutable bindings in that their values can be changed
    at run time, but they work much differently. A reasonable way to think of reference
    cells is that they are to pointers what mutable bindings are to traditional variables.
    That said, reference cells aren’t really pointers either because they’re concrete
    types that encapsulate a mutable value rather than pointing to a particular resource
    or memory address.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 引用单元格像可变绑定一样，它们的值可以在运行时改变，但它们的工作方式完全不同。一个合理的理解方式是，引用单元格类似于指针，就像可变绑定类似于传统变量。也就是说，引用单元格其实并不是真正的指针，因为它们是封装可变值的具体类型，而不是指向特定资源或内存地址。
- en: You create a new reference cell like a typical `let` binding except that you
    include the `ref` operator before the bound value.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像普通的 `let` 绑定一样创建一个新的引用单元格，只不过你在绑定的值前加上 `ref` 操作符。
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Accessing and changing a reference cell’s value requires a different syntax
    than a standard binding because we need to affect the encapsulated value rather
    than the reference cell itself.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 访问和更改引用单元格的值需要不同的语法，因为我们需要操作封装的值，而不是引用单元格本身。
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see at ①, the `:=` operator is used to change the reference cell’s
    value, and at ② the `!` operator is used to return the cell’s value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在 ① 处，`:=` 操作符用于更改引用单元格的值，在 ② 处，`!` 操作符用于返回单元格的值。
- en: use Bindings
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用绑定
- en: F# provides a binding mechanism for types that implement the `IDisposable` interface
    in a way that’s similar to C#’s `using` statement. In F#, when you want the compiler
    to insert a call to an `IDisposable` object’s `Dispose` method, you can create
    a `use` binding with the `use` keyword.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: F# 提供了一种绑定机制，用于实现 `IDisposable` 接口的类型，这种机制类似于 C# 的 `using` 语句。在 F# 中，当你希望编译器插入一个对
    `IDisposable` 对象的 `Dispose` 方法的调用时，你可以使用 `use` 关键字创建一个 `use` 绑定。
- en: Like the `using` statement, which delimits the block where the `IDisposable`
    object is in scope, objects created through `use` bindings are disposed of when
    their enclosing block terminates; that is, if a `use` binding is created at the
    top level of a function, the object will be disposed of immediately after the
    function returns. Similarly, if a `use` binding is created within a nested construct,
    like a loop, the object will be disposed of when the iteration completes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `using` 语句一样，它限定了 `IDisposable` 对象的作用域块，`use` 绑定创建的对象会在其所在的块结束时被处置；也就是说，如果在一个函数的顶层创建了
    `use` 绑定，该对象将在函数返回后立即被处置。类似地，如果 `use` 绑定是在一个嵌套结构（例如循环）内创建的，该对象将在循环迭代完成时被处置。
- en: 'The following example shows this principle in action:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了这个原理的实际应用：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the `createDisposable` function ① writes a message to the console
    telling you that a disposable object is being created. It then returns an object
    that prints a message when it’s disposed of ②. The `testDisposable` function ③
    repeatedly invokes the `createDisposable` function both inside and outside of
    a simple `for` loop and writes out messages telling you when each block is terminating.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`createDisposable` 函数 ① 向控制台输出一条消息，告诉你正在创建一个可处置的对象。然后它返回一个对象，当该对象被处置时会输出一条消息
    ②。`testDisposable` 函数 ③ 在一个简单的 `for` 循环内外反复调用 `createDisposable` 函数，并输出消息，告诉你每个代码块何时终止。
- en: Invoking the `testDisposable` function produces the following output that shows
    when each object is created and disposed of in relation to its containing block.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `testDisposable` 函数会产生如下输出，显示每个对象在其包含块中被创建和处置的时间。
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A simple and more practical example of a `use` binding is writing some text
    to a file, like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单且更实用的 `use` 绑定示例是将一些文本写入文件，如下所示：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice at ① that a `let` binding is used for the `writeToFile` function (functions
    are data in F#) and that at ② a `use` binding is used in conjunction with the
    `new` keyword ③ to create the `FileStream`. (The `new` keyword is optional in
    F#, but by convention it’s included whenever an `IDisposable` object is created
    to indicate that the object should be disposed of. If you create a `use` binding
    without the `new` keyword, the compiler will issue a warning.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 ① 处，使用了 `let` 绑定来定义 `writeToFile` 函数（函数在 F# 中也是数据），而在 ② 处，`use` 绑定与 `new`
    关键字一起使用 ③ 来创建 `FileStream`。 （`new` 关键字在 F# 中是可选的，但按照惯例，每当创建一个 `IDisposable` 对象时都会包含它，以表示该对象应当被处置。如果你在没有
    `new` 关键字的情况下创建 `use` 绑定，编译器会发出警告。）
- en: '`use` bindings can’t be used directly within a module, primarily because modules
    are essentially static classes that never go out of scope. If you try to define
    a `use` binding directly within a module, you’ll receive a compiler warning along
    with a note that the binding will be treated as a `let` binding instead, like
    this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`use` 绑定不能直接在模块内使用，主要是因为模块本质上是静态类，它们永远不会超出作用域。如果你尝试直接在模块中定义 `use` 绑定，你将收到编译器的警告，提示该绑定将被当作
    `let` 绑定处理，如下所示：'
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: using Function
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: using 函数
- en: 'For more control over an `IDisposable`, turn to the `using` function. Although
    not a binding in its own right, `using` offers functionality that’s a bit more
    like C#’s `using` statement: Give it an `IDisposable` and a function that accepts
    the instance, and `using` automatically calls `Dispose` when it completes, as
    shown here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 若想对 `IDisposable` 有更多控制，使用 `using` 函数。尽管它本身不是一个绑定，`using` 提供的功能与 C# 的 `using`
    语句有些相似：给它一个 `IDisposable` 和一个接受该实例的函数，`using` 会在完成时自动调用 `Dispose`，如下面所示：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In some ways `using` is more powerful than its C# counterpart because, like
    every expression in F#, it returns a value. Consider this revision of the previous
    example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从某些方面来说，`using` 比它的 C# 对应物更强大，因为像 F# 中的每个表达式一样，它都会返回一个值。考虑以下修改版的前一个例子：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Instead of writing the dimensions to the console within the function passed
    to the `using` function at ②, we return them as a *tuple* (a simple type containing
    multiple data items) and bind each component value to meaningful names as shown
    at ①, before writing them to the console at ③. Even in this simple example you
    can begin to see how F#’s composable, expressive syntax leads to more understandable
    solutions by eliminating most of the *plumbing code* (code you have to write to
    satisfy the compiler), allowing you to focus on the problem itself.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在传递给 `using` 函数的 ② 中的函数内直接将维度写入控制台，而是将它们作为 *元组*（一个包含多个数据项的简单类型）返回，并将每个组件值绑定到有意义的名称，如
    ① 所示，然后在 ③ 中写入控制台。即便在这个简单的例子中，你也可以看到 F# 的组合式、表达性语法如何通过消除大部分 *管道代码*（为满足编译器需要编写的代码），让你能够专注于问题本身，从而得出更易于理解的解决方案。
- en: Replicating the using Function in C#
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 C# 中复制 `using` 函数
- en: I like F#’s `using` function so much that I’ve created a couple of static helper
    methods for use in my C# projects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢 F# 的 `using` 函数，因此我为我的 C# 项目创建了一些静态辅助方法。
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: They’re not exactly pretty, but they get the job done.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不算漂亮，但能够完成任务。
- en: Now here’s the C# version of the preceding examples using my helper functions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里是使用我的辅助函数的前面例子的 C# 版本。
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Although the code looks and behaves like the F# version, I find the F# version
    much cleaner, especially with its syntactic support for tuples.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码看起来和行为上与 F# 版本相似，但我发现 F# 版本更加简洁，特别是它对元组的语法支持。
- en: do Bindings
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: do 绑定
- en: The final type of binding is the `do` binding, defined with the `do` keyword.
    Unlike the other binding types, `do` bindings don’t attach values to a name; they’re
    used whenever you need to execute some code outside the context of a function
    or value definition.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种绑定类型是 `do` 绑定，通过 `do` 关键字定义。与其他绑定类型不同，`do` 绑定不会将值附加到名称上；它们用于在函数或值定义之外执行一些代码。
- en: '`do` bindings are commonly used within looping constructs, sequence expressions,
    class constructors, and module initialization. We’ll look at each scenario in
    turn as we encounter them in later chapters.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`do`绑定通常在循环结构、序列表达式、类构造函数和模块初始化中使用。我们将在后续章节中逐一讨论这些场景。'
- en: Identifier Naming
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标识符命名
- en: We’ve seen quite a few identifiers already, but we haven’t really looked at
    what makes something a valid identifier. Like any programming language, F# has
    naming rules.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过一些标识符，但还没有真正探讨什么才是有效的标识符。像任何编程语言一样，F#也有命名规则。
- en: Identifiers in F# are pretty typical of most programming languages. In general,
    F# identifiers must start with an underscore (**`_`**), an uppercase letter, or
    a lowercase letter, followed by any combination thereof. Numbers are also valid
    characters in identifiers so long as they are not the first character. For example,
    the following are valid identifiers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: F#中的标识符与大多数编程语言非常相似。通常，F#标识符必须以下划线(**`_`**)、大写字母或小写字母开头，后面可以跟随任何组合。数字也可以作为标识符中的有效字符，只要它们不是第一个字符。例如，以下是有效的标识符。
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The most interesting thing about identifiers in F# is that there’s an alternative
    *quoted identifier* format with fewer restrictions. By enclosing an identifier
    in double backtick characters (`"`), you can use virtually any string as a valid
    F# identifier, like so.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: F#中最有趣的标识符之一是替代的*引用标识符*格式，它有更少的限制。通过将标识符用双反引号（`"`）括起来，你可以几乎使用任何字符串作为有效的F#标识符，例如这样。
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It’s usually best to use quoted identifiers sparingly, but they can be incredibly
    useful in certain situations. For example, they’re often used for naming unit
    tests. By using quoted identifiers for test names, you can focus on describing
    the test rather than arguing over naming conventions. If you’re using a test framework
    (like NUnit), the full quoted name in the test list clarifies what is being tested.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好谨慎使用引用标识符，但在某些情况下，它们非常有用。例如，它们经常用于命名单元测试。通过使用引用标识符命名测试，你可以专注于描述测试内容，而不是争论命名约定。如果你使用测试框架（如NUnit），测试列表中的完整引用名称可以明确说明正在测试什么。
- en: Core Data Types
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心数据类型
- en: As a .NET language, F# supports the full range of Common Language Infrastructure
    (CLI) types. Each of the core primitives and even some more complex types, like
    `System.String`, are exposed as *type abbreviations* (convenient aliases for existing
    types). Many of these even have additional syntax support to enhance *type inference*
    (the compiler’s ability to automatically determine data types) or otherwise simplify
    working with them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 作为.NET语言，F#支持完整的公共语言基础结构（CLI）类型。每个核心原始类型，甚至一些更复杂的类型，如`System.String`，都作为*类型缩写*（现有类型的便捷别名）暴露出来。许多类型还支持附加的语法支持，以增强*类型推断*（编译器自动确定数据类型的能力）或简化与它们的交互。
- en: Boolean Values and Operators
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔值和运算符
- en: 'The `bool` type abbreviation exposes the standard `System.Boolean` structure.
    Just as in other languages, `bool` can have one of two values: `true` and `false`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool`类型缩写暴露了标准的`System.Boolean`结构。与其他语言一样，`bool`只能取两个值：`true`和`false`。'
- en: The F# language includes a few operators for comparing Boolean values, as listed
    in [Table 3-1](ch03.html#boolean_operators "Table 3-1. Boolean Operators").
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: F#语言包括一些用于比较布尔值的运算符，具体列表请参见[表3-1](ch03.html#boolean_operators "表3-1. 布尔运算符")。
- en: Table 3-1. Boolean Operators
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表3-1. 布尔运算符
- en: '| Operator | Description |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `not` | Negation |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `not` | 取反 |'
- en: '| `&#124;&#124;` | OR |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | OR |'
- en: '| `&&` | AND |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | AND |'
- en: The OR and AND operators are short-circuited so they immediately return when
    the expression on the left satisfies the overall condition. In the case of the
    OR operator, if the expression on the left is true, there is no need to evaluate
    the expression on the right. Similarly, the AND operator will evaluate the expression
    on the right only when the expression on the left is true.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: OR和AND运算符是短路运算符，因此当左侧的表达式满足整体条件时，它们会立即返回。对于OR运算符，如果左侧的表达式为真，则不需要评估右侧的表达式。同样，AND运算符只有在左侧的表达式为真时才会评估右侧的表达式。
- en: Numeric Types
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数值类型
- en: F# offers the same selection of numeric types as in other .NET languages. [Table 3-2](ch03.html#common_numeric_types
    "Table 3-2. Common Numeric Types") lists commonly used numeric types along with
    their corresponding .NET type, value range, and suffix.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: F# 提供了与其他 .NET 语言相同的数字类型选择。[表 3-2](ch03.html#common_numeric_types "表 3-2. 常见数字类型")列出了常用的数字类型及其相应的
    .NET 类型、值范围和后缀。
- en: Table 3-2. Common Numeric Types
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-2. 常见的数字类型
- en: '| Type Abbreviation | .NET Type | Range | Suffix |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 类型缩写 | .NET 类型 | 范围 | 后缀 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `byte` | `System.Byte` | 0 to 255 | `uy` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `System.Byte` | 0 到 255 | `uy` |'
- en: '| `sbyte`, `int8` | `System.SByte` | –128 to 127 | `y` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `sbyte`, `int8` | `System.SByte` | –128 到 127 | `y` |'
- en: '| `int16` | `System.Int16` | –32,768 to 32,767 | `s` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `int16` | `System.Int16` | –32,768 到 32,767 | `s` |'
- en: '| `uint16` | `System.UInt16` | 0 to 65,535 | `us` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `uint16` | `System.UInt16` | 0 到 65,535 | `us` |'
- en: '| `int`, `int32` | `System.Int32` | –2^(31) to 2^(31)–1 |   |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `int`, `int32` | `System.Int32` | –2^(31) 到 2^(31)–1 |   |'
- en: '| `uint`, `uint32` | `System.UInt32` | 0 to 2^(32)–1 | `u`, `ul` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `uint`, `uint32` | `System.UInt32` | 0 到 2^(32)–1 | `u`, `ul` |'
- en: '| `int64` | `System.Int64` | –2^(63) to 2^(63)–1 | `L` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `int64` | `System.Int64` | –2^(63) 到 2^(63)–1 | `L` |'
- en: '| `uint64` | `System.UInt64` | 0 to 2^(64)–1 | `UL` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `uint64` | `System.UInt64` | 0 到 2^(64)–1 | `UL` |'
- en: '| `decimal` | `System.Decimal` | –2^(96)–1 to 2^(96)–1 | `M` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `decimal` | `System.Decimal` | –2^(96)–1 到 2^(96)–1 | `M` |'
- en: '| `float`, `double` | `System.Double` | 64-bit double precision number precise
    to approximately 15 digits |  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `float`, `double` | `System.Double` | 64 位双精度数，精确到大约 15 位数字 |  |'
- en: '| `float32`, `single` | `System.Single` | 32-bit single precision number precise
    to approximately 7 digits | `F, f` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `float32`, `single` | `System.Single` | 32 位单精度数，精确到大约 7 位数字 | `F, f` |'
- en: '| `bigint` | `System.Numerics.BigInteger` | No defined upper or lower bounds
    | `I` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `bigint` | `System.Numerics.BigInteger` | 无定义的上限或下限 | `I` |'
- en: '| `nativeint` | `System.IntPtr` | 32-bit platform-specific integer | `n` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `nativeint` | `System.IntPtr` | 32 位平台特定整数 | `n` |'
- en: '| `unativeint` | `System.UIntPtr` | 32-bit unsigned platform-specific integer
    | `un` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `unativeint` | `System.UIntPtr` | 32 位平台特定的无符号整数 | `un` |'
- en: In general, the suffixes are used more frequently in F# than in other .NET languages
    because they provide the compiler with all of the information it needs to correctly
    infer the type.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，后缀在 F# 中使用的频率比其他 .NET 语言更高，因为它们为编译器提供了正确推断类型所需的所有信息。
- en: Numeric Operators
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数字运算符
- en: As you might expect, F# includes a number of built-in operators for working
    with the numeric types. [Table 3-3](ch03.html#numeric_operators-id00003 "Table 3-3. Numeric
    Operators") lists commonly used arithmetic, comparison, and bitwise operations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的，F# 包含了许多用于处理数字类型的内置运算符。[表 3-3](ch03.html#numeric_operators-id00003 "表
    3-3. 数字运算符")列出了常用的算术、比较和位运算操作。
- en: Table 3-3. Numeric Operators
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-3. 数字运算符
- en: '| Operator | Description |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `+` | Unary positive (does not change the sign of the expression)Unchecked
    addition |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 一元正号（不改变表达式的符号）未检查的加法 |'
- en: '| `-` | Unary negation (changes the sign of the expression)Unchecked subtraction
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 一元负号（改变表达式的符号）未检查的减法 |'
- en: '| `*` | Unchecked multiplication |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 未检查的乘法 |'
- en: '| `/` | Unchecked division |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 未检查的除法 |'
- en: '| `%` | Unchecked modulus |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 未检查的取模 |'
- en: '| `**` | Unchecked exponent (valid only for floating-point types) |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `**` | 未检查的指数（仅对浮点类型有效） |'
- en: '| `=` | Equality |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `=` | 等于 |'
- en: '| `>` | Greater than |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 大于 |'
- en: '| `<` | Less than |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 小于 |'
- en: '| `>=` | Greater than or equal |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 大于或等于 |'
- en: '| `<=` | Less than or equal |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 小于或等于 |'
- en: '| `<>` | Not equal |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `<>` | 不等于 |'
- en: '| `&&&` | Bitwise AND |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `&&&` | 位运算与 |'
- en: '| `&#124;&#124;&#124;` | Bitwise OR |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;&#124;` | 位运算或 |'
- en: '| `^^^` | Bitwise exclusive OR |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `^^^` | 位运算异或 |'
- en: '| `~~~` | Bitwise negation |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `~~~` | 位运算取反 |'
- en: '| `<<<` | Bitwise left shift |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `<<<` | 位运算左移 |'
- en: '| `>>>` | Bitwise right shift |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `>>>` | 位运算右移 |'
- en: 'It’s important to note that although most of the operators in [Table 3-3](ch03.html#numeric_operators-id00003
    "Table 3-3. Numeric Operators") work with any numeric type, the bitwise operators
    work only against the integral types. Also, because of the way floating-point
    numbers are represented in memory you should avoid using the equality operators
    with them directly or you may see incorrect results, as shown here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，尽管 [表 3-3](ch03.html#numeric_operators-id00003 "表 3-3. 数字运算符") 中的大多数运算符都可以用于任何数字类型，但位运算符仅适用于整数类型。此外，由于浮点数在内存中的表示方式，你应该避免直接使用等于运算符，否则可能会得到错误的结果，如下所示：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Instead of using the equality operator (`=`), you can calculate the difference
    between the two floating-point values and verify that the difference is within
    a threshold. I generally prefer to define this type of operation as a function
    for reusability.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用等号操作符（`=`），不如计算两个浮点值之间的差异，并验证该差异是否在阈值范围内。我通常更倾向于将这种操作定义为一个函数，以便复用。
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Numeric Conversion Functions
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数字转换函数
- en: When you’re working with numeric data types in F#, there are no implicit type
    conversions. This is largely because type conversions are considered side effects,
    and computation problems arising from implicit type conversions are often difficult
    to locate.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 F# 中处理数值数据类型时，没有隐式类型转换。这主要是因为类型转换被视为副作用，且由于隐式类型转换引发的计算问题通常很难定位。
- en: To work with different numeric types in the same expression, you’ll need to
    explicitly convert them using the appropriate built-in conversion functions. Each
    conversion function has the same name as the target type abbreviation, which makes
    them really easy to remember. For instance, to convert an integer value to a float
    you’d call the `float` function, as shown in this example.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在同一表达式中处理不同的数值类型，你需要使用适当的内建转换函数进行显式转换。每个转换函数的名称与目标类型的缩写相同，这使得它们非常容易记住。例如，要将整数值转换为浮点数，你可以调用
    `float` 函数，如此示例所示。
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Characters
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符
- en: As a .NET language, F# carries on the tradition of using 16-bit Unicode for
    character data. Individual characters are represented by `System.Char` and exposed
    to F# via the `char` type abbreviation. You can bind most individual Unicode characters
    to an identifier by wrapping them in single quotes, while the remaining characters
    are represented with escaped character codes, as shown here.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一门 .NET 语言，F# 延续了使用 16 位 Unicode 来表示字符数据的传统。单个字符由 `System.Char` 表示，并通过 `char`
    类型缩写暴露给 F#。你可以通过将它们包裹在单引号中来绑定大多数单个 Unicode 字符，而其余字符则通过转义字符代码表示，如下所示。
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In addition to the Unicode character escape code, F# has a few other escape
    sequences for some common characters, as listed in [Table 3-4](ch03.html#common_escape_sequences
    "Table 3-4. Common Escape Sequences").
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Unicode 字符转义代码外，F# 还有一些其他转义序列用于表示一些常见字符，如 [表格 3-4](ch03.html#common_escape_sequences
    "表格 3-4. 常见转义序列") 中列出。
- en: Table 3-4. Common Escape Sequences
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 3-4. 常见转义序列
- en: '| Character | Sequence |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 序列 |'
- en: '| --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Backspace | `\b` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 退格符 | `\b` |'
- en: '| Newline | `\n` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 换行符 | `\n` |'
- en: '| Carriage return | `\r` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 回车符 | `\r` |'
- en: '| Tab | `\t` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 制表符 | `\t` |'
- en: '| Backslash | `\\` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 反斜杠 | `\\` |'
- en: '| Quotation mark | `\"` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 引号 | `\"` |'
- en: '| Apostrophe | `\''` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 撇号 | `\''` |'
- en: Strings
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Strings are sequential collections of `char` and are represented by the `string`
    type abbreviation. There are three types of strings in F#: string literals, verbatim
    strings, and triple-quoted strings.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是 `char` 的顺序集合，并由 `string` 类型缩写表示。F# 中有三种类型的字符串：字符串字面量、逐字字符串和三引号字符串。
- en: String Literals
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串字面量
- en: The most common string definition is the *string literal*, which is enclosed
    in quotation marks as follows.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的字符串定义是 *字符串字面量*，它被引号括起来，如下所示。
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: String literals can contain the same characters and escape sequences described
    in [Table 3-4](ch03.html#common_escape_sequences "Table 3-4. Common Escape Sequences").
    Newlines within the string literal are retained unless they’re preceded by a backslash
    (`\`) character. If a backslash is present, the newline character will be removed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量可以包含 [表格 3-4](ch03.html#common_escape_sequences "表格 3-4. 常见转义序列") 中描述的相同字符和转义序列。字符串字面量中的换行符会被保留，除非它们前面有一个反斜杠（`\`）字符。如果存在反斜杠，换行符将被移除。
- en: Verbatim Strings
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 逐字字符串
- en: '*Verbatim strings* are much like string literals except that they are preceded
    by the `@` character and ignore escape sequences. You can embed quotation marks
    within the string, but they must be written as `""`, like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*逐字字符串* 与字符串字面量非常相似，唯一不同的是它们以 `@` 字符开头并且忽略转义序列。你可以在字符串中嵌入引号，但必须以 `""` 的形式写入，像这样：'
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Not parsing escape sequences makes verbatim strings a good choice for representing
    system paths containing backslashes, provided that you don’t have them stored
    in a configuration setting somewhere. (You’re not hard-coding your paths, right?)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 不解析转义序列使得逐字字符串成为表示包含反斜杠的系统路径的良好选择，前提是你没有将它们存储在某个配置设置中。（你没有硬编码路径，对吧？）
- en: Triple-Quoted Strings
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 三引号字符串
- en: 'As the name implies, *triple-quoted strings* are enclosed in triple quotation
    marks like `""Klaatu barada nikto!""`. Triple-quoted strings are like verbatim
    strings in that they ignore all escape sequences, but they also ignore double
    quotes. This type of string is most useful when you’re working with formatted
    character data that naturally contains embedded quotes, like XML documents. For
    example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，*三重引号字符串*是用三个引号括起来的，像这样：`""Klaatu barada nikto!""`。三重引号字符串类似于逐字字符串，它忽略所有的转义序列，但它也忽略双引号。这种类型的字符串在处理包含嵌入引号的格式化字符数据时最为有用，例如XML文档。例如：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: String Concatenation
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串连接
- en: When you want to combine multiple strings, you can concatenate them in a variety
    of ways. First, there’s the traditional `Concat` method on the `System.String`
    class. This method is exactly what you’d expect from other .NET languages.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要将多个字符串组合在一起时，可以通过多种方式进行连接。首先，`System.String`类中的传统`Concat`方法是其中的一种。这个方法和你在其他.NET语言中所期望的完全一致。
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Warning
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: '*Be careful when using String.Concat to not accidentally use the concat extension
    method defined in FSharp.Core. The concat extension method has more in common
    with the String.Join method than it does with String.Concat.*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*在使用String.Concat时要小心，避免不小心使用FSharp.Core中定义的concat扩展方法。这个concat扩展方法与String.Join方法更为相似，而非String.Concat。*'
- en: 'You can also use the operators `+` and `^` to make the code a bit cleaner.
    For example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`+`和`^`运算符来使代码看起来更简洁。例如：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `+` operator is preferred, particularly in cross-language scenarios, because
    it’s defined on `System.String`. The `^` operator is provided for ML compatibility,
    and the compiler will issue a warning if you use it in your code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`运算符更受青睐，特别是在跨语言场景中，因为它是在`System.String`上定义的。`^`运算符是为了兼容ML而提供的，如果你在代码中使用它，编译器会发出警告。'
- en: Type Inference
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型推导
- en: 'I’ve been very careful not to explicitly state any data types in examples so
    far in order to illustrate one of F#’s most interesting features: type inference.
    *Type inference* means that the compiler can often deduce data types based on
    individual values and usage. In fact, F#’s type inference capabilities are so
    powerful that they often give newcomers to F# the impression that the language
    is dynamically typed when it’s actually statically typed.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我小心翼翼地避免在示例中明确声明任何数据类型，以便展示F#最有趣的特点之一：类型推导。*类型推导*意味着编译器通常能够根据单个值和使用情况推断出数据类型。事实上，F#的类型推导能力如此强大，以至于它常常给F#的新手一种语言是动态类型的错觉，尽管它实际上是静态类型的。
- en: F# certainly isn’t the first .NET language to include type inference. C# supports
    type inference through the `var` keyword, as does Visual Basic when `Option Infer`
    is enabled. However, while the type inference in C# and Visual Basic helps avoid
    some explicit type declarations, it works only in very limited situations. Furthermore,
    while both C# and Visual Basic can infer data types for individual values, they
    still generally require you to explicitly specify types in multiple places. In
    contrast, F#’s top-down evaluation takes type inference to levels never before
    seen in .NET.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: F#当然不是第一个支持类型推导的.NET语言。C#通过`var`关键字支持类型推导，Visual Basic也支持，当`Option Infer`启用时同样如此。然而，尽管C#和Visual
    Basic中的类型推导有助于避免一些显式的类型声明，但它们仅在非常有限的情况下有效。而且，尽管C#和Visual Basic能够推导出单个值的数据类型，但它们仍然通常要求你在多个地方显式指定类型。相比之下，F#的自顶向下的求值方式将类型推导提升到.NET中前所未见的水平。
- en: F#’s type inference capabilities permeate the entire language. You’ve seen examples
    of type inference previously, ranging from simple values to function parameters
    and return types, but this feature even enters into F#’s object-oriented features.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: F#的类型推导能力贯穿整个语言。你之前见过类型推导的例子，从简单的值到函数参数和返回类型，但这个特性甚至渗透到F#的面向对象特性中。
- en: At the risk of jumping too far ahead, let’s examine how much F#’s type inference
    helps with a simple class definition, beginning with an example in C#.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有点提前讲得太多了，我们来看看F#的类型推导在简单类定义中的帮助，先从C#的一个示例开始。
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Even in this simple example, C# requires no fewer than six explicit type declarations.
    If you wanted to take it a step further and define `readonly` backing variables
    rather than using auto-implemented properties with private setters, you’d take
    the number of type declarations up to nine!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 即便是在这个简单的示例中，C#也需要不少于六个显式的类型声明。如果你想进一步将其扩展，定义`readonly`备份变量，而不是使用带有私有setter的自动实现属性，那么类型声明的数量将增加到九个！
- en: Now let’s look at an equivalent class in F#.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个F#中的等效类。
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Yes, those two definitions are indeed the same class! Not convinced? [Figure 3-1](ch03.html#comparison_of_compiled_fhash_and_chash_c
    "Figure 3-1. Comparison of compiled F# and C# classes") shows how each class looks
    in the compiled assemblies according to the decompiler, ILSpy.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，那两个定义确实是相同的类！不相信？[图 3-1](ch03.html#comparison_of_compiled_fhash_and_chash_c
    "图 3-1. F# 和 C# 编译后的类比较") 显示了根据反编译工具 ILSpy 查看每个类在编译后的程序集中的样子。
- en: '![Comparison of compiled F# and C# classes](httpatomoreillycomsourcenostarchimages1981218.png.jpg)Figure 3-1. Comparison
    of compiled F# and C# classes'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![F# 和 C# 编译后的类比较](httpatomoreillycomsourcenostarchimages1981218.png.jpg)图
    3-1. F# 和 C# 编译后的类比较'
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*There is a subtle difference between the two classes that isn’t pictured.
    The C# class sets the property values via the private setters, whereas the F#
    class foregoes the private setters and relies exclusively on the backing variables.*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*这两个类之间有一个微妙的差别没有在图中展示。C# 类通过私有设置器设置属性值，而 F# 类则放弃了私有设置器，完全依赖于后备变量。*'
- en: As you can see in the decompiled code, the classes are virtually identical.
    Ignoring the other syntactic differences between the two languages (object-oriented
    programming is covered in [Chapter 4](ch04.html "Chapter 4. Staying Objective")),
    you can see F#’s type inference in action throughout this example. In F# we needed
    to specify the data types for each member only once in the constructor, and in
    many cases the compiler can infer it there, too. Even each property’s data type
    is automatically inferred from that one definition!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在反编译的代码中看到的，两个类几乎是一样的。忽略两种语言之间的其他语法差异（面向对象编程在[第 4 章](ch04.html "第 4 章. 保持客观")有介绍），你可以看到
    F# 的类型推断在整个示例中的实际应用。在 F# 中，我们只需要在构造函数中为每个成员指定数据类型，并且在许多情况下编译器也能在此推断出类型。即使是每个属性的数据类型，也从这个定义中自动推断出来！
- en: 'In cases where the compiler can’t infer the type, you can add a *type annotation*
    to tell it what the type should be. You can use type annotations anywhere you
    introduce a new value. For example, you can include a type annotation in a `let`
    binding like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译器无法推断类型的情况下，你可以添加 *类型注解* 来告诉它应该使用什么类型。你可以在引入新值的任何地方使用类型注解。例如，你可以在 `let` 绑定中这样添加类型注解：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can also annotate each part of a function definition. A function that adds
    two integers might be annotated like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为函数定义的每个部分添加注解。一个加法函数，可能会这样注解：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, no type inference is performed because the definitions explicitly
    specify the type.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，没有进行类型推断，因为定义明确指定了类型。
- en: Nullability
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空值性
- en: 'If project structure differences and immutability aren’t enough to make your
    head spin, F# has yet another trick for you: `null` is almost never used! You
    can’t create null values directly with F# without resorting to a library function,
    and types defined in F# allow `null` as a valid value only if they’re decorated
    with the `AllowNullLiteral` attribute. If not for the need to interoperate with
    .NET assemblies written in languages that lack the same restrictions, `null` probably
    wouldn’t be included in the language at all.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目结构的差异和不可变性还不足以让你头晕，F# 还有另一个技巧：`null` 几乎从不使用！在 F# 中，你不能直接创建 null 值，除非使用库函数，且在
    F# 中定义的类型只有在使用 `AllowNullLiteral` 特性装饰时，`null` 才能作为有效值。如果不是为了与使用没有相同限制的语言编写的 .NET
    程序集进行互操作，`null` 可能根本不会包含在语言中。
- en: By placing such tight restrictions around nulls, the F# language designers have
    greatly reduced the possibility of encountering stray null references, particularly
    when you’re working entirely within F#. This means that you get to spend less
    time checking to see if every reference type instance is `null` before doing anything
    with it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对 null 添加如此严格的限制，F# 语言设计者大大减少了遇到孤立的 null 引用的可能性，特别是当你完全在 F# 中工作时。这意味着你花在检查每个引用类型实例是否为
    `null` 上的时间会更少，再去处理它之前。
- en: That said, `null` is still a valid keyword in F#, and you will find that you
    do need to use it from time to time, particularly as you work with assemblies
    written in other .NET languages. Usually, you’ll pass `null` as a parameter to
    a library function or verify that the return value of a library function isn’t
    `null`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`null` 仍然是 F# 中的一个有效关键字，你会发现确实有时需要使用它，特别是在与其他 .NET 语言编写的程序集交互时。通常，你会将 `null`
    作为参数传递给库函数，或者验证库函数的返回值是否为 `null`。
- en: Options
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项
- en: Although F# strives to eradicate nulls from your software, there are times when
    something legitimately doesn’t have a value. Without nulls this could seem like
    a problem, but the language has you covered.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然F#努力消除软件中的空值，但在某些情况下，某些东西确实没有值。没有空值可能会让这看起来像个问题，但语言已经为你考虑到了这一点。
- en: 'Rather than simply allowing `null` to be valid for every reference type, F#
    takes an opt-in approach via the `Option<''T>` type. This type is a generic *discriminated
    union* with two values: `Some(''T)` and `None`. In some ways options are like
    nullable types, but their explicit nature makes it obvious that a meaningful value
    might not be present. (We’ll cover discriminated unions in [Chapter 5](ch05.html
    "Chapter 5. Let’s Get Functional"). Generics are covered later in this chapter.)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: F#并不是简单地允许`null`对每个引用类型都有效，而是通过`Option<'T>`类型采取了选择加入的方式。这个类型是一个泛型*判别联合*，包含两个值：`Some('T)`和`None`。从某种程度上来说，选项就像可空类型，但它们的显式特性使得缺少有意义的值变得显而易见。（我们将在[第5章](ch05.html
    "第5章：让我们来搞函数式编程")中讲解判别联合，泛型将在本章稍后介绍。）
- en: 'Options are so important in F# that they have syntactic support in type annotations
    through the `option` keyword, as shown here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 选项在F#中非常重要，以至于它们在类型注解中通过`option`关键字得到了语法支持，如下所示：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Options are also how the compiler represents optional parameters for constructors
    or methods. You make a parameter optional by prefixing it with a question mark
    (`?`). Optional parameters are allowed only at the end of the parameter list,
    as shown here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 选项也是编译器表示构造函数或方法的可选参数的方式。通过在参数前加上问号（`?`），可以使一个参数变为可选的。可选参数只能放在参数列表的末尾，如下所示：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding example, ① is the optional `stopAtPercent` parameter. The function
    needs to account for the cases when `stopAtPercent` is `None`. One common way
    to provide a default value in these cases is with the `defaultArg` function ②.
    This function is kind of like C#’s null coalescing operator (`??`) except that
    it works with options instead of nulls. The `defaultArg` function accepts an option
    as its first argument and returns its value when it is `Some<_>`; otherwise, it
    returns the second argument.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，①是可选的`stopAtPercent`参数。函数需要处理`stopAtPercent`为`None`的情况。一个常见的提供默认值的方式是使用`defaultArg`函数②。这个函数有点像C#中的空合并运算符（`??`），只不过它是与选项一起使用，而不是与空值一起使用。`defaultArg`函数接受一个选项作为第一个参数，并在它是`Some<_>`时返回它的值；否则，返回第二个参数。
- en: Unit Type
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单位类型
- en: Expressions must always evaluate to a value, but sometimes they’re evaluated
    solely for a side effect, such as writing to a log or updating a database. In
    these cases, turn to the `unit` type. The `unit` type, represented by `()` (an
    empty pair of parentheses), is a concrete type with a single value that signifies
    that no particular value is present, so the result of any expression that returns
    `unit` can safely be ignored. (In some ways, `unit` is like a manifestation of
    the `void` return type in C# in that it should be returned whenever a function
    doesn’t really return anything, but it’s also used syntactically to signify parameterless
    functions.)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式必须始终求值为一个值，但有时它们只是为了副作用而求值，例如写入日志或更新数据库。在这些情况下，可以使用`unit`类型。`unit`类型由`()`（一对空括号）表示，是一个具体类型，具有单一值，表示没有特定的值存在，因此任何返回`unit`的表达式的结果可以安全地忽略。（在某些方面，`unit`类似于C#中的`void`返回类型，它应该在一个函数没有实际返回值时返回，但它在语法上也用于表示无参数函数。）
- en: 'Whenever an expression returns a value other than `unit`, F# expects you to
    do something with it. The compiler doesn’t care whether you bind the value to
    an identifier or pass it as an argument to a function; it just wants you to use
    it. When you don’t do something with the return value, the compiler warns that
    the expression should have type `unit` because it may actually indicate a program
    error (the warning is displayed only in compiled code and doesn’t appear in FSI).
    For example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个表达式返回除`unit`之外的值时，F#要求你对它做点什么。编译器并不关心你是将值绑定到标识符，还是将它作为参数传递给函数；它只希望你使用它。当你没有对返回值做任何操作时，编译器会警告该表达式应该具有`unit`类型，因为它可能实际上表示一个程序错误（这个警告只会在编译后的代码中显示，FSI中不会出现）。例如：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you don’t want to do anything with the return value, you can pass the result
    to the `ignore` function, which accepts a single, unconstrained generic argument
    and returns `unit`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想对返回值做任何操作，可以将结果传递给`ignore`函数，它接受一个单一的、不受约束的泛型参数，并返回`unit`。
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, the `add` function’s result is sent to the `ignore` function
    via the *forward pipelining operator* (`|>`). This operator evaluates the expression
    on the left and sends the result as the last argument to the expression on the
    right. We’ll look at the forward pipelining operator in detail in [Pipelining](ch05.html#pipelining
    "Pipelining").
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`add` 函数的结果通过 *前向管道操作符* (`|>`) 发送到 `ignore` 函数。该操作符会评估左侧的表达式，并将结果作为最后一个参数传递给右侧的表达式。我们将在
    [管道](ch05.html#pipelining "Pipelining") 中详细介绍前向管道操作符。
- en: Enumerations
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: '*Enumerations* help you write more readable code by letting you assign descriptive
    labels to integral values. F# enumerations compile to the same CLI type as in
    other .NET languages, so all of the capabilities and restrictions that apply in
    C# or Visual Basic apply in F# too.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*枚举* 通过让你为整数值分配描述性标签，帮助你编写更具可读性的代码。F# 枚举与其他 .NET 语言编译成相同的 CLI 类型，因此 C# 或 Visual
    Basic 中适用的所有功能和限制在 F# 中也适用。'
- en: 'The basic syntax of an enumeration in F# is:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中枚举的基本语法是：
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, unlike in C# and Visual Basic, F# doesn’t automatically generate a
    value for each label in an enumeration, so you need to explicitly provide one.
    For example, if your program represents each day of the week as an integer, you
    might define a `DayOfWeek` enumeration like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与 C# 和 Visual Basic 不同，F# 不会自动为每个标签生成一个枚举值，因此你需要显式地提供一个。例如，如果你的程序将每一天表示为一个整数，你可能会像这样定义一个
    `DayOfWeek` 枚举：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Should you want to base your enumerations on an integral type other than `int`,
    simply include the appropriate suffix for the data type in the label definition.
    For example, you could easily change the preceding `DayOfWeek` sample to use `sbyte`
    as its underlying type by changing the suffix on each value:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望基于 `int` 以外的整数类型来定义枚举，只需在标签定义中包含适当的后缀。例如，你可以通过改变每个值的后缀，将之前的 `DayOfWeek`
    示例轻松改为使用 `sbyte` 作为其基础类型：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Flags Enumerations
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标志枚举
- en: The enumerations we’ve seen so far represent only single values. However, it’s
    common for each label to represent a value by position in a bit mask so that multiple
    items can be combined.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的枚举仅表示单一值。然而，通常每个标签会通过位掩码中的位置表示一个值，这样可以将多个项组合在一起。
- en: 'For example, consider the case of the `RegexOptions` enumeration from the `System.Text.RegularExpressions`
    namespace. This enumeration allows you to control how the regular expression engine
    processes the pattern by combining multiple values with the logical `or` operator,
    like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑 `System.Text.RegularExpressions` 命名空间中的 `RegexOptions` 枚举。该枚举允许你通过使用逻辑
    `or` 运算符将多个值组合在一起，从而控制正则表达式引擎如何处理模式，例如：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To achieve this same result in your own enumerations, include the `Flags` attribute
    and use values that are powers of two.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在你自己的枚举中实现相同的结果，添加 `Flags` 特性并使用 2 的幂值。
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The Flags attribute isn’t required, but it’s good practice to include it to
    show other developers how the enumeration should be used.*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*Flags 特性不是必需的，但建议包含它，以便向其他开发者展示该枚举应如何使用。*'
- en: You can now represent the days in a weekend by combining the Saturday and Sunday
    values as we did previously.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过将星期六和星期天的值组合在一起来表示周末，就像我们之前做的那样。
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you know that several values will be commonly combined, consider including
    those combinations in your enumeration definition. F# doesn’t allow referencing
    the other values in the definition by name, but you can still provide the appropriate
    corresponding integral value. In the case of `DayOfWeek` you could provide `Weekdays`
    and `WeekendDays` with the values `62` and `65`, respectively.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道多个值将会经常组合，考虑将这些组合包含在你的枚举定义中。F# 不允许在定义中按名称引用其他值，但你仍然可以提供相应的整数值。例如，在 `DayOfWeek`
    中，你可以提供 `Weekdays` 和 `WeekendDays`，其值分别为 `62` 和 `65`。
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It’s easy to determine whether a particular enumeration value has a particular
    flag set with the `HasFlag` method of `System.Enum`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `System.Enum` 的 `HasFlag` 方法，可以轻松确定某个特定枚举值是否设置了特定标志。
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Reconstructing Enumeration Values
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重建枚举值
- en: Using named labels for integral values is a great way to avoid *magic numbers*
    (numbers without any apparent meaning) in your code, but what if you save off
    the underlying value (say, to a database) and later want to reconstruct the original
    enumeration value from it? The built-in `enum` function allows you to do just
    that for integer (`int32`) values.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名标签来表示整数值是避免代码中出现*魔法数字*（没有明显含义的数字）的一种好方法，但如果你将底层值（比如保存到数据库）存储起来，稍后又想从中重建原始的枚举值该怎么办呢？内置的`enum`函数可以让你对整数（`int32`）值做到这一点。
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When the enumeration’s underlying type is something other than `int32`, use
    the `EnumOfValue` function from the `Microsoft.FSharp.Core.LanguagePrimitives`
    module namespace instead.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当枚举的底层类型不是`int32`时，请改用`Microsoft.FSharp.Core.LanguagePrimitives`模块命名空间中的`EnumOfValue`函数。
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Enumeration types aren’t constrained to the values identified by labels, so
    when using these functions be sure to create only enumeration values that you’ve
    accounted for in your code.*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*枚举类型不限于标签所标识的值，因此在使用这些函数时，请确保只创建你在代码中已经考虑过的枚举值。*'
- en: Flow Control
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流程控制
- en: Despite its emphasis on functional programming, F# fully supports several imperative
    constructs for looping and branching. These are particularly useful in combination
    with other constructs like *sequence expressions* (particularly the looping constructs),
    but they’re certainly useful in other contexts as well.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管F#强调函数式编程，但它完全支持多种命令式结构用于循环和分支。这些结构与其他构造如*序列表达式*（尤其是循环结构）结合使用时尤其有用，但在其他上下文中也同样有用。
- en: Looping
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环
- en: '*Recursion* is the preferred looping mechanism in functional programming, but
    F# also includes a few approaches typically found in imperative languages. These
    looping structures are similar to those of other languages.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归*是函数式编程中首选的循环机制，但F#也包括一些典型的命令式语言中的循环方法。这些循环结构与其他语言中的类似。'
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*F# doesn’t provide mechanisms (like break or continue) for premature termination,
    so take extra care when using loops.*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*F#没有提供（如break或continue之类的）机制来提前终止循环，因此在使用循环时要特别小心。*'
- en: while Loops
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: while 循环
- en: The simplest iterative structure is the `while...do` loop. As you might expect,
    this construct evaluates a Boolean expression and iterates as long as that condition
    is true. `while` loops are useful when you need to iterate an unknown number of
    times, but because they inherently rely on a state change, they can’t be used
    in pure functional programming. The body of the loop can be any expression that
    returns `unit`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的迭代结构是`while...do`循环。顾名思义，这种结构会评估一个布尔表达式，并在该条件为真时进行迭代。`while`循环适用于需要迭代一个不确定次数的情况，但由于它们本质上依赖于状态变化，因此无法用于纯函数式编程。循环体可以是任何返回`unit`的表达式。
- en: One scenario in which `while` loops are helpful is responding to user input.
    In the following example, the `echoUserInput` function uses a `while` loop to
    echo whatever the user enters at the console until it encounters the word `quit`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环有助于响应用户输入。在下面的示例中，`echoUserInput`函数使用`while`循环回显用户在控制台输入的内容，直到遇到单词`quit`为止。'
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: for Loops
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: for 循环
- en: 'When you know how many iterations you need to perform, you can turn to one
    of the `for` loop variations: simple or enumerable. *Simple* `for` loops are pretty
    restrictive in that they can iterate only over a range of integers and always
    return `unit`. Attempting to return something other than `unit` will result in
    a compilation error.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道需要进行多少次迭代时，可以使用其中一种`for`循环变体：简单的或可枚举的。*简单*的`for`循环非常有限，只能迭代整数范围，并始终返回`unit`。尝试返回其他内容将导致编译错误。
- en: 'Simple `for` loops are useful when you know how many times you need to iterate.
    Here, the numbers 0 through 100 are printed in the body of a simple `for` loop:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的`for`循环在你知道需要迭代多少次时非常有用。以下是一个简单`for`循环的例子，打印数字0到100：
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: By replacing the `to` keyword with the `downto` keyword, you can make a simple
    `for` loop count down instead.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`to`关键字替换为`downto`关键字，你可以使一个简单的`for`循环进行倒计时。
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The more powerful variation of the `for` loop is the *enumerable* `for` loop.
    In some ways, the enumerable `for` loop is similar to C#’s `foreach` loop in that
    it operates over any sequence (collection types implementing `IEnumerable<''T>`).
    For instance, the enumerable `for` loop makes it easy to iterate over a range
    of integers, like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的更强大变种是*枚举型*`for`循环。在某些方面，枚举型`for`循环类似于C#的`foreach`循环，因为它作用于任何序列（实现了`IEnumerable<''T>`的集合类型）。例如，枚举型`for`循环使得遍历整数范围变得容易，如下所示：'
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In reality, though, the enumerable `for` loop is a fancy syntactic shortcut
    for applying F#’s powerful pattern-matching capabilities over a sequence. With
    pattern matching, you can extract values from more complex types and even perform
    some rudimentary filtering right in the loop definition! No LINQ required!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际上，枚举型的`for`循环是一个方便的语法快捷方式，它在序列上应用了F#强大的模式匹配能力。通过模式匹配，你可以从更复杂的类型中提取值，甚至在循环定义中执行一些基本的过滤！无需LINQ！
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: At ① we see a discriminated union representing the rating scale, at ② a record
    type representing a movie with an optional rating, at ③ an F# list, and finally
    at ④ the `for...in` loop with a pattern match to find all movies that have been
    rated. The compiler will highlight the pattern match and warn you about not having
    a covering case, but that’s okay because we’re using it as a filter.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在①处，我们看到一个表示评分尺度的区分联合，在②处看到一个表示电影并带有可选评分的记录类型，在③处看到一个F#列表，最后在④处看到一个`for...in`循环，结合模式匹配来查找所有已经评分的电影。编译器会高亮显示模式匹配并警告你没有覆盖所有情况，但这没关系，因为我们把它当作一个过滤器。
- en: Note
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Don’t worry about all this discussion of pattern matching, discriminated unions,
    record types, and other functional concepts yet. We’ll explore each in detail
    in [Chapter 5](ch05.html "Chapter 5. Let’s Get Functional") and [Chapter 7](ch07.html
    "Chapter 7. Patterns, Patterns, Everywhere").*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*别担心现在讨论的模式匹配、区分联合、记录类型以及其他函数式概念。我们将在[第5章](ch05.html "第5章。让我们走向函数式编程")和[第7章](ch07.html
    "第7章。模式，模式，无处不在")中详细探讨每一个概念。*'
- en: Branching
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分支
- en: 'F# offers only a single imperative construct for branching: the `if...then...else`
    expression, as shown next. This expression evaluates a Boolean expression in the
    `if` part. When that expression evaluates to `true`, the `then` branch is executed;
    otherwise, the `else` branch is executed (if one is present).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: F#仅提供一种命令式的分支构造：`if...then...else`表达式，如下所示。此表达式在`if`部分求值一个布尔表达式。当该表达式求值为`true`时，执行`then`分支；否则，执行`else`分支（如果有的话）。
- en: '[PRE53]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can chain multiple `if...then...else` expressions together with the `elif`
    keyword (a shortcut for `else if`), as shown next. This has the same effect as
    nesting them, though the result is much more readable.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`elif`关键字（`else if`的快捷方式）将多个`if...then...else`表达式连接起来，如下所示。这与将它们嵌套在一起的效果相同，不过结果更加可读。
- en: '[PRE54]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Because the `if...then...else` expression returns a value, constructs like C#’s
    conditional operator (`?:`) aren’t necessary. You should know, though, that because
    the expression returns a value it behaves a bit differently depending on how it’s
    being used. When only the `if` branch is specified, its expression must evaluate
    to `unit`, but when both the `if` and `else` branches are specified, their expressions
    must both evaluate to the same type.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`if...then...else`表达式返回一个值，所以像C#中的条件操作符（`?:`）这样的构造不再需要。需要注意的是，由于表达式返回一个值，具体的行为会根据其使用方式有所不同。当只指定`if`分支时，其表达式必须求值为`unit`，但当同时指定`if`和`else`分支时，它们的表达式必须都求值为相同类型。
- en: In each example so far, the result of the `if...then...else` expression has
    been `unit`, but what happens if you change the function to use `sprintf` instead
    of `printfn` like this?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在每个例子中，`if...then...else`表达式的结果都是`unit`，但如果将函数改为使用`sprintf`而不是`printfn`，会发生什么呢？
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Instead of printing the message to the console, the `isEven` function actually
    returns the message as a string. You can see this by invoking the function in
    FSI like so:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`isEven`函数实际上将消息作为字符串返回，而不是打印到控制台。你可以通过在FSI中调用该函数来验证这一点，如下所示：'
- en: '[PRE56]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Generics
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型
- en: Don Syme, the designer and architect of F#, was heavily involved in the research
    and development of what eventually became generics in the .NET Framework. With
    a heritage like that, it’s no surprise that generics in F# are incredibly robust,
    in some ways even more powerful than in other .NET languages.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Don Syme，F#的设计者和架构师，深度参与了最终成为.NET框架中泛型的研究和开发。拥有这样的背景，F#中的泛型异常强大，某些方面甚至比其他.NET语言中的泛型更为强大，毫不奇怪。
- en: Generics allow you to define functions, classes, methods, interfaces, and structures
    that can work directly with any data type. Without generics, the only way to write
    type-safe code that works with multiple data types is to write a separate implementation
    for each type. However, this approach is limiting, because any new type that relies
    on that code will need its own implementation. Generics abstract away this complexity
    by generating these implementations for you based on the type parameters you’ve
    supplied in your code.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型允许你定义可以直接与任何数据类型一起工作的函数、类、方法、接口和结构。没有泛型时，唯一编写与多种数据类型兼容的类型安全代码的方式是为每个类型编写单独的实现。然而，这种方法是有限制的，因为任何依赖于该代码的新类型都需要自己的实现。泛型通过根据你在代码中提供的类型参数自动为你生成这些实现，从而抽象化了这种复杂性。
- en: To show how useful generics really are, consider how one of the original .NET
    collection types, the `ArrayList`, compares to its cousin, the generic list. The
    `ArrayList` class is a collection type that has been around since the earliest
    days of .NET and well before generics were available in the framework. In order
    for it to hold data of any type, it needed to treat every element as `System.Object`.
    As a result, code written with `ArrayList` almost always involved excessive type
    conversions of elements in the list. Worse, there was no way to enforce consistency
    between elements, so although a developer might believe that every element in
    the list was a string, it could very well also contain integers, floats, or instances
    of any other data type. This type of code was highly error prone and often had
    a negative impact on performance.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示泛型的真正用处，考虑一下原始 .NET 集合类型之一，`ArrayList`，与其“亲戚”泛型列表的对比。`ArrayList` 类是一种从 .NET
    初期就存在的集合类型，在泛型被引入框架之前就已经使用了。为了能够存储任何类型的数据，它必须将每个元素视为 `System.Object`。因此，使用 `ArrayList`
    编写的代码几乎总是涉及过多的类型转换，尤其是列表中的元素。更糟糕的是，`ArrayList` 没有办法强制元素之间保持一致性，因此，尽管开发人员可能认为列表中的每个元素都是字符串，但它也可能包含整数、浮动点数或其他任何数据类型的实例。这种类型的代码非常容易出错，并且往往对性能产生负面影响。
- en: The generic `List<'T>` class, on the other hand, can be instantiated to work
    with any specific data type. It removes all ambiguity about what its elements
    are and typically eliminates the type conversions (subclassing notwithstanding),
    which leads to more reliable and efficient code.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，泛型 `List<'T>` 类可以实例化为处理任何特定数据类型。它消除了关于元素类型的所有歧义，并通常避免了类型转换（即使有子类化的情况），从而导致更可靠和高效的代码。
- en: Since their beginning, generics have played a starring role in virtually every
    innovation in .NET development, including LINQ and the Task Parallel Library.
    In some ways, they play an even greater part in F# development than in traditional
    .NET development because of their role in the type inference process and concepts
    like statically resolved type parameters (discussed in [Statically Resolved Type
    Parameters](ch03.html#statically_resolved_type_parameters "Statically Resolved
    Type Parameters")).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 自泛型引入以来，几乎每个 .NET 开发中的创新都离不开它们的身影，包括 LINQ 和任务并行库（Task Parallel Library）。在某些方面，泛型在
    F# 开发中的作用甚至比在传统 .NET 开发中更为重要，因为它们在类型推断过程中的角色以及像静态解析类型参数这样的概念（在[静态解析类型参数](ch03.html#statically_resolved_type_parameters
    "静态解析类型参数")中有讨论）。
- en: In F#, most generic type parameters are named with a leading apostrophe. For
    example, `'a`, `'A`, and `'TInput` are all valid type parameter names. By convention,
    F# uses sequential lowercase identifiers for inferred type parameters, whereas
    user-defined type parameters begin with an uppercase character.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，大多数泛型类型参数都以撇号开头。例如，`'a`、`'A` 和 `'TInput` 都是有效的类型参数名称。根据约定，F# 使用小写顺序标识符表示推断的类型参数，而用户定义的类型参数则以大写字母开头。
- en: Automatic Generalization
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动泛化
- en: 'F#’s type inference feature favors generic types whenever possible through
    a process called *automatic generalization*. Here it is in action:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: F# 的类型推断特性在可能的情况下优先使用泛型类型，采用一种被称为*自动泛化*的过程。以下是其应用示例：
- en: '[PRE57]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this example the `toTriple` function converts its three parameters into a
    three-item tuple (sometimes called a triple). We’ll explore the arrows and tuples
    in detail in [Chapter 5](ch05.html "Chapter 5. Let’s Get Functional"); for now
    just recognize that the compiler automatically generalized each of the three parameters
    to the types `'a`, `'b`, and `'c`, respectively.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`toTriple`函数将它的三个参数转换为一个包含三项的元组（有时称为三元组）。我们将在[第5章](ch05.html "第5章。让我们开始函数式编程")中详细探讨箭头和元组；现在只需知道，编译器自动将这三个参数分别泛化为类型`'a`、`'b`和`'c`。
- en: Whether the compiler can automatically generalize a parameter depends largely
    on how and where it’s used. Automatic generalization is attempted only with immutable
    values on complete function definitions with explicit parameters.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器是否能够自动泛化一个参数，主要取决于该参数的使用方式和位置。只有在具有显式参数的完整函数定义中，对不可变值进行自动泛化时，编译器才会尝试进行泛化。
- en: Explicit Generalization
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式泛化
- en: 'If the compiler can’t automatically generalize a parameter, or you want more
    control over it, you can explicitly generalize a parameter with a type annotation.
    This is especially useful when you want to constrain the types allowed. You could
    rewrite the previous `toTriple` example with explicit type parameters as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器不能自动泛化一个参数，或者你想对其进行更多控制，可以通过类型注解显式地泛化一个参数。当你想要约束允许的类型时，这尤其有用。你可以像下面这样，用显式的类型参数重写之前的`toTriple`示例：
- en: '[PRE58]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: When type parameters are unconstrained, you’re fairly limited in what you can
    do with them. Generally, you can use them only with other unconstrained generic
    types or functions, and good luck invoking any methods beyond those defined on
    `System.Object`. To do something that depends on some aspect of the type, such
    as calling an interface method, you’ll need to add a *constraint*.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型参数没有约束时，你在使用它们时会受到很大限制。通常，你只能将它们与其他没有约束的泛型类型或函数一起使用，此外几乎无法调用超出`System.Object`上定义的方法。如果你需要依赖于类型的某个方面进行操作，比如调用接口方法，你将需要添加一个*约束*。
- en: If you’re familiar with generic constraints in C# or Visual Basic, you may have
    been frustrated by the lack of things you can actually constrain. In those languages
    you can constrain type parameters only to reference types, value types, types
    with a default constructor, types that derive from a particular class, and types
    that derive from a particular interface. F# supports each of these but also adds
    a few other constraints.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉C#或Visual Basic中的泛型约束，可能会对你实际上能够约束的内容感到沮丧。在这些语言中，你只能将类型参数约束为引用类型、值类型、具有默认构造函数的类型、继承自特定类的类型以及实现特定接口的类型。而F#不仅支持这些，还增加了一些其他约束。
- en: Note
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Most constraint types apply to standard type parameters, but a few apply only
    to an F#-specific form of type parameters called* statically resolved type parameters.
    *In the following examples, you’ll see these constraints defined in inline functions
    with a type parameter that uses a caret (^) instead of an apostrophe. Statically
    resolved type parameters are described later in this section.*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*大多数约束类型适用于标准类型参数，但有一些仅适用于F#特定形式的类型参数，称为* 静态解析类型参数。*在以下示例中，你将看到这些约束在使用插入符号（^）而不是撇号的类型参数的内联函数中定义。静态解析类型参数将在本节后面描述。*'
- en: You apply constraints by following the generic type annotation with `when` and
    the constraint. You can specify multiple constraints by combining them with `and`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过在泛型类型注解后跟`when`和约束来应用约束。你可以通过使用`and`将多个约束结合起来。
- en: '****Subtype constraints****. A subtype constraint limits the acceptable types
    to the constraint type itself or any type that derives from that type. When the
    constraint type is an interface, the provided type needs to implement that interface.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****子类型约束****。子类型约束将可接受的类型限制为约束类型本身或从该类型派生的任何类型。当约束类型是接口时，提供的类型需要实现该接口。'
- en: '[PRE59]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**Nullness constraints** A nullness constraint limits the acceptable types
    to those where `null` is a valid value.'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**空值约束** 空值约束将可接受的类型限制为那些`null`是有效值的类型。'
- en: '[PRE60]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '****Member constraints****. A member constraint ensures that the supplied type
    includes a member with a specific signature. You can constrain the types based
    on either instance or static members.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****成员约束****。成员约束确保提供的类型包含一个具有特定签名的成员。你可以根据实例成员或静态成员来约束类型。'
- en: '[PRE61]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '****Default constructor constraints****. A default constructor constraint ensures
    that the supplied type has a default constructor.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****默认构造函数约束****。默认构造函数约束确保提供的类型具有默认构造函数。'
- en: '[PRE62]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '****Value type constraints****. A value type constraint restricts the supplied
    type to any .NET value types except `System.Nullable<_>`.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****值类型约束****。值类型约束将提供的类型限制为任何.NET值类型，除了`System.Nullable<_>`。'
- en: '[PRE63]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '****Reference type constraints****. A reference type constraint ensures that
    the supplied type is a .NET reference type.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****引用类型约束****。引用类型约束确保提供的类型是.NET引用类型。'
- en: '[PRE64]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '****Enumeration constraints****. An enumeration constraint limits the supplied
    types to enumerations with a specific underlying type.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****枚举约束****。枚举约束将提供的类型限制为具有特定基础类型的枚举类型。'
- en: '[PRE65]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '****Delegate constraints****. A delegate constraint restricts the provided
    types to delegate types with a particular set of arguments and return type. Delegate
    constraints are intended primarily for use with traditional .NET event handlers.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****委托约束****。委托约束将提供的类型限制为具有特定参数集和返回类型的委托类型。委托约束主要用于传统的.NET事件处理程序。'
- en: '[PRE66]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '****Unmanaged constraints****. Unmanaged constraints restrict the provided
    type to unmanaged types like some of the numeric primitives and enumeration types.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****非托管约束****。非托管约束将提供的类型限制为非托管类型，如某些数值原始类型和枚举类型。'
- en: '[PRE67]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '****Equality constraints****. An equality constraint restricts the provided
    type to types that support equality. This constraint is considered weak because
    it’s satisfied by nearly every CLI type.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****相等性约束****。相等性约束将提供的类型限制为支持相等性的类型。此约束被认为是弱约束，因为几乎所有CLI类型都满足此约束。'
- en: '[PRE68]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '****Comparison constraints****. Comparison constraints are satisfied only by
    types that implement `System.IComparable`, arrays, `nativeint`, and `unativeint`
    unless the type has the `NoEquality` attribute.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****比较约束****。比较约束仅由实现了`System.IComparable`、数组、`nativeint`和`unativeint`的类型满足，除非该类型具有`NoEquality`属性。'
- en: '[PRE69]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Flexible Types
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 灵活类型
- en: Although not strictly generic constructs, *flexible types* are a syntactic shortcut
    for subtype constraints. They’re particularly useful with the function arguments
    of a higher-order function where automatic type conversion normally doesn’t automatically
    occur.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管灵活类型并非严格的泛型结构，*灵活类型*实际上是子类型约束的语法简写。它们在高阶函数的函数参数中尤其有用，因为自动类型转换通常不会自动发生。
- en: You can specify a flexible type by prefixing a type name with a `#` character
    within a type annotation.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在类型注解中用`#`字符作为前缀来指定灵活类型。
- en: '[PRE70]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Wildcard Pattern
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通配符模式
- en: When you want to use a generic type as a parameter but want the compiler to
    infer the type, you can use the *Wildcard pattern* in place of a named type parameter.
    The Wildcard pattern is represented with an underscore.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想使用泛型类型作为参数，但希望编译器推断出类型时，可以使用*通配符模式*来代替命名的类型参数。通配符模式用下划线表示。
- en: '[PRE71]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The preceding function will print each element in an F# list with its `ToString`
    function regardless of what type is contained in the list.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数将打印F#列表中的每个元素，并使用其`ToString`函数，而不管列表中包含的是什么类型。
- en: Statically Resolved Type Parameters
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态解析的类型参数
- en: F# has two classifications of generics. The first (which we’ve focused on almost
    exclusively so far) is standard generics, the same generics as in other .NET languages.
    The second, called *statically resolved type parameters*, is specific to F# and
    identified by a caret (`^`) instead of an apostrophe. Statically resolved type
    parameters force the compiler to resolve the types at compile time rather than
    run time. The implication is that the compiler generates a version of the generic
    type for each resolved type rather than a single version.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: F#有两种泛型分类。第一种（我们到目前为止几乎专注于此）是标准泛型，与其他.NET语言中的泛型相同。第二种，称为*静态解析类型参数*，是F#特有的，并用插入符号（`^`）代替撇号来表示。静态解析类型参数强制编译器在编译时解析类型，而不是在运行时解析。这意味着编译器为每个解析出的类型生成泛型类型的一个版本，而不是生成单一版本。
- en: Statically resolved type parameters are primarily intended for use with inline
    functions and are especially well suited for custom operators, as shown here.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 静态解析类型参数主要用于内联函数，并且特别适用于自定义操作符，如此处所示。
- en: '[PRE72]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: When this operator is compiled, it uses static resolution with a constraint
    to ensure that any types that use it include the `Pow` function in their definition
    based on the use of the `**` operator.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当此操作符被编译时，它使用静态解析和约束来确保任何使用它的类型都包括`Pow`函数，基于`**`操作符的使用。
- en: '[PRE73]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: When Things Go Wrong
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 出现问题时
- en: Despite your best efforts and the extra safety that F# provides, things can
    and will go wrong. Proper error handling is a critical piece of any program. F#
    builds upon the standard .NET exception mechanisms with additional syntactic support
    that allows you to *throw* (or *raise* in F# parlance) and handle exceptions with
    ease. (For convenience, the standard exception type, `System.Exception`, is abbreviated
    as `exn`.)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你已尽最大努力，并且F#提供了额外的安全性，但事情还是可能出错。适当的错误处理是任何程序的关键组成部分。F#在标准的.NET异常机制基础上，提供了额外的语法支持，使你能够轻松地*抛出*（或在F#术语中称为*提升*）和处理异常。（为了方便，标准的异常类型`System.Exception`简写为`exn`。）
- en: Handling Exceptions
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理异常
- en: 'Error conditions are always a possibility, so it’s important to know how to
    handle them properly when they arise. F# provides two constructs for error handling:
    `try...with` and `try...finally`. These constructs are strictly independent of
    each other; that is, there is no `try...with...finally` construct in F#. If you
    need both a `with` and a `finally` block, you’ll generally nest a `try...with`
    block within a `try...finally` block, although the nesting order doesn’t really
    matter.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 错误条件始终是可能的，因此在它们出现时，正确处理它们是非常重要的。F#提供了两种错误处理结构：`try...with`和`try...finally`。这两种结构是完全独立的；也就是说，F#中没有`try...with...finally`结构。如果你需要同时使用`with`和`finally`块，通常会将`try...with`块嵌套在`try...finally`块内，尽管嵌套的顺序并不重要。
- en: try. . .with Expressions
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: try...with 表达式
- en: In a `try...with` construct, the expressions contained within the `try` block
    are evaluated and if any raise an exception, F# pattern matching is used to locate
    an appropriate handler in the `with` block.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在`try...with`结构中，`try`块中的表达式会被求值，如果其中有任何异常被抛出，则使用F#模式匹配来定位`with`块中合适的处理器。
- en: Input/output-related operations, like reading from a file, are great examples
    of where you’d use the exception-handling constructs because you’re at the mercy
    of external factors like network availability issues or file permissions. In this
    example, we attempt to read a text file and write its contents to the console
    but do so in a `try` block.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 输入/输出相关操作，如从文件中读取，是使用异常处理结构的典型示例，因为你受到外部因素的制约，比如网络可用性问题或文件权限问题。在这个例子中，我们尝试读取一个文本文件并将其内容写入控制台，但在`try`块中进行。
- en: '[PRE74]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If an exception is raised, execution passes to the `with` block, where the system
    attempts to find a handler first using ①, a *Type-Test pattern* (a pattern that
    matches a specific data type). In this case, the *Wildcard pattern* ② (a general-purpose
    pattern that matches everything) is used as a general exception handler. If a
    suitable match isn’t found, the exception bubbles up the call stack until a handler
    is found or the application fails.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出异常，执行将转到`with`块，系统首先尝试使用①，一个*类型测试模式*（匹配特定数据类型的模式）来查找处理程序。在这种情况下，使用*通配符模式*②（一个匹配所有内容的通用模式）作为一般异常处理程序。如果找不到合适的匹配，异常会在调用栈中冒泡，直到找到处理程序或应用程序失败。
- en: Without delving too much into the specifics of pattern matching, we can look
    at a few ways to unlock the potential of the `with` block. As it stands now, the
    handler for `FileNotFoundException` isn’t very helpful because it doesn’t give
    any information about which file wasn’t found. You can capture the exception for
    use in the handler by including an identifier with the `as` keyword in the pattern.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入探讨模式匹配的细节，我们可以看一下如何利用`with`块的潜力。现在，`FileNotFoundException`的处理程序并不十分有用，因为它没有提供关于哪个文件未找到的任何信息。你可以通过在模式中使用`as`关键字来包含标识符，从而捕获异常并在处理程序中使用它。
- en: '[PRE75]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now that the `ex` identifier is defined ①, you can include the filename in the
    printed message ②.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在定义了`ex`标识符①后，你可以在打印消息中包含文件名②。
- en: You can even combine cases when two or more exception types should use the same
    handler.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或多个异常类型应该使用相同的处理程序时，你甚至可以将这些情况结合起来。
- en: '[PRE76]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Sometimes you may want to partially handle an exception at one level but still
    allow it to traverse up the call stack to another handler. You could raise the
    exception normally with the `raise` function, but in doing so you’d lose the call
    stack information embedded in the exception and later handlers would recognize
    your handler as the source of the error. To preserve the stack trace, *reraise*
    the exception with a function that’s valid only within a `with` block: `reraise`.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能希望在某一层次上部分处理一个异常，但仍然允许它在调用栈中向上遍历到另一个处理程序。你可以正常地使用`raise`函数抛出异常，但这样做会丢失嵌入在异常中的调用栈信息，后续的处理程序会将你的处理程序识别为错误的源。为了保留堆栈跟踪，*重新抛出*异常，可以使用一个仅在`with`块内有效的函数：`reraise`。
- en: '[PRE77]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Unlike in C# and Visual Basic, F#’s `try...with` construct is an expression,
    so it returns a value. All of the examples so far have returned `unit`. This opens
    up more possibilities as to how you can use the construct, but it also means that
    each exception case must have the same return type as the `try` block.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 与C#和Visual Basic不同，F#的`try...with`结构是一个表达式，因此它会返回一个值。到目前为止的所有示例都返回了`unit`。这为你如何使用该结构提供了更多可能性，但也意味着每个异常情况的返回类型必须与`try`块相同。
- en: A common practice is to have the `try...with` return an option type where the
    `try` block returns `Some<_>` and each exception case returns `None`. You can
    follow this pattern to return the contents of a text file.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的做法是让`try...with`返回一个选项类型，其中`try`块返回`Some<_>`，而每个异常情况返回`None`。你可以遵循这个模式来返回文本文件的内容。
- en: '[PRE78]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In this example, you can see at ① where an option is created with the contents
    of the text file and returned. Returning `None` from the `FileNotFoundException`
    handler is shown at ②.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你可以看到①处创建了一个包含文本文件内容的选项并返回。在②处，`FileNotFoundException`处理程序返回了`None`。
- en: try. . .finally Expressions
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: try...finally 表达式
- en: The `try...finally` construct is used to execute code that must run regardless
    of whether the code in the `try` block raises an exception.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`try...finally`结构用于执行必须运行的代码，不管`try`块中的代码是否抛出异常。'
- en: 'Usually, `try...finally` is used to clean up any resources that might have
    been left open by the `try` block, as shown here:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`try...finally`用于清理`try`块中可能打开的任何资源，如下所示：
- en: '[PRE79]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Raising Exceptions
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抛出异常
- en: An exception-handling mechanism isn’t much use if you’re stuck handling exceptions
    from library functions but can’t raise your own. You can raise an exception of
    any type with the `raise` function.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只能处理库函数抛出的异常，但不能抛出自己的异常，那么异常处理机制的用处就不大了。你可以使用`raise`函数抛出任何类型的异常。
- en: '[PRE80]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In addition to `raise`, F# includes a sprinkling of additional functions for
    raising some of the more commonly used exceptions. The `failwith` and `failwithf`
    functions are convenient for general exceptions. Both raise a `Microsoft.FSharp.Core.FailureException`,
    but the `failwithf` function allows you to use the F# format strings (discussed
    in [String Formatting](ch03.html#string_formatting "String Formatting")), as shown
    here.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`raise`，F#还包括一些其他函数，用于抛出一些常用的异常。`failwith`和`failwithf`函数方便用于一般异常。这两个函数都会抛出`Microsoft.FSharp.Core.FailureException`，但`failwithf`函数允许你使用F#格式字符串（详见[String
    Formatting](ch03.html#string_formatting "字符串格式化")），如下所示。
- en: '[PRE81]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Another common exception type that’s easily raised through a built-in function
    is `System.ArgumentException`. To conveniently raise it, use the `invalidArg`
    function.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的异常类型是`System.ArgumentException`，可以通过内置函数轻松抛出。为了方便抛出它，可以使用`invalidArg`函数。
- en: '[PRE82]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Custom Exceptions
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义异常
- en: 'It’s usually best to use predefined exception types like `ArgumentException`,
    `FormatException`, or even `NullReferenceException`, but if you must define your
    own exception types, you can define a new class that extends `System.Exception`.
    For example:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好使用预定义的异常类型，如`ArgumentException`、`FormatException`，甚至是`NullReferenceException`，但如果你必须定义自己的异常类型，可以定义一个扩展自`System.Exception`的新类。例如：
- en: '[PRE83]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: You can raise your custom exception with the `raise` function and handle it
    in a `try...with` or `try...finally` block as with any other exception type. Here
    you can see the custom `MyException` exception raised and caught.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`raise`函数抛出自定义异常，并像处理其他异常类型一样，在`try...with`或`try...finally`块中处理它。在这里你可以看到自定义的`MyException`异常被抛出并捕获。
- en: '[PRE84]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: There’s also a lightweight alternative to creating exception classes. In F#
    you can define a custom exception type and its associated data with the `exception`
    keyword. Exceptions created this way are still standard .NET exceptions that derive
    from `System.Exception`, but the syntax borrows from a few functional concepts
    (syntactic tuples and discriminated unions, in particular) to accomplish its magic.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种轻量级的替代方案来创建异常类。在 F# 中，你可以使用 `exception` 关键字定义一个自定义的异常类型及其相关数据。以这种方式创建的异常仍然是标准的
    .NET 异常，派生自 `System.Exception`，但其语法借鉴了一些函数式编程概念（特别是语法元组和区分联合类型）来实现其魔力。
- en: '[PRE85]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You raise these exceptions as you would any exception. However, handling them
    is streamlined because you can use the same pattern-matching syntax as discriminated
    unions (more on pattern matching in [Chapter 7](ch07.html "Chapter 7. Patterns,
    Patterns, Everywhere")) to not only determine which handler to use but also to
    bind the associated data to useful identifiers.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像处理任何异常一样抛出这些异常。然而，处理这些异常更加简化，因为你可以使用与区分联合类型相同的模式匹配语法（更多关于模式匹配的内容请参见[第 7
    章](ch07.html "第 7 章. 模式，模式，处处都是模式")），不仅可以确定使用哪个处理器，还能将相关数据绑定到有用的标识符。
- en: A generalized `retry` function might raise different exception types that indicate
    whether it should keep trying or give up depending on how many times it has tried
    to execute some action.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通用的 `retry` 函数可能会抛出不同的异常类型，指示它应该继续尝试还是放弃，这取决于它已经尝试执行某个操作的次数。
- en: '[PRE86]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In this example, the `retry` function ① accepts two parameters. The first indicates
    the maximum number of attempts and the second is a Boolean-returning function
    to invoke. All of the work is performed within `retryInternal` ②, a nested *recursive
    function* that calls itself and that invokes the supplied function. If the supplied
    function returns `false`, it raises either a `RetryCountExceeded` exception ③
    or a `RetryAttemptFailed` exception ④. When `RetryAttemptFailed` is raised, the
    handler ⑤ writes the exception message to the console before calling the `retryInternal`
    function again with an incremented counter. If a `RetryCountExceeded` exception
    is raised, the handler ⑥ writes the exception message to the console and then
    reraises the exception for another handler to process. Of course, this process
    has to start somewhere, so we make the initial call to `retryInternal` ⑦ with
    1 to indicate the first attempt.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`retry` 函数 ① 接受两个参数。第一个参数表示最大尝试次数，第二个参数是一个返回布尔值的函数。所有工作都在 `retryInternal`
    ② 中执行，这是一个嵌套的 *递归函数*，它调用自身并调用传入的函数。如果传入的函数返回 `false`，则抛出 `RetryCountExceeded`
    异常 ③ 或 `RetryAttemptFailed` 异常 ④。当抛出 `RetryAttemptFailed` 异常时，处理器 ⑤ 会将异常消息写入控制台，然后再次调用
    `retryInternal` 函数，计数器增加。如果抛出 `RetryCountExceeded` 异常，处理器 ⑥ 会将异常消息写入控制台，然后重新抛出异常，以便另一个处理器进行处理。当然，这个过程必须从某个地方开始，因此我们通过初始调用
    `retryInternal` ⑦ 来表示第一次尝试，传入的参数为 1。
- en: This syntactic simplicity does come at a cost. Despite `RetryAttemptFailed`
    and `RetryCountExceeded` being standard exceptions, you’ll really want to keep
    them isolated to your F# assemblies because consuming them in other languages
    can be cumbersome. The associated data is defined as a syntactic tuple, so the
    individual values don’t get descriptive names in the compiled code; instead, the
    values are assigned “useful” generated names like `Data0` and `Data1`. To confuse
    matters even more, the compiler has no way of knowing which, if any, of the associated
    data items should be treated as the exception’s `Message` property, so the default
    message (from the base exception class) is used.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法简洁性确实是有代价的。尽管 `RetryAttemptFailed` 和 `RetryCountExceeded` 是标准异常类型，但你真的希望将它们限制在你的
    F# 程序集中，因为在其他语言中使用它们可能会很麻烦。相关数据被定义为语法元组，因此在编译后的代码中，单独的值没有描述性的名称；相反，这些值会被分配一些“有用的”生成名称，比如
    `Data0` 和 `Data1`。更糟糕的是，编译器无法知道哪些相关数据项应该被视为异常的 `Message` 属性，因此使用的是默认消息（来自基类异常）。
- en: String Formatting
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: You probably guessed that the tried and tested `Console.Write`, `Console.WriteLine`,
    and `String.Format` methods are perfectly acceptable in F#. When you need absolute
    control over formatting, you’ll have to use them. As capable as they are, though,
    they don’t take advantage of all that F# has to offer.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能猜到了，经过验证的 `Console.Write`、`Console.WriteLine` 和 `String.Format` 方法在 F# 中是完全可以接受的。当你需要完全控制格式化时，你必须使用它们。尽管它们功能强大，但它们并没有充分利用
    F# 所能提供的一切。
- en: F# has its own string formatting capabilities that you can use with the `printf`,
    `printfn`, and `sprintf` functions, among others. Why did the language designers
    choose to build another formatting mechanism when .NET’s built-in mechanism is
    already so capable? Because F#’s native formatting capabilities tie into the compiler
    better than the traditional ones. For one, the tokens used within the F# format
    strings are generally easier to remember than the format strings in the core methods,
    but that’s not the primary advantage. What really distinguishes the F# formatting
    system is that it ties in to the F# type inference system! The compiler will verify
    that each token has a matching value and that each supplied value is the correct
    type for the corresponding token!
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: F# 有其独特的字符串格式化功能，可以与 `printf`、`printfn` 和 `sprintf` 等函数一起使用。为什么语言设计者要在 .NET
    内置机制已经如此强大的情况下，再构建一个格式化机制呢？因为 F# 的本地格式化能力比传统的机制更能与编译器紧密结合。首先，F# 格式字符串中使用的标记通常比核心方法中的格式字符串更容易记住，但这并不是主要优势。真正使
    F# 格式化系统与众不同的是，它与 F# 的类型推导系统紧密集成！编译器会验证每个标记是否有匹配的值，并且每个提供的值是否与相应标记的类型匹配！
- en: To simply format a string, you could use the `sprintf` function. For example,
    here’s how to quickly format a basic integer value.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 要简单地格式化一个字符串，你可以使用 `sprintf` 函数。例如，下面是如何快速格式化一个基本的整数值。
- en: '[PRE87]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Of course, integers aren’t the only data type you can format in this manner.
    [Table 3-5](ch03.html#common_format_tokens "Table 3-5. Common Format Tokens")
    shows a list of common format string tokens.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，整数并不是唯一可以以这种方式格式化的数据类型。[表 3-5](ch03.html#common_format_tokens "表 3-5. 常见格式标记")展示了常见的格式字符串标记列表。
- en: Table 3-5. Common Format Tokens
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-5. 常见格式标记
- en: '| Token | Description |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| Token | 描述 |'
- en: '| --- | --- |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `%A` | Prints any value with F#’s default layout settings |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `%A` | 使用 F# 的默认布局设置打印任何值 |'
- en: '| `%b` | Formats a Boolean value as `true` or `false` |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `%b` | 格式化一个布尔值为 `true` 或 `false` |'
- en: '| `%c` | Formats a character |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `%c` | 格式化一个字符 |'
- en: '| `%d`, `%i` | Formats any integer |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| `%d`, `%i` | 格式化任何整数 |'
- en: '| `%e`, `%E` | Formats a floating-point number with scientific notation |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| `%e`, `%E` | 使用科学记数法格式化一个浮动点数 |'
- en: '| `%f` | Formats a floating-point number |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| `%f` | 格式化一个浮动点数 |'
- en: '| `%g`, `%G` | Shortcut for `%e` or `%f`; the more concise one will be selected
    automatically. |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| `%g`, `%G` | `%e` 或 `%f` 的快捷方式；会自动选择更简洁的表示。 |'
- en: '| `%M` | Formats a decimal value |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| `%M` | 格式化一个十进制值 |'
- en: '| `%o` | Octal |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `%o` | 八进制 |'
- en: '| `%O` | Prints any value by calling its `ToString` method |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `%O` | 通过调用其 `ToString` 方法打印任何值 |'
- en: '| `%s` | Formats a string |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `%s` | 格式化一个字符串 |'
- en: '| `%x` | Lowercase hexadecimal |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `%x` | 小写十六进制 |'
- en: '| `%X` | Uppercase hexadecimal |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| `%X` | 大写十六进制 |'
- en: 'To ensure that the formatted text is at least a certain number of characters
    wide, you can include an optional width value after the `%`. (The default formatter
    won’t truncate your data unless the format token explicitly allows it.) For example:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保格式化的文本至少宽度达到一定字符数，你可以在 `%` 后添加一个可选的宽度值。（默认格式化器不会截断你的数据，除非格式标记明确允许。）例如：
- en: '[PRE88]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: You can combine several modifiers with the tokens for a little extra flexibility
    in formatting, as listed in [Table 3-6](ch03.html#numeric_format_string_modifiers
    "Table 3-6. Numeric Format String Modifiers").
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将多个修饰符与标记组合，以获得更多格式化的灵活性，如 [表 3-6](ch03.html#numeric_format_string_modifiers
    "表 3-6. 数值格式字符串修饰符") 所示。
- en: Table 3-6. Numeric Format String Modifiers
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-6. 数值格式字符串修饰符
- en: '| Modifier | Effect | Example | Result |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| 修饰符 | 效果 | 示例 | 结果 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `0` | When used in conjunction with a width, pads any extra space with zeros
    | `"%010d"` | `"0000000123"` |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `0` | 与宽度一起使用时，用零填充额外的空格 | `"%010d"` | `"0000000123"` |'
- en: '| `-` | Left-justifies the text within the available space | `"%-10d"` | `"123
    "` |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 将文本左对齐到可用空间内 | `"%-10d"` | `"123 "` |'
- en: '| `+` | Prepends a positive sign if the number is positive | `"%+d"` | `"+123"`
    |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 如果数字是正数，则在前面加上正号 | `"%+d"` | `"+123"` |'
- en: '| (space) | Prepends a space if the number is positive | `"% d"` | `" 123"`
    |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| (空格) | 如果数字是正数，则在前面加空格 | `"% d"` | `" 123"` |'
- en: You can also combine several modifiers within a single token. For example, you
    could use the token `%+010d` to print a number front-padded with zeros and the
    plus (`+`) sign.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在一个标记内组合多个修饰符。例如，你可以使用标记 `%+010d` 来打印一个前面用零和加号（`+`）填充的数字。
- en: Type Abbreviations
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型缩写
- en: Type abbreviations allow you to define a new name for an existing type just
    like the core data types are exposed to F#. It’s possible to do something similar
    in C# with the `using` directive, but F#’s type abbreviations allow you to use
    the name throughout your library (after its definition, of course) instead of
    only within a single file.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 类型缩写允许你为现有类型定义一个新名称，就像核心数据类型被暴露给F#一样。你可以在C#中使用`using`指令做类似的事情，但F#的类型缩写允许你在整个库中使用该名称（当然是在定义之后），而不是仅限于单个文件内。
- en: 'You define type abbreviations with the `type` keyword, an identifier, and the
    type. If you wanted to refer to `System.IO.FileStream` as `fs`, you’d use the
    following:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`type`关键字、标识符和类型来定义类型缩写。如果你想将`System.IO.FileStream`引用为`fs`，你可以使用以下方式：
- en: '[PRE89]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Comments
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'When you want to describe what a particular piece of code is doing, use comments.
    There are three ways to comment your code in F#: end-of-line comments, block comments,
    and XML documentation.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想描述某段代码的功能时，可以使用注释。F#提供了三种注释方式：行尾注释、块注释和XML文档注释。
- en: End-of-Line Comments
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行尾注释
- en: '*End-of-line* (or *single-line*)*comments* begin with two slash characters
    (`//`). As their name implies, they include everything until the end of the line.
    These comments frequently appear on a line of their own but can also appear at
    the end of a line.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '*行尾*（或*单行*）*注释*以两个斜杠字符（`//`）开头。正如其名称所示，它们包括从注释符号到行尾的所有内容。这些注释通常单独占一行，但也可以出现在一行的末尾。'
- en: '[PRE90]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Block Comments
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 块注释
- en: '*Block comments* are delimited with `(*` and `*)` and are typically used for
    comments that need to span multiple lines.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '*块注释*以`(*`和`*)`为分隔符，通常用于需要跨多行的注释。'
- en: '[PRE91]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: You can also use block comments in the middle of a line of otherwise uncommented
    code.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在一行未注释的代码中间使用块注释。
- en: '[PRE92]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Be careful with what you include in block comments because the compiler treats
    their content as strings, verbatim strings, and triple-quoted strings. If you
    happen to include a quotation mark (or three consecutive quotation marks), the
    compiler will insist that you’re beginning a string and will produce a syntax
    error if it doesn’t find the corresponding closing token.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在块注释中包含的内容，因为编译器将其视为字符串、逐字字符串和三引号字符串。如果你不小心包含了一个引号（或三个连续的引号），编译器会认为你开始了一个字符串，如果找不到对应的闭合符号，就会产生语法错误。
- en: '[PRE93]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: XML Documentation
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XML文档
- en: Like the other .NET languages, F# allows *XML documentation comments* with triple
    slashes (`///`). These comments are technically just a special case of end-of-line
    comments where the compiler retains the contents to build an XML document that
    can eventually serve as documentation.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他.NET语言一样，F#也允许使用*XML文档注释*，使用三斜杠（`///`）。这些注释在技术上只是行尾注释的一种特殊情况，编译器保留内容以构建一个XML文档，最终可以作为文档使用。
- en: A complete discussion of XML documentation comments is beyond the scope of this
    book, but keep in mind that comments are useful for documenting your API. At a
    minimum I recommend using them on all of your application’s public and internal
    types and members.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并未详细讨论XML文档注释，但请记住，注释对记录你的API非常有用。至少我建议在所有应用程序的公共和内部类型及成员上使用注释。
- en: Your XML documentation comments will usually include a few elements like `summary`,
    `param`, and `returns`. `summary` elements briefly describe the documented code,
    `param` elements identify and describe individual function or constructor parameters,
    and `returns` elements describe a function’s return value.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 你的XML文档注释通常包括一些元素，如`summary`、`param`和`returns`。`summary`元素简要描述被注释的代码，`param`元素识别并描述函数或构造函数的各个参数，`returns`元素描述函数的返回值。
- en: 'You might document a function that calculates some circle measurements based
    on its radius like this:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会像这样记录一个计算某个圆形度量（基于其半径）的函数：
- en: '[PRE94]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Even if you don’t intend to distribute the resulting XML file, XML documentation
    comments can help you by surfacing information about the documented types and
    members through IntelliSense. In [Figure 3-2](ch03.html#xml_documentation_in_intellisense
    "Figure 3-2. XML documentation in IntelliSense") you can see the summary from
    the preceding example included in the tool tip displayed when you hover the mouse
    over the `measureCircle` function in Visual Studio.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不打算分发生成的XML文件，XML文档注释也能通过IntelliSense为你提供关于文档化类型和成员的信息。在[图3-2](ch03.html#xml_documentation_in_intellisense
    "图3-2. IntelliSense中的XML文档")中，你可以看到前一个示例中的摘要，它包含在鼠标悬停在Visual Studio中的`measureCircle`函数时显示的工具提示中。
- en: '![XML documentation in IntelliSense](httpatomoreillycomsourcenostarchimages1981220.png.jpg)Figure 3-2. XML
    documentation in IntelliSense'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![IntelliSense中的XML文档](httpatomoreillycomsourcenostarchimages1981220.png.jpg)图3-2.
    IntelliSense中的XML文档'
- en: 'There’s a shortcut for XML documentation comments. When you’re writing only
    a summary, you can simply use the triple slashes and omit the tags. Here’s the
    summary in the previous example written using the shortcut:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: XML文档注释有一个快捷方式。当你只写摘要时，你可以简单地使用三个斜杠并省略标签。以下是使用快捷方式书写的前一个示例中的摘要：
- en: '[PRE95]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: As you can see, when your comment is too long for a single line, you can write
    it on multiple lines as long as each line begins with triple slashes.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当你的注释太长而无法放在一行时，只需确保每一行都以三个斜杠开始，就可以将其分成多行书写。
- en: Summary
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve explored some of the fundamental concepts of the F# language.
    You’ve seen the problems that can arise from mutable data and how F#’s default
    immutability, type inference capabilities, and explicit opt-in approach for valueless
    data can help you write more robust, fault-tolerant code. You’ve also learned
    how F# supports the core CLI types and other base capabilities of the .NET Framework
    like enumerations, generics, exception handling, and string formatting.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了F#语言的一些基本概念。你已经看到可变数据可能带来的问题，以及F#默认的不可变性、类型推断能力和显式选择无值数据的方法如何帮助你编写更强健、更容错的代码。你还了解了F#如何支持核心CLI类型和.NET框架的其他基础功能，如枚举、泛型、异常处理和字符串格式化。
- en: What really makes F# stand out as a viable language for your projects, though,
    is how it expands upon so many concepts even at this fundamental level. Constructs
    like `use` bindings that dispose of objects without requiring additional nesting
    levels, exception handlers that return values, and string-formatting functions
    that tie into the compiler can have an immediate, positive impact on your productivity.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，F#真正脱颖而出的地方，是它在如此基础的层面上扩展了如此多的概念。像`use`绑定这样的构造能够在不需要额外嵌套的情况下处理对象，返回值的异常处理器，以及与编译器紧密结合的字符串格式化函数，都能对你的生产力产生立即且积极的影响。
- en: In the next chapter, we’ll build upon these concepts with a look into F#’s object-oriented
    capabilities. We’ll see how the concepts introduced here can help you quickly
    develop complex libraries while keeping you focused on the problem rather than
    the compiler.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将基于这些概念，进一步探讨F#的面向对象能力。我们将看到这里介绍的概念如何帮助你快速开发复杂的库，同时让你专注于问题而非编译器。
