- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Low-Level Bit Manipulation
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses some bit manipulation techniques for WebAssembly applications,
    which we’ll apply to projects in later chapters to improve application performance.
    This topic can be challenging for readers not familiar with low-level programming,
    so if working with binary data isn’t in your interest, you can continue on to
    the next chapter and simply refer back to this one as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Before exploring bit manipulation techniques, we’ll go over a few essential
    topics, which include the three different numeric bases—decimal, hexadecimal,
    and binary; the details of integer and floating-point arithmetic; and 2s complement
    as well as big-endian and little-endian byte order. Additionally, we’ll examine
    high-order and low-order bits, bit masking, bit shifting, and bit rotation.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly allows you to get as close to the metal as possible from within
    a web browser. If you want to write WebAssembly that executes at lightning speed,
    understanding how to manipulate your data at the level of bits is very useful.
    Bit manipulation is also essential to comprehend the data types WebAssembly works
    with, how they perform, and their limitations. WAT can manipulate data at the
    level of bits in a way that’s similar to assembly languages. Low-level coding
    is a tricky subject, and if you’re not already familiar with some of the concepts
    in this chapter, you might not grasp them all immediately. The good news is you
    don’t need to know all of these low-level concepts to work with WebAssembly, but
    understanding low-level WebAssembly can help you write fast, high-performance
    code for the web. Many times, code a compiler optimizes will generate code that
    performs bit manipulation, so knowledge of how these bit manipulation operations
    work is also important when you’re disassembling a WebAssembly binary to WAT code.
  prefs: []
  type: TYPE_NORMAL
- en: Binary, Decimal, and Hexadecimal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *hexadecimal system* is a common numbering system in computer programming
    that uses base-16 instead of the base-10 decimal numbering system you’ve been
    using since you were two years old. Computer programmers work with hexadecimal
    (hex) because computers natively use binary, and hex more cleanly translates into
    binary than decimal. You won’t learn how to convert from decimal to hex manually,
    because I’ll assume you’re either familiar with how to do it or have access to
    a calculator; most calculator apps offer a programmer mode that will do this conversion
    for you, like the one shown in [Figure 4-1](#figure4-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f04001](Images/f04001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: Microsoft Windows Calculator app in Programmer mode'
  prefs: []
  type: TYPE_NORMAL
- en: I also provide a simple decimal to hex conversion tool at [https://wasmbook.com/hex](https://wasmbook.com/hex),
    as well as an online calculator written in WAT at [https://wasmbook.com/calculator.html](https://wasmbook.com/calculator.html).
    Keep in mind that if you want to embed numeric data into a string in WAT, you
    need to use two-digit hex numbers, not decimals.
  prefs: []
  type: TYPE_NORMAL
- en: Integers and Floating-Point Arithmetic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before discussing how we can use bit manipulation on types, we need to discuss
    the details of the types that WebAssembly supports. The two primary data types
    in WebAssembly are integers and floating-point numbers. These types are assigned
    to all local and global variables when they’re declared, and you should use them
    for all parameters in function declarations. Integers represent whole numbers
    and can represent negative as well as positive numbers. However, using negative
    integer numbers requires a little more effort than negative floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: You can store integers and floating-point numbers in variables and in linear
    memory. If you’re familiar with JavaScript, linear memory is like a typed, unsigned-integer
    array. We’ll discuss linear memory more in Chapter 6.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll look at how integer and floating-point variables work,
    the different types of floating-point and integer variables, and how to do some
    basic binary manipulation on them. Let’s first briefly discuss the four primary
    data types that WebAssembly supports. There are two integer data types (`i32`
    and `i64`) as well as two floating-point data types (`f32` and `f64`).
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Integer arithmetic is usually faster than floating-point arithmetic for most
    math operations. WebAssembly currently supports 32-bit and 64-bit integers but,
    unfortunately, cannot share 64-bit integers with JavaScript as easily as the other
    data types.
  prefs: []
  type: TYPE_NORMAL
- en: i32 (32-Bit Integers)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `i32` data type is fast, small, and easily moved between WebAssembly and
    JavaScript. It can represent between 0 and 4,294,967,295 as unsigned data and
    between –2,147,483,648 to 2,147,483,647 for signed integers. If you’re dealing
    with numbers that you know will be less than a billion in value and you don’t
    need fractional numbers, using `i32` is a great choice. Working with signed or
    unsigned values has more to do with the functions you perform on the data rather
    than the data in the variable. The `i32` data type represents negative numbers
    using 2s complement.
  prefs: []
  type: TYPE_NORMAL
- en: 2s Complement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The 2s complement is a widely used technique for representing negative numbers
    in a binary format. Computers only work in binary so only have memory with 1s
    and 0s. Binary can be translated into decimal fairly easily, but it’s less obvious
    how to represent a negative number with only 1s and 0s. It’s important to note
    that floating-point numbers have a dedicated sign bit and therefore don’t use
    2s complement.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how 2s complement works, let’s digress into a metaphorical comparison.
    Imagine you have a push button tally counter and each time you press a button,
    it advances a little number dial by one ([Figure 4-2](#figure4-2)). This particular
    counter only has a single decimal digit display, so it starts at 0 and counts
    to 9, but when you click it a tenth time, it rolls back to 0\. From your counter’s
    perspective, adding 10 is the equivalent of adding 0, because your counter ends
    up in the same location as it started. Apropos of that, pressing the button 9
    times is functionally the same as subtracting 1 for all numbers except 0.
  prefs: []
  type: TYPE_NORMAL
- en: '![f04002](Images/f04002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: Nine rolls over to 0 when 1 is added.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the high-value numbers as negatives is only useful if you know that your
    numbers will be in a range that doesn’t include the chosen negative numbers. If
    you declare that 9 is equivalent to –1, but you need to count up to 9 with your
    counter, this number system won’t work. The rolling-over system is the reason
    that a signed 8-bit integer supports numbers from –128 to 127\. The unsigned 8-bit
    encoding of the number 255 (eight 1s) is the same as the signed 8-bit representation
    of –1 because adding 255 to any number causes the bits to roll over like an odometer
    and subtract one. The largest numbers become negative because they result in the
    bits rolling over. The code that performs a 2s complement conversion on binary
    digits uses a binary XOR to flip all of the bits and then adds the number 1 to
    the result, which results in the negative of the number. You’ll see the code to
    this function when we look at XOR and bit flipping later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: i64 (64-Bit Integers)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `i64` data type can represent positive integer numbers between 0 and 18,446,744,073,709,551,615
    for unsigned integers and between –9,223,372,036,854,775,808 and 9,223,372,036,854,775,807
    for signed integers. The `i64` data type in WAT doesn’t specify whether it’s signed
    or unsigned when the variable is declared. Instead, WAT has to choose operations
    to perform on that data based on whether the user wants to treat the number as
    signed or unsigned. Not all operations require you to make that choice: for example,
    `i64.add`, `i64.sub`, and `i64.mul` all work the same whether the integers are
    signed or not. In contrast are the division functions, such as `i64.div_s` and
    `i64.div_u`. The division operation must treat the numbers differently if they’re
    signed or unsigned and so must have the `_s` and `_u` suffix appended to the different
    versions of the operation.'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, one problem with `i64` data types is that you cannot directly
    move 64-bit integers back and forth between WebAssembly and JavaScript. JavaScript
    only uses 64-bit floating-point numbers, but 64-bit floats can accommodate 32-bit
    integers and 32-bit floating-point numbers. The bottom line is that transferring
    64-bit integers to the JavaScript portion of your app can be a pain.
  prefs: []
  type: TYPE_NORMAL
- en: Floating-Point Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A floating-point number contains three parts in binary: a sign bit, followed
    by a series of bits to represent the exponent, and then the bits that represent
    the significant digits (sometimes called the *mantissa* or *significand*). Remember,
    there is no decimal point in binary; computer scientists had to invent a system
    for representing decimal points inside a binary number. The sign bit indicates
    whether the number is positive or negative. The exponent signifies how many positions
    to move a decimal point (left or right), and the significant digits are simply
    the numbers for your floating-point number. Let’s look at how you could create
    floating-point numbers using base 10 by first using the exponent to raise a number:
    if you take a number like 345, and multiply it by 10 raised to a power of 2, it
    appends two zeros to the end of your number, as shown in [Figure 4-3](#figure4-3).
    This is effectively moving the decimal place two positions to the right.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f04003](Images/f04003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-3: Shift the decimal point right with a positive exponent.'
  prefs: []
  type: TYPE_NORMAL
- en: Using only base 10 numbers, you would say that you have an exponent of 2 followed
    by 3 decimal digits, so 2345 would be the number 34,500, or 345 × 10² depicted
    in [Figure 4-4](#figure4-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![f04004](Images/f04004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-4: Using a decimal exponent'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a fractional value, we need an exponent that is negative rather than
    positive, as shown in [Figure 4-5](#figure4-5): a negative exponent moves the
    decimal point to the left.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f04005](Images/f04005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-5: Shift the decimal point left with a negative exponent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An exponent of negative 2 turns 345 into 3.45, resulting in a fractional value.
    Notice the problem with this system: so far we have no method for representing
    the negative nature of the first exponent bit. We said we could use 2345 to represent
    345 × 10², but we didn’t represent the minus sign. We can choose from one of two
    approaches: 2s complement and biased exponent. First, we could use a method like
    2s complement and assign the higher digit values negative numbers, so 8345 could
    represent 345 × 10^(–2) because 10 – 2 = 8\. But this isn’t the method the designers
    of floating-point numbers chose. Instead, they use a *biased exponent* where they
    simply subtract a particular chosen value from the exponent to give us the negative
    exponent. For example, if we decide to always subtract 5 from our exponent digit,
    3345 would represent 345 × 10^(–2) because 3 – 5 = –2.'
  prefs: []
  type: TYPE_NORMAL
- en: Real floating-point numbers are binary, not decimal, but the basic principles
    are the same. In binary floating-point numbers, the most significant bit is a
    sign bit, which is 0 if the number is positive and 1 if it’s negative. The eight
    bits that follow the sign bit represent the exponent. The mantissa represents
    a fractional number value between one and two. The leftmost bit represents a value
    of 0.5, followed by 0.25, 0.125, 0.0625, and so on, halving each time. Because
    the minimum value of the mantissa is 1, the actual value of the mantissa is always
    one greater than the sum of all these fraction bits. The layout of these bits
    is shown in [Figure 4-6](#figure4-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![f04006](Images/f04006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-6: 32-bit floating-point bits'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the mantissa has a minimum value of 1 creates a problem for the
    number 0\. Raising a non-zero value to any power can never result in a value of
    0\. To compensate for this, the exponent has two special values that allow for
    the representation of 0 and infinite values in the floating-point number. If all
    the bits in the exponent and mantissa are 0, then the number represented is 0,
    even though 0⁰ is 1\. Interestingly, floating-point numbers can represent 0 and
    –0 depending on the value in the sign bit. Infinity and –Infinity are values that
    have all of the exponent bits set to 1 and all of the mantissa bits set to 0\.
    If the mantissa bits aren’t 0, the floating-point is a NaN (not a number).
  prefs: []
  type: TYPE_NORMAL
- en: Subnormal Numbers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Subnormal numbers* (sometimes called *denormalized numbers*) are another floating-point
    edge case in the IEEE-754 specification for floating-point numbers. Subnormal
    numbers are an edge case where the exponent bits are all 0\. In the situation
    in which all the exponent bits are 0, the mantissa value no longer adds 1 to the
    value represented. This allows for even smaller decimal point values. We won’t
    use subnormal numbers in this book, but you should at least be aware of their
    existence.'
  prefs: []
  type: TYPE_NORMAL
- en: f64/number
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `f64` data type is a double-precision 64-bit floating-point number. An `f64`
    has 52 bits that represent the significant digits, an 11-bit exponent, and a sign
    bit. This data type allows for high precision but on most hardware executes more
    slowly than integers or smaller floating-point numbers. One of its benefits is
    that it’s the same data type JavaScript uses for all of its numbers, making it
    a convenient data type for numbers that must be moved back and forth between JavaScript
    and WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: f32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `f32` data type is smaller and faster than `f64` but has far less precision,
    giving you fewer significant digits to work with. The `f64` data type has roughly
    16 decimal significant digits for you to play with where an `f32` has only about
    seven. Because binary digits represent the significand, it doesn’t line up perfectly
    with decimal digits. The number of significant decimal digits is only an approximation,
    but it does give you a sense of each type’s limitations.
  prefs: []
  type: TYPE_NORMAL
- en: High- and Low-Order Bits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll look at bit significance. The low-order bit is the least
    significant bit of a binary number; significance simply means *representing the
    largest value*. In [Figure 4-7](#figure4-7), in the number 128, the digit 1 is
    the most significant digit and 8 is the least significant.
  prefs: []
  type: TYPE_NORMAL
- en: '![f04007](Images/f04007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-7: Most significant and least significant digits'
  prefs: []
  type: TYPE_NORMAL
- en: The digit representing the largest numeric value is the most significant. Here,
    1 is the most significant digit because it’s in the 100th place, and there are
    no digits representing numbers in a higher position. The sad little 8 in the illustration
    is the least significant digit because it represents the 1s place.
  prefs: []
  type: TYPE_NORMAL
- en: Binary numbers also have higher-order digits. On a computer, one byte is always
    eight binary digits; even if the number is 00000001, the left seven binary digits
    are still in the byte. For example, the number 37 is 100101 in binary, but in
    computer memory, the value in the byte is 00100101\. The most significant bit
    (high-order bit) in this byte is the leftmost 0, as shown in [Figure 4-8](#figure4-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![f04008](Images/f04008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-8: High-order and low-order bit'
  prefs: []
  type: TYPE_NORMAL
- en: The low-order bit in this byte is the 1 on the far right, and the high-order
    bit is the 0 on the far left.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at just the high-order and low-order bits of a variable can reveal some
    information about a byte. The low-order bit in an integer indicates whether that
    integer has an even (0) or odd (1) value. The high-order bit of a signed integer
    determines whether that number is positive (0) or negative (1).
  prefs: []
  type: TYPE_NORMAL
- en: Bit Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebAssembly offers data manipulation at a low level of abstraction. If you’re
    willing to put in the work, you can frequently provide better code performance
    by manipulating data at the level of bits. Understanding how these operations
    work can also be useful when you’re trying to improve your code’s performance,
    even in high-level languages. We’ll use many of the operations in this chapter
    in applications we write later in the book, so refer back to this chapter as needed.
    These operations are very general purpose, so it’s difficult to give an example
    of when we would use them. However, as situations arise, it will be obvious which
    operation is suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Shifting and Rotating Bits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll cover shifting and rotating bits. These are fundamental
    bit manipulation operations that we’ll use from time to time in this book. A single
    byte of data is made up of eight bits and can hold a number from 0 to 255 in decimal,
    which is the same as 0 to FF in hexadecimal. Did you know that four bits are called
    a *nibble*? Single hexadecimal digits are made up of a single nibble (half a byte)
    and can be a value from 0 to 15 in decimal and 0 to F in hexadecimal.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that four bits can store a single hexadecimal digit makes it relatively
    easy to work with hexadecimal numbers in WAT, especially when it comes to *shifting*.
    Shifting is a generic operation that’s a building block for the optimizations
    we’ll discuss in later chapters. Shifting is somewhat like pushing bits off a
    cliff and replacing them with 0s (or 1s for some signed right shifts). You can
    shift by any number of bits and in either the left or right direction. For example,
    the binary 1110 1001 is E9 in hexadecimal (and 233 in decimal). If we shift that
    number 4 bits to the right using the `(i32.shr_u``)` expression, it returns the
    binary 0000 1110 or 0E in hexadecimal. [Figure 4-9](#figure4-9) shows a dramatization
    of a four-bit shift of E9.
  prefs: []
  type: TYPE_NORMAL
- en: '![f04009](Images/f04009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-9: Shifting hexadecimal E9 four bits to the right results in 0E.'
  prefs: []
  type: TYPE_NORMAL
- en: Shifting data to the right can be a useful trick. Every bit you shift to the
    right is the functional equivalent of dividing by 2\. Similarly, every bit you
    shift to the left is the functional equivalent of multiplying by 2\. You can use
    shifting in combination with masking to isolate sections of binary data.
  prefs: []
  type: TYPE_NORMAL
- en: Left-shifting in WebAssembly is sign-independent, but to right-shift we use
    a signed or an unsigned shift operation. When you right-shift or left-shift a
    binary number, the bits shifted off are usually replaced on the opposite side
    of the integer with 0s. However, with a negative number, if you sign-shift to
    the right, 1s will be sign-shifted in from the left side to preserve the integer’s
    sign. Sign-shifting a 2s complement representation preserves the sign (negativeness).
  prefs: []
  type: TYPE_NORMAL
- en: '*Bit rotation*, unlike a shift, flips bits back around to the other side of
    the variable. If you rotate a bit to the right, the least significant bit is transferred
    to the front and ends up as the most significant bit, and all the other bits shift
    to the right. WAT does bit rotation with the `rotl` (rotate left) or `rotr` (rotate
    right) commands, depicted in [Figure 4-10](#figure4-10).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f04010](Images/f04010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-10: Rotating a bit to the right'
  prefs: []
  type: TYPE_NORMAL
- en: Masking Bits with AND and OR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Bit masking*is a method used to set some specified bits in an integer to 1
    or 0, depending on the kind of mask we use, to isolate or override them. This
    can be very helpful when writing high-performance applications. Also, it’s important
    to know that WebAssembly doesn’t have the concept of boolean values. Comparisons
    in WebAssembly usually return a value of 1 for true and 0 for false. You must
    use the `i32.and` and `i32.or` when, in many languages, you would use boolean
    logic. In this section, we’ll use the `i32.and` and `i32.or` to isolate or override
    bit values with bit masking.'
  prefs: []
  type: TYPE_NORMAL
- en: When you mask with a bitwise AND, the 0 bits in your integer win the battle
    of the bits. The 0 bits in the mask act like masking tape that covers up any other
    bit in the integer, replacing them with 0s. The 1 bits in the mask allow the original
    value to show through. [Figure 4-11](#figure4-11) shows what it looks like to
    mask binary 1011 1110 (190) with 0000 0111 (7).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 4-11](#figure4-11), all of the bits of our original
    value are covered by the 0s in the AND mask. When a bitwise AND operation is performed
    on two different integers, the 0 bit wins ([Figure 4-12](#figure4-12)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f04011](Images/f04011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-11: Masking bits with bitwise AND'
  prefs: []
  type: TYPE_NORMAL
- en: '![f04012](Images/f04012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-12: Bitwise AND 0 wins the battle of the bits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you mask with OR, using an `i32/i64.or`, the results would be the exact
    opposite: 1 bits cover up any bits with 1s. You cannot use the OR mask to isolate
    bits as with an AND. Instead, you use it to set specific bits to 1\. [Figure 4-13](#figure4-13)
    shows masking with OR.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f04013](Images/f04013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-13: Masking with a bitwise OR'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 4-13](#figure4-13), when you use a bitwise OR, the
    1 bits in your mask cover any bits in your initial integer value. So in a bitwise
    OR situation, the 1 bit wins over the 0 bit ([Figure 4-14](#figure4-14)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f04014](Images/f04014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-14: In a bitwise OR, the 1 bit always wins.'
  prefs: []
  type: TYPE_NORMAL
- en: XOR Bit Flip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last binary operation we’ll cover is XOR. With AND and OR, the results of
    a mask are clear. The XOR `i32/i64.xor` operation is a little different. If a
    0 masks a 0, a 1 masks a 0, or a 0 masks a 1, the XOR operates just like a typical
    `i32/i64.or`. The weirdness occurs when you have two 1s, which results in the
    XOR setting the resulting bit to 0\. This feature is handy for *bit flipping*,
    where you invert each bit to its opposite. Certain operations require you to change
    every 1 bit in an integer to a 0 and every 0 bit to a 1\. [Figure 4-15](#figure4-15)
    shows how to flip every bit in a nibble with an XOR.
  prefs: []
  type: TYPE_NORMAL
- en: '![f04015](Images/f04015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-15: XOR bit flip'
  prefs: []
  type: TYPE_NORMAL
- en: In our 2s complement discussion earlier, we noted that if you want to find the
    negative of any number, you can do so by flipping every bit and adding the number
    1\. You can flip all the bits using an `XOR` against an integer that has every
    bit set to 1\. Let’s write a short app that converts an integer value to its negative
    using 2s complement and bit flipping. Create a file named *twos_complement.wat*
    and add the code in [Listing 4-1](#listing4-1).
  prefs: []
  type: TYPE_NORMAL
- en: '**twos_complement.wat**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-1: 2s complement function'
  prefs: []
  type: TYPE_NORMAL
- en: This is a very simple module that takes an `i32` parameter called `$number`.
    We push the `i32` onto the stack, followed by a 32-bit number where all the bits
    are 1 1. When we call `i32.xor` 2, all of the bits from the original number are
    flipped. Every 1 is turned into a 0 and every 0 into a 1\. We then call `i32.add`
    3 to add a value of 1 to this number to get 2s complement, resulting in the negative
    number. This code works well as a demonstration of how 2s complement works; however,
    it would perform better if we just subtracted `$number` from `0` to negate it.
  prefs: []
  type: TYPE_NORMAL
- en: Big-Endian vs. Little-Endian
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All numbers you’re familiar with are arranged in a *big-endian*format, meaning
    the highest-order digits are on the left side and the lowest-order digits are
    on the right side. Most computer hardware uses *little-endian*, where the lowest-order
    digit is on the left and the high-order digit is on the right, so one hundred
    twenty-eight would be written as 821 instead. Keep in mind that endianness is
    about byte order, not digit order, so my little-endian decimal 821 example is
    an oversimplification that can’t be directly translated to binary. Little-endian
    hardware orders the bytes in reverse of what is typical. The number 168,496,141
    written in big-endian hex is 0A0B0C0D. The high-order byte is 0A, and the low-order
    byte is 0D because each hex digit is represented by a nibble or half a byte. If
    we order the bytes in little-endian order, they’re arranged as 0D0C0B0A, as illustrated
    in [Figure 4-16](#figure4-16).
  prefs: []
  type: TYPE_NORMAL
- en: '![f04016](Images/f04016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-16: Big-endian versus little-endian byte order'
  prefs: []
  type: TYPE_NORMAL
- en: Most hardware today arranges bytes in little-endian order for performance reasons.
    WebAssembly uses little-endian byte order regardless of the hardware. When you’re
    initializing data using the `(data``)` statement in WebAssembly, it’s important
    to keep the byte order in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter covered a lot of low-level programming concepts. We looked at the
    different numeric bases (decimal, hexadecimal, and binary) used in low-level programming.
    We examined the details of integer and floating-point arithmetic, and touched
    on 2s complement as well as big-endian and little-endian byte order. We talked
    about bit manipulation, including discussions of high-order and low-order bits,
    bit masking, bit shifting, and bit rotation. These low-level options will become
    useful for applications in later chapters that enhance performance by manipulating
    bits.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn several methods for managing strings as data
    structures, including null-terminated strings and length-prefixed strings. We’ll
    also explore copying strings and converting numeric data into strings in decimal,
    hexadecimal, and binary formats.
  prefs: []
  type: TYPE_NORMAL
