- en: Chapter 1. HELLO, WORLD OF ASSEMBLY LANGUAGE
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 汇编语言的“你好，世界！”
- en: '![HELLO, WORLD OF ASSEMBLY LANGUAGE](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![汇编语言的“你好，世界！”](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: 'This chapter is a "quick-start" chapter that lets you start writing basic assembly
    language programs as rapidly as possible. This chapter does the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一个“快速入门”章节，旨在让你尽快开始编写基本的汇编语言程序。本章内容包括：
- en: Presents the basic syntax of an HLA (High Level Assembly) program
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍了HLA（高级汇编语言）程序的基本语法
- en: Introduces you to the Intel CPU architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Intel CPU架构
- en: Provides a handful of data declarations, machine instructions, and high-level
    control statements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一些数据声明、机器指令和高级控制语句
- en: Describes some utility routines you can call in the HLA Standard Library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述了一些你可以在HLA标准库中调用的实用程序
- en: Shows you how to write some simple assembly language programs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向你展示如何编写一些简单的汇编语言程序
- en: By the conclusion of this chapter, you should understand the basic syntax of
    an HLA program and should understand the prerequisites that are needed to start
    learning new assembly language features in the chapters that follow.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，你应该理解HLA程序的基本语法，并且应该了解学习后续章节中新的汇编语言特性所需的前置条件。
- en: 1.1 The Anatomy of an HLA Program
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1 HLA程序的结构
- en: A typical HLA program takes the form shown in [Figure 1-1](ch01.html#basic_hla_program
    "Figure 1-1. Basic HLA program").
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的HLA程序的形式如[图1-1](ch01.html#basic_hla_program "图1-1. 基本HLA程序")所示。
- en: '![Basic HLA program](tagoreillycom20100401nostarchimages577855.png.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![基本HLA程序](tagoreillycom20100401nostarchimages577855.png.jpg)'
- en: Figure 1-1. Basic HLA program
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-1. 基本HLA程序
- en: '*`pgmID`* in the template above is a user-defined program identifier. You must
    pick an appropriate descriptive name for your program. In particular, *`pgmID`*
    would be a horrible choice for any real program. If you are writing programs as
    part of a course assignment, your instructor will probably give you the name to
    use for your main program. If you are writing your own HLA program, you will have
    to choose an appropriate name for your project.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模板中的*`pgmID`*是一个用户定义的程序标识符。你必须为你的程序选择一个合适的描述性名称。特别是，*`pgmID`*对于任何实际程序来说都是一个糟糕的选择。如果你是在编写课程作业，导师可能会为你提供主程序的名称。如果你是在编写自己的HLA程序，你将需要为你的项目选择一个合适的名称。
- en: Identifiers in HLA are very similar to identifiers in most high-level languages.
    HLA identifiers may begin with an underscore or an alphabetic character and may
    be followed by zero or more alphanumeric or underscore characters. HLA's identifiers
    are *case neutral*. This means that the identifiers are case sensitive insofar
    as you must always spell an identifier exactly the same way in your program (even
    with respect to upper- and lowercase). However, unlike in case-sensitive languages
    such as C/C++, you may not declare two identifiers in the program whose name differs
    only by alphabetic case.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: HLA中的标识符与大多数高级语言中的标识符非常相似。HLA标识符可以以下划线或字母字符开头，后面可以跟零个或多个字母数字字符或下划线字符。HLA的标识符是*大小写不敏感*的。这意味着标识符是区分大小写的，因为你必须在程序中始终准确地拼写标识符（包括大小写）。然而，与像C/C++等区分大小写的语言不同，你不能在程序中声明两个仅因字母大小写不同而名称不同的标识符。
- en: A traditional first program people write, popularized by Kernighan and Ritchie's
    *The C Programming Language*, is the "Hello, world!" program. This program makes
    an excellent concrete example for someone who is learning a new language. [Example 1-1](ch01.html#the_helloworld_program
    "Example 1-1. The helloWorld program") presents the HLA *helloWorld* program.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常写的传统第一个程序，由Kernighan和Ritchie的*《C程序设计语言》*推广，是“你好，世界！”程序。这个程序是学习新语言的一个极好的具体例子。[示例1-1](ch01.html#the_helloworld_program
    "示例1-1. helloWorld程序")展示了HLA的*helloWorld*程序。
- en: Example 1-1. The *helloWorld* program
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-1. *helloWorld*程序
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `#include` statement in this program tells the HLA compiler to include a
    set of declarations from the *stdlib.hhf* (standard library, HLA Header File).
    Among other things, this file contains the declaration of the `stdout.put` code
    that this program uses.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的`#include`语句告诉HLA编译器包含来自*stdlib.hhf*（标准库，HLA头文件）的一组声明。此文件包含了程序使用的`stdout.put`代码声明。
- en: The `stdout.put` statement is the print statement for the HLA language. You
    use it to write data to the standard output device (generally the console). To
    anyone familiar with I/O statements in a high-level language, it should be obvious
    that this statement prints the phrase `Hello, World of Assembly Language`. The
    `nl` appearing at the end of this statement is a constant, also defined in *stdlib.hhf*,
    that corresponds to the newline sequence.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdout.put` 语句是 HLA 语言中的打印语句。你用它将数据写入标准输出设备（通常是控制台）。对于熟悉高级语言中 I/O 语句的人来说，这个语句显然是用来打印短语
    `Hello, World of Assembly Language` 的。该语句末尾的 `nl` 是一个常量，也定义在 *stdlib.hhf* 中，表示换行序列。'
- en: Note that semicolons follow the `program`, `begin`, `stdout.put`, and `end`
    statements. Technically speaking, a semicolon does not follow the `#include` statement.
    It is possible to create include files that generate an error if a semicolon follows
    the `#include` statement, so you may want to get in the habit of not putting a
    semicolon here.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，分号跟在 `program`、`begin`、`stdout.put` 和 `end` 语句后面。严格来说，`#include` 语句后并不跟分号。可以创建包含错误的
    include 文件，如果在 `#include` 语句后加分号，会导致错误，因此你可能要养成不在此处加分号的习惯。
- en: The `#include` is your first introduction to HLA declarations. The `#include`
    itself isn't actually a declaration, but it does tell the HLA compiler to substitute
    the file *stdlib.hhf* in place of the `#include` directive, thus inserting several
    declarations at this point in your program. Most HLA programs you will write will
    need to include one or more of the HLA Standard Library header files (*stdlib.hhf*
    actually includes all the standard library definitions into your program).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`#include` 是你第一次接触 HLA 声明的地方。`#include` 本身并不是声明，但它告诉 HLA 编译器将文件 *stdlib.hhf*
    替代 `#include` 指令，从而在你的程序中插入几个声明。你编写的大多数 HLA 程序都需要包含一个或多个 HLA 标准库头文件（*stdlib.hhf*
    实际上将所有标准库定义包含进你的程序中）。'
- en: Compiling this program produces a *console* application. Running this program
    in a command window prints the specified string, and then control returns to the
    command-line interpreter (or *shell* in Unix terminology).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编译此程序将生成一个 *console* 应用程序。在命令窗口中运行此程序会打印指定的字符串，然后控制权返回到命令行解释器（在 Unix 术语中称为 *shell*）。
- en: 'HLA is a free-format language. Therefore, you may split statements across multiple
    lines if this helps to make your programs more readable. For example, you could
    write the `stdout.put` statement in the *helloWorld* program as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 是一种自由格式的语言。因此，如果将语句拆分成多行有助于提高程序的可读性，你可以这样做。例如，你可以像下面这样编写 *helloWorld* 程序中的
    `stdout.put` 语句：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Another construction you'll see appearing in example code throughout this text
    is that HLA automatically concatenates any adjacent string constants it finds
    in your source file. Therefore, the statement above is also equivalent to
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在本书的示例代码中看到另一个结构，HLA 会自动连接它在源文件中发现的任何相邻的字符串常量。因此，上面的语句也等同于
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Indeed, `nl` (the newline) is really nothing more than a string constant, so
    (technically) the comma between the `nl` and the preceding string isn't necessary.
    You'll often see the above written as
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`nl`（换行符）实际上不过是一个字符串常量，因此（从技术上讲）`nl` 和前一个字符串之间的逗号并不是必需的。你通常会看到上述写法是
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice the lack of a comma between the string constant and `nl`; this turns
    out to be legal in HLA, though it applies only to certain constants; you may not,
    in general, drop the comma. [Chapter 4](ch04.html "Chapter 4. CONSTANTS, VARIABLES,
    AND DATA TYPES") explains in detail how this works. This discussion appears here
    because you'll probably see this "trick" employed by sample code prior to the
    formal explanation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意字符串常量和 `nl` 之间没有逗号；这在 HLA 中是合法的，尽管它只适用于某些常量；通常情况下，你不能省略逗号。[第4章](ch04.html
    "第4章：常量、变量和数据类型") 详细解释了这一点。这里提到这一点是因为你可能会在正式解释之前，看到示例代码使用了这个“技巧”。
- en: 1.2 Running Your First HLA Program
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2 运行你的第一个 HLA 程序
- en: The whole purpose of the "Hello, world!" program is to provide a simple example
    by which someone who is learning a new programming language can figure out how
    to use the tools needed to compile and run programs in that language. True, the
    *helloWorld* program in [1.1 The Anatomy of an HLA Program](ch01.html#the_anatomy_of_an_hla_program
    "1.1 The Anatomy of an HLA Program") helps demonstrate the format and syntax of
    a simple HLA program, but the real purpose behind a program like *helloWorld*
    is to learn how to create and run a program from beginning to end. Although the
    previous section presents the layout of an HLA program, it did not discuss how
    to edit, compile, and run that program. This section will briefly cover those
    details.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: “Hello, world!” 程序的整个目的在于提供一个简单的示例，通过它，学习新编程语言的人可以弄清楚如何使用所需的工具来编译和运行该语言的程序。的确，[1.1
    HLA 程序的构成](ch01.html#the_anatomy_of_an_hla_program "1.1 HLA 程序的构成")中的*helloWorld*
    程序有助于演示一个简单的 HLA 程序的格式和语法，但像 *helloWorld* 这样的程序的真正目的是学习如何从头到尾创建和运行一个程序。尽管上一节介绍了
    HLA 程序的布局，但并未讨论如何编辑、编译和运行该程序。本节将简要介绍这些细节。
- en: All of the software you need to compile and run HLA programs can be found at
    [http://randallhyde.com/](http://randallhyde.com/) or at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/).
    Select **High Level Assembly** from the Quick Navigation Panel and then the Download
    HLA link from that page. HLA is currently available for Windows, Mac OS X, Linux,
    and FreeBSD. Download the appropriate version of the HLA software for your system.
    From the Download HLA web page, you will also be able to download all the software
    associated with this book. If the HLA download doesn't include them, you will
    probably want to download the HLA reference manual and the HLA Standard Library
    reference manual along with HLA and the software for this book. This text does
    not describe the entire HLA language, nor does it describe the entire HLA Standard
    Library. You'll want to have these reference manuals handy as you learn assembly
    language using HLA.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有需要编译和运行 HLA 程序的软件可以在 [http://randallhyde.com/](http://randallhyde.com/) 或
    [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) 找到。在快速导航面板中选择 **High
    Level Assembly**，然后从该页面选择下载 HLA 链接。HLA 目前可用于 Windows、Mac OS X、Linux 和 FreeBSD。下载适合你系统的
    HLA 软件版本。在 HLA 下载页面，你还可以下载与本书相关的所有软件。如果 HLA 下载包中没有包含这些内容，你可能需要下载 HLA 参考手册和 HLA
    标准库参考手册，连同 HLA 和本书的软件一起下载。本书并未描述整个 HLA 语言，也没有描述整个 HLA 标准库。在学习使用 HLA 的汇编语言时，最好随时准备好这些参考手册。
- en: This section will not describe how to install and set up the HLA system because
    those instructions change over time. The HLA download page for each of the operating
    systems describes how to install and use HLA. Please consult those instructions
    for the exact installation procedure.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本节不会描述如何安装和设置 HLA 系统，因为这些说明会随时间而变化。每个操作系统的 HLA 下载页面都会描述如何安装和使用 HLA。请查阅这些说明以获得准确的安装程序。
- en: Creating, compiling, and running an HLA program is very similar to the process
    you'd use when creating, compiling, or running a program in any computer language.
    First, because HLA is not an *integrated development environment (IDE)* that allows
    you to edit, compile, test and debug, and run your application all from within
    the same program, you'll create and edit HLA programs using a text editor.^([[1](#ftn.CHP-1-FN-1)])
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建、编译和运行 HLA 程序的过程与在任何计算机语言中创建、编译或运行程序的过程非常相似。首先，由于 HLA 不是一个*集成开发环境（IDE）*，不能在同一个程序中进行编辑、编译、测试、调试和运行应用程序，你将使用文本编辑器来创建和编辑
    HLA 程序。^([[1](#ftn.CHP-1-FN-1)])
- en: Windows, Mac OS X, Linux, and FreeBSD offer many text editor options. You can
    even use the text editor provided with other IDEs to create and edit HLA programs
    (such as those found in Visual C++, Borland's Delphi, Apple's Xcode, and similar
    languages). The only restriction is that HLA expects ASCII text files, so the
    editor you use must be capable of manipulating and saving text files. Under Windows
    you can always use Notepad to create HLA programs. If you're working under Linux
    and FreeBSD you can use joe, vi, or emacs. Under Mac OS X you can use XCode or
    Text Wrangler or another editor of your preference.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Windows、Mac OS X、Linux和FreeBSD提供了多种文本编辑器选项。你甚至可以使用其他IDE附带的文本编辑器来创建和编辑HLA程序（例如在Visual
    C++、Borland的Delphi、Apple的Xcode以及类似语言中找到的编辑器）。唯一的限制是HLA期望的是ASCII文本文件，因此你使用的编辑器必须能够处理并保存文本文件。在Windows下，你始终可以使用记事本来创建HLA程序。如果你在Linux或FreeBSD下工作，你可以使用joe、vi或emacs。在Mac
    OS X下，你可以使用XCode、Text Wrangler或你偏好的其他编辑器。
- en: 'The HLA compiler^([[2](#ftn.CHP-1-FN-2)]) is a traditional *command-line compiler*,
    which means that you need to run it from a Windows *command-line prompt* or a
    Linux/FreeBSD/Mac OS X *shell*. To do so, enter something like the following into
    the command-line prompt or shell window:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: HLA编译器^([[2](#ftn.CHP-1-FN-2)])是一个传统的*命令行编译器*，这意味着你需要从Windows的*命令行提示符*或Linux/FreeBSD/Mac
    OS X的*Shell*中运行它。为此，你需要在命令行提示符或Shell窗口中输入如下命令：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command tells HLA to compile the *hw.hla* (*helloWorld*) program to an
    executable file. Assuming there are no errors, you can run the resulting program
    by typing the following command into your command prompt window (Windows):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令告诉HLA将*hw.hla*（*helloWorld*）程序编译成可执行文件。如果没有错误，你可以通过在命令提示符窗口（Windows）中输入以下命令来运行生成的程序：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'or into the shell interpreter window (Linux/FreeBSD/Mac OS X):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者进入Shell解释器窗口（Linux/FreeBSD/Mac OS X）：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you're having problems getting the program to compile and run properly, please
    see the HLA installation instructions on the HLA download page. These instructions
    describe in great detail how to install, set up, and use HLA.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在编译和运行程序时遇到问题，请参阅HLA下载页面上的安装说明。这些说明详细描述了如何安装、设置和使用HLA。
- en: '* * *'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-1-FN-1)]) HIDE (HLA Integrated Development Environment) is an IDE
    available for Windows users. See the High Level Assembly web page for details
    on downloading HIDE.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-1-FN-1)]) HIDE（HLA集成开发环境）是一个适用于Windows用户的IDE。有关下载HIDE的详细信息，请参阅高级汇编语言（HLA）网页。
- en: ^([[2](#CHP-1-FN-2)]) Traditionally, programmers have always called translators
    for assembly languages *assemblers* rather than *compilers*. However, because
    of HLA's high-level features, it is more proper to call HLA a compiler rather
    than an assembler.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-1-FN-2)]) 传统上，程序员总是将汇编语言的翻译器称为*汇编器*，而不是*编译器*。然而，由于HLA具有高级特性，因此将HLA称为编译器而不是汇编器更为恰当。
- en: 1.3 Some Basic HLA Data Declarations
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3 一些基本的HLA数据声明
- en: HLA provides a wide variety of constant, type, and data declaration statements.
    Later chapters will cover the declaration sections in more detail, but it's important
    to know how to declare a few simple variables in an HLA program.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: HLA提供了各种常量、类型和数据声明语句。后续章节将更详细地讲解声明部分，但了解如何在HLA程序中声明一些简单的变量是很重要的。
- en: HLA predefines several different signed integer types including int8, int16,
    and int32, corresponding to 8-bit (1-byte) signed integers, 16-bit (2-byte) signed
    integers, and 32-bit (4-byte) signed integers, respectively.^([[3](#ftn.CHP-1-FN-3)])
    Typical variable declarations occur in the HLA *static variable section*. A typical
    set of variable declarations takes the form shown in [Figure 1-2](ch01s03.html#static_variable_declarations
    "Figure 1-2. Static variable declarations").
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: HLA预定义了几种不同的有符号整数类型，包括int8、int16和int32，分别对应8位（1字节）有符号整数、16位（2字节）有符号整数和32位（4字节）有符号整数。^([[3](#ftn.CHP-1-FN-3)])典型的变量声明发生在HLA的*静态变量部分*。一组典型的变量声明形式如[图1-2](ch01s03.html#static_variable_declarations
    "图1-2. 静态变量声明")所示。
- en: '![Static variable declarations](tagoreillycom20100401nostarchimages577857.png.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![静态变量声明](tagoreillycom20100401nostarchimages577857.png.jpg)'
- en: Figure 1-2. Static variable declarations
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-2. 静态变量声明
- en: 'Those who are familiar with the Pascal language should be comfortable with
    this declaration syntax. This example demonstrates how to declare three separate
    integers: `i8`, `i16`*,* and `i32`. Of course, in a real program you should use
    variable names that are more descriptive. While names like *i8* and *i32* describe
    the type of the object, they do not describe its purpose. Variable names should
    describe the purpose of the object.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉Pascal语言的人应该能轻松理解这种声明语法。此示例演示了如何声明三个独立的整数：`i8`、`i16` 和 `i32`。当然，在实际程序中，你应该使用更具描述性的变量名。像
    *i8* 和 *i32* 这样的名称虽然描述了对象的类型，但没有描述其用途。变量名应当描述对象的用途。
- en: In the *static declaration section*, you can also give a variable an initial
    value that the operating system will assign to the variable when it loads the
    program into memory. [Figure 1-3](ch01s03.html#static_variable_initialization
    "Figure 1-3. Static variable initialization") provides the syntax for this.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在*静态声明部分*，你还可以为变量赋初始值，操作系统将在程序加载到内存时将该初始值赋给变量。[图 1-3](ch01s03.html#static_variable_initialization
    "图 1-3. 静态变量初始化")提供了相关的语法。
- en: '![Static variable initialization](tagoreillycom20100401nostarchimages577859.png.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![静态变量初始化](tagoreillycom20100401nostarchimages577859.png.jpg)'
- en: Figure 1-3. Static variable initialization
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-3. 静态变量初始化
- en: It is important to realize that the expression following the assignment operator
    (`:=`) must be a constant expression. You cannot assign the values of other variables
    within a static variable declaration.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，在赋值运算符（`:=`）后面的表达式必须是常量表达式。你不能在静态变量声明中为其他变量赋值。
- en: Those familiar with other high-level languages (especially Pascal) should note
    that you can declare only one variable per statement. That is, HLA does not allow
    a comma-delimited list of variable names followed by a colon and a type identifier.
    Each variable declaration consists of a single identifier, a colon, a type ID,
    and a semicolon.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉其他高级语言（尤其是Pascal）的人应注意，你每个语句只能声明一个变量。也就是说，HLA不允许在一个声明中使用逗号分隔的变量名列表，后跟冒号和类型标识符。每个变量声明由一个标识符、一个冒号、一个类型标识符和一个分号组成。
- en: '[Example 1-2](ch01s03.html#variable_declaration_and_use "Example 1-2. Variable
    declaration and use") provides a simple HLA program that demonstrates the use
    of variables within an HLA program.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-2](ch01s03.html#variable_declaration_and_use "示例 1-2. 变量声明与使用")提供了一个简单的HLA程序，演示了在HLA程序中使用变量。'
- en: Example 1-2. Variable declaration and use
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-2. 变量声明与使用
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In addition to static variable declarations, this example introduces three new
    concepts. First, the `stdout.put` statement allows multiple parameters. If you
    specify an integer value, `stdout.put` will convert that value to its string representation
    on output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了静态变量声明外，此示例还引入了三个新概念。首先，`stdout.put`语句允许多个参数。如果你指定一个整数值，`stdout.put`会将该值转换为字符串表示并输出。
- en: The second new feature introduced in [Example 1-2](ch01s03.html#variable_declaration_and_use
    "Example 1-2. Variable declaration and use") is the `stdin.get` statement. This
    statement reads a value from the standard input device (usually the keyboard),
    converts the value to an integer, and stores the integer value into the `NotInitialized`
    variable. Finally, [Example 1-2](ch01s03.html#variable_declaration_and_use "Example 1-2. Variable
    declaration and use") also introduces the syntax for (one form of) HLA comments.
    The HLA compiler ignores all text from the `//` sequence to the end of the current
    line. (Those familiar with Java, C++, and Delphi should recognize these comments.)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 1-2](ch01s03.html#variable_declaration_and_use "示例 1-2. 变量声明与使用")中引入的第二个新特性是`stdin.get`语句。此语句从标准输入设备（通常是键盘）读取一个值，将该值转换为整数，并将整数值存储到`NotInitialized`变量中。最后，[示例
    1-2](ch01s03.html#variable_declaration_and_use "示例 1-2. 变量声明与使用")还介绍了（其中一种形式的）HLA注释的语法。HLA编译器会忽略从`//`序列到当前行末尾的所有文本。（熟悉Java、C++和Delphi的人应该能识别这些注释。）
- en: '* * *'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[3](#CHP-1-FN-3)]) A discussion of bits and bytes will appear in [Chapter 2](ch02.html
    "Chapter 2. DATA REPRESENTATION") for those who are unfamiliar with these terms.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-1-FN-3)]) 对于不熟悉这些术语的人，关于比特和字节的讨论将在[第2章](ch02.html "第2章. 数据表示")中出现。
- en: 1.4 Boolean Values
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.4 布尔值
- en: HLA and the HLA Standard Library provide limited support for boolean objects.
    You can declare boolean variables, use boolean literal constants, use boolean
    variables in boolean expressions, and you can print the values of boolean variables.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 和 HLA 标准库对布尔对象提供了有限的支持。你可以声明布尔变量，使用布尔字面常量，在布尔表达式中使用布尔变量，并且可以打印布尔变量的值。
- en: Boolean literal constants consist of the two predefined identifiers `true` and
    `false`. Internally, HLA represents the value true using the numeric value `1`;
    HLA represents false using the value `0`. Most programs treat `0` as false and
    anything else as true, so HLA's representations for true and false should prove
    sufficient.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔字面常量由两个预定义标识符 `true` 和 `false` 组成。HLA 内部用数值 `1` 表示真，`0` 表示假。大多数程序将 `0` 视为假，将其他任何值视为真，因此
    HLA 对真和假的表示应该足够。
- en: 'To declare a boolean variable, you use the `boolean` data type. HLA uses a
    single byte (the least amount of memory it can allocate) to represent boolean
    values. The following example demonstrates some typical declarations:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个布尔变量，你使用 `boolean` 数据类型。HLA 使用一个字节（它能分配的最小内存）来表示布尔值。以下示例演示了一些典型的声明：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As this example demonstrates, you can initialize boolean variables if you desire.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个示例所演示的，你可以在需要时初始化布尔变量。
- en: Because boolean variables are byte objects, you can manipulate them using any
    instructions that operate directly on 8-bit values. Furthermore, as long as you
    ensure that your boolean variables only contain `0` and `1` (for false and true,
    respectively), you can use the 80x86 `and`, `or`, `xor`, and `not` instructions
    to manipulate these boolean values (these instructions are covered in [Chapter 2](ch02.html
    "Chapter 2. DATA REPRESENTATION")).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因为布尔变量是字节对象，你可以使用任何直接操作 8 位值的指令来操作它们。此外，只要确保布尔变量只包含 `0` 和 `1`（分别表示假和真），你就可以使用
    80x86 的 `and`、`or`、`xor` 和 `not` 指令来操作这些布尔值（这些指令在[第 2 章](ch02.html "第 2 章 数据表示")中有介绍）。
- en: 'You can print boolean values by making a call to the `stdout.put` routine.
    For example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用 `stdout.put` 例程来打印布尔值。例如：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This routine prints the text `true` or `false` depending upon the value of the
    boolean parameter (`0` is false; anything else is true). Note that the HLA Standard
    Library does not allow you to read boolean values via `stdin.get`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例程会根据布尔参数的值打印 `true` 或 `false`（`0` 为假，其他值为真）。请注意，HLA 标准库不允许通过 `stdin.get`
    读取布尔值。
- en: 1.5 Character Values
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.5 字符值
- en: 'HLA lets you declare 1-byte ASCII character objects using the `char` data type.
    You may initialize character variables with a literal character value by surrounding
    the character with a pair of apostrophes. The following example demonstrates how
    to declare and initialize character variables in HLA:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 允许你使用 `char` 数据类型声明 1 字节的 ASCII 字符对象。你可以通过将字符值用一对撇号括起来来初始化字符变量。以下示例演示了如何在
    HLA 中声明和初始化字符变量：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can print character variables use the `stdout.put` routine, and you can
    read character variables using the `stdin.get` procedure call.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `stdout.put` 例程打印字符变量，也可以通过调用 `stdin.get` 过程来读取字符变量。
- en: 1.6 An Introduction to the Intel 80x86 CPU Family
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.6 英特尔 80x86 CPU 系列简介
- en: Thus far, you've seen a couple of HLA programs that will actually compile and
    run. However, all the statements appearing in programs to this point have been
    either data declarations or calls to HLA Standard Library routines. There hasn't
    been any *real* assembly language. Before we can progress any further and learn
    some real assembly language, a detour is necessary; unless you understand the
    basic structure of the Intel 80x86 CPU family, the machine instructions will make
    little sense.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看过几个实际可以编译和运行的 HLA 程序。然而，到目前为止，程序中出现的所有语句都只是数据声明或对 HLA 标准库例程的调用。还没有涉及任何*真正的*汇编语言。在我们进一步学习一些真正的汇编语言之前，有必要先绕个弯；除非你了解英特尔
    80x86 CPU 系列的基本结构，否则机器指令几乎没有意义。
- en: 'The Intel CPU family is generally classified as a *Von Neumann Architecture
    Machine*. Von Neumann computer systems contain three main building blocks: the
    *central processing unit (CPU)*, *memory*, and *input/output (I/0) devices*. These
    three components are interconnected using the *system bus* (consisting of the
    address, data, and control buses). The block diagram in [Figure 1-4](ch01s06.html#von_neumann_computer_system_block_diagra
    "Figure 1-4. Von Neumann computer system block diagram") shows this relationship.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Intel CPU 家族通常被归类为 *冯·诺依曼架构机器*。冯·诺依曼计算机系统包含三个主要组成部分：*中央处理单元（CPU）*、*内存* 和 *输入/输出（I/O）设备*。这三部分通过
    *系统总线*（由地址总线、数据总线和控制总线组成）互联。[图 1-4](ch01s06.html#von_neumann_computer_system_block_diagra
    "图 1-4. 冯·诺依曼计算机系统框图") 显示了这种关系。
- en: The CPU communicates with memory and I/O devices by placing a numeric value
    on the address bus to select one of the memory locations or I/O device port locations,
    each of which has a unique binary numeric *address*. Then the CPU, memory, and
    I/O devices pass data among themselves by placing the data on the data bus. The
    control bus contains signals that determine the direction of the data transfer
    (to/from memory and to/from an I/O device).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 通过将一个数值放置在地址总线上，来与内存和 I/O 设备进行通信，从而选择一个内存位置或 I/O 设备端口位置，每个位置都有一个唯一的二进制数值
    *地址*。然后，CPU、内存和 I/O 设备通过将数据放置在数据总线上相互传递数据。控制总线包含决定数据传输方向（到/从内存以及到/从 I/O 设备）的信号。
- en: '![Von Neumann computer system block diagram](tagoreillycom20100401nostarchimages577861.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![冯·诺依曼计算机系统框图](tagoreillycom20100401nostarchimages577861.png)'
- en: Figure 1-4. Von Neumann computer system block diagram
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-4. 冯·诺依曼计算机系统框图
- en: 'The 80x86 CPU registers can be broken down into four categories: general-purpose
    registers, special-purpose application-accessible registers, segment registers,
    and special-purpose kernel-mode registers. Because the segment registers aren''t
    used much in modern 32-bit operating systems (such as Windows, Mac OS X, FreeBSD,
    and Linux) and because this text is geared to writing programs written for 32-bit
    operating systems, there is little need to discuss the segment registers. The
    special-purpose kernel-mode registers are intended for writing operating systems,
    debuggers, and other system-level tools. Such software construction is well beyond
    the scope of this text.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 CPU 寄存器可以分为四类：通用寄存器、特殊用途应用程序可访问的寄存器、段寄存器和特殊用途内核模式寄存器。由于段寄存器在现代 32 位操作系统（如
    Windows、Mac OS X、FreeBSD 和 Linux）中使用较少，并且本书的内容主要针对为 32 位操作系统编写的程序，因此不需要过多讨论段寄存器。特殊用途的内核模式寄存器是用于编写操作系统、调试器及其他系统级工具的。这类软件构建超出了本书的范围。
- en: 'The 80x86 (Intel family) CPUs provide several general-purpose registers for
    application use. These include eight 32-bit registers that have the following
    names: EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86（Intel 家族）CPU 提供了多个通用寄存器供应用程序使用。其中包括八个 32 位寄存器，名称分别为：EAX、EBX、ECX、EDX、ESI、EDI、EBP
    和 ESP。
- en: 'The *E* prefix on each name stands for *extended*. This prefix differentiates
    the 32-bit registers from the eight 16-bit registers that have the following names:
    AX, BX, CX, DX, SI, DI, BP, and SP.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个名称前的 *E* 前缀表示 *扩展*。这个前缀将 32 位寄存器与八个 16 位寄存器区分开来，后者的名称分别为：AX、BX、CX、DX、SI、DI、BP
    和 SP。
- en: 'Finally, the 80x86 CPUs provide eight 8-bit registers that have the following
    names: AL, AH, BL, BH, CL, CH, DL, and DH.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，80x86 CPU 提供了八个 8 位寄存器，名称分别为：AL、AH、BL、BH、CL、CH、DL 和 DH。
- en: Unfortunately, these are not all separate registers. That is, the 80x86 does
    not provide 24 independent registers. Instead, the 80x86 overlays the 32-bit registers
    with the 16-bit registers, and it overlays the 16-bit registers with the 8-bit
    registers. [Figure 1-5](ch01s06.html#x86_open_parenthesis_intel_cpu_close_par
    "Figure 1-5. 80x86 (Intel CPU) general-purpose registers") shows this relationship.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这些并不是完全独立的寄存器。也就是说，80x86 并没有提供 24 个独立的寄存器。相反，80x86 使用 32 位寄存器覆盖 16 位寄存器，并且使用
    16 位寄存器覆盖 8 位寄存器。[图 1-5](ch01s06.html#x86_open_parenthesis_intel_cpu_close_par
    "图 1-5. 80x86（Intel CPU）通用寄存器") 展示了这种关系。
- en: The most important thing to note about the general-purpose registers is that
    they are not independent. Modifying one register may modify as many as three other
    registers. For example, modification of the EAX register may very well modify
    the AL, AH, and AX registers. This fact cannot be overemphasized here. A very
    common mistake in programs written by beginning assembly language programmers
    is register value corruption because the programmer did not completely understand
    the ramifications of the relationship shown in [Figure 1-5](ch01s06.html#x86_open_parenthesis_intel_cpu_close_par
    "Figure 1-5. 80x86 (Intel CPU) general-purpose registers").
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于通用寄存器，最重要的一点是它们不是独立的。修改一个寄存器可能会修改最多三个其他寄存器。例如，修改 EAX 寄存器可能会影响 AL、AH 和 AX 寄存器。这个事实在这里必须特别强调。初学汇编语言的程序员常犯的一个错误是寄存器值被破坏，因为程序员没有完全理解
    [图 1-5](ch01s06.html#x86_open_parenthesis_intel_cpu_close_par "图 1-5. 80x86 (Intel
    CPU) 通用寄存器") 中显示的关系。
- en: '![80x86 (Intel CPU) general-purpose registers](tagoreillycom20100401nostarchimages577863.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![80x86 (Intel CPU) 通用寄存器](tagoreillycom20100401nostarchimages577863.png)'
- en: Figure 1-5. 80x86 (Intel CPU) general-purpose registers
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-5. 80x86 (Intel CPU) 通用寄存器
- en: The EFLAGS register is a 32-bit register that encapsulates several single-bit
    boolean (true/false) values. Most of the bits in the EFLAGS register are either
    reserved for kernel mode (operating system) functions or are of little interest
    to the application programmer. Eight of these bits (or *flags*) are of interest
    to application programmers writing assembly language programs. These are the overflow,
    direction, interrupt disable,^([[4](#ftn.CHP-1-FN-4)]) sign, zero, auxiliary carry,
    parity, and carry flags. [Figure 1-6](ch01s06.html#layout_of_the_flags_register_open_parent
    "Figure 1-6. Layout of the FLAGS register (lower 16 bits of EFLAGS)") shows the
    layout of the flags within the lower 16 bits of the EFLAGS register.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: EFLAGS 寄存器是一个 32 位寄存器，封装了多个单比特布尔值（真/假）。EFLAGS 寄存器中的大部分位要么是为内核模式（操作系统）功能保留的，要么对于应用程序员来说并不重要。其中特别有意义的八个比特（或称为*标志*）是应用程序员编写汇编语言程序时需要关注的。这些标志包括溢出、方向、禁止中断、符号、零、辅助进位、奇偶和进位标志。[图
    1-6](ch01s06.html#layout_of_the_flags_register_open_parent "图 1-6. EFLAGS 寄存器的布局（EFLAGS
    寄存器的低 16 位）") 展示了这些标志在 EFLAGS 寄存器低 16 位中的布局。
- en: '![Layout of the FLAGS register (lower 16 bits of EFLAGS)](tagoreillycom20100401nostarchimages577865.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![EFLAGS 寄存器的布局（EFLAGS 寄存器的低 16 位）](tagoreillycom20100401nostarchimages577865.png)'
- en: Figure 1-6. Layout of the FLAGS register (lower 16 bits of EFLAGS)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-6. EFLAGS 寄存器的布局（EFLAGS 寄存器的低 16 位）
- en: 'Of the eight flags that are of interest to application programmers, four flags
    in particular are extremely valuable: the overflow, carry, sign, and zero flags.
    Collectively, we will call these four flags the *condition codes*.^([[5](#ftn.CHP-1-FN-5)])
    The state of these flags lets you test the result of previous computations. For
    example, after comparing two values, the condition code flags will tell you whether
    one value is less than, equal to, or greater than a second value.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在八个对应用程序员有意义的标志中，尤其有四个标志是极为重要的：溢出、进位、符号和零标志。我们统称这四个标志为*条件码*。[图 1-5](#ftn.CHP-1-FN-5)
    这些标志的状态可以让你测试之前计算的结果。例如，在比较两个值之后，条件码标志会告诉你第一个值是否小于、等于或大于第二个值。
- en: One important fact that comes as a surprise to those just learning assembly
    language is that almost all calculations on the 80x86 CPU involve a register.
    For example, to add two variables together, storing the sum into a third variable,
    you must load one of the variables into a register, add the second operand to
    the value in the register, and then store the register away in the destination
    variable. Registers are a middleman in nearly every calculation. Therefore, registers
    are very important in 80x86 assembly language programs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚学习汇编语言的人来说，有一个重要的事实可能会让人感到惊讶，那就是几乎所有在 80x86 CPU 上的计算都涉及寄存器。例如，为了将两个变量相加并将结果存储到第三个变量中，你必须将其中一个变量加载到寄存器中，将第二个操作数加到寄存器中的值，然后将寄存器的值存储到目标变量中。寄存器几乎在每个计算中都充当中介。因此，寄存器在
    80x86 汇编语言程序中非常重要。
- en: Another thing you should be aware of is that although the registers have the
    name "general purpose," you should not infer that you can use any register for
    any purpose. All the 80x86 registers have their own special purposes that limit
    their use in certain contexts. The SP/ESP register pair, for example, has a very
    special purpose that effectively prevents you from using it for anything else
    (it's the *stack pointer*). Likewise, the BP/EBP register has a special purpose
    that limits its usefulness as a general-purpose register. For the time being,
    you should avoid the use of the ESP and EBP registers for generic calculations;
    also, keep in mind that the remaining registers are not completely interchangeable
    in your programs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事情是，尽管寄存器被称为“通用寄存器”，但你不应推断出可以将任何寄存器用于任何目的。所有80x86寄存器都有自己的特殊用途，这限制了它们在某些上下文中的使用。例如，SP/ESP寄存器对有一个非常特殊的用途，实际上阻止你将其用于其他任何事情（它是*栈指针*）。同样，BP/EBP寄存器也有一个特殊的用途，这限制了它作为通用寄存器的有效性。目前，你应该避免在通用计算中使用ESP和EBP寄存器；另外，请记住，剩余的寄存器在程序中并不是完全可以互换的。
- en: '* * *'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[4](#CHP-1-FN-4)]) Application programs cannot modify the interrupt flag,
    but we'll look at this flag in [Chapter 2](ch02.html "Chapter 2. DATA REPRESENTATION");
    hence the discussion of this flag here.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-1-FN-4)]) 应用程序无法修改中断标志，但我们将在[第2章](ch02.html "第2章. 数据表示")中查看该标志；因此，这里会讨论该标志。
- en: ^([[5](#CHP-1-FN-5)]) Technically the parity flag is also a condition code,
    but we will not use that flag in this text.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#CHP-1-FN-5)]) 从技术上讲，奇偶标志也是一种状态码，但在本文中我们不会使用该标志。
- en: 1.7 The Memory Subsystem
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.7 内存子系统
- en: A typical 80x86 processor running a modern 32-bit OS can access a maximum of
    2^(32) different memory locations, or just over 4 billion bytes. A few years ago,
    4 gigabytes of memory would have seemed like infinity; modern machines, however,
    exceed this limit. Nevertheless, because the 80x86 architecture supports a maximum
    4GB address space when using a 32-bit operating system like Windows, Mac OS X,
    FreeBSD, or Linux, the following discussion will assume the 4GB limit.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一台运行现代32位操作系统的典型80x86处理器可以访问最多2^(32)个不同的内存位置，即超过40亿字节。几年前，4GB内存看起来就像是无限；然而，现代计算机已经超过了这一限制。尽管如此，由于80x86架构在使用像Windows、Mac
    OS X、FreeBSD或Linux等32位操作系统时支持最大4GB的地址空间，以下讨论将假设4GB的限制。
- en: Of course, the first question you should ask is, "What exactly is a memory location?"
    The 80x86 supports *byte-addressable memory*. Therefore, the basic memory unit
    is a byte, which is sufficient to hold a single character or a (very) small integer
    value (we'll talk more about that in [Chapter 2](ch02.html "Chapter 2. DATA REPRESENTATION")).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你首先应该问的问题是，“什么是内存位置？”80x86支持*字节可寻址内存*。因此，基本的内存单元是字节，足以存储单个字符或一个（非常）小的整数值（我们将在[第2章](ch02.html
    "第2章. 数据表示")中详细讨论）。
- en: 'Think of memory as a linear array of bytes. The address of the first byte is
    0 and the address of the last byte is 2^(32)−1\. For an 80x86 processor, the following
    pseudo-Pascal array declaration is a good approximation of memory:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 把内存想象成一个线性字节数组。第一个字节的地址是0，最后一个字节的地址是2^(32)−1。对于80x86处理器，以下伪Pascal数组声明是内存的一个良好近似：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'C/C++ and Java users might prefer the following syntax:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++和Java用户可能更喜欢以下语法：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To execute the equivalent of the Pascal statement `Memory [125] := 0;` the CPU
    places the value 0 on the data bus, places the address 125 on the address bus,
    and asserts the write line (this generally involves setting that line to 0), as
    shown in [Figure 1-7](ch01s07.html#memory_write_operation "Figure 1-7. Memory
    write operation").
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行等同于Pascal语句`Memory [125] := 0;`的操作，CPU将值0放到数据总线上，将地址125放到地址总线上，并激活写线（这通常涉及将该线路设置为0），如[图1-7](ch01s07.html#memory_write_operation
    "图1-7. 内存写入操作")所示。
- en: '![Memory write operation](tagoreillycom20100401nostarchimages577867.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![内存写入操作](tagoreillycom20100401nostarchimages577867.png)'
- en: Figure 1-7. Memory write operation
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-7. 内存写入操作
- en: To execute the equivalent of `CPU := Memory [125];` the CPU places the address
    125 on the address bus, asserts the read line (because the CPU is reading data
    from memory), and then reads the resulting data from the data bus (see [Figure 1-8](ch01s07.html#memory_read_operation
    "Figure 1-8. Memory read operation")).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行等同于`CPU := Memory [125];`的操作，CPU会将地址125放到地址总线上，激活读线（因为CPU正在从内存读取数据），然后从数据总线读取结果数据（见[图1-8](ch01s07.html#memory_read_operation
    "图1-8. 内存读取操作")）。
- en: '![Memory read operation](tagoreillycom20100401nostarchimages577869.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![内存读取操作](tagoreillycom20100401nostarchimages577869.png)'
- en: Figure 1-8. Memory read operation
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-8. 内存读取操作
- en: This discussion applies *only* when accessing a single byte in memory. So what
    happens when the processor accesses a word or a double word? Because memory consists
    of an array of bytes, how can we possibly deal with values larger than a single
    byte? Easy—to store larger values, the 80x86 uses a sequence of consecutive memory
    locations. [Figure 1-9](ch01s07.html#byte_comma_word_comma_and_double-word_st
    "Figure 1-9. Byte, word, and double-word storage in memory") shows how the 80x86
    stores bytes, words (2 bytes), and double words (4 bytes) in memory. The memory
    address of each of these objects is the address of the first byte of each object
    (that is, the lowest address).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个讨论*仅*适用于访问内存中的单个字节。那么当处理器访问字或双字时会发生什么呢？由于内存是由字节数组构成的，那么我们如何处理大于单字节的值呢？很简单——为了存储更大的值，80x86
    使用一系列连续的内存位置。[图 1-9](ch01s07.html#byte_comma_word_comma_and_double-word_st "图
    1-9. 内存中的字节、字和双字存储") 展示了 80x86 如何在内存中存储字节、字（2 字节）和双字（4 字节）。每个这些对象的内存地址是每个对象第一个字节的地址（即最低地址）。
- en: Modern 80x86 processors don't actually connect directly to memory. Instead,
    there is a special memory buffer on the CPU known as the *cache* (pronounced "cash")
    that acts as a high-speed intermediary between the CPU and main memory. Although
    the cache handles the details automatically for you, one fact you should know
    is that accessing data objects in memory is sometimes more efficient if the address
    of the object is an even multiple of the object's size. Therefore, it's a good
    idea to *align* 4-byte objects (double words) on addresses that are multiples
    of 4\. Likewise, it's most efficient to align 2-byte objects on even addresses.
    You can efficiently access single-byte objects at any address. You'll see how
    to set the alignment of memory objects in [3.4 HLA Support for Data Alignment](ch03s04.html
    "3.4 HLA Support for Data Alignment").
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现代的 80x86 处理器并不直接连接到内存。相反，CPU 上有一个特殊的内存缓冲区，称为 *缓存*（发音为“cash”），它充当 CPU 和主内存之间的高速中介。尽管缓存自动为你处理了这些细节，但你应该知道的一个事实是，如果对象的地址是该对象大小的偶数倍，访问内存中的数据对象有时会更加高效。因此，最好将
    4 字节的对象（双字）对齐到 4 的倍数地址。同样，将 2 字节的对象对齐到偶数地址是最有效的。你可以在任何地址高效访问单字节对象。你将在[3.4 HLA
    数据对齐支持](ch03s04.html "3.4 HLA 支持数据对齐")中了解如何设置内存对象的对齐方式。
- en: '![Byte, word, and double-word storage in memory](tagoreillycom20100401nostarchimages577871.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![字节、字和双字存储在内存中的方式](tagoreillycom20100401nostarchimages577871.png)'
- en: Figure 1-9. Byte, word, and double-word storage in memory
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-9. 内存中的字节、字和双字存储
- en: 'Before leaving this discussion of memory objects, it''s important to understand
    the correspondence between memory and HLA variables. One of the nice things about
    using an assembler/compiler like HLA is that you don''t have to worry about numeric
    memory addresses. All you need to do is declare a variable in HLA, and HLA takes
    care of associating that variable with some unique set of memory addresses. For
    example, if you have the following declaration section:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论内存对象之前，理解内存与 HLA 变量之间的对应关系非常重要。使用像 HLA 这样的汇编器/编译器的一个好处是，你不需要担心数字内存地址。你所需要做的就是在
    HLA 中声明一个变量，HLA 会自动将该变量与一组唯一的内存地址关联起来。例如，如果你有以下的声明部分：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: HLA will find some unused 8-bit byte in memory and associate it with the `i8`
    variable; it will find a pair of consecutive unused bytes and associate `i16`
    with them; finally, HLA will find 4 consecutive unused bytes and associate the
    value of `i32` with those 4 bytes (32 bits). You'll always refer to these variables
    by their name. You generally don't have to concern yourself with their numeric
    address. Still, you should be aware that HLA is doing this for you behind your
    back.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 会在内存中找到一些未使用的 8 位字节，并将其与 `i8` 变量关联；它会找到一对连续的未使用字节，并将 `i16` 与它们关联；最后，HLA
    会找到 4 个连续的未使用字节，并将 `i32` 的值与这 4 个字节（32 位）关联。你将始终通过这些变量的名称来引用它们。通常，你不需要关心它们的数字地址。不过，你应该知道
    HLA 在幕后为你完成了这些操作。
- en: 1.8 Some Basic Machine Instructions
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.8 一些基本的机器指令
- en: The 80x86 CPU family provides from just over a hundred to many thousands of
    different machine instructions, depending on how you define a machine instruction.
    Even at the low end of the count (greater than 100), it appears as though there
    are far too many machine instructions to learn in a short time. Fortunately, you
    don't need to know all the machine instructions. In fact, most assembly language
    programs probably use around 30 different machine instructions.^([[6](#ftn.CHP-1-FN-6)])
    Indeed, you can certainly write several meaningful programs with only a few machine
    instructions. The purpose of this section is to provide a small handful of machine
    instructions so you can start writing simple HLA assembly language programs right
    away.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 CPU 系列提供了从一百多条到几千条不同的机器指令，具体数量取决于你如何定义机器指令。即便是在指令数量较少的一端（大于 100），似乎也有太多指令需要在短时间内学习。幸运的是，你不需要知道所有的机器指令。事实上，大多数汇编语言程序可能只使用大约
    30 条不同的机器指令。^([[6](#ftn.CHP-1-FN-6)]) 确实，你完全可以用几条机器指令编写几个有意义的程序。本节的目的是提供少量机器指令，让你能够立即开始编写简单的
    HLA 汇编语言程序。
- en: 'Without question, the `mov` instruction is the most oft-used assembly language
    statement. In a typical program, anywhere from 25 percent to 40 percent of the
    instructions are `mov` instructions. As its name suggests, this instruction moves
    data from one location to another.^([[7](#ftn.CHP-1-FN-7)]) The HLA syntax for
    this instruction is:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸置疑，`mov` 指令是最常用的汇编语言语句。在一个典型的程序中，25% 到 40% 的指令都是 `mov` 指令。正如其名称所示，这条指令将数据从一个位置移动到另一个位置。^([[7](#ftn.CHP-1-FN-7)])
    该指令的 HLA 语法是：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The *`source_operand`* can be a register, a memory variable, or a constant.
    The *`destination_operand`* may be a register or a memory variable. Technically
    the 80x86 instruction set does not allow both operands to be memory variables.
    HLA, however, will automatically translate a `mov` instruction with two-word or
    double-word memory operands into a pair of instructions that will copy the data
    from one location to another. In a high-level language like Pascal or C/C++, the
    `mov` instruction is roughly equivalent to the following assignment statement:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*`source_operand`* 可以是寄存器、内存变量或常量。*`destination_operand`* 可以是寄存器或内存变量。严格来说，80x86
    指令集不允许两个操作数都为内存变量。然而，HLA 会自动将两个字或双字内存操作数的 `mov` 指令转换为一对指令，从一个位置复制数据到另一个位置。在像 Pascal
    或 C/C++ 这样的高级语言中，`mov` 指令大致相当于以下赋值语句：'
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Perhaps the major restriction on the `mov` instruction's operands is that they
    must both be the same size. That is, you can move data between a pair of byte
    (8-bit) objects, word (16-bit) objects, or double-word (32-bit) objects; you may
    not, however, mix the sizes of the operands. [Table 1-1](ch01s08.html#legal_80x86_mov_instruction_operands
    "Table 1-1. Legal 80x86 mov Instruction Operands") lists all the legal combinations
    for the `mov` instruction.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 或许 `mov` 指令操作数的主要限制是它们必须具有相同的大小。也就是说，你可以在一对字节（8 位）、字（16 位）或双字（32 位）对象之间移动数据；但是，你不能混合操作数的大小。[表
    1-1](ch01s08.html#legal_80x86_mov_instruction_operands "表 1-1. 合法的 80x86 mov 指令操作数")
    列出了所有 `mov` 指令的合法组合。
- en: You should study this table carefully because most of the general-purpose 80x86
    instructions use this syntax.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该仔细研究这张表，因为大多数通用 80x86 指令都使用这种语法。
- en: Table 1-1. Legal 80x86 `mov` Instruction Operands
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-1. 合法的 80x86 `mov` 指令操作数
- en: '| Source | Destination |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 源 | 目标 |'
- en: '| --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Reg[8]^([[a](#ftn.CHP-1-TFN-1)]) | Reg[8] |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| Reg[8]^([[a](#ftn.CHP-1-TFN-1)]) | Reg[8] |'
- en: '| Reg[8] | Mem[8] |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| Reg[8] | Mem[8] |'
- en: '| Mem[8] | Reg[8] |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| Mem[8] | Reg[8] |'
- en: '| Constant^([[b](#ftn.CHP-1-TFN-2)]) | Reg[8] |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 常量^([[b](#ftn.CHP-1-TFN-2)]) | Reg[8] |'
- en: '| Constant | Mem[8] |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | Mem[8] |'
- en: '| Reg[16] | Reg[16] |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| Reg[16] | Reg[16] |'
- en: '| Reg[16] | Mem[16] |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| Reg[16] | Mem[16] |'
- en: '| Mem[16] | Reg[16] |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| Mem[16] | Reg[16] |'
- en: '| Constant | Reg[16] |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | Reg[16] |'
- en: '| Constant | Mem[16] |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | Mem[16] |'
- en: '| Reg[32] | Reg[32] |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| Reg[32] | Reg[32] |'
- en: '| Reg[32] | Mem[32] |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| Reg[32] | Mem[32] |'
- en: '| Mem[32] | Reg[32] |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| Mem[32] | Reg[32] |'
- en: '| Constant | Reg[32] |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | Reg[32] |'
- en: '| Constant | Mem[32] |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | Mem[32] |'
- en: '|'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: ^([[a](#CHP-1-TFN-1)]) The suffix denotes the size of the register or memory
    location.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[a](#CHP-1-TFN-1)]) 后缀表示寄存器或内存位置的大小。
- en: ^([[b](#CHP-1-TFN-2)]) The constant must be small enough to fit in the specified
    destination operand.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[b](#CHP-1-TFN-2)]) 常量必须足够小，以适应指定的目标操作数。
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'The 80x86 `add` and `sub` instructions let you add and subtract two operands.
    Their syntax is nearly identical to the `mov` instruction:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86的`add`和`sub`指令允许你进行加法和减法操作。它们的语法与`mov`指令几乎完全相同：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `add` and `sub` operands take the same form as the `mov` instruction.^([[8](#ftn.CHP-1-FN-8)])
    The `add` instruction does the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`和`sub`操作数的格式与`mov`指令完全相同。^([[8](#ftn.CHP-1-FN-8)]) `add`指令执行以下操作：'
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `sub` instruction does the calculation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub`指令执行计算：'
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With nothing more than these three instructions, plus the HLA control structures
    that the next section discusses, you can actually write some sophisticated programs.
    [Example 1-3](ch01s08.html#demonstration_of_the_mov_comma_add_comma "Example 1-3. Demonstration
    of the mov, add, and sub instructions") provides a sample HLA program that demonstrates
    these three instructions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭这三条指令，再加上下一节讨论的HLA控制结构，你实际上就可以编写一些复杂的程序。[示例1-3](ch01s08.html#demonstration_of_the_mov_comma_add_comma
    "示例1-3. mov、add和sub指令演示")提供了一个HLA程序示例，展示了这三条指令。
- en: Example 1-3. Demonstration of the `mov`, `add`, and `sub` instructions
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-3. `mov`、`add`和`sub`指令演示
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '* * *'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[6](#CHP-1-FN-6)]) Different programs may use a different set of 30 instructions,
    but few programs use more than 30 distinct instructions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[6](#CHP-1-FN-6)]) 不同的程序可能会使用不同的30条指令，但很少有程序会使用超过30条不同的指令。
- en: ^([[7](#CHP-1-FN-7)]) Technically, `mov` actually copies data from one location
    to another. It does not destroy the original data in the source operand. Perhaps
    a better name for this instruction would have been `copy`. Alas, it's too late
    to change it now.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[7](#CHP-1-FN-7)]) 从技术上讲，`mov`实际上是将数据从一个位置复制到另一个位置。它并不会销毁源操作数中的原始数据。也许这个指令应该叫做`copy`会更好。可惜现在已经太晚了，无法更改它了。
- en: ^([[8](#CHP-1-FN-8)]) Remember, though, that `add` and `sub` do not support
    memory-to-memory operations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[8](#CHP-1-FN-8)]) 但请记住，`add`和`sub`不支持内存到内存的操作。
- en: 1.9 Some Basic HLA Control Structures
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.9 一些基本的HLA控制结构
- en: The `mov`, `add`, and `sub` instructions, while valuable, aren't sufficient
    to let you write meaningful programs. You will need to complement these instructions
    with the ability to make decisions and create loops in your HLA programs before
    you can write anything other than a simple program. HLA provides several high-level
    control structures that are very similar to control structures found in high-level
    languages. These include `if..then..elseif..else..endif`, `while..endwhile`, `repeat..until`,
    and so on. By learning these statements you will be armed and ready to write some
    real programs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov`、`add`和`sub`指令虽然很有用，但它们不足以让你编写有意义的程序。在你能够编写复杂程序之前，你还需要具备做决策和创建循环的能力，HLA提供了几种高级控制结构，这些控制结构与高级语言中的控制结构非常相似，包括`if..then..elseif..else..endif`、`while..endwhile`、`repeat..until`等。通过学习这些指令，你将能够准备好编写一些真正的程序。'
- en: Before discussing these high-level control structures, it's important to point
    out that these are not real 80x86 assembly language statements. HLA compiles these
    statements into a sequence of one or more real assembly language statements for
    you. In [Chapter 7](ch07.html "Chapter 7. LOW-LEVEL CONTROL STRUCTURES"), you'll
    learn how HLA compiles the statements, and you'll learn how to write pure assembly
    language code that doesn't use them. However, there is a lot to learn before you
    get to that point, so we'll stick with these high-level language statements for
    now.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论这些高级控制结构之前，首先需要指出的是，这些并不是实际的80x86汇编语言指令。HLA会将这些指令编译成一系列一个或多个真实的汇编语言指令。在[第7章](ch07.html
    "第7章. 低级控制结构")中，你将学习HLA如何编译这些指令，并且你将学习如何编写不使用这些指令的纯汇编语言代码。不过，在你学到这些之前，还有很多内容需要学习，因此我们现在将继续使用这些高级语言指令。
- en: Another important fact to mention is that HLA's high-level control structures
    are *not* as high level as they first appear. The purpose behind HLA's high-level
    control structures is to let you start writing assembly language programs as quickly
    as possible, not to let you avoid the use of assembly language altogether. You
    will soon discover that these statements have some severe restrictions associated
    with them, and you will quickly outgrow their capabilities. This is intentional.
    Once you reach a certain level of comfort with HLA's high-level control structures
    and decide you need more power than they have to offer, it's time to move on and
    learn the real 80x86 instructions behind these statements.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要提到的重要事实是，HLA 的高级控制结构*并不像它们最初看起来的那么高级*。HLA 高级控制结构的目的是让你尽可能快速地开始编写汇编语言程序，而不是让你完全避免使用汇编语言。你很快会发现，这些语句有一些严重的限制，并且你很快会超出它们的能力。这是故意的。一旦你对
    HLA 的高级控制结构有了足够的了解，并且决定你需要比它们提供的更多的功能，那么是时候转向学习这些语句背后的真正 80x86 指令了。
- en: Do not let the presence of high-level-like statements in HLA confuse you. Many
    people, after learning about the presence of these statements in the HLA language,
    erroneously come to the conclusion that HLA is just some special high-level language
    and not a true assembly language. This isn't true. HLA is a full low-level assembly
    language. HLA supports all the same machine instructions as any other 80x86 assembler.
    The difference is that HLA has some *extra* statements that allow you to do *more*
    than is possible with those other 80x86 assemblers. Once you learn 80x86 assembly
    language with HLA, you may elect to ignore all these extra (high-level) statements
    and write only low-level 80x86 assembly language code if this is your desire.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让 HLA 中出现的类似高级语言的语句让你感到困惑。许多人在了解这些语句在 HLA 语言中出现后，错误地得出结论，认为 HLA 只是某种特殊的高级语言，而不是一种真正的汇编语言。这不是真的。HLA
    是一种完整的低级汇编语言。HLA 支持与其他 80x86 汇编器相同的所有机器指令。不同之处在于，HLA 有一些*额外*的语句，允许你做一些比其他 80x86
    汇编器更多的事情。一旦你使用 HLA 学会了 80x86 汇编语言，你可以选择忽略所有这些额外的（高级）语句，只编写低级的 80x86 汇编语言代码，如果这是你的需求。
- en: The following sections assume that you're familiar with at least one high-level
    language. They present the HLA control statements from that perspective without
    bothering to explain how you actually use these statements to accomplish something
    in a program. One prerequisite this text assumes is that you already know how
    to use these generic control statements in a high-level language; you'll use them
    in HLA programs in an identical manner.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节假设你至少熟悉一种高级语言。它们从这个角度介绍 HLA 控制语句，而不去解释如何在程序中实际使用这些语句来完成任务。本文假设的一个前提条件是，你已经知道如何在高级语言中使用这些通用控制语句；你将以相同的方式在
    HLA 程序中使用它们。
- en: 1.9.1 Boolean Expressions in HLA Statements
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.9.1 HLA 语句中的布尔表达式
- en: Several HLA statements require a boolean (true or false) expression to control
    their execution. Examples include the `if`, `while`, and `repeat..until` statements.
    The syntax for these boolean expressions represents the greatest limitation of
    the HLA high-level control structures. This is one area where your familiarity
    with a high-level language will work against you—you'll want to use the fancy
    expressions you use in a high-level language, yet HLA supports only some basic
    forms.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 HLA 语句需要布尔（真或假）表达式来控制它们的执行。例如，`if`、`while` 和 `repeat..until` 语句。对于这些布尔表达式的语法，代表了
    HLA 高级控制结构的最大限制。这是你对高级语言的熟悉度会对你不利的一个地方——你会想要使用在高级语言中常用的复杂表达式，而 HLA 只支持一些基本形式。
- en: HLA boolean expressions take the following forms:^([[9](#ftn.CHP-1-FN-9)])
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 布尔表达式的形式如下：^([[9](#ftn.CHP-1-FN-9)])
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A `flag_specification` may be one of the symbols that are described in [Table 1-2](ch01s09.html#symbols_for_flag_underscore_specificatio
    "Table 1-2. Symbols for flag_specification").
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`flag_specification` 可能是[表1-2](ch01s09.html#symbols_for_flag_underscore_specificatio
    "表1-2. 标志符号")中描述的符号之一。'
- en: Table 1-2. Symbols for `flag_specification`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-2. `flag_specification` 符号
- en: '| Symbol | Meaning | Explanation |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 含义 | 解释 |'
- en: '| --- | --- | --- |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `@c` | Carry | True if the carry is set (1); false if the carry is clear
    (0). |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `@c` | 进位 | 如果进位设置（1），则为真；如果进位清除（0），则为假。 |'
- en: '| `@nc` | No carry | True if the carry is clear (0); false if the carry is
    set (1). |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `@nc` | 无进位 | 如果进位清除（0），则为真；如果进位设置（1），则为假。 |'
- en: '| `@z` | Zero | True if the zero flag is set; false if it is clear. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `@z` | 零 | 如果零标志设置，则为真；如果零标志未设置，则为假。 |'
- en: '| `@nz` | Not zero | True if the zero flag is clear; false if it is set. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `@nz` | 非零 | 如果零标志未设置，则为真；如果零标志设置，则为假。 |'
- en: '| `@o` | Overflow | True if the overflow flag is set; false if it is clear.
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `@o` | 溢出 | 如果溢出标志设置，则为真；如果溢出标志未设置，则为假。 |'
- en: '| `@no` | No overflow | True if the overflow flag is clear; false if it is
    set. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `@no` | 无溢出 | 如果溢出标志未设置，则为真；如果溢出标志设置，则为假。 |'
- en: '| `@s` | Sign | True if the sign flag is set; false if it is clear. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `@s` | 有符号 | 如果符号标志设置，则为真；如果符号标志未设置，则为假。 |'
- en: '| `@ns` | No sign | True if the sign flag is clear; false if it is set. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `@ns` | 无符号 | 如果符号标志未设置，则为真；如果符号标志设置，则为假。 |'
- en: The use of the flag values in a boolean expression is somewhat advanced. You
    will begin to see how to use these boolean expression operands in the next chapter.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在布尔表达式中使用标志值是相对高级的内容。你将在下一章看到如何使用这些布尔表达式操作数。
- en: A register operand can be any of the 8-bit, 16-bit, or 32-bit general-purpose
    registers. The expression evaluates false if the register contains a zero; it
    evaluates true if the register contains a nonzero value.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器操作数可以是任何8位、16位或32位通用寄存器。如果寄存器的值为零，则表达式计算为假；如果寄存器的值为非零，则计算为真。
- en: If you specify a boolean variable as the expression, the program tests it for
    zero (false) or nonzero (true). Because HLA uses the values zero and one to represent
    false and true, respectively, the test works in an intuitive fashion. Note that
    HLA requires such variables be of type `boolean`. HLA rejects other data types.
    If you want to test some other type against zero/not zero, then use the general
    boolean expression discussed next.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将布尔变量指定为表达式，程序会测试它是否为零（假）或非零（真）。由于HLA使用零和一分别表示假和真，因此该测试直观易懂。注意，HLA要求这样的变量类型为`boolean`。HLA会拒绝其他数据类型。如果你想测试某个其他类型是否为零或非零，则需要使用接下来讨论的一般布尔表达式。
- en: The most general form of an HLA boolean expression has two operands and a relational
    operator. [Table 1-3](ch01s09.html#legal_boolean_expressions "Table 1-3. Legal
    Boolean Expressions") lists the legal combinations.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: HLA布尔表达式的最一般形式有两个操作数和一个关系运算符。[表1-3](ch01s09.html#legal_boolean_expressions "表1-3.
    合法布尔表达式")列出了合法的组合。
- en: Table 1-3. Legal Boolean Expressions
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-3. 合法布尔表达式
- en: '| Left Operand | Relational Operator | Right Operand |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 左操作数 | 关系运算符 | 右操作数 |'
- en: '| --- | --- | --- |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Memory variable or register | = or ==<> or !=<<=>>= | Variable, register,
    or constant |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 内存变量或寄存器 | = 或 ==<> 或 !=<<=>>= | 变量、寄存器或常量 |'
- en: Note that both operands cannot be memory operands. In fact, if you think of
    the *right operand* as the source operand and the *left operand* as the destination
    operand, then the two operands must be the same that `add` and `sub` allow.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，两个操作数不能都是内存操作数。实际上，如果你将*右操作数*视为源操作数，将*左操作数*视为目标操作数，那么这两个操作数必须与`add`和`sub`允许的操作数相同。
- en: Also like the `add` and `sub` instructions, the two operands must be the same
    size. That is, they must both be byte operands, they must both be word operands,
    or they must both be double-word operands. If the right operand is a constant,
    its value must be in the range that is compatible with the left operand.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 同样像`add`和`sub`指令一样，两个操作数必须是相同大小的。也就是说，它们必须都是字节操作数，必须都是字操作数，或者必须都是双字操作数。如果右操作数是常量，它的值必须在与左操作数兼容的范围内。
- en: 'There is one other issue: if the left operand is a register and the right operand
    is a positive constant or another register, HLA uses an *unsigned* comparison.
    The next chapter will discuss the ramifications of this; for the time being, do
    not compare negative values in a register against a constant or another register.
    You may not get an intuitive result.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个问题：如果左操作数是一个寄存器，而右操作数是一个正数常量或另一个寄存器，HLA会使用*无符号*比较。下一章将讨论这个问题的后果；目前，请不要将寄存器中的负值与常量或另一个寄存器进行比较。你可能得不到直观的结果。
- en: The `in` and `not in` operators let you test a register to see if it is within
    a specified range. For example, the expression `eax in 2000..2099` evaluates true
    if the value in the EAX register is between 2,000 and 2,099 (inclusive). The `not
    in` (two words) operator checks to see if the value in a register is outside the
    specified range. For example, `al not in 'a'..'z'` evaluates true if the character
    in the AL register is not a lowercase alphabetic character.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`in` 和 `not in` 运算符允许你测试一个寄存器，查看它是否在指定的范围内。例如，表达式 `eax in 2000..2099` 如果 EAX
    寄存器中的值在 2000 到 2099 之间（包含 2000 和 2099），则返回真。`not in`（两个单词）运算符检查寄存器中的值是否在指定范围之外。例如，`al
    not in ''a''..''z''` 如果 AL 寄存器中的字符不是小写字母字符，则返回真。'
- en: 'Here are some examples of legal boolean expressions in HLA:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 HLA 中合法布尔表达式的一些示例：
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 1.9.2 The HLA if..then..elseif..else..endif Statement
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.9.2 HLA 的 if..then..elseif..else..endif 语句
- en: The HLA `if` statement uses the syntax shown in [Figure 1-10](ch01s09.html#hla_if_statement_syntax
    "Figure 1-10. HLA if statement syntax").
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: HLA `if` 语句使用的语法如 [图 1-10](ch01s09.html#hla_if_statement_syntax "图 1-10. HLA
    if 语句语法") 所示。
- en: '![HLA if statement syntax](tagoreillycom20100401nostarchimages577873.png.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![HLA if 语句语法](tagoreillycom20100401nostarchimages577873.png.jpg)'
- en: Figure 1-10. HLA `if` statement syntax
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-10. HLA `if` 语句语法
- en: The expressions appearing in an `if` statement must take one of the forms from
    the previous section. If the boolean expression is true, the code after the `then`
    executes; otherwise control transfers to the next `elseif` or `else` clause in
    the statement.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 出现在 `if` 语句中的表达式必须符合前一节所述的形式。如果布尔表达式为真，`then` 之后的代码将执行；否则，控制权将转移到语句中的下一个 `elseif`
    或 `else` 子句。
- en: 'Because the `elseif` and `else` clauses are optional, an `if` statement could
    take the form of a single `if..then` clause, followed by a sequence of statements
    and a closing `endif` clause. The following is such a statement:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `elseif` 和 `else` 子句是可选的，所以一个 `if` 语句可以只包含一个 `if..then` 子句，后面跟着一系列语句和一个结束的
    `endif` 子句。以下是这样的一个语句：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If, during program execution, the expression evaluates true, then the code between
    the `then` and the `endif` executes. If the expression evaluates false, then the
    program skips over the code between the `then` and the `endif`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在程序执行过程中，表达式为真，则 `then` 和 `endif` 之间的代码将执行。如果表达式为假，则程序会跳过 `then` 和 `endif`
    之间的代码。
- en: 'Another common form of the `if` statement has a single `else` clause. The following
    is an example of an `if` statement with an optional `else` clause:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的 `if` 语句形式只有一个 `else` 子句。以下是一个带有可选 `else` 子句的 `if` 语句示例：
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the expression evaluates true, the code between the `then` and the `else`
    executes; otherwise the code between the `else` and the `endif` clauses executes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式为真，则 `then` 和 `else` 之间的代码将执行；否则，`else` 和 `endif` 之间的代码将执行。
- en: 'You can create sophisticated decision-making logic by incorporating the `elseif`
    clause into an `if` statement. For example, if the CH register contains a character
    value, you can select from a menu of items using code like the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `elseif` 子句集成到 `if` 语句中，你可以创建复杂的决策逻辑。例如，如果 CH 寄存器包含一个字符值，你可以使用如下代码从菜单中选择项目：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Although this simple example doesn't demonstrate it, HLA does not require an
    `else` clause at the end of a sequence of `elseif` clauses. However, when making
    multiway decisions, it's always a good idea to provide an `else` clause just in
    case an error arises. Even if you think it's impossible for the `else` clause
    to execute, just keep in mind that future modifications to the code could void
    this assertion, so it's a good idea to have error-reporting statements in your
    code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个简单的例子没有展示，但 HLA 并不要求在一系列 `elseif` 子句的末尾一定要有 `else` 子句。然而，在做多路决策时，提供一个 `else`
    子句总是一个好主意，以防出现错误。即使你认为 `else` 子句不可能执行，也要记住，未来对代码的修改可能会使这个假设失效，因此在代码中包含错误报告语句是个好习惯。
- en: 1.9.3 Conjunction, Disjunction, and Negation in Boolean Expressions
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.9.3 布尔表达式中的合取、析取与否定
- en: Some obvious omissions in the list of operators in the previous sections are
    the conjunction (logical `and`), disjunction (logical `or`), and negation (logical
    `not`) operators. This section describes their use in boolean expressions (the
    discussion had to wait until after describing the `if` statement in order to present
    realistic examples).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面各节的运算符列表中，有一些明显遗漏的运算符：合取（逻辑 `and`）、析取（逻辑 `or`）和否定（逻辑 `not`）。本节描述它们在布尔表达式中的使用（讨论必须等到描述完
    `if` 语句之后，才能展示实际的例子）。
- en: 'HLA uses the `&&` operator to denote logical `and` in a runtime boolean expression.
    This is a dyadic (two-operand) operator, and the two operands must be legal runtime
    boolean expressions. This operator evaluates to true if both operands evaluate
    to true. For example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: HLA使用`&&`运算符来表示运行时布尔表达式中的逻辑`与`。这是一个二元（两个操作数）运算符，两个操作数必须是合法的运行时布尔表达式。如果两个操作数都为真，则此运算符的结果为真。例如：
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The two `mov` statements above execute only if EAX is greater than zero *and*
    CH is equal to the character *a*. If either of these conditions is false, then
    program execution skips over these `mov` instructions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 上面两个`mov`语句仅在EAX大于零*且*CH等于字符*a*时执行。如果这两个条件中的任何一个为假，程序执行将跳过这些`mov`指令。
- en: 'Note that the expressions on either side of the `&&` operator may be any legal
    boolean expressions; these expressions don''t have to be comparisons using the
    relational operators. For example, the following are all legal expressions:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`&&`运算符两侧的表达式可以是任何合法的布尔表达式；这些表达式不一定要使用关系运算符进行比较。例如，以下所有的表达式都是合法的：
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: HLA uses *short-circuit evaluation* when compiling the `&&` operator. If the
    leftmost operand evaluates false, then the code that HLA generates does not bother
    evaluating the second operand (because the whole expression must be false at that
    point). Therefore, in the last expression above, the code will not check EAX against
    zero if `boolVar` evaluates false.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: HLA在编译`&&`运算符时使用*短路求值*。如果最左边的操作数为假，则HLA生成的代码不会再评估第二个操作数（因为此时整个表达式必定为假）。因此，在上面的最后一个表达式中，如果`boolVar`为假，则代码不会检查EAX是否为零。
- en: 'Note that an expression like `eax < 10 && ebx <> eax` is itself a legal boolean
    expression and, therefore, may appear as the left or right operand of the `&&`
    operator. Therefore, expressions like the following are perfectly legal:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，像`eax < 10 && ebx <> eax`这样的表达式本身就是一个合法的布尔表达式，因此可以作为`&&`运算符的左或右操作数。因此，以下类似的表达式是完全合法的：
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `&&` operator is left associative, so the code that HLA generates evaluates
    the expression above in a left-to-right fashion. If EAX is less than zero, the
    CPU will not test either of the remaining expressions. Likewise, if EAX is not
    less than zero but EBX is equal to EAX, this code will not evaluate the third
    expression because the whole expression is false regardless of ECX's value.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`运算符是左结合的，因此HLA生成的代码会从左到右评估上述表达式。如果EAX小于零，CPU将不会测试剩余的表达式。类似地，如果EAX不小于零但EBX等于EAX，这段代码将不会评估第三个表达式，因为无论ECX的值如何，整个表达式都为假。'
- en: 'HLA uses the `||` operator to denote disjunction (logical `or`) in a runtime
    boolean expression. Like the `&&` operator, this operator expects two legal runtime
    boolean expressions as operands. This operator evaluates true if either (or both)
    operands evaluate true. Like the `&&` operator, the disjunction operator uses
    short-circuit evaluation. If the left operand evaluates true, then the code that
    HLA generates doesn''t bother to test the value of the second operand. Instead,
    the code will transfer to the location that handles the situation when the boolean
    expression evaluates true. Here are some examples of legal expressions using the
    `||` operator:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: HLA使用`||`运算符来表示析取（逻辑`或`）在运行时布尔表达式中的应用。和`&&`运算符一样，这个运算符也期望两个合法的运行时布尔表达式作为操作数。如果任一（或两个）操作数为真，则此运算符的结果为真。与`&&`运算符一样，析取运算符也使用短路求值。如果左侧操作数为真，则HLA生成的代码不会再测试第二个操作数的值。相反，代码将跳转到处理布尔表达式为真时的相应位置。以下是一些使用`||`运算符的合法表达式示例：
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Like the `&&` operator, the disjunction operator is left associative, so multiple
    instances of the `||` operator may appear within the same expression. Should this
    be the case, the code that HLA generates will evaluate the expressions from left
    to right. For example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 和`&&`运算符一样，析取运算符是左结合的，因此在同一个表达式中可以出现多个`||`运算符。如果出现这种情况，HLA生成的代码将从左到右计算表达式。例如：
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The code above evaluates to true if EAX is less than zero, EBX does not equal
    EAX, or ECX is zero. Note that if the first comparison is true, the code doesn't
    bother testing the other conditions. Likewise, if the first comparison is false
    and the second is true, the code doesn't bother checking to see if ECX is zero.
    The check for ECX equal to zero occurs only if the first two comparisons are false.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在 EAX 小于零、EBX 不等于 EAX 或 ECX 为零时评估为真。注意，如果第一个比较为真，代码不会检查其他条件。同样，如果第一个比较为假且第二个为真，代码不会再检查
    ECX 是否为零。仅当前两个比较为假时，才会检查 ECX 是否等于零。
- en: 'If both the conjunction and disjunction operators appear in the same expression,
    then the `&&` operator takes precedence over the `||` operator. Consider the following
    expression:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果合取运算符和析取运算符出现在同一表达式中，则 `&&` 运算符优先于 `||` 运算符。考虑以下表达式：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The machine code HLA generates evaluates this as
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 生成的机器代码将此表达式评估为：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If EAX is less than zero, then the code HLA generates does not bother to check
    the remainder of the expression, and the entire expression evaluates true. However,
    if EAX is not less than zero, then both of the following conditions must evaluate
    true in order for the overall expression to evaluate true.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 EAX 小于零，则 HLA 生成的代码不会检查表达式的其余部分，整个表达式会被判定为真。但是，如果 EAX 不小于零，则以下两个条件必须都为真，整个表达式才会为真。
- en: 'HLA allows you to use parentheses to surround subexpressions involving `&&`
    and `||` if you need to adjust the precedence of the operators. Consider the following
    expression:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要调整运算符的优先级，HLA 允许你使用括号来围绕涉及 `&&` 和 `||` 的子表达式。考虑以下表达式：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For this expression to evaluate true, ECX must contain zero and either EAX must
    be less than zero or EBX must not equal EAX. Contrast this to the result the expression
    produces without the parentheses.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此表达式评估为真，ECX 必须为零，并且 EAX 必须小于零或 EBX 必须不等于 EAX。与没有括号时该表达式的结果相比，可以看到区别。
- en: 'HLA uses the `!` operator to denote logical negation. However, the `!` operator
    may only prefix a register or boolean variable; you may not use it as part of
    a larger expression (e.g., `!eax < 0`). To achieve logical negative of an existing
    boolean expression, you must surround that expression with parentheses and prefix
    the parentheses with the `!` operator. For example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 使用 `!` 运算符表示逻辑否定。然而，`!` 运算符只能作为寄存器或布尔变量的前缀；不能将其用作更大表达式的一部分（例如，`!eax < 0`）。要对现有的布尔表达式进行逻辑否定，必须将该表达式用括号括起来，并将
    `!` 运算符放在括号前。例如：
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This expression evaluates true if EAX is not less than zero.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 EAX 不小于零，则此表达式为真。
- en: The logical `not` operator is primarily useful for surrounding complex expressions
    involving the conjunction and disjunction operators. While it is occasionally
    useful for short expressions like the one above, it's usually easier (and more
    readable) to simply state the logic directly rather than convolute it with the
    logical `not` operator.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符`not`主要用于围绕涉及合取和析取运算符的复杂表达式。尽管它偶尔对像上面那样的简短表达式有用，但通常直接表达逻辑会更简单（且更具可读性），而不是用逻辑`not`运算符将其复杂化。
- en: Note that HLA also provides the `|` and `&` operators, but they are distinct
    from `||` and `&&` and have completely different meanings. See the HLA reference
    manual for more details on these (compile-time) operators.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，HLA 还提供了 `|` 和 `&` 运算符，但它们与 `||` 和 `&&` 不同，含义完全不同。有关这些（编译时）运算符的更多细节，请参阅 HLA
    参考手册。
- en: 1.9.4 The while..endwhile Statement
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.9.4 while..endwhile 语句
- en: The `while` statement uses the basic syntax shown in [Figure 1-11](ch01s09.html#hla_while_statement_syntax
    "Figure 1-11. HLA while statement syntax").
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 语句使用的基本语法如[图 1-11](ch01s09.html#hla_while_statement_syntax "图 1-11.
    HLA while 语句语法")所示。'
- en: '![HLA while statement syntax](tagoreillycom20100401nostarchimages577875.png.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![HLA while 语句语法](tagoreillycom20100401nostarchimages577875.png.jpg)'
- en: Figure 1-11. HLA `while` statement syntax
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-11. HLA `while` 语句语法
- en: This statement evaluates the boolean expression. If it is false, control immediately
    transfers to the first statement following the `endwhile` clause. If the value
    of the expression is true, then the CPU executes the body of the loop. After the
    loop body executes, control transfers back to the top of the loop, where the `while`
    statement retests the loop control expression. This process repeats until the
    expression evaluates false.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句计算布尔表达式。如果为假，控制会立即转移到`endwhile`子句后面的第一条语句。如果表达式的值为真，则CPU执行循环体。循环体执行后，控制返回到循环顶部，此时`while`语句会重新测试循环控制表达式。这个过程会一直重复，直到表达式计算为假。
- en: Note that the `while` loop, like its high-level-language counterpart, tests
    for loop termination at the top of the loop. Therefore, it is quite possible that
    the statements in the body of the loop will not execute (if the expression is
    false when the code first executes the `while` statement). Also note that the
    body of the `while` loop must, at some point, modify the value of the boolean
    expression or an infinite loop will result.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`while`循环与其高级语言对应物一样，在循环顶部测试是否终止。因此，循环体中的语句有可能不会执行（如果在代码首次执行`while`语句时，表达式为假）。还请注意，`while`循环体中的语句必须在某个时刻修改布尔表达式的值，否则将会导致无限循环。
- en: 'Here''s an example of an HLA `while` loop:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个HLA的`while`循环示例：
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 1.9.5 The for..endfor Statement
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.9.5 for..endfor语句
- en: 'The HLA `for` loop takes the following general form:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: HLA的`for`循环具有以下通用形式：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is equivalent to the following `while` statement:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于以下`while`语句：
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*`Initial_Stmt`* can be any single HLA/80x86 instruction. Generally this statement
    initializes a register or memory location (the loop counter) with zero or some
    other initial value. *`Termination_Expression`* is an HLA boolean expression (same
    format that `while` allows). This expression determines whether the loop body
    executes. *`Post_Body_Statement`* executes at the bottom of the loop (as shown
    in the `while` example above). This is a single HLA statement. Usually an instruction
    like `add` modifies the value of the loop control variable.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*`Initial_Stmt`*可以是任何单个HLA/80x86指令。通常该语句会将寄存器或内存位置（循环计数器）初始化为零或其他初始值。*`Termination_Expression`*是一个HLA布尔表达式（与`while`允许的格式相同）。该表达式决定循环体是否执行。*`Post_Body_Statement`*在循环底部执行（如上所示的`while`示例）。这是一条单一的HLA语句，通常像`add`这样的指令会修改循环控制变量的值。'
- en: 'The following gives a complete example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个完整的示例：
- en: '[PRE37]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The above, rewritten as a while loop, becomes:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容重写为`while`循环后变为：
- en: '[PRE38]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 1.9.6 The repeat..until Statement
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.9.6 repeat..until语句
- en: The HLA `repeat..until` statement uses the syntax shown in [Figure 1-12](ch01s09.html#hla_repeat..until_statement_syntax
    "Figure 1-12. HLA repeat..until statement syntax"). C/C++/C# and Java users should
    note that the `repeat..until` statement is very similar to the `do..while` statement.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: HLA的`repeat..until`语句使用[图1-12](ch01s09.html#hla_repeat..until_statement_syntax
    "图1-12. HLA repeat..until语句语法")所示的语法。C/C++/C#和Java用户应注意，`repeat..until`语句与`do..while`语句非常相似。
- en: '![HLA repeat..until statement syntax](tagoreillycom20100401nostarchimages577877.png.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![HLA repeat..until语句语法](tagoreillycom20100401nostarchimages577877.png.jpg)'
- en: Figure 1-12. HLA `repeat..until` statement syntax
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-12. HLA `repeat..until`语句语法
- en: The HLA `repeat..until` statement tests for loop termination at the bottom of
    the loop. Therefore, the statements in the loop body always execute at least once.
    Upon encountering the `until` clause, the program will evaluate the expression
    and repeat the loop if the expression is false (that is, it repeats while false).
    If the expression evaluates true, the control transfers to the first statement
    following the `until` clause.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: HLA的`repeat..until`语句在循环底部测试循环是否终止。因此，循环体中的语句总是至少执行一次。当遇到`until`子句时，程序将评估表达式，并在表达式为假时重复循环（即，当假时重复）。如果表达式计算为真，控制会转移到`until`子句后面的第一条语句。
- en: 'The following simple example demonstrates the `repeat..until` statement:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简单示例演示了`repeat..until`语句：
- en: '[PRE39]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If the loop body will always execute at least once, then it is usually more
    efficient to use a `repeat..until` loop rather than a `while` loop.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果循环体总是至少执行一次，那么通常使用`repeat..until`循环比使用`while`循环更高效。
- en: 1.9.7 The break and breakif Statements
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.9.7 break和breakif语句
- en: The `break` and `breakif` statements provide the ability to prematurely exit
    from a loop. [Figure 1-13](ch01s09.html#hla_break_and_breakif_syntax "Figure 1-13. HLA
    break and breakif syntax") shows the syntax for these two statements.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 和 `breakif` 语句提供了提前退出循环的功能。[图 1-13](ch01s09.html#hla_break_and_breakif_syntax
    "图 1-13. HLA break 和 breakif 语法") 显示了这两个语句的语法。'
- en: '![HLA break and breakif syntax](tagoreillycom20100401nostarchimages577879.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![HLA break 和 breakif 语法](tagoreillycom20100401nostarchimages577879.png)'
- en: Figure 1-13. HLA `break` and `breakif` syntax
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-13. HLA `break` 和 `breakif` 语法
- en: The `break` statement exits the loop that immediately contains the `break`.
    The `breakif` statement evaluates the boolean expression and exits the containing
    loop if the expression evaluates true.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 语句退出直接包含 `break` 的循环。`breakif` 语句评估布尔表达式，并在表达式为真时退出包含的循环。'
- en: Note that the `break` and `breakif` statements do not allow you to break out
    of more than one nested loop. HLA does provide statements that do this, the `begin..end`
    block and the `exit`/`exitif` statements. Please consult the HLA reference manual
    for more details. HLA also provides the `continue`/`continueif` pair that lets
    you repeat a loop body. Again, see the HLA reference manual for more details.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`break` 和 `breakif` 语句不允许你跳出多个嵌套循环。HLA 提供了其他语句来实现这一功能，包括 `begin..end` 块和
    `exit`/`exitif` 语句。请参阅 HLA 参考手册了解更多细节。HLA 还提供了 `continue`/`continueif` 配对语句，允许你重复循环体。同样，请参考
    HLA 参考手册以获取更多信息。
- en: 1.9.8 The forever..endfor Statement
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.9.8 forever..endfor 语句
- en: '[Figure 1-14](ch01s09.html#hla_forever_loop_syntax "Figure 1-14. HLA forever
    loop syntax") shows the syntax for the `forever` statement.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-14](ch01s09.html#hla_forever_loop_syntax "图 1-14. HLA forever 循环语法") 显示了
    `forever` 语句的语法。'
- en: '![HLA forever loop syntax](tagoreillycom20100401nostarchimages577881.png.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![HLA forever 循环语法](tagoreillycom20100401nostarchimages577881.png.jpg)'
- en: Figure 1-14. HLA `forever` loop syntax
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-14. HLA `forever` 循环语法
- en: 'This statement creates an infinite loop. You may also use the `break` and `breakif`
    statements along with `forever..endfor` to create a loop that tests for loop termination
    in the middle of the loop. Indeed, this is probably the most common use of this
    loop, as the following example demonstrates:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句创建一个无限循环。你还可以将 `break` 和 `breakif` 语句与 `forever..endfor` 一起使用，在循环中间进行循环终止条件的测试。实际上，这可能是此循环最常见的使用方式，以下示例演示了这一点：
- en: '[PRE40]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 1.9.9 The try..exception..endtry Statement
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.9.9 try..exception..endtry 语句
- en: The HLA `try..exception..endtry` statement provides very powerful *exception
    handling* capabilities. The syntax for this statement appears in [Figure 1-15](ch01s09.html#hla_try..exception..endtry_statement_syn
    "Figure 1-15. HLA try..exception..endtry statement syntax").
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: HLA `try..exception..endtry` 语句提供了非常强大的*异常处理*功能。此语句的语法如[图 1-15](ch01s09.html#hla_try..exception..endtry_statement_syn
    "图 1-15. HLA try..exception..endtry 语句语法")所示。
- en: '![HLA try..exception..endtry statement syntax](tagoreillycom20100401nostarchimages577883.png.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![HLA try..exception..endtry 语句语法](tagoreillycom20100401nostarchimages577883.png.jpg)'
- en: Figure 1-15. HLA `try..exception..endtry` statement syntax
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-15. HLA `try..exception..endtry` 语句语法
- en: The `try..endtry` statement protects a block of statements during execution.
    If the statements between the `try` clause and the first `exception` clause (the
    *protected block*), execute without incident, control transfers to the first statement
    after the `endtry` immediately after executing the last statement in the protected
    block. If an error (exception) occurs, then the program interrupts control at
    the point of the exception (that is, the program *raises* an exception). Each
    exception has an unsigned integer constant associated with it, known as the *exception
    ID*. The *excepts.hhf* header file in the HLA Standard Library predefines several
    exception IDs, although you may create new ones for your own purposes. When an
    exception occurs, the system compares the exception ID against the values appearing
    in each of the exception clauses following the protected code. If the current
    exception ID matches one of the exception values, control continues with the block
    of statements immediately following that exception. After the exception-handling
    code completes execution, control transfers to the first statement following the
    `endtry`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`try..endtry`语句在执行过程中保护一组语句。如果`try`子句和第一个`exception`子句之间的语句（即*保护块*）顺利执行，控制会立即转移到`endtry`之后的第一条语句。如果发生错误（异常），程序会在异常发生的地方中断控制（即程序会*抛出*一个异常）。每个异常都有一个与之关联的无符号整数常量，称为*异常ID*。HLA标准库中的*excepts.hhf*头文件预定义了几个异常ID，尽管你可以根据需要创建新的异常ID。当异常发生时，系统会将异常ID与保护代码之后每个异常子句中的值进行比较。如果当前的异常ID与某个异常值匹配，控制会继续执行该异常后面紧接着的语句块。在异常处理代码执行完毕后，控制会转移到`endtry`之后的第一条语句。'
- en: If an exception occurs and there is no active `try..endtry` statement, or the
    active `try..endtry` statements do not handle the specific exception, the program
    will abort with an error message.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生异常且没有活动的`try..endtry`语句，或者活动的`try..endtry`语句无法处理特定的异常，程序将以错误消息终止。
- en: 'The following code fragment demonstrates how to use the `try..endtry` statement
    to protect the program from bad user input:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何使用`try..endtry`语句来保护程序免受错误用户输入的影响：
- en: '[PRE41]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `repeat..until` loop repeats this code as long as there is an error during
    input. Should an exception occur because of bad input, control transfers to the
    exception clauses to see if a conversion error (e.g., illegal characters in the
    number) or a numeric overflow occurs. If either of these exceptions occur, then
    they print the appropriate message, control falls out of the `try..endtry` statement,
    and the `repeat..until` loop repeats because the code will not have set `GoodInteger`
    to true. If a different exception occurs (one that is not handled in this code),
    then the program aborts with the specified error message.^([[10](#ftn.CHP-1-FN-10)])
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat..until`循环会在输入过程中出现错误时重复执行该代码。如果由于错误输入而发生异常，控制将转移到异常处理部分，查看是否发生了转换错误（例如，数字中的非法字符）或数字溢出。如果发生这些异常，则会打印相应的消息，控制跳出`try..endtry`语句，`repeat..until`循环将会重复，因为代码没有将`GoodInteger`设置为true。如果发生了其他异常（代码中未处理的异常），程序将以指定的错误消息终止。^([[10](#ftn.CHP-1-FN-10)])'
- en: '[Table 1-4](ch01s09.html#exceptions_provided_in_excepts.hhf "Table 1-4. Exceptions
    Provided in excepts.hhf") lists the exceptions provided in the *excepts.hhf* header
    file at the time this was being written. See the *excepts.hhf* header file provided
    with HLA for the most current list of exceptions.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[表1-4](ch01s09.html#exceptions_provided_in_excepts.hhf "表1-4. 在excepts.hhf中提供的异常")列出了在编写本文时，*excepts.hhf*头文件中提供的异常。请参见随HLA提供的*excepts.hhf*头文件，以获取最新的异常列表。'
- en: Table 1-4. Exceptions Provided in *excepts.hhf*
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-4. 在*excepts.hhf*中提供的异常
- en: '| Exception | Description |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 异常 | 描述 |'
- en: '| --- | --- |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ex.StringOverflow` | Attempt to store a string that is too large into a
    string variable. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `ex.StringOverflow` | 尝试将一个过大的字符串存入字符串变量。 |'
- en: '| `ex.StringIndexError` | Attempt to access a character that is not present
    in a string. |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `ex.StringIndexError` | 尝试访问字符串中不存在的字符。 |'
- en: '| `ex.StringOverlap` | Attempt to copy a string onto itself. |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `ex.StringOverlap` | 尝试将一个字符串复制到自身。 |'
- en: '| `ex.StringMetaData` | Corrupted string value. |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `ex.StringMetaData` | 损坏的字符串值。 |'
- en: '| `ex.StringAlignment` | Attempt to store a string an at unaligned address.
    |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `ex.StringAlignment` | 尝试将字符串存储在未对齐的地址上。 |'
- en: '| `ex.StringUnderflow` | Attempt to extract "negative" characters from a string.
    |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `ex.StringUnderflow` | 尝试从字符串中提取“负”字符。 |'
- en: '| `ex.IllegalStringOperation` | Operation not permitted on string data. |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `ex.IllegalStringOperation` | 字符串数据上不允许进行该操作。 |'
- en: '| `ex.ValueOutOfRange` | Value is too large for the current operation. |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `ex.ValueOutOfRange` | 值对于当前操作来说过大。 |'
- en: '| `ex.IllegalChar` | Operation encountered a character code whose ASCII code
    is not in the range 0..127. |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `ex.IllegalChar` | 操作遇到的字符代码，其 ASCII 码不在 0..127 的范围内。 |'
- en: '| `ex.TooManyCmdLnParms` | Command line contains too many program parameters.
    |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `ex.TooManyCmdLnParms` | 命令行包含过多的程序参数。 |'
- en: '| `ex.BadObjPtr` | Pointer to class object is illegal. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `ex.BadObjPtr` | 类对象的指针无效。 |'
- en: '| `ex.InvalidAlignment` | Argument was not aligned on a proper memory address.
    |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `ex.InvalidAlignment` | 参数没有在正确的内存地址对齐。 |'
- en: '| `ex.InvalidArgument` | Function call (generally OS API call) contains an
    invalid argument value. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `ex.InvalidArgument` | 函数调用（通常是操作系统 API 调用）包含无效的参数值。 |'
- en: '| `ex.BufferOverflow` | Buffer or blob object exceeded declared size. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `ex.BufferOverflow` | 缓冲区或 blob 对象超出了声明的大小。 |'
- en: '| `ex.BufferUnderflow` | Attempt to retrieve nonexistent data from a blob or
    buffer. |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `ex.BufferUnderflow` | 尝试从 blob 或缓冲区中检索不存在的数据。 |'
- en: '| `ex.IllegalSize` | Argument''s data size is incorrect. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `ex.IllegalSize` | 参数的数据大小不正确。 |'
- en: '| `ex.ConversionError` | String-to-numeric conversion operation contains illegal
    (nonnumeric) characters. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `ex.ConversionError` | 字符串转数字时包含非法（非数字）字符。 |'
- en: '| `ex.BadFileHandle` | Program attempted a file access using an invalid file
    handle value. |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `ex.BadFileHandle` | 程序尝试使用无效的文件句柄值访问文件。 |'
- en: '| `ex.FileNotFound` | Program attempted to access a nonexistent file. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `ex.FileNotFound` | 程序尝试访问一个不存在的文件。 |'
- en: '| `ex.FileOpenFailure` | Operating system could not open the file (file not
    found). |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `ex.FileOpenFailure` | 操作系统无法打开文件（文件未找到）。 |'
- en: '| `ex.FileCloseError` | Operating system could not close the file. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `ex.FileCloseError` | 操作系统无法关闭文件。 |'
- en: '| `ex.FileWriteError` | Error writing data to a file. |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `ex.FileWriteError` | 写入数据到文件时发生错误。 |'
- en: '| `ex.FileReadError` | Error reading data from a file. |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `ex.FileReadError` | 从文件读取数据时发生错误。 |'
- en: '| `ex.FileSeekError` | Attempted to seek to a nonexistent position in a file.
    |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `ex.FileSeekError` | 尝试定位到文件中不存在的位置。 |'
- en: '| `ex.DiskFullError` | Attempted to write data to a full disk. |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `ex.DiskFullError` | 尝试写入数据到已满的磁盘。 |'
- en: '| `ex.AccessDenied` | User does not have sufficient priviledges to access file
    data. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `ex.AccessDenied` | 用户没有足够的权限访问文件数据。 |'
- en: '| `ex.EndOfFile` | Program attempted to read beyond the end of file. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `ex.EndOfFile` | 程序尝试读取文件末尾之后的数据。 |'
- en: '| `ex.CannotCreateDir` | Attempt to create a directory failed. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `ex.CannotCreateDir` | 尝试创建目录失败。 |'
- en: '| `ex.CannotRemoveDir` | Attempt to delete a directory failed. |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `ex.CannotRemoveDir` | 尝试删除目录失败。 |'
- en: '| `ex.CannotRemoveFile` | Attempt to delete a file failed. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `ex.CannotRemoveFile` | 尝试删除文件失败。 |'
- en: '| `ex.CDFailed` | Attempt to change to a new directory failed. |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `ex.CDFailed` | 尝试切换到新目录失败。 |'
- en: '| `ex.CannotRenameFile` | Attempt to rename a file failed. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `ex.CannotRenameFile` | 尝试重命名文件失败。 |'
- en: '| `ex.MemoryAllocationFailure` | Insufficient system memory for allocation
    request. |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `ex.MemoryAllocationFailure` | 系统内存不足，无法满足分配请求。 |'
- en: '| `ex.MemoryFreeFailure` | Could not free the specified memory block (corrupted
    memory management system). |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `ex.MemoryFreeFailure` | 无法释放指定的内存块（内存管理系统损坏）。 |'
- en: '| `ex.MemoryAllocationCorruption` | Corrupted memory management system. |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `ex.MemoryAllocationCorruption` | 内存管理系统损坏。 |'
- en: '| `ex.AttemptToFreeNULL` | Caller attempted to free a NULL pointer. |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `ex.AttemptToFreeNULL` | 调用者尝试释放一个 NULL 指针。 |'
- en: '| `ex.AttemptToDerefNULL` | Program attempted to access data indirectly using
    a NULL pointer. |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `ex.AttemptToDerefNULL` | 程序尝试通过 NULL 指针间接访问数据。 |'
- en: '| `ex.BlockAlreadyFree` | Caller attempted to free a block that was already
    freed. |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `ex.BlockAlreadyFree` | 调用者尝试释放一个已经被释放的内存块。 |'
- en: '| `ex.CannotFreeMemory` | Memory free operation failure. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `ex.CannotFreeMemory` | 释放内存操作失败。 |'
- en: '| `ex.PointerNotInHeap` | Caller attempted to free a block of memory that was
    not allocated on the heap. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `ex.PointerNotInHeap` | 调用者尝试释放一个未在堆上分配的内存块。 |'
- en: '| `ex.WidthTooBig` | Format width for numeric to string conversion was too
    large. |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `ex.WidthTooBig` | 数字转字符串时格式宽度过大。 |'
- en: '| `ex.FractionTooBig` | Format size for fractional portion in floating-point-to-string
    conversion was too large. |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `ex.FractionTooBig` | 浮点转字符串时，格式中小数部分的大小过大。 |'
- en: '| `ex.ArrayShapeViolation` | Attempted operation on two arrays whose dimensions
    don''t match. |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| `ex.ArrayShapeViolation` | 尝试在两个维度不匹配的数组上执行操作。 |'
- en: '| `ex.ArrayBounds` | Attempted to access an element of an array, but the index
    was out of bounds. |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| `ex.ArrayBounds` | 尝试访问数组元素，但索引超出了范围。 |'
- en: '| `ex.InvalidDate` | Attempted date operation with an illegal date. |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `ex.InvalidDate` | 尝试对非法日期进行日期操作。 |'
- en: '| `ex.InvalidDateFormat` | Conversion from string to date contains illegal
    characters. |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `ex.InvalidDateFormat` | 从字符串到日期的转换包含非法字符。 |'
- en: '| `ex.TimeOverflow` | Overflow during time arithmetic. |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `ex.TimeOverflow` | 时间算术运算中的溢出。 |'
- en: '| `ex.InvalidTime` | Attempted time operation with an illegal time. |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `ex.InvalidTime` | 尝试对非法时间进行时间操作。 |'
- en: '| `ex.InvalidTimeFormat` | Conversion from string to time contains illegal
    characters. |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `ex.InvalidTimeFormat` | 从字符串到时间的转换包含非法字符。 |'
- en: '| `ex.SocketError` | Network communication failure. |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `ex.SocketError` | 网络通信失败。 |'
- en: '| `ex.ThreadError` | Generic thread (multitasking) error. |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `ex.ThreadError` | 通用线程（多任务）错误。 |'
- en: '| `ex.AssertionFailed` | `assert` statement encountered a failed assertion.
    |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `ex.AssertionFailed` | `assert`语句遇到失败的断言。 |'
- en: '| `ex.ExecutedAbstract` | Attempt to execute an abstract class method. |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `ex.ExecutedAbstract` | 尝试执行抽象类方法。 |'
- en: '| `ex.AccessViolation` | Attempt to access an illegal memory location. |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `ex.AccessViolation` | 尝试访问非法内存位置。 |'
- en: '| `ex.InPageError` | OS memory access error. |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `ex.InPageError` | 操作系统内存访问错误。 |'
- en: '| `ex.NoMemory` | OS memory failure. |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `ex.NoMemory` | 操作系统内存失败。 |'
- en: '| `ex.InvalidHandle` | Bad handle passed to OS API call. |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `ex.InvalidHandle` | 向操作系统API调用传递了错误的句柄。 |'
- en: '| `ex.ControlC` | **ctrl**-C was pressed on system console (functionality is
    OS specific). |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `ex.ControlC` | 在系统控制台上按下了**ctrl**-C（此功能取决于操作系统）。 |'
- en: '| `ex.Breakpoint` | Program executed a breakpoint instruction (INT 3). |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `ex.Breakpoint` | 程序执行了断点指令（INT 3）。 |'
- en: '| `ex.SingleStep` | Program is operating with the trace flag set. |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `ex.SingleStep` | 程序在追踪标志设置的情况下运行。 |'
- en: '| `ex.PrivInstr` | Program attempted to execute a kernel-only instruction.
    |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `ex.PrivInstr` | 程序尝试执行仅限内核的指令。 |'
- en: '| `ex.IllegalInstr` | Program attempted to execute an illegal machine instruction.
    |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `ex.IllegalInstr` | 程序尝试执行非法机器指令。 |'
- en: '| `ex.BoundInstr` | Bound instruction execution with "out of bounds" value.
    |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `ex.BoundInstr` | 使用“越界”值执行了界限指令。 |'
- en: '| `ex.IntoInstr` | Into instruction execution with the overflow flag set. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `ex.IntoInstr` | 在溢出标志设置的情况下执行Into指令。 |'
- en: '| `ex.DivideError` | Program attempted division by zero or other divide error.
    |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `ex.DivideError` | 程序尝试除以零或其他除法错误。 |'
- en: '| `ex.fDenormal` | Floating point exception (see [Chapter 6](ch06.html "Chapter 6. ARITHMETIC")).
    |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `ex.fDenormal` | 浮点异常（请参阅[第6章](ch06.html "第6章。算术")）。 |'
- en: '| `ex.fDivByZero` | Floating point exception (see [Chapter 6](ch06.html "Chapter 6. ARITHMETIC")).
    |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| `ex.fDivByZero` | 浮点异常（请参阅[第6章](ch06.html "第6章。算术")）。 |'
- en: '| `ex.fInexactResult` | Floating point exception (see [Chapter 6](ch06.html
    "Chapter 6. ARITHMETIC")). |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `ex.fInexactResult` | 浮点异常（请参阅[第6章](ch06.html "第6章。算术")）。 |'
- en: '| `ex.fInvalidOperation` | Floating point exception (see [Chapter 6](ch06.html
    "Chapter 6. ARITHMETIC")). |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| `ex.fInvalidOperation` | 浮点异常（请参阅[第6章](ch06.html "第6章。算术")）。 |'
- en: '| `ex.fOverflow` | Floating point exception (see [Chapter 6](ch06.html "Chapter 6. ARITHMETIC")).
    |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| `ex.fOverflow` | 浮点异常（请参阅[第6章](ch06.html "第6章。算术")）。 |'
- en: '| `ex.fStackCheck` | Floating point exception (see [Chapter 6](ch06.html "Chapter 6. ARITHMETIC")).
    |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| `ex.fStackCheck` | 浮点异常（请参阅[第6章](ch06.html "第6章。算术")）。 |'
- en: '| `ex.fUnderflow` | Floating point exception (see [Chapter 6](ch06.html "Chapter 6. ARITHMETIC")).
    |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| `ex.fUnderflow` | 浮点异常（请参阅[第6章](ch06.html "第6章。算术")）。 |'
- en: '| `ex.InvalidHandle` | OS reported an invalid handle for some operation. |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| `ex.InvalidHandle` | 操作系统报告某个操作的无效句柄。 |'
- en: Most of these exceptions occur in situations that are well beyond the scope
    of this chapter. Their appearance here is strictly for completeness. See the HLA
    reference manual, the HLA Standard Library documentation, and the HLA Standard
    Library source code for more details concerning these exceptions. The `ex.ConversionError`*,*
    `ex.ValueOutOfRange`, and `ex.StringOverflow` exceptions are the ones you'll most
    commonly use.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这些异常大多数发生在超出本章范围的情况中。它们出现在这里是为了完整性。有关这些异常的更多细节，请参阅HLA参考手册、HLA标准库文档以及HLA标准库源代码。`ex.ConversionError`、`ex.ValueOutOfRange`和`ex.StringOverflow`是您最常使用的异常。
- en: We'll return to the discussion of the `try..endtry` statement in [1.11 Additional
    Details About try..endtry](ch01s11.html "1.11 Additional Details About try..endtry").
    First, however, we need to cover a little more material.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[1.11 关于try..endtry的更多细节](ch01s11.html "1.11 关于try..endtry的更多细节")中重新讨论`try..endtry`语句。首先，然而我们需要覆盖更多的内容。
- en: '* * *'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[9](#CHP-1-FN-9)]) There are a few additional forms that we'll cover in [Chapter 6](ch06.html
    "Chapter 6. ARITHMETIC").
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[9](#CHP-1-FN-9)]) 还有一些额外的形式我们将在[第6章](ch06.html "第6章. 算术")中讨论。
- en: ^([[10](#CHP-1-FN-10)]) An experienced programmer may wonder why this code uses
    a boolean variable rather than a `breakif` statement to exit the `repeat..until`
    loop. There are some technical reasons for this that you will learn about in [1.11
    Additional Details About try..endtry](ch01s11.html "1.11 Additional Details About
    try..endtry").
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[10](#CHP-1-FN-10)]) 一位经验丰富的程序员可能会想知道，为什么这段代码使用布尔变量，而不是`breakif`语句来退出`repeat..until`循环。背后有一些技术原因，你将在[1.11
    关于try..endtry的更多细节](ch01s11.html "1.11 关于try..endtry的更多细节")中了解到这些原因。
- en: 1.10 Introduction to the HLA Standard Library
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.10 HLA标准库简介
- en: 'There are two reasons HLA is much easier to learn and use than standard assembly
    language. The first reason is HLA''s high-level syntax for declarations and control
    structures. This leverages your high-level language knowledge, allowing you to
    learn assembly language more efficiently. The other half of the equation is the
    HLA Standard Library. The HLA Standard Library provides many common, easy-to-use,
    assembly language routines that you can call without having to write this code
    yourself (and, more importantly, having to learn how to write yourself). This
    eliminates one of the larger stumbling blocks many people have when learning assembly
    language: the need for sophisticated I/O and support code in order to write basic
    statements. Prior to the advent of a standardized assembly language library, it
    often took considerable study before a new assembly language programmer could
    do as much as print a string to the display. With the HLA Standard Library, this
    roadblock is removed, and you can concentrate on learning assembly language concepts
    rather than learning low-level I/O details that are specific to a given operating
    system.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: HLA比标准汇编语言更容易学习和使用的原因有两个。第一个原因是HLA为声明和控制结构提供了高级语法。这利用了你对高级语言的知识，使你能更高效地学习汇编语言。方程的另一半是HLA标准库。HLA标准库提供了许多常见的、易于使用的汇编语言例程，你可以调用这些例程，而不需要自己编写这些代码（更重要的是，不需要学习如何编写这些代码）。这消除了很多人在学习汇编语言时遇到的一个大障碍：编写基本语句所需的复杂I/O和支持代码。在没有标准化的汇编语言库之前，新手汇编程序员往往需要相当长的学习时间，才能做到打印一个字符串到显示器。而有了HLA标准库，这一障碍就被移除了，你可以专注于学习汇编语言的概念，而不是学习特定操作系统的底层I/O细节。
- en: A wide variety of library routines is only part of HLA's support. After all,
    assembly language libraries have been around for quite some time.^([[11](#ftn.CHP-1-FN-11)])
    HLA's Standard Library complements HLA by providing a high-level language interface
    to these routines. Indeed, the HLA language itself was originally designed specifically
    to allow the creation of a high-level set of library routines. This high-level
    interface, combined with the high-level nature of many of the routines in the
    library, packs a surprising amount of power in an easy-to-use package.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 丰富的库例程只是HLA支持的一部分。毕竟，汇编语言库已经存在相当长的时间了。^([[11](#ftn.CHP-1-FN-11)]) HLA的标准库通过为这些例程提供一个高级语言接口来补充HLA。实际上，HLA语言本身最初就是专门设计用来创建一套高级的库例程的。这个高级接口，加上库中许多例程的高级特性，带来了令人惊讶的强大功能，并且易于使用。
- en: The HLA Standard Library consists of several modules organized by category.
    [Table 1-5](ch01s10.html#hla_standard_library_modules "Table 1-5. HLA Standard
    Library Modules") lists many of the modules that are available.^([[12](#ftn.CHP-1-FN-12)])
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: HLA标准库由几个按类别组织的模块组成。[表1-5](ch01s10.html#hla_standard_library_modules "表1-5.
    HLA标准库模块")列出了许多可用的模块。^([[12](#ftn.CHP-1-FN-12)])
- en: Table 1-5. HLA Standard Library Modules
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-5. HLA标准库模块
- en: '| Name | Description |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `args` | Command-line parameter-parsing support routines. |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| `args` | 命令行参数解析支持例程。 |'
- en: '| `arrays` | Array declarations and operations. |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| `arrays` | 数组声明和操作。 |'
- en: '| `bits` | Bit-manipulation functions. |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| `bits` | 位操作函数。 |'
- en: '| `blobs` | Binary large objects—operations on large blocks of binary data.
    |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `blobs` | 二进制大对象——对大块二进制数据的操作。 |'
- en: '| `bsd` | OS API calls for FreeBSD (HLA FreeBSD version only). |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `bsd` | FreeBSD的操作系统API调用（仅限HLA FreeBSD版本）。 |'
- en: '| `chars` | Operations on character data. |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `chars` | 对字符数据的操作。 |'
- en: '| `console` | Portable console (text screen) operations (cursor movement, screen
    clears, etc.). |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `console` | 可移植的控制台（文本屏幕）操作（光标移动、屏幕清除等）。 |'
- en: '| `conv` | Various conversions between strings and other values. |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `conv` | 字符串与其他值之间的各种转换。 |'
- en: '| `coroutines` | Support for coroutines ("cooperative multitasking"). |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `coroutines` | 支持协程（“协作式多任务”）。 |'
- en: '| `cset` | Character set functions. |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| `cset` | 字符集函数。 |'
- en: '| `DateTime` | Calendar, date, and time functions. |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| `DateTime` | 日历、日期和时间功能。 |'
- en: '| `env` | Access to OS environment variables. |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| `env` | 访问操作系统环境变量。 |'
- en: '| `excepts` | Exception-handling routines. |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| `excepts` | 异常处理例程。 |'
- en: '| `fileclass` | Object-oriented file input and output. |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| `fileclass` | 面向对象的文件输入输出。 |'
- en: '| `fileio` | File input and output routines. |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `fileio` | 文件输入和输出例程。 |'
- en: '| `filesys` | Access to the OS file system. |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `filesys` | 访问操作系统文件系统。 |'
- en: '| `hla` | Special HLA constants and other values. |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `hla` | 特殊的HLA常量和其他值。 |'
- en: '| `Linux` | Linux system calls (HLA Linux version only). |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `Linux` | Linux系统调用（仅限HLA Linux版本）。 |'
- en: '| `lists` | An HLA class for manipulating linked lists. |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| `lists` | HLA类，用于操作链表。 |'
- en: '| `mac` | OS API calls for Mac OS X (HLA Mac OS X version only). |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `mac` | Mac OS X的操作系统API调用（仅限HLA Mac OS X版本）。 |'
- en: '| `math` | Extended-precision arithmetic, transcendental functions, and other
    mathematical functions. |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `math` | 扩展精度算术、超越函数和其他数学函数。 |'
- en: '| `memmap` | Memory-mapped file operations. |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `memmap` | 内存映射文件操作。 |'
- en: '| `memory` | Memory allocation, deallocation, and support code. |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| `memory` | 内存分配、释放和支持代码。 |'
- en: '| `patterns` | The HLA pattern-matching library. |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| `patterns` | HLA模式匹配库。 |'
- en: '| `random` | Pseudo-random number generators and support code. |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| `random` | 伪随机数生成器和支持代码。 |'
- en: '| `sockets` | A set of network communication functions and classes. |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `sockets` | 一组网络通信函数和类。 |'
- en: '| `stderr` | Provides user output and several other support functions. |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| `stderr` | 提供用户输出和其他几个支持函数。 |'
- en: '| `stdin` | User input routines. |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `stdin` | 用户输入例程。 |'
- en: '| `stdio` | A support module for stderr, stdin, and stdout. |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| `stdio` | 支持stderr、stdin和stdout的模块。 |'
- en: '| `stdout` | Provides user output and several other support routines. |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| `stdout` | 提供用户输出和其他几个支持例程。 |'
- en: '| `strings` | HLA''s powerful string library. |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| `strings` | HLA强大的字符串库。 |'
- en: '| `tables` | Table (associative array) support routines. |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| `tables` | 表（关联数组）支持例程。 |'
- en: '| `threads` | Support for multithreaded applications and process synchronization.
    |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| `threads` | 支持多线程应用程序和进程同步。 |'
- en: '| `timers` | Support for timing events in an application. |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| `timers` | 支持应用程序中的定时事件。 |'
- en: '| `win32` | Constants used in Windows calls (HLA Windows version only). |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| `win32` | 用于Windows调用的常量（仅限HLA Windows版本）。 |'
- en: '| `x86` | Constants and other items specific to the 80x86 CPU. |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| `x86` | 特定于80x86 CPU的常量和其他项。 |'
- en: Later sections of this text will explain many of these modules in greater detail.
    This section will concentrate on the most important routines (at least to beginning
    HLA programmers), the `stdio` library.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 后续部分将更详细地解释这些模块。本节将集中讨论最重要的例程（至少对于初学者HLA程序员来说），即`stdio`库。
- en: 1.10.1 Predefined Constants in the stdio Module
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.10.1 stdio模块中的预定义常量
- en: 'Perhaps the first place to start is with a description of some common constants
    that the `stdio` module defines for you. Consider the following (typical) example:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 也许首先要介绍的是`stdio`模块为你定义的一些常见常量。请考虑以下（典型）示例：
- en: '[PRE42]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `nl` appearing at the end of this statement stands for *newline*. The `nl`
    identifier is not a special HLA reserved word, nor is it specific to the `stdout.put`
    statement. Instead, it's simply a predefined constant that corresponds to the
    string containing the standard end-of-line sequence (a carriage return/line feed
    pair under Windows or just a line feed under Linux, FreeBSD, and Mac OS X).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`nl`出现在此语句的末尾，代表*换行*。`nl`标识符不是HLA的保留关键字，也与`stdout.put`语句无关。相反，它只是一个预定义常量，对应包含标准换行符序列的字符串（在Windows下是回车/换行对，在Linux、FreeBSD和Mac
    OS X下只是换行符）。 '
- en: In addition to the `nl` constant, the HLA standard I/O library module defines
    several other useful character constants, as listed in [Table 1-6](ch01s10.html#character_constants_defined_by_the_hla_s
    "Table 1-6. Character Constants Defined by the HLA Standard I/O Library").
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`nl`常量外，HLA标准I/O库模块还定义了几个其他有用的字符常量，具体见[表1-6](ch01s10.html#character_constants_defined_by_the_hla_s
    "表1-6. HLA标准I/O库定义的字符常量")。
- en: Table 1-6. Character Constants Defined by the HLA Standard I/O Library
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-6. HLA标准I/O库定义的字符常量
- en: '| Character | Definition |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 定义 |'
- en: '| --- | --- |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `stdio.bell` | The ASCII bell character; beeps the speaker when printed |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `stdio.bell` | ASCII铃声字符；打印时会发出蜂鸣声 |'
- en: '| `stdio.bs` | The ASCII backspace character |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| `stdio.bs` | ASCII退格符字符 |'
- en: '| `stdio.tab` | The ASCII tab character |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| `stdio.tab` | ASCII制表符字符 |'
- en: '| `stdio.lf` | The ASCII linefeed character |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| `stdio.lf` | ASCII换行符字符 |'
- en: '| `stdio.cr` | The ASCII carriage return character |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| `stdio.cr` | ASCII回车符字符 |'
- en: Except for `nl`, these characters appear in the `stdio` namespace^([[13](#ftn.CHP-1-FN-13)])
    (and therefore require the `stdio`. prefix). The placement of these ASCII constants
    within the `stdio` namespace helps avoid naming conflicts with your own variables.
    The `nl` name does not appear within a namespace because you will use it very
    often, and typing `stdio.nl` would get tiresome very quickly.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`nl`外，这些字符出现在`stdio`命名空间中^([[13](#ftn.CHP-1-FN-13)])（因此需要使用`stdio`前缀）。将这些ASCII常量放置在`stdio`命名空间内有助于避免与您自己变量的命名冲突。`nl`名称不出现在命名空间中，因为您会非常频繁地使用它，键入`stdio.nl`会很快变得麻烦。
- en: 1.10.2 Standard In and Standard Out
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.10.2 标准输入和标准输出
- en: Many of the HLA I/O routines have a `stdin` or `stdout` prefix. Technically,
    this means that the standard library defines these names in a namespace. In practice,
    this prefix suggests where the input is coming from (the standard input device)
    or going to (the standard output device). By default, the standard input device
    is the system keyboard. Likewise, the default standard output device is the console
    display. So, in general, statements that have `stdin` or `stdout` prefixes will
    read and write data on the console device.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 许多HLA I/O例程有一个`stdin`或`stdout`前缀。从技术上讲，这意味着标准库在一个命名空间中定义了这些名称。实际上，这个前缀提示了输入来源（标准输入设备）或输出目标（标准输出设备）。默认情况下，标准输入设备是系统键盘。同样，默认标准输出设备是控制台显示。因此，一般来说，带有`stdin`或`stdout`前缀的语句将在控制台设备上读写数据。
- en: When you run a program from the command-line window (or shell), you have the
    option of *redirecting* the standard input and/or standard output devices. A command-line
    parameter of the form `>outfile` redirects the standard output device to the specified
    file (outfile). A command-line parameter of the form `<infile` redirects the standard
    input so that its data comes from the specified input file (infile). The following
    examples demonstrate how to use these parameters when running a program named
    *testpgm* in the command window:^([[14](#ftn.CHP-1-FN-14)])
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从命令行窗口（或shell）运行程序时，可以选择*重定向*标准输入和/或标准输出设备。形式为`>outfile`的命令行参数将标准输出设备重定向到指定的文件（outfile）。形式为`<infile`的命令行参数将标准输入重定向，使得输入数据来自指定的输入文件（infile）。以下示例展示了如何在命令窗口运行名为*testpgm*的程序时使用这些参数：^([[14](#ftn.CHP-1-FN-14)])
- en: '[PRE43]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 1.10.3 The stdout.newln Routine
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.10.3 `stdout.newln`例程
- en: 'The `stdout.newln` procedure prints a newline sequence to the standard output
    device. This is functionally equivalent to saying `stdout.put( nl );`. The call
    to `stdout.newln` is sometimes a little more convenient. For example:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdout.newln`过程将换行符序列输出到标准输出设备。这在功能上等同于执行`stdout.put( nl );`。调用`stdout.newln`有时更加方便。例如：'
- en: '[PRE44]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 1.10.4 The stdout.putiX Routines
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.10.4 `stdout.putiX`例程
- en: The `stdout.puti8`, `stdout.puti16`, and `stdout.puti32` library routines print
    a single parameter (one byte, two bytes, or four bytes, respectively) as a signed
    integer value. The parameter may be a constant, a register, or a memory variable,
    as long as the size of the actual parameter is the same as the size of the formal
    parameter.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdout.puti8`、`stdout.puti16`和`stdout.puti32`库例程将一个单一参数（分别为一个字节、两个字节或四个字节）作为有符号整数值输出。该参数可以是常量、寄存器或内存变量，只要实际参数的大小与形式参数的大小相同。'
- en: 'These routines print the value of their specified parameter to the standard
    output device. These routines will print the value using the minimum number of
    print positions possible. If the number is negative, these routines will print
    a leading minus sign. Here are some examples of calls to these routines:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例程将其指定参数的值打印到标准输出设备。这些例程将使用尽可能少的打印位置打印该值。如果数字是负数，这些例程将打印一个前导负号。以下是调用这些例程的一些示例：
- en: '[PRE45]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 1.10.5 The stdout.putiXSize Routines
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.10.5 `stdout.putiXSize`例程
- en: 'The `stdout.puti8Size`, `stdout.puti16Size`, and `stdout.puti32Size` routines
    output signed integer values to the standard output, just like the `stdout.puti`*`X`*
    routines. These routines, however, provide more control over the output; they
    let you specify the (minimum) number of print positions the value will require
    on output. These routines also let you specify a padding character should the
    print field be larger than the minimum needed to display the value. These routines
    require the following parameters:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdout.puti8Size`、`stdout.puti16Size`和`stdout.puti32Size`例程将有符号整数值输出到标准输出，类似于`stdout.puti`*`X`*例程。不同的是，这些例程提供了更多的输出控制；它们允许您指定输出时值所需的（最小）打印位置数。这些例程还允许您指定填充字符，如果打印字段大于显示值所需的最小空间时使用。调用这些例程需要以下参数：'
- en: '[PRE46]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The *`Value*`* parameter can be a constant, a register, or a memory location
    of the specified size. The *`width`* parameter can be any signed integer constant
    that is between −256 and +256; this parameter may be a constant, register (32-bit),
    or memory location (32-bit). The *`padchar`* parameter should be a single-character
    value.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '*`Value*`*参数可以是常量、寄存器或指定大小的内存位置。*`width`*参数可以是一个在−256和+256之间的有符号整数常量；该参数可以是常量、寄存器（32位）或内存位置（32位）。*`padchar`*参数应为单字符值。'
- en: Like the `stdout.puti`*`X`* routines, these routines print the specified value
    as a signed integer constant to the standard output device. These routines, however,
    let you specify the *field width* for the value. The field width is the minimum
    number of print positions these routines will use when printing the value. The
    `width` parameter specifies the minimum field width. If the number would require
    more print positions (e.g., if you attempt to print `1234` with a field width
    of 2), then these routines will print however many characters are necessary to
    properly display the value. On the other hand, if the *`width`* parameter is greater
    than the number of character positions required to display the value, then these
    routines will print some extra padding characters to ensure that the output has
    at least *`width`* character positions. If the *`width`* value is negative, the
    number is left justified in the print field; if the *`width`* value is positive,
    the number is right justified in the print field.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 与`stdout.puti`*`X`*例程类似，这些例程将指定的值作为有符号整数常量打印到标准输出设备。不同的是，这些例程允许您指定值的*字段宽度*。字段宽度是这些例程在打印值时将使用的最小打印位置数。`width`参数指定最小字段宽度。如果数字需要更多的打印位置（例如，如果您尝试以2的字段宽度打印`1234`），则这些例程将打印足够的字符以正确显示该值。另一方面，如果*`width`*参数大于显示该值所需的字符位置数，则这些例程将打印一些额外的填充字符，以确保输出至少有*`width`*个字符位置。如果*`width`*值为负，则数字在打印字段中左对齐；如果*`width`*值为正，则数字在打印字段中右对齐。
- en: If the absolute value of the *`width`* parameter is greater than the minimum
    number of print positions, then these `stdout.puti`*`X`*`Size` routines will print
    a padding character before or after the number. The *`padchar`* parameter specifies
    which character these routines will print. Most of the time you would specify
    a space as the pad character; for special cases, you might specify some other
    character. Remember, the *`padchar`* parameter is a character value; in HLA character
    constants are surrounded by apostrophes, not quotation marks. You may also specify
    an 8-bit register as this parameter.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*`width`*参数的绝对值大于最小打印位置数，那么这些`stdout.puti`*`X`*`Size`例程将在数字前后打印填充字符。*`padchar`*参数指定这些例程将打印的字符。大多数情况下，您会将空格指定为填充字符；对于特殊情况，您可能会指定其他字符。请记住，*`padchar`*参数是一个字符值；在HLA中，字符常量用撇号括起来，而不是引号。您还可以指定一个8位寄存器作为该参数。
- en: '[Example 1-4](ch01s10.html#tabular_output_demonstration_using_stdio "Example 1-4. Tabular
    output demonstration using stdio.Puti32Size") provides a short HLA program that
    demonstrates the use of the `stdout.puti32Size` routine to display a list of values
    in tabular form.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-4](ch01s10.html#tabular_output_demonstration_using_stdio "示例 1-4. 使用
    stdio.Puti32Size 的表格输出演示")提供了一个简短的HLA程序，演示了如何使用`stdout.puti32Size`例程以表格形式显示一系列值。'
- en: Example 1-4. Tabular output demonstration using `stdio.Puti32Size`
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-4. 使用 `stdio.Puti32Size` 的表格输出演示
- en: '[PRE47]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 1.10.6 The stdout.put Routine
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.10.6 `stdout.put` 例程
- en: The `stdout.put` routine^([[15](#ftn.CHP-1-FN-15)]) is the one of the most flexible
    output routines in the standard output library module. It combines most of the
    other output routines into a single, easy-to-use procedure.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdout.put`例程^([[15](#ftn.CHP-1-FN-15)])是标准输出库模块中最灵活的输出例程之一。它将大多数其他输出例程合并为一个易于使用的过程。'
- en: 'The generic form for the `stdout.put` routine is the following:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdout.put`例程的通用格式如下：'
- en: '[PRE48]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `stdout.put` parameter list consists of one or more constants, registers,
    or memory variables, each separated by a comma. This routine displays the value
    associated with each parameter appearing in the list. Because we''ve already been
    using this routine throughout this chapter, you''ve already seen many examples
    of this routine''s basic form. It is worth pointing out that this routine has
    several additional features not apparent in the examples appearing in this chapter.
    In particular, each parameter can take one of the following two forms:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdout.put`参数列表由一个或多个常量、寄存器或内存变量组成，每个项之间用逗号分隔。该例程显示与每个参数相关联的值。由于我们在本章中已经多次使用该例程，因此你已经看到了许多该例程基本形式的示例。值得指出的是，该例程有一些在本章示例中未体现的附加功能。特别是，每个参数可以采用以下两种形式之一：'
- en: '[PRE49]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The *`value`* may be any legal constant, register, or memory variable object.
    In this chapter, you've seen string constants and memory variables appearing in
    the `stdout.put` parameter list. These parameters correspond to the first form
    above. The second parameter form above lets you specify a minimum field width,
    similar to the `stdout.puti`*`X`*`Size` routines.^([[16](#ftn.CHP-1-FN-16)]) The
    program in [Example 1-5](ch01s10.html#demonstration_of_the_stdout.put_field_wi
    "Example 1-5. Demonstration of the stdout.put field width specification") produces
    the same output as the program in [Example 1-4](ch01s10.html#tabular_output_demonstration_using_stdio
    "Example 1-4. Tabular output demonstration using stdio.Puti32Size"); however,
    [Example 1-5](ch01s10.html#demonstration_of_the_stdout.put_field_wi "Example 1-5. Demonstration
    of the stdout.put field width specification") uses `stdout.put` rather than `stdout.puti32Size`.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '*`value`*可以是任何合法的常量、寄存器或内存变量对象。在本章中，你已看到字符串常量和内存变量出现在`stdout.put`的参数列表中。这些参数对应于上面提到的第一种形式。上述第二种参数形式允许你指定最小字段宽度，类似于`stdout.puti`*`X`*`Size`例程。^([[16](#ftn.CHP-1-FN-16)])
    [示例 1-5](ch01s10.html#demonstration_of_the_stdout.put_field_wi "示例 1-5. `stdout.put`
    字段宽度指定演示")的程序产生与[示例 1-4](ch01s10.html#tabular_output_demonstration_using_stdio
    "示例 1-4. 使用 stdio.Puti32Size 的表格输出演示")相同的输出；然而，[示例 1-5](ch01s10.html#demonstration_of_the_stdout.put_field_wi
    "示例 1-5. `stdout.put` 字段宽度指定演示")使用的是`stdout.put`而非`stdout.puti32Size`。'
- en: Example 1-5. Demonstration of the `stdout.put` field width specification
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-5. `stdout.put` 字段宽度指定的演示
- en: '[PRE50]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `stdout.put` routine is capable of much more than the few attributes this
    section describes. This text will introduce those additional capabilities as appropriate.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdout.put`例程的功能远不止本节描述的这些属性。本文将根据需要介绍这些附加功能。'
- en: 1.10.7 The stdin.getc Routine
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.10.7 `stdin.getc` 例程
- en: The `stdin.getc` routine reads the next available character from the standard
    input device's input buffer.^([[17](#ftn.CHP-1-FN-17)]) It returns this character
    in the CPU's AL register. The program in [Example 1-6](ch01s10.html#demonstration_of_the_stdin.getc_open_par
    "Example 1-6. Demonstration of the stdin.getc() routine") demonstrates a simple
    use of this routine.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdin.getc`例程从标准输入设备的输入缓冲区读取下一个可用字符。^([[17](#ftn.CHP-1-FN-17)]) 它将该字符返回到CPU的AL寄存器中。[示例
    1-6](ch01s10.html#demonstration_of_the_stdin.getc_open_par "示例 1-6. stdin.getc()
    例程演示")中的程序演示了该例程的一个简单用法。'
- en: Example 1-6. Demonstration of the `stdin.getc()` routine
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-6. `stdin.getc()` 例程演示
- en: '[PRE51]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This program uses the `stdin.ReadLn` routine to force a new line of input from
    the user. A description of `stdin.ReadLn` appears in [1.10.9 The stdin.readLn
    and stdin.flushInput Routines](ch01s10.html#the_stdin.readln_and_stdin.flushinput_ro
    "1.10.9 The stdin.readLn and stdin.flushInput Routines").
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序使用`stdin.ReadLn`例程强制从用户输入一个新的行。关于`stdin.ReadLn`的描述见[1.10.9 `stdin.readLn`和`stdin.flushInput`例程](ch01s10.html#the_stdin.readln_and_stdin.flushinput_ro
    "1.10.9 stdin.readLn和stdin.flushInput例程")。
- en: 1.10.8 The stdin.geti X Routines
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.10.8 `stdin.getiX` 例程
- en: The `stdin.geti8`, `stdin.geti16`, and `stdin.geti32` routines read 8-, 16-,
    and 32-bit signed integer values from the standard input device. These routines
    return their values in the AL, AX, or EAX register, respectively. They provide
    the standard mechanism for reading signed integer values from the user in HLA.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdin.geti8`、`stdin.geti16`和`stdin.geti32`例程分别从标准输入设备读取8位、16位和32位有符号整数值。这些例程将它们的值返回到AL、AX或EAX寄存器中。它们提供了在HLA中从用户读取有符号整数值的标准机制。'
- en: Like the `stdin.getc` routine, these routines read a sequence of characters
    from the standard input buffer. They begin by skipping over any whitespace characters
    (spaces, tabs, and so on) and then convert the following stream of decimal digits
    (with an optional leading minus sign) into the corresponding integer. These routines
    raise an exception (that you can trap with the `try..endtry` statement) if the
    input sequence is not a valid integer string or if the user input is too large
    to fit in the specified integer size. Note that values read by `stdin.geti8` must
    be in the range −128..+127; values read by `stdin.geti16` must be in the range
    −32,768..+32,767; and values read by `stdin.geti32` must be in the range −2,147,483,648..+2,147,483,647.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 像`stdin.getc`例程一样，这些例程从标准输入缓冲区读取一串字符。它们首先跳过任何空白字符（空格、制表符等），然后将接下来的十进制数字流（可选的前导负号）转换为相应的整数。如果输入序列不是有效的整数字符串，或者用户输入的值太大，无法适应指定的整数大小，这些例程会引发一个异常（你可以通过`try..endtry`语句来捕获该异常）。请注意，`stdin.geti8`读取的值必须在−128到+127之间；`stdin.geti16`读取的值必须在−32,768到+32,767之间；`stdin.geti32`读取的值必须在−2,147,483,648到+2,147,483,647之间。
- en: The sample program in [Example 1-7](ch01s10.html#stdin.getix_example_code "Example 1-7. stdin.getiX
    example code") demonstrates the use of these routines.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 1-7](ch01s10.html#stdin.getix_example_code "示例 1-7. stdin.getiX 示例代码")中的示例程序演示了这些例程的使用。
- en: Example 1-7. `stdin.getiX` example code
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-7. `stdin.getiX` 示例代码
- en: '[PRE52]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You should compile and run this program and then test what happens when you
    enter a value that is out of range or enter an illegal string of characters.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该编译并运行这个程序，然后测试当你输入超出范围的值或输入非法字符时会发生什么。
- en: 1.10.9 The stdin.readLn and stdin.flushInput Routines
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.10.9 `stdin.readLn`和`stdin.flushInput`例程
- en: 'Whenever you call an input routine like `stdin.getc` or `stdin.geti32`, the
    program does not necessarily read the value from the user at that moment. Instead,
    the HLA Standard Library buffers the input by reading a whole line of text from
    the user. Calls to input routines will fetch data from this input buffer until
    the buffer is empty. While this buffering scheme is efficient and convenient,
    sometimes it can be confusing. Consider the following code sequence:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你调用像`stdin.getc`或`stdin.geti32`这样的输入例程时，程序不一定会在那个时刻从用户那里读取值。相反，HLA标准库会通过从用户那里读取整行文本来缓冲输入。调用输入例程时，会从这个输入缓冲区中获取数据，直到缓冲区为空。虽然这种缓冲机制高效且方便，但有时也可能会让人感到困惑。考虑以下代码示例：
- en: '[PRE53]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Intuitively, you would expect the program to print the first prompt message,
    wait for user input, print the second prompt message, and wait for the second
    user input. However, this isn't exactly what happens. For example, if you run
    this code (from the sample program in the previous section) and enter the text
    **`123 456`** in response to the first prompt, the program will not stop for additional
    user input at the second prompt. Instead, it will read the second integer (456)
    from the input buffer read during the execution of the `stdin.geti16` call.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 直观上，你会期望程序打印出第一个提示信息，等待用户输入，然后打印第二个提示信息，等待第二次用户输入。然而，实际情况并非如此。例如，如果你运行这段代码（来自上一节的示例程序），并在第一个提示符处输入文本**`123
    456`**，程序不会在第二个提示符处等待额外的用户输入。相反，它会在执行`stdin.geti16`调用时，从输入缓冲区读取第二个整数（456）。
- en: 'In general, the `stdin` routines read text from the user only when the input
    buffer is empty. As long as the input buffer contains additional characters, the
    input routines will attempt to read their data from the buffer. You can take advantage
    of this behavior by writing code sequences such as the following:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`stdin`例程仅在输入缓冲区为空时从用户读取文本。只要输入缓冲区包含额外的字符，输入例程将尝试从缓冲区中读取数据。你可以通过编写以下代码序列来利用这种行为：
- en: '[PRE54]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This sequence allows the user to enter both values on the same line (separated
    by one or more whitespace characters), thus preserving space on the screen. So
    the input buffer behavior is desirable every now and then. The buffered behavior
    of the input routines can be counterintuitive at other times.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 该序列允许用户在同一行输入两个值（由一个或多个空白字符分隔），从而节省屏幕空间。因此，输入缓冲区的行为有时是可取的。输入例程的缓冲行为在其他时候可能是反直觉的。
- en: Fortunately, the HLA Standard Library provides two routines, `stdin.readLn`
    and `stdin.flushInput`, that let you control the standard input buffer. The `stdin.readLn`
    routine discards everything that is in the input buffer and immediately requires
    the user to enter a new line of text. The `stdin.flushInput` routine simply discards
    everything that is in the buffer. The next time an input routine executes, the
    system will require a new line of input from the user. You would typically call
    `stdin.readLn` immediately before some standard input routine; you would normally
    call `stdin.flushInput` immediately after a call to a standard input routine.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，HLA标准库提供了两个例程，`stdin.readLn`和`stdin.flushInput`，它们允许你控制标准输入缓冲区。`stdin.readLn`例程丢弃输入缓冲区中的所有内容，并立即要求用户输入新的一行文本。`stdin.flushInput`例程只是丢弃缓冲区中的所有内容。下一次输入例程执行时，系统将要求用户输入新的一行数据。你通常会在某个标准输入例程之前立即调用`stdin.readLn`；在调用标准输入例程之后，通常会立即调用`stdin.flushInput`。
- en: Note
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are calling `stdin.readLn` and you find that you are having to input
    your data twice, this is a good indication that you should be calling `stdin.flushInput`
    rather than `stdin.readLn`. In general, you should always be able to call `stdin.flushInput`
    to flush the input buffer and read a new line of data on the next input call.
    The `stdin.readLn` routine is rarely necessary, so you should use `stdin.flushInput`
    unless you really need to immediately force the input of a new line of text.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在调用`stdin.readLn`，并且发现你需要输入两次数据，这通常表明你应该调用`stdin.flushInput`而不是`stdin.readLn`。通常，你应该始终能够调用`stdin.flushInput`来刷新输入缓冲区，并在下一次输入调用时读取新的一行数据。`stdin.readLn`例程很少需要使用，因此除非你真的需要立即强制输入新的一行文本，否则应该使用`stdin.flushInput`。
- en: 1.10.10 The stdin.get Routine
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.10.10 `stdin.get`例程
- en: The `stdin.get` routine combines many of the standard input routines into a
    single call, just as the `stdout.put` combines all of the output routines into
    a single call. Actually, `stdin.get` is a bit easier to use than `stdout.put`
    because the only parameters to this routine are a list of variable names.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdin.get`例程将许多标准输入例程合并为一个调用，就像`stdout.put`将所有输出例程合并为一个调用一样。实际上，`stdin.get`比`stdout.put`更易于使用，因为该例程的唯一参数是变量名列表。'
- en: 'Let''s rewrite the example given in the previous section:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写上一节给出的示例：
- en: '[PRE55]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Using the `stdin.get` routine, we could rewrite this code as:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`stdin.get`例程，我们可以将此代码重写为：
- en: '[PRE56]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, the `stdin.get` routine is a little more convenient to use.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`stdin.get`例程更方便使用。
- en: Note that `stdin.get` stores the input values directly into the memory variables
    you specify in the parameter list; it does not return the values in a register
    unless you actually specify a register as a parameter. The `stdin.get` parameters
    must all be variables or registers.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`stdin.get`将输入值直接存储到你在参数列表中指定的内存变量中；除非你明确指定了寄存器作为参数，否则它不会将值返回到寄存器中。`stdin.get`的所有参数必须是变量或寄存器。
- en: '* * *'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[11](#CHP-1-FN-11)]) For example, see the UCR Standard Library for 80x86
    Assembly Language Programmers.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[11](#CHP-1-FN-11)]) 例如，请参阅针对80x86汇编语言程序员的UCR标准库。
- en: ^([[12](#CHP-1-FN-12)]) Because the HLA Standard Library is expanding, this
    list is probably out of date. See the HLA documentation for a current list of
    Standard Library modules.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[12](#CHP-1-FN-12)]) 由于HLA标准库正在扩展，这个列表可能已经过时。请参阅HLA文档以获取当前的标准库模块列表。
- en: ^([[13](#CHP-1-FN-13)]) Namespaces are the subject of [Chapter 5](ch05.html
    "Chapter 5. PROCEDURES AND UNITS").
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[13](#CHP-1-FN-13)]) 命名空间是[第5章](ch05.html "第5章. 程序和单元")的主题。
- en: ^([[14](#CHP-1-FN-14)]) For Linux, FreeBSD, and Mac OS X users, depending on
    how your system is set up, you may need to type `./` in front of the program's
    name to actually execute the program (e.g., `./testpgm <input.data)`.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[14](#CHP-1-FN-14)]) 对于 Linux、FreeBSD 和 Mac OS X 用户，根据系统的配置，可能需要在程序名称前加上
    `./` 才能执行程序（例如，`./testpgm <input.data>`）。
- en: ^([[15](#CHP-1-FN-15)]) `stdout.put` is actually a macro, not a procedure. The
    distinction between the two is beyond the scope of this chapter. [Chapter 9](ch09.html
    "Chapter 9. MACROS AND THE HLA COMPILE-TIME LANGUAGE") describes their differences.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[15](#CHP-1-FN-15)]) `stdout.put` 实际上是一个宏，而不是一个过程。两者之间的区别超出了本章的范围。[第 9 章](ch09.html
    "第 9 章. 宏和 HLA 编译时语言") 描述了它们的区别。
- en: ^([[16](#CHP-1-FN-16)]) Note that you cannot specify a padding character when
    using the `stdout.put` routine; the padding character defaults to the space character.
    If you need to use a different padding character, call the `stdout.puti`*`X`*`Size`
    routines.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[16](#CHP-1-FN-16)]) 请注意，使用 `stdout.put` 例程时无法指定填充字符；填充字符默认为空格字符。如果需要使用不同的填充字符，可以调用
    `stdout.puti`*`X`*`Size` 例程。
- en: ^([[17](#CHP-1-FN-17)]) *Buffer* is just a fancy term for an array.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[17](#CHP-1-FN-17)]) *缓冲区* 只是一个表示数组的 fancy 术语。
- en: 1.11 Additional Details About try..endtry
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.11 关于 try..endtry 的附加细节
- en: 'As you may recall, the `try..endtry` statement surrounds a block of statements
    in order to capture any exceptions that occur during the execution of those statements.
    The system raises exceptions in one of three ways: through a hardware fault (such
    as a divide-by-zero error), through an operating system-generated exception, or
    through the execution of the HLA `raise` statement. You can write an exception
    handler to intercept specific exceptions using the `exception` clause. The program
    in [Example 1-8](ch01s11.html#try..endtry_example "Example 1-8. try..endtry example")
    provides a typical example of the use of this statement.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记得，`try..endtry` 语句将一组语句包围起来，以捕捉在执行这些语句过程中发生的任何异常。系统通过以下三种方式之一引发异常：通过硬件故障（如除零错误）、通过操作系统生成的异常，或通过执行
    HLA `raise` 语句。你可以编写异常处理程序，使用 `exception` 子句来拦截特定的异常。[示例 1-8](ch01s11.html#try..endtry_example
    "示例 1-8. try..endtry 示例") 中的程序提供了使用此语句的典型示例。
- en: Example 1-8. `try..endtry` example
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-8. `try..endtry` 示例
- en: '[PRE57]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: HLA refers to the statements between the `try` clause and the first `exception`
    clause as the *protected* statements. If an exception occurs within the protected
    statements, then the program will scan through each of the exceptions and compare
    the value of the current exception against the value in the parentheses after
    each of the `exception` clauses.^([[18](#ftn.CHP-1-FN-18)]) This exception value
    is simply a 32-bit value. The value in the parentheses after each `exception`
    clause, therefore, must be a 32-bit value. The HLA *excepts.hhf* header file predefines
    several exception constants. Although it would be an incredibly bad style violation,
    you could substitute the numeric values for the two `exception` clauses above.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 将 `try` 子句与第一个 `exception` 子句之间的语句称为 *保护* 语句。如果在保护语句内发生异常，程序将扫描每个异常并将当前异常的值与每个
    `exception` 子句后括号中的值进行比较。^([[18](#ftn.CHP-1-FN-18)]) 这个异常值只是一个 32 位值。因此，每个 `exception`
    子句后括号中的值必须是一个 32 位值。HLA *excepts.hhf* 头文件预定义了几个异常常量。尽管这将是一个极其严重的风格违规，但你仍然可以用数字值来替代上述两个
    `exception` 子句中的值。
- en: 1.11.1 Nesting try..endtry Statements
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.11.1 嵌套 try..endtry 语句
- en: If the program scans through all the `exception` clauses in a `try..endtry`
    statement and does not match the current exception value, then the program searches
    through the `exception` clauses of a *dynamically nested* `try..endtry` block
    in an attempt to find an appropriate exception handler. For example, consider
    the code in [Example 1-9](ch01s11.html#nested_try..endtry_statements "Example 1-9. Nested
    try..endtry statements").
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序扫描完 `try..endtry` 语句中的所有 `exception` 子句并且没有找到与当前异常值匹配的子句，则程序会在 *动态嵌套* 的
    `try..endtry` 块的 `exception` 子句中继续查找，以尝试找到合适的异常处理程序。例如，考虑 [示例 1-9](ch01s11.html#nested_try..endtry_statements
    "示例 1-9. 嵌套 try..endtry 语句") 中的代码。
- en: Example 1-9. Nested `try..endtry` statements
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-9. 嵌套 `try..endtry` 语句
- en: '[PRE58]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In [Example 1-9](ch01s11.html#nested_try..endtry_statements "Example 1-9. Nested
    try..endtry statements") one `try` statement is nested inside another. During
    the execution of the `stdin.get` statement, if the user enters a value greater
    than four billion and some change, then `stdin.get` will raise the `ex.ValueOutOfRange`
    exception. When the HLA runtime system receives this exception, it first searches
    through all the exception clauses in the `try..endtry` statement immediately surrounding
    the statement that raised the exception (this would be the nested `try..endtry`
    in the example above). If the HLA runtime system fails to locate an exception
    handler for `ex.ValueOutOfRange`, then it checks to see if the current `try..endtry`
    is nested inside another `try..endtry` (as is the case in [Example 1-9](ch01s11.html#nested_try..endtry_statements
    "Example 1-9. Nested try..endtry statements")). If so, the HLA runtime system
    searches for the appropriate exception clause in the outer `try..endtry` statement.
    Within the `try..endtry` block appearing in [Example 1-9](ch01s11.html#nested_try..endtry_statements
    "Example 1-9. Nested try..endtry statements") the program finds an appropriate
    exception handler, so control transfers to the statements after the `exception(
    ex.ValueOutOfRange )` clause.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例1-9](ch01s11.html#nested_try..endtry_statements "示例1-9. 嵌套的try..endtry语句")中，一个`try`语句嵌套在另一个`try`语句内。在执行`stdin.get`语句时，如果用户输入一个大于四十亿并且有些变化的值，则`stdin.get`会引发`ex.ValueOutOfRange`异常。当HLA运行时系统接收到此异常时，它首先会在引发异常的语句周围的`try..endtry`语句中的所有异常子句中进行搜索（在上面的示例中就是嵌套的`try..endtry`）。如果HLA运行时系统未能找到`ex.ValueOutOfRange`的异常处理程序，它会检查当前的`try..endtry`是否嵌套在另一个`try..endtry`内（正如[示例1-9](ch01s11.html#nested_try..endtry_statements
    "示例1-9. 嵌套的try..endtry语句")中的情况）。如果是这样，HLA运行时系统会在外层`try..endtry`语句中搜索适当的异常子句。在[示例1-9](ch01s11.html#nested_try..endtry_statements
    "示例1-9. 嵌套的try..endtry语句")中，程序在`try..endtry`块中找到了合适的异常处理程序，因此控制权转移到`exception(
    ex.ValueOutOfRange )`子句后的语句。
- en: After leaving a `try..endtry` block, the HLA runtime system no longer considers
    that block active and will not search through its list of exceptions when the
    program raises an exception.^([[19](#ftn.CHP-1-FN-19)]) This allows you to handle
    the same exception differently in other parts of the program.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 离开`try..endtry`块后，HLA运行时系统不再认为该块是活动的，并且在程序引发异常时不会在其异常列表中进行搜索。^([[19](#ftn.CHP-1-FN-19)])
    这样可以让你在程序的其他部分以不同的方式处理相同的异常。
- en: If two `try..endtry` statements handle the same exception, and one of the `try..endtry`
    blocks is nested inside the protected section of the other `try..endtry` statement,
    and the program raises an exception while executing in the innermost `try..endtry`
    sequence, then HLA transfers control directly to the exception handler provided
    by the innermost `try..endtry` block. HLA does not automatically transfer control
    to the exception handler provided by the outer `try..endtry` sequence.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个`try..endtry`语句处理相同的异常，并且其中一个`try..endtry`块嵌套在另一个`try..endtry`语句的保护区段内，并且程序在执行最内层的`try..endtry`序列时引发异常，则HLA会直接将控制权转移到最内层`try..endtry`块提供的异常处理程序。HLA不会自动将控制权转移到外层`try..endtry`序列提供的异常处理程序。
- en: 'In the previous example ([Example 1-9](ch01s11.html#nested_try..endtry_statements
    "Example 1-9. Nested try..endtry statements")) the second `try..endtry` statement
    was statically nested inside the enclosing `try..endtry` statement.^([[20](#ftn.CHP-1-FN-20)])
    As mentioned without comment earlier, if the most recently activated `try..endtry`
    statement does not handle a specific exception, the program will search through
    the `exception` clauses of any dynamically nesting `try..endtry` blocks. Dynamic
    nesting does not require the nested `try..endtry` block to physically appear within
    the enclosing `try..endtry` statement. Instead, control could transfer from inside
    the enclosing `try..endtry` protected block to some other point in the program.
    Execution of a `try..endtry` statement at that other point dynamically nests the
    two `try` statements. Although there are many ways to dynamically nest code, there
    is one method you are probably familiar with from your high-level language experience:
    the procedure call. In [Chapter 5](ch05.html "Chapter 5. PROCEDURES AND UNITS"),
    when you learn how to write procedures (functions) in assembly language, you should
    keep in mind that any call to a procedure within the protected section of a `try..endtry`
    block can create a dynamically nested `try..endtry` if the program executes a
    `try..endtry` within that procedure.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中（[示例 1-9](ch01s11.html#nested_try..endtry_statements "示例 1-9. 嵌套的 try..endtry
    语句")），第二个 `try..endtry` 语句是静态地嵌套在外部的 `try..endtry` 语句内部的。^([[20](#ftn.CHP-1-FN-20)])
    正如之前没有评论提到的，如果最近激活的 `try..endtry` 语句没有处理特定的异常，程序将通过任何动态嵌套的 `try..endtry` 块的 `exception`
    子句进行查找。动态嵌套不要求嵌套的 `try..endtry` 块物理上出现在外部的 `try..endtry` 语句中。相反，控制权可以从外部 `try..endtry`
    保护块内部转移到程序中的其他位置。在该位置执行的 `try..endtry` 语句会动态地将两个 `try` 语句嵌套在一起。虽然有很多方法可以动态嵌套代码，但有一种方法你可能已经通过高级语言的经验熟悉：过程调用。在[第
    5 章](ch05.html "第 5 章. 过程与单元")中，当你学习如何在汇编语言中编写过程（函数）时，应该记住，任何在 `try..endtry` 保护部分内对过程的调用，都可能在该过程中执行
    `try..endtry` 时创建一个动态嵌套的 `try..endtry`。
- en: 1.11.2 The unprotected Clause in a try..endtry Statement
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.11.2 `try..endtry` 语句中的未保护子句
- en: Whenever a program executes the `try` clause, it preserves the current exception
    environment and sets up the system to transfer control to the `exception` clauses
    within that `try..endtry` statement should an exception occur. If the program
    successfully completes the execution of a `try..endtry` protected block, the program
    restores the original exception environment and control transfers to the first
    statement beyond the `endtry` clause. This last step, restoring the execution
    environment, is very important. If the program skips this step, any future exceptions
    will transfer control to this `try..endtry` statement even though the program
    has already left the `try..endtry` block. [Example 1-10](ch01s11.html#improperly_exiting_a_try..endtry_stateme
    "Example 1-10. Improperly exiting a try..endtry statement") demonstrates this
    problem.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 每当程序执行 `try` 子句时，它会保存当前的异常环境，并设置系统，在发生异常时将控制权转移到该 `try..endtry` 语句中的 `exception`
    子句。如果程序成功完成了 `try..endtry` 保护块的执行，程序将恢复原始的异常环境，控制权转移到 `endtry` 子句之后的第一条语句。恢复执行环境的这个最后步骤非常重要。如果程序跳过这一步，任何未来的异常都会将控制权转移到这个
    `try..endtry` 语句，即使程序已经离开了 `try..endtry` 块。[示例 1-10](ch01s11.html#improperly_exiting_a_try..endtry_stateme
    "示例 1-10. 不当退出 try..endtry 语句") 展示了这个问题。
- en: Example 1-10. Improperly exiting a `try..endtry` statement
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-10. 不当退出 `try..endtry` 语句
- en: '[PRE59]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This example attempts to create a robust input system by putting a loop around
    the `try..endtry` statement and forcing the user to reenter the data if the `stdin.get`
    routine raises an exception (because of bad input data). While this is a good
    idea, there is a big problem with this implementation: the `break` statement immediately
    exits the `forever..endfor` loop without first restoring the exception environment.
    Therefore, when the program executes the second `stdin.get` statement, at the
    bottom of the program, the HLA exception-handling code still thinks that it''s
    inside the `try..endtry` block. If an exception occurs, HLA transfers control
    back into the `try..endtry` statement looking for an appropriate exception handler.
    Assuming the exception was `ex.ValueOutOfRange` or `ex.ConversionError`, the program
    in [Example 1-10](ch01s11.html#improperly_exiting_a_try..endtry_stateme "Example 1-10. Improperly
    exiting a try..endtry statement") will print an appropriate error message *and
    then force the user to re-enter the first value*. This isn''t desirable.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例试图通过将一个循环放置在 `try..endtry` 语句周围来创建一个强健的输入系统，并在 `stdin.get` 例程由于输入数据错误而抛出异常时，强制用户重新输入数据。虽然这是一个不错的想法，但该实现有一个重大问题：`break`
    语句会立即退出 `forever..endfor` 循环，而没有先恢复异常环境。因此，当程序执行第二个 `stdin.get` 语句时，在程序底部，HLA
    的异常处理代码仍然认为它在 `try..endtry` 块内部。如果发生异常，HLA 会将控制转回到 `try..endtry` 语句，寻找适当的异常处理程序。假设异常是
    `ex.ValueOutOfRange` 或 `ex.ConversionError`，则[示例 1-10](ch01s11.html#improperly_exiting_a_try..endtry_stateme
    "示例 1-10. 错误地退出 try..endtry 语句")中的程序将打印一个适当的错误信息*并迫使用户重新输入第一个值*。这显然不是理想的做法。
- en: 'Transferring control to the wrong `try..endtry` exception handlers is only
    part of the problem. Another big problem with the code in [Example 1-10](ch01s11.html#improperly_exiting_a_try..endtry_stateme
    "Example 1-10. Improperly exiting a try..endtry statement") has to do with the
    way HLA preserves and restores the exception environment: specifically, HLA saves
    the old execution environment information in a special region of memory known
    as the *stack*. If you exit a `try..endtry` without restoring the exception environment,
    this leaves the old execution environment information on the stack, and this extra
    data on could cause your program to malfunction.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 将控制转交给错误的 `try..endtry` 异常处理程序只是问题的一部分。另一个大问题与 HLA 保存和恢复异常环境的方式有关：具体来说，HLA 将旧的执行环境信息保存在一个特殊的内存区域中，称为
    *堆栈*。如果在不恢复异常环境的情况下退出 `try..endtry`，这将导致旧的执行环境信息仍然保留在堆栈上，而这部分额外的数据可能会导致程序故障。
- en: Although this discussion makes it quite clear that a program should not exit
    from a `try..endtry` statement in the manner that [Example 1-10](ch01s11.html#improperly_exiting_a_try..endtry_stateme
    "Example 1-10. Improperly exiting a try..endtry statement") uses, it would be
    nice if you could use a loop around a `try..endtry` block to force the reentry
    of bad data as this program attempts to do. To allow for this, HLA's `try..endtry`
    statement provides an `unprotected` section. Consider the code in [Example 1-11](ch01s11.html#the_try..endtry_unprotected_section
    "Example 1-11. The try..endtry unprotected section").
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个讨论很清楚地表明，程序不应该以 [示例 1-10](ch01s11.html#improperly_exiting_a_try..endtry_stateme
    "示例 1-10. 错误地退出 try..endtry 语句") 中的方式退出 `try..endtry` 语句，但如果你能够在 `try..endtry`
    块周围使用一个循环，强制重新输入错误数据，就像这个程序尝试做的那样，那就更好了。为了支持这种做法，HLA 的 `try..endtry` 语句提供了一个 `unprotected`
    区域。请参考[示例 1-11](ch01s11.html#the_try..endtry_unprotected_section "示例 1-11. try..endtry
    未保护区域")中的代码。
- en: Example 1-11. The `try..endtry` unprotected section
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-11. `try..endtry` 未保护区域
- en: '[PRE60]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Whenever the `try..endtry` statement hits the `unprotected` clause, it immediately
    restores the exception environment. As the phrase suggests, the execution of statements
    in the `unprotected` section is no longer protected by that `try..endtry` block
    (note, however, that any dynamically nesting `try..endtry` statements will still
    be active; `unprotected` turns off only the exception handling of the `try..endtry`
    statement containing the `unprotected` clause). Because the `break` statement
    in [Example 1-11](ch01s11.html#the_try..endtry_unprotected_section "Example 1-11. The
    try..endtry unprotected section") appears inside the `unprotected` section, it
    can safely transfer control out of the `try..endtry` block without "executing"
    the `endtry` because the program has already restored the former exception environment.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`try..endtry`语句遇到`unprotected`子句时，它会立即恢复异常环境。正如其名称所示，`unprotected`部分中的语句执行不再受到该`try..endtry`块的保护（然而，注意，任何动态嵌套的`try..endtry`语句仍然是活动的；`unprotected`只会关闭包含`unprotected`子句的`try..endtry`语句的异常处理）。因为[示例1-11](ch01s11.html#the_try..endtry_unprotected_section
    "示例1-11. `try..endtry`未保护部分")中的`break`语句出现在`unprotected`部分内，它可以安全地将控制转移出`try..endtry`块，而不需要“执行”`endtry`，因为程序已经恢复了之前的异常环境。
- en: Note that the `unprotected` keyword must appear in the `try..endtry` statement
    immediately after the `protected` block. That is, it must precede all `exception`
    keywords.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`unprotected`关键字必须紧跟在`try..endtry`语句中的`protected`块之后出现。也就是说，它必须位于所有`exception`关键字之前。
- en: If an exception occurs during the execution of a `try..endtry` sequence, HLA
    automatically restores the execution environment. Therefore, you may execute a
    `break` statement (or any other instruction that transfers control out of the
    `try..endtry` block) within an `exception` clause.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行`try..endtry`序列时发生异常，HLA会自动恢复执行环境。因此，你可以在`exception`子句中执行`break`语句（或任何其他会将控制转移出`try..endtry`块的指令）。
- en: Because the program restores the exception environment upon encountering an
    `unprotected` block or an `exception` block, an exception that occurs within one
    of these areas immediately transfers control to the previous (dynamically nesting)
    active `try..endtry` sequence. If there is no nesting `try..endtry` sequence,
    the program aborts with an appropriate error message.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 因为程序在遇到`unprotected`块或`exception`块时会恢复异常环境，所以在这些区域内发生的异常会立即将控制转移到之前的（动态嵌套的）活动`try..endtry`序列。如果没有嵌套的`try..endtry`序列，程序将以适当的错误信息终止。
- en: 1.11.3 The anyexception Clause in a try..endtry Statement
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.11.3 `try..endtry`语句中的`anyexception`子句
- en: In a typical situation, you will use a `try..endtry` statement with a set of
    `exception` clauses that will handle all possible exceptions that can occur in
    the protected section of the `try..endtry` sequence. Often, it is important to
    ensure that a `try..endtry` statement handles all possible exceptions to prevent
    the program from prematurely aborting due to an unhandled exception. If you have
    written all the code in the protected section, you will know the exceptions it
    can raise, so you can handle all possible exceptions. However, if you are calling
    a library routine (especially a third-party library routine), making a OS API
    call, or otherwise executing code that you have no control over, it may not be
    possible for you to anticipate all possible exceptions this code could raise (especially
    when considering past, present, and future versions of the code). If that code
    raises an exception for which you do not have an `exception` clause, this could
    cause your program to fail. Fortunately, HLA's `try..endtry` statement provides
    the `anyexception` clause that will automatically trap any exception the existing
    `exception` clauses do not handle.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的情况下，你将使用`try..endtry`语句，并配合一组`exception`子句来处理在`try..endtry`序列的保护区域内可能发生的所有异常。通常，确保`try..endtry`语句处理所有可能的异常是很重要的，以防程序由于未处理的异常而提前终止。如果你已经编写了保护区内的所有代码，你会知道它可能抛出的异常，因此可以处理所有可能的异常。然而，如果你调用的是一个库函数（尤其是第三方库函数）、进行操作系统API调用，或者执行一些你无法控制的代码，那么你可能无法预测这段代码可能抛出的所有异常（尤其是在考虑过去、现在和未来的版本时）。如果这段代码抛出一个你没有`exception`子句处理的异常，这可能会导致你的程序失败。幸运的是，HLA的`try..endtry`语句提供了`anyexception`子句，它会自动捕获所有现有的`exception`子句没有处理的异常。
- en: The `anyexception` clause is similar to the `exception` clause except it does
    not require an exception number parameter (because it handles any exception).
    If the `anyexception` clause appears in a `try..endtry` statement with other `exception`
    sections, the `anyexception` section must be the last exception handler in the
    `try..endtry` statement. An `anyexception` section may be the only exception handler
    in a `try..endtry` statement.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '`anyexception`子句类似于`exception`子句，不同之处在于它不需要异常编号参数（因为它处理任何异常）。如果`anyexception`子句出现在包含其他`exception`部分的`try..endtry`语句中，`anyexception`部分必须是`try..endtry`语句中的最后一个异常处理程序。`anyexception`部分可以是`try..endtry`语句中的唯一异常处理程序。'
- en: If an otherwise unhandled exception transfers control to an `anyexception` section,
    the EAX register will contain the exception number. Your code in the `anyexception`
    block can test this value to determine the cause of the exception.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个未处理的异常将控制转移到`anyexception`部分，EAX寄存器将包含异常编号。你在`anyexception`块中的代码可以测试这个值，以确定异常的原因。
- en: 1.11.4 Registers and the try..endtry Statement
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.11.4 寄存器与try..endtry语句
- en: The `try..endtry` statement preserves several bytes of data whenever you enter
    a `try..endtry` statement. Upon leaving the `try..endtry` block (or hitting the
    `unprotected` clause), the program restores the exception environment. As long
    as no exception occurs, the `try..endtry` statement does not affect the values
    of any registers upon entry to or upon exit from the `try..endtry` statement.
    However, this claim is not true if an exception occurs during the execution of
    the protected statements.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`try..endtry`语句在你进入`try..endtry`语句时会保存几个字节的数据。离开`try..endtry`块时（或触发`unprotected`子句时），程序会恢复异常环境。只要没有发生异常，`try..endtry`语句在进入或退出时不会影响任何寄存器的值。然而，如果在执行受保护语句期间发生异常，则这一说法不成立。'
- en: Upon entry into an `exception` clause, the EAX register contains the exception
    number, but the values of all other general-purpose registers are undefined. Because
    the operating system may have raised the exception in response to a hardware error
    (and, therefore, has played around with the registers), you can't even assume
    that the general-purpose registers contain whatever values they happened to contain
    at the point of the exception. The underlying code that HLA generates for exceptions
    is subject to change in different versions of the compiler, and certainly it changes
    across operating systems, so it is never a good idea to experimentally determine
    what values registers contain in an exception handler and depend on those values
    in your code.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`exception`子句时，EAX寄存器包含异常编号，但所有其他通用寄存器的值都是未定义的。由于操作系统可能因硬件错误而引发了异常（因此，可能已修改了寄存器的值），你甚至不能假设通用寄存器在异常发生时包含它们所包含的任何值。HLA为异常生成的底层代码在不同版本的编译器中可能会有所变化，当然在不同操作系统之间也会有所不同，因此，在异常处理程序中实验性地确定寄存器包含什么值并依赖于这些值从来不是一个好主意。
- en: 'Because entry into an exception handler can scramble the register values, you
    must ensure that you reload important registers if the code following your `endtry`
    clause assumes that the registers contain certain values (i.e., values set in
    the protected section or values set prior to executing the `try..endtry` statement).
    Failure to do so will introduce some nasty defects into your program (and these
    defects may be very intermittent and difficult to detect because exceptions rarely
    occur and may not always destroy the value in a particular register). The following
    code fragment provides a typical example of this problem and its solution:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 由于进入异常处理程序可能会破坏寄存器的值，因此你必须确保在`endtry`子句之后的代码中，如果假设寄存器包含某些特定值（即在受保护部分中设置的值或在执行`try..endtry`语句之前设置的值），要重新加载重要的寄存器。否则，这将引入一些严重的缺陷到你的程序中（这些缺陷可能是间歇性的并且难以检测，因为异常很少发生，且可能不会总是破坏某个特定寄存器中的值）。以下代码片段提供了这个问题及其解决方案的典型示例：
- en: '[PRE61]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Because the HLA exception-handling mechanism messes with the registers, and
    because exception handling is a relatively inefficient process, you should never
    use the `try..endtry` statement as a generic control structure (e.g., using it
    to simulate a `switch/case` statement by raising an integer exception value and
    using the exception clauses as the cases to process). Doing so will have a very
    negative impact on the performance of your program and may introduce subtle defects
    because exceptions scramble the registers.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: For proper operation, the `try..endtry` statement assumes that you use the EBP
    register only to point at *activation records* ([Chapter 5](ch05.html "Chapter 5. PROCEDURES
    AND UNITS") discusses activation records). By default, HLA programs automatically
    use EBP for this purpose; as long as you do not modify the value in EBP, your
    programs will automatically use EBP to maintain a pointer to the current activation
    record. If you attempt to use the EBP register as a general-purpose register to
    hold values and compute arithmetic results, HLA's exception-handling capabilities
    will no longer function properly (along with other possible problems). Therefore,
    you should never use the EBP register as a general-purpose register. Of course,
    this same discussion applies to the ESP register.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: ^([[18](#CHP-1-FN-18)]) Note that HLA loads this value into the EAX register.
    So upon entry into an `exception` clause, EAX contains the exception number.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: ^([[19](#CHP-1-FN-19)]) Unless, of course, the program re-enters the `try..endtry`
    block via a loop or other control structure.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: ^([[20](#CHP-1-FN-20)]) *Statically nested* means that one statement is physically
    nested within another in the source code. When we say one statement is nested
    within another, this typically means that the statement is statically nested within
    the other statement.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 1.12 High-Level Assembly Language vs. Low-Level Assembly Language
  id: totrans-539
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before concluding this chapter, it's important to remind you that none of the
    control statements appearing in this chapter are "real" assembly language. The
    80x86 CPU does not support machine instructions like `if`, `while`, `repeat`,
    `for`, `break`, `breakif`, and `try`. Whenever HLA encounters these statements,
    it *compiles* them into a sequence of one or more true machine instructions that
    do the operation as the high-level statements you've used. While these statements
    are convenient to use, and in many cases just as efficient as the sequence of
    low-level machine instructions into which HLA translates them, don't lose sight
    of the fact that they are not true machine instructions.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this text is to teach you low-level assembly language programming;
    these high-level control structures are simply a means to that end. Remember,
    learning the HLA high-level control structures allows you to leverage your high-level
    language knowledge early on in the educational process so you don't have to learn
    everything about assembly language all at once. By using high-level control structures
    that you're already comfortable with, this text can put off the discussion of
    the actual machine instructions you'd normally use for control flow until much
    later. By doing so, this text can regulate how much material it presents, so,
    hopefully, you'll find learning assembly language to be much more pleasant. However,
    you must always remember that these high-level control statements are just a pedagogical
    tool to help you learn assembly language. Though you're free to use them in your
    assembly programs once you master the real control-flow statements, you really
    must learn the low-level control statements if you want to learn assembly language
    programming. Since, presumably, that's why you're reading this book, don't allow
    the high-level control structures to become a crutch. When you get to the point
    where you learn how to really write low-level control statements, embrace and
    use them (exclusively). As you gain experience with the low-level control statements
    and learn their advantages and disadvantages, you'll be in a good position to
    decide whether a high-level or low-level code sequence is most appropriate for
    a given application. However, until you gain considerable experience with the
    low-level control structures, you'll not be able to make an educated decision.
    Remember, you can't really call yourself an assembly language programmer unless
    you've mastered the low-level statements.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to keep in mind is that the HLA Standard Library functions are
    not part of the assembly *language*. They're just some convenient functions that
    have been prewritten for you. Although there is nothing wrong with calling these
    functions, always remember that they are not machine instructions and that there
    is nothing special about these routines; as you gain experience writing assembly
    language code, you can write your own versions of each of these routines (and
    even write them more efficiently).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: If you're learning assembly language because you want to write the most efficient
    programs possible (either the fastest or the smallest code), you need to understand
    that you won't achieve this goal completely if you're using high-level control
    statements and making a lot of calls to the HLA Standard Library. HLA's code generator
    and the HLA Standard Library aren't *horribly* inefficient, but the only true
    way to write efficient programs in assembly language is to *think* in assembly
    language. HLA's high-level control statements and many of the routines in the
    HLA Standard Library are great because they let you *avoid* thinking in assembly
    language. While this is great while you're first learning assembly, if your ultimate
    goal is to write efficient code, then you have to learn to think in assembly language.
    This text will get you to that point (and will do so much more rapidly because
    it uses HLA's high-level features), but don't forget that your ultimate goal is
    to give up these high-level features in favor of low-level coding.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你学习汇编语言是因为你想写出尽可能高效的程序（无论是最快还是最小的代码），你需要理解，如果你使用高级控制语句并且频繁调用 HLA 标准库，你将无法完全实现这一目标。HLA
    的代码生成器和 HLA 标准库并不是*极其*低效的，但编写高效汇编程序的唯一真正方式是*用*汇编语言思考。HLA 的高级控制语句以及 HLA 标准库中的许多例程非常棒，因为它们让你*避免*用汇编语言思考。虽然这在你刚开始学习汇编语言时很有用，但如果你的最终目标是写出高效的代码，那么你必须学会用汇编语言思考。这篇文章将帮助你达到这个目标（并且会因为使用了
    HLA 的高级特性而更迅速地做到这一点），但不要忘了，你的最终目标是放弃这些高级特性，转而使用低级编程。
- en: 1.13 For More Information
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.13 更多信息
- en: This chapter has covered a lot of ground! While you still have a lot to learn
    about assembly language programming, this chapter, combined with your knowledge
    of high-level languages, provides just enough information to let you start writing
    real assembly language programs.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经涵盖了很多内容！虽然你仍然有很多关于汇编语言编程需要学习，但本章结合你对高级语言的知识，提供了足够的信息，帮助你开始编写真正的汇编语言程序。
- en: Although this chapter has covered many different topics, the three primary topics
    of interest are the 80x86 CPU architecture, the syntax for simple HLA programs,
    and the HLA Standard Library. For additional topics on this subject, please consult
    the (unabridged) electronic version of this text, the HLA reference manual, and
    the HLA Standard Library manual. All three are available at [http://www.artofasm.com/](http://www.artofasm.com/)
    and [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/).
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章涵盖了许多不同的主题，但主要的三个关注点是 80x86 CPU 架构、简单 HLA 程序的语法和 HLA 标准库。有关更多相关主题的信息，请参考本书的（完整版）电子版、HLA
    参考手册和 HLA 标准库手册。所有这三者都可以在 [http://www.artofasm.com/](http://www.artofasm.com/)
    和 [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) 查阅。
