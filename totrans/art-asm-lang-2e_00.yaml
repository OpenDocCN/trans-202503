- en: Chapter 1. HELLO, WORLD OF ASSEMBLY LANGUAGE
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 汇编语言的“你好，世界！”
- en: '![HELLO, WORLD OF ASSEMBLY LANGUAGE](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![汇编语言的“你好，世界！”](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: 'This chapter is a "quick-start" chapter that lets you start writing basic assembly
    language programs as rapidly as possible. This chapter does the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一个“快速入门”章节，旨在让你尽快开始编写基本的汇编语言程序。本章内容包括：
- en: Presents the basic syntax of an HLA (High Level Assembly) program
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍了HLA（高级汇编语言）程序的基本语法
- en: Introduces you to the Intel CPU architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Intel CPU架构
- en: Provides a handful of data declarations, machine instructions, and high-level
    control statements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一些数据声明、机器指令和高级控制语句
- en: Describes some utility routines you can call in the HLA Standard Library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述了一些你可以在HLA标准库中调用的实用程序
- en: Shows you how to write some simple assembly language programs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向你展示如何编写一些简单的汇编语言程序
- en: By the conclusion of this chapter, you should understand the basic syntax of
    an HLA program and should understand the prerequisites that are needed to start
    learning new assembly language features in the chapters that follow.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，你应该理解HLA程序的基本语法，并且应该了解学习后续章节中新的汇编语言特性所需的前置条件。
- en: 1.1 The Anatomy of an HLA Program
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1 HLA程序的结构
- en: A typical HLA program takes the form shown in [Figure 1-1](ch01.html#basic_hla_program
    "Figure 1-1. Basic HLA program").
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的HLA程序的形式如[图1-1](ch01.html#basic_hla_program "图1-1. 基本HLA程序")所示。
- en: '![Basic HLA program](tagoreillycom20100401nostarchimages577855.png.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![基本HLA程序](tagoreillycom20100401nostarchimages577855.png.jpg)'
- en: Figure 1-1. Basic HLA program
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-1. 基本HLA程序
- en: '*`pgmID`* in the template above is a user-defined program identifier. You must
    pick an appropriate descriptive name for your program. In particular, *`pgmID`*
    would be a horrible choice for any real program. If you are writing programs as
    part of a course assignment, your instructor will probably give you the name to
    use for your main program. If you are writing your own HLA program, you will have
    to choose an appropriate name for your project.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模板中的*`pgmID`*是一个用户定义的程序标识符。你必须为你的程序选择一个合适的描述性名称。特别是，*`pgmID`*对于任何实际程序来说都是一个糟糕的选择。如果你是在编写课程作业，导师可能会为你提供主程序的名称。如果你是在编写自己的HLA程序，你将需要为你的项目选择一个合适的名称。
- en: Identifiers in HLA are very similar to identifiers in most high-level languages.
    HLA identifiers may begin with an underscore or an alphabetic character and may
    be followed by zero or more alphanumeric or underscore characters. HLA's identifiers
    are *case neutral*. This means that the identifiers are case sensitive insofar
    as you must always spell an identifier exactly the same way in your program (even
    with respect to upper- and lowercase). However, unlike in case-sensitive languages
    such as C/C++, you may not declare two identifiers in the program whose name differs
    only by alphabetic case.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: HLA中的标识符与大多数高级语言中的标识符非常相似。HLA标识符可以以下划线或字母字符开头，后面可以跟零个或多个字母数字字符或下划线字符。HLA的标识符是*大小写不敏感*的。这意味着标识符是区分大小写的，因为你必须在程序中始终准确地拼写标识符（包括大小写）。然而，与像C/C++等区分大小写的语言不同，你不能在程序中声明两个仅因字母大小写不同而名称不同的标识符。
- en: A traditional first program people write, popularized by Kernighan and Ritchie's
    *The C Programming Language*, is the "Hello, world!" program. This program makes
    an excellent concrete example for someone who is learning a new language. [Example 1-1](ch01.html#the_helloworld_program
    "Example 1-1. The helloWorld program") presents the HLA *helloWorld* program.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常写的传统第一个程序，由Kernighan和Ritchie的*《C程序设计语言》*推广，是“你好，世界！”程序。这个程序是学习新语言的一个极好的具体例子。[示例1-1](ch01.html#the_helloworld_program
    "示例1-1. helloWorld程序")展示了HLA的*helloWorld*程序。
- en: Example 1-1. The *helloWorld* program
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-1. *helloWorld*程序
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `#include` statement in this program tells the HLA compiler to include a
    set of declarations from the *stdlib.hhf* (standard library, HLA Header File).
    Among other things, this file contains the declaration of the `stdout.put` code
    that this program uses.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的`#include`语句告诉HLA编译器包含来自*stdlib.hhf*（标准库，HLA头文件）的一组声明。此文件包含了程序使用的`stdout.put`代码声明。
- en: The `stdout.put` statement is the print statement for the HLA language. You
    use it to write data to the standard output device (generally the console). To
    anyone familiar with I/O statements in a high-level language, it should be obvious
    that this statement prints the phrase `Hello, World of Assembly Language`. The
    `nl` appearing at the end of this statement is a constant, also defined in *stdlib.hhf*,
    that corresponds to the newline sequence.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdout.put` 语句是 HLA 语言中的打印语句。你用它将数据写入标准输出设备（通常是控制台）。对于熟悉高级语言中 I/O 语句的人来说，这个语句显然是用来打印短语
    `Hello, World of Assembly Language` 的。该语句末尾的 `nl` 是一个常量，也定义在 *stdlib.hhf* 中，表示换行序列。'
- en: Note that semicolons follow the `program`, `begin`, `stdout.put`, and `end`
    statements. Technically speaking, a semicolon does not follow the `#include` statement.
    It is possible to create include files that generate an error if a semicolon follows
    the `#include` statement, so you may want to get in the habit of not putting a
    semicolon here.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，分号跟在 `program`、`begin`、`stdout.put` 和 `end` 语句后面。严格来说，`#include` 语句后并不跟分号。可以创建包含错误的
    include 文件，如果在 `#include` 语句后加分号，会导致错误，因此你可能要养成不在此处加分号的习惯。
- en: The `#include` is your first introduction to HLA declarations. The `#include`
    itself isn't actually a declaration, but it does tell the HLA compiler to substitute
    the file *stdlib.hhf* in place of the `#include` directive, thus inserting several
    declarations at this point in your program. Most HLA programs you will write will
    need to include one or more of the HLA Standard Library header files (*stdlib.hhf*
    actually includes all the standard library definitions into your program).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`#include` 是你第一次接触 HLA 声明的地方。`#include` 本身并不是声明，但它告诉 HLA 编译器将文件 *stdlib.hhf*
    替代 `#include` 指令，从而在你的程序中插入几个声明。你编写的大多数 HLA 程序都需要包含一个或多个 HLA 标准库头文件（*stdlib.hhf*
    实际上将所有标准库定义包含进你的程序中）。'
- en: Compiling this program produces a *console* application. Running this program
    in a command window prints the specified string, and then control returns to the
    command-line interpreter (or *shell* in Unix terminology).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编译此程序将生成一个 *console* 应用程序。在命令窗口中运行此程序会打印指定的字符串，然后控制权返回到命令行解释器（在 Unix 术语中称为 *shell*）。
- en: 'HLA is a free-format language. Therefore, you may split statements across multiple
    lines if this helps to make your programs more readable. For example, you could
    write the `stdout.put` statement in the *helloWorld* program as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 是一种自由格式的语言。因此，如果将语句拆分成多行有助于提高程序的可读性，你可以这样做。例如，你可以像下面这样编写 *helloWorld* 程序中的
    `stdout.put` 语句：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Another construction you'll see appearing in example code throughout this text
    is that HLA automatically concatenates any adjacent string constants it finds
    in your source file. Therefore, the statement above is also equivalent to
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在本书的示例代码中看到另一个结构，HLA 会自动连接它在源文件中发现的任何相邻的字符串常量。因此，上面的语句也等同于
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Indeed, `nl` (the newline) is really nothing more than a string constant, so
    (technically) the comma between the `nl` and the preceding string isn't necessary.
    You'll often see the above written as
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`nl`（换行符）实际上不过是一个字符串常量，因此（从技术上讲）`nl` 和前一个字符串之间的逗号并不是必需的。你通常会看到上述写法是
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice the lack of a comma between the string constant and `nl`; this turns
    out to be legal in HLA, though it applies only to certain constants; you may not,
    in general, drop the comma. [Chapter 4](ch04.html "Chapter 4. CONSTANTS, VARIABLES,
    AND DATA TYPES") explains in detail how this works. This discussion appears here
    because you'll probably see this "trick" employed by sample code prior to the
    formal explanation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意字符串常量和 `nl` 之间没有逗号；这在 HLA 中是合法的，尽管它只适用于某些常量；通常情况下，你不能省略逗号。[第4章](ch04.html
    "第4章：常量、变量和数据类型") 详细解释了这一点。这里提到这一点是因为你可能会在正式解释之前，看到示例代码使用了这个“技巧”。
- en: 1.2 Running Your First HLA Program
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2 运行你的第一个 HLA 程序
- en: The whole purpose of the "Hello, world!" program is to provide a simple example
    by which someone who is learning a new programming language can figure out how
    to use the tools needed to compile and run programs in that language. True, the
    *helloWorld* program in [1.1 The Anatomy of an HLA Program](ch01.html#the_anatomy_of_an_hla_program
    "1.1 The Anatomy of an HLA Program") helps demonstrate the format and syntax of
    a simple HLA program, but the real purpose behind a program like *helloWorld*
    is to learn how to create and run a program from beginning to end. Although the
    previous section presents the layout of an HLA program, it did not discuss how
    to edit, compile, and run that program. This section will briefly cover those
    details.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: “Hello, world!” 程序的整个目的在于提供一个简单的示例，通过它，学习新编程语言的人可以弄清楚如何使用所需的工具来编译和运行该语言的程序。的确，[1.1
    HLA 程序的构成](ch01.html#the_anatomy_of_an_hla_program "1.1 HLA 程序的构成")中的*helloWorld*
    程序有助于演示一个简单的 HLA 程序的格式和语法，但像 *helloWorld* 这样的程序的真正目的是学习如何从头到尾创建和运行一个程序。尽管上一节介绍了
    HLA 程序的布局，但并未讨论如何编辑、编译和运行该程序。本节将简要介绍这些细节。
- en: All of the software you need to compile and run HLA programs can be found at
    [http://randallhyde.com/](http://randallhyde.com/) or at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/).
    Select **High Level Assembly** from the Quick Navigation Panel and then the Download
    HLA link from that page. HLA is currently available for Windows, Mac OS X, Linux,
    and FreeBSD. Download the appropriate version of the HLA software for your system.
    From the Download HLA web page, you will also be able to download all the software
    associated with this book. If the HLA download doesn't include them, you will
    probably want to download the HLA reference manual and the HLA Standard Library
    reference manual along with HLA and the software for this book. This text does
    not describe the entire HLA language, nor does it describe the entire HLA Standard
    Library. You'll want to have these reference manuals handy as you learn assembly
    language using HLA.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有需要编译和运行 HLA 程序的软件可以在 [http://randallhyde.com/](http://randallhyde.com/) 或
    [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) 找到。在快速导航面板中选择 **High
    Level Assembly**，然后从该页面选择下载 HLA 链接。HLA 目前可用于 Windows、Mac OS X、Linux 和 FreeBSD。下载适合你系统的
    HLA 软件版本。在 HLA 下载页面，你还可以下载与本书相关的所有软件。如果 HLA 下载包中没有包含这些内容，你可能需要下载 HLA 参考手册和 HLA
    标准库参考手册，连同 HLA 和本书的软件一起下载。本书并未描述整个 HLA 语言，也没有描述整个 HLA 标准库。在学习使用 HLA 的汇编语言时，最好随时准备好这些参考手册。
- en: This section will not describe how to install and set up the HLA system because
    those instructions change over time. The HLA download page for each of the operating
    systems describes how to install and use HLA. Please consult those instructions
    for the exact installation procedure.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本节不会描述如何安装和设置 HLA 系统，因为这些说明会随时间而变化。每个操作系统的 HLA 下载页面都会描述如何安装和使用 HLA。请查阅这些说明以获得准确的安装程序。
- en: Creating, compiling, and running an HLA program is very similar to the process
    you'd use when creating, compiling, or running a program in any computer language.
    First, because HLA is not an *integrated development environment (IDE)* that allows
    you to edit, compile, test and debug, and run your application all from within
    the same program, you'll create and edit HLA programs using a text editor.^([[1](#ftn.CHP-1-FN-1)])
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建、编译和运行 HLA 程序的过程与在任何计算机语言中创建、编译或运行程序的过程非常相似。首先，由于 HLA 不是一个*集成开发环境（IDE）*，不能在同一个程序中进行编辑、编译、测试、调试和运行应用程序，你将使用文本编辑器来创建和编辑
    HLA 程序。^([[1](#ftn.CHP-1-FN-1)])
- en: Windows, Mac OS X, Linux, and FreeBSD offer many text editor options. You can
    even use the text editor provided with other IDEs to create and edit HLA programs
    (such as those found in Visual C++, Borland's Delphi, Apple's Xcode, and similar
    languages). The only restriction is that HLA expects ASCII text files, so the
    editor you use must be capable of manipulating and saving text files. Under Windows
    you can always use Notepad to create HLA programs. If you're working under Linux
    and FreeBSD you can use joe, vi, or emacs. Under Mac OS X you can use XCode or
    Text Wrangler or another editor of your preference.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Windows、Mac OS X、Linux和FreeBSD提供了多种文本编辑器选项。你甚至可以使用其他IDE附带的文本编辑器来创建和编辑HLA程序（例如在Visual
    C++、Borland的Delphi、Apple的Xcode以及类似语言中找到的编辑器）。唯一的限制是HLA期望的是ASCII文本文件，因此你使用的编辑器必须能够处理并保存文本文件。在Windows下，你始终可以使用记事本来创建HLA程序。如果你在Linux或FreeBSD下工作，你可以使用joe、vi或emacs。在Mac
    OS X下，你可以使用XCode、Text Wrangler或你偏好的其他编辑器。
- en: 'The HLA compiler^([[2](#ftn.CHP-1-FN-2)]) is a traditional *command-line compiler*,
    which means that you need to run it from a Windows *command-line prompt* or a
    Linux/FreeBSD/Mac OS X *shell*. To do so, enter something like the following into
    the command-line prompt or shell window:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: HLA编译器^([[2](#ftn.CHP-1-FN-2)])是一个传统的*命令行编译器*，这意味着你需要从Windows的*命令行提示符*或Linux/FreeBSD/Mac
    OS X的*Shell*中运行它。为此，你需要在命令行提示符或Shell窗口中输入如下命令：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command tells HLA to compile the *hw.hla* (*helloWorld*) program to an
    executable file. Assuming there are no errors, you can run the resulting program
    by typing the following command into your command prompt window (Windows):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令告诉HLA将*hw.hla*（*helloWorld*）程序编译成可执行文件。如果没有错误，你可以通过在命令提示符窗口（Windows）中输入以下命令来运行生成的程序：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'or into the shell interpreter window (Linux/FreeBSD/Mac OS X):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者进入Shell解释器窗口（Linux/FreeBSD/Mac OS X）：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you're having problems getting the program to compile and run properly, please
    see the HLA installation instructions on the HLA download page. These instructions
    describe in great detail how to install, set up, and use HLA.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在编译和运行程序时遇到问题，请参阅HLA下载页面上的安装说明。这些说明详细描述了如何安装、设置和使用HLA。
- en: '* * *'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-1-FN-1)]) HIDE (HLA Integrated Development Environment) is an IDE
    available for Windows users. See the High Level Assembly web page for details
    on downloading HIDE.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-1-FN-1)]) HIDE（HLA集成开发环境）是一个适用于Windows用户的IDE。有关下载HIDE的详细信息，请参阅高级汇编语言（HLA）网页。
- en: ^([[2](#CHP-1-FN-2)]) Traditionally, programmers have always called translators
    for assembly languages *assemblers* rather than *compilers*. However, because
    of HLA's high-level features, it is more proper to call HLA a compiler rather
    than an assembler.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-1-FN-2)]) 传统上，程序员总是将汇编语言的翻译器称为*汇编器*，而不是*编译器*。然而，由于HLA具有高级特性，因此将HLA称为编译器而不是汇编器更为恰当。
- en: 1.3 Some Basic HLA Data Declarations
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3 一些基本的HLA数据声明
- en: HLA provides a wide variety of constant, type, and data declaration statements.
    Later chapters will cover the declaration sections in more detail, but it's important
    to know how to declare a few simple variables in an HLA program.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: HLA提供了各种常量、类型和数据声明语句。后续章节将更详细地讲解声明部分，但了解如何在HLA程序中声明一些简单的变量是很重要的。
- en: HLA predefines several different signed integer types including int8, int16,
    and int32, corresponding to 8-bit (1-byte) signed integers, 16-bit (2-byte) signed
    integers, and 32-bit (4-byte) signed integers, respectively.^([[3](#ftn.CHP-1-FN-3)])
    Typical variable declarations occur in the HLA *static variable section*. A typical
    set of variable declarations takes the form shown in [Figure 1-2](ch01s03.html#static_variable_declarations
    "Figure 1-2. Static variable declarations").
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: HLA预定义了几种不同的有符号整数类型，包括int8、int16和int32，分别对应8位（1字节）有符号整数、16位（2字节）有符号整数和32位（4字节）有符号整数。^([[3](#ftn.CHP-1-FN-3)])典型的变量声明发生在HLA的*静态变量部分*。一组典型的变量声明形式如[图1-2](ch01s03.html#static_variable_declarations
    "图1-2. 静态变量声明")所示。
- en: '![Static variable declarations](tagoreillycom20100401nostarchimages577857.png.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![静态变量声明](tagoreillycom20100401nostarchimages577857.png.jpg)'
- en: Figure 1-2. Static variable declarations
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-2. 静态变量声明
- en: 'Those who are familiar with the Pascal language should be comfortable with
    this declaration syntax. This example demonstrates how to declare three separate
    integers: `i8`, `i16`*,* and `i32`. Of course, in a real program you should use
    variable names that are more descriptive. While names like *i8* and *i32* describe
    the type of the object, they do not describe its purpose. Variable names should
    describe the purpose of the object.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉Pascal语言的人应该能轻松理解这种声明语法。此示例演示了如何声明三个独立的整数：`i8`、`i16` 和 `i32`。当然，在实际程序中，你应该使用更具描述性的变量名。像
    *i8* 和 *i32* 这样的名称虽然描述了对象的类型，但没有描述其用途。变量名应当描述对象的用途。
- en: In the *static declaration section*, you can also give a variable an initial
    value that the operating system will assign to the variable when it loads the
    program into memory. [Figure 1-3](ch01s03.html#static_variable_initialization
    "Figure 1-3. Static variable initialization") provides the syntax for this.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在*静态声明部分*，你还可以为变量赋初始值，操作系统将在程序加载到内存时将该初始值赋给变量。[图 1-3](ch01s03.html#static_variable_initialization
    "图 1-3. 静态变量初始化")提供了相关的语法。
- en: '![Static variable initialization](tagoreillycom20100401nostarchimages577859.png.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![静态变量初始化](tagoreillycom20100401nostarchimages577859.png.jpg)'
- en: Figure 1-3. Static variable initialization
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-3. 静态变量初始化
- en: It is important to realize that the expression following the assignment operator
    (`:=`) must be a constant expression. You cannot assign the values of other variables
    within a static variable declaration.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，在赋值运算符（`:=`）后面的表达式必须是常量表达式。你不能在静态变量声明中为其他变量赋值。
- en: Those familiar with other high-level languages (especially Pascal) should note
    that you can declare only one variable per statement. That is, HLA does not allow
    a comma-delimited list of variable names followed by a colon and a type identifier.
    Each variable declaration consists of a single identifier, a colon, a type ID,
    and a semicolon.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉其他高级语言（尤其是Pascal）的人应注意，你每个语句只能声明一个变量。也就是说，HLA不允许在一个声明中使用逗号分隔的变量名列表，后跟冒号和类型标识符。每个变量声明由一个标识符、一个冒号、一个类型标识符和一个分号组成。
- en: '[Example 1-2](ch01s03.html#variable_declaration_and_use "Example 1-2. Variable
    declaration and use") provides a simple HLA program that demonstrates the use
    of variables within an HLA program.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-2](ch01s03.html#variable_declaration_and_use "示例 1-2. 变量声明与使用")提供了一个简单的HLA程序，演示了在HLA程序中使用变量。'
- en: Example 1-2. Variable declaration and use
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-2. 变量声明与使用
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In addition to static variable declarations, this example introduces three new
    concepts. First, the `stdout.put` statement allows multiple parameters. If you
    specify an integer value, `stdout.put` will convert that value to its string representation
    on output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了静态变量声明外，此示例还引入了三个新概念。首先，`stdout.put`语句允许多个参数。如果你指定一个整数值，`stdout.put`会将该值转换为字符串表示并输出。
- en: The second new feature introduced in [Example 1-2](ch01s03.html#variable_declaration_and_use
    "Example 1-2. Variable declaration and use") is the `stdin.get` statement. This
    statement reads a value from the standard input device (usually the keyboard),
    converts the value to an integer, and stores the integer value into the `NotInitialized`
    variable. Finally, [Example 1-2](ch01s03.html#variable_declaration_and_use "Example 1-2. Variable
    declaration and use") also introduces the syntax for (one form of) HLA comments.
    The HLA compiler ignores all text from the `//` sequence to the end of the current
    line. (Those familiar with Java, C++, and Delphi should recognize these comments.)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 1-2](ch01s03.html#variable_declaration_and_use "示例 1-2. 变量声明与使用")中引入的第二个新特性是`stdin.get`语句。此语句从标准输入设备（通常是键盘）读取一个值，将该值转换为整数，并将整数值存储到`NotInitialized`变量中。最后，[示例
    1-2](ch01s03.html#variable_declaration_and_use "示例 1-2. 变量声明与使用")还介绍了（其中一种形式的）HLA注释的语法。HLA编译器会忽略从`//`序列到当前行末尾的所有文本。（熟悉Java、C++和Delphi的人应该能识别这些注释。）
- en: '* * *'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[3](#CHP-1-FN-3)]) A discussion of bits and bytes will appear in [Chapter 2](ch02.html
    "Chapter 2. DATA REPRESENTATION") for those who are unfamiliar with these terms.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-1-FN-3)]) 对于不熟悉这些术语的人，关于比特和字节的讨论将在[第2章](ch02.html "第2章. 数据表示")中出现。
- en: 1.4 Boolean Values
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.4 布尔值
- en: HLA and the HLA Standard Library provide limited support for boolean objects.
    You can declare boolean variables, use boolean literal constants, use boolean
    variables in boolean expressions, and you can print the values of boolean variables.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 和 HLA 标准库对布尔对象提供了有限的支持。你可以声明布尔变量，使用布尔字面常量，在布尔表达式中使用布尔变量，并且可以打印布尔变量的值。
- en: Boolean literal constants consist of the two predefined identifiers `true` and
    `false`. Internally, HLA represents the value true using the numeric value `1`;
    HLA represents false using the value `0`. Most programs treat `0` as false and
    anything else as true, so HLA's representations for true and false should prove
    sufficient.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔字面常量由两个预定义标识符 `true` 和 `false` 组成。HLA 内部用数值 `1` 表示真，`0` 表示假。大多数程序将 `0` 视为假，将其他任何值视为真，因此
    HLA 对真和假的表示应该足够。
- en: 'To declare a boolean variable, you use the `boolean` data type. HLA uses a
    single byte (the least amount of memory it can allocate) to represent boolean
    values. The following example demonstrates some typical declarations:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个布尔变量，你使用 `boolean` 数据类型。HLA 使用一个字节（它能分配的最小内存）来表示布尔值。以下示例演示了一些典型的声明：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As this example demonstrates, you can initialize boolean variables if you desire.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个示例所演示的，你可以在需要时初始化布尔变量。
- en: Because boolean variables are byte objects, you can manipulate them using any
    instructions that operate directly on 8-bit values. Furthermore, as long as you
    ensure that your boolean variables only contain `0` and `1` (for false and true,
    respectively), you can use the 80x86 `and`, `or`, `xor`, and `not` instructions
    to manipulate these boolean values (these instructions are covered in [Chapter 2](ch02.html
    "Chapter 2. DATA REPRESENTATION")).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因为布尔变量是字节对象，你可以使用任何直接操作 8 位值的指令来操作它们。此外，只要确保布尔变量只包含 `0` 和 `1`（分别表示假和真），你就可以使用
    80x86 的 `and`、`or`、`xor` 和 `not` 指令来操作这些布尔值（这些指令在[第 2 章](ch02.html "第 2 章 数据表示")中有介绍）。
- en: 'You can print boolean values by making a call to the `stdout.put` routine.
    For example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用 `stdout.put` 例程来打印布尔值。例如：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This routine prints the text `true` or `false` depending upon the value of the
    boolean parameter (`0` is false; anything else is true). Note that the HLA Standard
    Library does not allow you to read boolean values via `stdin.get`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例程会根据布尔参数的值打印 `true` 或 `false`（`0` 为假，其他值为真）。请注意，HLA 标准库不允许通过 `stdin.get`
    读取布尔值。
- en: 1.5 Character Values
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.5 字符值
- en: 'HLA lets you declare 1-byte ASCII character objects using the `char` data type.
    You may initialize character variables with a literal character value by surrounding
    the character with a pair of apostrophes. The following example demonstrates how
    to declare and initialize character variables in HLA:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 允许你使用 `char` 数据类型声明 1 字节的 ASCII 字符对象。你可以通过将字符值用一对撇号括起来来初始化字符变量。以下示例演示了如何在
    HLA 中声明和初始化字符变量：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can print character variables use the `stdout.put` routine, and you can
    read character variables using the `stdin.get` procedure call.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `stdout.put` 例程打印字符变量，也可以通过调用 `stdin.get` 过程来读取字符变量。
- en: 1.6 An Introduction to the Intel 80x86 CPU Family
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.6 英特尔 80x86 CPU 系列简介
- en: Thus far, you've seen a couple of HLA programs that will actually compile and
    run. However, all the statements appearing in programs to this point have been
    either data declarations or calls to HLA Standard Library routines. There hasn't
    been any *real* assembly language. Before we can progress any further and learn
    some real assembly language, a detour is necessary; unless you understand the
    basic structure of the Intel 80x86 CPU family, the machine instructions will make
    little sense.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看过几个实际可以编译和运行的 HLA 程序。然而，到目前为止，程序中出现的所有语句都只是数据声明或对 HLA 标准库例程的调用。还没有涉及任何*真正的*汇编语言。在我们进一步学习一些真正的汇编语言之前，有必要先绕个弯；除非你了解英特尔
    80x86 CPU 系列的基本结构，否则机器指令几乎没有意义。
- en: 'The Intel CPU family is generally classified as a *Von Neumann Architecture
    Machine*. Von Neumann computer systems contain three main building blocks: the
    *central processing unit (CPU)*, *memory*, and *input/output (I/0) devices*. These
    three components are interconnected using the *system bus* (consisting of the
    address, data, and control buses). The block diagram in [Figure 1-4](ch01s06.html#von_neumann_computer_system_block_diagra
    "Figure 1-4. Von Neumann computer system block diagram") shows this relationship.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Intel CPU 家族通常被归类为 *冯·诺依曼架构机器*。冯·诺依曼计算机系统包含三个主要组成部分：*中央处理单元（CPU）*、*内存* 和 *输入/输出（I/O）设备*。这三部分通过
    *系统总线*（由地址总线、数据总线和控制总线组成）互联。[图 1-4](ch01s06.html#von_neumann_computer_system_block_diagra
    "图 1-4. 冯·诺依曼计算机系统框图") 显示了这种关系。
- en: The CPU communicates with memory and I/O devices by placing a numeric value
    on the address bus to select one of the memory locations or I/O device port locations,
    each of which has a unique binary numeric *address*. Then the CPU, memory, and
    I/O devices pass data among themselves by placing the data on the data bus. The
    control bus contains signals that determine the direction of the data transfer
    (to/from memory and to/from an I/O device).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 通过将一个数值放置在地址总线上，来与内存和 I/O 设备进行通信，从而选择一个内存位置或 I/O 设备端口位置，每个位置都有一个唯一的二进制数值
    *地址*。然后，CPU、内存和 I/O 设备通过将数据放置在数据总线上相互传递数据。控制总线包含决定数据传输方向（到/从内存以及到/从 I/O 设备）的信号。
- en: '![Von Neumann computer system block diagram](tagoreillycom20100401nostarchimages577861.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![冯·诺依曼计算机系统框图](tagoreillycom20100401nostarchimages577861.png)'
- en: Figure 1-4. Von Neumann computer system block diagram
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-4. 冯·诺依曼计算机系统框图
- en: 'The 80x86 CPU registers can be broken down into four categories: general-purpose
    registers, special-purpose application-accessible registers, segment registers,
    and special-purpose kernel-mode registers. Because the segment registers aren''t
    used much in modern 32-bit operating systems (such as Windows, Mac OS X, FreeBSD,
    and Linux) and because this text is geared to writing programs written for 32-bit
    operating systems, there is little need to discuss the segment registers. The
    special-purpose kernel-mode registers are intended for writing operating systems,
    debuggers, and other system-level tools. Such software construction is well beyond
    the scope of this text.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 CPU 寄存器可以分为四类：通用寄存器、特殊用途应用程序可访问的寄存器、段寄存器和特殊用途内核模式寄存器。由于段寄存器在现代 32 位操作系统（如
    Windows、Mac OS X、FreeBSD 和 Linux）中使用较少，并且本书的内容主要针对为 32 位操作系统编写的程序，因此不需要过多讨论段寄存器。特殊用途的内核模式寄存器是用于编写操作系统、调试器及其他系统级工具的。这类软件构建超出了本书的范围。
- en: 'The 80x86 (Intel family) CPUs provide several general-purpose registers for
    application use. These include eight 32-bit registers that have the following
    names: EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86（Intel 家族）CPU 提供了多个通用寄存器供应用程序使用。其中包括八个 32 位寄存器，名称分别为：EAX、EBX、ECX、EDX、ESI、EDI、EBP
    和 ESP。
- en: 'The *E* prefix on each name stands for *extended*. This prefix differentiates
    the 32-bit registers from the eight 16-bit registers that have the following names:
    AX, BX, CX, DX, SI, DI, BP, and SP.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个名称前的 *E* 前缀表示 *扩展*。这个前缀将 32 位寄存器与八个 16 位寄存器区分开来，后者的名称分别为：AX、BX、CX、DX、SI、DI、BP
    和 SP。
- en: 'Finally, the 80x86 CPUs provide eight 8-bit registers that have the following
    names: AL, AH, BL, BH, CL, CH, DL, and DH.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，80x86 CPU 提供了八个 8 位寄存器，名称分别为：AL、AH、BL、BH、CL、CH、DL 和 DH。
- en: Unfortunately, these are not all separate registers. That is, the 80x86 does
    not provide 24 independent registers. Instead, the 80x86 overlays the 32-bit registers
    with the 16-bit registers, and it overlays the 16-bit registers with the 8-bit
    registers. [Figure 1-5](ch01s06.html#x86_open_parenthesis_intel_cpu_close_par
    "Figure 1-5. 80x86 (Intel CPU) general-purpose registers") shows this relationship.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这些并不是完全独立的寄存器。也就是说，80x86 并没有提供 24 个独立的寄存器。相反，80x86 使用 32 位寄存器覆盖 16 位寄存器，并且使用
    16 位寄存器覆盖 8 位寄存器。[图 1-5](ch01s06.html#x86_open_parenthesis_intel_cpu_close_par
    "图 1-5. 80x86（Intel CPU）通用寄存器") 展示了这种关系。
- en: The most important thing to note about the general-purpose registers is that
    they are not independent. Modifying one register may modify as many as three other
    registers. For example, modification of the EAX register may very well modify
    the AL, AH, and AX registers. This fact cannot be overemphasized here. A very
    common mistake in programs written by beginning assembly language programmers
    is register value corruption because the programmer did not completely understand
    the ramifications of the relationship shown in [Figure 1-5](ch01s06.html#x86_open_parenthesis_intel_cpu_close_par
    "Figure 1-5. 80x86 (Intel CPU) general-purpose registers").
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于通用寄存器，最重要的一点是它们不是独立的。修改一个寄存器可能会修改最多三个其他寄存器。例如，修改 EAX 寄存器可能会影响 AL、AH 和 AX 寄存器。这个事实在这里必须特别强调。初学汇编语言的程序员常犯的一个错误是寄存器值被破坏，因为程序员没有完全理解
    [图 1-5](ch01s06.html#x86_open_parenthesis_intel_cpu_close_par "图 1-5. 80x86 (Intel
    CPU) 通用寄存器") 中显示的关系。
- en: '![80x86 (Intel CPU) general-purpose registers](tagoreillycom20100401nostarchimages577863.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![80x86 (Intel CPU) 通用寄存器](tagoreillycom20100401nostarchimages577863.png)'
- en: Figure 1-5. 80x86 (Intel CPU) general-purpose registers
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-5. 80x86 (Intel CPU) 通用寄存器
- en: The EFLAGS register is a 32-bit register that encapsulates several single-bit
    boolean (true/false) values. Most of the bits in the EFLAGS register are either
    reserved for kernel mode (operating system) functions or are of little interest
    to the application programmer. Eight of these bits (or *flags*) are of interest
    to application programmers writing assembly language programs. These are the overflow,
    direction, interrupt disable,^([[4](#ftn.CHP-1-FN-4)]) sign, zero, auxiliary carry,
    parity, and carry flags. [Figure 1-6](ch01s06.html#layout_of_the_flags_register_open_parent
    "Figure 1-6. Layout of the FLAGS register (lower 16 bits of EFLAGS)") shows the
    layout of the flags within the lower 16 bits of the EFLAGS register.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: EFLAGS 寄存器是一个 32 位寄存器，封装了多个单比特布尔值（真/假）。EFLAGS 寄存器中的大部分位要么是为内核模式（操作系统）功能保留的，要么对于应用程序员来说并不重要。其中特别有意义的八个比特（或称为*标志*）是应用程序员编写汇编语言程序时需要关注的。这些标志包括溢出、方向、禁止中断、符号、零、辅助进位、奇偶和进位标志。[图
    1-6](ch01s06.html#layout_of_the_flags_register_open_parent "图 1-6. EFLAGS 寄存器的布局（EFLAGS
    寄存器的低 16 位）") 展示了这些标志在 EFLAGS 寄存器低 16 位中的布局。
- en: '![Layout of the FLAGS register (lower 16 bits of EFLAGS)](tagoreillycom20100401nostarchimages577865.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![EFLAGS 寄存器的布局（EFLAGS 寄存器的低 16 位）](tagoreillycom20100401nostarchimages577865.png)'
- en: Figure 1-6. Layout of the FLAGS register (lower 16 bits of EFLAGS)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-6. EFLAGS 寄存器的布局（EFLAGS 寄存器的低 16 位）
- en: 'Of the eight flags that are of interest to application programmers, four flags
    in particular are extremely valuable: the overflow, carry, sign, and zero flags.
    Collectively, we will call these four flags the *condition codes*.^([[5](#ftn.CHP-1-FN-5)])
    The state of these flags lets you test the result of previous computations. For
    example, after comparing two values, the condition code flags will tell you whether
    one value is less than, equal to, or greater than a second value.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在八个对应用程序员有意义的标志中，尤其有四个标志是极为重要的：溢出、进位、符号和零标志。我们统称这四个标志为*条件码*。[图 1-5](#ftn.CHP-1-FN-5)
    这些标志的状态可以让你测试之前计算的结果。例如，在比较两个值之后，条件码标志会告诉你第一个值是否小于、等于或大于第二个值。
- en: One important fact that comes as a surprise to those just learning assembly
    language is that almost all calculations on the 80x86 CPU involve a register.
    For example, to add two variables together, storing the sum into a third variable,
    you must load one of the variables into a register, add the second operand to
    the value in the register, and then store the register away in the destination
    variable. Registers are a middleman in nearly every calculation. Therefore, registers
    are very important in 80x86 assembly language programs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚学习汇编语言的人来说，有一个重要的事实可能会让人感到惊讶，那就是几乎所有在 80x86 CPU 上的计算都涉及寄存器。例如，为了将两个变量相加并将结果存储到第三个变量中，你必须将其中一个变量加载到寄存器中，将第二个操作数加到寄存器中的值，然后将寄存器的值存储到目标变量中。寄存器几乎在每个计算中都充当中介。因此，寄存器在
    80x86 汇编语言程序中非常重要。
- en: Another thing you should be aware of is that although the registers have the
    name "general purpose," you should not infer that you can use any register for
    any purpose. All the 80x86 registers have their own special purposes that limit
    their use in certain contexts. The SP/ESP register pair, for example, has a very
    special purpose that effectively prevents you from using it for anything else
    (it's the *stack pointer*). Likewise, the BP/EBP register has a special purpose
    that limits its usefulness as a general-purpose register. For the time being,
    you should avoid the use of the ESP and EBP registers for generic calculations;
    also, keep in mind that the remaining registers are not completely interchangeable
    in your programs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事情是，尽管寄存器被称为“通用寄存器”，但你不应推断出可以将任何寄存器用于任何目的。所有80x86寄存器都有自己的特殊用途，这限制了它们在某些上下文中的使用。例如，SP/ESP寄存器对有一个非常特殊的用途，实际上阻止你将其用于其他任何事情（它是*栈指针*）。同样，BP/EBP寄存器也有一个特殊的用途，这限制了它作为通用寄存器的有效性。目前，你应该避免在通用计算中使用ESP和EBP寄存器；另外，请记住，剩余的寄存器在程序中并不是完全可以互换的。
- en: '* * *'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[4](#CHP-1-FN-4)]) Application programs cannot modify the interrupt flag,
    but we'll look at this flag in [Chapter 2](ch02.html "Chapter 2. DATA REPRESENTATION");
    hence the discussion of this flag here.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-1-FN-4)]) 应用程序无法修改中断标志，但我们将在[第2章](ch02.html "第2章. 数据表示")中查看该标志；因此，这里会讨论该标志。
- en: ^([[5](#CHP-1-FN-5)]) Technically the parity flag is also a condition code,
    but we will not use that flag in this text.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#CHP-1-FN-5)]) 从技术上讲，奇偶标志也是一种状态码，但在本文中我们不会使用该标志。
- en: 1.7 The Memory Subsystem
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.7 内存子系统
- en: A typical 80x86 processor running a modern 32-bit OS can access a maximum of
    2^(32) different memory locations, or just over 4 billion bytes. A few years ago,
    4 gigabytes of memory would have seemed like infinity; modern machines, however,
    exceed this limit. Nevertheless, because the 80x86 architecture supports a maximum
    4GB address space when using a 32-bit operating system like Windows, Mac OS X,
    FreeBSD, or Linux, the following discussion will assume the 4GB limit.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一台运行现代32位操作系统的典型80x86处理器可以访问最多2^(32)个不同的内存位置，即超过40亿字节。几年前，4GB内存看起来就像是无限；然而，现代计算机已经超过了这一限制。尽管如此，由于80x86架构在使用像Windows、Mac
    OS X、FreeBSD或Linux等32位操作系统时支持最大4GB的地址空间，以下讨论将假设4GB的限制。
- en: Of course, the first question you should ask is, "What exactly is a memory location?"
    The 80x86 supports *byte-addressable memory*. Therefore, the basic memory unit
    is a byte, which is sufficient to hold a single character or a (very) small integer
    value (we'll talk more about that in [Chapter 2](ch02.html "Chapter 2. DATA REPRESENTATION")).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你首先应该问的问题是，“什么是内存位置？”80x86支持*字节可寻址内存*。因此，基本的内存单元是字节，足以存储单个字符或一个（非常）小的整数值（我们将在[第2章](ch02.html
    "第2章. 数据表示")中详细讨论）。
- en: 'Think of memory as a linear array of bytes. The address of the first byte is
    0 and the address of the last byte is 2^(32)−1\. For an 80x86 processor, the following
    pseudo-Pascal array declaration is a good approximation of memory:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 把内存想象成一个线性字节数组。第一个字节的地址是0，最后一个字节的地址是2^(32)−1。对于80x86处理器，以下伪Pascal数组声明是内存的一个良好近似：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'C/C++ and Java users might prefer the following syntax:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++和Java用户可能更喜欢以下语法：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To execute the equivalent of the Pascal statement `Memory [125] := 0;` the CPU
    places the value 0 on the data bus, places the address 125 on the address bus,
    and asserts the write line (this generally involves setting that line to 0), as
    shown in [Figure 1-7](ch01s07.html#memory_write_operation "Figure 1-7. Memory
    write operation").
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行等同于Pascal语句`Memory [125] := 0;`的操作，CPU将值0放到数据总线上，将地址125放到地址总线上，并激活写线（这通常涉及将该线路设置为0），如[图1-7](ch01s07.html#memory_write_operation
    "图1-7. 内存写入操作")所示。
- en: '![Memory write operation](tagoreillycom20100401nostarchimages577867.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![内存写入操作](tagoreillycom20100401nostarchimages577867.png)'
- en: Figure 1-7. Memory write operation
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-7. 内存写入操作
- en: To execute the equivalent of `CPU := Memory [125];` the CPU places the address
    125 on the address bus, asserts the read line (because the CPU is reading data
    from memory), and then reads the resulting data from the data bus (see [Figure 1-8](ch01s07.html#memory_read_operation
    "Figure 1-8. Memory read operation")).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行等同于`CPU := Memory [125];`的操作，CPU会将地址125放到地址总线上，激活读线（因为CPU正在从内存读取数据），然后从数据总线读取结果数据（见[图1-8](ch01s07.html#memory_read_operation
    "图1-8. 内存读取操作")）。
- en: '![Memory read operation](tagoreillycom20100401nostarchimages577869.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Figure 1-8. Memory read operation
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: This discussion applies *only* when accessing a single byte in memory. So what
    happens when the processor accesses a word or a double word? Because memory consists
    of an array of bytes, how can we possibly deal with values larger than a single
    byte? Easy—to store larger values, the 80x86 uses a sequence of consecutive memory
    locations. [Figure 1-9](ch01s07.html#byte_comma_word_comma_and_double-word_st
    "Figure 1-9. Byte, word, and double-word storage in memory") shows how the 80x86
    stores bytes, words (2 bytes), and double words (4 bytes) in memory. The memory
    address of each of these objects is the address of the first byte of each object
    (that is, the lowest address).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Modern 80x86 processors don't actually connect directly to memory. Instead,
    there is a special memory buffer on the CPU known as the *cache* (pronounced "cash")
    that acts as a high-speed intermediary between the CPU and main memory. Although
    the cache handles the details automatically for you, one fact you should know
    is that accessing data objects in memory is sometimes more efficient if the address
    of the object is an even multiple of the object's size. Therefore, it's a good
    idea to *align* 4-byte objects (double words) on addresses that are multiples
    of 4\. Likewise, it's most efficient to align 2-byte objects on even addresses.
    You can efficiently access single-byte objects at any address. You'll see how
    to set the alignment of memory objects in [3.4 HLA Support for Data Alignment](ch03s04.html
    "3.4 HLA Support for Data Alignment").
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![Byte, word, and double-word storage in memory](tagoreillycom20100401nostarchimages577871.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: Figure 1-9. Byte, word, and double-word storage in memory
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Before leaving this discussion of memory objects, it''s important to understand
    the correspondence between memory and HLA variables. One of the nice things about
    using an assembler/compiler like HLA is that you don''t have to worry about numeric
    memory addresses. All you need to do is declare a variable in HLA, and HLA takes
    care of associating that variable with some unique set of memory addresses. For
    example, if you have the following declaration section:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: HLA will find some unused 8-bit byte in memory and associate it with the `i8`
    variable; it will find a pair of consecutive unused bytes and associate `i16`
    with them; finally, HLA will find 4 consecutive unused bytes and associate the
    value of `i32` with those 4 bytes (32 bits). You'll always refer to these variables
    by their name. You generally don't have to concern yourself with their numeric
    address. Still, you should be aware that HLA is doing this for you behind your
    back.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 1.8 Some Basic Machine Instructions
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The 80x86 CPU family provides from just over a hundred to many thousands of
    different machine instructions, depending on how you define a machine instruction.
    Even at the low end of the count (greater than 100), it appears as though there
    are far too many machine instructions to learn in a short time. Fortunately, you
    don't need to know all the machine instructions. In fact, most assembly language
    programs probably use around 30 different machine instructions.^([[6](#ftn.CHP-1-FN-6)])
    Indeed, you can certainly write several meaningful programs with only a few machine
    instructions. The purpose of this section is to provide a small handful of machine
    instructions so you can start writing simple HLA assembly language programs right
    away.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 CPU 系列提供了从一百多条到几千条不同的机器指令，具体数量取决于你如何定义机器指令。即便是在指令数量较少的一端（大于 100），似乎也有太多指令需要在短时间内学习。幸运的是，你不需要知道所有的机器指令。事实上，大多数汇编语言程序可能只使用大约
    30 条不同的机器指令。^([[6](#ftn.CHP-1-FN-6)]) 确实，你完全可以用几条机器指令编写几个有意义的程序。本节的目的是提供少量机器指令，让你能够立即开始编写简单的
    HLA 汇编语言程序。
- en: 'Without question, the `mov` instruction is the most oft-used assembly language
    statement. In a typical program, anywhere from 25 percent to 40 percent of the
    instructions are `mov` instructions. As its name suggests, this instruction moves
    data from one location to another.^([[7](#ftn.CHP-1-FN-7)]) The HLA syntax for
    this instruction is:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸置疑，`mov` 指令是最常用的汇编语言语句。在一个典型的程序中，25% 到 40% 的指令都是 `mov` 指令。正如其名称所示，这条指令将数据从一个位置移动到另一个位置。^([[7](#ftn.CHP-1-FN-7)])
    该指令的 HLA 语法是：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The *`source_operand`* can be a register, a memory variable, or a constant.
    The *`destination_operand`* may be a register or a memory variable. Technically
    the 80x86 instruction set does not allow both operands to be memory variables.
    HLA, however, will automatically translate a `mov` instruction with two-word or
    double-word memory operands into a pair of instructions that will copy the data
    from one location to another. In a high-level language like Pascal or C/C++, the
    `mov` instruction is roughly equivalent to the following assignment statement:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*`source_operand`* 可以是寄存器、内存变量或常量。*`destination_operand`* 可以是寄存器或内存变量。严格来说，80x86
    指令集不允许两个操作数都为内存变量。然而，HLA 会自动将两个字或双字内存操作数的 `mov` 指令转换为一对指令，从一个位置复制数据到另一个位置。在像 Pascal
    或 C/C++ 这样的高级语言中，`mov` 指令大致相当于以下赋值语句：'
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Perhaps the major restriction on the `mov` instruction's operands is that they
    must both be the same size. That is, you can move data between a pair of byte
    (8-bit) objects, word (16-bit) objects, or double-word (32-bit) objects; you may
    not, however, mix the sizes of the operands. [Table 1-1](ch01s08.html#legal_80x86_mov_instruction_operands
    "Table 1-1. Legal 80x86 mov Instruction Operands") lists all the legal combinations
    for the `mov` instruction.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 或许 `mov` 指令操作数的主要限制是它们必须具有相同的大小。也就是说，你可以在一对字节（8 位）、字（16 位）或双字（32 位）对象之间移动数据；但是，你不能混合操作数的大小。[表
    1-1](ch01s08.html#legal_80x86_mov_instruction_operands "表 1-1. 合法的 80x86 mov 指令操作数")
    列出了所有 `mov` 指令的合法组合。
- en: You should study this table carefully because most of the general-purpose 80x86
    instructions use this syntax.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该仔细研究这张表，因为大多数通用 80x86 指令都使用这种语法。
- en: Table 1-1. Legal 80x86 `mov` Instruction Operands
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-1. 合法的 80x86 `mov` 指令操作数
- en: '| Source | Destination |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 源 | 目标 |'
- en: '| --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Reg[8]^([[a](#ftn.CHP-1-TFN-1)]) | Reg[8] |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| Reg[8]^([[a](#ftn.CHP-1-TFN-1)]) | Reg[8] |'
- en: '| Reg[8] | Mem[8] |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| Reg[8] | Mem[8] |'
- en: '| Mem[8] | Reg[8] |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| Mem[8] | Reg[8] |'
- en: '| Constant^([[b](#ftn.CHP-1-TFN-2)]) | Reg[8] |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 常量^([[b](#ftn.CHP-1-TFN-2)]) | Reg[8] |'
- en: '| Constant | Mem[8] |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | Mem[8] |'
- en: '| Reg[16] | Reg[16] |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| Reg[16] | Reg[16] |'
- en: '| Reg[16] | Mem[16] |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| Reg[16] | Mem[16] |'
- en: '| Mem[16] | Reg[16] |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| Mem[16] | Reg[16] |'
- en: '| Constant | Reg[16] |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | Reg[16] |'
- en: '| Constant | Mem[16] |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | Mem[16] |'
- en: '| Reg[32] | Reg[32] |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| Reg[32] | Reg[32] |'
- en: '| Reg[32] | Mem[32] |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| Reg[32] | Mem[32] |'
- en: '| Mem[32] | Reg[32] |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| Mem[32] | Reg[32] |'
- en: '| Constant | Reg[32] |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | Reg[32] |'
- en: '| Constant | Mem[32] |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | Mem[32] |'
- en: '|'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: ^([[a](#CHP-1-TFN-1)]) The suffix denotes the size of the register or memory
    location.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[a](#CHP-1-TFN-1)]) 后缀表示寄存器或内存位置的大小。
- en: ^([[b](#CHP-1-TFN-2)]) The constant must be small enough to fit in the specified
    destination operand.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[b](#CHP-1-TFN-2)]) 常量必须足够小，以适应指定的目标操作数。
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'The 80x86 `add` and `sub` instructions let you add and subtract two operands.
    Their syntax is nearly identical to the `mov` instruction:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86的`add`和`sub`指令允许你进行加法和减法操作。它们的语法与`mov`指令几乎完全相同：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `add` and `sub` operands take the same form as the `mov` instruction.^([[8](#ftn.CHP-1-FN-8)])
    The `add` instruction does the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`和`sub`操作数的格式与`mov`指令完全相同。^([[8](#ftn.CHP-1-FN-8)]) `add`指令执行以下操作：'
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `sub` instruction does the calculation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub`指令执行计算：'
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With nothing more than these three instructions, plus the HLA control structures
    that the next section discusses, you can actually write some sophisticated programs.
    [Example 1-3](ch01s08.html#demonstration_of_the_mov_comma_add_comma "Example 1-3. Demonstration
    of the mov, add, and sub instructions") provides a sample HLA program that demonstrates
    these three instructions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭这三条指令，再加上下一节讨论的HLA控制结构，你实际上就可以编写一些复杂的程序。[示例1-3](ch01s08.html#demonstration_of_the_mov_comma_add_comma
    "示例1-3. mov、add和sub指令演示")提供了一个HLA程序示例，展示了这三条指令。
- en: Example 1-3. Demonstration of the `mov`, `add`, and `sub` instructions
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-3. `mov`、`add`和`sub`指令演示
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '* * *'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[6](#CHP-1-FN-6)]) Different programs may use a different set of 30 instructions,
    but few programs use more than 30 distinct instructions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[6](#CHP-1-FN-6)]) 不同的程序可能会使用不同的30条指令，但很少有程序会使用超过30条不同的指令。
- en: ^([[7](#CHP-1-FN-7)]) Technically, `mov` actually copies data from one location
    to another. It does not destroy the original data in the source operand. Perhaps
    a better name for this instruction would have been `copy`. Alas, it's too late
    to change it now.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[7](#CHP-1-FN-7)]) 从技术上讲，`mov`实际上是将数据从一个位置复制到另一个位置。它并不会销毁源操作数中的原始数据。也许这个指令应该叫做`copy`会更好。可惜现在已经太晚了，无法更改它了。
- en: ^([[8](#CHP-1-FN-8)]) Remember, though, that `add` and `sub` do not support
    memory-to-memory operations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[8](#CHP-1-FN-8)]) 但请记住，`add`和`sub`不支持内存到内存的操作。
- en: 1.9 Some Basic HLA Control Structures
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.9 一些基本的HLA控制结构
- en: The `mov`, `add`, and `sub` instructions, while valuable, aren't sufficient
    to let you write meaningful programs. You will need to complement these instructions
    with the ability to make decisions and create loops in your HLA programs before
    you can write anything other than a simple program. HLA provides several high-level
    control structures that are very similar to control structures found in high-level
    languages. These include `if..then..elseif..else..endif`, `while..endwhile`, `repeat..until`,
    and so on. By learning these statements you will be armed and ready to write some
    real programs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov`、`add`和`sub`指令虽然很有用，但它们不足以让你编写有意义的程序。在你能够编写复杂程序之前，你还需要具备做决策和创建循环的能力，HLA提供了几种高级控制结构，这些控制结构与高级语言中的控制结构非常相似，包括`if..then..elseif..else..endif`、`while..endwhile`、`repeat..until`等。通过学习这些指令，你将能够准备好编写一些真正的程序。'
- en: Before discussing these high-level control structures, it's important to point
    out that these are not real 80x86 assembly language statements. HLA compiles these
    statements into a sequence of one or more real assembly language statements for
    you. In [Chapter 7](ch07.html "Chapter 7. LOW-LEVEL CONTROL STRUCTURES"), you'll
    learn how HLA compiles the statements, and you'll learn how to write pure assembly
    language code that doesn't use them. However, there is a lot to learn before you
    get to that point, so we'll stick with these high-level language statements for
    now.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论这些高级控制结构之前，首先需要指出的是，这些并不是实际的80x86汇编语言指令。HLA会将这些指令编译成一系列一个或多个真实的汇编语言指令。在[第7章](ch07.html
    "第7章. 低级控制结构")中，你将学习HLA如何编译这些指令，并且你将学习如何编写不使用这些指令的纯汇编语言代码。不过，在你学到这些之前，还有很多内容需要学习，因此我们现在将继续使用这些高级语言指令。
- en: Another important fact to mention is that HLA's high-level control structures
    are *not* as high level as they first appear. The purpose behind HLA's high-level
    control structures is to let you start writing assembly language programs as quickly
    as possible, not to let you avoid the use of assembly language altogether. You
    will soon discover that these statements have some severe restrictions associated
    with them, and you will quickly outgrow their capabilities. This is intentional.
    Once you reach a certain level of comfort with HLA's high-level control structures
    and decide you need more power than they have to offer, it's time to move on and
    learn the real 80x86 instructions behind these statements.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要提到的重要事实是，HLA 的高级控制结构*并不像它们最初看起来的那么高级*。HLA 高级控制结构的目的是让你尽可能快速地开始编写汇编语言程序，而不是让你完全避免使用汇编语言。你很快会发现，这些语句有一些严重的限制，并且你很快会超出它们的能力。这是故意的。一旦你对
    HLA 的高级控制结构有了足够的了解，并且决定你需要比它们提供的更多的功能，那么是时候转向学习这些语句背后的真正 80x86 指令了。
- en: Do not let the presence of high-level-like statements in HLA confuse you. Many
    people, after learning about the presence of these statements in the HLA language,
    erroneously come to the conclusion that HLA is just some special high-level language
    and not a true assembly language. This isn't true. HLA is a full low-level assembly
    language. HLA supports all the same machine instructions as any other 80x86 assembler.
    The difference is that HLA has some *extra* statements that allow you to do *more*
    than is possible with those other 80x86 assemblers. Once you learn 80x86 assembly
    language with HLA, you may elect to ignore all these extra (high-level) statements
    and write only low-level 80x86 assembly language code if this is your desire.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让 HLA 中出现的类似高级语言的语句让你感到困惑。许多人在了解这些语句在 HLA 语言中出现后，错误地得出结论，认为 HLA 只是某种特殊的高级语言，而不是一种真正的汇编语言。这不是真的。HLA
    是一种完整的低级汇编语言。HLA 支持与其他 80x86 汇编器相同的所有机器指令。不同之处在于，HLA 有一些*额外*的语句，允许你做一些比其他 80x86
    汇编器更多的事情。一旦你使用 HLA 学会了 80x86 汇编语言，你可以选择忽略所有这些额外的（高级）语句，只编写低级的 80x86 汇编语言代码，如果这是你的需求。
- en: The following sections assume that you're familiar with at least one high-level
    language. They present the HLA control statements from that perspective without
    bothering to explain how you actually use these statements to accomplish something
    in a program. One prerequisite this text assumes is that you already know how
    to use these generic control statements in a high-level language; you'll use them
    in HLA programs in an identical manner.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节假设你至少熟悉一种高级语言。它们从这个角度介绍 HLA 控制语句，而不去解释如何在程序中实际使用这些语句来完成任务。本文假设的一个前提条件是，你已经知道如何在高级语言中使用这些通用控制语句；你将以相同的方式在
    HLA 程序中使用它们。
- en: 1.9.1 Boolean Expressions in HLA Statements
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.9.1 HLA 语句中的布尔表达式
- en: Several HLA statements require a boolean (true or false) expression to control
    their execution. Examples include the `if`, `while`, and `repeat..until` statements.
    The syntax for these boolean expressions represents the greatest limitation of
    the HLA high-level control structures. This is one area where your familiarity
    with a high-level language will work against you—you'll want to use the fancy
    expressions you use in a high-level language, yet HLA supports only some basic
    forms.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 HLA 语句需要布尔（真或假）表达式来控制它们的执行。例如，`if`、`while` 和 `repeat..until` 语句。对于这些布尔表达式的语法，代表了
    HLA 高级控制结构的最大限制。这是你对高级语言的熟悉度会对你不利的一个地方——你会想要使用在高级语言中常用的复杂表达式，而 HLA 只支持一些基本形式。
- en: HLA boolean expressions take the following forms:^([[9](#ftn.CHP-1-FN-9)])
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 布尔表达式的形式如下：^([[9](#ftn.CHP-1-FN-9)])
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A `flag_specification` may be one of the symbols that are described in [Table 1-2](ch01s09.html#symbols_for_flag_underscore_specificatio
    "Table 1-2. Symbols for flag_specification").
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`flag_specification` 可能是[表1-2](ch01s09.html#symbols_for_flag_underscore_specificatio
    "表1-2. 标志符号")中描述的符号之一。'
- en: Table 1-2. Symbols for `flag_specification`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-2. `flag_specification` 符号
- en: '| Symbol | Meaning | Explanation |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 含义 | 解释 |'
- en: '| --- | --- | --- |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `@c` | Carry | True if the carry is set (1); false if the carry is clear
    (0). |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `@c` | 进位 | 如果进位设置（1），则为真；如果进位清除（0），则为假。 |'
- en: '| `@nc` | No carry | True if the carry is clear (0); false if the carry is
    set (1). |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `@nc` | 无进位 | 如果进位清除（0），则为真；如果进位设置（1），则为假。 |'
- en: '| `@z` | Zero | True if the zero flag is set; false if it is clear. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `@z` | 零 | 如果零标志设置，则为真；如果零标志未设置，则为假。 |'
- en: '| `@nz` | Not zero | True if the zero flag is clear; false if it is set. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `@nz` | 非零 | 如果零标志未设置，则为真；如果零标志设置，则为假。 |'
- en: '| `@o` | Overflow | True if the overflow flag is set; false if it is clear.
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `@o` | 溢出 | 如果溢出标志设置，则为真；如果溢出标志未设置，则为假。 |'
- en: '| `@no` | No overflow | True if the overflow flag is clear; false if it is
    set. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `@no` | 无溢出 | 如果溢出标志未设置，则为真；如果溢出标志设置，则为假。 |'
- en: '| `@s` | Sign | True if the sign flag is set; false if it is clear. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `@s` | 有符号 | 如果符号标志设置，则为真；如果符号标志未设置，则为假。 |'
- en: '| `@ns` | No sign | True if the sign flag is clear; false if it is set. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `@ns` | 无符号 | 如果符号标志未设置，则为真；如果符号标志设置，则为假。 |'
- en: The use of the flag values in a boolean expression is somewhat advanced. You
    will begin to see how to use these boolean expression operands in the next chapter.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在布尔表达式中使用标志值是相对高级的内容。你将在下一章看到如何使用这些布尔表达式操作数。
- en: A register operand can be any of the 8-bit, 16-bit, or 32-bit general-purpose
    registers. The expression evaluates false if the register contains a zero; it
    evaluates true if the register contains a nonzero value.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器操作数可以是任何8位、16位或32位通用寄存器。如果寄存器的值为零，则表达式计算为假；如果寄存器的值为非零，则计算为真。
- en: If you specify a boolean variable as the expression, the program tests it for
    zero (false) or nonzero (true). Because HLA uses the values zero and one to represent
    false and true, respectively, the test works in an intuitive fashion. Note that
    HLA requires such variables be of type `boolean`. HLA rejects other data types.
    If you want to test some other type against zero/not zero, then use the general
    boolean expression discussed next.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将布尔变量指定为表达式，程序会测试它是否为零（假）或非零（真）。由于HLA使用零和一分别表示假和真，因此该测试直观易懂。注意，HLA要求这样的变量类型为`boolean`。HLA会拒绝其他数据类型。如果你想测试某个其他类型是否为零或非零，则需要使用接下来讨论的一般布尔表达式。
- en: The most general form of an HLA boolean expression has two operands and a relational
    operator. [Table 1-3](ch01s09.html#legal_boolean_expressions "Table 1-3. Legal
    Boolean Expressions") lists the legal combinations.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: HLA布尔表达式的最一般形式有两个操作数和一个关系运算符。[表1-3](ch01s09.html#legal_boolean_expressions "表1-3.
    合法布尔表达式")列出了合法的组合。
- en: Table 1-3. Legal Boolean Expressions
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-3. 合法布尔表达式
- en: '| Left Operand | Relational Operator | Right Operand |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 左操作数 | 关系运算符 | 右操作数 |'
- en: '| --- | --- | --- |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Memory variable or register | = or ==<> or !=<<=>>= | Variable, register,
    or constant |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 内存变量或寄存器 | = 或 ==<> 或 !=<<=>>= | 变量、寄存器或常量 |'
- en: Note that both operands cannot be memory operands. In fact, if you think of
    the *right operand* as the source operand and the *left operand* as the destination
    operand, then the two operands must be the same that `add` and `sub` allow.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，两个操作数不能都是内存操作数。实际上，如果你将*右操作数*视为源操作数，将*左操作数*视为目标操作数，那么这两个操作数必须与`add`和`sub`允许的操作数相同。
- en: Also like the `add` and `sub` instructions, the two operands must be the same
    size. That is, they must both be byte operands, they must both be word operands,
    or they must both be double-word operands. If the right operand is a constant,
    its value must be in the range that is compatible with the left operand.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 同样像`add`和`sub`指令一样，两个操作数必须是相同大小的。也就是说，它们必须都是字节操作数，必须都是字操作数，或者必须都是双字操作数。如果右操作数是常量，它的值必须在与左操作数兼容的范围内。
- en: 'There is one other issue: if the left operand is a register and the right operand
    is a positive constant or another register, HLA uses an *unsigned* comparison.
    The next chapter will discuss the ramifications of this; for the time being, do
    not compare negative values in a register against a constant or another register.
    You may not get an intuitive result.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个问题：如果左操作数是一个寄存器，而右操作数是一个正数常量或另一个寄存器，HLA会使用*无符号*比较。下一章将讨论这个问题的后果；目前，请不要将寄存器中的负值与常量或另一个寄存器进行比较。你可能得不到直观的结果。
- en: The `in` and `not in` operators let you test a register to see if it is within
    a specified range. For example, the expression `eax in 2000..2099` evaluates true
    if the value in the EAX register is between 2,000 and 2,099 (inclusive). The `not
    in` (two words) operator checks to see if the value in a register is outside the
    specified range. For example, `al not in 'a'..'z'` evaluates true if the character
    in the AL register is not a lowercase alphabetic character.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of legal boolean expressions in HLA:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 1.9.2 The HLA if..then..elseif..else..endif Statement
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HLA `if` statement uses the syntax shown in [Figure 1-10](ch01s09.html#hla_if_statement_syntax
    "Figure 1-10. HLA if statement syntax").
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![HLA if statement syntax](tagoreillycom20100401nostarchimages577873.png.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: Figure 1-10. HLA `if` statement syntax
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The expressions appearing in an `if` statement must take one of the forms from
    the previous section. If the boolean expression is true, the code after the `then`
    executes; otherwise control transfers to the next `elseif` or `else` clause in
    the statement.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the `elseif` and `else` clauses are optional, an `if` statement could
    take the form of a single `if..then` clause, followed by a sequence of statements
    and a closing `endif` clause. The following is such a statement:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If, during program execution, the expression evaluates true, then the code between
    the `then` and the `endif` executes. If the expression evaluates false, then the
    program skips over the code between the `then` and the `endif`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common form of the `if` statement has a single `else` clause. The following
    is an example of an `if` statement with an optional `else` clause:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the expression evaluates true, the code between the `then` and the `else`
    executes; otherwise the code between the `else` and the `endif` clauses executes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create sophisticated decision-making logic by incorporating the `elseif`
    clause into an `if` statement. For example, if the CH register contains a character
    value, you can select from a menu of items using code like the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Although this simple example doesn't demonstrate it, HLA does not require an
    `else` clause at the end of a sequence of `elseif` clauses. However, when making
    multiway decisions, it's always a good idea to provide an `else` clause just in
    case an error arises. Even if you think it's impossible for the `else` clause
    to execute, just keep in mind that future modifications to the code could void
    this assertion, so it's a good idea to have error-reporting statements in your
    code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.3 Conjunction, Disjunction, and Negation in Boolean Expressions
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some obvious omissions in the list of operators in the previous sections are
    the conjunction (logical `and`), disjunction (logical `or`), and negation (logical
    `not`) operators. This section describes their use in boolean expressions (the
    discussion had to wait until after describing the `if` statement in order to present
    realistic examples).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA uses the `&&` operator to denote logical `and` in a runtime boolean expression.
    This is a dyadic (two-operand) operator, and the two operands must be legal runtime
    boolean expressions. This operator evaluates to true if both operands evaluate
    to true. For example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The two `mov` statements above execute only if EAX is greater than zero *and*
    CH is equal to the character *a*. If either of these conditions is false, then
    program execution skips over these `mov` instructions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the expressions on either side of the `&&` operator may be any legal
    boolean expressions; these expressions don''t have to be comparisons using the
    relational operators. For example, the following are all legal expressions:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: HLA uses *short-circuit evaluation* when compiling the `&&` operator. If the
    leftmost operand evaluates false, then the code that HLA generates does not bother
    evaluating the second operand (because the whole expression must be false at that
    point). Therefore, in the last expression above, the code will not check EAX against
    zero if `boolVar` evaluates false.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that an expression like `eax < 10 && ebx <> eax` is itself a legal boolean
    expression and, therefore, may appear as the left or right operand of the `&&`
    operator. Therefore, expressions like the following are perfectly legal:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `&&` operator is left associative, so the code that HLA generates evaluates
    the expression above in a left-to-right fashion. If EAX is less than zero, the
    CPU will not test either of the remaining expressions. Likewise, if EAX is not
    less than zero but EBX is equal to EAX, this code will not evaluate the third
    expression because the whole expression is false regardless of ECX's value.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA uses the `||` operator to denote disjunction (logical `or`) in a runtime
    boolean expression. Like the `&&` operator, this operator expects two legal runtime
    boolean expressions as operands. This operator evaluates true if either (or both)
    operands evaluate true. Like the `&&` operator, the disjunction operator uses
    short-circuit evaluation. If the left operand evaluates true, then the code that
    HLA generates doesn''t bother to test the value of the second operand. Instead,
    the code will transfer to the location that handles the situation when the boolean
    expression evaluates true. Here are some examples of legal expressions using the
    `||` operator:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Like the `&&` operator, the disjunction operator is left associative, so multiple
    instances of the `||` operator may appear within the same expression. Should this
    be the case, the code that HLA generates will evaluate the expressions from left
    to right. For example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The code above evaluates to true if EAX is less than zero, EBX does not equal
    EAX, or ECX is zero. Note that if the first comparison is true, the code doesn't
    bother testing the other conditions. Likewise, if the first comparison is false
    and the second is true, the code doesn't bother checking to see if ECX is zero.
    The check for ECX equal to zero occurs only if the first two comparisons are false.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'If both the conjunction and disjunction operators appear in the same expression,
    then the `&&` operator takes precedence over the `||` operator. Consider the following
    expression:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The machine code HLA generates evaluates this as
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If EAX is less than zero, then the code HLA generates does not bother to check
    the remainder of the expression, and the entire expression evaluates true. However,
    if EAX is not less than zero, then both of the following conditions must evaluate
    true in order for the overall expression to evaluate true.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA allows you to use parentheses to surround subexpressions involving `&&`
    and `||` if you need to adjust the precedence of the operators. Consider the following
    expression:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For this expression to evaluate true, ECX must contain zero and either EAX must
    be less than zero or EBX must not equal EAX. Contrast this to the result the expression
    produces without the parentheses.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA uses the `!` operator to denote logical negation. However, the `!` operator
    may only prefix a register or boolean variable; you may not use it as part of
    a larger expression (e.g., `!eax < 0`). To achieve logical negative of an existing
    boolean expression, you must surround that expression with parentheses and prefix
    the parentheses with the `!` operator. For example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This expression evaluates true if EAX is not less than zero.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The logical `not` operator is primarily useful for surrounding complex expressions
    involving the conjunction and disjunction operators. While it is occasionally
    useful for short expressions like the one above, it's usually easier (and more
    readable) to simply state the logic directly rather than convolute it with the
    logical `not` operator.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Note that HLA also provides the `|` and `&` operators, but they are distinct
    from `||` and `&&` and have completely different meanings. See the HLA reference
    manual for more details on these (compile-time) operators.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.4 The while..endwhile Statement
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `while` statement uses the basic syntax shown in [Figure 1-11](ch01s09.html#hla_while_statement_syntax
    "Figure 1-11. HLA while statement syntax").
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![HLA while statement syntax](tagoreillycom20100401nostarchimages577875.png.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: Figure 1-11. HLA `while` statement syntax
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: This statement evaluates the boolean expression. If it is false, control immediately
    transfers to the first statement following the `endwhile` clause. If the value
    of the expression is true, then the CPU executes the body of the loop. After the
    loop body executes, control transfers back to the top of the loop, where the `while`
    statement retests the loop control expression. This process repeats until the
    expression evaluates false.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `while` loop, like its high-level-language counterpart, tests
    for loop termination at the top of the loop. Therefore, it is quite possible that
    the statements in the body of the loop will not execute (if the expression is
    false when the code first executes the `while` statement). Also note that the
    body of the `while` loop must, at some point, modify the value of the boolean
    expression or an infinite loop will result.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of an HLA `while` loop:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 1.9.5 The for..endfor Statement
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HLA `for` loop takes the following general form:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is equivalent to the following `while` statement:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*`Initial_Stmt`* can be any single HLA/80x86 instruction. Generally this statement
    initializes a register or memory location (the loop counter) with zero or some
    other initial value. *`Termination_Expression`* is an HLA boolean expression (same
    format that `while` allows). This expression determines whether the loop body
    executes. *`Post_Body_Statement`* executes at the bottom of the loop (as shown
    in the `while` example above). This is a single HLA statement. Usually an instruction
    like `add` modifies the value of the loop control variable.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'The following gives a complete example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The above, rewritten as a while loop, becomes:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 1.9.6 The repeat..until Statement
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HLA `repeat..until` statement uses the syntax shown in [Figure 1-12](ch01s09.html#hla_repeat..until_statement_syntax
    "Figure 1-12. HLA repeat..until statement syntax"). C/C++/C# and Java users should
    note that the `repeat..until` statement is very similar to the `do..while` statement.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![HLA repeat..until statement syntax](tagoreillycom20100401nostarchimages577877.png.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: Figure 1-12. HLA `repeat..until` statement syntax
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The HLA `repeat..until` statement tests for loop termination at the bottom of
    the loop. Therefore, the statements in the loop body always execute at least once.
    Upon encountering the `until` clause, the program will evaluate the expression
    and repeat the loop if the expression is false (that is, it repeats while false).
    If the expression evaluates true, the control transfers to the first statement
    following the `until` clause.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'The following simple example demonstrates the `repeat..until` statement:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If the loop body will always execute at least once, then it is usually more
    efficient to use a `repeat..until` loop rather than a `while` loop.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.7 The break and breakif Statements
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `break` and `breakif` statements provide the ability to prematurely exit
    from a loop. [Figure 1-13](ch01s09.html#hla_break_and_breakif_syntax "Figure 1-13. HLA
    break and breakif syntax") shows the syntax for these two statements.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![HLA break and breakif syntax](tagoreillycom20100401nostarchimages577879.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: Figure 1-13. HLA `break` and `breakif` syntax
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: The `break` statement exits the loop that immediately contains the `break`.
    The `breakif` statement evaluates the boolean expression and exits the containing
    loop if the expression evaluates true.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `break` and `breakif` statements do not allow you to break out
    of more than one nested loop. HLA does provide statements that do this, the `begin..end`
    block and the `exit`/`exitif` statements. Please consult the HLA reference manual
    for more details. HLA also provides the `continue`/`continueif` pair that lets
    you repeat a loop body. Again, see the HLA reference manual for more details.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.8 The forever..endfor Statement
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 1-14](ch01s09.html#hla_forever_loop_syntax "Figure 1-14. HLA forever
    loop syntax") shows the syntax for the `forever` statement.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![HLA forever loop syntax](tagoreillycom20100401nostarchimages577881.png.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
- en: Figure 1-14. HLA `forever` loop syntax
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'This statement creates an infinite loop. You may also use the `break` and `breakif`
    statements along with `forever..endfor` to create a loop that tests for loop termination
    in the middle of the loop. Indeed, this is probably the most common use of this
    loop, as the following example demonstrates:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 1.9.9 The try..exception..endtry Statement
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HLA `try..exception..endtry` statement provides very powerful *exception
    handling* capabilities. The syntax for this statement appears in [Figure 1-15](ch01s09.html#hla_try..exception..endtry_statement_syn
    "Figure 1-15. HLA try..exception..endtry statement syntax").
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '![HLA try..exception..endtry statement syntax](tagoreillycom20100401nostarchimages577883.png.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: Figure 1-15. HLA `try..exception..endtry` statement syntax
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The `try..endtry` statement protects a block of statements during execution.
    If the statements between the `try` clause and the first `exception` clause (the
    *protected block*), execute without incident, control transfers to the first statement
    after the `endtry` immediately after executing the last statement in the protected
    block. If an error (exception) occurs, then the program interrupts control at
    the point of the exception (that is, the program *raises* an exception). Each
    exception has an unsigned integer constant associated with it, known as the *exception
    ID*. The *excepts.hhf* header file in the HLA Standard Library predefines several
    exception IDs, although you may create new ones for your own purposes. When an
    exception occurs, the system compares the exception ID against the values appearing
    in each of the exception clauses following the protected code. If the current
    exception ID matches one of the exception values, control continues with the block
    of statements immediately following that exception. After the exception-handling
    code completes execution, control transfers to the first statement following the
    `endtry`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: If an exception occurs and there is no active `try..endtry` statement, or the
    active `try..endtry` statements do not handle the specific exception, the program
    will abort with an error message.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code fragment demonstrates how to use the `try..endtry` statement
    to protect the program from bad user input:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `repeat..until` loop repeats this code as long as there is an error during
    input. Should an exception occur because of bad input, control transfers to the
    exception clauses to see if a conversion error (e.g., illegal characters in the
    number) or a numeric overflow occurs. If either of these exceptions occur, then
    they print the appropriate message, control falls out of the `try..endtry` statement,
    and the `repeat..until` loop repeats because the code will not have set `GoodInteger`
    to true. If a different exception occurs (one that is not handled in this code),
    then the program aborts with the specified error message.^([[10](#ftn.CHP-1-FN-10)])
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 1-4](ch01s09.html#exceptions_provided_in_excepts.hhf "Table 1-4. Exceptions
    Provided in excepts.hhf") lists the exceptions provided in the *excepts.hhf* header
    file at the time this was being written. See the *excepts.hhf* header file provided
    with HLA for the most current list of exceptions.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Table 1-4. Exceptions Provided in *excepts.hhf*
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '| Exception | Description |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '| `ex.StringOverflow` | Attempt to store a string that is too large into a
    string variable. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: '| `ex.StringIndexError` | Attempt to access a character that is not present
    in a string. |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| `ex.StringOverlap` | Attempt to copy a string onto itself. |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: '| `ex.StringMetaData` | Corrupted string value. |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: '| `ex.StringAlignment` | Attempt to store a string an at unaligned address.
    |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: '| `ex.StringUnderflow` | Attempt to extract "negative" characters from a string.
    |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: '| `ex.IllegalStringOperation` | Operation not permitted on string data. |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
- en: '| `ex.ValueOutOfRange` | Value is too large for the current operation. |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| `ex.IllegalChar` | Operation encountered a character code whose ASCII code
    is not in the range 0..127. |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '| `ex.TooManyCmdLnParms` | Command line contains too many program parameters.
    |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
- en: '| `ex.BadObjPtr` | Pointer to class object is illegal. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: '| `ex.InvalidAlignment` | Argument was not aligned on a proper memory address.
    |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
- en: '| `ex.InvalidArgument` | Function call (generally OS API call) contains an
    invalid argument value. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: '| `ex.BufferOverflow` | Buffer or blob object exceeded declared size. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: '| `ex.BufferUnderflow` | Attempt to retrieve nonexistent data from a blob or
    buffer. |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
- en: '| `ex.IllegalSize` | Argument''s data size is incorrect. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
- en: '| `ex.ConversionError` | String-to-numeric conversion operation contains illegal
    (nonnumeric) characters. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
- en: '| `ex.BadFileHandle` | Program attempted a file access using an invalid file
    handle value. |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
- en: '| `ex.FileNotFound` | Program attempted to access a nonexistent file. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
- en: '| `ex.FileOpenFailure` | Operating system could not open the file (file not
    found). |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '| `ex.FileCloseError` | Operating system could not close the file. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| `ex.FileWriteError` | Error writing data to a file. |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: '| `ex.FileReadError` | Error reading data from a file. |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: '| `ex.FileSeekError` | Attempted to seek to a nonexistent position in a file.
    |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
- en: '| `ex.DiskFullError` | Attempted to write data to a full disk. |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
- en: '| `ex.AccessDenied` | User does not have sufficient priviledges to access file
    data. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: '| `ex.EndOfFile` | Program attempted to read beyond the end of file. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
- en: '| `ex.CannotCreateDir` | Attempt to create a directory failed. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: '| `ex.CannotRemoveDir` | Attempt to delete a directory failed. |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: '| `ex.CannotRemoveFile` | Attempt to delete a file failed. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
- en: '| `ex.CDFailed` | Attempt to change to a new directory failed. |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
- en: '| `ex.CannotRenameFile` | Attempt to rename a file failed. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
- en: '| `ex.MemoryAllocationFailure` | Insufficient system memory for allocation
    request. |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
- en: '| `ex.MemoryFreeFailure` | Could not free the specified memory block (corrupted
    memory management system). |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
- en: '| `ex.MemoryAllocationCorruption` | Corrupted memory management system. |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
- en: '| `ex.AttemptToFreeNULL` | Caller attempted to free a NULL pointer. |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
- en: '| `ex.AttemptToDerefNULL` | Program attempted to access data indirectly using
    a NULL pointer. |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
- en: '| `ex.BlockAlreadyFree` | Caller attempted to free a block that was already
    freed. |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
- en: '| `ex.CannotFreeMemory` | Memory free operation failure. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
- en: '| `ex.PointerNotInHeap` | Caller attempted to free a block of memory that was
    not allocated on the heap. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
- en: '| `ex.WidthTooBig` | Format width for numeric to string conversion was too
    large. |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: '| `ex.FractionTooBig` | Format size for fractional portion in floating-point-to-string
    conversion was too large. |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
- en: '| `ex.ArrayShapeViolation` | Attempted operation on two arrays whose dimensions
    don''t match. |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
- en: '| `ex.ArrayBounds` | Attempted to access an element of an array, but the index
    was out of bounds. |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '| `ex.InvalidDate` | Attempted date operation with an illegal date. |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '| `ex.InvalidDateFormat` | Conversion from string to date contains illegal
    characters. |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| `ex.TimeOverflow` | Overflow during time arithmetic. |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| `ex.InvalidTime` | Attempted time operation with an illegal time. |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| `ex.InvalidTimeFormat` | Conversion from string to time contains illegal
    characters. |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '| `ex.SocketError` | Network communication failure. |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: '| `ex.ThreadError` | Generic thread (multitasking) error. |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
- en: '| `ex.AssertionFailed` | `assert` statement encountered a failed assertion.
    |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: '| `ex.ExecutedAbstract` | Attempt to execute an abstract class method. |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: '| `ex.AccessViolation` | Attempt to access an illegal memory location. |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '| `ex.InPageError` | OS memory access error. |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: '| `ex.NoMemory` | OS memory failure. |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
- en: '| `ex.InvalidHandle` | Bad handle passed to OS API call. |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: '| `ex.ControlC` | **ctrl**-C was pressed on system console (functionality is
    OS specific). |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
- en: '| `ex.Breakpoint` | Program executed a breakpoint instruction (INT 3). |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: '| `ex.SingleStep` | Program is operating with the trace flag set. |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '| `ex.PrivInstr` | Program attempted to execute a kernel-only instruction.
    |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
- en: '| `ex.IllegalInstr` | Program attempted to execute an illegal machine instruction.
    |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
- en: '| `ex.BoundInstr` | Bound instruction execution with "out of bounds" value.
    |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
- en: '| `ex.IntoInstr` | Into instruction execution with the overflow flag set. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
- en: '| `ex.DivideError` | Program attempted division by zero or other divide error.
    |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
- en: '| `ex.fDenormal` | Floating point exception (see [Chapter 6](ch06.html "Chapter 6. ARITHMETIC")).
    |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
- en: '| `ex.fDivByZero` | Floating point exception (see [Chapter 6](ch06.html "Chapter 6. ARITHMETIC")).
    |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
- en: '| `ex.fInexactResult` | Floating point exception (see [Chapter 6](ch06.html
    "Chapter 6. ARITHMETIC")). |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
- en: '| `ex.fInvalidOperation` | Floating point exception (see [Chapter 6](ch06.html
    "Chapter 6. ARITHMETIC")). |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
- en: '| `ex.fOverflow` | Floating point exception (see [Chapter 6](ch06.html "Chapter 6. ARITHMETIC")).
    |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
- en: '| `ex.fStackCheck` | Floating point exception (see [Chapter 6](ch06.html "Chapter 6. ARITHMETIC")).
    |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
- en: '| `ex.fUnderflow` | Floating point exception (see [Chapter 6](ch06.html "Chapter 6. ARITHMETIC")).
    |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
- en: '| `ex.InvalidHandle` | OS reported an invalid handle for some operation. |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
- en: Most of these exceptions occur in situations that are well beyond the scope
    of this chapter. Their appearance here is strictly for completeness. See the HLA
    reference manual, the HLA Standard Library documentation, and the HLA Standard
    Library source code for more details concerning these exceptions. The `ex.ConversionError`*,*
    `ex.ValueOutOfRange`, and `ex.StringOverflow` exceptions are the ones you'll most
    commonly use.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: We'll return to the discussion of the `try..endtry` statement in [1.11 Additional
    Details About try..endtry](ch01s11.html "1.11 Additional Details About try..endtry").
    First, however, we need to cover a little more material.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: ^([[9](#CHP-1-FN-9)]) There are a few additional forms that we'll cover in [Chapter 6](ch06.html
    "Chapter 6. ARITHMETIC").
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: ^([[10](#CHP-1-FN-10)]) An experienced programmer may wonder why this code uses
    a boolean variable rather than a `breakif` statement to exit the `repeat..until`
    loop. There are some technical reasons for this that you will learn about in [1.11
    Additional Details About try..endtry](ch01s11.html "1.11 Additional Details About
    try..endtry").
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 1.10 Introduction to the HLA Standard Library
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two reasons HLA is much easier to learn and use than standard assembly
    language. The first reason is HLA''s high-level syntax for declarations and control
    structures. This leverages your high-level language knowledge, allowing you to
    learn assembly language more efficiently. The other half of the equation is the
    HLA Standard Library. The HLA Standard Library provides many common, easy-to-use,
    assembly language routines that you can call without having to write this code
    yourself (and, more importantly, having to learn how to write yourself). This
    eliminates one of the larger stumbling blocks many people have when learning assembly
    language: the need for sophisticated I/O and support code in order to write basic
    statements. Prior to the advent of a standardized assembly language library, it
    often took considerable study before a new assembly language programmer could
    do as much as print a string to the display. With the HLA Standard Library, this
    roadblock is removed, and you can concentrate on learning assembly language concepts
    rather than learning low-level I/O details that are specific to a given operating
    system.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: A wide variety of library routines is only part of HLA's support. After all,
    assembly language libraries have been around for quite some time.^([[11](#ftn.CHP-1-FN-11)])
    HLA's Standard Library complements HLA by providing a high-level language interface
    to these routines. Indeed, the HLA language itself was originally designed specifically
    to allow the creation of a high-level set of library routines. This high-level
    interface, combined with the high-level nature of many of the routines in the
    library, packs a surprising amount of power in an easy-to-use package.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: The HLA Standard Library consists of several modules organized by category.
    [Table 1-5](ch01s10.html#hla_standard_library_modules "Table 1-5. HLA Standard
    Library Modules") lists many of the modules that are available.^([[12](#ftn.CHP-1-FN-12)])
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Table 1-5. HLA Standard Library Modules
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
- en: '| `args` | Command-line parameter-parsing support routines. |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
- en: '| `arrays` | Array declarations and operations. |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
- en: '| `bits` | Bit-manipulation functions. |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
- en: '| `blobs` | Binary large objects—operations on large blocks of binary data.
    |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
- en: '| `bsd` | OS API calls for FreeBSD (HLA FreeBSD version only). |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
- en: '| `chars` | Operations on character data. |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
- en: '| `console` | Portable console (text screen) operations (cursor movement, screen
    clears, etc.). |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
- en: '| `conv` | Various conversions between strings and other values. |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
- en: '| `coroutines` | Support for coroutines ("cooperative multitasking"). |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
- en: '| `cset` | Character set functions. |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
- en: '| `DateTime` | Calendar, date, and time functions. |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
- en: '| `env` | Access to OS environment variables. |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
- en: '| `excepts` | Exception-handling routines. |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
- en: '| `fileclass` | Object-oriented file input and output. |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
- en: '| `fileio` | File input and output routines. |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
- en: '| `filesys` | Access to the OS file system. |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
- en: '| `hla` | Special HLA constants and other values. |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
- en: '| `Linux` | Linux system calls (HLA Linux version only). |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
- en: '| `lists` | An HLA class for manipulating linked lists. |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
- en: '| `mac` | OS API calls for Mac OS X (HLA Mac OS X version only). |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
- en: '| `math` | Extended-precision arithmetic, transcendental functions, and other
    mathematical functions. |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
- en: '| `memmap` | Memory-mapped file operations. |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
- en: '| `memory` | Memory allocation, deallocation, and support code. |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
- en: '| `patterns` | The HLA pattern-matching library. |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
- en: '| `random` | Pseudo-random number generators and support code. |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
- en: '| `sockets` | A set of network communication functions and classes. |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
- en: '| `stderr` | Provides user output and several other support functions. |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
- en: '| `stdin` | User input routines. |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
- en: '| `stdio` | A support module for stderr, stdin, and stdout. |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
- en: '| `stdout` | Provides user output and several other support routines. |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
- en: '| `strings` | HLA''s powerful string library. |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
- en: '| `tables` | Table (associative array) support routines. |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
- en: '| `threads` | Support for multithreaded applications and process synchronization.
    |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
- en: '| `timers` | Support for timing events in an application. |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
- en: '| `win32` | Constants used in Windows calls (HLA Windows version only). |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
- en: '| `x86` | Constants and other items specific to the 80x86 CPU. |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
- en: Later sections of this text will explain many of these modules in greater detail.
    This section will concentrate on the most important routines (at least to beginning
    HLA programmers), the `stdio` library.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.1 Predefined Constants in the stdio Module
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perhaps the first place to start is with a description of some common constants
    that the `stdio` module defines for you. Consider the following (typical) example:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `nl` appearing at the end of this statement stands for *newline*. The `nl`
    identifier is not a special HLA reserved word, nor is it specific to the `stdout.put`
    statement. Instead, it's simply a predefined constant that corresponds to the
    string containing the standard end-of-line sequence (a carriage return/line feed
    pair under Windows or just a line feed under Linux, FreeBSD, and Mac OS X).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `nl` constant, the HLA standard I/O library module defines
    several other useful character constants, as listed in [Table 1-6](ch01s10.html#character_constants_defined_by_the_hla_s
    "Table 1-6. Character Constants Defined by the HLA Standard I/O Library").
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Table 1-6. Character Constants Defined by the HLA Standard I/O Library
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '| Character | Definition |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
- en: '| `stdio.bell` | The ASCII bell character; beeps the speaker when printed |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
- en: '| `stdio.bs` | The ASCII backspace character |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
- en: '| `stdio.tab` | The ASCII tab character |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
- en: '| `stdio.lf` | The ASCII linefeed character |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
- en: '| `stdio.cr` | The ASCII carriage return character |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
- en: Except for `nl`, these characters appear in the `stdio` namespace^([[13](#ftn.CHP-1-FN-13)])
    (and therefore require the `stdio`. prefix). The placement of these ASCII constants
    within the `stdio` namespace helps avoid naming conflicts with your own variables.
    The `nl` name does not appear within a namespace because you will use it very
    often, and typing `stdio.nl` would get tiresome very quickly.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.2 Standard In and Standard Out
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of the HLA I/O routines have a `stdin` or `stdout` prefix. Technically,
    this means that the standard library defines these names in a namespace. In practice,
    this prefix suggests where the input is coming from (the standard input device)
    or going to (the standard output device). By default, the standard input device
    is the system keyboard. Likewise, the default standard output device is the console
    display. So, in general, statements that have `stdin` or `stdout` prefixes will
    read and write data on the console device.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: When you run a program from the command-line window (or shell), you have the
    option of *redirecting* the standard input and/or standard output devices. A command-line
    parameter of the form `>outfile` redirects the standard output device to the specified
    file (outfile). A command-line parameter of the form `<infile` redirects the standard
    input so that its data comes from the specified input file (infile). The following
    examples demonstrate how to use these parameters when running a program named
    *testpgm* in the command window:^([[14](#ftn.CHP-1-FN-14)])
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 1.10.3 The stdout.newln Routine
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `stdout.newln` procedure prints a newline sequence to the standard output
    device. This is functionally equivalent to saying `stdout.put( nl );`. The call
    to `stdout.newln` is sometimes a little more convenient. For example:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 1.10.4 The stdout.putiX Routines
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `stdout.puti8`, `stdout.puti16`, and `stdout.puti32` library routines print
    a single parameter (one byte, two bytes, or four bytes, respectively) as a signed
    integer value. The parameter may be a constant, a register, or a memory variable,
    as long as the size of the actual parameter is the same as the size of the formal
    parameter.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'These routines print the value of their specified parameter to the standard
    output device. These routines will print the value using the minimum number of
    print positions possible. If the number is negative, these routines will print
    a leading minus sign. Here are some examples of calls to these routines:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 1.10.5 The stdout.putiXSize Routines
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `stdout.puti8Size`, `stdout.puti16Size`, and `stdout.puti32Size` routines
    output signed integer values to the standard output, just like the `stdout.puti`*`X`*
    routines. These routines, however, provide more control over the output; they
    let you specify the (minimum) number of print positions the value will require
    on output. These routines also let you specify a padding character should the
    print field be larger than the minimum needed to display the value. These routines
    require the following parameters:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The *`Value*`* parameter can be a constant, a register, or a memory location
    of the specified size. The *`width`* parameter can be any signed integer constant
    that is between −256 and +256; this parameter may be a constant, register (32-bit),
    or memory location (32-bit). The *`padchar`* parameter should be a single-character
    value.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Like the `stdout.puti`*`X`* routines, these routines print the specified value
    as a signed integer constant to the standard output device. These routines, however,
    let you specify the *field width* for the value. The field width is the minimum
    number of print positions these routines will use when printing the value. The
    `width` parameter specifies the minimum field width. If the number would require
    more print positions (e.g., if you attempt to print `1234` with a field width
    of 2), then these routines will print however many characters are necessary to
    properly display the value. On the other hand, if the *`width`* parameter is greater
    than the number of character positions required to display the value, then these
    routines will print some extra padding characters to ensure that the output has
    at least *`width`* character positions. If the *`width`* value is negative, the
    number is left justified in the print field; if the *`width`* value is positive,
    the number is right justified in the print field.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: If the absolute value of the *`width`* parameter is greater than the minimum
    number of print positions, then these `stdout.puti`*`X`*`Size` routines will print
    a padding character before or after the number. The *`padchar`* parameter specifies
    which character these routines will print. Most of the time you would specify
    a space as the pad character; for special cases, you might specify some other
    character. Remember, the *`padchar`* parameter is a character value; in HLA character
    constants are surrounded by apostrophes, not quotation marks. You may also specify
    an 8-bit register as this parameter.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 1-4](ch01s10.html#tabular_output_demonstration_using_stdio "Example 1-4. Tabular
    output demonstration using stdio.Puti32Size") provides a short HLA program that
    demonstrates the use of the `stdout.puti32Size` routine to display a list of values
    in tabular form.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-4. Tabular output demonstration using `stdio.Puti32Size`
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 1.10.6 The stdout.put Routine
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `stdout.put` routine^([[15](#ftn.CHP-1-FN-15)]) is the one of the most flexible
    output routines in the standard output library module. It combines most of the
    other output routines into a single, easy-to-use procedure.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'The generic form for the `stdout.put` routine is the following:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `stdout.put` parameter list consists of one or more constants, registers,
    or memory variables, each separated by a comma. This routine displays the value
    associated with each parameter appearing in the list. Because we''ve already been
    using this routine throughout this chapter, you''ve already seen many examples
    of this routine''s basic form. It is worth pointing out that this routine has
    several additional features not apparent in the examples appearing in this chapter.
    In particular, each parameter can take one of the following two forms:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The *`value`* may be any legal constant, register, or memory variable object.
    In this chapter, you've seen string constants and memory variables appearing in
    the `stdout.put` parameter list. These parameters correspond to the first form
    above. The second parameter form above lets you specify a minimum field width,
    similar to the `stdout.puti`*`X`*`Size` routines.^([[16](#ftn.CHP-1-FN-16)]) The
    program in [Example 1-5](ch01s10.html#demonstration_of_the_stdout.put_field_wi
    "Example 1-5. Demonstration of the stdout.put field width specification") produces
    the same output as the program in [Example 1-4](ch01s10.html#tabular_output_demonstration_using_stdio
    "Example 1-4. Tabular output demonstration using stdio.Puti32Size"); however,
    [Example 1-5](ch01s10.html#demonstration_of_the_stdout.put_field_wi "Example 1-5. Demonstration
    of the stdout.put field width specification") uses `stdout.put` rather than `stdout.puti32Size`.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-5. Demonstration of the `stdout.put` field width specification
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `stdout.put` routine is capable of much more than the few attributes this
    section describes. This text will introduce those additional capabilities as appropriate.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.7 The stdin.getc Routine
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `stdin.getc` routine reads the next available character from the standard
    input device's input buffer.^([[17](#ftn.CHP-1-FN-17)]) It returns this character
    in the CPU's AL register. The program in [Example 1-6](ch01s10.html#demonstration_of_the_stdin.getc_open_par
    "Example 1-6. Demonstration of the stdin.getc() routine") demonstrates a simple
    use of this routine.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-6. Demonstration of the `stdin.getc()` routine
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This program uses the `stdin.ReadLn` routine to force a new line of input from
    the user. A description of `stdin.ReadLn` appears in [1.10.9 The stdin.readLn
    and stdin.flushInput Routines](ch01s10.html#the_stdin.readln_and_stdin.flushinput_ro
    "1.10.9 The stdin.readLn and stdin.flushInput Routines").
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.8 The stdin.geti X Routines
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `stdin.geti8`, `stdin.geti16`, and `stdin.geti32` routines read 8-, 16-,
    and 32-bit signed integer values from the standard input device. These routines
    return their values in the AL, AX, or EAX register, respectively. They provide
    the standard mechanism for reading signed integer values from the user in HLA.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Like the `stdin.getc` routine, these routines read a sequence of characters
    from the standard input buffer. They begin by skipping over any whitespace characters
    (spaces, tabs, and so on) and then convert the following stream of decimal digits
    (with an optional leading minus sign) into the corresponding integer. These routines
    raise an exception (that you can trap with the `try..endtry` statement) if the
    input sequence is not a valid integer string or if the user input is too large
    to fit in the specified integer size. Note that values read by `stdin.geti8` must
    be in the range −128..+127; values read by `stdin.geti16` must be in the range
    −32,768..+32,767; and values read by `stdin.geti32` must be in the range −2,147,483,648..+2,147,483,647.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: The sample program in [Example 1-7](ch01s10.html#stdin.getix_example_code "Example 1-7. stdin.getiX
    example code") demonstrates the use of these routines.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-7. `stdin.getiX` example code
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You should compile and run this program and then test what happens when you
    enter a value that is out of range or enter an illegal string of characters.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.9 The stdin.readLn and stdin.flushInput Routines
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whenever you call an input routine like `stdin.getc` or `stdin.geti32`, the
    program does not necessarily read the value from the user at that moment. Instead,
    the HLA Standard Library buffers the input by reading a whole line of text from
    the user. Calls to input routines will fetch data from this input buffer until
    the buffer is empty. While this buffering scheme is efficient and convenient,
    sometimes it can be confusing. Consider the following code sequence:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Intuitively, you would expect the program to print the first prompt message,
    wait for user input, print the second prompt message, and wait for the second
    user input. However, this isn't exactly what happens. For example, if you run
    this code (from the sample program in the previous section) and enter the text
    **`123 456`** in response to the first prompt, the program will not stop for additional
    user input at the second prompt. Instead, it will read the second integer (456)
    from the input buffer read during the execution of the `stdin.geti16` call.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the `stdin` routines read text from the user only when the input
    buffer is empty. As long as the input buffer contains additional characters, the
    input routines will attempt to read their data from the buffer. You can take advantage
    of this behavior by writing code sequences such as the following:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This sequence allows the user to enter both values on the same line (separated
    by one or more whitespace characters), thus preserving space on the screen. So
    the input buffer behavior is desirable every now and then. The buffered behavior
    of the input routines can be counterintuitive at other times.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the HLA Standard Library provides two routines, `stdin.readLn`
    and `stdin.flushInput`, that let you control the standard input buffer. The `stdin.readLn`
    routine discards everything that is in the input buffer and immediately requires
    the user to enter a new line of text. The `stdin.flushInput` routine simply discards
    everything that is in the buffer. The next time an input routine executes, the
    system will require a new line of input from the user. You would typically call
    `stdin.readLn` immediately before some standard input routine; you would normally
    call `stdin.flushInput` immediately after a call to a standard input routine.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are calling `stdin.readLn` and you find that you are having to input
    your data twice, this is a good indication that you should be calling `stdin.flushInput`
    rather than `stdin.readLn`. In general, you should always be able to call `stdin.flushInput`
    to flush the input buffer and read a new line of data on the next input call.
    The `stdin.readLn` routine is rarely necessary, so you should use `stdin.flushInput`
    unless you really need to immediately force the input of a new line of text.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.10 The stdin.get Routine
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `stdin.get` routine combines many of the standard input routines into a
    single call, just as the `stdout.put` combines all of the output routines into
    a single call. Actually, `stdin.get` is a bit easier to use than `stdout.put`
    because the only parameters to this routine are a list of variable names.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the example given in the previous section:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Using the `stdin.get` routine, we could rewrite this code as:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, the `stdin.get` routine is a little more convenient to use.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Note that `stdin.get` stores the input values directly into the memory variables
    you specify in the parameter list; it does not return the values in a register
    unless you actually specify a register as a parameter. The `stdin.get` parameters
    must all be variables or registers.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: ^([[11](#CHP-1-FN-11)]) For example, see the UCR Standard Library for 80x86
    Assembly Language Programmers.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: ^([[12](#CHP-1-FN-12)]) Because the HLA Standard Library is expanding, this
    list is probably out of date. See the HLA documentation for a current list of
    Standard Library modules.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: ^([[13](#CHP-1-FN-13)]) Namespaces are the subject of [Chapter 5](ch05.html
    "Chapter 5. PROCEDURES AND UNITS").
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: ^([[14](#CHP-1-FN-14)]) For Linux, FreeBSD, and Mac OS X users, depending on
    how your system is set up, you may need to type `./` in front of the program's
    name to actually execute the program (e.g., `./testpgm <input.data)`.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: ^([[15](#CHP-1-FN-15)]) `stdout.put` is actually a macro, not a procedure. The
    distinction between the two is beyond the scope of this chapter. [Chapter 9](ch09.html
    "Chapter 9. MACROS AND THE HLA COMPILE-TIME LANGUAGE") describes their differences.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: ^([[16](#CHP-1-FN-16)]) Note that you cannot specify a padding character when
    using the `stdout.put` routine; the padding character defaults to the space character.
    If you need to use a different padding character, call the `stdout.puti`*`X`*`Size`
    routines.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: ^([[17](#CHP-1-FN-17)]) *Buffer* is just a fancy term for an array.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 1.11 Additional Details About try..endtry
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may recall, the `try..endtry` statement surrounds a block of statements
    in order to capture any exceptions that occur during the execution of those statements.
    The system raises exceptions in one of three ways: through a hardware fault (such
    as a divide-by-zero error), through an operating system-generated exception, or
    through the execution of the HLA `raise` statement. You can write an exception
    handler to intercept specific exceptions using the `exception` clause. The program
    in [Example 1-8](ch01s11.html#try..endtry_example "Example 1-8. try..endtry example")
    provides a typical example of the use of this statement.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-8. `try..endtry` example
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: HLA refers to the statements between the `try` clause and the first `exception`
    clause as the *protected* statements. If an exception occurs within the protected
    statements, then the program will scan through each of the exceptions and compare
    the value of the current exception against the value in the parentheses after
    each of the `exception` clauses.^([[18](#ftn.CHP-1-FN-18)]) This exception value
    is simply a 32-bit value. The value in the parentheses after each `exception`
    clause, therefore, must be a 32-bit value. The HLA *excepts.hhf* header file predefines
    several exception constants. Although it would be an incredibly bad style violation,
    you could substitute the numeric values for the two `exception` clauses above.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 1.11.1 Nesting try..endtry Statements
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the program scans through all the `exception` clauses in a `try..endtry`
    statement and does not match the current exception value, then the program searches
    through the `exception` clauses of a *dynamically nested* `try..endtry` block
    in an attempt to find an appropriate exception handler. For example, consider
    the code in [Example 1-9](ch01s11.html#nested_try..endtry_statements "Example 1-9. Nested
    try..endtry statements").
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-9. Nested `try..endtry` statements
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In [Example 1-9](ch01s11.html#nested_try..endtry_statements "Example 1-9. Nested
    try..endtry statements") one `try` statement is nested inside another. During
    the execution of the `stdin.get` statement, if the user enters a value greater
    than four billion and some change, then `stdin.get` will raise the `ex.ValueOutOfRange`
    exception. When the HLA runtime system receives this exception, it first searches
    through all the exception clauses in the `try..endtry` statement immediately surrounding
    the statement that raised the exception (this would be the nested `try..endtry`
    in the example above). If the HLA runtime system fails to locate an exception
    handler for `ex.ValueOutOfRange`, then it checks to see if the current `try..endtry`
    is nested inside another `try..endtry` (as is the case in [Example 1-9](ch01s11.html#nested_try..endtry_statements
    "Example 1-9. Nested try..endtry statements")). If so, the HLA runtime system
    searches for the appropriate exception clause in the outer `try..endtry` statement.
    Within the `try..endtry` block appearing in [Example 1-9](ch01s11.html#nested_try..endtry_statements
    "Example 1-9. Nested try..endtry statements") the program finds an appropriate
    exception handler, so control transfers to the statements after the `exception(
    ex.ValueOutOfRange )` clause.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: After leaving a `try..endtry` block, the HLA runtime system no longer considers
    that block active and will not search through its list of exceptions when the
    program raises an exception.^([[19](#ftn.CHP-1-FN-19)]) This allows you to handle
    the same exception differently in other parts of the program.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: If two `try..endtry` statements handle the same exception, and one of the `try..endtry`
    blocks is nested inside the protected section of the other `try..endtry` statement,
    and the program raises an exception while executing in the innermost `try..endtry`
    sequence, then HLA transfers control directly to the exception handler provided
    by the innermost `try..endtry` block. HLA does not automatically transfer control
    to the exception handler provided by the outer `try..endtry` sequence.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example ([Example 1-9](ch01s11.html#nested_try..endtry_statements
    "Example 1-9. Nested try..endtry statements")) the second `try..endtry` statement
    was statically nested inside the enclosing `try..endtry` statement.^([[20](#ftn.CHP-1-FN-20)])
    As mentioned without comment earlier, if the most recently activated `try..endtry`
    statement does not handle a specific exception, the program will search through
    the `exception` clauses of any dynamically nesting `try..endtry` blocks. Dynamic
    nesting does not require the nested `try..endtry` block to physically appear within
    the enclosing `try..endtry` statement. Instead, control could transfer from inside
    the enclosing `try..endtry` protected block to some other point in the program.
    Execution of a `try..endtry` statement at that other point dynamically nests the
    two `try` statements. Although there are many ways to dynamically nest code, there
    is one method you are probably familiar with from your high-level language experience:
    the procedure call. In [Chapter 5](ch05.html "Chapter 5. PROCEDURES AND UNITS"),
    when you learn how to write procedures (functions) in assembly language, you should
    keep in mind that any call to a procedure within the protected section of a `try..endtry`
    block can create a dynamically nested `try..endtry` if the program executes a
    `try..endtry` within that procedure.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 1.11.2 The unprotected Clause in a try..endtry Statement
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever a program executes the `try` clause, it preserves the current exception
    environment and sets up the system to transfer control to the `exception` clauses
    within that `try..endtry` statement should an exception occur. If the program
    successfully completes the execution of a `try..endtry` protected block, the program
    restores the original exception environment and control transfers to the first
    statement beyond the `endtry` clause. This last step, restoring the execution
    environment, is very important. If the program skips this step, any future exceptions
    will transfer control to this `try..endtry` statement even though the program
    has already left the `try..endtry` block. [Example 1-10](ch01s11.html#improperly_exiting_a_try..endtry_stateme
    "Example 1-10. Improperly exiting a try..endtry statement") demonstrates this
    problem.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-10. Improperly exiting a `try..endtry` statement
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This example attempts to create a robust input system by putting a loop around
    the `try..endtry` statement and forcing the user to reenter the data if the `stdin.get`
    routine raises an exception (because of bad input data). While this is a good
    idea, there is a big problem with this implementation: the `break` statement immediately
    exits the `forever..endfor` loop without first restoring the exception environment.
    Therefore, when the program executes the second `stdin.get` statement, at the
    bottom of the program, the HLA exception-handling code still thinks that it''s
    inside the `try..endtry` block. If an exception occurs, HLA transfers control
    back into the `try..endtry` statement looking for an appropriate exception handler.
    Assuming the exception was `ex.ValueOutOfRange` or `ex.ConversionError`, the program
    in [Example 1-10](ch01s11.html#improperly_exiting_a_try..endtry_stateme "Example 1-10. Improperly
    exiting a try..endtry statement") will print an appropriate error message *and
    then force the user to re-enter the first value*. This isn''t desirable.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: 'Transferring control to the wrong `try..endtry` exception handlers is only
    part of the problem. Another big problem with the code in [Example 1-10](ch01s11.html#improperly_exiting_a_try..endtry_stateme
    "Example 1-10. Improperly exiting a try..endtry statement") has to do with the
    way HLA preserves and restores the exception environment: specifically, HLA saves
    the old execution environment information in a special region of memory known
    as the *stack*. If you exit a `try..endtry` without restoring the exception environment,
    this leaves the old execution environment information on the stack, and this extra
    data on could cause your program to malfunction.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Although this discussion makes it quite clear that a program should not exit
    from a `try..endtry` statement in the manner that [Example 1-10](ch01s11.html#improperly_exiting_a_try..endtry_stateme
    "Example 1-10. Improperly exiting a try..endtry statement") uses, it would be
    nice if you could use a loop around a `try..endtry` block to force the reentry
    of bad data as this program attempts to do. To allow for this, HLA's `try..endtry`
    statement provides an `unprotected` section. Consider the code in [Example 1-11](ch01s11.html#the_try..endtry_unprotected_section
    "Example 1-11. The try..endtry unprotected section").
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-11. The `try..endtry` unprotected section
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Whenever the `try..endtry` statement hits the `unprotected` clause, it immediately
    restores the exception environment. As the phrase suggests, the execution of statements
    in the `unprotected` section is no longer protected by that `try..endtry` block
    (note, however, that any dynamically nesting `try..endtry` statements will still
    be active; `unprotected` turns off only the exception handling of the `try..endtry`
    statement containing the `unprotected` clause). Because the `break` statement
    in [Example 1-11](ch01s11.html#the_try..endtry_unprotected_section "Example 1-11. The
    try..endtry unprotected section") appears inside the `unprotected` section, it
    can safely transfer control out of the `try..endtry` block without "executing"
    the `endtry` because the program has already restored the former exception environment.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `unprotected` keyword must appear in the `try..endtry` statement
    immediately after the `protected` block. That is, it must precede all `exception`
    keywords.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: If an exception occurs during the execution of a `try..endtry` sequence, HLA
    automatically restores the execution environment. Therefore, you may execute a
    `break` statement (or any other instruction that transfers control out of the
    `try..endtry` block) within an `exception` clause.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Because the program restores the exception environment upon encountering an
    `unprotected` block or an `exception` block, an exception that occurs within one
    of these areas immediately transfers control to the previous (dynamically nesting)
    active `try..endtry` sequence. If there is no nesting `try..endtry` sequence,
    the program aborts with an appropriate error message.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 1.11.3 The anyexception Clause in a try..endtry Statement
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a typical situation, you will use a `try..endtry` statement with a set of
    `exception` clauses that will handle all possible exceptions that can occur in
    the protected section of the `try..endtry` sequence. Often, it is important to
    ensure that a `try..endtry` statement handles all possible exceptions to prevent
    the program from prematurely aborting due to an unhandled exception. If you have
    written all the code in the protected section, you will know the exceptions it
    can raise, so you can handle all possible exceptions. However, if you are calling
    a library routine (especially a third-party library routine), making a OS API
    call, or otherwise executing code that you have no control over, it may not be
    possible for you to anticipate all possible exceptions this code could raise (especially
    when considering past, present, and future versions of the code). If that code
    raises an exception for which you do not have an `exception` clause, this could
    cause your program to fail. Fortunately, HLA's `try..endtry` statement provides
    the `anyexception` clause that will automatically trap any exception the existing
    `exception` clauses do not handle.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: The `anyexception` clause is similar to the `exception` clause except it does
    not require an exception number parameter (because it handles any exception).
    If the `anyexception` clause appears in a `try..endtry` statement with other `exception`
    sections, the `anyexception` section must be the last exception handler in the
    `try..endtry` statement. An `anyexception` section may be the only exception handler
    in a `try..endtry` statement.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: If an otherwise unhandled exception transfers control to an `anyexception` section,
    the EAX register will contain the exception number. Your code in the `anyexception`
    block can test this value to determine the cause of the exception.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: 1.11.4 Registers and the try..endtry Statement
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `try..endtry` statement preserves several bytes of data whenever you enter
    a `try..endtry` statement. Upon leaving the `try..endtry` block (or hitting the
    `unprotected` clause), the program restores the exception environment. As long
    as no exception occurs, the `try..endtry` statement does not affect the values
    of any registers upon entry to or upon exit from the `try..endtry` statement.
    However, this claim is not true if an exception occurs during the execution of
    the protected statements.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Upon entry into an `exception` clause, the EAX register contains the exception
    number, but the values of all other general-purpose registers are undefined. Because
    the operating system may have raised the exception in response to a hardware error
    (and, therefore, has played around with the registers), you can't even assume
    that the general-purpose registers contain whatever values they happened to contain
    at the point of the exception. The underlying code that HLA generates for exceptions
    is subject to change in different versions of the compiler, and certainly it changes
    across operating systems, so it is never a good idea to experimentally determine
    what values registers contain in an exception handler and depend on those values
    in your code.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: 'Because entry into an exception handler can scramble the register values, you
    must ensure that you reload important registers if the code following your `endtry`
    clause assumes that the registers contain certain values (i.e., values set in
    the protected section or values set prior to executing the `try..endtry` statement).
    Failure to do so will introduce some nasty defects into your program (and these
    defects may be very intermittent and difficult to detect because exceptions rarely
    occur and may not always destroy the value in a particular register). The following
    code fragment provides a typical example of this problem and its solution:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Because the HLA exception-handling mechanism messes with the registers, and
    because exception handling is a relatively inefficient process, you should never
    use the `try..endtry` statement as a generic control structure (e.g., using it
    to simulate a `switch/case` statement by raising an integer exception value and
    using the exception clauses as the cases to process). Doing so will have a very
    negative impact on the performance of your program and may introduce subtle defects
    because exceptions scramble the registers.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: For proper operation, the `try..endtry` statement assumes that you use the EBP
    register only to point at *activation records* ([Chapter 5](ch05.html "Chapter 5. PROCEDURES
    AND UNITS") discusses activation records). By default, HLA programs automatically
    use EBP for this purpose; as long as you do not modify the value in EBP, your
    programs will automatically use EBP to maintain a pointer to the current activation
    record. If you attempt to use the EBP register as a general-purpose register to
    hold values and compute arithmetic results, HLA's exception-handling capabilities
    will no longer function properly (along with other possible problems). Therefore,
    you should never use the EBP register as a general-purpose register. Of course,
    this same discussion applies to the ESP register.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: ^([[18](#CHP-1-FN-18)]) Note that HLA loads this value into the EAX register.
    So upon entry into an `exception` clause, EAX contains the exception number.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: ^([[19](#CHP-1-FN-19)]) Unless, of course, the program re-enters the `try..endtry`
    block via a loop or other control structure.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: ^([[20](#CHP-1-FN-20)]) *Statically nested* means that one statement is physically
    nested within another in the source code. When we say one statement is nested
    within another, this typically means that the statement is statically nested within
    the other statement.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 1.12 High-Level Assembly Language vs. Low-Level Assembly Language
  id: totrans-539
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before concluding this chapter, it's important to remind you that none of the
    control statements appearing in this chapter are "real" assembly language. The
    80x86 CPU does not support machine instructions like `if`, `while`, `repeat`,
    `for`, `break`, `breakif`, and `try`. Whenever HLA encounters these statements,
    it *compiles* them into a sequence of one or more true machine instructions that
    do the operation as the high-level statements you've used. While these statements
    are convenient to use, and in many cases just as efficient as the sequence of
    low-level machine instructions into which HLA translates them, don't lose sight
    of the fact that they are not true machine instructions.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this text is to teach you low-level assembly language programming;
    these high-level control structures are simply a means to that end. Remember,
    learning the HLA high-level control structures allows you to leverage your high-level
    language knowledge early on in the educational process so you don't have to learn
    everything about assembly language all at once. By using high-level control structures
    that you're already comfortable with, this text can put off the discussion of
    the actual machine instructions you'd normally use for control flow until much
    later. By doing so, this text can regulate how much material it presents, so,
    hopefully, you'll find learning assembly language to be much more pleasant. However,
    you must always remember that these high-level control statements are just a pedagogical
    tool to help you learn assembly language. Though you're free to use them in your
    assembly programs once you master the real control-flow statements, you really
    must learn the low-level control statements if you want to learn assembly language
    programming. Since, presumably, that's why you're reading this book, don't allow
    the high-level control structures to become a crutch. When you get to the point
    where you learn how to really write low-level control statements, embrace and
    use them (exclusively). As you gain experience with the low-level control statements
    and learn their advantages and disadvantages, you'll be in a good position to
    decide whether a high-level or low-level code sequence is most appropriate for
    a given application. However, until you gain considerable experience with the
    low-level control structures, you'll not be able to make an educated decision.
    Remember, you can't really call yourself an assembly language programmer unless
    you've mastered the low-level statements.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to keep in mind is that the HLA Standard Library functions are
    not part of the assembly *language*. They're just some convenient functions that
    have been prewritten for you. Although there is nothing wrong with calling these
    functions, always remember that they are not machine instructions and that there
    is nothing special about these routines; as you gain experience writing assembly
    language code, you can write your own versions of each of these routines (and
    even write them more efficiently).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: If you're learning assembly language because you want to write the most efficient
    programs possible (either the fastest or the smallest code), you need to understand
    that you won't achieve this goal completely if you're using high-level control
    statements and making a lot of calls to the HLA Standard Library. HLA's code generator
    and the HLA Standard Library aren't *horribly* inefficient, but the only true
    way to write efficient programs in assembly language is to *think* in assembly
    language. HLA's high-level control statements and many of the routines in the
    HLA Standard Library are great because they let you *avoid* thinking in assembly
    language. While this is great while you're first learning assembly, if your ultimate
    goal is to write efficient code, then you have to learn to think in assembly language.
    This text will get you to that point (and will do so much more rapidly because
    it uses HLA's high-level features), but don't forget that your ultimate goal is
    to give up these high-level features in favor of low-level coding.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: 1.13 For More Information
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered a lot of ground! While you still have a lot to learn
    about assembly language programming, this chapter, combined with your knowledge
    of high-level languages, provides just enough information to let you start writing
    real assembly language programs.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Although this chapter has covered many different topics, the three primary topics
    of interest are the 80x86 CPU architecture, the syntax for simple HLA programs,
    and the HLA Standard Library. For additional topics on this subject, please consult
    the (unabridged) electronic version of this text, the HLA reference manual, and
    the HLA Standard Library manual. All three are available at [http://www.artofasm.com/](http://www.artofasm.com/)
    and [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/).
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
