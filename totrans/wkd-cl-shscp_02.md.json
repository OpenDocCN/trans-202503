["```\n   #!/bin/bash\n   # inpath--Verifies that a specified program is either valid as is\n   #   or can be found in the PATH directory list\n\n   in_path()\n   {\n     # Given a command and the PATH, tries to find the command. Returns 0 if\n     #   found and executable; 1 if not. Note that this temporarily modifies\n     #   the IFS (internal field separator) but restores it upon completion.\n\n     cmd=$1        ourpath=$2         result=1\n     oldIFS=$IFS   IFS=\":\"\n\n     for directory in \"$ourpath\"\n     do\n       if [ -x $directory/$cmd ] ; then\n         result=0      # If we're here, we found the command.\n       fi\n     done\n\n     IFS=$oldIFS\n     return $result\n   }\n\n   checkForCmdInPath()\n   {\n     var=$1\n\n     if [ \"$var\" != \"\" ] ; then\n➊     if [ \"${var:0:1}\" = \"/\" ] ; then\n➋       if [ !  -x $var ] ; then\n           return 1\n         fi\n➌     elif !  in_path $var \"$PATH\" ; then\n         return 2\n       fi\n     fi\n   }\n```", "```\n$ var=\"something wicked this way comes...\"\n$ echo ${var:10}\nwicked this way comes...\n$ echo ${var:10:6}\nwicked\n$\n```", "```\nif [ $# -ne 1 ] ; then\n  echo \"Usage: $0 command\" >&2\n  exit 1\nfi\n\ncheckForCmdInPath \"$1\"\ncase $? in\n  0 ) echo \"$1 found in PATH\"                   ;;\n  1 ) echo \"$1 not found or not executable\"     ;;\n  2 ) echo \"$1 not found in PATH\"               ;;\nesac\n\nexit 0\n```", "```\n$ inpath echo\necho found in PATH\n$ inpath MrEcho\nMrEcho not found in PATH\n$ inpath /usr/bin/MrEcho\n/usr/bin/MrEcho not found or not executable\n```", "```\nif [ \"$BASH_SOURCE\" = \"$0\" ]\n```", "```\n   #!/bin/bash\n   # validAlphaNum--Ensures that input consists only of alphabetical\n   #   and numeric characters\n\n   validAlphaNum()\n   {\n     # Validate arg: returns 0 if all upper+lower+digits; 1 otherwise\n\n     # Remove all unacceptable chars.\n➊   validchars=\"$(echo $1 | sed -e 's/[^[:alnum:]]//g')\"\n\n➋   if [ \"$validchars\" = \"$1\" ] ; then\n       return 0\n     else\n       return 1\n     fi\n   }\n\n   # BEGIN MAIN SCRIPT--DELETE OR COMMENT OUT EVERYTHING BELOW THIS LINE IF\n   #   YOU WANT TO INCLUDE THIS IN OTHER SCRIPTS.\n   # =================\n   /bin/echo -n \"Enter input: \"\n   read input\n\n   # Input validation\n   if ! validAlphaNum \"$input\" ; then\n     echo \"Please enter only letters and numbers.\" >&2\n     exit 1\n   else\n     echo \"Input is valid.\"\n   fi\n\n   exit 0\n```", "```\n$ validalnum\nEnter input: valid123SAMPLE\nInput is valid.\n$ validalnum\nEnter input: this is most assuredly NOT valid, 12345\nPlease enter only letters and numbers.\n```", "```\nsed 's/[^[:upper:] ,.]//g'\n```", "```\nsed 's/[^- [:digit:]\\(\\)]//g'\n```", "```\nsed 's/[^[:digit:]]//g'\n```", "```\n   #!/bin/bash\n   # normdate--Normalizes month field in date specification to three letters,\n   #   first letter capitalized. A helper function for Script #7, valid-date.\n   #   Exits with 0 if no error.\n\n   monthNumToName()\n   {\n     # Sets the 'month' variable to the appropriate value.\n     case $1 in\n       1 ) month=\"Jan\"    ;;  2 ) month=\"Feb\"    ;;\n       3 ) month=\"Mar\"    ;;  4 ) month=\"Apr\"    ;;\n       5 ) month=\"May\"    ;;  6 ) month=\"Jun\"    ;;\n       7 ) month=\"Jul\"    ;;  8 ) month=\"Aug\"    ;;\n       9 ) month=\"Sep\"    ;;  10) month=\"Oct\"    ;;\n       11) month=\"Nov\"    ;;  12) month=\"Dec\"    ;;\n       * ) echo \"$0: Unknown month value $1\" >&2\n           exit 1\n     esac\n     return 0\n   }\n\n   # BEGIN MAIN SCRIPT--DELETE OR COMMENT OUT EVERYTHING BELOW THIS LINE IF\n   #   YOU WANT TO INCLUDE THIS IN OTHER SCRIPTS.\n   # =================\n   # Input validation\n   if [ $# -ne 3 ] ; then\n     echo \"Usage: $0 month day year\" >&2\n     echo \"Formats are August 3 1962 and 8 3 1962\" >&2\n     exit 1\n   fi\n   if [ $3 -le 99 ] ; then\n     echo \"$0: expected 4-digit year value.\" >&2\n     exit 1\n   fi\n\n   # Is the month input format a number?\n➊ if [ -z $(echo $1|sed 's/[[:digit:]]//g') ]; then\n     monthNumToName $1\n   else\n   # Normalize to first 3 letters, first upper- and then lowercase.\n➋   month=\"$(echo $1|cut -c1|tr '[:lower:]' '[:upper:]')\"\n➌   month=\"$month$(echo $1|cut -c2-3 | tr '[:upper:]' '[:lower:]')\"\n   fi\n\n   echo $month $2 $3\n\n   exit 0\n```", "```\n$ normdate 8 3 62\nnormdate: expected 4-digit year value.\n$ normdate 8 3 1962\nAug 3 1962\n$ normdate AUGUST 03 1962\nAug 03 1962\n```", "```\nif [ $# -eq 1 ] ; then # To compensate for / or - formats\n  set -- $(echo $1 | sed 's/[\\/\\-]/ /g')\nfi\n```", "```\n$ normdate 6-10-2000\nJun 10 2000\n$ normdate March-11-1911\nMar 11 1911\n$ normdate 8/3/1962\nAug 3 1962\n```", "```\n   #!/bin/bash\n   # nicenumber--Given a number, shows it in comma-separated form. Expects DD\n   #   (decimal point delimiter) and TD (thousands delimiter) to be instantiated.\n   #   Instantiates nicenum or, if a second arg is specified, the output is\n   #   echoed to stdout.\n\n   nicenumber()\n   {\n     # Note that we assume that '.' is the decimal separator in the INPUT value\n     #   to this script. The decimal separator in the output value is '.' unless\n     #   specified by the user with the -d flag.\n\n➊   integer=$(echo $1 | cut -d. -f1)        # Left of the decimal\n➋   decimal=$(echo $1 | cut -d. -f2)        # Right of the decimal\n     # Check if number has more than the integer part.\n     if [ \"$decimal\" != \"$1\" ]; then\n       # There's a fractional part, so let's include it.\n       result=\"${DD:= '.'}$decimal\"\n     fi\n\n     thousands=$integer\n\n➌   while [ $thousands -gt 999 ]; do\n➍     remainder=$(($thousands % 1000))    # Three least significant digits\n\n       # We need 'remainder' to be three digits. Do we need to add zeros?\n       while [ ${#remainder} -lt 3 ] ; do  # Force leading zeros\n         remainder=\"0$remainder\"\n       done\n\n➎     result=\"${TD:=\",\"}${remainder}${result}\"    # Builds right to left\n➏     thousands=$(($thousands / 1000))    # To left of remainder, if any\n     done\n\n     nicenum=\"${thousands}${result}\"\n     if [ ! -z $2 ] ; then\n       echo $nicenum\n     fi\n   }\n\n   DD=\".\"  # Decimal point delimiter, to separate whole and fractional values\n   TD=\",\"  # Thousands delimiter, to separate every three digits\n\n   # BEGIN MAIN SCRIPT\n   # =================\n\n➐ while getopts \"d:t:\" opt; do\n     case $opt in\n       d ) DD=\"$OPTARG\"   ;;\n       t ) TD=\"$OPTARG\"   ;;\n     esac\n   done\n   shift $(($OPTIND - 1))\n\n   # Input validation\n   if [ $# -eq 0 ] ; then\n     echo \"Usage: $(basename $0) [-d c] [-t c] number\"\n     echo \"  -d specifies the decimal point delimiter\"\n     echo \"  -t specifies the thousands delimiter\"\n     exit 0\n   fi\n\n➑ nicenumber $1 1    # Second arg forces nicenumber to 'echo' output.\n\n   exit 0\n```", "```\necho \"Do you really want to pay \\$$(nicenumber $price)?\"\n```", "```\n$ nicenumber 5894625\n5,894,625\n$ nicenumber 589462532.433\n589,462,532.433\n$ nicenumber -d, -t. 589462532.433\n589.462.532,433\n```", "```\ninteger=$(echo $1 | cut \"-d$DD\" -f1)         # Left of the decimal\ndecimal=$(echo $1 | cut \"-d$DD\" -f2)         # Right of the decimal\n```", "```\nseparator=\"$(echo $1 | sed 's/[[:digit:]]//g')\"\nif [ ! -z \"$separator\" -a \"$separator\" != \"$DD\" ] ; then\n  echo \"$0: Unknown decimal separator $separator encountered.\" >&2\n  exit 1\nfi\n```", "```\n   #!/bin/bash\n   # validint--Validates integer input, allowing negative integers too\n\n   validint()\n   {\n     # Validate first field and test that value against min value $2 and/or\n     #   max value $3 if they are supplied. If the value isn't within range\n     #   or it's not composed of just digits, fail.\n\n     number=\"$1\";      min=\"$2\";      max=\"$3\"\n\n➊   if [ -z $number ] ; then\n       echo \"You didn't enter anything. Please enter a number.\" >&2\n       return 1\n     fi\n\n     # Is the first character a '-' sign?\n➋   if [ \"${number%${number#?}}\" = \"-\" ] ; then\n       testvalue=\"${number#?}\" # Grab all but the first character to test.\n     else\n       testvalue=\"$number\"\n     fi\n\n     # Create a version of the number that has no digits for testing.\n➌   nodigits=\"$(echo $testvalue | sed 's/[[:digit:]]//g')\"\n\n     # Check for nondigit characters.\n     if [ ! -z $nodigits ] ; then\n       echo \"Invalid number format! Only digits, no commas, spaces, etc.\" >&2\n       return 1\n     fi\n\n➍   if [ ! -z $min ] ; then\n       # Is the input less than the minimum value?\n       if [ \"$number\" -lt \"$min\" ] ; then\n         echo \"Your value is too small: smallest acceptable value is $min.\" >&2\n         return 1\n       fi\n     fi\n     if [ ! -z $max ] ; then\n       # Is the input greater than the maximum value?\n       if [ \"$number\" -gt \"$max\" ] ; then\n         echo \"Your value is too big: largest acceptable value is $max.\" >&2\n         return 1\n       fi\n     fi\n     return 0\n   }\n```", "```\n# Input validation\nif validint \"$1\" \"$2\" \"$3\" ; then\n  echo \"Input is a valid integer within your constraints.\"\nfi\n```", "```\n$ validint 1234.3\nInvalid number format! Only digits, no commas, spaces, etc.\n$ validint 103 1 100\nYour value is too big: largest acceptable value is 100.\n$ validint -17 0 25\nYour value is too small: smallest acceptable value is 0.\n$ validint -17 -20 25\nInput is a valid integer within your constraints.\n```", "```\nif [ \"${number%${number#?}}\" = \"-\" ] ; then\n```", "```\nif [ ! -z $min -a \"$number\" -lt \"$min\" ] ; then\n  echo \"Your value is too small: smallest acceptable value is $min.\" >&2\n  exit 1\nfi\n```", "```\n   #!/bin/bash\n\n   # validfloat--Tests whether a number is a valid floating-point value.\n   #   Note that this script cannot accept scientific (1.304e5) notation.\n\n   # To test whether an entered value is a valid floating-point number,\n   #   we need to split the value into two parts: the integer portion\n   #   and the fractional portion. We test the first part to see whether\n   #   it's a valid integer, and then we test whether the second part is a\n   #   valid >=0 integer. So -30.5 evaluates as valid, but -30.-8 doesn't.\n\n   # To include another shell script as part of this one, use the \".\" source\n   #   notation. Easy enough.\n\n   . validint\n\n   validfloat()\n   {\n     fvalue=\"$1\"\n\n     # Check whether the input number has a decimal point.\n➊   if [ ! -z $(echo $fvalue | sed 's/[^.]//g') ] ; then\n\n       # Extract the part before the decimal point.\n➋     decimalPart=\"$(echo $fvalue | cut -d. -f1)\"\n\n       # Extract the digits after the decimal point.\n➌     fractionalPart=\"${fvalue#*\\.}\"\n\n       # Start by testing the decimal part, which is everything\n       #   to the left of the decimal point.\n\n➍     if [ ! -z $decimalPart ] ; then\n         # \"!\" reverses test logic, so the following is\n         #   \"if NOT a valid integer\"\n         if ! validint \"$decimalPart\" \"\" \"\" ; then\n           return 1\n         fi\n       fi\n\n       # Now let's test the fractional value.\n\n       # To start, you can't have a negative sign after the decimal point\n       #   like 33.-11, so let's test for the '-' sign in the decimal.\n➎     if [ \"${fractionalPart%${fractionalPart#?}}\" = \"-\" ] ; then\n         echo \"Invalid floating-point number: '-' not allowed \\\n           after decimal point.\" >&2\n         return 1\n       fi\n       if [ \"$fractionalPart\" != \"\" ] ; then\n         # If the fractional part is NOT a valid integer...\n         if ! validint \"$fractionalPart\" \"0\" \"\" ; then\n           return 1\n         fi\n       fi\n\n   else\n     # If the entire value is just \"-\", that's not good either.\n➏   if [ \"$fvalue\" = \"-\" ] ; then\n       echo \"Invalid floating-point format.\" >&2\n       return 1\n     fi\n\n     # Finally, check that the remaining digits are actually\n     #   valid as integers.\n     if ! validint \"$fvalue\" \"\" \"\" ; then\n       return 1\n     fi\n   fi\n\n     return 0\n   }\n```", "```\nif validfloat $1 ; then\n  echo \"$1 is a valid floating-point value.\"\nfi\n\nexit 0\n```", "```\n$ validfloat 1234.56\n1234.56 is a valid floating-point value.\n$ validfloat -1234.56\n-1234.56 is a valid floating-point value.\n$ validfloat -.75\n-.75 is a valid floating-point value.\n$ validfloat -11.-12\nInvalid floating-point number: '-' not allowed after decimal point.\n$ validfloat 1.0344e22\nInvalid number format! Only digits, no commas, spaces, etc.\n```", "```\n   #!/bin/bash\n   # valid-date--Validates a date, taking into account leap year rules\n\n   normdate=\"whatever you called the normdate.sh script\"\n\n   exceedsDaysInMonth()\n   {\n     # Given a month name and day number in that month, this function will\n     #   return 0 if the specified day value is less than or equal to the\n     #   max days in the month; 1 otherwise.\n\n➊   case $(echo $1|tr '[:upper:]' '[:lower:]') in\n       jan* ) days=31    ;;  feb* ) days=28    ;;\n       mar* ) days=31    ;;  apr* ) days=30    ;;\n       may* ) days=31    ;;  jun* ) days=30    ;;\n jul* ) days=31    ;;  aug* ) days=31    ;;\n       sep* ) days=30    ;;  oct* ) days=31    ;;\n       nov* ) days=30    ;;  dec* ) days=31    ;;\n          * ) echo \"$0: Unknown month name $1\" >&2\n              exit 1\n     esac\n     if [ $2 -lt 1 -o $2 -gt $days ] ; then\n       return 1\n     else\n       return 0   # The day number is valid.\n     fi\n   }\n\n   isLeapYear()\n   {\n     # This function returns 0 if the specified year is a leap year;\n     #   1 otherwise.\n     # The formula for checking whether a year is a leap year is:\n     #   1\\. Years not divisible by 4 are not leap years.\n     #   2\\. Years divisible by 4 and by 400 are leap years.\n     #   3\\. Years divisible by 4, not divisible by 400, but divisible\n     #      by 100 are not leap years.\n     #   4\\. All other years divisible by 4 are leap years.\n\n     year=$1\n➋   if [ \"$((year % 4))\" -ne 0 ] ; then\n       return 1 # Nope, not a leap year.\n     elif [ \"$((year % 400))\" -eq 0 ] ; then\n       return 0 # Yes, it's a leap year.\n     elif [ \"$((year % 100))\" -eq 0 ] ; then\n       return 1\n     else\n       return 0\n     fi\n   }\n\n   # BEGIN MAIN SCRIPT\n   # =================\n\n   if [ $# -ne 3 ] ; then\n     echo \"Usage: $0 month day year\" >&2\n     echo \"Typical input formats are August 3 1962 and 8 3 1962\" >&2\n     exit 1\n   fi\n\n   # Normalize date and store the return value to check for errors.\n\n➌ newdate=\"$($normdate \"$@\")\"\n\n   if [ $? -eq 1 ] ; then\n     exit 1        # Error condition already reported by normdate\n   fi\n\n   # Split the normalized date format, where\n   #   first word = month, second word = day, third word = year.\n   month=\"$(echo $newdate | cut -d\\  -f1)\"\n   day=\"$(echo $newdate | cut -d\\  -f2)\"\n   year=\"$(echo $newdate | cut -d\\  -f3)\"\n\n   # Now that we have a normalized date, let's check whether the\n   #   day value is legal and valid (e.g., not Jan 36).\n\n   if ! exceedsDaysInMonth $month \"$2\" ; then\n     if [ \"$month\" = \"Feb\" -a \"$2\" -eq \"29\" ] ; then\n       if ! isLeapYear $3 ; then\n➍       echo \"$0: $3 is not a leap year, so Feb doesn't have 29 days.\" >&2\n         exit 1\n       fi\n     else\n       echo \"$0: bad day value: $month doesn't have $2 days.\" >&2\n       exit 1\n     fi\n   fi\n\n   echo \"Valid date: $newdate\"\n\n   exit 0\n```", "```\n$ valid-date august 3 1960\nValid date: Aug 3 1960\n$ valid-date 9 31 2001\nvalid-date: bad day value: Sep doesn't have 31 days.\n$ valid-date feb 29 2004\nValid date: Feb 29 2004\n$ valid-date feb 29 2014\nvalid-date: 2014 is not a leap year, so Feb doesn't have 29 days.\n```", "```\n$ date -d 12/31/1996 +%j\n```", "```\n$ echo -n \"The rain in Spain\"; echo \" falls mainly on the Plain\"\n```", "```\nThe rain in Spain falls mainly on the Plain\n```", "```\n-n The rain in Spain\nfalls mainly on the Plain\n```", "```\nechon()\n{\n  echo \"$*\" | awk '{ printf \"%s\", $0 }'\n}\n```", "```\nechon()\n{\n  printf \"%s\" \"$*\"\n}\n```", "```\nechon()\n{\n  echo \"$*\" | tr -d '\\n'\n}\n```", "```\n$ echon \"Enter coordinates for satellite acquisition: \"\nEnter coordinates for satellite acquisition: 12,34\n```", "```\necho $(( 1 / 2 ))\n```", "```\n   #!/bin/bash\n\n   # scriptbc--Wrapper for 'bc' that returns the result of a calculation\n\n➊ if [\"$1\" = \"-p\" ] ; then\n     precision=$2\n     shift 2\n   else\n➋   precision=2           # Default\n   fi\n\n➌ bc -q -l << EOF\n     scale=$precision\n     $*\n     quit\n   EOF\n\n   exit 0\n```", "```\n$ bc\nbc 1.06.95\nCopyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation,\nInc.\nThis is free software with ABSOLUTELY NO WARRANTY.\nFor details type 'warranty'.\nscale=10\n(2002-1962)*365\n14600\n14600/7\n2085.7142857142\nquit\n```", "```\n$ scriptbc 14600/7\n2085.71\n$ scriptbc -p 10 14600/7\n2085.7142857142\n```", "```\nwhile [ -f $lockfile ] ; do\n  sleep 1\ndone\ntouch $lockfile\n```", "```\n   #!/bin/bash\n\n   # filelock--A flexible file-locking mechanism\n\n   retries=\"10\"            # Default number of retries\n   action=\"lock\"           # Default action\n   nullcmd=\"'which true'\"  # Null command for lockfile\n\n➊ while getopts \"lur:\" opt; do\n     case $opt in\n       l ) action=\"lock\"      ;;\n       u ) action=\"unlock\"    ;;\n       r ) retries=\"$OPTARG\"  ;;\n     esac\n   done\n➋ shift $(($OPTIND - 1))\n\n   if [ $# -eq 0 ] ; then # Output a multiline error message to stdout.\n     cat << EOF >&2\n   Usage: $0 [-l|-u] [-r retries] LOCKFILE\n   Where -l requests a lock (the default), -u requests an unlock, -r X\n   specifies a max number of retries before it fails (default = $retries).\n     EOF\n     exit 1\n   fi\n\n   # Ascertain if we have the lockfile command.\n\n➌ if [ -z \"$(which lockfile | grep -v '^no ')\" ] ; then\n     echo \"$0 failed: 'lockfile' utility not found in PATH.\" >&2\n     exit 1\n   fi\n➍ if [ \"$action\" = \"lock\" ] ; then\n     if ! lockfile -1 -r $retries \"$1\" 2> /dev/null; then\n       echo \"$0: Failed: Couldn't create lockfile in time.\" >&2\n       exit 1\n     fi\n   else    # Action = unlock.\n     if [ ! -f \"$1\" ] ; then\n       echo \"$0: Warning: lockfile $1 doesn't exist to unlock.\" >&2\n       exit 1\n     fi\n     rm -f \"$1\"\n   fi\n\n   exit 0\n```", "```\n$ filelock /tmp/exclusive.lck\n$ ls -l /tmp/exclusive.lck\n-r--r--r--  1 taylor  wheel  1 Mar 21 15:35 /tmp/exclusive.lck\n```", "```\n$ filelock /tmp/exclusive.lck\nfilelock : Failed: Couldn't create lockfile in time.\n```", "```\n$ filelock -u /tmp/exclusive.lck\n```", "```\n#!/bin/bash\n\n# ANSI color--Use these variables to make output in different colors\n#   and formats. Color names that end with 'f' are foreground colors,\n#   and those ending with 'b' are background colors.\n\ninitializeANSI()\n{\n  esc=\"\\033\"   # If this doesn't work, enter an ESC directly.\n\n  # Foreground colors\n  blackf=\"${esc}[30m\";   redf=\"${esc}[31m\";    greenf=\"${esc}[32m\"\n  yellowf=\"${esc}[33m\"   bluef=\"${esc}[34m\";   purplef=\"${esc}[35m\"\n  cyanf=\"${esc}[36m\";    whitef=\"${esc}[37m\"\n\n  # Background colors\n  blackb=\"${esc}[40m\";   redb=\"${esc}[41m\";    greenb=\"${esc}[42m\"\n  yellowb=\"${esc}[43m\"   blueb=\"${esc}[44m\";   purpleb=\"${esc}[45m\"\n  cyanb=\"${esc}[46m\";    whiteb=\"${esc}[47m\"\n\n  # Bold, italic, underline, and inverse style toggles\n  boldon=\"${esc}[1m\";    boldoff=\"${esc}[22m\"\n  italicson=\"${esc}[3m\"; italicsoff=\"${esc}[23m\"\n  ulon=\"${esc}[4m\";      uloff=\"${esc}[24m\"\n  invon=\"${esc}[7m\";     invoff=\"${esc}[27m\"\n\n  reset=\"${esc}[0m\"\n}\n```", "```\n<b>this is in bold and <i>this is italics</i> within the bold</b>\n```", "```\n${boldon}this is in bold and ${italicson}this is\nitalics${italicsoff}within the bold${reset}\n```", "```\ninitializeANSI\n\ncat << EOF\n${yellowf}This is a phrase in yellow${redb} and red${reset}\n${boldon}This is bold${ulon} this is italics${reset} bye-bye\n${italicson}This is italics${italicsoff} and this is not\n${ulon}This is ul${uloff} and this is not\n${invon}This is inv${invoff} and this is not\n${yellowf}${redb}Warning I ${yellowb}${redf}Warning II${reset}\nEOF\n```", "```\nThis is a phrase in yellow and red\nThis is bold this is italics bye-bye\nThis is italics and this is not\nThis is ul and this is not\nThis is inv and this is not\nWarning I Warning II\n```", "```\n\\033[33m\\033[41mWarning!\\033[43m\\033[31mWarning!\\033[0m\n```", "```\n$ echo \"test=2\" >> tinyscript.sh\n$ chmod +x tinyscript.sh\n$ test=1\n$ ./tinyscript.sh\n$ echo $test\n1\n```", "```\n$ . tinyscript.sh\n$ echo $test\n2\n```", "```\n   #!/bin/bash\n\n   # Library test script\n\n   # Start by sourcing (reading in) the library.sh file.\n\n➊ . library.sh\n\n   initializeANSI  # Let's set up all those ANSI escape sequences.\n   # Test validint functionality.\n   echon \"First off, do you have echo in your path? (1=yes, 2=no) \"\n   read answer\n   while ! validint $answer 1 2 ; do\n     echon \"${boldon}Try again${boldoff}. Do you have echo \"\n     echon \"in your path? (1=yes, 2=no) \"\n     read answer\n   done\n\n   # Is the command that checks what's in the path working?\n   if ! checkForCmdInPath \"echo\" ; then\n     echo \"Nope, can't find the echo command.\"\n   else\n     echo \"The echo command is in the PATH.\"\n   fi\n\n   echo \"\"\n   echon \"Enter a year you think might be a leap year: \"\n   read year\n\n   # Test to see if the year specified is between 1 and 9999 by\n   #   using validint with a min and max value.\n   while ! validint $year 1 9999 ; do\n     echon \"Please enter a year in the ${boldon}correct${boldoff} format: \"\n     read year\n   done\n\n   # Now test whether it is indeed a leap year.\n   if isLeapYear $year ; then\n     echo \"${greenf}You're right! $year is a leap year.${reset}\"\n   else\n     echo \"${redf}Nope, that's not a leap year.${reset}\"\n   fi\n\n   exit 0\n```", "```\n$ library-test\nFirst off, do you have echo in your PATH? (1=yes, 2=no) 1\nThe echo command is in the PATH.\n\nEnter a year you think might be a leap year: 432423\nYour value is too big: largest acceptable value is 9999.\nPlease enter a year in the correct format: 432\nYou're right! 432 is a leap year.\n```", "```\n$ bash -x myscript.sh\n```", "```\n$ set -x\n$ ./myscript.sh\n$ set +x\n```", "```\n   #!/bin/bash\n   # hilow--A simple number-guessing game\n\n   biggest=100                   # Maximum number possible\n   guess=0                       # Guessed by player\n   guesses=0                     # Number of guesses made\n➊ number=$(( $$ % $biggest )    # Random number, between 1 and $biggest\n   echo \"Guess a number between 1 and $biggest\"\n\n   while [ \"$guess\" -ne $number ] ; do\n➋   /bin/echo -n \"Guess? \" ; read answer\n     if [ \"$guess\" -lt $number ] ; then\n➌     echo \"... bigger!\"\n     elif [ \"$guess\" -gt $number ] ; then\n➍     echo \"... smaller!\n     fi\n     guesses=$(( $guesses + 1 ))\n   done\n\n   echo \"Right!! Guessed $number in $guesses guesses.\"\n\n   exit 0\n```", "```\n$ echo $(( $$ % 100 ))\n5\n$ echo $(( $$ % 100 ))\n5\n$ echo $(( $$ % 100 ))\n5\n```", "```\n$ hilow\n./013-hilow.sh: line 19: unexpected EOF while looking for matching '\"'\n./013-hilow.sh: line 22: syntax error: unexpected end of file\n```", "```\n$ sed -n 19p hilow\necho \"Right!! Guessed $number in $guesses guesses.\"\n```", "```\n$ grep '\"' 013-hilow.sh | egrep -v '.*\".*\".*'\necho \"... smaller!\n```", "```\n$ hilow\n./013-hilow.sh: line 7: unexpected EOF while looking for matching ')'\n./013-hilow.sh: line 22: syntax error: unexpected end of file\n```", "```\nnumber=$(( $$ % $biggest )          # Random number between 1 and $biggest\n```", "```\n$ hilow\nGuess? 33\n... bigger!\nGuess? 66\n... bigger!\nGuess? 99\n... bigger!\nGuess? 100\n... bigger!\nGuess? ^C\n```", "```\n  /bin/echo -n \"Guess? \" ; read answer\n  if [ \"$guess\" -lt $number ] ; then\n```", "```\n$ hilow\nGuess? 50\n... bigger!\nGuess? 75\n... bigger!\nGuess? 88\n... smaller!\nGuess? 83\n... smaller!\nGuess? 80\n... smaller!\nGuess? 77\n... bigger!\nGuess? 79\nRight!! Guessed 79 in 7 guesses.\n```", "```\nif [ -z \"$guess\" ] ; then\n  echo \"Please enter a number. Use ^C to quit\"; continue;\nfi\n```"]