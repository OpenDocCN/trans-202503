- en: Chapter 10. A Horse of a Different Color
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章：一种不同颜色的马
- en: Utter Panda-monium
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完全的熊猫乱象
- en: The King, the Queen, Ruben, and Scarlet spiraled down staircase after staircase
    toward the Royal Stables. Just when Ruben and Scarlet thought there would be no
    end to the twisty maze of stairs, the Queen reached a huge set of heavy oak doors
    and threw them open. They all ran blinking into the sudden light of the fields
    behind the palace, and only a stone’s throw away stood the entrance to the Royal
    Stables.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 国王、女王、鲁本和斯卡利特一层又一层地绕过楼梯，向皇家马厩走去。就在鲁本和斯卡利特以为这曲折的楼梯永远没有尽头时，女王来到了一扇沉重的橡木大门前，推开了它们。他们全都眯着眼睛跑进了宫殿后方田野的阳光里，离得不远处就是皇家马厩的入口。
- en: “Over here!” said the Queen. “Quickly now!”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “这边！”女王说道。“快点！”
- en: They ran to the front gate of the stables, where two of the Queen’s guards were
    waiting. Each held a very familiar-looking Senior Apprentice to the Royal Plumber
    by the arm.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 他们跑到马厩的前门，那里有两名女王的卫兵在等候。每个卫兵都抓住了一位非常眼熟的皇家水管工高级学徒的胳膊。
- en: '![image with no caption](../Images/httpatomoreillycomsourcenostarchimages2160049.png.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![没有说明的图片](../Images/httpatomoreillycomsourcenostarchimages2160049.png.jpg)'
- en: “Haldo!” gasped Ruben.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: “哈尔多！”鲁本倒吸一口气。
- en: “Now, now,” said the King. “I’m sure there’s a reasonable explanation for all
    this.” Despite his words, the King looked worried. He turned to Haldo. “Haldo,
    what in the name of the Hashery’s glorious breakfast hash is the explanation for
    all this?”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: “好了好了，”国王说道，“我相信这一切一定有合理的解释。”尽管他说着这些话，国王看上去依然很担心。他转向哈尔多。“哈尔多，这一切的解释到底是什么，天晓得你到底做了什么？”
- en: Before Haldo could respond, the Queen approached the guards. “Haldo isn’t who
    I saw in my Royal Office,” she said. “There were four of them, and they were much
    shorter. Please release him.”
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在哈尔多来得及回应之前，女王走近卫兵。“哈尔多不是我在我的皇家办公室里看到的那个人，”她说道。“那时有四个人，他们个头要矮得多。请放开他。”
- en: The guards nodded and dropped Haldo’s arms.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 卫兵们点点头，放开了哈尔多的胳膊。
- en: “Thank you, Your Highness,” Haldo said, brushing himself off.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: “谢谢，殿下，”哈尔多说道，拍了拍自己身上的灰尘。
- en: “Why are you down here at the stables?” asked the King.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: “你为什么在这里的马厩？”国王问道。
- en: “That’s what we were just asking him,” said the guard with the crooked nose.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “这就是我们刚刚问他的，”那位鼻子弯曲的卫兵说道。
- en: “I was trying to explain,” said Haldo. “You see, after searching through the
    Ambrose Caverns and finding nothing, I returned to my work as the Senior Apprentice
    to the Royal Plumber. I’d learned so much from Scarlet and Ruben about Ruby, though,
    that I could do a day’s work in just a few hours. I had a bit of spare time on
    my hands, so I took on the job of Part-Time Apprentice to the Royal Stableman
    as well.”
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “我在试着解释，”哈尔多说道。“你看，经过在安布罗斯洞窟的搜寻却一无所获后，我回到了我的工作，作为皇家水管工的高级学徒。不过，我从斯卡利特和鲁本那里学到了很多Ruby的知识，因此我可以在几个小时内完成一天的工作。于是，我有些空闲时间，就兼任了皇家马夫的兼职学徒。”
- en: “Marvelous,” said the King, visibly relieved that Haldo was not the villain
    they’d been chasing. “A veritable jack-of-all-trades!”
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: “太棒了，”国王显然松了口气，看到哈尔多不是他们一直追的坏人。“真是一个全能的人！”
- en: “I’m not sure I’d go that far,” Haldo said, blushing slightly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: “我不确定我会走那么远，”哈尔多微微脸红地说道。
- en: “Your Majesties,” said the guard without the crooked nose, “we chased a group
    of hooded figures from the Queen’s office, but lost track of them once they got
    out here to the stables. When we saw what had happened, Haldo was the only one
    around. We thought he might be involved, so we called the Queen.” He shrugged.
    “Turns out Haldo had come out to see what the trouble was and try to help.”
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: “陛下们，”那位没有弯曲鼻子的卫兵说道，“我们从女王的办公室追赶一群戴兜帽的人，但一旦他们到达这里的马厩，我们就失去了他们的踪迹。当我们看到发生的事情时，只有哈尔多一个人在附近。我们以为他可能卷入其中，于是我们召唤了女王。”他耸耸肩，“结果是哈尔多出来看看发生了什么事，试图帮忙。”
- en: “One moment,” said the Queen. “When you saw *what* had happened in the stables?”
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: “等一下，”女王说道。“你在马厩看到*什么*事情了？”
- en: The guards exchanged an uneasy look. “You’d better come see,” said the guard
    with the crooked nose.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 卫兵们交换了一个不安的眼神。“你最好来看看，”那位鼻子弯曲的卫兵说道。
- en: The group hurried into the stables. The two guards pointed to the first stall,
    and the King, the Queen, Ruben, and Scarlet peered inside.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一行人匆忙走进马厩。两名卫兵指向第一个马厩，国王、女王、鲁本和斯卡利特探头望了进去。
- en: “Strangest horse I’ve ever seen,” said the King.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: “这是我见过的最奇怪的马，”国王说道。
- en: '![image with no caption](../Images/httpatomoreillycomsourcenostarchimages2160051.png.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![没有说明的图片](../Images/httpatomoreillycomsourcenostarchimages2160051.png.jpg)'
- en: “That . . . is a panda,” said Ruben.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: “那……是一只熊猫，”鲁本说道。
- en: “And it’s red!” moaned the Queen. “Good heavens, what’s happened here?”
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: “而且它是红色的！”女王呻吟道，“天啊，这里发生了什么事？”
- en: “It’s not supposed to be red?” Scarlet asked.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: “不应该是红色吗？”斯卡雷特问。
- en: “Not at all!” said the Queen. “All royal pandas are supposed to be purple!”
    She ran to the next stall, then the next, then the next. “This one’s blue!” she
    cried. “And this one’s yellow! Not a single panda is purple!” She threw up her
    hands. “Whoever heard of a Purple Panda-monium Parade with pandas of every color
    *except* purple?”
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: “一点也不！”女王说，“所有的皇家熊猫应该是紫色的！”她跑到下一个摊位，然后是下一个，再下一个。“这个是蓝色的！”她喊道，“这个是黄色的！一个熊猫都不是紫色的！”她摊开双手，“谁听说过紫色熊猫的狂欢游行，结果熊猫都是*除了*紫色的其他颜色？”
- en: “Wait, the pandas were purple, but now they’re not?” said Ruben. “Aren’t they
    *born* purple?”
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: “等一下，熊猫以前是紫色的，但现在不是了吗？”鲁本说，“它们*天生*就是紫色的吗？”
- en: “And what, exactly, is the Purple Panda-monium Parade?” Scarlet asked.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: “那么，紫色熊猫狂欢游行究竟是什么？”斯卡雷特问。
- en: “One at a time,” said the Queen. She turned to Ruben “No, the pandas aren’t
    born purple. They’re born white, but we feed them special extra-nutritious food
    that turns them purple. As for the parade,” she said to Scarlet, “We hold it once
    a month to celebrate the peace and prosperity of the kingdom. We figure if there’s
    going to be a little craziness in our lives, we should at least be in control
    of it.” She sighed. “Of course, given all the chaos today, we won’t be able to
    hold the parade.”
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: “一个一个来，”女王说。她转向鲁本，“不，熊猫不是天生紫色的。它们一出生是白色的，但我们给它们喂食特殊的营养丰富的食物，才让它们变成紫色的。至于游行，”她对斯卡雷特说，“我们每个月举行一次，庆祝王国的和平与繁荣。我们认为如果我们的生活中有一点疯狂，至少我们应该能掌控它。”她叹了口气，“当然，考虑到今天的混乱，我们是没法举行游行了。”
- en: “Not so fast,” said Scarlet. “I’ll bet we can fix this! It sounds like someone
    must have tampered with the pandas’ food. Where is it?”
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: “别急，”斯卡雷特说，“我敢打赌我们能修好它！听起来像是有人动了熊猫食物的手脚。它在哪里？”
- en: “Over here,” said Haldo. “The food is prepared by the Panda Provisionator 3000.”
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: “在这边，”哈尔多说，“食物是由熊猫供应器3000号准备的。”
- en: They all walked past the rows of stalls to the far side of the stable, where
    a huge round machine covered in dials and switches hummed away. A familiar-looking
    screen glowed in its center.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 他们走过一排排摊位，走到马厩的另一边，那儿有一台巨大的圆形机器，上面布满了刻度盘和开关，正在嗡嗡作响。中间的一个熟悉的屏幕在发光。
- en: '![image with no caption](../Images/httpatomoreillycomsourcenostarchimages2160053.png.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](../Images/httpatomoreillycomsourcenostarchimages2160053.png.jpg)'
- en: “A Computing Contraption!” said Ruben. “Does the Panda Provisionator 3000 run
    on Ruby?”
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: “计算装置！”鲁本说，“熊猫供应器3000号是用Ruby编写的吗？”
- en: “Absolutely,” said Haldo. “Ever since you kids helped me fix the Mysterious
    Pipe, I’ve been learning as much Ruby as I can. I daresay I’ve gotten pretty good,”
    he said, hooking his thumbs behind the straps of his overalls. “I’ve even gotten
    the hang of the Panda Provisionator here.”
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: “绝对是的，”哈尔多说，“自从你们帮我修好了神秘管道之后，我就尽可能多地学习Ruby。我敢说我已经学得相当好了，”他说着，一边把大拇指挂在工装裤的带子上。“我甚至已经掌握了这个熊猫供应器。”
- en: “Could you tell us if someone’s messed with the pandas’ food?” Ruben asked.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: “你能告诉我们有人动过熊猫的食物吗？”鲁本问道。
- en: “And can you fix it?” asked the Queen, looking anxious.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: “那你能修好吗？”女王焦急地问道。
- en: Creating Modules
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模块
- en: '“I think so,” said Haldo. “Let’s have a look.” He opened a file called *colorize.rb*
    on the Computing Contraption, and this is what the group saw:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: “我想是的，”哈尔多说，“我们看看。”他打开了一个名为*colorize.rb*的文件，这时大家看到的内容是：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: “Aha!” said Haldo. “I see the trouble here. Someone’s changed the `color` method
    to return a random color as a symbol—either red, blue, green, or yellow. That’s
    what the `sample` method does,” he explained. “It picks a random item from an
    array.”
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: “啊哈！”哈尔多说，“我看出了问题所在。有人把`color`方法改成了返回一个随机颜色的符号——红色、蓝色、绿色或黄色。这就是`sample`方法的作用，”他解释道，“它从一个数组中挑选一个随机项。”
- en: “That’s why the pandas are all different colors *except* purple!” Ruben said.
    “But wait a minute—there’s nothing about panda food in this file. And what does
    the first line mean?”
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: “这就是为什么熊猫都是不同的颜色，*除了*紫色！”鲁本说，“不过等一下——这个文件里根本没有关于熊猫食物的内容。那第一行是什么意思？”
- en: “That? That means this code is a *module*,” said Haldo, scratching his heavy
    black beard. “You can think of a Ruby module as a bucket of handy information
    and methods that we can use whenever we need it.”
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: “那个？那意味着这段代码是一个*模块*，”哈尔多一边挠着浓密的黑胡子一边说道，“你可以把Ruby模块看作是一个装满了方便的信息和方法的桶，随时可以用到。”
- en: “It looks kind of like a class,” said Scarlet.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: “它看起来像是一个类，”斯卡雷特说。
- en: '“It’s very much like a class!” said Haldo. “Like classes, modules have their
    own methods. In fact, that’s all modules really are: just collections of methods!”'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: “这就像一个类！” Haldo 说。“像类一样，模块有它们自己的方法。事实上，模块其实就是：一组方法的集合！”
- en: “Then what’s the difference between classes and modules?” Ruben asked.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: “那类和模块之间的区别是什么？” Ruben 问。
- en: '“Modules are actually *exactly* like classes, only we can’t make new modules
    with the `new` method,” Haldo explained. “First, let’s do a lightning-quick review
    of classes.” He started up IRB and typed:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: “模块实际上*和*类完全相同，只是我们不能使用`new`方法来创建新的模块，” Haldo 解释道。“首先，我们快速回顾一下类。”他启动了 IRB 并输入了：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: “That just creates a new, empty class called `FancyClass`,” Haldo explained.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: “这只是创建了一个名为`FancyClass`的新空类，” Haldo 解释道。
- en: “What’s that semicolon for?” Scarlet asked.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: “那个分号是做什么用的？” Scarlet 问。
- en: “It’s just a way of telling Ruby you’re done with a line of code,” Haldo said.
    “Normally in IRB you do that by pressing RETURN or ENTER and starting a new line,
    but since our class and module definitions are empty, we can just use the semicolon
    to tell Ruby we’re done with one line and we’re starting a new one.” He shrugged.
    “Some people don’t like to use semicolons. To each her own! Now, let’s create
    an instance of our `FancyClass`.”
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: “这只是告诉 Ruby 一行代码结束了，” Haldo 说。“通常在 IRB 中，你通过按 RETURN 或 ENTER 键开始新的一行来实现，但由于我们的类和模块定义是空的，所以我们可以使用分号告诉
    Ruby 一行代码已经结束，并且我们将开始新的一行。”他耸耸肩。“有些人不喜欢使用分号。每个人有自己的喜好！现在，让我们创建一个`FancyClass`的实例。”
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: “You’ve created instances of classes before, right?” Haldo asked. Scarlet and
    Ruben nodded. “Good!” he said. “Now, let’s create a module and try to create an
    instance of it.”
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: “你们以前创建过类的实例，对吧？” Haldo 问。Scarlet 和 Ruben 点了点头。“很好！”他说。“现在，让我们创建一个模块，尝试创建它的实例。”
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: “Trying to create an instance of a module causes an error because modules don’t
    have the `new` method that classes do,” Haldo said.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: “尝试创建模块的实例会导致错误，因为模块没有像类那样的`new`方法，” Haldo 说。
- en: “So if you can’t create instances of a module,” Ruben said, “what *can* you
    do with it?”
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “所以，如果你不能创建模块的实例，” Ruben 说，“那你*能*用它做什么？”
- en: '“I’ll show you!” said Haldo. “Let’s create a module of our own.” He typed:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: “我来给你们展示！” Haldo 说，“让我们创建一个自己的模块。”他输入了：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: “What’s `MAX_BITS_AND_TRINKETS`,” Scarlet asked, “and why is it in all caps?”
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: “`MAX_BITS_AND_TRINKETS`是什么，” Scarlet 问，“为什么它是全大写的？”
- en: Constants
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量
- en: '“That’s a *constant*,” said Haldo. “Constants are like variables, only their
    values don’t change once you set them. They start with a capital letter—for example,
    class and module names are constants—and while you *technically* can reassign
    them during your Ruby program, Ruby will warn you if you do. See?” He typed:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: “那是一个*常量*，” Haldo 说。“常量像变量，但一旦你设定了它们的值，就不能再改变。它们以大写字母开头——例如，类名和模块名就是常量——虽然你*技术上*可以在
    Ruby 程序中重新赋值给常量，但 Ruby 会警告你这么做。看？”他输入了：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: “When you create your own constant that isn’t a class or module—that is, just
    a name for a value that won’t change—you usually write it in ALL CAPS,” Haldo
    said.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: “当你创建一个不是类或模块的常量时——也就是说，只是一个不会改变的值的名字——你通常会把它写成全大写，” Haldo 说。
- en: “Can you use constants only inside modules?” Ruben asked.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: “常量只能在模块里使用吗？” Ruben 问。
- en: “Nope!” Haldo said. “You can use them anywhere in your Ruby program. I just
    bring them up now because class names and module names are technically constants,
    since they start with a capital letter.”
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: “不行！” Haldo 说，“你可以在 Ruby 程序中的任何地方使用它们。我现在之所以提到它们，是因为类名和模块名在技术上是常量，因为它们以大写字母开头。”
- en: “That’s pretty cool,” said Scarlet, “but how do we get to our ALL CAPS constants
    and methods if they’re stuck inside a module?”
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: “这挺酷的，” Scarlet 说，“但是如果常量和方法都被放在模块里，如何访问它们的全大写形式呢？”
- en: '“I’m glad you asked,” Haldo said, smiling. “Let’s have a look!” He typed some
    more:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: “我很高兴你问了这个问题，” Haldo 说，笑着。“让我们来看一下！”他又输入了一些代码：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: “Here, I’ve made an `Announcer` class that *includes* the `Bucket` module. Our
    `Bucket` module contains a constant, `MAX_BITS_AND_TRINKETS`, which is set to
    `100`, and a method, `announcing_bits_and_trinkets`, that prints some text on
    the screen.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: “在这里，我创建了一个`Announcer`类，它*包含*了`Bucket`模块。我们的`Bucket`模块包含一个常量`MAX_BITS_AND_TRINKETS`，它被设置为`100`，还有一个方法`announcing_bits_and_trinkets`，它会在屏幕上打印一些文字。
- en: When we `include` a module in a class, the constants and methods in that module
    can be used by any instance of the class. Because we’ve included `Bucket` in `Announcer`,
    an `Announcer` can now use any of the constants and methods defined in `Bucket`!
    Let’s create an instance of `Announcer` and see what happens when we use a method
    we defined in `Bucket`.”
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: “当我们在类中`include`一个模块时，模块中的常量和方法可以被该类的任何实例使用。因为我们在`Announcer`中包含了`Bucket`，所以`Announcer`现在可以使用`Bucket`中定义的任何常量和方法！让我们创建一个`Announcer`实例，看看当我们使用`Bucket`中定义的方法时会发生什么。”
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: “Wow!” said Ruben. “`loud_lucy` knows how to use the `announcing_bits_and_trinkets`
    method, even though it’s defined in the `Bucket` module!”
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: “哇！”鲁本说。“`loud_lucy`知道如何使用`announcing_bits_and_trinkets`方法，尽管它在`Bucket`模块中定义！”
- en: Extending Your Knowledge
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拓展你的知识
- en: '“Exactly!” said Haldo. “But `include` isn’t the only way to get constants and
    methods defined in modules into other classes. Have a look at this.” He typed
    some more:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: “完全正确！”哈尔多说。“但`include`并不是唯一一种将模块中定义的常量和方法引入其他类的方法。看看这个。”他又敲了一些代码：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: “If we `extend` the module `Bucket` into the class, then those constants and
    methods can be used by the class itself,” Haldo explained. “In this case, the
    class `Announcer`—instead of its instance, `loud_lucy`—can use the method. You
    usually end up wanting your instances to have the method rather than your classes,
    so in my experience, you tend to `include` more often than you `extend`.”
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: “如果我们将模块`Bucket`通过`extend`引入类，那么这些常量和方法就可以被类本身使用，”哈尔多解释道。“在这种情况下，类`Announcer`——而不是它的实例`loud_lucy`——可以使用该方法。通常情况下，你会希望实例拥有该方法，而不是类，所以根据我的经验，你通常会更常使用`include`而不是`extend`。”
- en: “Remember when I said there was a Ruby trick that lets you mix the behavior
    of several classes into one?” asked the Queen. “This is how you do it!”
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: “记得我说过有一个Ruby技巧，让你可以将多个类的行为混合到一个类中吗？”女王问。“这就是方法！”
- en: Mixins and Inheritance
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mixin与继承
- en: “Wait,” said Ruben. “So you can have a class that inherits from another class
    *and* includes modules to add extra methods?”
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: “等一下，”鲁本说。“所以你可以有一个类继承另一个类*并且*包括模块来添加额外的方法？”
- en: '“See for yourself!” replied Haldo, and he typed:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: “自己看！”哈尔多回答道，然后他敲了几行代码：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: “First, I’ve just created an `Enchanted` module with a single `speak` method.”
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: “首先，我创建了一个包含单一`speak`方法的`Enchanted`模块。”
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: “Next, I’ve created an `Animal` class that takes care of setting the names of
    the `Animal` instances we create.”
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: “接下来，我创建了一个`Animal`类，用来设置我们创建的`Animal`实例的名字。”
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: “In the next step, I’ve created a `Dog` class that inherits from `Animal` and
    includes `Enchanted`. If we’ve done everything right, our `Dog` instances should
    be able to use the `Dog bark` method *and* the `Enchanted speak` method. Let’s
    try it now!”
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: “在下一步中，我创建了一个继承自`Animal`并包含`Enchanted`模块的`Dog`类。如果我们做对了，我们的`Dog`实例应该能同时使用`Dog
    bark`方法*和*`Enchanted speak`方法。现在就试试看！”
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '“When we use a module this way, we call it a *mixin*,” Haldo said, “because
    you’re mixing new constants and methods into an existing class. Basically, `Dog`
    now gets the powers of `Animal` and `Enchanted`, even though it only directly
    inherits from `Animal`. We can `include` as many classes as we like! Assuming
    we defined all these modules somewhere, we could use them all in a row:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: “当我们以这种方式使用模块时，我们称之为*mixin*，”哈尔多说，“因为你将新的常量和方法混合到一个现有的类中。基本上，`Dog`现在拥有了`Animal`和`Enchanted`的功能，尽管它仅直接继承自`Animal`。我们可以`include`任意多个类！假设我们在某个地方定义了所有这些模块，我们可以将它们一一使用：”
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: “So if you had a `Dog` class and the modules `Enchanted`, `Magical`, and `AnythingWeLike`,”
    said the King, “if you were to make a dog with the `Dog` class, that dog could
    use any of the methods defined in `Enchanted`, `Magical`, or `AnythingWeLike`.”
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: “所以如果你有一个`Dog`类和模块`Enchanted`、`Magical`以及`AnythingWeLike`，”国王说，“如果你用`Dog`类创建了一只狗，那只狗就可以使用`Enchanted`、`Magical`或`AnythingWeLike`中定义的任何方法。”
- en: '“Exactly,” Haldo said. “We could also `extend` our class with as many modules
    as we wanted.” He continued typing:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: “完全正确，”哈尔多说。“我们也可以通过`extend`为我们的类引入任意多个模块。”他继续敲打着键盘：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: “That’s amazing!” said Scarlet.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: “太棒了！”斯卡利特说。
- en: “But hang on just a second,” Ruben said. “That means that somewhere on the Computing
    Contraption, there’s a file for the panda food that `include`s the `Colorize`
    module?”
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: “等一下，”鲁本说。“这意味着在计算装置的某个地方，有一个包含`Colorize`模块的熊猫食物文件？”
- en: Requiring Another File
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入另一个文件
- en: “Absolutely correct,” said Haldo. “It happens to be called *panda_food.rb*.
    Take a look!” And he opened the file for them all to see. “This is the code that
    controls the pandas’ food.”
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: “完全正确，”哈尔多说。“它的名字正是 *panda_food.rb*。看一下！”他打开了文件让大家看。“这就是控制熊猫食物的代码。”
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: '*The next few examples are just for you to follow along and read for now—running
    this code as is will cause an error! We’ll run this example ourselves later in
    the chapter.*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*接下来的几个例子只是让你跟着看一看而已——按原样运行这些代码会导致错误！我们会在本章稍后自己运行这个例子。*'
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '“Here’s how it works,” Haldo said. “Let’s pick one of the pandas—Hogarth’s
    my favorite—and see if we can figure out what’s going on with his food.” He opened
    up IRB and typed:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: “它是这么工作的，”哈尔多说。“我们选择一只熊猫——霍戈斯是我最喜欢的——看看我们能不能弄明白它的食物出了什么问题。”他说着，打开了 IRB 并输入：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: “`attr_accessor` gives us access to the `@calories` instance variable, which
    is `1000`,” Haldo explained. “Now let’s take a look at the color!”
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: “`attr_accessor` 让我们访问 `@calories` 实例变量，它的值是 `1000`，”哈尔多解释道。“现在我们来看一下颜色！”
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: “Hmm,” said Haldo. “Can that be right? Let’s try it again.”
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: “嗯，”哈尔多说。“这能对吗？我们再试试。”
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: “There you have it!” Haldo said. “You see? That’s our trouble. Other Ruby programs
    running in the Panda Provisionator 3000 check the color of the panda food when
    they give instructions to the machine to make it, and they’re getting colors like
    yellow and blue, but not purple!”
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: “看到了吧！”哈尔多说。“你看到了吗？这就是我们的麻烦所在。其他在 Panda Provisionator 3000 上运行的 Ruby 程序在给机器指令制作食物时，会检查熊猫食物的颜色，它们得到的是黄色和蓝色，而不是紫色！”
- en: “Then the pandas ate the food and changed color!” said Ruben. “Wow, that must
    happen pretty quickly.”
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: “然后熊猫们吃了食物并变了颜色！”鲁本说。“哇，那应该是很快发生的。”
- en: Haldo nodded. “The pandas were just fed. It actually takes a while for them
    to change from white to any other color, but once they’ve taken on a color, eating
    different-colored food will make their color change instantly.”
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 哈尔多点了点头。“熊猫们刚刚吃了食物。它们从白色变成其他颜色其实需要一些时间，但一旦它们变成了某种颜色，吃不同颜色的食物就会让它们的颜色立即变化。”
- en: “So switching them back should be a piece of cake!” said Scarlet. “We just need
    to change the color back to purple.” She studied the screen for a minute. “Hey
    Haldo,” she said, “what’s this `require` bit do?”
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: “所以把它们换回来应该是小菜一碟！”斯卡雷特说。“我们只需要把颜色改回紫色。”她研究了一会儿屏幕。“嘿，哈尔多，”她说，“这个 `require` 是干什么的？”
- en: “I’m glad you caught that,” said Haldo. “The `require` method pulls in Ruby
    code from a file *outside* the file you’re currently working in! So you don’t
    need it for IRB when you’re just messing around, but if you’ve written out a Ruby
    file, you can use `require` to pull in code from a separate file. You don’t even
    need to type the *.rb* file extension; you just type `require`, then the name
    of your file as a string, and you can use that code immediately.”
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: “我很高兴你注意到了这一点，”哈尔多说。“`require` 方法将 Ruby 代码从你当前工作之外的文件中引入！所以在 IRB 中你只是随便玩玩的时候不需要它，但如果你写了一个
    Ruby 文件，你可以使用 `require` 来引入来自其他文件的代码。你甚至不需要输入 *.rb* 文件扩展名；只要输入 `require`，然后文件名作为字符串，就能立即使用那里的代码。”
- en: 'He created a file called *test_colors.rb* and began typing:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 他创建了一个名为 *test_colors.rb* 的文件，并开始输入：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Haldo closed the file. When he ran it with `ruby test_colors.rb`, this is what
    they saw:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 哈尔多关闭了文件。当他运行 `ruby test_colors.rb` 时，他们看到的是：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: “See?” Haldo said. “We can create our own file called *test_colors.rb*, then
    `require` the *colorize.rb* file inside it ➊. Once we do that, we can create our
    own `TestColors` class ➋, `include` the `Colorize` module from the *colorize.rb*
    file we saw earlier ➌, and then use the `color` method ➍!”
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: “看到了吗？”哈尔多说。“我们可以创建一个名为 *test_colors.rb* 的文件，然后在其中 `require` 我们之前看到的 *colorize.rb*
    文件 ➊。一旦这么做了，我们可以创建自己的 `TestColors` 类 ➋，从 *colorize.rb* 文件中 `include` `Colorize`
    模块 ➌，然后使用 `color` 方法 ➍！”
- en: “Nice!” said Ruben. “But why do we need the `./` in front of `colorize`?”
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: “不错！”鲁本说。“但为什么我们需要在 `colorize` 前加上 `./`？”
- en: “That’s a little complicated,” said Haldo, “but the short answer is that when
    you want to `require` a Ruby file, you need to tell Ruby where to look for it.
    `./` says, ‘Look in this folder right here!’ If we needed to require something
    from a folder *outside* the one we’re in, we’d use *two* dots to tell Ruby to
    go up one folder. This can be confusing,” Haldo finished, “so I drew a couple
    of pictures to help myself remember. I think I still have them!” He rummaged around
    in his pocket for a moment, then pulled out a piece of paper, unfolded it, and
    showed it to the King, the Queen, Scarlet, and Ruben.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: “这有点复杂，”哈尔多说，“不过简短的回答是，当你想要`require`一个Ruby文件时，你需要告诉Ruby去哪儿找它。`./`表示，‘就在这个文件夹里找！’如果我们需要从我们所在的文件夹*之外*的文件夹中引用东西，我们就用*两个*点告诉Ruby上一级文件夹。这可能会让人困惑，”哈尔多接着说，“所以我画了几张图来帮助自己记住。我想我还留着它们！”他在口袋里翻找了一会儿，然后拿出一张纸，展开，展示给国王、女王、斯卡利特和鲁本看。
- en: '![image with no caption](../Images/httpatomoreillycomsourcenostarchimages2160055.png.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](../Images/httpatomoreillycomsourcenostarchimages2160055.png.jpg)'
- en: “I get it!” said Scarlet. “One dot and a slash means ‘look in the current folder,’
    two dots and a slash means ‘go up one folder and look there,’ and anytime we need
    to go into folders within folders, we just use folder names separated by slashes.”
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: “我明白了！”斯卡利特说，“一个点加一个斜杠表示‘在当前文件夹里找’，两个点加一个斜杠表示‘上一级文件夹找’，而每当我们需要进入嵌套文件夹时，我们就用斜杠分隔的文件夹名称。”
- en: “Exactly right,” said Haldo.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: “完全正确，”哈尔多说。
- en: “But is there ever a time when you *don’t* need to use dots or slashes?” she
    asked.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: “但是有没有这种情况，你*不*需要使用点或斜杠？”她问。
- en: “That’s also a bit complicated,” said Haldo, “but the short answer is yes. I
    can show you sometime, but there’s a way to use the Internet to download collections
    of Ruby files other people have written, called *gems*, to use in your own code!”
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: “那也有点复杂，”哈尔多说，“不过简短的答案是，当然可以。我可以找时间给你演示一下，但有一种方法可以使用互联网下载其他人写的Ruby文件集合，这些文件叫做*gems*，你可以在自己的代码中使用！”
- en: “That sounds amazing!” said Scarlet.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: “听起来真棒！”斯卡利特说。
- en: “It is!” said Haldo. “When we get to the bottom of this mystery, I’ll be glad
    to show you.”
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: “确实是！”哈尔多说，“等我们搞清楚这个谜题后，我很乐意给你展示。”
- en: “I think I’ve got a handle on all this,” interrupted the King, “but I’ve been
    wondering about constants since you brought them up. Is including a module in
    a class the only way to get to its constants?”
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: “我想我已经弄明白这一切了，”国王插话道，“但是自从你提到常量，我一直在想，包含一个模块到类中是获取它常量的唯一方法吗？”
- en: Looking Up Constants
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找常量
- en: '“Not at all!” said Haldo. “Take a look.” He quickly typed into the Computing
    Contraption:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: “一点也不！”哈尔多说，“看看这个。”他迅速在计算装置上敲打了几下：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注解
- en: '*These examples will work if you try them out, so go ahead!*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些示例如果你试试就能正常工作，所以赶紧试试吧！*'
- en: “Here, I’ve defined a module called `APocketFullofMethods`,” Haldo said. “Inside
    it, I’ve put a constant, `NUMBER_OF_METHODS`, which equals 42\. You see that if
    I try to get to `NUMBER_OF_METHODS` from outside the module, I get a `NameError`,
    but if I type `APocketFullofMethods::NUMBER_OF_METHODS`, I get `42`!”
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: “这里，我定义了一个名为`APocketFullofMethods`的模块，”哈尔多说，“在其中，我放了一个常量，`NUMBER_OF_METHODS`，它的值是42。你看，如果我从模块外部尝试访问`NUMBER_OF_METHODS`，我会得到一个`NameError`，但是如果我输入`APocketFullofMethods::NUMBER_OF_METHODS`，我就能得到`42`！”
- en: “Wonderful!” said the King.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: “太棒了！”国王说。
- en: “But what are those two colons in a row for?” asked Scarlet.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: “但是那两个连在一起的冒号是干什么的？”斯卡利特问。
- en: “Ah, I’ve seen this before,” said the Queen. “That’s the *scope resolution operator*,
    right, Haldo?”
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: “啊，我以前见过这个，”女王说，“那是*作用域解析操作符*，对吧，哈尔多？”
- en: '“Oh, yes,” said Haldo, “but I find that name a bit confusing. Really, you can
    think of it as a way of looking things up: the four dots look like two little
    sets of eyes. It’s how we specify which module to look in to find something we’ve
    created.”'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: “哦，是的，”哈尔多说，“不过我觉得这个名字有点令人困惑。实际上，你可以把它当作一种查找方法：那四个点看起来像是一双小眼睛。它是我们指定查找哪个模块来找到我们创建的东西的方式。”
- en: “That’s cool!” said Ruben.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: “真酷！”鲁本说。
- en: “Isn’t it?” said Haldo, “Ruby modules are mostly good for two things. The first,
    as I showed you, is mixing new behavior into a Ruby class. The second is called
    *namespacing*. You can think of it as making individual spaces for the things
    you name—mostly methods and constants—to live in.” He pushed his sunglasses up
    on his nose. “You see, if you define a method with a certain name, and then define
    it again, Ruby replaces the old version of the method with the new one. But if
    you put a method inside a module with the same name as a method or constant outside
    the module, you can use them both!”
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: “不是吗？”哈尔多说，“Ruby 模块主要有两个用途。第一个，正如我向你展示的，是将新行为混入到 Ruby 类中。第二个叫做 *命名空间*。你可以把它看作是为你命名的东西——主要是方法和常量——创建独立的空间。”他把太阳镜推到鼻梁上。“你看，如果你定义一个方法，并给它起个名字，然后再定义同名的方法，Ruby
    会用新定义的方法替换旧方法。但如果你把一个同名的方法放进模块里，而模块外面也有一个同名的方法或常量，那你就可以同时使用它们！”
- en: “Modules must create a new scope!” said Ruben. “So having two methods with the
    same name and putting one in a module is like having two identical sodas, only
    one’s in the fridge and the other’s not. With methods, one’s in the module (the
    fridge) and one isn’t, so you know which one’s which based on where it is.”
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: “模块必须创建一个新的作用域！”鲁本说。“所以有两个同名的方法，把一个放在模块里就像是有两瓶相同的汽水，一个在冰箱里，另一个不在。对于方法来说，一个在模块里（冰箱里），另一个不在，所以你可以根据它所在的位置来判断它们的区别。”
- en: “Exactly,” said Haldo.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: “没错，”哈尔多说。
- en: “And everything we just said about methods works for constants, too, right?”
    asked Scarlet.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: “而且我们刚才说的关于方法的内容，对常量也适用吧？”斯卡雷特问道。
- en: “It does!” answered Haldo.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: “它的确能！”哈尔多回答道。
- en: “What happens if you put one module inside another?” asked Ruben.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: “如果把一个模块放到另一个模块里面会发生什么？”鲁本问道。
- en: “You just need to keep using those `::` dots,” said Haldo. “For instance, if
    you had a module `Pastel` inside the `Colorize` module and you wanted to get to
    the `NUMBER_OF_PASTEL_COLORS` constant inside the `Pastel` module, you’d type
    `Colorize::Pastel::NUMBER_OF_PASTEL_COLORS`.”
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: “你只需要继续使用那些 `::` 点，”哈尔多说。“例如，如果你在 `Colorize` 模块里面有一个 `Pastel` 模块，想要访问 `Pastel`
    模块里面的 `NUMBER_OF_PASTEL_COLORS` 常量，你可以写成 `Colorize::Pastel::NUMBER_OF_PASTEL_COLORS`。”
- en: “If things inside a module are namespaced, like you said,” Scarlet asked, “does
    that mean you can have two things with the same name, only one’s inside the module
    and one’s outside?”
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: “如果模块内部的内容都进行了命名空间处理，就像你说的那样，”斯卡雷特问道，“那是否意味着你可以有两个同名的东西，一个在模块里面，另一个在模块外面？”
- en: '“Absolutely!” Haldo said. He typed:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: “完全正确！”哈尔多说道。他打字：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '“Here, I’ve defined two constants with the same name: `GREETING`. The first
    one is inside the `Namespace` module, and the other is in the main scope, outside
    any module. Here’s how we tell Ruby which one to get.” He typed some more:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: “这里，我定义了两个同名的常量：`GREETING`。第一个在 `Namespace` 模块内部，另一个在主作用域中，外面没有任何模块。我们可以通过这种方式告诉
    Ruby 要获取哪一个。”他又打了几行代码：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: “I get it!” said Ruben. “The two colons tell Ruby which scope to use!” He thought
    for a moment. “Can we do all of this for class methods, too? I mean, if a module
    can contain methods created with `def`, can’t it have methods that get added to
    the including class with `self.def`?”
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: “我明白了！”鲁本说。“那两个冒号告诉 Ruby 使用哪个作用域！”他停顿了一下。“我们能不能对类方法也做这些操作？我的意思是，如果一个模块能包含用 `def`
    创建的方法，那它是不是也可以有方法通过 `self.def` 被添加到包含的类中？”
- en: 'Haldo nodded. “You *can* use the scope resolution operator to get class methods
    as well as constants, but in Ruby, we usually get class methods using the dot,
    and constants using the two colons. Since the method is a class method,” he continued,
    “it’s just like calling a method on a regular old object. Remember, classes are
    objects! Here’s an example—we haven’t defined any of these methods, so the code
    won’t run, but it would look something like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 哈尔多点了点头。“你*可以*使用作用域解析运算符来获取类方法和常量，但在 Ruby 中，我们通常用点号获取类方法，用两个冒号获取常量。因为这个方法是类方法，”他继续说道，“它就像是在普通对象上调用一个方法一样。记住，类本身就是对象！这里有个例子——我们并没有定义这些方法，所以代码不会运行，但它看起来大概是这样的：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: “Whew!” said the King, sitting down on a bale of hay. “I think I’ve got all
    this—surprisingly.” Scarlet and Ruben grinned at each other.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: “呼！”国王说着，坐在一捆干草上。“我觉得我已经明白了——竟然如此简单。”斯卡雷特和鲁本相视而笑。
- en: “What I *don’t* understand,” the King continued, “is how these scoundrels broke
    the `Colorize` module so quickly. They were only in the stables for a few seconds!
    How fast do they type?”
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: “我*不*明白的是，”国王继续说道，“这些家伙怎么这么快就破坏了 `Colorize` 模块。他们只在马厩待了几秒钟！他们打字的速度有多快？”
- en: “I think I might have just found the answer,” said the Queen, who had been inspecting
    the Panda Provisionator 3000\. She reached around to the side of the machine and
    pulled out a small bit of scuffed metal.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: “我想我可能刚刚找到了答案，”女王说，她一直在检查熊猫配给机 3000。她伸手到机器的一侧，拉出一块有些磨损的金属片。
- en: “What’s that?” asked Haldo.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: “那是什么？”哈尔多问。
- en: “This,” said the Queen, “is a Key-a-ma-Jigger. It’s a little device you can
    preload code onto. Our mischief-makers must have known something about how the
    Provisionator works and preloaded some code onto this little machine to break
    it. They just had to plug it in and run!”
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: “这个，”女王说，“是一个 Key-a-ma-Jigger。它是一个可以预先加载代码的小设备。我们的捣蛋鬼们一定知道 Provisionator 是如何工作的，并将一些代码预先加载到这个小机器上来破坏它。他们只需要插上去并运行！”
- en: “Sweet corn muffins!” said the King. “We’re up against professionals.”
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: “甜玉米松饼！”国王说，“我们对上了专业人士。”
- en: “I’ll say,” said Ruben, frowning. “How are we going to catch them? They’ve got
    to be a mile away by now.”
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: “我倒是说，”鲁本皱着眉头说，“我们怎么抓住他们？他们现在肯定已经跑了一英里远了。”
- en: The Queen had been studying the Key-a-ma-Jigger, and her mouth curled into a
    small smile. “I think I know that, too,” she said. “Have a look! Key-a-ma-Jiggers
    are sold on little rings of five, and this one still has the ring on it. That
    means this was probably their last one!” She closed her fist around the tiny machine.
    “My guess is that they need more, and there’s only one place in the whole kingdom
    that makes Key-a-ma-Jiggers.”
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 女王一直在研究 Key-a-ma-Jigger，她嘴角微微上扬。“我想我也知道这个，”她说，“看！Key-a-ma-Jigger 是五个一组出售的，而这个上面还挂着一圈，这意味着这很可能是它们的最后一个！”她把那台小机器紧紧握在手中。“我猜它们需要更多，而全王国只有一个地方生产
    Key-a-ma-Jigger。”
- en: “Where?” asked Scarlet, Ruben, and Haldo at the same time.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: “哪里？”斯卡雷特、鲁本和哈尔多同时问道。
- en: “Yes, dear, *where*?” asked the King.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: “是的，亲爱的，*哪里*？”国王问。
- en: “The Refactory!” replied the Queen.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: “重构工厂！”女王回答道。
- en: “The Refactory!” said Haldo. “That’s in the center of the kingdom. The Loop
    can take you there in just a few minutes!”
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: “重构工厂！”哈尔多说，“那个地方在王国的中心，环路可以在几分钟内带你到那里！”
- en: “Let’s go!” said the King. “We’ll take the express straight to the center of
    the kingdom. Let’s catch these poisonous perpetrators purple-handed!”
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: “走吧！”国王说，“我们直接乘快车去王国中心。我们要抓住这些带毒的犯罪分子，现行抓捕！”
- en: “To the Loop!” said the Queen. She turned to Haldo. “Haldo, do you mind staying
    behind and fixing the Provisionator?”
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: “去环路！”女王说。她转向哈尔多，“哈尔多，你介意留下来修好 Provisionator 吗？”
- en: “Not at all, Your Highness,” he said. “It shouldn’t take long.”
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: “一点也不，陛下，”他说，“这应该不需要太久。”
- en: “Thank you,” said the Queen. She turned to the others and said, “Quickly, now!”
    And with that, they ran out of the stables toward the Loop platform on the hill
    next to the palace.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: “谢谢你，”女王说。她转向其他人，说道，“快点，赶快！”说完，她们冲出了马厩，朝着宫殿旁的小山上的环路平台跑去。
- en: A Horse of a Different Color
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一匹不同颜色的马
- en: Now that you know how modules work, you can help Haldo fix up the Panda Provisionator
    and get all the pandas back to the right color! With any luck, you’ll have them
    all fixed up in time for the Purple Panda-monium Parade.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了模块是如何工作的，你可以帮助哈尔多修复熊猫配给机，并让所有的熊猫恢复原来的颜色！如果运气好的话，你将能够及时修好它们，参加紫色熊猫狂潮游行。
- en: 'Let’s begin by making a new file called colorize.rb and typing the following
    code. We’ll actually be making *two* files this time around: one for the module
    and one for the class that includes it.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个新的文件，命名为 colorize.rb，并输入以下代码。实际上，这次我们会创建*两个*文件：一个是模块文件，另一个是包含该模块的类文件。
- en: colorize.rb
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: colorize.rb
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, we set up the `Colorize` module and created a very simple `color` method
    that just returns the color we want (`:purple`).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置了 `Colorize` 模块，并创建了一个非常简单的 `color` 方法，它只返回我们想要的颜色（`:purple`）。
- en: In another file *in the same folder* on your computer, create the panda_food.rb
    file and type the following code into it. It might be a little weird writing two
    files instead of just one, but there’s nothing here you don’t already know how
    to do!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在你电脑的同一个文件夹里，创建一个名为 panda_food.rb 的文件，并在其中输入以下代码。写两个文件而不是一个可能有点奇怪，但这里没有什么是你不知道怎么做的！
- en: panda_food.rb
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: panda_food.rb
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, we `require` *colorize.rb* in our *panda_food.rb* file at ➊. Next, we
    define a very simple `Food` ➋ class that our `PandaFood` class inherits from ➌,
    and we include the `Colorize` module in our `PandaFood` class at ➍. We round it
    all out with a constant to tell us how many calories are in each serving ➎ and
    an `analyze` method to tell us about the food’s calorie content and color ➏. (You
    can’t be too careful when it comes to your food!) Finally, we create an instance
    of `PandaFood` and call the `analyze` method on it ➐.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 *panda_food.rb* 文件的 ➊ 处 `require` 了 *colorize.rb*。接着，我们定义了一个非常简单的 `Food`
    ➋ 类，`PandaFood` 类继承自它 ➌，并且我们在 `PandaFood` 类的 ➍ 处包含了 `Colorize` 模块。最后，我们加上了一个常量来告诉我们每份食物的卡路里数
    ➎，并定义了一个 `analyze` 方法来告诉我们食物的卡路里含量和颜色 ➏。（在对待食物这件事上，你永远不能太小心！）最后，我们创建了 `PandaFood`
    的一个实例并调用了它的 `analyze` 方法 ➐。
- en: 'As always, try running the code in your file by typing **`ruby panda_food.rb`**
    from the command line. Make sure you’re in the same folder as your *panda_food.rb*
    file and type:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，尝试通过命令行输入 **`ruby panda_food.rb`** 来运行你文件中的代码。确保你在与你的 *panda_food.rb*
    文件相同的文件夹中，然后输入：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You should see this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到这个：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Purple panda food! Our pandas are saved!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 紫色的熊猫食物！我们的熊猫得救了！
- en: This should work for Haldo’s purposes nicely, but you can make this code even
    better with a little elbow grease (which you can purchase directly from the Refactory
    for the low, low price of nine ninety-nine ninety-nine ninety-nine ninety-five).
    For example, our `Colorize` module has only one method, and all it does is return
    the color purple. How might we change the `color` method to set whatever color
    we wanted? What other methods might we want to add to `Colorize`?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该能够很好地满足 Haldo 的需求，但你可以通过一点努力让这段代码更好（你可以直接从 Refactory 购买，价格低廉，仅为九十九九九九十九九十九五）。例如，我们的
    `Colorize` 模块只有一个方法，它做的就是返回紫色。我们如何修改 `color` 方法，以便设置任何我们想要的颜色呢？我们还可能想在 `Colorize`
    中添加哪些方法？
- en: 'We also don’t do a whole lot with our `Food` class—`PandaFood` overrides the
    only method `Food` has! What else could we add to `Food` to make it even better?
    (Hint: The possibilities are endless!)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `Food` 类的使用也不多——`PandaFood` 覆盖了 `Food` 唯一的一个方法！我们还能在 `Food` 中添加什么内容来让它变得更好呢？（提示：可能性是无穷无尽的！）
- en: 'Finally, remember the code Haldo saw in [Creating Modules](../Text/ch10.html#creating_modules
    "Creating Modules") that had been tampered with? It looked like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，记住 Haldo 在 [创建模块](../Text/ch10.html#creating_modules "创建模块") 中看到的被篡改过的代码吗？它是这样的：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you’re feeling adventurous, try changing the code in your *colorize.rb* file
    to this code and then rerun **`ruby panda_food.rb`**. See how the color changes
    each time, just like our heroes saw?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有冒险精神，试试把 *colorize.rb* 文件中的代码改成这个，然后重新运行 **`ruby panda_food.rb`**。看看每次颜色是如何变化的，就像我们的英雄们看到的那样？
- en: You Know This!
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你知道这个！
- en: I can tell you’ve got a great grasp on all this module business. (I’m an excellent
    judge of many a character.) Let’s go over it one more time, though, just to make
    sure *I* know it. Haldo did a lot of explaining and I didn’t do any, so I want
    to be sure this is all sealed up tight in my noggin.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我能看出你对这个模块的操作非常熟练。（我是一个非常出色的性格判断者。）不过，为了确保*我*也能掌握这一点，我们再复习一遍。Haldo 解释了很多，而我没做什么解释，所以我想确保这一切都已经牢牢地记在我的脑袋里。
- en: 'First, we learned about modules and how they’re basically just like classes,
    except you can’t create instances of them with the `new` method. We saw that we
    could use modules as *namespaces*, which is just a fancy way of saying they let
    us organize our code nicely, like so:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们学习了模块，了解它们基本上就像类一样，只是你不能使用 `new` 方法来创建它们的实例。我们看到，我们可以将模块作为 *命名空间* 使用，这只是一种高级说法，意思是它们让我们能够像这样优雅地组织代码：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We also learned about *constants* (like `MAX_BITS_AND_TRINKETS`), which are
    just like Ruby variables, only their values aren’t supposed to change. (You *can*
    change them, but Ruby will issue a stern warning.) Constants are always CAPITALIZED.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了 *常量*（如 `MAX_BITS_AND_TRINKETS`），它们与 Ruby 变量类似，只是它们的值应该是不变的。（你*可以*修改它们，但
    Ruby 会发出严厉的警告。）常量总是用大写字母表示。
- en: 'We saw that we could also use modules as *mixins* by using `include` or `extend`.
    When we use `include`, it adds all the methods in the module to instances of whatever
    class is doing the including; when we use `extend`, those module methods are added
    to the class itself:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了，可以通过使用 `include` 或 `extend` 来将模块作为 *混入* 使用。当我们使用 `include` 时，它会将模块中的所有方法添加到包括它的类的实例中；当我们使用
    `extend` 时，这些模块方法会被添加到类本身：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There, we’ve just created a `Greetings` module with a few methods. Next, we’ll
    create a `Message` class and include the `Greetings` module:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们刚刚创建了一个包含几个方法的`Greetings`模块。接下来，我们将创建一个`Message`类，并包含`Greetings`模块：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Then we’ll see that any instance of `Message` can use the methods defined in
    `Greetings`!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们会看到，任何`Message`的实例都可以使用`Greetings`中定义的方法！
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we `extend Message` with `Greetings` instead, then the `Greetings` methods
    can be used by the `Message` class itself:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改用`extend Message`与`Greetings`，那么`Greetings`的方法将可以被`Message`类本身使用：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Remember, it’s the `Message` class *itself* that now has the `robot` method,
    not an instance of `Message`! If we try to create an instance of `Message` and
    call the `robot` method on it, we’ll get an error:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，现在拥有`robot`方法的是`Message`类*本身*，而不是`Message`的实例！如果我们尝试创建`Message`的实例并调用它的`robot`方法，就会报错：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'But if a class *includes* `Greetings`, then instances of that class have the
    method instead:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果一个类*包含*了`Greetings`模块，那么该类的实例就会拥有该方法：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'By including modules into classes that already inherit from other classes,
    we can get all the benefits of inheriting from multiple classes with the simplicity
    of having just one superclass:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将模块包含进已经继承自其他类的类中，我们可以在保持只有一个父类的简洁性的同时，享受从多个类继承的所有好处：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There, we’ve got our `Enchanted` module again with its tried-and-true `speak`
    method.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次创建了我们的`Enchanted`模块，并包含了它那经过验证的`speak`方法。
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We’ve seen this before: we just define an `Animal` class and a `Dog` class
    that inherits from it. `Dog` has one method: `bark`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到过这个例子：我们只需定义一个`Animal`类和一个继承自它的`Dog`类。`Dog`类有一个方法：`bark`。
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, we see that `Dog` instances like `bigelow` can use `bark` (which it
    got from `Dog`) and `speak` (which it got from `Enchanted`)!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到`Dog`类的实例，例如`bigelow`，可以使用`bark`（它从`Dog`继承而来）和`speak`（它从`Enchanted`继承而来）！
- en: 'This is all fine and dandy when our modules and classes are in the same file,
    but what happens when they’re not? That’s right: we can use `require`! To pull
    a file we wrote into another file, we just use the `require` method and give it
    a string with the name of the file we want (no *.rb* file extension necessary).
    Remember, we need to use dots and slashes to tell Ruby where to look: `./` means
    “look in the current folder” and `../` means “go outside the current folder and
    look around.” If we want to go *two* folders up, we’d use `../../`; if we wanted
    to get at a file called *genius_idea_3.rb* in the current folder but nested inside
    the folders *fancy_things* and *genius_ideas*, we’d type `./fancy_things/genius_ideas/genius_idea_3`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的模块和类都在同一个文件中时，这一切都很顺利，但如果它们不在同一个文件呢？没错：我们可以使用`require`！为了将我们写的一个文件导入到另一个文件中，我们只需使用`require`方法，并提供一个字符串，指明我们想要的文件名（不需要*.rb*扩展名）。记住，我们需要使用点和斜杠来告诉Ruby去哪里查找：`./`表示“在当前文件夹中查找”，而`../`表示“跳出当前文件夹并四处查找”。如果我们想向上跳*两个*文件夹，可以使用`../../`；如果我们想访问当前文件夹中但嵌套在*
    fancy_things*和*genius_ideas*文件夹中的*genius_idea_3.rb*文件，我们就写`./fancy_things/genius_ideas/genius_idea_3`。
- en: 'So for example, if we had *colorize.rb* in the same folder as the following
    Ruby script, we’d write it like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所以举个例子，如果我们将*colorize.rb*与下面的Ruby脚本放在同一个文件夹中，我们会这样写：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, you saw that we could use the *scope resolution operator* to get at
    particular constants located in modules (even deeply nested ones!), and we can
    simply use the dot syntax we’re used to for getting ahold of class methods:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你看到我们可以使用*作用域解析运算符*来访问模块中的特定常量（甚至是深层嵌套的常量！），而且我们可以像往常一样使用点语法来获取类方法：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With that, you now officially know everything there is to know about Ruby classes
    and modules! (Okay, okay, there’s always more to learn, but you know all the stuff
    you’d use to write everyday Ruby programs.) You know so much Ruby, in fact, that
    we’re going to take a short break from learning new stuff to focus on *re*writing
    some of the code we already know. Rewriting your code so it still does the same
    thing but looks nicer or runs faster is called *refactoring*, and—as luck would
    have it!—that’s exactly what the Refactory is all about.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，你现在已经正式掌握了关于Ruby类和模块的所有知识！（好吧，好吧，总是有更多可以学习的，但你已经知道了写日常Ruby程序所需的所有内容。）事实上，你已经学会了这么多Ruby，以至于我们现在要从学习新东西中短暂休息一下，集中精力*重*写一些我们已经知道的代码。重写代码，目的是让它做相同的事情，但看起来更好或运行得更快，这叫做*重构*，而——幸运的是！——这正是Refactory的核心内容。
