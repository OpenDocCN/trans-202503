- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decision and Control Statements
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: A computer is a powerful instrument because it can make decisions based on the
    data it receives. For example, a computer can turn on an LED if a button is being
    pressed and turn off the LED if it isn’t. In this chapter we will see how C’s
    various decision and control statements operate. Then we’ll apply them to embedded
    programming by making our device respond to button presses.
  prefs: []
  type: TYPE_NORMAL
- en: The if Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the `if` statement to execute some code only if some condition is true.
    Here is the general form of this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To conditionally execute more than one statement, enclose the set of statements
    affected by the condition inside curly brackets (`{}`), as shown next. C will
    treat the set of statements as a single block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: C considers anything nonzero as true and zero as false. Therefore, if the condition
    is nonzero, the statements will execute. If the condition is zero, they will not.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 5-1](#table5-1) lists the other comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5-1: The Comparison Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | Equals |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | Less than |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | Less than or equal |'
  prefs: []
  type: TYPE_TB
- en: '| `!=` | Not equals |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | Greater than |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | Greater than or equal |'
  prefs: []
  type: TYPE_TB
- en: 'For example, if you wanted some code to execute only if a variable had a value
    of 5, you could use the equals (`==`) operator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A word of warning: C allows assignment inside conditionals. For example, the
    following code, which assigns a variable a value of 7 within the `if` statement,
    is legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the equivalent of the following code, which tests whether the variable
    is equal to zero after the assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It is *not* the same as the following condition, which tests whether a variable
    is equal to 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This problem was a nasty one in the early days of C when compiler technology
    was not what it is today. You’d make a mistake by accidentally writing something
    like the following code, only much more complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The code within the `if` statement would be executed, as the variable would
    be reassigned a value of 7, which as a nonzero value would immediately make the
    condition true, even though you intended `aNumber` to be 5, not 7\. With the modern
    GCC compiler, assignment in a condition generates a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, GCC is telling you that if you want to suppress the warning because you
    really want to combine an assignment statement and an `if` statement, you should
    write the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I’ve added the comment because I consider it poor programming practice to combine
    statements. Make one statement do one thing. For example, when you need to do
    an assignment and a test, do the assignment and then do the test.
  prefs: []
  type: TYPE_NORMAL
- en: The if/else Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the `if`/`else` statement when we want to make some statements execute
    if the condition is true and other statements execute when it is false. For example,
    consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the value of the `number` variable has a remainder of 0 when divided by 2,
    this code will print a message noting that the number is even; otherwise, it will
    print a message noting that the number is odd.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we come to another of C’s darker little corners: you don’t have to put
    curly brackets (`{}`) around a single statement after an `if` or an `else`. Consider
    the following code, deliberately indented incorrectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Which `if` does the `else` go with, the first `if` or the second `if`?
  prefs: []
  type: TYPE_NORMAL
- en: 'a. The first `if`: `if (a == 1)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'b. The second `if`: `if (b == 2)`'
  prefs: []
  type: TYPE_NORMAL
- en: c. If you don’t write code like this, you don’t have to worry about such silly
    questions.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use answer C and rewrite the code. Which `if` does the `else` go with
    in the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can tell it goes with the second `if`. That’s the “official” answer
    to the previous question too, but by writing your code clearly, you can come up
    with the answer without having to go through the C language standard with a fine-tooth
    comb.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that some style guides require that you always put the body
    of the `if` inside curly brackets; however, this is a decision best left up to
    the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Looping Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *loop* is a programming feature that repeats some code as long as a condition
    is met. C has three looping statements: `while`, `for`, and `do/while`. We’ll
    start with `while`, since it’s the simplest, followed by `for`. We won’t get into
    `do/while` because it’s rarely used.'
  prefs: []
  type: TYPE_NORMAL
- en: The while Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The general form of the `while` statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `statement` can be a single C statement or a series of statements
    enclosed in `{}`. To see how a `while` loop can be useful, let’s write a program
    that tests the numbers from 1 to 10 to see which ones are even and which ones
    are odd, as shown in [Listing 5-1](#listing5-1).
  prefs: []
  type: TYPE_NORMAL
- en: '***odd.c***'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-1: Testing for oddness'
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, we declare a variable, `aNumber`, to hold the value
    we’ll test in our `while` loop. Then we set that variable to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the `while` loop to run as long as `aNumber` is less than or equal
    to 10\. Inside the loop (that is, inside the brackets) we use the `if`/`else`
    statement introduced in the previous section of this chapter to check the remainder
    of dividing `aNumber` by 2\. This lets us know whether it’s even or odd.
  prefs: []
  type: TYPE_NORMAL
- en: Before we finish the loop, we add 1 to `aNumber` with `++aNumber;`. Thus, the
    next time the loop runs, `aNumber` will have a value of 2, and so on. Eventually,
    when `aNumber`’s value reaches 11, the loop ends and the program exits with the
    return value `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this program runs, the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The for Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our `while` loop had three main components: an initialization statement (`aNumber
    = 1`), a test statement (checking whether `aNumber` is greater or equal to 10),
    and a statement to increment the variable after the loop was executed (`++aNumber`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This design pattern (initialization, condition, and increment) is so common
    it has its own statement: the `for` statement. We write this statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To see how it works, let’s convert our `while` loop into a `for` loop. The
    following code shows the same odd-or-even program using a `for` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `for` clause includes our three statements, separated by semicolons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any one of the statements may be left out of the `for` loop. For example, we
    could have written our program by initializing `aNumber` before entering the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could increment the variable’s value within the loop’s body,
    rather than in the `for` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If the condition is left out, however, the loop will never terminate. This
    is why the following statement loops forever:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We use this “for-ever” loop in our embedded programs, because the programs should
    never exit.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know how to make decisions, we’ll write a program that makes a
    decision based on the one input source our development board has by default: a
    blue button. Our program will make use of the one output we know how to control:
    the LED. Let’s turn our development board into a tiny computerized lamp.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start System Workbench for STM32 and begin a new embedded project. The *main.c*
    file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over this code in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To begin our program, we’ll make use of a lot of code that is defined by the
    hardware abstraction layer (HAL). In the next few chapters, you’ll learn about
    every one of these pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a new variable named `GPIO_LedInit` of type `GPIO_InitTypeDef`
    1. The `GPIO_InitTypeDef` type is not a standard C type: it’s defined by the HAL
    include files brought in at the top of the program. At this point, the details
    of this type don’t matter. We need the variable to define how the LED pin is going
    to be configured. (You’ll learn about defining variable types in later chapters.)'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we define another variable, `GPIO_ButtonInit`, to define how the
    button GPIO pin is going to be configured, and a variable to hold the state of
    the button pin (`GPIO_PinState`).
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `main` procedure, the first thing we do is call `HAL_Init` to set
    up the hardware, as we did in the blink program from Chapter 3. You need to call
    `HAL_Init` at the top of every STM32 program.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we turn on the clock for `LED2` (the user LED) 2. The *clock* controls
    how the data we write to the GPIO pin gets to the actual pin. Without this line,
    writing to the LED doesn’t work. Although it looks like a procedure call to a
    function named `LED2_GPIO_CLK_ENABLE`, it’s actually a preprocessor macro, which
    we will study later.
  prefs: []
  type: TYPE_NORMAL
- en: Now we come to the part where we assign values to the `GPIO_LedInit` variable
    3, which is a structure type that has a bunch of pieces we need to assign individually.
    Later, you will learn the details of what’s going on here.
  prefs: []
  type: TYPE_NORMAL
- en: Similar code initializes the pin used for the button, except that the pin mode
    is set to `GPIO_MODE_INPUT` because we’ll be reading the pin to get the state
    of the button, not writing it.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a Pulldown Circuit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that we set the `Pull` field to `GPIO_PULLDOWN` 4, not `GPIO_PULLUP`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Pull` field tells the CPU what type of pullup/pulldown circuity to use.
    An input pin can have one of three states: floating, pullup, and pulldown. [Figure
    5-1](#figure5-1) shows the circuit for a *floating* input.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f05001](image_fi/501621c05/f05001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: A floating circuit'
  prefs: []
  type: TYPE_NORMAL
- en: When the switch SW1 is open, no voltage is applied to the `User_Button_Pin`.
    As such, it could be high (about 3 volts or more) or low (less than about 3 volts)
    or somewhere in between. It could be set by whatever stray electrical noise is
    floating around near it. The key here is that there is no way to know the value
    of this signal unless it’s actually shorted to ground or power.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s take a look at an input with a *pullup* circuit (see [Figure 5-2](#figure5-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05002](image_fi/501621c05/f05002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: A pullup circuit'
  prefs: []
  type: TYPE_NORMAL
- en: When SW1 is open, voltage flows though the resistor R1, raising (or *pulling
    up*) the `User_Button_Pin` to VCC, or a positive level. When SW1 is closed, the
    pin is shorted to ground (Gnd). R1 is a very big resistor, so the current flowing
    through it is negligible and the voltage on the pin goes to zero.
  prefs: []
  type: TYPE_NORMAL
- en: A *pulldown* circuit is similar, except R1 is connected to ground, and SW1 to
    VCC, so the `User_Button_Pin` goes to ground (that is, it’s pulled down to zero)
    if SW1 is open (see [Figure 5-3](#figure5-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05003](image_fi/501621c05/f05003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-3: A pulldown circuit'
  prefs: []
  type: TYPE_NORMAL
- en: On the STM32 chip, circuits are cheap and pins are expensive. Therefore, the
    chip’s creators wanted to get as much out of each pin as possible. For every GPIO
    pin, there is a pullup resistor, a pulldown resistor, and the transistors to connect
    these resistors, depending on how the pin may be configured. This makes things
    easy, as we don’t have to put these resistors on the board ourselves. It also
    makes things difficult, however, because we have to program them. [Figure 5-4](#figure5-4)
    shows the internal wiring of a single GPIO pin on the STM32\. (Even this is a
    simplified version.) The key thing to note is that there are pullup (R[PU]) and
    pulldown (R[PD]) internal resistors that can be turned on and off.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05004](image_fi/501621c05/f05004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-4: STM32 internal wiring for a GPIO pin'
  prefs: []
  type: TYPE_NORMAL
- en: We chose to use a pulldown circuit because the other side of the button is connected
    to +5 V, so when the button is not pressed and the switch is open, our pulldown
    resistor kicks in and the GPIO pin has a value of 0\. When the button is pressed,
    the 5 V coming from the button cause the GPIO pin to have a value of 1\. (A little
    current will also flow through the resistor, but that amount of current is negligible.)
  prefs: []
  type: TYPE_NORMAL
- en: Getting the State of the Button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we reach our main loop. The `for` statement loops forever, or until we
    reset the machine. Inside the loop, the first statement initializes a variable
    called `result` of type `GPIO_PinState` (a nonstandard type defined by the HAL
    include files) with the result of a call to the function `HAL_GPIO_ReadPin`. `HAL_GPIO_ReadPin`
    reads the GPIO pin connected to the button. More specifically, it reads the 32-bit
    GPIO port `USER_BUTTON_GPIO_PORT` and then tests the value of the `USER_BUTTON_PIN`.
    (A lot of the bit manipulation we covered in the previous chapter goes on inside
    the `HAL_GPIO_ReadPin` function.)
  prefs: []
  type: TYPE_NORMAL
- en: Now we test to see if the pin is set by comparing `result` to the symbol `GPIO_PIN_SET`
    (a constant defined by the HAL code), and then we turn on the LED pin if the button
    pin is set. Otherwise, we turn off the LED pin. (The code to do this was covered
    in Chapter 3.)
  prefs: []
  type: TYPE_NORMAL
- en: Running the Program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we run the program, the LED turns on. Press the user button and the LED
    turns off. Release the button and the LED will come back on, and so on. Although
    a simple operation, it took a lot of learning to get us here.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we’ve made a very complex flashlight with a button that turns
    the light off instead of on. The good news is that it’s computer-controlled, so
    we can fix it in software. I’m going to leave that for you to figure out.
  prefs: []
  type: TYPE_NORMAL
- en: Loop Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our programming example made basic use of looping statements, but C gives you
    several ways of adding extra control to your loops. The two major statements that
    modify the loop control are `break` and `continue`.
  prefs: []
  type: TYPE_NORMAL
- en: The break Statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `break` statement allows you to exit a loop early (that is, break out of
    the loop). For example, consider the following short program, which looks through
    an array for a key number. If the number is there, the program prints it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This program searches an array for a key value. Once we find the key value,
    we’re done. We don’t want to go through the entire rest of the loop, so to exit,
    we use the `break` statement 1.
  prefs: []
  type: TYPE_NORMAL
- en: The continue Statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The other loop control statement, `continue`, starts execution at the top of
    the loop. The following program prints a list of commands, skipping those that
    start with a dot. When we encounter one of these, we jump to the top of the loop
    with the `continue` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The key to this program is the test to see if we have a dot command 1 and then
    `continue` 2 to start over (thus skipping the rest of the loop and the `printf`).
  prefs: []
  type: TYPE_NORMAL
- en: Anti-patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While you’re learning how to use loops, you should also learn how *not* to use
    loops. Several programming patterns have crept into the programming industry that
    do more to confuse things than promote good programming, which is why they’re
    called *anti-patterns*. I’m going to warn you about two.
  prefs: []
  type: TYPE_NORMAL
- en: The Empty while Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first anti-pattern is the empty `while` loop. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You probably gather that this code repeats some action as long as the user
    button is pressed. But it doesn’t. The reason it doesn’t is that the `while` loop
    affects a single statement only. You might assume that the statement within the
    `while` loop is the one enclosed in curly brackets, but there is a statement before
    the brackets too. It’s a very short statement and very easy to miss, because it’s
    an empty statement. We can tell it’s there because there is a semicolon after
    the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The semicolon is easy to overlook. That’s why I had to set it in boldface. It’s
    also why this type of coding is considered bad. Very bad.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `continue` statement comes to our rescue. We can rewrite this `while` loop
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now we can see that the `while` loop controls the `continue` statement and nothing
    else. The indentation and the big obvious statement tell us that.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment in while
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second anti-pattern is assignment in the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This statement does two things at once. First, it calls `ReadPin` and assigns
    the result to `result`. Second, it tests `result` to see if it is set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programs are much easier to understand and maintain if they do small, simple
    things one at a time. This shortcut saves typing a couple of newlines at the cost
    of program clarity. It could just as easily have been written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Our goal should be to make our programs as simple and easy to read as possible,
    not as compact and clever as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have two key aspects of computing under our belt: numbers and how to
    make decisions based on those numbers. Single decisions can be made with the `if`
    statement, while the `while` and `for` statements let us make repeating decisions.
    The `break` and `continue` keywords give us more control over those decisions.'
  prefs: []
  type: TYPE_NORMAL
- en: Decision statements gave us the ability to write a small program that flashes
    the LED at the touch of a button. Although the program is simple, we took input,
    processed it, and produced output, which is the basis for a huge number of embedded
    programs. In the next few chapters, you’ll learn how to deal with more complex
    data and more complex ways of processing it, all of which builds on the basics
    you learned here.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a program to produce a multiplication table for the numbers from 0 × 0
    to 9 × 9.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to count the number of bits that are set in a `uint32_t` integer.
    For example, the number 0x0000A0 has two bits set in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that flashes a pattern on the LED. Use one array of integers
    to control the delay for LED on and LED off. Repeat the pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that blinks the letter “H” in Morse code using the LED. When
    the button is pressed, it blinks “E.” If you keep pressing the button, you’ll
    get all of “HELLO WORLD” in Morse code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to compute the first 10 primes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to find the largest and smallest elements in a set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a program that goes through a string and prints only the vowels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
