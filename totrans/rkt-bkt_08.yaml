- en: '**6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6'
- en: BOOT PROCESS SECURITY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 引导过程安全**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'In this chapter we’ll look at two important security mechanisms implemented
    in the Microsoft Windows kernel: the Early Launch Anti-Malware (ELAM) module,
    introduced in Windows 8, and the Kernel-Mode Code Signing Policy, introduced in
    Windows Vista. Both mechanisms were designed to prevent the execution of unauthorized
    code in the kernel address space, in order to make it harder for rootkits to compromise
    a system. We’ll look at how these mechanisms are implemented, discuss their advantages
    and weak points, and examine their effectiveness against rootkits and bootkits.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍Microsoft Windows内核中实现的两个重要安全机制：Windows 8中引入的早期启动反恶意软件（ELAM）模块，以及Windows
    Vista中引入的内核模式代码签名策略。这两种机制旨在防止未经授权的代码在内核地址空间中执行，从而使得rootkit更难以危害系统。我们将探讨这些机制的实现方式，讨论它们的优点和弱点，并检视它们在防御rootkit和bootkit方面的有效性。
- en: '**The Early Launch Anti-Malware Module**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**早期启动反恶意软件模块**'
- en: The Early Launch Anti-Malware (ELAM) module is a detection mechanism for Windows
    systems that allows third-party security software, such as antivirus software,
    to register a kernel-mode driver that is guaranteed to execute very early in the
    boot process, before any other third-party driver is loaded. Thus, when an attacker
    attempts to load a malicious component into the Windows kernel address space,
    the security software can inspect and prevent that malicious driver from loading
    since the ELAM driver is already active.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 早期启动反恶意软件（ELAM）模块是一个用于Windows系统的检测机制，允许第三方安全软件（如防病毒软件）注册一个内核模式驱动程序，该驱动程序在引导过程中非常早期执行，且在任何其他第三方驱动程序加载之前执行。因此，当攻击者试图将恶意组件加载到Windows内核地址空间时，安全软件可以检查并防止该恶意驱动程序加载，因为ELAM驱动程序已经处于活动状态。
- en: '***API Callback Routines***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***API回调例程***'
- en: The ELAM driver registers *callback* routines that the kernel uses to evaluate
    data in the system registry hive and boot-start drivers. These callbacks detect
    malicious data and modules and prevent them from being loaded and initialized
    by Windows.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ELAM驱动程序注册*回调*例程，内核使用这些回调例程评估系统注册表集群和引导启动驱动程序中的数据。这些回调可以检测恶意数据和模块，并防止它们被Windows加载和初始化。
- en: 'The Windows kernel registers and unregisters these callbacks by implementing
    the following API routines:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Windows内核通过实现以下API例程来注册和注销这些回调：
- en: CmRegisterCallbackEx **and** CmUnRegisterCallback Register and unregister callbacks
    for monitoring registry data
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: CmRegisterCallbackEx **和** CmUnRegisterCallback 用于注册和注销回调以监控注册表数据
- en: IoRegisterBootDriverCallback **and** IoUnRegisterBootDriverCallback Register
    and unregister callbacks for boot-start drivers
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: IoRegisterBootDriverCallback **和** IoUnRegisterBootDriverCallback 用于注册和注销引导启动驱动程序的回调
- en: These callback routines use the prototype `EX_CALLBACK_FUNCTION`, shown in [Listing
    6-1](ch06.xhtml#ch06list01).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些回调例程使用原型`EX_CALLBACK_FUNCTION`，如[清单6-1](ch06.xhtml#ch06list01)所示。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 6-1: Prototype of ELAM callbacks*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-1：ELAM回调的原型*'
- en: 'The parameter `CallbackContext` ➊ receives a context from the ELAM driver once
    the driver has executed one of the aforementioned callback routines to register
    a callback. The *context* is a pointer to a memory buffer holding ELAM driver–specific
    parameters that may be accessed by any of the callback routines. This context
    is a pointer that’s also used to store the current state of the ELAM driver. The
    argument at ➋ provides the callback type, which may be either of the following
    for the boot-start drivers:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`CallbackContext` ➊ 在驱动程序执行上述回调例程之一以注册回调后，接收来自ELAM驱动程序的上下文。*上下文*是指向内存缓冲区的指针，该缓冲区包含特定于ELAM驱动程序的参数，这些参数可以被任何回调例程访问。此上下文是一个指针，且也用于存储ELAM驱动程序的当前状态。➋处的参数提供了回调类型，对于引导启动驱动程序，回调类型可以是以下之一：
- en: BdCbStatusUpdate Provides status updates to an ELAM driver regarding the loading
    of driver dependencies or boot-start drivers
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: BdCbStatusUpdate 向ELAM驱动程序提供有关驱动程序依赖关系或引导启动驱动程序加载的状态更新
- en: BdCbInitializeImage Used by the ELAM driver to classify boot-start drivers and
    their dependencies
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: BdCbInitializeImage ELAM驱动程序用于分类引导启动驱动程序及其依赖关系
- en: '**Classification of Boot-Start Drivers**'
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**引导启动驱动程序分类**'
- en: The argument at ➌ provides information that the operating system uses to classify
    the boot-start driver as *known good* (drivers known to be legitimate and clean),
    *unknown* (drivers that ELAM can’t classify), and *known bad* (drivers known to
    be malicious).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ➌处的参数提供了操作系统用来将启动驱动程序分类为*已知良好*（已知合法且干净的驱动程序）、*未知*（ELAM无法分类的驱动程序）和*已知不良*（已知恶意的驱动程序）的信息。
- en: 'Unfortunately, the ELAM driver must base this decision on limited data about
    the driver image to classify, namely:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，ELAM驱动程序必须基于有限的关于驱动程序映像的数据来做出分类决策，即：
- en: The name of the image
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映像的名称
- en: The registry location where the image is registered as a boot-start driver
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映像注册为启动驱动程序的注册表位置
- en: The publisher and issuer of the image’s certificate
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映像证书的发布者和签发者
- en: A hash of the image and the name of the hashing algorithm
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映像的哈希值和哈希算法的名称
- en: A certificate thumbprint and the name of the thumbprint algorithm
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书指纹和指纹算法的名称
- en: The ELAM driver doesn’t receive the image’s base address, nor can it access
    the binary image on the hard drive because the storage device driver stack isn’t
    yet initialized (as the system hasn’t finished bootup). It must decide which drivers
    to load based solely on the hash of the image and its certificate, without being
    able to observe the image itself. As a consequence, the protection for the drivers
    is not very effective at this stage.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ELAM驱动程序无法接收映像的基地址，也无法访问硬盘上的二进制映像，因为存储设备驱动程序堆栈尚未初始化（因为系统尚未完成启动）。它必须仅根据映像的哈希值及其证书来决定加载哪些驱动程序，而无法观察到映像本身。因此，在此阶段，驱动程序的保护并不非常有效。
- en: '**ELAM Policy**'
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**ELAM策略**'
- en: 'Windows decides whether to load known bad or unknown drivers based on the ELAM
    policy specified in this registry key: *HKLM\System\CurrentControlSet\Control\EarlyLaunch\DriverLoadPolicy*.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Windows根据注册表中指定的ELAM策略决定是否加载已知不良或未知驱动程序：*HKLM\System\CurrentControlSet\Control\EarlyLaunch\DriverLoadPolicy*。
- en: '[Table 6-1](ch06.xhtml#ch06tab01) lists the ELAM policy values that determine
    which drivers may be loaded.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-1](ch06.xhtml#ch06tab01)列出了决定可以加载哪些驱动程序的ELAM策略值。'
- en: '**Table 6-1:** ELAM Policy Values'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-1：** ELAM策略值'
- en: '| **Policy name** | **Policy value** | **Description** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **策略名称** | **策略值** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `PNP_INITIALIZE_DRIVERS_DEFAULT` | `0x00` | Load known good drivers only.
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `PNP_INITIALIZE_DRIVERS_DEFAULT` | `0x00` | 仅加载已知良好的驱动程序。 |'
- en: '| `PNP_INITIALIZE_UNKNOWN_DRIVERS` | `0x01` | Load known good and unknown drivers
    only. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `PNP_INITIALIZE_UNKNOWN_DRIVERS` | `0x01` | 仅加载已知良好和未知的驱动程序。 |'
- en: '| `PNP_INITIALIZE_BAD_CRITICAL_DRIVERS` | `0x03` | Load known good, unknown,
    and known bad critical drivers. (This is the default setting.) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `PNP_INITIALIZE_BAD_CRITICAL_DRIVERS` | `0x03` | 加载已知良好、未知和已知不良的关键驱动程序。（这是默认设置。）
    |'
- en: '| `PNP_INITIALIZE_BAD_DRIVERS` | `0x07` | Load all drivers. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `PNP_INITIALIZE_BAD_DRIVERS` | `0x07` | 加载所有驱动程序。 |'
- en: As you can see, the default ELAM policy, `PNP_INITIALIZE_BAD_CRITICAL_DRIVERS`,
    allows the loading of bad critical drivers. This means that if a critical driver
    is classified by ELAM as known bad, the system will load it regardless. The rationale
    behind this policy is that critical system drivers are an essential part of the
    operating system, so any failure in their initialization will render the operating
    system unbootable; that is, the system won’t boot unless all its critical drivers
    are successfully loaded and initialized. This ELAM policy therefore compromises
    some security in favor of availability and serviceability.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，默认的ELAM策略`PNP_INITIALIZE_BAD_CRITICAL_DRIVERS`允许加载不良的关键驱动程序。这意味着，如果一个关键驱动程序被ELAM分类为已知不良，系统仍然会加载它。此策略的背后逻辑是，关键系统驱动程序是操作系统的基本组成部分，因此它们初始化失败将导致操作系统无法启动；也就是说，系统只有在所有关键驱动程序成功加载和初始化后才能启动。因此，ELAM策略在可用性和服务性方面妥协了一些安全性。
- en: 'However, this policy won’t load known bad *noncritical* drivers, or those drivers
    without which the operating system can still successfully load. This is the main
    difference between the `PNP_INITIALIZE_BAD_CRITICAL_DRIVERS` and `PNP_INITIALIZE_BAD_DRIVERS`
    policies: the latter allows all drivers to be loaded, including known bad noncritical
    drivers.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用此策略不会加载已知的不良*非关键*驱动程序，或那些即使没有也能让操作系统成功加载的驱动程序。这是`PNP_INITIALIZE_BAD_CRITICAL_DRIVERS`和`PNP_INITIALIZE_BAD_DRIVERS`策略之间的主要区别：后者允许加载所有驱动程序，包括已知的不良非关键驱动程序。
- en: '***How Bootkits Bypass ELAM***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Bootkit如何绕过ELAM***'
- en: ELAM gives security software an advantage against rootkit threats but not against
    bootkits—nor was it designed to. ELAM can monitor only legitimately loaded drivers,
    but most bootkits load kernel-mode drivers that use undocumented operating system
    features. This means that a bootkit can bypass security enforcement and inject
    its code into kernel address space despite ELAM. In addition, as shown in [Figure
    6-1](ch06.xhtml#ch06fig01), a bootkit’s malicious code runs before the operating
    system kernel is initialized and before any kernel-mode driver is loaded, including
    ELAM. This means that a bootkit can sidestep ELAM protection.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ELAM为安全软件提供了对抗rootkit威胁的优势，但对抗bootkit的能力较弱——它本来就不是为了应对bootkit设计的。ELAM只能监控合法加载的驱动程序，但大多数引导包加载的是使用操作系统未公开功能的内核模式驱动程序。这意味着引导包可以绕过安全强制措施，将其代码注入内核地址空间，尽管有ELAM。此外，如[图6-1](ch06.xhtml#ch06fig01)所示，引导包的恶意代码在操作系统内核初始化之前、任何内核模式驱动程序加载之前（包括ELAM）就已经运行。这意味着引导包可以绕过ELAM保护。
- en: '![image](../images/06fig01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig01.jpg)'
- en: '*Figure 6-1: The flow of the boot process with ELAM*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：带有ELAM的引导过程流程*'
- en: Most bootkits load their kernel-mode code in the middle of kernel initialization,
    once all OS subsystems (the I/O subsystem, object manager, plug and play manager,
    and so forth) have been initialized but before ELAM is executed. ELAM can’t prevent
    the execution of malicious code that has been loaded before it, of course, so
    it has no defenses against bootkit techniques.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数引导包在内核初始化的过程中加载它们的内核模式代码，通常是在所有操作系统子系统（如I/O子系统、对象管理器、即插即用管理器等）初始化完成后，但在执行ELAM之前。显然，ELAM无法阻止在它之前加载的恶意代码的执行，因此它对引导包技术没有防御能力。
- en: '**Microsoft Kernel-Mode Code Signing Policy**'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**微软内核模式代码签名政策**'
- en: The Kernel-Mode Code Signing Policy protects the Windows operating system by
    imposing code-signing requirements for modules meant to be loaded into the kernel
    address space. This policy has made it much harder for bootkits and rootkits to
    compromise a system by executing kernel-mode drivers, thus pushing rootkit developers
    to switch to bootkit techniques instead. Unfortunately, as explained later in
    the chapter, attackers can disable the entire logic of on-load signature verification
    by manipulating a few variables that correspond to startup configuration options.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模式代码签名政策通过对加载到内核地址空间的模块强制执行代码签名要求，保护了Windows操作系统。该政策使得引导包和rootkit通过执行内核模式驱动程序来危害系统变得更加困难，从而迫使rootkit开发者转而采用引导包技术。然而，正如本章后续部分所解释的，攻击者可以通过操控一些与启动配置选项对应的变量，禁用整个加载时签名验证逻辑。
- en: '***Kernel-Mode Drivers Subject to Integrity Checks***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内核模式驱动程序完整性检查要求***'
- en: The signing policy was introduced in Windows Vista and has been enforced in
    all subsequent versions of Windows, though it’s enforced differently on 32-bit
    and 64-bit operating systems. It kicks in when the kernel-mode drivers are loaded
    so that it can verify their integrity before driver images are mapped into kernel
    address space. [Table 6-2](ch06.xhtml#ch06tab02) shows which kernel-mode drivers
    on 64- and 32-bit systems are subject to which integrity checks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 签名策略首次在Windows Vista中引入，并且在所有后续版本的Windows中得到了强制执行，尽管在32位和64位操作系统上其执行方式不同。它在加载内核模式驱动程序时生效，以便在将驱动程序映像映射到内核地址空间之前验证其完整性。[表6-2](ch06.xhtml#ch06tab02)展示了64位和32位系统上哪些内核模式驱动程序需要进行哪些完整性检查。
- en: '**Table 6-2:** Kernel-Mode Code Signing Policy Requirements'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-2：** 内核模式代码签名政策要求'
- en: '| **Driver type** | **Subject to integrity checks?** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **驱动程序类型** | **是否需要进行完整性检查？** |'
- en: '| --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **64-bit** | **32-bit** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **64位** | **32位** |'
- en: '| --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Boot-start drivers | Yes | Yes |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 启动驱动程序 | 是 | 是 |'
- en: '| Non-boot-start PnP drivers | Yes | No |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 非启动即插即用驱动程序 | 是 | 否 |'
- en: '| Non-boot-start, non-PnP drivers | Yes | No (except drivers that stream protected
    media) |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 非启动驱动程序 | 是 | 否（除非是流媒体保护内容的驱动程序） |'
- en: As the table shows, on 64-bit systems, all kernel-mode modules, regardless of
    type, are subject to integrity checks. On 32-bit systems, the signing policy applies
    only to boot-start and media drivers; other drivers are not checked (PnP device
    installation enforces an install-time signing requirement).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如表所示，在64位系统上，所有内核模式模块，无论类型如何，都需要进行完整性检查。在32位系统上，签名策略仅适用于启动驱动程序和媒体驱动程序；其他驱动程序不进行检查（PnP设备安装强制执行安装时签名要求）。
- en: In order to comply with the code integrity requirements, drivers must have either
    an embedded Software Publisher Certificate (SPC) digital signature or a catalog
    file with an SPC signature. Boot-start drivers, however, can have only embedded
    signatures because at boot time the storage device driver stack isn’t initialized,
    making the drivers’ catalog files inaccessible.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了符合代码完整性要求，驱动程序必须具有嵌入式的软件发布者证书（SPC）数字签名或带有SPC签名的目录文件。然而，引导启动驱动程序只能拥有嵌入式签名，因为在启动时存储设备驱动程序堆栈尚未初始化，导致驱动程序的目录文件无法访问。
- en: '***Location of Driver Signatures***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***驱动程序签名的位置***'
- en: The embedded driver signature within a PE file, such as a boot-start driver,
    is specified in the `IMAGE_DIRECTORY_DATA_SECURITY` entry in the PE header data
    directories. Microsoft provides APIs to enumerate and get information on all the
    certificates contained in an image, as shown in [Listing 6-2](ch06.xhtml#ch06list02).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入在PE文件中的驱动程序签名，例如引导启动驱动程序，指定在PE头数据目录中的`IMAGE_DIRECTORY_DATA_SECURITY`条目中。微软提供了API来枚举并获取映像中包含的所有证书信息，如[清单6-2](ch06.xhtml#ch06list02)所示。
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 6-2: Microsoft’s API for enumerating and validating certificates*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-2：微软用于枚举和验证证书的API*'
- en: The Kernel-Mode Code Signing Policy has increased the security resilience of
    the system, but it does have its limitations. In the following sections, we discuss
    some of those shortcomings and how malware authors have leveraged them to bypass
    protections.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模式代码签名策略提高了系统的安全性韧性，但它确实有其局限性。在接下来的章节中，我们将讨论这些局限性以及恶意软件作者如何利用这些局限性绕过保护。
- en: '**PLUG AND PLAY DEVICE INSTALLATION SIGNING POLICY**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**即插即用设备安装签名策略**'
- en: 'In addition to the Kernel-Mode Code Signing Policy, Microsoft Windows has another
    type of signing policy: the Plug and Play Device Installation Signing Policy.
    It’s important not to confuse the two.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内核模式代码签名策略，微软Windows还有另一种签名策略：即插即用设备安装签名策略。重要的是不要混淆这两者。
- en: The requirements of the Plug and Play Device Installation Signing Policy apply
    only to plug and play (PnP) device drivers and are enforced in order to verify
    the identity of the publisher and the integrity of the PnP device driver installation
    package. Verification requires that the catalog file of the driver package be
    signed either by a Windows Hardware Quality Labs (WHQL) certificate or by a third-party
    SPC. If the driver package doesn’t meet the requirements of the PnP policy, a
    warning dialog prompts users to decide whether to allow the driver package to
    be installed on their system.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 即插即用设备安装签名策略的要求仅适用于即插即用（PnP）设备驱动程序，并且此策略用于验证发布者的身份和PnP设备驱动程序安装包的完整性。验证要求驱动程序包的目录文件必须由Windows硬件质量实验室（WHQL）证书或第三方SPC签名。如果驱动程序包不符合PnP策略的要求，系统将显示警告对话框，提示用户决定是否允许在系统上安装该驱动程序包。
- en: System administrators can disable the PnP policy, allowing PnP driver packages
    to be installed on a system without proper signatures. Also, note that this policy
    is applied only when the driver package is installed, not when the drivers are
    loaded. Although this may look like a TOCTOU (time of check to time of use) weakness,
    it’s not; it simply means that a PnP driver package that is successfully installed
    on a system won’t necessarily be loaded, because these drivers are also subject
    to the Kernel-Mode Code Signing Policy check at boot.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员可以禁用PnP策略，允许没有适当签名的PnP驱动程序包安装到系统中。此外，请注意，该策略仅在安装驱动程序包时应用，而不是在驱动程序加载时应用。虽然这看起来像是一个TOCTOU（检查时间到使用时间）弱点，但实际上不是；它只是意味着，成功安装到系统中的PnP驱动程序包不一定会被加载，因为这些驱动程序在启动时也会受到内核模式代码签名策略的检查。
- en: '***The Legacy Code Integrity Weakness***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***传统代码完整性弱点***'
- en: The logic in the Kernel-Mode Code Signing Policy responsible for enforcing code
    integrity is shared between the Windows kernel image and the kernel-mode library
    *ci.dll*. The kernel image uses this library to verify the integrity of all modules
    being loaded into the kernel address space. The key weakness of the signing process
    lies in a single point of failure in this code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 负责执行代码完整性的内核模式代码签名策略的逻辑由Windows内核映像和内核模式库*ci.dll*共享。内核映像使用此库来验证所有加载到内核地址空间中的模块的完整性。签名过程的主要弱点在于代码中的单点故障。
- en: 'In Microsoft Windows Vista and 7, a single variable in the kernel image lies
    at the heart of this mechanism and determines whether integrity checks are enforced.
    It looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft Windows Vista和7中，内核镜像中的一个单一变量是此机制的核心，决定是否执行完整性检查。它如下所示：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This variable is initialized at boot time in the kernel image routine `NTSTATUS
    SepInitializeCodeIntegrity()`. The operating system checks to see if it is booted
    into the Windows preinstallation (WinPE) mode, and if so, the variable `nt!g_CiEnabled`
    is initialized with the `FALSE` (0x00) value, which disables integrity checks.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该变量在引导时通过内核镜像例程`NTSTATUS SepInitializeCodeIntegrity()`进行初始化。操作系统会检查是否已进入Windows预安装（WinPE）模式，如果是，变量`nt!g_CiEnabled`将被初始化为`FALSE`（0x00）值，这会禁用完整性检查。
- en: So, of course, attackers found that they could easily dodge the integrity check
    by simply setting `nt!g_CiEnabled` to `FALSE`, which is exactly what happened
    with the Uroburos family of malware (also known as Snake and Turla) in 2011\.
    Uroburos bypassed the code-signing policy by introducing and then exploiting a
    vulnerability in a third-party driver. The legitimate third-party signed driver
    was *VBoxDrv.sys* (the VirtualBox driver), and the exploit cleared the value of
    the `nt!g_CiEnabled` variable after gaining code execution in kernel mode, at
    which point any malicious unsigned driver could be loaded on the attacked machine.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当然，攻击者发现他们可以通过简单地将`nt!g_CiEnabled`设置为`FALSE`来轻松绕过完整性检查，这正是2011年Uroburos恶意软件家族（也称为Snake和Turla）发生的情况。Uroburos通过引入并利用第三方驱动程序中的漏洞绕过了代码签名策略。合法的第三方签名驱动程序是*VBoxDrv.sys*（VirtualBox驱动程序），该漏洞在内核模式中获得代码执行后清除了`nt!g_CiEnabled`变量的值，此时任何恶意的未签名驱动程序都可以加载到被攻击的机器上。
- en: '**A LINUX VULNERABILITY**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个LINUX漏洞**'
- en: 'This kind of weakness is not unique to Windows: attackers have disabled the
    mandatory access control enforcement in SELinux in similar ways. Specifically,
    if the attacker knows the address of the variable containing SELinux’s enforcement
    status, all the attacker needs to do is overwrite the value of that variable.
    Because SELinux enforcement logic tests the variable’s value before doing any
    checks, this logic will render itself inactive. A detailed analysis of this vulnerability
    and its exploit code can be found at *[https://grsecurity.net/~spender/exploits/exploit2.txt](https://grsecurity.net/~spender/exploits/exploit2.txt)*.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种弱点不仅仅是Windows特有的：攻击者也以类似的方式禁用了SELinux中的强制访问控制。具体来说，如果攻击者知道包含SELinux强制执行状态的变量的地址，攻击者只需覆盖该变量的值即可。由于SELinux的强制执行逻辑在执行任何检查之前会先测试该变量的值，因此此逻辑会被禁用。关于此漏洞及其利用代码的详细分析可以在*[https://grsecurity.net/~spender/exploits/exploit2.txt](https://grsecurity.net/~spender/exploits/exploit2.txt)*找到。
- en: If Windows isn’t in WinPE mode, it next checks the values of the boot options
    `DISABLE_INTEGRITY_CHECKS` and `TESTSIGNING`. As the name suggests, `DISABLE_INTEGRITY_CHECKS`
    disables integrity checks. A user, on any Windows version, can set this option
    manually at boot with the Boot menu option Disable Driver Signature Enforcement.
    Windows Vista users can also use the *bcdedit.exe* tool to set the value of the
    `nointegritychecks` option to `TRUE`; later versions ignore this option in the
    Boot Configuration Data (BCD) when Secure Boot is enabled (see [Chapter 17](ch17.xhtml#ch17)
    for more on Secure Boot).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Windows不是处于WinPE模式，它接下来会检查引导选项`DISABLE_INTEGRITY_CHECKS`和`TESTSIGNING`的值。如其名称所示，`DISABLE_INTEGRITY_CHECKS`会禁用完整性检查。任何版本的Windows用户都可以通过引导菜单选项“禁用驱动程序签名强制执行”手动设置此选项。Windows
    Vista用户还可以使用*bcdedit.exe*工具将`nointegritychecks`选项的值设置为`TRUE`；在启用安全启动时，较高版本的Windows会忽略启动配置数据（BCD）中的此选项（有关安全启动的更多信息，请参见[第17章](ch17.xhtml#ch17)）。
- en: The `TESTSIGNING` option alters the way the operating system verifies the integrity
    of kernel-mode modules. When it’s set to `TRUE`, certificate validation isn’t
    required to chain all the way up to a trusted root certificate authority (CA).
    In other words, *any* driver with *any* digital signature can be loaded into kernel
    address space. The Necurs rootkit abuses the `TESTSIGNING` option by setting it
    to `TRUE` and loading its kernel-mode driver, signed with a custom certificate.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`TESTSIGNING`选项更改操作系统验证内核模式模块完整性的方式。当设置为`TRUE`时，不需要验证证书链到受信任的根证书颁发机构（CA）。换句话说，*任何*具有*任何*数字签名的驱动程序都可以加载到内核地址空间。Necurs根套件通过将`TESTSIGNING`设置为`TRUE`并加载其内核模式驱动程序（该驱动程序使用自定义证书签名）来滥用此选项。'
- en: For years, there have been browser bugs that failed to follow the intermediate
    links in the X.509 certificate’s chains of trust to a legitimate trusted CA,^([1](footnotes.xhtml#ch06fn1))
    but OS module-signing schemes still don’t eschew shortcuts wherever chains of
    trust are concerned.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，浏览器存在未能遵循X.509证书链中的中间链接以到达合法受信CA的bug^([1](footnotes.xhtml#ch06fn1))，但是操作系统的模块签名方案在涉及信任链时仍然没有避免捷径。
- en: '***The ci.dll Module***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***ci.dll模块***'
- en: 'The kernel-mode library *ci.dll*, which is responsible for enforcing code integrity
    policy, contains the following routines:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 负责执行代码完整性策略的内核模式库*ci.dll*包含以下例程：
- en: CiCheckSignedFile Verifies the digest and validates the digital signature
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: CiCheckSignedFile 验证摘要并验证数字签名
- en: CiFindPageHashesInCatalog Validates whether a verified system catalog contains
    the digest of the first memory page of the PE image
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: CiFindPageHashesInCatalog 验证经过验证的系统目录是否包含PE映像第一内存页面的摘要
- en: CiFindPageHashesInSignedFile Verifies the digest and validates the digital signature
    of the first memory page of the PE image
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: CiFindPageHashesInSignedFile 验证PE映像第一内存页面的摘要并验证其数字签名
- en: CiFreePolicyInfo Frees memory allocated by the functions `CiVerifyHashInCatalog`,
    `CiCheckSignedFile`, `CiFindPageHashesInCatalog`, and `CiFindPageHashesInSignedFile`
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: CiFreePolicyInfo 释放由`CiVerifyHashInCatalog`、`CiCheckSignedFile`、`CiFindPageHashesInCatalog`和`CiFindPageHashesInSignedFile`函数分配的内存
- en: CiGetPEInformation Creates an encrypted communication channel between the caller
    and the *ci.dll* module
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: CiGetPEInformation 创建一个加密的通信通道，连接调用者和*ci.dll*模块
- en: CiInitialize Initializes the capability of *ci.dll* to validate PE image file
    integrity
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: CiInitialize 初始化*ci.dll*的功能，用于验证PE映像文件的完整性
- en: CiVerifyHashInCatalog Validates the digest of the PE image contained within
    a verified system catalog
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: CiVerifyHashInCatalog 验证包含在经过验证的系统目录中的PE映像的摘要
- en: The routine `CiInitialize` is the most important one for our purposes, because
    it initializes the library and creates its data context. We can see its prototype
    corresponding to Windows 7 in [Listing 6-3](ch06.xhtml#ch06list03).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`CiInitialize`例程对我们的目的来说最为重要，因为它初始化库并创建其数据上下文。我们可以在[清单6-3](ch06.xhtml#ch06list03)中看到与Windows
    7对应的原型。'
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 6-3: Prototype of the `CiInitialize` routine*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-3：`CiInitialize`例程的原型*'
- en: The `CiInitialize` routine receives as parameters the code integrity options
    (`CiOptions`) ➊ and a pointer to an array of callbacks (`OUT PVOID g_CiCallbacks`)
    ➋, the routines of which it fills in upon output. The kernel uses these callbacks
    to verify the integrity of kernel-mode modules.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`CiInitialize`例程接收作为参数的代码完整性选项（`CiOptions`）➊以及指向回调数组的指针（`OUT PVOID g_CiCallbacks`）➋，它将在输出时填充该数组。内核使用这些回调来验证内核模式模块的完整性。'
- en: The `CiInitialize` routine also performs a self-check to ensure that no one
    has tampered with it. The routine then proceeds to verify the integrity of all
    the drivers in the boot-driver list, which essentially contains boot-start drivers
    and their dependencies.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`CiInitialize`例程还会执行自检，以确保没有人篡改它。然后，例程继续验证启动驱动程序列表中所有驱动程序的完整性，该列表本质上包含启动时加载的驱动程序及其依赖项。'
- en: Once initialization of the *ci.dll* library is complete, the kernel uses callbacks
    in the `g_CiCallbacks` buffer to verify the integrity of the modules. In Windows
    Vista and 7 (but not Windows 8), the `SeValidateImageHeader` routine decides whether
    a particular image passes the integrity check. [Listing 6-4](ch06.xhtml#ch06list04)
    shows the algorithm underlying this routine.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦*ci.dll*库的初始化完成，内核会使用`g_CiCallbacks`缓冲区中的回调来验证模块的完整性。在Windows Vista和7中（但不包括Windows
    8），`SeValidateImageHeader`例程决定某个特定映像是否通过完整性检查。[清单6-4](ch06.xhtml#ch06list04)展示了该例程的算法。
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 6-4: Pseudocode of the `SeValidateImageHeader` routine*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-4：`SeValidateImageHeader`例程的伪代码*'
- en: '`SeValidateImageHeader` checks to see if the `nt!g_CiEnabled` variable is set
    to `TRUE` ➊. If not, it tries to allocate a byte-length buffer ➌ and, if it succeeds,
    returns a `STATUS_SUCCESS` value.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`SeValidateImageHeader`检查`nt!g_CiEnabled`变量是否设置为`TRUE`➊。如果不是，它会尝试分配一个字节长度的缓冲区➌，并且如果成功，则返回`STATUS_SUCCESS`值。'
- en: If `nt!g_CiEnabled` is `TRUE`, then `SeValidateImageHeader` executes the first
    callback in the `g_CiCallbacks` buffer, `g_CiCallbacks[0]` ➋, which is set to
    the `CiValidateImageData` routine. The later callback `CiValidateImageData` verifies
    the integrity of the image being loaded.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`nt!g_CiEnabled`为`TRUE`，则`SeValidateImageHeader`执行`g_CiCallbacks`缓冲区中的第一个回调`g_CiCallbacks[0]`➋，该回调设置为`CiValidateImageData`例程。后续回调`CiValidateImageData`验证加载的映像的完整性。
- en: '***Defensive Changes in Windows 8***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Windows 8中的防御性变化***'
- en: With Windows 8, Microsoft made a few changes designed to limit the kinds of
    attacks possible in this scenario. First, Microsoft deprecated the kernel variable
    `nt!g_CiEnabled`, leaving no single point of control over the integrity policy
    in the kernel image as in earlier versions of Windows. Windows 8 also changed
    the layout of the `g_CiCallbacks` buffer.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows 8中，微软进行了一些更改，旨在限制在这种场景下可能发生的攻击类型。首先，微软废弃了内核变量`nt!g_CiEnabled`，这意味着不再像早期版本的Windows那样在内核镜像中有一个控制完整性策略的单一控制点。Windows
    8还改变了`g_CiCallbacks`缓冲区的布局。
- en: '[Listing 6-5](ch06.xhtml#ch06list05) (Windows 7 and Vista) and [Listing 6-6](ch06.xhtml#ch06list06)
    (Windows 8) show how the layout of `g_CiCallbacks` differs between the OS versions.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单6-5](ch06.xhtml#ch06list05)（Windows 7和Vista）和[清单6-6](ch06.xhtml#ch06list06)（Windows
    8）展示了`g_CiCallbacks`在不同操作系统版本中的布局差异。'
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 6-5: Layout of `g_CiCallbacks` buffer in Windows Vista and Windows
    7*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-5：Windows Vista和Windows 7中`g_CiCallbacks`缓冲区的布局*'
- en: As you can see in [Listing 6-5](ch06.xhtml#ch06list05), the Windows Vista and
    Windows 7 layout includes just the necessary basics. The Windows 8 layout ([Listing
    6-6](ch06.xhtml#ch06list06)), on the other hand, has more fields for additional
    callback functions for PE image digital signature validation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单6-5](ch06.xhtml#ch06list05)所示，Windows Vista和Windows 7的布局仅包含基本的必要内容。相比之下，Windows
    8的布局（[清单6-6](ch06.xhtml#ch06list06)）则有更多的字段，用于额外的回调函数，用于PE映像数字签名验证。
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 6-6: Layout of `g_CiCallbacks` buffer in Windows 8*.x'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-6：Windows 8中`g_CiCallbacks`缓冲区的布局*.x'
- en: In addition to the function pointers `CiQueryInformation` ➊, `CiValidateImageHeader`
    ➋, and `CiValidateImageData` ➌, which are present in both `CI_CALLBACKS_WIN7_VISTA`
    and `CI_CALLBACKS_WIN8` structures, `CI_CALLBACKS_WIN8` also has fields that affect
    how code integrity is enforced in Windows 8.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在`CI_CALLBACKS_WIN7_VISTA`和`CI_CALLBACKS_WIN8`结构中都存在的函数指针`CiQueryInformation`
    ➊、`CiValidateImageHeader` ➋和`CiValidateImageData` ➌之外，`CI_CALLBACKS_WIN8`结构还具有一些字段，这些字段影响Windows
    8中代码完整性执行的方式。
- en: '**FURTHER READING ON CI.DLL**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于CI.DLL的进一步阅读**'
- en: More information on the implementation details of the *ci.dll* module can be
    found at *[https://github.com/airbus-seclab/warbirdvm](https://github.com/airbus-seclab/warbirdvm)*.
    This article delves into the implementation details of the encrypted memory storage
    used within *ci.dll* module, which may be used by other OS components to keep
    certain details and configuration information secret. This storage is protected
    by a heavily obfuscated virtual machine (VM), making it much harder to reverse
    engineer the storage encryption/decryption algorithm. The authors of the article
    provide a detailed analysis of the VM obfuscation method, and they share their
    Windbg plug-in for decrypting and encrypting the storage on the fly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于*ci.dll*模块实现细节的信息可以在* [https://github.com/airbus-seclab/warbirdvm](https://github.com/airbus-seclab/warbirdvm)*找到。本文深入探讨了*ci.dll*模块中用于加密内存存储的实现细节，该存储可能被其他操作系统组件用于保持某些细节和配置信息的保密。该存储受到了高度混淆的虚拟机（VM）保护，这使得逆向工程存储加密/解密算法变得更加困难。文章的作者提供了有关VM混淆方法的详细分析，并分享了他们的Windbg插件，用于实时解密和加密存储。
- en: '**Secure Boot Technology**'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安全启动技术**'
- en: Secure Boot technology was introduced in Windows 8 to protect the boot process
    against bootkit infection. Secure Boot leverages the Unified Extensible Firmware
    Interface (UEFI) to block the loading and execution of any boot application or
    driver without a valid digital signature in order to protect the integrity of
    the operating system kernel, system files, and boot-critical drivers. [Figure
    6-2](ch06.xhtml#ch06fig02) shows the boot process with Secure Boot enabled.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 安全启动技术是在Windows 8中引入的，用于防止引导过程受到bootkit感染。安全启动利用统一可扩展固件接口（UEFI）来阻止任何没有有效数字签名的引导应用程序或驱动程序的加载和执行，以保护操作系统内核、系统文件和启动关键驱动程序的完整性。[图6-2](ch06.xhtml#ch06fig02)展示了启用安全启动的启动过程。
- en: '![image](../images/06fig02.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig02.jpg)'
- en: '*Figure 6-2: The flow of the boot process with Secure Boot*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：启用安全启动的启动过程*'
- en: When Secure Boot is enabled, the BIOS verifies the integrity of all UEFI and
    OS boot files executed at startup to ensure that they come from a legitimate source
    and have a valid digital signature. The signatures on all boot-critical drivers
    are checked in *winload.exe* and by the ELAM driver as part of Secure Boot verification.
    Secure Boot is similar to the Microsoft Kernel-Mode Code Signing Policy, but it
    applies to modules that are executed *before* the operating system kernel is loaded
    and initialized. As a result, untrusted components (that is, ones without valid
    signatures) will not be loaded and will trigger remediation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用安全启动时，BIOS会验证启动时执行的所有UEFI和操作系统启动文件的完整性，以确保它们来自合法来源并具有有效的数字签名。所有与启动相关的驱动程序的签名都将在*winload.exe*和ELAM驱动程序中进行检查，作为安全启动验证的一部分。安全启动类似于微软的内核模式代码签名策略，但它适用于在操作系统内核加载并初始化*之前*执行的模块。因此，未经信任的组件（即没有有效签名的组件）将无法加载，并会触发修复。
- en: When the system first starts, Secure Boot ensures that the preboot environment
    and bootloader components aren’t tampered with. The bootloader, in turn, validates
    the integrity of the kernel and boot-start drivers. Once the kernel passes the
    integrity validations, Secure Boot verifies other drivers and modules. Fundamentally,
    Secure Boot relies on the assumption of a *root of trust*—the idea that early
    in execution, a system is trustworthy. Of course, if attackers manage to execute
    an attack before that point, they probably win.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统首次启动时，安全启动确保预启动环境和引导加载程序组件没有被篡改。引导加载程序则验证内核和启动驱动程序的完整性。一旦内核通过完整性验证，安全启动就会验证其他驱动程序和模块。从根本上说，安全启动依赖于一个*信任根*的假设——即在执行初期，系统是可信的。当然，如果攻击者设法在此之前发起攻击，他们很可能会成功。
- en: Over the last few years, the security research community has focused considerable
    attention on BIOS vulnerabilities that can allow attackers to bypass Secure Boot.
    We’ll discuss these vulnerabilities in detail in [Chapter 16](ch16.xhtml#ch16)
    and delve into Secure Boot in more detail in [Chapter 17](ch17.xhtml#ch17).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，安全研究社区已经将大量关注集中在了可以让攻击者绕过安全启动（Secure Boot）的BIOS漏洞上。我们将在[第16章](ch16.xhtml#ch16)中详细讨论这些漏洞，并在[第17章](ch17.xhtml#ch17)中更深入地探讨安全启动。
- en: '**Virtualization-Based Security in Windows 10**'
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Windows 10中的虚拟化基础安全**'
- en: 'Up until Windows 10, code integrity mechanisms were part of the system kernel
    itself. That essentially means that the integrity mechanism runs with the same
    privilege level that it is trying to protect. While this can be effective in many
    cases, it also means it is possible for an attacker to attack the integrity mechanism
    itself. To increase the effectiveness of the code integrity mechanism, Windows
    10 introduced two new features: Virtual Secure Mode and Device Guard, both of
    which are based on memory isolation assisted by hardware. This technology is generally
    referred to as *Second Level Address Translation*, and it is included in both
    Intel (where it is known as Extended Page Tables, or EPT) and AMD (where it’s
    called Rapid Virtualization Indexing, or RVI) CPUs.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 直到Windows 10，代码完整性机制仍是系统内核的一部分。这实际上意味着完整性机制以它试图保护的相同特权级别运行。虽然在许多情况下这可以有效，但也意味着攻击者有可能攻击完整性机制本身。为了增强代码完整性机制的有效性，Windows
    10引入了两个新功能：虚拟安全模式和设备保护（Device Guard），这两者都基于硬件辅助的内存隔离。这项技术通常被称为*二级地址转换*，并且被包括在英特尔（称为扩展页表，或EPT）和AMD（称为快速虚拟化索引，或RVI）CPU中。
- en: '***Second Level Address Translation***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***二级地址转换***'
- en: Windows has supported Second Level Address Translation (SLAT) since Windows
    8 with Hyper-V (a Microsoft hypervisor). Hyper-V uses SLAT to perform memory management
    (for example, access protection) for virtual machines and to reduce the overhead
    of translating guest physical addresses (memory isolated by virtualization technologies)
    to real physical addresses.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Windows自Windows 8以来就支持二级地址转换（SLAT）与Hyper-V（微软的虚拟机管理程序）。Hyper-V使用SLAT来执行虚拟机的内存管理（例如，访问保护），并减少将来宾物理地址（虚拟化技术隔离的内存）转换为实际物理地址的开销。
- en: SLAT provides hypervisors with an intermediary cache of virtual-to-physical
    address translation, which drastically reduces the amount of time the hypervisor
    takes to service translation requests to the physical memory of the host. It’s
    also used in the implementation of Virtual Secure Mode technology in Windows 10.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: SLAT为虚拟机监控器提供了一个虚拟到物理地址转换的中介缓存，这大大减少了虚拟机监控器处理翻译请求所需的时间，特别是对于主机的物理内存。它还被用于Windows
    10中虚拟安全模式技术的实现。
- en: '***Virtual Secure Mode and Device Guard***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***虚拟安全模式与设备防护***'
- en: Virtual Secure Mode (VSM) virtualization-based security first appeared in Windows
    10 and is based on Microsoft’s Hyper-V. When VSM is in place, the operating system
    and critical system modules are executed in isolated hypervisor-protected containers.
    This means that even if the kernel is compromised, critical components executed
    in other virtual environments are still secure because an attacker cannot pivot
    from one compromised virtual container to another. VSM also isolates the code
    integrity components from the Windows kernel itself in a hypervisor-protected
    container.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟安全模式（VSM）基于虚拟化的安全性首次出现在Windows 10，并基于微软的Hyper-V。当VSM启用时，操作系统和关键系统模块会在隔离的虚拟机监控器保护的容器中执行。这意味着即使内核被攻破，其他虚拟环境中执行的关键组件仍然是安全的，因为攻击者无法从一个被攻破的虚拟容器跳转到另一个虚拟容器。VSM还将代码完整性组件与Windows内核本身隔离在虚拟机监控器保护的容器中。
- en: VSM isolation makes it impossible to use vulnerable legitimate kernel-mode drivers
    to disable code integrity (unless a vulnerability is found that affects the protection
    mechanism itself). Because the potentially vulnerable driver and the code integrity
    libraries are located in separate virtual containers, attackers should not be
    able to turn code integrity protection off.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: VSM隔离使得无法使用易受攻击的合法内核模式驱动程序来禁用代码完整性（除非发现影响保护机制本身的漏洞）。由于潜在的易受攻击驱动程序和代码完整性库位于不同的虚拟容器中，攻击者不应能够关闭代码完整性保护。
- en: Device Guard technology leverages VSM to prevent untrusted code from running
    on the system. To make these assurances, Device Guard combines VSM-protected code
    integrity with platform and UEFI Secure Boot. In doing so, Device Guard enforces
    the code integrity policy from the very beginning of the boot process all the
    way up to loading OS kernel-mode drivers and user-mode applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 设备防护技术利用虚拟安全模式（VSM）来防止不可信的代码在系统上运行。为了实现这一保障，设备防护将VSM保护的代码完整性与平台和UEFI安全启动相结合。通过这样做，设备防护从启动过程的最初阶段一直到加载操作系统内核模式驱动程序和用户模式应用程序时，都在强制执行代码完整性策略。
- en: '[Figure 6-3](ch06.xhtml#ch06fig03) shows how Device Guard affects Windows 10’s
    ability to protect against bootkits and rootkits. Secure Boot protects from bootkits
    by verifying any firmware components executed in the preboot environment, including
    the OS bootloader. To prevent malicious code from being injected into the kernel-mode
    address space, the VSM isolates the critical OS components responsible for enforcing
    code integrity (known as Hypervisor-Enforced Code Integrity, or HVCI, in this
    context) from the OS kernel address space.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-3](ch06.xhtml#ch06fig03)展示了设备防护如何影响Windows 10防止引导劫持和根套件的能力。安全启动通过验证在预启动环境中执行的任何固件组件（包括操作系统引导加载程序）来保护免受引导劫持。为了防止恶意代码被注入到内核模式地址空间，VSM将负责强制执行代码完整性的关键操作系统组件（在此背景下称为虚拟机监控器强制代码完整性，或HVCI）从操作系统内核地址空间中隔离开。'
- en: '![image](../images/06fig03.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/06fig03.jpg)'
- en: '*Figure 6-3: The boot process with Virtual Secure Mode and Device Guard enabled*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：启用虚拟安全模式和设备防护的启动过程*'
- en: '***Device Guard Limitations on Driver Development***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设备防护对驱动程序开发的限制***'
- en: 'Device Guard imposes specific requirements and limitations on the driver development
    process, and some existing drivers will not run correctly with it active. All
    drivers must follow these rules:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 设备防护对驱动程序开发过程施加了特定的要求和限制，某些现有驱动程序在启用设备防护时将无法正确运行。所有驱动程序必须遵循以下规则：
- en: Allocate all nonpaged memory from the no-execute (NX) nonpaged pool. The driver’s
    PE module cannot have sections that are both writable and executable.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从不可执行（NX）不可分页池中分配所有非分页内存。驱动程序的PE模块不能有既可写又可执行的部分。
- en: Do not attempt direct modification of executable system memory.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要尝试直接修改可执行系统内存。
- en: Do not use dynamic or self-modifying code in kernel mode.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在内核模式下使用动态或自修改代码。
- en: Do not load any data as executable.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要加载任何数据作为可执行文件。
- en: Because most modern rootkits and bootkits do not adhere to these requirements,
    they cannot run with Device Guard active, even if the driver has a valid signature
    or is able to bypass code integrity protection.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数现代根套件和启动病毒不符合这些要求，即使驱动程序具有有效的签名或能够绕过代码完整性保护，它们也无法在启用设备保护的情况下运行。
- en: '**Conclusion**'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: This chapter has provided an overview of the evolution of code integrity protections.
    Boot process security is the most important frontier in defending operating systems
    against malware attacks. ELAM and code integrity protections are powerful security
    features that restrict the execution of untrusted code on the platform.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了代码完整性保护的演变。启动过程的安全性是防御操作系统免受恶意软件攻击的最重要前沿。ELAM 和代码完整性保护是强大的安全功能，可以限制平台上不受信任代码的执行。
- en: Windows 10 took boot process security to a new level, preventing code integrity
    bypasses by isolating HVCI components from the OS kernel with VSM. However, without
    an active Secure Boot mechanism in place, bootkits can circumvent these protections
    by attacking a system before they are loaded. In the following chapters, we’ll
    discuss Secure Boot in more detail and the BIOS attacks designed to evade it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 10 将启动过程的安全性提升到了一个新的水平，通过使用 VSM 将 HVCI 组件与操作系统内核隔离，防止了代码完整性绕过。然而，如果没有启用安全启动机制，启动病毒可以在系统加载前攻击系统，从而绕过这些保护措施。在接下来的章节中，我们将更详细地讨论安全启动以及设计用于规避它的
    BIOS 攻击。
