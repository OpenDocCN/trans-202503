<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch24" epub:type="chapter" role="doc-chapter">
<span aria-label="459" epub:type="pagebreak" id="pg_459" role="doc-pagebreak"/>
<hgroup>
<h2 class="CHAPTER" id="ch24">
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">24</span></span>
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">LOGGING EVENTS, MESSAGES, AND TRANSACTIONS</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="380" src="../images/opener.jpg" width="380"/>
</figure>
<p class="INTRO">Almost all live, commercial web applications keep a <i>log</i>, a record of messages, errors, events, performance summaries, and other information generated by the application while it runs. In this chapter, we’ll explore how to maintain logs for PHP web applications so you can analyze application performance and respond to problems when they occur. You’ll learn about PHP’s built-in resources for logging, as well as Monolog, a popular third-party PHP logging package, and you’ll see how to log messages to various locations.</p>
<p class="TX">Sometimes a log records events for auditing purposes, such as to review electronic monetary transactions for irregularities. Other times, transactions are logged for backup and recovery purposes. For example, if something goes wrong while writing information to a database, the database can be returned <span aria-label="460" epub:type="pagebreak" id="pg_460" role="doc-pagebreak"/>to a correct state by reverting to a backup (called an <i>image</i>, or <i>snapshot</i>) from a known point in time and then rerunning the sequence of transactions logged after that snapshot was created. Logging also goes hand in hand with exceptions, which we discussed in the preceding chapter. When an exception is thrown, it can be recorded in the system log for later analysis.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="toc-link_318"/><span class="SANS_Futura_Std_Bold_B_11">Built-in PHP Resources for Logging</span></h3>
<p class="TNI1">Logging is such a core part of server programming that PHP provides many resources to facilitate it. These include a set of predefined constants corresponding to various log severity levels, as well as built-in functions for logging messages to files. We’ll explore these features now.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="toc-link_319"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Predefined Constants for Severity Levels</span></h4>
<p class="TNI1">Most computer logging systems allow messages to be classified according to a particular level of urgency or importance. To that end, PHP comes with eight predefined constants establishing levels of logging severity. These severity levels, numbered 0 through 7, from most to least urgent, correspond to the eight levels laid out in RFC 5424, a widely used standard for the syslog protocol set by the IETF. You can find this protocol at <i><a href="https://www.rfc-editor.org/rfc/rfc5424">https://www.rfc-editor.org/rfc/rfc5424</a></i>.</p>
<p class="TX">You can use the PHP constants in conjunction with the built-in <span class="SANS_TheSansMonoCd_W5Regular_11">syslog()</span> function, which we’ll discuss next, to generate log messages of the appropriate severity level. <a href="#tab24-1">Table 24-1</a> shows the eight severity levels, their RFC 5424 level names, and a summary of their meanings.</p>
<p class="TT"><a id="tab24-1"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 24-1:</span></span> <span class="SANS_Futura_Std_Book_11">Levels of Severity for Log Messages from RFC 5424</span></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Syslog severity value</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">RFC 5424 log level</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Meaning</span></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">0</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Emergency</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">The system is unusable or unavailable.</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Alert</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">A problem has happened, and immediate action is required.</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">2</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Critical</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">A problem is about to happen and must be addressed immediately.</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">3</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Error</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">A failure has occurred that is non-urgent but needs action in a given time frame.</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">4</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Warning</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">An event requires action, since it is likely to lead to an error.</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">5</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Notice</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">An expected but significant event has occurred that warrants logging, but no action is required.</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">6</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Info</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">An expected event has occurred for reporting and measurement.</span></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">7</span></p></td>
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Debug</span></p></td>
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Used by software developers to record detailed information supporting current debugging and code analysis.</span></p></td>
</tr>
</tbody>
</table>
<p class="TX"><span aria-label="461" epub:type="pagebreak" id="pg_461" role="doc-pagebreak"/><a href="#tab24-2">Table 24-2</a> shows the eight named PHP constants corresponding to the RFC 5424 log levels as well as the integer values of these constants for macOS, Unix, and Windows systems.</p>
<p class="TT"><a id="tab24-2"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 24-2:</span></span> <span class="SANS_Futura_Std_Book_11">PHP Log-Level Constants</span></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">PHP constant</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">macOS and Unix value</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Windows value</span></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">LOG_EMERG</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">0</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">1</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">LOG_ALERT</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">LOG_CRIT</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">2</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">1</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">LOG_ERR</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">3</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">4</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">LOG_WARNING</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">4</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">5</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">LOG_NOTICE</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">5</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">6</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">LOG_INFO</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">6</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">6</span></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">LOG_DEBUG</span></p></td>
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">7</span></p></td>
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">6</span></p></td>
</tr>
</tbody>
</table>
<p class="TX">On macOS and Unix systems, each constant has an integer value corresponding to one of the eight severity levels. For example, the <span class="SANS_TheSansMonoCd_W5Regular_11">LOG_EMERG</span> constant has a value of <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> in macOS and Unix. If you’re running PHP on a Windows server, the values of these constants are slightly different, because of different standards for system header files. For all systems, however, the severity of the log level increases as the value of the constant decreases, in line with the principles of RFC 5424. We’ll refer to the macOS and Unix values throughout this chapter.</p>
<p class="TX">The various severity levels have their own conventional uses. When testing and debugging code, for example, it’s customary to use <span class="SANS_TheSansMonoCd_W5Regular_11">LOG_DEBUG</span> severity and perhaps to direct these log entries to their own debugging logfile. You might log messages about standard, noncritical issues, such as a user trying to upload files that are too big or of the wrong file type, with a severity of <span class="SANS_TheSansMonoCd_W5Regular_11">LOG_INFO</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">LOG_NOTICE</span>. This way, user-interface or file-size improvements could be considered if the same issues occur many times. Much thought should go into events likely to lead to errors, and these should be logged as <span class="SANS_TheSansMonoCd_W5Regular_11">LOG_ERR</span> severity. Likewise, it’s always important when coding for exceptions to identify those that might impact the overall functioning of the web application and log them with <span class="SANS_TheSansMonoCd_W5Regular_11">LOG_EMERG</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">LOG_ALERT</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">LOG_CRIT</span> severity.</p>
<p class="TX">Classifying log messages by severity level allows you to design computer systems with logic to respond to new log messages of different importance in different ways. For example, when a new log message occurs at the top three severity levels (Emergency, Alert, or Critical), the logging system rules might perform actions such as sending text messages and automated phone calls to the site technicians listed as being on call. Meanwhile, messages of lower importance might be written to archive files or perhaps sent via a web API to a cloud logging system. We’ll explore an example of creating customized responses for different severity in <span class="Xref">“Managing Logs According to Severity” on <a href="#pg_466">page 466</a></span>.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<span aria-label="462" epub:type="pagebreak" id="pg_462" role="doc-pagebreak"/>
<h4 class="H2" id="sec3"><span id="toc-link_320"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Logging Functions</span></h4>
<p class="TNI1">PHP has two built-in functions for logging messages: <span class="SANS_TheSansMonoCd_W5Regular_11">error_log()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">syslog()</span>. They differ based on where the messages get logged.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">error_log()</span> function appends to the PHP error logfile, whose location is defined by the <span class="SANS_TheSansMonoCd_W5Regular_11">error_log</span> path in your <i>php.ini</i> file or your server log settings, or to another location that can be passed as a parameter when calling the function. (See <span class="Xref"><a href="appendix-a.xhtml">Appendix A</a></span> for information on how to locate your system’s <i>php.ini</i> file.)</p>
<p class="TX">By contrast, the <span class="SANS_TheSansMonoCd_W5Regular_11">syslog()</span> function appends messages to your computer system’s general syslog file. <a href="#tab24-3">Table 24-3</a> shows the default name and location of this file on macOS, Unix, and Windows.</p>
<p class="TT"><a id="tab24-3"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 24-3:</span></span> <span class="SANS_Futura_Std_Book_11">Default Names and Locations of Syslog Files</span></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Operating system</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Filename</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Location</span></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">macOS</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_Oblique_11">system.log</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_Oblique_11">/var/log</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Unix</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">syslog</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_11">/etc</span></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Windows</span></p></td>
<td class="TBL"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_Oblique_11">SysEvent.evt</span></p></td>
<td class="TBL"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_Oblique_11">C:\WINDOWS\system32\config\</span></p></td>
</tr>
</tbody>
</table>
<p class="TX">When setting up an application, choosing where to log messages can be difficult: Do you want to have dedicated logfiles just for this application, do you want to log your PHP web application messages to the same location as other PHP logs, or do you want logs from the application to be added to the computer system’s general logging system? As you’ll see in <span class="Xref">“Logging to the Cloud” on <a href="#pg_472">page 472</a></span>, using a third-party logging library provides even more options to select from: choosing the filename and location, using multiple files for different log types, or even logging to a web API.</p>
<p class="TX">The decision partly depends on the nature of the project. For personal project development, logging to your local machine might make sense, whereas for mission-critical reporting of a live production system, logging to files on a web server or the cloud is probably more appropriate and may be mandated by the requirements and standards of the organization you’re working for.</p>
<p class="TX">An advantage of logging to the system’s general syslog file, as with PHP’s <span class="SANS_TheSansMonoCd_W5Regular_11">syslog()</span> function, is that logs for all applications and processes will be in one place, so you can look at issues with your web application in relation to other system issues (such as memory or processing speed problems). Also, you can use a range of applications for viewing, searching, and analyzing the general logging system, whether it be for Windows, macOS, or Unix. However, general logs are large and constantly being appended to by running processes, so when developing and even when running a production site, targeting logs for the web application to a dedicated file, as with the <span class="SANS_TheSansMonoCd_W5Regular_11">error_log()</span> function, can make a lot of sense. With this in mind, let’s take a look at how the two built-in PHP logging functions work.</p>
<p class="TX">You can log a message to the PHP error logfile with <span class="SANS_TheSansMonoCd_W5Regular_11">error_log()</span> by writing a statement such as the following:</p>
<pre><code><span aria-label="463" epub:type="pagebreak" id="pg_463" role="doc-pagebreak"/>error_log('Some event has happened!');</code></pre>
<p class="BodyContinued">Pass the message you want to log as an argument to the function. By default, this message will be appended to the file specified in your <i>php.ini</i> settings. You can view that file from the command line by using <span class="SANS_TheSansMonoCd_W5Regular_11">cat</span> (macOS/Unix) or <span class="SANS_TheSansMonoCd_W5Regular_11">type</span> (Windows), followed by the filename. For example, here’s the entry added to the logfile on my macOS laptop (which logs to a file named <i>php_error.log</i>) by the previous <span class="SANS_TheSansMonoCd_W5Regular_11">error_log()</span> call:</p>
<pre><code>$ <b>cat php_error.log</b>&#13;
[28-Jan-2025 22:08:16 UTC] Some event has happened!</code></pre>
<p class="BodyContinued">The log entry starts with a timestamp, followed by the message string passed as an argument to the function.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">syslog()</span> function takes two arguments. The first is one of the integers (0 through 7) indicating the severity level, or a constant declared with that integer value. This is where the built-in PHP constants discussed earlier come in. The second argument is a string message to be logged to the system’s general syslog file. Here’s an example call to the function:</p>
<pre><code>syslog(LOG_WARNING, 'warning message from Matt');</code></pre>
<p class="BodyContinued">We use the <span class="SANS_TheSansMonoCd_W5Regular_11">LOG_WARNING</span> constant as the first argument, which PHP defines with a value of <span class="SANS_TheSansMonoCd_W5Regular_11">4</span>, corresponding to the fifth level on the RFC 5424 severity scale. This event requires action since it’s likely to lead to an error.</p>
<p class="TX">The syslog file often contains hundreds or even thousands of entries, logging many events and actions from many system programs and applications. Rather than display the whole logfile, filtering it to just the entries you want is helpful. For macOS or Unix, you can use <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> to see entries containing a certain string. Windows has an equivalent <span class="SANS_TheSansMonoCd_W5Regular_11">findstr</span> command. Here’s an example of using <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> to view the log entry just created with the <span class="SANS_TheSansMonoCd_W5Regular_11">syslog()</span> function:</p>
<pre><code>$ <b>grep "from Matt" system.log</b>&#13;
Jan 28 22:15:15 matts-MacBook-Pro-2 php[4304]: warning message from Matt</code></pre>
<p class="TX">Here I’ve used <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> to show only log entries containing the string <span class="SANS_TheSansMonoCd_W5Regular_11">"from Matt"</span>. (In Windows, the command would be <span class="SANS_TheSansMonoCd_W5Regular_11">findstr "from Matt" SysEvent.evt</span>.) On my Apple MacBook, the log entry created by <span class="SANS_TheSansMonoCd_W5Regular_11">syslog()</span> begins with a formatted date, followed by the computer name (<span class="SANS_TheSansMonoCd_W5Regular_11">matts-MacBook-Pro-2</span>). Next comes the program or service appending to the log (in this case, <span class="SANS_TheSansMonoCd_W5Regular_11">php</span>), followed by the process ID (<span class="SANS_TheSansMonoCd_W5Regular_11">4304</span>), a number assigned by the operating system to uniquely identify each active process. Finally, the entry ends with the message string passed to the <span class="SANS_TheSansMonoCd_W5Regular_11">syslog()</span> function. The contents of each syslog entry are similar for Windows, containing the event type, event ID, source, message, and so on.</p>
<span aria-label="464" epub:type="pagebreak" id="pg_464" role="doc-pagebreak"/>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>If you aren’t comfortable perusing syslog files at the command line, many applications are available for viewing, filtering, and analyzing these files. For example, Windows has Event Viewer, and macOS has Console.</i></p>
</section>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H1" id="sec4"><span id="toc-link_321"/><span class="SANS_Futura_Std_Bold_B_11">The Monolog Logging Library</span></h3>
<p class="TNI1">Logging is so common in web applications that several third-party PHP libraries exist to help with it, including the popular Monolog library. The majority of PHP web frameworks and cloud logging systems provide integration with Monolog. It’s usually the first, and sometimes only, logging system many PHP programmers learn to use. The library makes it easy to develop customized, sophisticated logging strategies, with different types of log entries handled in different ways, and messages being logged to a variety of locations, including local files, cloud-based systems, and more.</p>
<p class="TX">Monolog is compliant with PSR-3, a standards recommendation for PHP logging systems. This standard uses the same eight levels of log severity as the RFC 5424 syslog standard. To be PSR-3 compliant, a logging interface should have methods for each of the eight log levels. Each method should require a string argument containing the message to be logged and an optional array for more information about the context of the message.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>Monolog’s source code and documentation can be found on GitHub at</i> <span class="note_LinkURL"><a href="https://github.com/Seldaek/monolog">https://github.com/Seldaek/monolog</a></span><i>, and you can learn more about the PSR-3 standard at</i> <span class="note_LinkURL"><a href="https://www.php-fig.org/psr/psr-3/">https://www.php-fig.org/psr/psr-3/</a></span><i>.</i></p>
<p class="TX">Let’s create an example project that uses Monolog to log messages. Create a new project folder and then use the command <span class="SANS_TheSansMonoCd_W7Bold_11">composer require monolog/monolog</span> to add the Monolog library. You should now have a <i>composer.json</i> file and a <i>vendor</i> folder with an autoloader and the Monolog library classes. Next, create an index script in <i>public/index.php</i> containing the code in <a href="#lis24-1">Listing 24-1</a>.</p>
<span id="lis24-1"/>
<pre><code>&lt;?php&#13;
require_once __DIR__ . '/../vendor/autoload.php';&#13;
&#13;
use Monolog\Logger;&#13;
use Monolog\Handler\StreamHandler;&#13;
&#13;
$logFile = __DIR__ . '/../logs/mylogs.log';&#13;
&#13;
$logger = new Logger('demo');&#13;
$logger-&gt;pushHandler(new StreamHandler($logFile));&#13;
&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> $logger-&gt;warning('I am a warning.');&#13;
$logger-&gt;error('I am a test error!');</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 24-1: Setting up and using Monolog in</span> <span class="SANS_Futura_Std_Book_11">public/index.php</span></p>
<p class="TX">As usual, our index script begins by requiring the autoloader script. Then we provide <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statements for the Monolog <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">StreamHandler</span> <span aria-label="465" epub:type="pagebreak" id="pg_465" role="doc-pagebreak"/>classes. Next, we declare a path to <i>mylogs.log</i> in the <i>logs</i> folder for this project; this is where we’ll log our messages, but you could provide a path to any file you wish. The first time Monolog tries to append a message to this file, it will create the file and directory if they don’t already exist.</p>
<p class="TX">We next create a new <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> object to manage the logging, providing the channel name <span class="SANS_TheSansMonoCd_W5Regular_11">demo</span>. We’ll explore channels and why they’re useful in the next section. Every <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> object needs one or more <i>log handler</i> classes to tell it what to do with log entries, so we also create a log handler by calling the <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> object’s <span class="SANS_TheSansMonoCd_W5Regular_11">pushHandler()</span> method, passing in a new object of Monolog’s <span class="SANS_TheSansMonoCd_W5Regular_11">StreamHandler</span> class. This is a class for logging messages to files (in our case, the <i>logs/mylogs.log</i> file specified in the <span class="SANS_TheSansMonoCd_W5Regular_11">$logFile</span> variable), but Monolog has different handler classes for other actions, such as logging to the browser, a cloud API, or a database. We’ll explore another log handler in <span class="Xref">“Logging to the Cloud” on <a href="#pg_472">page 472</a></span>.</p>
<p class="TX">Since Monolog is PSR-3 compliant, <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> objects have methods for logging messages with each of the eight standard severity levels. We use two of these methods. First, we use <span class="SANS_TheSansMonoCd_W5Regular_11">warning()</span> to create a warning log entry with the text <span class="SANS_TheSansMonoCd_W5Regular_11">'I am a warning.'</span><span aria-label="annotation1" class="CodeAnnotation">❶</span> Then we use the <span class="SANS_TheSansMonoCd_W5Regular_11">error()</span> method to create an error log entry with the text <span class="SANS_TheSansMonoCd_W5Regular_11">'I am a test error!'</span></p>
<p class="TX">After executing the index script, the contents of <i>logs/mylogs.log</i> should look something like the following:</p>
<pre><code>[2025-01-28T23:26:51.686815 + 00:00] demo.WARNING: I am a warning. [] []&#13;
[2025-01-28T23:26:51.688375 + 00:00] demo.ERROR: I am a test error! [] []</code></pre>
<p class="BodyContinued">Remember, you can view the file at the command line via <span class="SANS_TheSansMonoCd_W5Regular_11">cat</span> (macOS and Unix) or <span class="SANS_TheSansMonoCd_W5Regular_11">type</span> (Windows).</p>
<p class="TX">Notice that each log entry generated by Monolog starts with a timestamp, followed by the channel name and severity level (for example, <span class="SANS_TheSansMonoCd_W5Regular_11">demo .WARNING</span>), followed by the log message. The empty square brackets at the end of each log entry indicate no additional information was provided. We’ll add more information about the context of the log message in <span class="Xref">“Logging Exceptions” on <a href="#pg_469">page 469</a></span>.</p>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="H2" id="sec5"><span id="toc-link_322"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Organizing Logs with Channels</span></h4>
<p class="TNI1">Larger systems are organized into well-defined subsystems, and knowing which subsystems have generated which log entries greatly aids debugging, error tracking, and code evaluations. Monolog makes this possible by giving each <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> object a channel name. By creating multiple <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> objects with unique channel names, you can organize your log based on the source of the entries. For example, an online shop might have channels like <span class="SANS_TheSansMonoCd_W5Regular_11">security</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">database</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">payments</span> for logging different kinds of system events.</p>
<p class="TX">In the previous section, we created our <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> object to be part of the <span class="SANS_TheSansMonoCd_W5Regular_11">demo</span> channel, and we saw how this channel name was included in each log entry. Let’s now modify our project to distinguish between two channels: <span class="SANS_TheSansMonoCd_W5Regular_11">demo</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">security</span>. Update <i>public/index.php</i> to match the contents of <a href="#lis24-2">Listing 24-2</a>.</p>
<span id="lis24-2"/>
<pre><code><span aria-label="466" epub:type="pagebreak" id="pg_466" role="doc-pagebreak"/><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/../vendor/autoload.php';</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">use Monolog\Logger;</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">use Monolog\Handler\StreamHandler;</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$logFile = __DIR__ . '/../logs/mylogs.log';</span>&#13;
&#13;
$demoLogger = new Logger('demo');&#13;
$demoLogger-&gt;pushHandler(new StreamHandler($logFile));&#13;
&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> $securityLogger = $demoLogger-&gt;withName('security');&#13;
&#13;
$demoLogger-&gt;error('I am a test error!');&#13;
$securityLogger-&gt;warning('invalid username entered');</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 24-2: Logging to two separate channels in</span> <span class="SANS_Futura_Std_Book_11">index.php</span></p>
<p class="TX">We create a new <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> object called <span class="SANS_TheSansMonoCd_W5Regular_11">$demoLogger</span> for a channel named <span class="SANS_TheSansMonoCd_W5Regular_11">demo</span> and set its log handler to be a <span class="SANS_TheSansMonoCd_W5Regular_11">StreamHandler</span> to the <i>logs/mylogs.log</i> file. Then we create a second <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> object with a channel named <span class="SANS_TheSansMonoCd_W5Regular_11">security</span>. Next, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">$demoLogger</span> object’s <span class="SANS_TheSansMonoCd_W5Regular_11">withName()</span> method to create a clone of the object with a channel name of <span class="SANS_TheSansMonoCd_W5Regular_11">security</span> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. This saves us from having to create the second Logger object and its log handler (which points to the same file as <span class="SANS_TheSansMonoCd_W5Regular_11">$demoLogger</span>) from scratch.</p>
<p class="TX">We now have two <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> objects, <span class="SANS_TheSansMonoCd_W5Regular_11">$demoLogger</span> (channel name <span class="SANS_TheSansMonoCd_W5Regular_11">demo</span>) and <span class="SANS_TheSansMonoCd_W5Regular_11">$securityLogger</span> (channel name <span class="SANS_TheSansMonoCd_W5Regular_11">security</span>). Both of these <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> objects use the same log handler, writing logs to <i>logs/mylogs.log</i>. Depending on which <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> object we use, we can ensure that log entries are marked with the appropriate channel to aid later logfile analysis. We finish the script by logging a message to each channel. The resulting contents of the <i>logs/mylogs.log</i> file should look something like this:</p>
<pre><code>[2025-01-30T08:54:05.091158 + 00:00]&#13;
  demo.ERROR: I am a test error! [] []&#13;
[2025-01-30T08:54:05.092702 + 00:00]&#13;
  security.WARNING: invalid username entered [] []</code></pre>
<p class="TX">Notice that the error log entry went to the <span class="SANS_TheSansMonoCd_W5Regular_11">demo</span> channel, while the warning entry went to the <span class="SANS_TheSansMonoCd_W5Regular_11">security</span> channel. We could filter the logfile to show entries from just one of the channels by using the Unix <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> or Windows <span class="SANS_TheSansMonoCd_W5Regular_11">findstr</span> commands. For example, we could search for <span class="SANS_TheSansMonoCd_W5Regular_11">security</span> channel entries by entering <span class="SANS_TheSansMonoCd_W5Regular_11">findstr "security." logs/mylogs.log</span> in a Windows command terminal.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H2" id="sec6"><span id="toc-link_323"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Managing Logs According to Severity</span></h4>
<p class="TNI1">Beyond sorting entries into channels, we can add even more sophistication to our logging strategy by treating log entries differently according to their level of severity. Monolog can do this by adding multiple log handlers, collectively referred to as a <i>stack</i>, to the same <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> object. When we add a <span aria-label="467" epub:type="pagebreak" id="pg_467" role="doc-pagebreak"/>log handler, we can optionally specify which severity levels it applies to. We could, for example, have one log handler for the three most severe levels that works with a web API to automatically notify IT staff via text message to address the problem immediately. A second log handler could respond to lower severity levels and record the messages to a logfile.</p>
<p class="TX">Monolog handlers also have an optional feature called <i>bubbling</i> that allows log entries to be processed by one handler and also passed (<i>bubbled</i>) down the stack to be processed again by other log handlers. In addition to high-severity log entries triggering automated messages to IT staff phones, for example, those same log entries could also be stored to a logfile for archive and analysis purposes, along with the low-severity entries. <a href="#fig24-1">Figure 24-1</a> shows an example log handler stack that uses bubbling and manages log entries according to severity.</p>
<figure class="IMG"><a id="fig24-1"/><img alt="" class="img100" height="899" src="../images/figure24-1.jpg" width="1660"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 24-1: Using bubbling and severity levels to create a sophisticated logging strategy</span></p></figcaption>
</figure>
<p class="TX">The diagram illustrates a stack of three log handlers. At the top of the stack, <span class="SANS_TheSansMonoCd_W5Regular_11">handler1</span> catches any log entries of Critical or more importance (severity levels 0 through 2) and records them in <i>immediateActions.log</i>. This first handler has bubbling enabled, so the high-severity log entries are also passed further down the stack for additional processing.</p>
<p class="TX">Next in the stack is <span class="SANS_TheSansMonoCd_W5Regular_11">handler2</span>, which catches all log entries of Info or more importance (levels 0 through 6) and records them in <i>infoActions.log</i>. Thanks to bubbling, the high-severity log entries will therefore be recorded in two separate files. Bubbling is turned off for <span class="SANS_TheSansMonoCd_W5Regular_11">handler2</span>, so any log entries this handler processes won’t be sent down the stack for further action. As a result, the only log entries arriving at the bottom of the log handler stack are those of severity level 7 (Debug). These are received by <span class="SANS_TheSansMonoCd_W5Regular_11">handler3</span> and recorded in <i>debug.log</i>. Notice that <span class="SANS_TheSansMonoCd_W5Regular_11">handler3</span> is set to receive log entries of any <span aria-label="468" epub:type="pagebreak" id="pg_468" role="doc-pagebreak"/>severity, but in practice it will receive only debug entries because all other severity levels stop at <span class="SANS_TheSansMonoCd_W5Regular_11">handler2</span>.</p>
<p class="TX">Let’s modify our project to implement the stack of these three log handlers. To make sure the stack works as expected, we’ll generate log entries for all eight levels of severity and check the contents of the three logs. Update <i>public/index.php</i> as shown in <a href="#lis24-3">Listing 24-3</a>.</p>
<span id="lis24-3"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">require_once __DIR__ . '/../vendor/autoload.php';</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">use Monolog\Logger;</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">use Monolog\Handler\StreamHandler;</span>&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> use Monolog\Level;&#13;
&#13;
&#13;
<span aria-label="annotation2" class="codeannotated_CodeAnnotation">❷</span> $immediateActionFile = __DIR__ . '/../logs/immediateActions.log';&#13;
$logFile = __DIR__ . '/../logs/infoActions.log';&#13;
$debugFile = __DIR__ . '/../logs/debug.log';&#13;
&#13;
<span aria-label="annotation3" class="codeannotated_CodeAnnotation">❸</span> $handler1 = new StreamHandler($immediateActionFile, Level::Critical);&#13;
$handler2 = new StreamHandler($logFile, Level::Info, false);&#13;
$handler3 = new StreamHandler($debugFile);&#13;
&#13;
<span aria-label="annotation4" class="codeannotated_CodeAnnotation">❹</span> $logger = new Logger('logger');&#13;
$logger-&gt;pushHandler($handler3);&#13;
$logger-&gt;pushHandler($handler2);&#13;
$logger-&gt;pushHandler($handler1);&#13;
&#13;
<span aria-label="annotation5" class="codeannotated_CodeAnnotation">❺</span> $logger-&gt;emergency('0 emergency');&#13;
$logger-&gt;alert('1 alert');&#13;
$logger-&gt;critical('2 critical');&#13;
$logger-&gt;error('3 error');&#13;
$logger-&gt;warning(' 4 warning');&#13;
$logger-&gt;notice(' 5 notice');&#13;
$logger-&gt;info('6 info');&#13;
$logger-&gt;debug('7 debug');</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 24-3: Managing log entries by severity level with a stack of three log handlers in</span> <span class="SANS_Futura_Std_Book_11">index.php</span></p>
<p class="TX">First, we have added a <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statement to give us access to the constants in the <span class="SANS_TheSansMonoCd_W5Regular_11">Monolog\Level</span> class <span aria-label="annotation1" class="CodeAnnotation">❶</span>. We declare three variables for the filepaths to <i>immediateActions.log</i>, <i>infoActions.log</i>, and <i>debug.log</i> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Then we create three variables referencing three <span class="SANS_TheSansMonoCd_W5Regular_11">StreamHandler</span> objects <span aria-label="annotation3" class="CodeAnnotation">❸</span>. These will be the three log handlers in our stack.</p>
<p class="TX">For the first, <span class="SANS_TheSansMonoCd_W5Regular_11">$handler1</span>, we pass the path to the immediate actions logfile, and we use the constant <span class="SANS_TheSansMonoCd_W5Regular_11">Level::Critical</span> as the second argument to assign this handler to entries of Critical or greater importance. The handler has bubbling enabled by default. We provide <span class="SANS_TheSansMonoCd_W5Regular_11">$handler2</span> the path to the info actions file and use <span class="SANS_TheSansMonoCd_W5Regular_11">Level::Info</span> to assign it to Info-level log entries or greater (all logs except Debug entries). The third argument of <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> turns bubbling off for <span class="SANS_TheSansMonoCd_W5Regular_11">handler2</span>.</p>
<p class="TX"><span aria-label="469" epub:type="pagebreak" id="pg_469" role="doc-pagebreak"/>To create <span class="SANS_TheSansMonoCd_W5Regular_11">$handler3</span>, we simply pass the path to the debug logfile and omit the other arguments. By default, all log entries will be processed by this handler and bubbling will be enabled. However, the handler will receive only Debug-level entries, and since it will be at the bottom of the stack, no other log handler exists for log entries to bubble down to.</p>
<p class="TX">Next, we create a new <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> object <span aria-label="annotation4" class="CodeAnnotation">❹</span> and assign all three log handlers to it, one at a time. When multiple handlers are added to the same <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> object, the last one added is considered to be at the top of the stack and will get the chance to process all log entries first. Therefore, we add the handlers in reverse order, starting with <span class="SANS_TheSansMonoCd_W5Regular_11">$handler3</span> and ending with <span class="SANS_TheSansMonoCd_W5Regular_11">$handler1</span>. Finally, we log eight messages <span aria-label="annotation5" class="CodeAnnotation">❺</span>, one for each level of severity, with a message confirming the level number and name.</p>
<p class="TX">After executing the index script, the <i>logs/immediateActions.log</i> file should look something like this:</p>
<pre><code>[2025-02-13T10:50:52.818515 + 00:00] logger.EMERGENCY: 0 emergency [] []&#13;
[2022-02-13T10:50:52.820236 + 00:00] logger.ALERT: 1 alert [] []&#13;
[2022-02-13T10:50:52.820352 + 00:00] logger.CRITICAL: 2 critical [] []</code></pre>
<p class="BodyContinued">Only Critical, Alert, and Emergency logs were processed and written to <i>immediateActions.log</i> by <span class="SANS_TheSansMonoCd_W5Regular_11">$handler1</span> at the top of the log handler stack. Here are the contents of <i>logs/infoActions.log</i>:</p>
<pre><code>[2025-02-13T10:50:52.818515 + 00:00] logger.EMERGENCY: 0 emergency [] []&#13;
[2025-02-13T10:50:52.820236 + 00:00] logger.ALERT: 1 alert [] []&#13;
[2025-02-13T10:50:52.820352 + 00:00] logger.CRITICAL: 2 critical [] []&#13;
[2025-02-13T10:50:52.820454 + 00:00] logger.ERROR: 3 error [] []&#13;
[2025-02-13T10:50:52.820509 + 00:00] logger.WARNING:  4 warning [] []&#13;
[2025-02-13T10:50:52.820563 + 00:00] logger.NOTICE:  5 notice [] []&#13;
[2025-02-13T10:50:52.820617 + 00:00] logger.INFO: 6 info [] []</code></pre>
<p class="BodyContinued">All logs from levels 0 to 6 were processed and written to <i>infoActions.log</i> by <span class="SANS_TheSansMonoCd_W5Regular_11">$handler2</span> from the middle of the log handler stack. Since we’ve already seen the level 0, 1, and 2 logs in <i>immediateActions.log</i> from <span class="SANS_TheSansMonoCd_W5Regular_11">$handler1</span>, seeing them again in <i>infoActions.log</i> confirms that the bubbling mechanism has worked, allowing these logs to also be received by <span class="SANS_TheSansMonoCd_W5Regular_11">$handler2</span>. Finally, here are the contents of the <i>logs/debug.log</i> file:</p>
<pre><code>[2025-02-13T10:50:52.820672 + 00:00] logger.DEBUG: 7 debug [] []</code></pre>
<p class="BodyContinued">Only the entry for severity level 7 (Debug) can be seen in <i>debug.log</i>. This demonstrates that <span class="SANS_TheSansMonoCd_W5Regular_11">$handler3</span> at the bottom of the stack received only this single log entry.</p>
</section>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H1" id="sec7"><span id="toc-link_324"/><span class="SANS_Futura_Std_Bold_B_11">Logging Exceptions</span></h3>
<p class="TNI1">A common use of logs is to record when exceptions occur during program execution. In <span class="Xref"><a href="chapter23.xhtml">Chapter 23</a></span>, we explored how programs can be organized around <span class="SANS_TheSansMonoCd_W5Regular_11">try...catch</span> statements: a <span class="SANS_TheSansMonoCd_W5Regular_11">try</span> statement with the code that should <span aria-label="470" epub:type="pagebreak" id="pg_470" role="doc-pagebreak"/>execute under normal circumstances, and a <span class="SANS_TheSansMonoCd_W5Regular_11">catch</span> statement for handling exceptions. When an application uses logging, the exceptions are logged as part of the <span class="SANS_TheSansMonoCd_W5Regular_11">catch</span> statement.</p>
<p class="TX">Let’s create a simple, single-class project to illustrate how to do this. Our project will have a <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> class that throws an exception when we try to create a <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object with a negative price. We’ll use Monolog to log those exceptions to a <i>logs/debug.log</i> file. We’ll begin by declaring the <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> class. Create a new project with <i>src/Product.php</i> containing the code in <a href="#lis24-4">Listing 24-4</a>.</p>
<span id="lis24-4"/>
<pre><code>&lt;?php&#13;
namespace Mattsmithdev;&#13;
&#13;
class Product&#13;
{&#13;
    private string $name;&#13;
    private float $price;&#13;
&#13;
    public function __construct(string $name, float $price)&#13;
    {&#13;
      <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> if ($price &lt; 0) {&#13;
            throw new \Exception(&#13;
                'attempting to set price to a negative value');&#13;
        }&#13;
&#13;
        $this-&gt;price = $price;&#13;
        $this-&gt;name = $name;&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 24-4: A</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Product</span> <span class="SANS_Futura_Std_Book_Oblique_11">class that throws an exception</span></p>
<p class="TX">We declare the <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> class in the <span class="SANS_TheSansMonoCd_W5Regular_11">Mattsmithdev</span> namespace and give it two private properties, <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">price</span>. The class’s constructor method takes in <span class="SANS_TheSansMonoCd_W5Regular_11">$name</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$price</span> values for the new object being created. Within the constructor, we validate the <span class="SANS_TheSansMonoCd_W5Regular_11">$price</span> argument and throw an exception if its value is negative <span aria-label="annotation1" class="CodeAnnotation">❶</span>. For this simple example, we’re using PHP’s root <span class="SANS_TheSansMonoCd_W5Regular_11">Exception</span> class.</p>
<p class="TX">We now need to create a <i>composer.json</i> file to autoload the class. <a href="#lis24-5">Listing 24-5</a> shows how.</p>
<span id="lis24-5"/>
<pre><code>{&#13;
    "autoload": {&#13;
        "psr-4": {&#13;
            "Mattsmithdev\\": "src"&#13;
        }&#13;
    }&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 24-5: The</span> <span class="SANS_Futura_Std_Book_11">composer.json</span> <span class="SANS_Futura_Std_Book_Oblique_11">file</span></p>
<p class="TX">Next, use Composer at the command line to generate the autoloader scripts and add the Monolog library to the project:</p>
<pre><code><span aria-label="471" epub:type="pagebreak" id="pg_471" role="doc-pagebreak"/>$ <b>composer dump-autoload</b>&#13;
$ <b>composer require monolog/monolog</b></code></pre>
<p class="TX">Now we need to write an index script that attempts to create a <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object and logs the exception if the attempt is unsuccessful. Create <i>public/index.php</i> to match <a href="#lis24-6">Listing 24-6</a>.</p>
<span id="lis24-6"/>
<pre><code>&lt;?php&#13;
require_once __DIR__ . '/../vendor/autoload.php';&#13;
&#13;
use Mattsmithdev\Product;&#13;
use Monolog\Logger;&#13;
use Monolog\Handler\StreamHandler;&#13;
&#13;
$debugFile = __DIR__ . '/../logs/debug.log';&#13;
$logger = new Logger('demo');&#13;
$logger-&gt;pushHandler(new StreamHandler($debugFile));&#13;
&#13;
try {&#13;
    $p1 = new Product('hammer', -1);&#13;
} catch (\Exception $e) {&#13;
  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> $logger-&gt;error('problem creating new product', ['exception' =&gt; $e]);&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 24-6: Attempting to create an invalid</span> <span class="TheSansMonoCd_W5Regular_Italic_11">Product</span> <span class="SANS_Futura_Std_Book_Oblique_11">object in</span> <span class="SANS_Futura_Std_Book_11">index.php</span></p>
<p class="TX">First, we read and execute the autoloader and add <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statements for the classes we need. Then we get set up for logging by creating a variable for the <i>logs/debug.log</i> filepath, creating a new <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> object for a channel named <span class="SANS_TheSansMonoCd_W5Regular_11">demo</span> and giving it a log handler. Next, inside a <span class="SANS_TheSansMonoCd_W5Regular_11">try</span> block, we create a new <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> object, passing <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span> for the price. In the related <span class="SANS_TheSansMonoCd_W5Regular_11">catch</span> block, we log an entry of Error-level severity with the <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> object if creating the product fails <span aria-label="annotation1" class="CodeAnnotation">❶</span>.</p>
<p class="TX">In addition to providing a message to log (<span class="SANS_TheSansMonoCd_W5Regular_11">'problem creating new product'</span>), we include an array as the second argument to log additional information. Specifically, we pass the entire <span class="SANS_TheSansMonoCd_W5Regular_11">Exception</span> object <span class="SANS_TheSansMonoCd_W5Regular_11">$e</span> and give it the key <span class="SANS_TheSansMonoCd_W5Regular_11">exception</span>. In the Monolog documentation, this optional array is called the <i>context</i> of the log entry. It can contain multiple elements with keys of your choosing, which can be helpful when reviewing the logs and analyzing them for patterns.</p>
<p class="TX">After executing the index script, the <i>logs/debug.log</i> file should look something like this:</p>
<pre><code>[2025-01-25T11:48:46.813377 + 00:00] demo.ERROR: problem creating new product&#13;
{"exception":"[object] (Exception(code: 0): attempting to set price to a&#13;
negative value at /Users/matt/src/Product.php:15)"} []</code></pre>
<p class="TX">An Error-level log has been added to the logfile for the <span class="SANS_TheSansMonoCd_W5Regular_11">demo</span> channel, with the message <span class="SANS_TheSansMonoCd_W5Regular_11">problem creating new product</span>. The log entry also contains the details of the <span class="SANS_TheSansMonoCd_W5Regular_11">Exception</span> object that was thrown by the <span class="SANS_TheSansMonoCd_W5Regular_11">Product</span> constructor method, including the message associated with the exception (<span class="SANS_TheSansMonoCd_W5Regular_11">attempting to set price to a negative value</span>) and the location of the exception-triggering code.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<span aria-label="472" epub:type="pagebreak" id="pg_472" role="doc-pagebreak"/>
<h3 class="H1" id="sec8"><span id="toc-link_325"/><span class="SANS_Futura_Std_Bold_B_11">Logging to the Cloud</span></h3>
<p class="TNI1">So far we’ve been logging messages to files, but most large-scale web applications log to a dedicated cloud-based logging system rather than to files on the server. One popular cloud logging system is Mezmo (previously LogDNA). Using a cloud logging API such as Mezmo provides many benefits, including historical storage of logs, powerful filtering and search features, and comprehensive analytical and reporting features. Cloud logging APIs such as Mezmo can also be linked to alert notification systems such as Atlassian’s Opsgenie to send the email or text alerts for log entries requiring immediate actions.</p>
<p class="TX">Let’s create a project that sends log entries to Mezmo. We’ll log to two separate channels and try out entries of each severity level. First, visit the Mezmo website (<i><a href="https://www.mezmo.com">https://www.mezmo.com</a></i>) and create a free account. Make a note of the unique hexadecimal Mezmo ingestion key created for you in your account details; you’ll need to reference it in your script.</p>
<p class="TX">To interact with Mezmo from your PHP code, we’ll use the <span class="SANS_TheSansMonoCd_W5Regular_11">monolog -logdna</span> package, maintained by Nicolas Vanheuverzwijn. This package adds Mezmo API communication capabilities to Monolog. Create a new project folder and add the package by entering <span class="SANS_TheSansMonoCd_W7Bold_11">composer require nvanheuverzwijn/monolog-logdna</span> at the command line. You should now have a <i>composer.json</i> file and a <i>vendor</i> folder containing an autoloader and the Monolog and other library classes for logging to the Mezmo API. Now create an index script in <i>public/index.php</i> containing the code in <a href="#lis24-7">Listing 24-7</a>.</p>
<span id="lis24-7"/>
<pre><code>&lt;?php&#13;
require_once __DIR__ . '/../vendor/autoload.php';&#13;
&#13;
use Monolog\Logger;&#13;
use Zwijn\Monolog\Handler\LogdnaHandler;&#13;
&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> $INGESTION_KEY='<span class="TheSansMonoCd_W5Regular_Italic_11">your-MEZMO-ingestion-key-goes-here</span>';&#13;
&#13;
&#13;
$generalLogger = new Logger('general');&#13;
$handler = new LogdnaHandler($INGESTION_KEY, 'host-mgw.com');&#13;
$generalLogger-&gt;pushHandler($handler);&#13;
&#13;
<span aria-label="annotation2" class="codeannotated_CodeAnnotation">❷</span> $generalLogger-&gt;emergency('0 emergency');&#13;
$generalLogger-&gt;alert('1 alert');&#13;
$generalLogger-&gt;critical('2 critical');&#13;
$generalLogger-&gt;error('3 error');&#13;
$generalLogger-&gt;warning(' 4 warning');&#13;
$generalLogger-&gt;notice(' 5 notice');&#13;
$generalLogger-&gt;info('6 info');&#13;
$generalLogger-&gt;debug('7 debug');&#13;
&#13;
<span aria-label="annotation3" class="codeannotated_CodeAnnotation">❸</span> $securityLogger = $generalLogger-&gt;withName('security');&#13;
$securityLogger-&gt;debug('7 debug - from security channel',&#13;
    ['context-1' =&gt; 'some data']);</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 24-7: Setting up and using Monolog in</span> <span class="SANS_Futura_Std_Book_11">public/index.php</span></p>
<p class="TX"><span aria-label="473" epub:type="pagebreak" id="pg_473" role="doc-pagebreak"/>We provide <span class="SANS_TheSansMonoCd_W5Regular_11">use</span> statements for Monolog’s <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> class and for <span class="SANS_TheSansMonoCd_W5Regular_11">LogDnaHandler</span>, the log handler needed to log to Mezmo. Then we declare a variable for the necessary Mezmo ingestion key; be sure to fill in your own key here <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Next, we create a new <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> object named <span class="SANS_TheSansMonoCd_W5Regular_11">$generalLogger</span>, providing <span class="SANS_TheSansMonoCd_W5Regular_11">general</span> as the channel name, and we give it a log handler, passing the ingestion key and naming the host source of logs as <span class="SANS_TheSansMonoCd_W5Regular_11">host-mgw.com</span> (short for My Great Website, as usual). Different web applications or subsites could use different hostnames in their handlers, to further differentiate the source of logs.</p>
<p class="TX">We log eight messages to our <span class="SANS_TheSansMonoCd_W5Regular_11">$generalLogger</span> object <span aria-label="annotation2" class="CodeAnnotation">❷</span>, one for each level of severity, with a message confirming the level number and name. Then we save a bit of work by using the <span class="SANS_TheSansMonoCd_W5Regular_11">withName()</span> method to create a clone of the <span class="SANS_TheSansMonoCd_W5Regular_11">$generalLogger</span> object called <span class="SANS_TheSansMonoCd_W5Regular_11">$securityLogger</span> with a channel name of <span class="SANS_TheSansMonoCd_W5Regular_11">security</span> <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Both <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> objects use the same log handler and so can send logs to the Mezmo API. We use this second object to log a debug entry, passing a second argument of a single-element array with the <span class="SANS_TheSansMonoCd_W5Regular_11">'context-1'</span> key and <span class="SANS_TheSansMonoCd_W5Regular_11">'some data'</span> data string. This tests how we might record extra data in a log entry.</p>
<p class="TX"><a href="#fig24-2">Figure 24-2</a> shows the logs from our executed index script, received and displayed on the Mezmo site.</p>
<figure class="IMG"><a id="fig24-2"/><img alt="" class="img100" height="1193" src="../images/figure24-2.jpg" width="1689"/>
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 24-2: Log entries on the Mezmo cloud service</span></p></figcaption>
</figure>
<p class="TX">Mezmo shows timestamped logs from the <span class="SANS_TheSansMonoCd_W5Regular_11">general</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">security</span> channels, with all entries coming from <span class="SANS_TheSansMonoCd_W5Regular_11">host-mgw</span>. Each entry is marked with its <span aria-label="474" epub:type="pagebreak" id="pg_474" role="doc-pagebreak"/>severity level. The details of the final log, to the <span class="SANS_TheSansMonoCd_W5Regular_11">security</span> channel, have been expanded in the figure, revealing the context data we passed to the <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> object via an array.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H1" id="sec9"><span id="toc-link_326"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>
<p class="TNI1">As you’ve seen in this chapter, you can create logs for a web application in several ways, from simple <span class="SANS_TheSansMonoCd_W5Regular_11">error_log()</span> function calls to the sophisticated <span class="SANS_TheSansMonoCd_W5Regular_11">Monolog</span> open source logging library package to APIs like Mezmo for cloud storage and analytics. The scale and importance of each project will determine the most appropriate approach to take, but for almost all projects that you need to quality-assure and maintain, you’ll probably have to adopt some form of logging to record and manage errors and exceptions, and to collect historical data about use and performance of the system.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H1" id="sec10"><span id="toc-link_327"/><span class="SANS_Futura_Std_Bold_B_11">Exercises</span></h3>
<p class="ListNumber">1.   Create message entries by using both the <span class="SANS_TheSansMonoCd_W5Regular_11">syslog()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">error_log()</span> functions. Locate the files that these functions write to on your computer system and view your messages in the logfiles.</p>
<p class="ListNumber">2.   Create a new project and use Composer to add the Monolog package. In your index script, create a new <span class="SANS_TheSansMonoCd_W5Regular_11">Logger</span> object for a channel named <span class="SANS_TheSansMonoCd_W5Regular_11">general</span>, and add a <span class="SANS_TheSansMonoCd_W5Regular_11">StreamHandler</span> to append logs to the <i>logs/mylogs.log</i> file. Log several entries of different severity levels, and view the log entries in your logfile after executing your index script.</p>
<p class="ListNumber">3.   Create a new project with a stack of two handlers: <span class="SANS_TheSansMonoCd_W5Regular_11">handler1</span> (appending to the <i>urgent.log</i> file) and <span class="SANS_TheSansMonoCd_W5Regular_11">handler2</span> (appending to the <i>other.log</i> file). Add <span class="SANS_TheSansMonoCd_W5Regular_11">handler2</span> first so that <span class="SANS_TheSansMonoCd_W5Regular_11">handler1</span> will be on the top of the stack. Turn off bubbling for <span class="SANS_TheSansMonoCd_W5Regular_11">handler1</span> and configure it to catch all log entries of Critical or more importance. Generate log entries for all eight levels of severity. You should see log entries of severity 0, 1, and 2 in <i>urgent.log</i>, and all others (3 through 7) in <i>other.log</i>.</p>
<p class="ListNumber">4.   Create an account at a cloud logging site such as Mezmo, and update the project from Exercise 3 to log entries to that site’s API. View the logs online to confirm that your program successfully sent them via the API.</p>
</section>
</section>
</div></body></html>