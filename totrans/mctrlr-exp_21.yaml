- en: '**21  CMOS VLSI Interlude**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Way back in [Chapter 18](ch18.xhtml#ch18), we took a step away from breaking
    chips to quickly study how dice were packaged. We saw that after being sawn apart,
    dice were glued to a lead frame and then wire bonded to pins. The entire frame
    was then encased in epoxy, after which the pins would be bent to the right shape
    and the excess of the frame would be cut away. In this chapter, we’ll take a deeper
    look into how chips are designed and manufactured. This won’t be as thorough as
    a real book on VLSI, so please study one of those books if you need to know this
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Very large scale integration (VLSI) is the technology by which millions or even
    billions of metal oxide semiconductor (MOS) transistors are placed onto microchips.
    These transistors are combined into a few hundred unique logical units called
    *basic blocks*, which are small sets of transistors that implement a particular
    function, like a logic gate or a memory cell. Those blocks are placed and routed
    to form intellectual property (IP) blocks of a VLSI chip. Larger IP blocks would
    be things like the CPU, SRAM, mask ROM, and flash ROM. IP blocks might be designed
    by hand, or they might be designed in a high-level language like Verilog or VHDL.
  prefs: []
  type: TYPE_NORMAL
- en: That explanation works a high level, but important details are missing. What
    does a basic block look like for logic, and are memories also constructed out
    of these blocks? Let’s take a look and see.
  prefs: []
  type: TYPE_NORMAL
- en: '**Process Layers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We learned in [Chapter 18](ch18.xhtml#ch18) that lithography is used to place
    chemical layers onto a wafer and then selectively etch them away. These are stacked
    in a consistent order for any given process, and in this section we will cover
    the stack as it is ordered after manufacturing. This is somewhat different than
    the order in which they are manufactured, as the fab sometimes digs down through
    a layer to place a different layer lower in the chip.
  prefs: []
  type: TYPE_NORMAL
- en: The process starts with a large wafer made out of silicon. Layers are stacked
    onto the *frontside* of the silicon, while the *backside* of the silicon remains
    blank. In most encapsulated chips, the frontside faces away from the circuit board,
    but there are exceptions like the MYK82 chip that we’ll dump in [Chapter 24](ch24.xhtml#ch24).
    Some devices with wafer-level chip-scale packaging (WL-CSP) have no encapsulation;
    they place solder balls on the frontside of the die.
  prefs: []
  type: TYPE_NORMAL
- en: Pure silicon isn’t very useful for doing things, so even though we start with
    pure silicon, we usually dope it into *n-type* or *p-type*. These are named for
    their charge, with n-type having a negative charge and p-type having a positive
    charge.
  prefs: []
  type: TYPE_NORMAL
- en: At the very bottom, we have a p-type *substrate* layer that covers the entire
    surface area of the wafer. NMOS transistors can be placed directly on this substrate,
    but PMOS transistors must be placed inside an *n-well*, which is dug into the
    substrate. We’ll come back to the difference between NMOS and PMOS transistors
    in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Above the p-substrate and the n-well, we have a *diffusion* layer that holds
    both n-type and p-type silicon at roughly the same depth. These are *implanted*
    into the exposed p-substrate or n-well by firing charged ions through a mask.
  prefs: []
  type: TYPE_NORMAL
- en: Above the diffusion layer, we have *polysilicon*. Polysilicon is most important
    as the inputs of NMOS and PMOS transistors. Wherever you see a polysilicon trace
    between two of the same diffusion type (p or n), that’s a transistor. In digital
    logic, it’s easiest to think of a transistor as a switch; current flow between
    the diffusions is turned on and off by the input on the polysilicon.
  prefs: []
  type: TYPE_NORMAL
- en: Above the polysilicon, we have metal layers that are used to wire pieces of
    the chip together. In the Seventies, there would be just one metal layer. The
    open source SKY130 process has five metal layers, and the MOSIS 200 nm process
    has six. Processes with nine and ten layers became common by 2003\. In old chips,
    this metal would be a aluminum (Al) but now copper (Cu) is quite common.
  prefs: []
  type: TYPE_NORMAL
- en: SKY130 and MOSIS are both reasonably open processes. This is the exception rather
    than the rule, and for many chips that you look at, you will not have the luxury
    of low-level process documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Chips with multiple metal layers will be routed much like a printed circuit
    board, but on chips with just one metal layer, it’s common to see metal routed
    to a short length of polysilicon without a transistor. This is a means of crossing
    wires without connecting them.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not exactly a separate layer, but you will notice that sometimes metal
    gets a little darker over polysilicon or diffusion. This is a *contact* or *via*
    between layers.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve skipped a few layers to focus on what’s important for reverse engineering
    and to keep the explanation generic to many foundries. These include oxide layers
    to insulate between the functional layers, cap layers that are used to build capacitors
    from metal layers, and other doohickies that are not fundamental to CMOS but are
    handy for making chips in the real world. To learn more about these for any real
    process, you will need to find the documentation from the process development
    kit of the relevant foundry.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0196-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.1: SKY130 NMOS Transistor Cross Section'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0196-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.2: SKY130 PMOS Transistor Cross Section'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0197-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.3: CMOS Inverter Schematic'
  prefs: []
  type: TYPE_NORMAL
- en: '**NMOS and PMOS Transistors**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we understand the layers and the order in which they are stacked,
    let’s take a look at how to build useful logic out of these pieces. CMOS logic
    is built from two types of transistors: NMOS and PMOS.'
  prefs: []
  type: TYPE_NORMAL
- en: NMOS transistors conduct when the input is high, pulling the output down to
    low voltage. PMOS transistors conduct when the input is low, pulling the output
    up to high voltage. Any given gate will have both types of transistors, balanced
    so that the NMOS transistors are pulling up when the output is high and the PMOS
    transistors are pulling down when the output is low.^([1](footnotes.xhtml#ch21fn1))
  prefs: []
  type: TYPE_NORMAL
- en: To make a transistor, a line of polysilicon is placed on a diffusion, separating
    it in half. The polysilicon is the input or *gate* connection, controlling current
    flow between the two halves of the diffusion, which we call the *source* and the
    *drain*. This structure with n-type diffusion over a p-substrate is an NMOS transistor,
    and the same structure with p-type diffusion over an n-well is a PMOS transistor.
  prefs: []
  type: TYPE_NORMAL
- en: See [Figures 21.1](ch21.xhtml#ch21fig1) and [21.2](ch21.xhtml#ch21fig2) for
    cross sections of transistors in the SKY130 process, including some extra details
    that I’ve skipped in this explanation. In those figures, `N` and `P` describe
    the diffusion traces that become the source and drain of the transistor. The gate
    of the transistor is the polysilicon trace that sits above and between them.
  prefs: []
  type: TYPE_NORMAL
- en: On particularly old chips, you will find that NMOS transistors are used alone,
    with pull-up resistors in lieu of PMOS transistors. This isn’t efficient by modern
    standards, but it was quite functional and saved the step of having to place an
    n-well layer or p-type diffusion at fabrication.
  prefs: []
  type: TYPE_NORMAL
- en: These two transistor types are enough to build any form of digital logic, but
    there’s a third, called a *floating gate transistor*, that’s found in EPROM and
    flash memory. Floating gate transistors are much like NMOS, except that there
    are two layers of polysilicon stacked on top of one another. The upper polysilicon
    is the *control* gate, while the lower one is the floating gate. By *floating*,
    we mean that it is electrically disconnected and holds a charge that can be read
    through the source and the drain.
  prefs: []
  type: TYPE_NORMAL
- en: To emphasize that everything changes with the process, I should tell you that
    the floating gate is sometimes made out of silicon nitride in a technology called
    SONOS. This is very important for flash memory quality and density, but it is
    a complication that we won’t pay much attention to in this book.
  prefs: []
  type: TYPE_NORMAL
- en: A floating gate transistor is *programmed* to a zero or *erased* to a one. Programming
    is performed by holding the source and the drain low while setting the gate high;
    this adds electrons to the floating gate and makes the transistor less conductive
    between the source and the drain. Erasure is performed the opposite way, setting
    both diffusions high while the control gate is low, so that electrons flow out
    of the floating gate and the transistor is more conductive between the diffusions.
  prefs: []
  type: TYPE_NORMAL
- en: Floating gate transistors can also be erased by ultraviolet light, as we saw
    in [Chapter 19](ch19.xhtml#ch19). In the early days, devices would use this as
    their only form of erasure, and those without quartz windows were effectively
    single-use. Later chips added circuitry for electrical erasure, eliminating the
    need for ultraviolet erasure in development.
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Blocks**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So now we understand that particular shapes will make transistors, that CMOS
    is built from two complementary types of transistors, and that an entire microchip’s
    behavior is defined by microscopic shapes on the die.
  prefs: []
  type: TYPE_NORMAL
- en: Chip designers usually first choose a company that’s going to fabricate their
    chip, and then choose a process design kit (PDK) from the list of processes that
    the factory or *fab* supports. For any given process, a PDK must be written to
    describe the basic blocks of the process along with simulation data about their
    characteristics, such as timing and voltage range.
  prefs: []
  type: TYPE_NORMAL
- en: A few design kits were published for use in university courses or for multi-project
    wafers such as MOSIS. More recently, the 130 nm process that Cypress used around
    2001 has been open sourced as the SKY130 PDK. If you ever wonder what a cell might
    look like, it’s handy to render that cell from a few of these PDKs to see how
    they implement it. There’s no guarantee that your process will look similar, of
    course.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 21.4](ch21.xhtml#ch21fig4) is a simplified rendering of a CMOS inverter
    for the SKY130 process, taken from an example by Matt Venn.^([2](footnotes.xhtml#ch21fn2))
    The input *A* comes on the small metal piece on the left side of the block, the
    output *Q* on the longer metal piece on the right side. Voltage comes from the
    top and ground from the bottom, just like the schematic of the same inverter in
    [Figure 21.3](ch21.xhtml#ch21fig3). This cell is viewed from above, and if you
    look carefully, you should see that the PMOS transistor at the top matches the
    cross section in [Figure 21.2](ch21.xhtml#ch21fig2) and the NMOS transistor at
    the bottom matches the cross section in [Figure 21.1](ch21.xhtml#ch21fig1).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0200-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.4: CMOS Inverter Layout'
  prefs: []
  type: TYPE_NORMAL
- en: The PDK will include thousands of these cells to represent digital logic gates,
    flip-flops and passives like resistors and capacitors. Many of these are variants
    for lower power or faster reaction time, so only a few hundred of them will make
    it into a given design. They usually appear in regular rows for the convenience
    of the power rails, with metal layer wires connecting them to one another. Where
    this is arranged by VLSI software with no obvious rhyme or reason, we call it
    a *sea of gates*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Large Structures**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we should consider the case of large structures. Basic blocks can be
    placed and routed to form any logic you’d like, but the result is far from efficient
    when implementing things like memories.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, chip designers will use a compiler of sorts to produce a memory of
    just the dimensions that are needed. This is not only useful for densely packing
    the bits of a memory, but also for ensuring that the memory meets timing and electrical
    requirements. See Guthaus et al. (2016) for an open source example of a RAM compiler
    and Walker (2023) for an extension of that compiler that supports mask ROMs.
  prefs: []
  type: TYPE_NORMAL
- en: Reading these papers, you’ll see that memories often scale poorly, working just
    fine at one size but collapsing in performance as they grow just a few sizes larger.
    When you see microcontrollers with a small memory size repeated multiple times,
    such as some members of the TMS320 family, this is why.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 22](ch22.xhtml#ch22), we will see how to extract the contents of
    ROMs by chemically revealing them and then processing the photographs. Fear not,
    it’s a lot easier than reverse engineering the rest of the chip.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reverse Engineering**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By this point, you should understand that a chip’s logic is made from standard
    cells. These cells are tiled onto the design and then wired together in the metal
    layers, and perhaps also with a little polysilicon. If we can photograph these
    and annotate them, why not reverse engineer the logic of the chip?
  prefs: []
  type: TYPE_NORMAL
- en: Reverse engineering the chip logic usually begins with identifying basic blocks
    on photographs of a delayered chip. After a basic block is reverse engineered
    once, the same shape can be identified across the chip to identify all other copies
    of the block. Once the blocks have been identifying, the wiring between basic
    blocks can then be traced and decoded into the digital logic that it implements.
  prefs: []
  type: TYPE_NORMAL
- en: Degate is an open source CAD tool for doing this sort of work, first building
    a library of basic blocks. It has demo projects for a DECT telephone’s controller
    chip and the Legic Prime RFID tag, each of which is decomposed into Verilog code
    that matches the device behavior.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible to perform the reverse engineering with layered image editing
    software like Inkscape. Layer images of the 6502 can be found in Visual6502 (2010),
    from which the project recovered all gates into an accurate simulation. For Yamaha’s
    OPEN series of FM audio synthesizer chips, Raki (2024) offers SVG files describing
    the standard cells and wiring, as well as reverse engineered schematics.
  prefs: []
  type: TYPE_NORMAL
