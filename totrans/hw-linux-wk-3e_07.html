<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="167" id="Page_167"/>7</span><br/>
<span class="ChapterTitle">System Configuration: Logging, System Time, Batch Jobs, and Users</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">When you first look in the <em>/etc</em> directory to explore your system’s configuration, you might feel a bit overwhelmed. The good news is that although most of the files you see affect a system’s operations to some extent, only a few are fundamental.</p>
<p>This chapter covers the parts of the system that make the infrastructure discussed in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> available to the user-space software that we normally interact with, such as the tools covered in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>. In particular, we’ll look at the following:</p>
<ul>
<li>System logging</li>
<li>Configuration files that the system libraries access to get server and user information</li>
<li><span epub:type="pagebreak" title="168" id="Page_168"/>A few selected server programs (sometimes called <em>daemons</em>) that run when the system boots</li>
<li>Configuration utilities that can be used to tweak the server programs and configuration files</li>
<li>Time configuration</li>
<li>Periodic task scheduling</li>
</ul>
<p>The widespread use of systemd has reduced the number of basic, independent daemons found on a typical Linux system. One example is the system logging (syslogd) daemon, whose functionality is now largely provided by a daemon built into systemd (journald). Still, a few traditional daemons remain, such as crond and atd.</p>
<p>As in previous chapters, this chapter includes virtually no networking material because the network is a separate building block of the system. In <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>, you’ll see where the network fits in.</p>
<h2 id="h1-500402c07-0001">	7.1	System Logging</h2>
<p class="BodyFirst">Most system programs write their diagnostic output as messages to the <em>syslog</em> service. The traditional syslogd daemon performs this service by waiting for messages and, upon receiving one, sending it to an appropriate channel, such as a file or a database. On most contemporary systems, journald (which comes with systemd) does most of the work. Though we’ll concentrate on journald in this book, we’ll also cover many aspects of the traditional syslog.</p>
<p>The system logger is one of the most important parts of the system. When something goes wrong and you don’t know where to start, it’s always wise to check the log. If you have journald, you’ll do this with the <code>journalctl</code> command, which we’ll cover in <span class="xref" itemid="xref_target_Section 7.1.2">Section 7.1.2</span>. On older systems, you’ll need to check the files themselves. In either case, log messages look like this:</p>
<pre><code>Aug 19 17:59:48 duplex sshd[484]: Server listening on 0.0.0.0 port 22.</code></pre>
<p>A log message typically contains important information such as the process name, process ID, and timestamp. There can also be two other fields: the <em>facility</em> (a general category) and <em>severity</em> (how urgent the message is). We’ll discuss those in more detail later.</p>
<p>Understanding logging in a Linux system can be somewhat challenging due to varied combinations of older and newer software components. Some distributions, such as Fedora, have moved to a journald-only default, while others run a version of the older syslogd (such as rsyslogd) alongside journald. Older distributions and some specialized systems may not use systemd at all and have only one of the syslogd versions. In addition, some software systems bypass standardized logging altogether and write their own.</p>
<h3 id="h2-500402c07-0001"><span epub:type="pagebreak" title="169" id="Page_169"/>7.1.1	Checking Your Log Setup</h3>
<p class="BodyFirst">You should inspect your own system to see what sort of logging is installed. Here’s how:</p>
<ol class="decimal">
<li value="1">Check for journald, which you almost certainly have if you’re running systemd. Although you can look for journald in a process listing, the easiest way is to simply run <code>journalctl</code>. If journald is active on your system, you’ll get a paged list of log messages.</li>
<li value="2">Check for rsyslogd. Look for rsyslogd in a process listing, and look for <em>/etc/rsyslog.conf</em>.</li>
<li value="3">If you don’t have rsyslogd, check for syslog-ng (another version of syslogd) by looking for a directory called <em>/etc/syslog-ng</em>.</li>
</ol>
<p>Continue your tour by looking in <em>/var/log</em> for logfiles. If you have a version of syslogd, this directory should contain many files, most created by your syslog daemon. However, there will be a few files here that are maintained by other services; two examples are <em>wtmp</em> and <em>lastlog</em>, the logfiles that utilities such as <code>last</code> and <code>lastlog</code> access in order to get login records.</p>
<p>In addition, there may be further subdirectories in <em>/var/log</em> containing logs. These nearly always come from other services. One of them, <em>/var/log/journal</em>, is where journald stores its (binary) logfiles.</p>
<h3 id="h2-500402c07-0002">7.1.2	Searching and Monitoring Logs</h3>
<p class="BodyFirst">Unless you have a system without journald or you’re searching a logfile maintained by some other utility, you’ll look through the journal. With no arguments, the <code>journalctl</code> access tool is like a fire hose, giving you all of the messages in the journal, starting with the oldest (just as they would appear in a logfile). Mercifully, <code>journalctl</code> defaults to using a pager such as <code>less</code> to display messages so your terminal won’t be flooded. You can search messages with the pager and reverse the message time order with <code>journalctl -r</code>, but there are much better ways of finding logs.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	To get full access to the journal messages, you need to run <var>journalctl</var> either as root or as a user belonging to the adm or systemd-journal groups. The default user on most distributions has access.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>In general, you can search individual fields of journals just by adding them to the command line; for example, run <code>journalctl _PID=8792</code> to search for messages from process ID 8792. However, the most powerful filtering features are more general in nature. You can specify one or more if you need multiple criteria.</p>
<h4 id="h3-500402c07-0001">Filtering by Time</h4>
<p class="BodyFirst">The <code>-S</code> (since) option is among the most useful in narrowing in on a specific time. Here’s an example of one of the easiest and most effective ways to use it:</p>
<pre><code>$ <b>journalctl -S -4h</b></code></pre>
<p><span epub:type="pagebreak" title="170" id="Page_170"/>The <code>-4h</code> part of this command may look like an option, but in reality, it’s a time specification telling <code>journalctl</code> to search for messages from the past four hours in your current time zone. You can also use a combination of a specific day and/or time:</p>
<pre><code>$ <b>journalctl -S 06:00:00</b>
$ <b>journalctl -S 2020-01-14</b>
$ <b>journalctl -S '2020-01-14 14:30:00'</b></code></pre>
<p>The <code>-U</code> (until) option works the same way, specifying a time up to which <code>journalctl</code> should retrieve messages. However, it’s often not as useful because you’ll typically page or search through messages until you find what you need, then just quit.</p>
<h4 id="h3-500402c07-0002">Filtering by Unit</h4>
<p class="BodyFirst">Another quick and effective way to get at relevant logs is to filter by systemd unit. You can do this with the <code>-u</code> option, like this:</p>
<pre><code>$ <b>journalctl -u cron.service</b></code></pre>
<p>You can normally omit the unit type (<code>.service</code> in this case) when filtering by unit.</p>
<p>If you don’t know the name of a particular unit, try this command to list all units in the journal:</p>
<pre><code>$ <b>journalctl -F _SYSTEMD_UNIT</b></code></pre>
<p>The <code>-F</code> option shows all values in the journal for a particular field.</p>
<h4 id="h3-500402c07-0003">Finding Fields</h4>
<p class="BodyFirst">Sometimes you just need to know which field to search. You can list all available fields as follows:</p>
<pre><code>$ <b>journalctl -N</b></code></pre>
<p>Any field beginning with an underscore (such as <code>_SYSTEMD_UNIT</code>  from the previous example) is a trusted field; the client that sends a message cannot alter these fields.</p>
<h4 id="h3-500402c07-0004">Filtering by Text</h4>
<p class="BodyFirst">A classic method of searching logfiles is to run <code>grep</code> over all of them, hoping to find a relevant line or spot in a file where there might be more information. Similarly, you can search journal messages by regular expression with the <code>-g</code> option, as in this example, which will return messages containing <code>kernel </code>followed somewhere by <code>memory</code>:</p>
<pre><code><code>$ journalctl -g 'kernel.*memory'</code></code></pre>
<p><span epub:type="pagebreak" title="171" id="Page_171"/>Unfortunately, when you search the journal this way, you get <em>only</em> the messages that match the expression. Often, important information might be nearby in terms of time. Try to pick out the timestamp from a match, and then run <code>journalctl -S</code> with a time just before to see what messages came around the same time.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The <var>-g</var> option requires a build of <var>journalctl</var> with a particular library. Some distributions do not include a version that supports <var>-g</var>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-500402c07-0005">Filtering by Boot</h4>
<p class="BodyFirst">Often, you’ll find yourself looking through the logs for messages around the time when a machine booted or just before it went down (and rebooted). It’s very easy to get the messages from just one boot, from when the machine started until it stopped. For example, if you’re looking for the start of the current boot, just use the <code>-b</code> option:</p>
<pre><code>$ <b>journalctl -b</b></code></pre>
<p>You can also add an offset; for example, to start at the previous boot, use an offset of <code>-1</code>.</p>
<pre><code>$ j<b>ournalctl -b -1</b></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	You can quickly check whether the machine shut down cleanly on the last cycle by combining the <var>-b</var> and <var>-r</var> (reverse) options. Try it; if the output looks like the example here, the shutdown was clean:</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<pre><code>$ <code>journalctl -r -b -1</code>
-- Logs begin at Wed 2019-04-03 12:29:31 EDT, end at Fri 2019-08-02 19:10:14 EDT. --
Jul 18 12:19:52 mymachine systemd-journald[602]: Journal stopped
Jul 18 12:19:52 mymachine systemd-shutdown[1]: Sending SIGTERM to remaining processes...
Jul 18 12:19:51 mymachine systemd-shutdown[1]: Syncing filesystems and block devices.</code></pre>
<p>Instead of an offset like <code>-1</code>, you can also view boots by IDs. Run the following to get the boot IDs:</p>
<pre><code>$ <b>journalctl --list-boots</b>
-1 e598bd09e5c046838012ba61075dccbb Fri 2019-03-22 17:20:01 EDT—Fri 2019-04-12 08:13:52 EDT
 0 5696e69b1c0b42d58b9c57c31d8c89cc Fri 2019-04-12 08:15:39 EDT—Fri 2019-08-02 19:17:01 EDT</code></pre>
<p><span epub:type="pagebreak" title="172" id="Page_172"/>Finally, you can display kernel messages (with or without selecting a particular boot) with <code>journalctl -k</code>.</p>
<h4 id="h3-500402c07-0006">Filtering by Severity/Priority</h4>
<p class="BodyFirst">Some programs produce a large number of diagnostic messages that can obscure important logs. You can filter by the severity level by specifying a value between 0 (most important) and 7 (least important) alongside the <code>-p</code> option. For example, to get the logs from levels 0 through 3, run:</p>
<pre><code>$ <b>journalctl -p 3</b></code></pre>
<p>If you want only the logs from a specific set of severity levels, use the <code>..</code> range syntax:</p>
<pre><code>$ <b>journalctl -p 2..3</b></code></pre>
<p>Filtering by severity sounds like it may save a lot of time, but you might not find much use for it. Most applications don’t generate large amounts of informational data by default, though some include configuration options to enable more verbose logging.</p>
<h4 id="h3-500402c07-0007">Simple Log Monitoring</h4>
<p class="BodyFirst">One traditional way to monitor logs is to use <code>tail -f</code> or the <code>less</code> follow mode (<code>less +F</code>) on a logfile to see messages as they arrive from the system logger. This isn’t a very effective regular system monitoring practice (it’s too easy to miss something), but it’s useful for examining a service when you’re trying to find a problem, or get a closer look at startup and operation in real time.</p>
<p>Using <code>tail -f</code> doesn’t work with journald because it doesn’t use plaintext files; instead, you can use the <code>-f</code> option to <code>journalctl</code> to produce the same effect of printing logs as they arrive:</p>
<pre><code>$ <b>journalctl -f</b></code></pre>
<p>This simple invocation is good enough for most needs. However, you may want to add some of the preceding filtering options if your system has a fairly constant stream of log messages not related to what you’re looking for.</p>
<h3 id="h2-500402c07-0003">7.1.3	Logfile Rotation</h3>
<p class="BodyFirst">When you’re using a syslog daemon, any log message that your system records goes into a logfile somewhere, which means you need to delete old messages occasionally so that they don’t eventually consume all of your storage space. Different distributions do this in different ways, but most use the <code>logrotate</code> utility.</p>
<p>The mechanism is called <em>log rotation</em>. Because a traditional text logfile contains the oldest messages at the beginning and the newest at the end, it’s quite difficult to remove just the older messages from a file to free up some space. Instead, a log maintained by <code>logrotate</code> is divided into many chunks.</p>
<p><span epub:type="pagebreak" title="173" id="Page_173"/>Say you have a logfile called <em>auth.log</em> in <em>/var/log</em> containing the most recent log messages. Then there’s an <em>auth.log.1</em>, <em>auth.log.2</em>, and <em>auth.log.3</em>, each with progressively older data. When <code>logrotate</code> decides that it’s time to delete some old data, it “rotates” the files like this:</p>
<ol class="decimal">
<li value="1">Removes the oldest file, <em>auth.log.3</em>.</li>
<li value="2">Renames <em>auth.log.2</em> to <em>auth.log.3</em>.</li>
<li value="3">Renames <em>auth.log.1</em> to <em>auth.log.2</em>.</li>
<li value="4">Renames <em>auth.log</em> to <em>auth.log.1</em>.</li>
</ol>
<p>The names and some details vary across distributions. For example, the Ubuntu configuration specifies that <code>logrotate</code> should compress the file that’s moved from the “1” position to the “2” position, so in the previous example, you would have <em>auth.log.2.gz</em> and <em>auth.log.3.gz</em>. In other distributions, <code>logrotate</code> renames the logfiles with a date suffix, such as <em>-20200529</em>. One advantage of this scheme is that it’s easier to find a logfile from a specific time.</p>
<p>You might be wondering what happens if <code>logrotate</code> performs a rotation around the same time that another utility (such as rsyslogd) wants to add to the logfile. For example, say the logging program opens the logfile for writing but doesn’t close it before <code>logrotate</code> performs the rename. In this somewhat unusual scenario, the log message would be written successfully, because in Linux, once a file is open, the I/O system has no way to know it was renamed. But note that the file the message appears in will be the file with the new name, such as <em>auth.log.1</em>. </p>
<p>If <code>logrotate</code> has already renamed the file before the logging program attempts to open it, the <code>open()</code> system call creates a new logfile (such as <em>auth.log</em>), just as it would if <code>logrotate</code> weren’t running.</p>
<h3 id="h2-500402c07-0004">7.1.4	Journal Maintenance</h3>
<p class="BodyFirst">The journals stored in <em>/var/log/journal</em> don’t need rotation, because journald itself can identify and remove old messages. Unlike traditional log management, journald normally decides to delete messages based on how much space is left on the journal’s filesystem, how much space the journal should take as a percentage of the filesystem, and what the maximum journal size is set to. There are other options for log management, such as the maximum allowed age of a log message. You’ll find a description of the defaults as well as the other settings in the journald.conf(5) manual page.</p>
<h3 id="h2-500402c07-0005">7.1.5	A Closer Look at System Logging</h3>
<p class="BodyFirst">Now that you’ve seen some of the operational details of syslog and the journal, it’s time to step back a bit and look at the reasons why and how logging works the way it does. This discussion is more theoretical than hands-on; you can skip to the next topic in the book without a problem.</p>
<p>In the 1980s, a gap was starting to emerge: Unix servers needed a way to record diagnostic information, but there was no standard for doing so. <span epub:type="pagebreak" title="174" id="Page_174"/>When syslog appeared with the sendmail email server, it made enough sense that developers of other services readily adopted it. RFC 3164 describes the evolution of syslog.</p>
<p>The mechanism is fairly simple. A traditional syslogd listens and waits for messages on Unix domain socket <em>/dev/log</em>. One additional powerful feature of syslogd is the ability to listen on a network socket in addition to <em>/dev/log</em>, enabling client machines to send messages across a network.</p>
<p>This makes it possible to consolidate all syslog messages from an entire network onto one logging server, and for this reason, syslog became very popular with network administrators. Many network devices, such as routers and embedded devices, can act as syslog clients, sending their diagnostic messages to a server.</p>
<p>Syslog has a classic client-server architecture, including its own protocol (currently defined in RFC 5424). However, the protocol wasn’t always standard, and earlier versions didn’t accommodate much structure beyond some basics. Programmers using syslog were expected to come up with a descriptive, yet clear and brief, log message format for their own applications. Over time, the protocol added new features while still trying to maintain as much backward compatibility as possible. </p>
<h4 id="h3-500402c07-0008">Facility, Severity, and Other Fields</h4>
<p class="BodyFirst">Because syslog sends messages of various types from different services to different destinations, it needs a way to classify each message. The traditional method is to use encoded values of facility and severity that were usually (but not always) included in a message. In addition to file output, even very old versions of syslogd were capable of sending important messages to consoles and directly to particular logged-in users based on the messages’ facility and severity—an early tool for system monitoring.</p>
<p>The <em>facility</em> is a general category of service, identifying what sent the message. Facilities include services and system components such as kernel, mail system, and printer.</p>
<p>The <em>severity</em> is the urgency of the log message. There are eight levels, numbered 0 through 7. They’re usually referred to by name, although the names aren’t very consistent and have varied across implementations:<code> </code></p>
<table id="tabular-500402c07-0001" border="1"><tbody>
<tr>
<td><code>0: emerg</code>
</td><td>
<code>4: warning</code>
</td></tr>
<tr>
<td>
<code>1: alert</code>
</td><td><code>5: notice</code>
</td></tr>
<tr>
<td>
<code>2: crit</code>
</td><td>
<code>6: info</code>
</td></tr>
<tr>
<td>
<code>3: err</code>
</td><td>
<code>7: debug</code>
</td></tr>
</tbody>
</table>
<p>The facility and severity together make up the <em>priority</em>, packaged as one number in the syslog protocol. You can read all about these fields in RFC 5424, learn how to specify them in applications in the syslog(3) manual page, and learn how to match them in the rsyslog.conf(5) manual page. <span epub:type="pagebreak" title="175" id="Page_175"/>However, you might run into some confusion when translating them to the journald world, where the severity is referred to as the priority (for example, when you run <code>journalctl -o json</code> to get machine-readable log output). </p>
<p>Unfortunately, when you start to examine the details of the priority part of the protocol, you’ll find that it hasn’t kept pace with changes and requirements in the rest of the OS. The severity definition still holds up well, but the available facilities are hardwired and include seldom-used services such as UUCP, with no way to define new ones (only a number of generic local0 through local7 slots).</p>
<p>We’ve already talked about some of the other fields in log data, but RFC 5424 also includes a provision for <em>structured data</em>, sets of arbitrary key-value pairs that application programmers can use to define their own fields. Though these can be used with journald with some extra work, it’s much more common to send them to other kinds of databases.</p>
<h4 id="h3-500402c07-0009">The Relationship Between Syslog and journald</h4>
<p class="BodyFirst">The fact that journald has completely displaced syslog on some systems might have you asking why syslog remains on others. There are two main reasons:</p>
<ul>
<li>Syslog has a well-defined means of aggregating logs across many machines. It is much easier to monitor logs when they are on just one machine.</li>
<li>Versions of syslog such as rsyslogd are modular and capable of output to many different formats and databases (including the journal format). This makes it easier to connect them to analysis and monitoring tools.</li>
</ul>
<p>By contrast, journald emphasizes collecting and organizing the log output of a single machine into a single format.</p>
<p>When you want to do something more complicated, journald’s capability of feeding its logs into a different logger offers a high degree of versatility. This is especially true when you consider that systemd can collect the output of server units and send them to journald, giving you access to even more log data than what applications send to syslog.</p>
<h4 id="h3-500402c07-0010">Final Notes on Logging</h4>
<p class="BodyFirst">Logging on Linux systems has changed significantly during its history, and it’s a near-certainty that it will continue to evolve. At the moment, the process of collecting, storing, and retrieving logs on a single machine is well defined, but there are other aspects of logging that aren’t standardized.</p>
<p>First, there’s a dizzying array of options available when you want to aggregate and store logs over a network of machines. Instead of a centralized log server simply storing logs in text files, the logs can now go into databases, and often the centralized server itself is replaced by an internet service.</p>
<p><span epub:type="pagebreak" title="176" id="Page_176"/>Next, the nature of how logs are consumed has changed. At one time, logs were not considered to be “real” data; their primary purpose was a resource that the (human) administrator could read when something went wrong. However, as applications have become more complex, logging needs have grown. These new requirements include the capability to search, extract, display, and analyze the data inside the logs. Although we have many ways of storing logs in databases, tools to use the logs in applications are still in their infancy.</p>
<p>Finally, there’s the matter of ensuring that the logs are trustworthy. The original syslog had no authentication to speak of; you simply trusted that whatever application and/or machine sending the log was telling the truth. In addition, the logs were not encrypted, making them vulnerable to snooping on the network. This was a serious risk in networks that required high security. Contemporary syslog servers have standard methods of encrypting a log message and authenticating the machine where it originates. However, when you get down to individual applications, the picture becomes less clear. For example, how can you be sure that the thing that calls itself your web server actually <em>is</em> the web server?</p>
<p>We’ll explore a few somewhat advanced authentication topics later in the chapter. But for now, let’s move on to the basics of how configuration files are organized on the system.</p>
<h2 id="h1-500402c07-0002">	7.2	The Structure of /etc</h2>
<p class="BodyFirst">Most system configuration files on a Linux system are found in <em>/etc</em>. Historically, each program or system service had one or more configuration files there, and due to the large number of components on a Unix system, <em>/etc</em> would accumulate files quickly. </p>
<p>There were two problems with this approach: it was hard to find particular configuration files on a running system, and it was difficult to maintain a system configured this way. For example, if you wanted to change the <code>sudo</code> configuration, you’d have to edit <em>/etc/sudoers</em>. But after your change, an upgrade to your distribution could wipe out your customizations because it would overwrite everything in <em>/etc</em>.</p>
<p>The trend for many years has been to place system configuration files into subdirectories under <em>/etc</em>, as you’ve already seen for systemd, which uses <em>/etc/systemd</em>. There are still a few individual configuration files in <em>/etc</em>, but if you run <code>ls</code> <code>-F</code> <code>/etc</code>, you’ll see that most of the items there are now subdirectories. </p>
<p>To solve the problem of overwriting configuration files, you can now place customizations in separate files in the configuration subdirectories, such as the ones in <em>/etc/grub.d</em>. </p>
<p>What kind of configuration files are found in <em>/etc</em>? The basic guideline is that customizable configurations for a single machine, such as user information (<em>/etc/passwd</em>) and network details (<em>/etc/network</em>), go into <em>/etc</em>. However, general application details, such as a distribution’s defaults for a <span epub:type="pagebreak" title="177" id="Page_177"/>user interface, don’t belong in <em>/etc</em>. System default configuration files not meant to be customized also are usually found elsewhere, as with the prepackaged systemd unit files in <em>/usr/lib/systemd</em>.</p>
<p>You’ve already seen some of the configuration files that pertain to booting. Let’s continue by looking at how users are configured on a system. </p>
<h2 id="h1-500402c07-0003">	7.3	User Management Files</h2>
<p class="BodyFirst">Unix systems allow for multiple independent users. At the kernel level, users are simply numbers (user IDs), but because it’s much easier to remember a name than a number, you’ll normally work instead with <em>usernames </em>(or <em>login names</em>) when managing Linux. Usernames exist only in user space, so any program that works with a username needs to find its corresponding user ID when talking to the kernel. </p>
<h3 id="h2-500402c07-0006">7.3.1	The /etc/passwd File</h3>
<p class="BodyFirst">The plaintext file <em>/etc/passwd</em> maps usernames to user IDs. It looks like <a href="#listing7-1" id="listinganchor7-1">Listing 7-1</a>.</p>
<pre><code>root:x:0:0:Superuser:/root:/bin/sh
daemon:*:1:1:daemon:/usr/sbin:/bin/sh
bin:*:2:2:bin:/bin:/bin/sh
sys:*:3:3:sys:/dev:/bin/sh
nobody:*:65534:65534:nobody:/home:/bin/false
juser:x:3119:1000:J. Random User:/home/juser:/bin/bash
beazley:x:143:1000:David Beazley:/home/beazley:/bin/bash</code></pre>
<p class="CodeListingCaption"><a id="listing7-1">Listing 7-1</a>: A list of users in <em>/etc/passwd</em></p>
<p>Each line represents one user and has seven fields separated by colons. The first is the username.</p>
<p>Following this is the user’s encrypted password, or at least what was once the field for the password. On most Linux systems, the password is no longer actually stored in the <em>passwd</em> file, but rather in the <em>shadow</em> file (see <span class="xref" itemid="xref_target_Section 7.3.3">Section 7.3.3</span>). The <em>shadow</em> file format is similar to that of <em>passwd</em>, but normal users don’t have read permission for <em>shadow</em>. The second field in <em>passwd</em> or <em>shadow</em> is the encrypted password, and it looks like a bunch of unreadable garbage, such as <code>d1CVEWiB/oppc</code>. Unix passwords are never stored as clear text; in fact, the field is not the password itself, but a derivation of it. In most cases, it’s exceptionally difficult to get the original password from this field (assuming that the password is not easy to guess).</p>
<p>An <code>x</code> in the second <em>passwd</em> file field indicates that the encrypted password is stored in the <em>shadow</em> file (which should be configured on your system). An asterisk (<code>*</code>) indicates that the user cannot log in.</p>
<p>If this password field is blank (that is, you see two colons in a row, like <code>::</code>), no password is required to log in. Beware of blank passwords like this. You should never have a user able to log in without a password.</p>
<p><span epub:type="pagebreak" title="178" id="Page_178"/>The remaining <em>passwd</em> fields are as follows:</p>
<ul>
<li>The <em>user ID</em> <em>(UID)</em>, which is the user’s representation in the kernel. You can have two entries with the same user ID, but this will confuse you—and possibly your software as well—so keep the user ID unique.</li>
<li>The <em>group ID</em> <em>(GID)</em>, which should be one of the numbered entries in the <em>/etc/group</em> file. Groups determine file permissions and little else. This group is also called the user’s <em>primary group</em>.</li>
<li>The user’s real name (often called the <em>GECOS</em> field). You’ll sometimes find commas in this field, denoting room and telephone numbers.</li>
<li>The user’s home directory.</li>
<li>The user’s shell (the program that runs when the user runs a terminal session).</li>
</ul>
<p><a href="#figure7-1" id="figureanchor7-1">Figure 7-1</a> identifies the various fields in one of the entries in <a href="#listing7-1">Listing 7-1</a>.</p>
<figure>
<img src="image_fi/500402c07/f07001.png" alt="f07001"/>
<figcaption><p><a id="figure7-1">Figure 7-1</a>: An entry in the password file</p></figcaption></figure>
<p>The <em>/etc/passwd</em> file syntax is fairly strict, allowing for no comments or blank lines.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	A user in <em>/etc/passwd</em> and a corresponding home directory are collectively known as an <em>account</em>. However, remember that this is a user-space convention. An entry in the <em>passwd</em> file is usually enough to qualify; the home directory doesn’t have to exist in order for most programs to recognize an account. Furthermore, there are ways to add users on a system without explicitly including them in the <em>passwd</em> file; for example, adding users from a network server using something like NIS (Network Information Service) or LDAP (Lightweight Directory Access Protocol) was once common.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c07-0007">7.3.2	Special Users</h3>
<p class="BodyFirst">You’ll find a few special users in <em>/etc/passwd</em>. The <em>superuser</em> (root) always has UID 0 and GID 0, as in <a href="#listing7-1">Listing 7-1</a>. Some users, such as daemon, have no login privileges. The nobody user is an underprivileged user; some processes run as nobody because it cannot (normally) write to anything on the system. </p>
<p><span epub:type="pagebreak" title="179" id="Page_179"/>Users that cannot log in are called <em>pseudo-users</em>. Although they can’t log in, the system can start processes with their user IDs. Pseudo-users such as nobody are usually created for security reasons.</p>
<p>Again, these are all user-space conventions. These users have no special meaning to the kernel; the only user ID that means anything special to the kernel is the superuser’s, 0. It’s possible to give the nobody user access to everything on the system just as you would with any other user.</p>
<h3 id="h2-500402c07-0008">7.3.3	The /etc/shadow File</h3>
<p class="BodyFirst">The shadow password file (<em>/etc/shadow</em>) on a Linux system normally contains user authentication information, including the encrypted passwords and password expiration information that correspond to the users in <em>/etc/passwd</em>. </p>
<p>The <em>shadow</em> file was introduced to provide a more flexible (and perhaps more secure) way of storing passwords. It included a suite of libraries and utilities, many of which were soon replaced by pieces of PAM (Pluggable Authentication Modules; we’ll cover this advanced topic in <span class="xref" itemid="xref_target_Section 7.10">Section 7.10</span>). Rather than introduce an entirely new set of files for Linux, PAM uses <em>/etc/shadow</em>, but not certain corresponding configuration files such as <em>/etc/login.defs</em>.</p>
<h3 id="h2-500402c07-0009">7.3.4	Manipulating Users and Passwords</h3>
<p class="BodyFirst">Regular users interact with <em>/etc/passwd</em> using the <code>passwd</code> command and a few other tools. Use <code>passwd</code> to change your password. You can use <code>chfn</code> and <code>chsh</code> to change the real name and shell, respectively (the shell must be listed in <em>/etc/shells</em>). These are all suid-root executables, because only the superuser can change the <em>/etc/passwd</em> file.</p>
<h4 id="h3-500402c07-0011">Changing /etc/passwd as the Superuser</h4>
<p class="BodyFirst">Because <em>/etc/passwd</em> is just a normal plaintext file, the superuser is technically allowed to use any text editor to make changes. To add a user, it’s possible to simply add an appropriate line and create a home directory for the user; to delete, you can do the opposite. </p>
<p>However, directly editing <em>passwd</em> like this is a bad idea. Not only is it too easy to make a mistake, but you can also get caught with a concurrency problem if something else is making <em>passwd</em> changes at the same time. It’s much easier (and safer) to make changes to users using separate commands available from the terminal or through the GUI. For example, to set a user’s password, run <code>passwd </code><var>user</var> as the superuser. Use <code>adduser</code> and <code>userdel</code> to add and remove users, respectively.</p>
<p>However, if you really must edit the file directly (for example, if it’s somehow corrupted), use the <code>vipw</code> program, which backs up and locks <em>/etc/passwd</em> while you’re editing it as an added precaution. To edit <em>/etc/shadow</em> instead of <em>/etc/passwd</em>, use <code>vipw -s</code>. (Hopefully, you’ll never need to do either of these.) </p>
<h3 id="h2-500402c07-0010"><span epub:type="pagebreak" title="180" id="Page_180"/>7.3.5	Working with Groups</h3>
<p class="BodyFirst"><em>Groups</em> in Unix offer a way to share files among certain users. The idea is that you can set read or write permission bits for a particular group, excluding everyone else. This feature was once important because many users shared one machine or network, but it’s become less significant in recent years as workstations are shared less often.</p>
<p>The <em>/etc/group</em> file defines the group IDs (such as the ones found in the <em>/etc/passwd</em> file). <a href="#listing7-2" id="listinganchor7-2">Listing 7-2</a> is an example.</p>
<pre><code>root:*:0:juser
daemon:*:1:
bin:*:2:
sys:*:3:
adm:*:4:
disk:*:6:juser,beazley
nogroup:*:65534:
user:*:1000:</code></pre>
<p class="CodeListingCaption"><a id="listing7-2">Listing 7-2</a>: A sample <em>/etc/group</em> file</p>
<p>As with the <em>/etc/passwd</em> file, each line in<em> /etc/group</em> is a set of fields separated by colons. The fields in each entry are as follows, from left to right:</p>
<ol class="none">
<li><span class="RunInHead">The group name</span>  This appears when you run a command like <code>ls -l</code>.</li>
<li><span class="RunInHead">The group password</span>  Unix group passwords are hardly ever used, nor should you use them (a good alternative in most cases is <code>sudo</code>). Use <code>*</code> or any other default value. An <code>x</code> here means that there’s a corresponding entry in <em>/etc/gshadow</em>, and this is also nearly always a disabled password, denoted with a <code>*</code> or <code>!</code>.</li>
<li><span class="RunInHead">The group ID (a number)</span>  The GID must be unique within the <code>group</code> file. This number goes into a user’s group field in that user’s <em>/etc/passwd</em> entry.</li>
<li><span class="RunInHead">An optional list of users that belong to the group</span>  In addition to the users listed here, users with the corresponding group ID in their <em>passwd</em> file entries also belong to the group.</li>
</ol>
<p><a href="#figure7-2" id="figureanchor7-2">Figure 7-2</a> identifies the fields in a <em>group</em> file entry.</p>
<figure>
<img src="image_fi/500402c07/f07002.png" alt="f07002"/>
<figcaption><p><a id="figure7-2">Figure 7-2</a>: An entry in the <em>group</em> file</p></figcaption></figure>
<p>To see the groups you belong to, run <code class="bold">groups</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Linux distributions often create a new group for each new user added, with the same name as the user.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c07-0004"><span epub:type="pagebreak" title="181" id="Page_181"/>	7.4	getty and login</h2>
<p class="BodyFirst">The <code>getty</code> program attaches to terminals and displays a login prompt. On most Linux systems, <code>getty</code> is uncomplicated because the system uses it only for logins on virtual terminals. In a process listing, it usually looks something like this (for example, when running on <em>/dev/tty1</em>):</p>
<pre><code>$ <b>ps ao args | grep getty</b>
/sbin/agetty -o -p -- \u --noclear tty1 linux</code></pre>
<p>On many systems, you may not even see a <code>getty</code> process until you access a virtual terminal with something like <span class="KeyCaps">Ctrl-Alt-F1</span>. This example shows <code>agetty</code>, the version that many Linux distributions include by default.</p>
<p>After you enter your login name, <code>getty</code> replaces itself with the <code>login</code> program, which asks for your password. If you enter the correct password, <code>login</code> replaces itself (using <code>exec()</code>) with your shell. Otherwise, you get a “Login incorrect” message. Much of the <code>login</code> program’s real authentication work is handled by PAM (see <span class="xref" itemid="xref_target_Section 7.10">Section 7.10</span>).</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	When investigating <var>getty</var>, you may come across a reference to a baud rate such as “38400.” This setting is all but obsolete. Virtual terminals ignore the baud rate; it’s only there for connecting to real serial lines.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>You now know what <code>getty</code> and <code>login</code> do, but you’ll probably never need to configure or change them. In fact, you’ll rarely even use them, because most users now log in either through a graphical interface such as <code>gdm</code> or remotely with SSH, neither of which uses <code>getty</code> or <code>login</code>. </p>
<h2 id="h1-500402c07-0005">	7.5	Setting the Time</h2>
<p class="BodyFirst">Unix machines depend on accurate timekeeping. The kernel maintains the <em>system clock</em>, which is the clock consulted when you run commands like <code>date</code>. You can also set the system clock using the <code>date</code> command, but it’s usually a bad idea to do so because you’ll never get the time exactly right. Your system clock should be as close to the correct time as possible.</p>
<p>PC hardware has a battery-backed <em>real-time clock (RTC)</em>. The RTC isn’t the best clock in the world, but it’s better than nothing. The kernel usually sets its time based on the RTC at boot time, and you can reset the system clock to the current hardware time with <code>hwclock</code>. Keep your hardware clock in Universal Coordinated Time (UTC) in order to avoid any trouble with time zone or daylight saving time corrections. You can set the RTC to your kernel’s UTC clock using this command:</p>
<pre><code># <b>hwclock --systohc --utc</b></code></pre>
<p>Unfortunately, the kernel is even worse at keeping time than the RTC, and because Unix machines often stay up for months or years on a single <span epub:type="pagebreak" title="182" id="Page_182"/>boot, they tend to develop time drift. <em>Time drift</em> is the current difference between the kernel time and the true time (as defined by an atomic clock or another very accurate clock). </p>
<p>You shouldn’t try to fix time drift with <code>hwclock</code> because time-based system events can get lost or mangled. You could run a utility like <code>adjtimex</code> to smoothly update the clock based on the RTC, but usually it’s best to keep your system time correct with a network time daemon (see <span class="xref" itemid="xref_target_Section 7.5.2">Section 7.5.2</span>).</p>
<h3 id="h2-500402c07-0011">7.5.1	Kernel Time Representation and Time Zones</h3>
<p class="BodyFirst">The kernel’s system clock represents the current time as the number of seconds since 12:00 midnight on January 1, 1970, UTC. To see this number at the moment, run:</p>
<pre><code>$ <b>date +%s</b></code></pre>
<p>To convert this number into something that humans can read, user-space programs change it to local time and compensate for daylight saving time and any other strange circumstances (such as living in Indiana). The local time zone is controlled by the file <em>/etc/localtime</em>. (Don’t bother trying to look at it; it’s a binary file.)</p>
<p>The time zone files on your system are in <em>/usr/share/zoneinfo</em>. You’ll find that this directory contains a lot of time zones and aliases for time zones. To set your system’s time zone manually, either copy one of the files in <em>/usr/share/zoneinfo</em> to <em>/etc/localtime</em> (or make a symbolic link) or change it with your distribution’s time zone tool. The command-line program <code>tzselect</code> may help you identify a time zone file.</p>
<p>To use a time zone other than the system default for just one shell session, set the <code>TZ</code> environment variable to the name of a file in <em>/usr/share/zoneinfo</em> and test the change, like this:</p>
<pre><code>$ <b>export TZ=US/Central</b>
$ <b>date</b></code></pre>
<p>As with other environment variables, you can also set the time zone for the duration of a single command like this:</p>
<pre><code>$ <b>TZ=US/Central date</b></code></pre>
<h3 id="h2-500402c07-0012">7.5.2	Network Time</h3>
<p class="BodyFirst">If your machine is permanently connected to the internet, you can run a Network Time Protocol (NTP) daemon to maintain the time using a remote server. This was once handled by the ntpd daemon, but as with many other services, systemd has replaced this with its own package, named timesyncd. Most Linux distributions include timesyncd, and it’s <span epub:type="pagebreak" title="183" id="Page_183"/>enabled by default. You shouldn’t need to configure it, but if you’re interested in how to do it, the timesyncd.conf(5) manual page can help you. The most common override is to change the remote time server(s).</p>
<p>If you want to run ntpd instead, you’ll need to disable timesyncd if you’ve got it installed. Go to <a href="https://www.ntppool.org/" class="LinkURL">https://www.ntppool.org/</a> to see the instructions there. This site might also be useful if you still want to use timesyncd with different servers.</p>
<p>If your machine doesn’t have a permanent internet connection, you can use a daemon such as chronyd to maintain the time during disconnections.</p>
<p>You can also set your hardware clock based on the network time in order to help your system maintain time coherency when it reboots. Many distributions do this automatically, but to do it manually, make sure that your system time is set from the network and then run this command:</p>
<pre><code># <b>hwclock --systohc –-utc</b></code></pre>
<h2 id="h1-500402c07-0006">	7.6	Scheduling Recurring Tasks with cron and Timer Units</h2>
<p class="BodyFirst">There are two ways to run programs on a repeating schedule: cron, and systemd timer units. This ability is vital to automating system maintenance tasks. One example is logfile rotation utilities to ensure that your hard drive doesn’t fill up with old logfiles (as discussed earlier in the chapter). The cron service has long been the de facto standard for doing this, and we’ll cover it in detail. However, systemd’s timer units are an alternative to cron with advantages in certain cases, so we’ll see how to use them as well.</p>
<p>You can run any program with cron at whatever times suit you. The program running through cron is called a <em>cron job</em>. To install a cron job, you’ll create an entry line in your <em>crontab file</em>, usually by running the <code>crontab</code> command. For example, the following crontab file entry schedules the <code>/home/juser/bin/spmake</code> command daily at 9:15 <span class="KeyCaps">am</span> (in the local time zone):</p>
<pre><code>15 09 * * * /home/juser/bin/spmake</code></pre>
<p>The five fields at the beginning of this line, delimited by whitespace, specify the scheduled time (see also <a href="#figure7-3" id="figureanchor7-3">Figure 7-3</a>). The fields are as follows, in order:</p>
<ul>
<li>Minute (0 through 59). This cron job is set for minute 15.</li>
<li>Hour (0 through 23). This job is set for the ninth hour.</li>
<li>Day of month (1 through 31). </li>
<li>Month (1 through 12). </li>
<li>Day of week (0 through 7). The numbers 0 and 7 are Sunday.
<span epub:type="pagebreak" title="184" id="Page_184"/><figure>
<img src="image_fi/500402c07/f07003.png" alt="f07003"/>
<figcaption><p><a id="figure7-3">Figure 7-3</a>: An entry in the crontab file</p></figcaption></figure>
</li>
</ul>
<p>A star (<code>*</code>) in any field means to match every value. The preceding example runs <code>spmake</code> daily because the day of month, month, and day of week fields are all filled with stars, which cron reads as “run this job every day, of every month, of every day of the week.” </p>
<p>To run <code>spmake</code> only on the 14th day of each month, you would use this crontab line:</p>
<pre><code>15 09 <b>14</b> * * /home/juser/bin/spmake</code></pre>
<p>You can select more than one time for each field. For example, to run the program on the 5th and the 14th day of each month, you could enter <code>5,14</code> in the third field:</p>
<pre><code>15 09 <b>5,14</b> * * /home/juser/bin/spmake</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If the cron job generates standard output or an error or exits abnormally, cron should email this information to the owner of the cron job (assuming that email works on your system). Redirect the output to <span class="Regular">/dev/null</span> or some other logfile if you find the email annoying.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The crontab(5) manual page provides complete information on the crontab format.</p>
<h3 id="h2-500402c07-0013">7.6.1	Installing Crontab Files</h3>
<p class="BodyFirst">Each user can have their own crontab file, which means that every system may have multiple crontabs, usually found in <em>/var/spool/cron/crontabs</em>. Normal users can’t write to this directory; the <code>crontab</code> command installs, lists, edits, and removes a user’s crontab.</p>
<p>The easiest way to install a crontab is to put your crontab entries into a file and then use <code>crontab </code><var>file</var> to install <var>file</var> as your current crontab. The <code>crontab</code> command checks the file format to make sure that you haven’t made any mistakes. To list your cron jobs, run <code>crontab -l</code>. To remove the crontab, use <code>crontab -r</code>.</p>
<p>After you’ve created your initial crontab, it can be a bit messy to use temporary files to make further edits. Instead, you can edit and install your <span epub:type="pagebreak" title="185" id="Page_185"/>crontab in one step with the <code>crontab -e</code> command. If you make a mistake, <code>crontab</code> should tell you where the mistake is and ask if you want to try editing again.</p>
<h3 id="h2-500402c07-0014">7.6.2	System Crontab Files</h3>
<p class="BodyFirst">Many common cron-activated system tasks are run as the superuser. However, rather than editing and maintaining a superuser’s crontab to schedule these, Linux distributions normally have an <em>/etc/crontab</em> file for the entire system. You won’t use <code>crontab</code> to edit this file, and in any case, it’s slightly different in format: before the command to run, there’s an additional field specifying the user that should run the job. (This gives you the opportunity to group system tasks together even if they aren’t all run by the same user.) For example, this cron job defined in <em>/etc/crontab</em> runs at 6:42 <span class="KeyCaps">am</span> as the superuser (<code>root</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>):</p>
<pre><code>42 6 * * * root<span class="CodeAnnotation" aria-label="annotation1">1</span> /usr/local/bin/cleansystem &gt; /dev/null 2&gt;&amp;1</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Some distributions store additional system crontab files in the <em>/etc/cron.d</em> directory. These files may have any name, but they have the same format as <em>/etc/crontab</em>. There may also be some directories such as <em>/etc/cron.daily</em>, but the files here are usually scripts run by a specific cron job in <em>/etc/crontab</em> or <em>/etc/cron.d</em>. It can sometimes be confusing to track down where the jobs are and when they run.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c07-0015">7.6.3	Timer Units</h3>
<p class="BodyFirst">An alternative to creating a cron job for a periodic task is to build a systemd timer unit. For an entirely new task, you must create two units: a timer unit and a service unit. The reason for two units is that a timer unit doesn’t contain any specifics about the task to perform; it’s just an activation mechanism to run a service unit (or conceptually, another kind of unit, but the most common usage is for service units).</p>
<p>Let’s look at a typical timer/service unit pair, starting with the timer unit. Let’s call this <em>loggertest.timer</em>; as with other custom unit files, we’ll put it in <em>/etc/systemd/system </em>(see <a href="#listing7-3" id="listinganchor7-3">Listing 7-3</a>).</p>
<pre><code>[Unit]
Description=Example timer unit

[Timer]
OnCalendar=*-*-* *:00,20,40
Unit=loggertest.service

[Install]
WantedBy=timers.target</code></pre>
<p class="CodeListingCaption"><a id="listing7-3">Listing 7-3</a>: <var>loggertest.timer</var></p>
<p><span epub:type="pagebreak" title="186" id="Page_186"/>This timer runs every 20 minutes, with the <code>OnCalendar</code> option resembling the cron syntax. In this example, it’s at the top of each hour, as well as 20 and 40 minutes past each hour.</p>
<p>The <code>OnCalendar</code> time format is <var>year</var><code>-</code><var>month</var><code>-</code><var>day</var><code> </code><var>hour</var><code>:</code><var>minute</var><code>:</code><var>second</var>. The field for seconds is optional. As with cron, a <code>*</code> represents a sort of wildcard, and commas allow for multiple values. The periodic <code>/</code> syntax is also valid; in the preceding example, you could change the <code>*:00,20,40</code> to <code>*:00/20</code> (every 20 minutes) for the same effect.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The syntax for times in the <var>OnCalendar</var> field has many shortcuts and variations. See the Calendar Events section of the systemd.time(7) manual page for the full list.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The associated service unit is named <em>loggertest.service </em>(see <a href="#listing7-4" id="listinganchor7-4">Listing 7-4</a>). We explicitly named it in the timer with the <code>Unit</code> option, but this isn’t strictly necessary because systemd looks for a <em>.service</em> file with the same base name as the timer unit file. This service unit also goes in <em>/etc/systemd/system</em>, and looks quite similar to the service units that you saw back in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>.</p>
<pre><code>[Unit]
Description=Example Test Service

[Service]
Type=oneshot
ExecStart=/usr/bin/logger -p local3.debug I\'m a logger</code></pre>
<p class="CodeListingCaption"><a id="listing7-4">Listing 7-4</a>: <var>loggertest.service</var></p>
<p>The meat of this is the <code>ExecStart</code> line, which is the command that the service runs when activated. This particular example sends a message to the system log.</p>
<p>Note the use of <code>oneshot</code> as the service type, indicating that the service is expected to run and exit, and that systemd won’t consider the service started until the command specified by <code>ExecStart</code> completes. This has a few advantages for timers:</p>
<ul>
<li>You can specify multiple <code>ExecStart</code> commands in the unit file. The other service unit styles that we saw in Chapter 6 do not allow this.</li>
<li>It’s easier to control strict dependency order when activating other units using <code>Wants</code> and <code>Before</code> dependency directives.</li>
<li>You have better records of start and end times of the unit in the journal.
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	In this unit example, we’re using <var>logger</var> to send an entry to syslog and the journal. You read in <span class="xref" itemid="xref_target_Section 7.1.2">Section 7.1.2</span> that you can view log messages by unit. However, the unit could finish up before journald has a chance to receive the message. This is a race condition, and in the case that the unit completes too quickly, journald won’t be able to look up the unit associated with the syslog message (this is done by process ID). <span epub:type="pagebreak" title="187" id="Page_187"/>Consequently, the message that gets written in the journal may not include a unit field, rendering a filtering command such as <var>journalctl -f -u loggertest.service</var> incapable of showing the syslog message. This isn’t normally a problem in longer-running services.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
</li>
</ul>
<h3 id="h2-500402c07-0016">7.6.4	cron vs. Timer Units</h3>
<p class="BodyFirst">The cron utility is one of the oldest components of a Linux system; it’s been around for decades (predating Linux itself), and its configuration format hasn’t changed much for many years. When something gets to be this old, it becomes fodder for replacement. </p>
<p>The systemd timer units that you just saw may seem like a logical replacement, and indeed, many distributions have now moved system-level periodic maintenance tasks to timer units. But it turns out that cron has some advantages:</p>
<ul>
<li>Simpler configuration</li>
<li>Compatibility with many third-party services</li>
<li>Easier for users to install their own tasks</li>
</ul>
<p>Timer units offer these advantages:</p>
<ul>
<li>Superior tracking of processes associated with tasks/units with cgroups</li>
<li>Excellent tracking of diagnostic information in the journal</li>
<li>Additional options for activation times and frequencies</li>
<li>Ability to use systemd dependencies and activation mechanisms</li>
</ul>
<p>Perhaps someday there will be a compatibility layer for cron jobs in much the same manner as mount units and <em>/etc/fstab</em>. However, configuration alone is a reason why it’s unlikely that the cron format will go away any time soon. As you’ll see in the next section, a utility called <code>systemd-run</code> does allow for creating timer units and associated services without creating unit files, but the management and implementation differ enough that many users would likely prefer cron. You’ll see some of this shortly when we discuss <code>at</code>.</p>
<h2 id="h1-500402c07-0007">	7.7	Scheduling One-Time Tasks with at</h2>
<p class="BodyFirst">To run a job once in the future without using cron, use the <code>at</code> service. For example, to run <code>myjob</code> at 10:30 <span class="KeyCaps">pm</span>, enter this command:</p>
<pre><code>$ <b>at 22:30</b>
at&gt; <b>myjob</b></code></pre>
<p>End the input with <span class="KeyCaps">ctrl</span>-D. (The <code>at</code> utility reads the commands from the standard input.) </p>
<p><span epub:type="pagebreak" title="188" id="Page_188"/>To check that the job has been scheduled, use <code>atq</code>. To remove it, use <code>atrm</code>. You can also schedule jobs days into the future by adding the date in <var>DD.MM.YY</var> format—for example, <code>at 22:30 30.09.15</code>.</p>
<p>There isn’t much else to the <code>at</code> command. Though it isn’t used that often, it can be invaluable when the need does arise.</p>
<h3 id="h2-500402c07-0017">7.7.1	Timer Unit Equivalents</h3>
<p class="BodyFirst">You can use systemd timer units as a substitute for <code>at</code>. These are much easier to create than the periodic timer units that you saw earlier, and can be run on the command line like this:</p>
<pre><code># <b>systemd-run </b>--<b>on-calendar='2022-08-14 18:00' /bin/echo this is a test</b>
Running timer as unit: run-rbd000cc6ee6f45b69cb87ca0839c12de.timer
Will run service as unit: run-rbd000cc6ee6f45b69cb87ca0839c12de.service</code></pre>
<p>The <code>systemd-run</code> command creates a transient timer unit that you can view with the usual <code>systemctl list-timers</code> command. If you don’t care about a specific time, you can specify a time offset instead with <code>--on-active</code> (for example, <code>--on-active=30m</code> for 30 minutes in the future).</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	When using <var>--on-calendar</var>, it’s important that you include a (future) calendar date as well as the time. Otherwise, the timer and service units will remain, with the timer running the service every day at the specified time, much as it would if you created a normal timer unit as described earlier. The syntax for this option is the same as the <var>OnCalendar</var> option in timer units.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c07-0008">	7.8	Timer Units Running as Regular Users</h2>
<p class="BodyFirst">All of the systemd timer units we’ve seen so far have been run as root. It’s also possible to create a timer unit as a regular user. To do this, add the <code>--user</code> option to <code>systemd-run</code>.</p>
<p>However, if you log out before the unit runs, the unit won’t start; and if you log out before the unit completes, the unit terminates. This happens because systemd has a user manager associated with a logged-in user, and this is necessary to run timer units. You can tell systemd to keep the user manager around after you log out with this command:</p>
<pre><code>$ <b>loginctl enable-linger</b></code></pre>
<p>As root, you can also enable a manager for another user:</p>
<pre><code># <b>loginctl enable-linger</b><b> </b><var class="bold">user</var></code></pre>
<h2 id="h1-500402c07-0009"><span epub:type="pagebreak" title="189" id="Page_189"/>	7.9	User Access Topics</h2>
<p class="BodyFirst">The remainder of this chapter covers several topics on how users get the permission to log in, switch to other users, and perform other related tasks. This is somewhat advanced material, and you’re welcome to skip to the next chapter if you’re ready to get your hands dirty with some process internals.</p>
<h3 id="h2-500402c07-0018">7.9.1	User IDs and User Switching</h3>
<p class="BodyFirst">We’ve discussed how setuid programs such as <code>sudo</code> and <code>su</code> allow you to temporarily change users, and we’ve covered system components like <code>login</code> that control user access. Perhaps you’re wondering how these pieces work and what role the kernel plays in user switching.</p>
<p>When you temporarily switch to another user, all you’re really doing is changing your user ID. There are two ways to do this, and the kernel handles both. The first is with a setuid executable, which was covered in <span class="xref" itemid="xref_target_Section 2.17">Section 2.17</span>. The second is through the <code>setuid()</code> family of system calls. There are a few different versions of this system call to accommodate the various user IDs associated with a process, as you’ll learn in <span class="xref" itemid="xref_target_Section 7.9.2">Section 7.9.2</span>. </p>
<p>The kernel has basic rules about what a process can or can’t do, but here are the three essentials that cover setuid executables and <code>setuid()</code>:</p>
<ul>
<li>A process can run a setuid executable as long as it has adequate file permissions.</li>
<li>A process running as root (user ID 0) can use <code>setuid()</code> to become any other user.</li>
<li>A process not running as root has severe restrictions on how it may use <code>setuid()</code>; in most cases, it cannot.</li>
</ul>
<p>As a consequence of these rules, if you want to switch user IDs from a regular user to another user, you often need a combination of the methods. For example, the <code>sudo</code> executable is setuid root, and once running, it can call <code>setuid()</code> to become another user.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	At its core, user switching has nothing to do with passwords or usernames. Those are strictly user-space concepts, as you first saw in the <span class="Regular">/etc/passwd</span> file in Section 7.3.1. You’ll learn more details about how this works in Section 7.9.4.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c07-0019">7.9.2	Process Ownership, Effective UID, Real UID, and Saved UID</h3>
<p class="BodyFirst">Our discussion of user IDs so far has been simplified. In reality, every process has more than one user ID. So far, you are familiar with the <em>effective user ID</em> <em>(effective UID, or euid)</em>, which defines the access rights for a process (most significantly, file permissions). A second user ID, the <em>real user ID</em> <em>(real UID, or ruid)</em>, indicates who initiated a process. Normally, these IDs are identical, but when you run a setuid program, Linux sets the euid to the program’s owner during execution, but it keeps your original user ID in the ruid.</p>
<p><span epub:type="pagebreak" title="190" id="Page_190"/>The difference between the effective and real UIDs is confusing, so much so that a lot of documentation regarding process ownership is incorrect. </p>
<p>Think of the euid as the <em>actor</em> and the ruid as the <em>owner</em>. The ruid defines the user that can interact with the running process—most significantly, which user can kill and send signals to a process. For example, if user A starts a new process that runs as user B (based on setuid permissions), user A still owns the process and can kill it.</p>
<p>We’ve seen that most processes have the same euid and ruid. As a result, the default output for <code>ps</code> and other system diagnostic programs show only the euid. To view both user IDs on your system, try this, but don’t be surprised if you find that the two user ID columns are identical for all processes on your system:</p>
<pre><code>$ <b>ps -eo pid,euser,ruser,comm</b></code></pre>
<p>To create an exception just so that you can see different values in the columns, try experimenting by creating a setuid copy of the <code>sleep</code> command, running the copy for a few seconds, and then running the preceding <code>ps</code> command in another window before the copy terminates.</p>
<p>To add to the confusion, in addition to the real and effective user IDs, there’s also a <em>saved user ID</em> (which is usually not abbreviated). A process can switch its euid to the ruid or saved user ID during execution. (To make things even more complicated, Linux has yet another user ID: the <em>file system user ID</em>, or <em>fsuid</em>, which defines the user accessing the filesystem but is rarely used.)</p>
<h4 id="h3-500402c07-0012">Typical Setuid Program Behavior</h4>
<p class="BodyFirst">The idea of the ruid might contradict your previous experience. Why don’t you have to deal with the other user IDs very frequently? For example, after starting a process with <code>sudo</code>, if you want to kill it, you still use <code>sudo</code>; you can’t kill it as your own regular user. Shouldn’t your regular user be the ruid in this case, giving you the correct permissions?</p>
<p>The cause of this behavior is that <code>sudo</code> and many other setuid programs explicitly change the euid <em>and</em> ruid with one of the <code>setuid()</code> system calls. These programs do so because there are often unintended side effects and access problems when all of the user IDs do not match.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you’re interested in the details and rules regarding user ID switching, read the setuid(2) manual page and check the other manual pages listed in the SEE ALSO section. There are many different system calls for diverse situations.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Some programs don’t like to have an ruid of root. To prevent <code>sudo</code> from changing the ruid, add this line to your <em>/etc/sudoers</em> file (and beware of side effects on other programs you want to run as root!):</p>
<pre><code>Defaults      stay_setuid</code></pre>
<h4 id="h3-500402c07-0013"><span epub:type="pagebreak" title="191" id="Page_191"/>Security Implications</h4>
<p class="BodyFirst">Because the Linux kernel handles all user switches (and as a result, file access permissions) through setuid programs and subsequent system calls, systems developers and administrators must be extremely careful with two things:</p>
<ul>
<li>The number and quality of programs that have setuid permissions</li>
<li>What those programs do</li>
</ul>
<p>If you make a copy of the <code>bash</code> shell that is setuid root, any local user can execute it and have complete run of the system. It’s really that simple. Furthermore, even a special-purpose program that is setuid root can pose a danger if it has bugs. Exploiting weaknesses in programs running as root is a primary method of systems intrusion, and there are too many such exploits to count.</p>
<p>Because there are so many ways to break into a system, preventing intrusion is a multifaceted affair. One of the most essential ways to keep unwanted activity off your system is to enforce user authentication with usernames and good passwords.</p>
<h3 id="h2-500402c07-0020">7.9.3	User Identification, Authentication, and Authorization</h3>
<p class="BodyFirst">A multiuser system must provide basic support for user security in three areas: identification, authentication, and authorization. The <em>identification</em> portion of security answers the question of <em>who</em> users are. The <em>authentication</em> piece asks users to <em>prove</em> that they are who they say they are. Finally, <em>authorization</em> is used to define and limit what users are <em>allowed</em> to do.</p>
<p>When it comes to user identification, the Linux kernel knows only the numeric user IDs for process and file ownership. The kernel knows authorization rules for how to run setuid executables and how user IDs may run the <code>setuid()</code> family of system calls to change from one user to another. However, the kernel doesn’t know anything about authentication: usernames, passwords, and so on. Practically everything related to authentication happens in user space. </p>
<p>We discussed the mapping between user IDs and passwords in <span class="xref" itemid="xref_target_Section 7.3.1">Section 7.3.1</span>; now we’ll cover how user processes access this mapping. We’ll begin with an oversimplified case, in which a user process wants to know its username (the name corresponding to the euid). On a traditional Unix system, a process could do something like this to get its username:</p>
<ol class="decimal">
<li value="1">The process asks the kernel for its euid with the <code>geteuid()</code> system call.</li>
<li value="2">The process opens the <em>/etc/passwd</em> file and starts reading at the beginning.</li>
<li value="3">The process reads a line of the <em>/etc/passwd</em> file. If there’s nothing left to read, the process has failed to find the username. </li>
<li value="4">The process parses the line into fields (breaking out everything between the colons). The third field is the user ID for the current line.</li>
<li value="5"><span epub:type="pagebreak" title="192" id="Page_192"/>The process compares the ID from step 4 to the ID from step 1. If they’re identical, the first field in step 4 is the desired username, and the process can stop searching and use this name. </li>
<li value="6">The process moves on to the next line in <em>/etc/passwd</em> and goes back to step 3.</li>
</ol>
<p>This is a long procedure, and a real-world implementation is usually even more complicated. </p>
<h3 id="h2-500402c07-0021">7.9.4	Using Libraries for User Information</h3>
<p class="BodyFirst">If every developer who needed to know the current username had to write all of the code you’ve just seen, the system would be a horrifyingly disjointed, buggy, bloated, and unmaintainable mess. Fortunately, there are often standard libraries we can use to perform repetitive tasks like this; in this case, all you’d normally need to do to get a username is call a function like <code>getpwuid()</code> in the standard library after you have the answer from <code>geteuid()</code>. (See the manual pages for these calls for more on how they work.)</p>
<p>The standard library is shared among the executables on your system, so you can make significant changes to the authentication implementation without changing any program. For example, you can move away from using <em>/etc/passwd</em> for your users and use a network service such as LDAP instead by changing only the system configuration. </p>
<p>This approach has worked well for identifying usernames associated with user IDs, but passwords have proven more troublesome. <span class="xref" itemid="xref_target_Section 7.3.1">Section 7.3.1</span> describes how, traditionally, the encrypted password was part of <em>/etc/passwd</em>, so if you wanted to verify a password that a user entered, you’d encrypt whatever the user typed and compare it to the contents of the <em>/etc/passwd</em> file.</p>
<p>This traditional implementation has many limitations, including:</p>
<ul>
<li>It doesn’t allow you to set a system-wide standard for the encryption protocol.</li>
<li>It assumes that you have access to the encrypted password.</li>
<li>It assumes that you want to prompt the user for a password every time the user wants to access something that requires authentication (which gets annoying).</li>
<li>It assumes that you want to use passwords. If you want to use one-time tokens, smart cards, biometrics, or some other form of user authentication, you have to add that support yourself.</li>
</ul>
<p>Some of these limitations contributed to the development of the <em>shadow</em> password package discussed in <span class="xref" itemid="xref_target_Section 7.3.3">Section 7.3.3</span>, which took the first step in allowing system-wide password configuration. But the solution to the bulk of the problems came with the design and implementation of PAM.</p>
<h2 id="h1-500402c07-0010">	7.10	Pluggable Authentication Modules</h2>
<p class="BodyFirst">To accommodate flexibility in user authentication, in 1995 Sun Microsystems proposed a new standard called <em>Pluggable Authentication Modules (PAM)</em>, a system <span epub:type="pagebreak" title="193" id="Page_193"/>of shared libraries for authentication (Open Software Foundation RFC 86.0, October 1995). To authenticate a user, an application hands the user to PAM to determine whether the user can successfully identify itself. This way, it’s relatively easy to add support for additional authentication techniques, such as two-factor and physical keys. In addition to authentication mechanism support, PAM also provides a limited amount of authorization control for services (for example, if you’d like to deny a service like cron to certain users).</p>
<p>Because there are many kinds of authentication scenarios, PAM employs a number of dynamically loadable <em>authentication modules</em>. Each module performs a specific task and is a shared object that processes can load dynamically and run in their executable space. For example, <em>pam_unix.so</em> is a module that can check a user’s password.</p>
<p>This is tricky business, to say the least. The programming interface isn’t easy, and it’s not clear that PAM actually solves all of the existing problems. Nevertheless, PAM is supported in nearly every program that requires authentication on a Linux system, and most distributions use PAM. And because it works on top of the existing Unix authentication API, integrating support into a client requires little, if any, extra work.</p>
<h3 id="h2-500402c07-0022">7.10.1	PAM Configuration</h3>
<p class="BodyFirst">We’ll explore the basics of how PAM works by examining its configuration. You’ll normally find PAM’s application configuration files in the <em>/etc/pam.d</em> directory (older systems may use a single <em>/etc/pam.conf</em> file). Most installations include many files, so you may not know where to start. Some filenames, such as <em>cron</em> and <em>passwd</em>, correspond to parts of the system that you know already. </p>
<p>Because the specific configuration in these files varies significantly between distributions, it can be difficult to find a commonly applicable example. We’ll look at an example configuration line that you might find for <code>chsh</code> (the change shell program):</p>
<pre><code>auth       requisite   pam_shells.so</code></pre>
<p>This line says that the user’s shell must be listed in <em>/etc/shells</em> in order for the user to successfully authenticate with the <code>chsh</code> program. Let’s see how. Each configuration line has three fields: a function type, control argument, and module, in that order. Here’s what they mean for this example:</p>
<ol class="none">
<li><span class="RunInHead">Function type</span>  The function that a user application asks PAM to perform. Here, it’s <code>auth</code>, the task of authenticating the user.</li>
<li><span class="RunInHead">Control argument</span>  This setting controls what PAM does <em>after</em> success or failure of its action for the current line (<code>requisite</code> in this example). We’ll get to this shortly.</li>
<li><span class="RunInHead">Module</span>  The authentication module that runs for this line, determining what the line actually does. Here, the <em>pam_shells.so</em> module checks to see whether the user’s current shell is listed in <em>/etc/shells</em>.</li>
</ol>
<p>PAM configuration is detailed on the pam.conf(5) manual page. Let’s look at a few of the essentials.</p>
<h4 id="h3-500402c07-0014"><span epub:type="pagebreak" title="194" id="Page_194"/>Function Types</h4>
<p class="BodyFirst">A user application can ask PAM to perform one of the following four functions: </p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">auth</code></span>  Authenticate a user (see if the user is who they say they are).</li>
<li><span class="RunInHead"><code class="bold">account</code></span>  Check user account status (whether the user is authorized to do something, for example). </li>
<li><span class="RunInHead"><code class="bold">session</code></span>  Perform something only for the user’s current session (such as displaying a message of the day).</li>
<li><span class="RunInHead"><code class="bold">password</code></span>  Change a user’s password or other credentials.</li>
</ol>
<p>For any configuration line, the module and function together determine PAM’s action. A module can have more than one function type, so when determining the purpose of a configuration line, always remember to consider the function and module as a pair. For example, the <em>pam_unix.so</em> module checks a password when performing the <code>auth</code> function, but it sets a password when performing the <code>password</code> function.</p>
<h4 id="h3-500402c07-0015">Control Arguments and Stacked Rules</h4>
<p class="BodyFirst">One important feature of PAM is that the rules specified by its configuration lines <em>stack</em>, meaning that you can apply many rules when performing a function. This is why the control argument is important: the success or failure of an action in one line can impact subsequent lines or cause the entire function to succeed or fail.</p>
<p>There are two kinds of control arguments: the simple syntax and a more advanced syntax. Here are the three major simple syntax control arguments that you’ll find in a rule: </p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">sufficient</code></span>  If this rule succeeds, the authentication is successful, and PAM doesn’t need to look at any more rules. If the rule fails, PAM proceeds to additional rules.</li>
<li><span class="RunInHead"><code class="bold">requisite</code></span>  If this rule succeeds, PAM proceeds to additional rules. If the rule fails, the authentication is unsuccessful, and PAM doesn’t need to look at any more rules.</li>
<li><span class="RunInHead"><code class="bold">required</code></span>  If this rule succeeds, PAM proceeds to additional rules. If the rule fails, PAM proceeds to additional rules but will always return an unsuccessful authentication regardless of the end result of the additional rules.</li>
</ol>
<p>Continuing with the preceding example, here is an example stack for the <code>chsh</code> authentication function:</p>
<pre><code>auth       sufficient     pam_rootok.so
auth       requisite      pam_shells.so
auth       sufficient     pam_unix.so
auth       required       pam_deny.so</code></pre>
<p><span epub:type="pagebreak" title="195" id="Page_195"/>With this configuration, when the <code>chsh</code> command asks PAM to perform the authentication function, PAM does the following (see <a href="#figure7-4" id="figureanchor7-4">Figure 7-4</a> for a flowchart):</p>
<ol class="decimal">
<li value="1">The <em>pam_rootok.so</em> module checks to see if root is the user trying to authenticate. If so, it immediately succeeds and attempts no further authentication. This works because the control argument is set to <code>sufficient</code>, meaning that success from this action is good enough for PAM to immediately report success back to <code>chsh</code>. Otherwise, it proceeds to step 2.
<figure>
<img src="image_fi/500402c07/f07004.png" alt="f07004"/>
<figcaption><p><a id="figure7-4">Figure 7-4</a>: PAM rule execution flow</p></figcaption></figure>
</li>
<li value="2">The <em>pam_shells.so</em> module checks to see if the user’s shell is listed in <em>/etc/shells</em>. If it’s not there, the module returns failure, and the <code>requisite</code> <span epub:type="pagebreak" title="196" id="Page_196"/>control argument indicates that PAM must immediately report this failure back to <code>chsh</code> and attempt no further authentication. Otherwise, the module returns success and fulfills the control flag of <code>requisite</code>; proceed to step 3.</li>
<li value="3">The <em>pam_unix.so</em> module asks the user for their password and checks it. The control argument is set to <code>sufficient</code>, so success from this module (a correct password) is enough for PAM to report success to <code>chsh</code>. If the password is incorrect, PAM continues to step 4.</li>
<li value="4">The <em>pam_deny.so</em> module always fails, and because the control argument is set to <code>required</code>, PAM reports failure back to <code>chsh</code>. This is a default for when there’s nothing left to try. (Note that a <code>required</code> control argument doesn’t cause PAM to fail its function immediately—it will run any lines left on its stack—but PAM will always report failure back to the application.)<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Don’t confuse the terms <em>function</em> and <em>action</em> when working with PAM. The function is the high-level goal: what the user application wants PAM to do (authenticate a user, for example). An action is a specific step that PAM takes in order to reach that goal. Just remember that the user application invokes the function first and that PAM takes care of the particulars with actions.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
</li>
</ol>
<p>The advanced control argument syntax, denoted inside square brackets (<code>[]</code>), allows you to manually control a reaction based on the specific return value of the module (not just success or failure). For details, see the pam.conf(5) manual page; when you understand the simple syntax, you’ll have no trouble with the advanced syntax. </p>
<h4 id="h3-500402c07-0016">Module Arguments</h4>
<p class="BodyFirst">PAM modules can take arguments after the module name. You’ll often encounter this example with the <em>pam_unix.so</em> module:</p>
<pre><code>auth       sufficient   pam_unix.so   nullok</code></pre>
<p>The <code>nullok</code> argument here says that the user can have no password (the default would be failure if the user has no password).</p>
<h3 id="h2-500402c07-0023">7.10.2	Tips on PAM Configuration Syntax</h3>
<p class="BodyFirst">Due to its control flow capability and module argument syntax, the PAM configuration syntax has many features of a programming language and a certain degree of power. We’ve only scratched the surface so far, but here are a few more tips on PAM:</p>
<ul>
<li>To find out which PAM modules are present on your system, try <code>man -k pam_</code> (note the underscore). It can be difficult to track down the location of modules. Try the <code>locate pam_unix.so</code> command and see where that leads you.</li>
<li><span epub:type="pagebreak" title="197" id="Page_197"/>The manual pages contain the functions and arguments for each module.</li>
<li>Many distributions automatically generate certain PAM configuration files, so it may not be wise to change them directly in <em>/etc/pam.d</em>. Read the comments in your <em>/etc/pam.d</em> files before editing them; if they’re generated files, the comments will tell you where they came from. </li>
<li>The <em>/etc/pam.d/other</em> configuration file defines the default configuration for any application that lacks its own configuration file. The default is often to deny everything.</li>
<li>There are different ways to include additional configuration files in a PAM configuration file. The <code>@include</code> syntax loads an entire configuration file, but you can also use a control argument to load only the configuration for a particular function. The usage varies among distributions.</li>
<li>PAM configuration doesn’t end with module arguments. Some modules can access additional files in <em>/etc/security</em>, usually to configure per-user restrictions.</li>
</ul>
<h3 id="h2-500402c07-0024">7.10.3	PAM and Passwords</h3>
<p class="BodyFirst">Due to the evolution of Linux password verification over the years, there are a number of password configuration artifacts that can cause confusion at times. The first to be aware of is the file <em>/etc/login.defs</em>. This is the configuration file for the original shadow password suite. It contains information about the encryption algorithm used for the <em>/etc/shadow</em> password file, but it’s rarely used on a system with PAM installed, because the PAM configuration contains this information. This said, the encryption algorithm in <em>/etc/login.defs</em> should match the PAM configuration in the rare case that you run into an application that doesn’t support PAM. </p>
<p>Where does PAM get its information about the password encryption scheme? Remember that there are two ways for PAM to interact with passwords: the <code>auth</code> function (for verifying a password) and the <code>password</code> function (for setting a password). It’s easiest to track down the password-setting parameter. The best way is probably just to <code>grep</code> it:</p>
<pre><code>$ <b>grep password.*unix /etc/pam.d/*</b></code></pre>
<p>The matching lines should contain <em>pam_unix.so</em> and look something like this:</p>
<pre><code>password        sufficient      pam_unix.so obscure sha512</code></pre>
<p>The arguments <code>obscure</code> and <code>sha512</code> tell PAM what to do when setting a password. First, PAM checks to see if the password is “obscure” enough (that is, the password isn’t too similar to the old password, among other things), and then PAM uses the SHA512 algorithm to encrypt the new password.</p>
<p><span epub:type="pagebreak" title="198" id="Page_198"/>But this happens <em>only</em> when a user <em>sets</em> a password, not when PAM is <em>verifying</em> a password. So how does PAM know which algorithm to use when authenticating? Unfortunately, the configuration won’t tell you anything; there are no encryption arguments for <em>pam_unix.so</em> for the <code>auth</code> function. The manual pages also tell you nothing.</p>
<p>It turns out that (as of this writing) <em>pam_unix.so</em> simply tries to guess the algorithm, usually by asking the libcrypt library to do the dirty work of trying a whole bunch of things until something works or there’s nothing left to try. Therefore, you normally don’t have to worry about the verification encryption algorithm.</p>
<h2 id="h1-500402c07-0011">	7.11	Looking Forward</h2>
<p class="BodyFirst">We’re now at about the midpoint in our progression through this book, having covered many of the vital building blocks of a Linux system. The discussion of logging and users on a Linux system has shown you how it’s possible to divide services and tasks into small, independent chunks that can still interact to a certain extent.</p>
<p>This chapter dealt almost exclusively with user space, and now we need to refine our view of user-space processes and the resources they consume. To do so, we’ll go back into the kernel in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>.</p>
</section>
</body></html>