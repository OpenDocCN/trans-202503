<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch7">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_355" aria-label="355"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch7">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">7</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">LOW-LEVEL CONTROL STRUCTURES</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro">The examples in this book up to this point have created assembly control structures in an ad hoc manner. Now it’s time to formalize how to control the operation of your assembly language programs. By the time you finish this chapter, you should be able to convert HLL control structures into assembly language control statements.</p>&#13;
<p class="TX">Control structures in assembly language consist of conditional branches and indirect jumps. This chapter discusses those instructions and how to emulate HLL control structures such as <span class="SANS_TheSansMonoCd_W5Regular_11">if...else</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span>, and loop statements. This chapter also discusses labels, the targets of conditional branches and jump statements, as well as the scope of labels in an assembly language source file.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_356" aria-label="356"/>&#13;
<h3 class="H1" id="sec1"><span id="h1-90"/><span class="SANS_Futura_Std_Bold_B_11">7.1 Statement Labels</span></h3>&#13;
<p class="TNI1">Before discussing the jump instructions and how to use them to emulate control structures, an in-depth discussion of assembly language statement labels is necessary. <i>Labels</i> in an assembly language program stand in as symbolic names for addresses. Referring to a position in your code by using a name such as <span class="SANS_TheSansMonoCd_W5Regular_11">LoopEntry</span> is far more convenient than using a numeric address such as 0xAF1C002345B7901E. For this reason, assembly language low-level control structures make extensive use of labels within source code (see section 2.10, <span class="Xref">“Control-Transfer Instructions,”</span> on <span class="Xref"><a href="chapter2.xhtml#pg_74">page 74</a></span>).</p>&#13;
<p class="TX">You can do three operations on code labels: transfer control to a label via a conditional or unconditional jump instruction, call a label via the <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction, and take the address of a label. The last of these is useful when you want to indirectly transfer control to that address at a later point in your program.</p>&#13;
<p class="TX">The following code sequence demonstrates how to take the address of a label in your program by using the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro:</p>&#13;
<pre id="pre-550"><code>stmtLbl:&#13;
   .&#13;
   .&#13;
   .&#13;
  lea x0, stmtLbl&#13;
   .&#13;
   .&#13;
   .&#13;
stmtLbl2:</code></pre>&#13;
<p class="TX">Because addresses are 64-bit quantities, you’ll typically load an address into a 64-bit general-purpose register by using the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> instruction. Also see section 7.5, <span class="Xref">“Taking the Address of Symbols in Your Code,”</span> on <span class="Xref"><a href="chapter7.xhtml#pg_364">page 364</a></span> for more information about taking the address of a label in your programs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-91"/><span class="SANS_Futura_Std_Bold_B_11">7.2 Initializing Arrays with Statement Labels</span></h3>&#13;
<p class="TNI1">Gas allows you to initialize double-word objects with the addresses of statement labels. The code fragment in Listing 7-1 demonstrates how to do this.</p>&#13;
<pre id="pre-551"><code>// Listing7-1.S&#13;
//&#13;
// Initializing qword values with the&#13;
// addresses of statement labels&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
            .data&#13;
            .align   3    // Align on dword boundary.&#13;
lblsInProc: .dword   globalLbl1, globalLbl2  // From procWLabels&#13;
&#13;
            .code&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_357" aria-label="357"/>// procWLabels&#13;
//&#13;
// Just a procedure containing private (lexically scoped)&#13;
// and global symbols. This really isn't an executable&#13;
// procedure.&#13;
&#13;
             proc    procWLabels&#13;
&#13;
globalLbl1:  b.al    globalLbl2&#13;
globalLbl2:&#13;
             ret&#13;
             endp    procWLabels&#13;
&#13;
             .pool&#13;
             .align  3   // dword align&#13;
dataInCode:  .dword  globalLbl2, globalLbl1</code></pre>&#13;
<p class="TX">You might recall that pointers in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section cannot refer to objects outside that section; however, it is perfectly legitimate for pointers in other sections (such as .<span class="SANS_TheSansMonoCd_W5Regular_11">data</span>) to refer to symbols in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section.</p>&#13;
<p class="TX">As addresses on the ARM are 64-bit quantities, you will typically use the <span class="SANS_TheSansMonoCd_W5Regular_11">.dword</span> directive, as in the previous examples, to initialize a data object with the address of a statement label.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1" id="sec3"><span id="h1-92"/><span class="SANS_Futura_Std_Bold_B_11">7.3 Unconditional Transfer of Control</span></h3>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> (branch) instruction unconditionally transfers control to another point in the program. This instruction has three forms: two PC-relative branches and an indirect jump. These instructions take the following forms:</p>&#13;
<pre id="pre-552"><code>b    <var>label</var>   // Range is ±128MB.&#13;
b.al <var>label</var>   // Range is ±1MB.&#13;
br   <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">64</span></code></pre>&#13;
<p class="TX">The first two instructions are <i>PC-relative branches</i>, which you’ve seen in various sample programs up to this point. For PC-relative branches, you normally specify the target address by using a statement label. The label appears either on the same line as an executable machine instruction or by itself on a line preceding it. The direct jump is completely equivalent to a <span class="SANS_TheSansMonoCd_W5Regular_11">goto</span> statement in an HLL.</p>&#13;
<p class="TX">Here’s an example of a direct jump that transfers control to a label elsewhere in the program:</p>&#13;
<pre id="pre-553"><code>           <var>statements</var>&#13;
           b laterInPgm   // Or b.al laterInPgm&#13;
               .&#13;
               .&#13;
               .&#13;
laterInPgm:&#13;
           <var>statements</var></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_358" aria-label="358"/>Unlike HLLs, for which your instructors usually forbid you to use <span class="SANS_TheSansMonoCd_W5Regular_11">goto</span> statements, you will find that the use of the <span class="SANS_TheSansMonoCd_W5Regular_11">b</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> instruction in assembly language is essential.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H1" id="sec4"><span id="h1-93"/><span class="SANS_Futura_Std_Bold_B_11">7.4 Register-Indirect Branches</span></h3>&#13;
<p class="TNI1">The third form of the <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">64</span> branch instruction given earlier is a <i>register-indirect jump</i> instruction that transfers control to the instruction whose address appears in the specified 64-bit general-purpose register. To use the <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> instruction, you must load a 64-bit register with the address of a machine instruction prior to the execution of <span class="SANS_TheSansMonoCd_W5Regular_11">br</span>. When several paths, each loading the register with a different address, converge on the same <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> instruction, control transfers to an appropriate location determined by the path up to that point.</p>&#13;
<p class="TX">Listing 7-2 reads a string of characters from the user that contain an integer value. It uses <span class="SANS_TheSansMonoCd_W5Regular_11">strtol()</span> to convert that string to a binary integer value. This C stdlib function doesn’t do the best job of reporting an error, so this program tests the return results to verify a correct input and uses register-indirect jumps to transfer control to different code paths based on the result.</p>&#13;
<p class="TX">The first part of Listing 7-2 contains constants, variables, external declarations, and the (usual) <span class="SANS_TheSansMonoCd_W5Regular_11">getTitle()</span> function.</p>&#13;
<pre id="pre-554"><code>// Listing7-2.S&#13;
//&#13;
// Demonstrate indirect jumps to&#13;
// control flow through a program.&#13;
&#13;
#include    "aoaa.inc"&#13;
&#13;
maxLen      =       256&#13;
EINVAL      =       22     // "Magic" C stdlib constant, invalid argument&#13;
ERANGE      =       34     // Value out of range&#13;
&#13;
&#13;
            .data&#13;
buffer:     .fill   256, 0 // Input buffer&#13;
&#13;
            .text&#13;
            .pool&#13;
ttlStr:     wastr   "Listing 7-2"&#13;
&#13;
fmtStrA:    wastr   "value=%d, error=%d\n"&#13;
&#13;
fmtStr1:    .ascii  "Enter an integer value between "&#13;
            wastr   "1 and 10 (0 to quit): "&#13;
&#13;
badInpStr:  .ascii  "There was an error in readLine "&#13;
            wastr   "(ctrl-D pressed?)\n"&#13;
&#13;
invalidStr: wastr   "The input string was not a proper number\n"&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_359" aria-label="359"/>rangeStr:   .ascii  "The input value was outside the "&#13;
            wastr   "range 1-10\n"&#13;
&#13;
unknownStr: .ascii  "The was a problem with strToInt "&#13;
            wastr   "(unknown error)\n"&#13;
&#13;
goodStr:    wastr   "The input value was %d\n"&#13;
&#13;
fmtStr:     wastr   "result:%d, errno:%d\n"&#13;
&#13;
&#13;
// getTitle&#13;
//&#13;
// Return pointer to program title&#13;
// to the C++ code.&#13;
&#13;
        proc    getTitle, public&#13;
        lea     x0, ttlStr&#13;
        ret&#13;
        endp    getTitle</code></pre>&#13;
<p class="TX">The next section of Listing 7-2 is the <span class="SANS_TheSansMonoCd_W5Regular_11">strToInt</span> function, a wrapper around the C stdlib <span class="SANS_TheSansMonoCd_W5Regular_11">strtol()</span> function that does a more thorough job of handling erroneous inputs from the user. See the comments for the function’s return values:</p>&#13;
<pre id="pre-555"><code>// Listing7-2.S (cont.)&#13;
//&#13;
// strToInt&#13;
//&#13;
// Converts a string to an integer, checking for errors&#13;
//&#13;
// Argument:&#13;
//    X0-   Pointer to string containing (only) decimal&#13;
//              digits to convert to an integer&#13;
//&#13;
// Returns:&#13;
//    X0-   Integer value if conversion was successful.&#13;
//    X1-   Conversion state. One of the following:&#13;
//          0- Conversion successful&#13;
//          1- Illegal characters at the beginning of the&#13;
//                 string (or empty string)&#13;
//          2- Illegal characters at the end of the string&#13;
//          3- Value too large for 32-bit signed integer&#13;
&#13;
&#13;
            proc    strToInt&#13;
&#13;
            locals  sti&#13;
            dword   sti.saveX19&#13;
            dword   sti.endPtr&#13;
            word    sti.value&#13;
            byte    sti.stackSpace, 64&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_360" aria-label="360"/>            endl    sti&#13;
&#13;
            enter   sti.size&#13;
&#13;
            mov     x19, x0         // Save, so you can test later.&#13;
&#13;
// X0 already contains string parameter for strtol,&#13;
// X1 needs the address of the string to convert, and&#13;
// X2 needs the base of the conversion (10).&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> add     x1, fp, #sti.endPtr&#13;
            mov     x2, #10             // Decimal conversion&#13;
            bl      strtol&#13;
&#13;
// On return:&#13;
//&#13;
//    X0-    Contains converted value, if successful&#13;
//    endPtr-Pointer to 1 position beyond last char in string&#13;
//&#13;
// If strtol returns with endPtr == strToConv, then there were no&#13;
// legal digits at the beginning of the string.&#13;
&#13;
            mov     x1, #1                // Assume bad conversion.&#13;
            ldr     x2, [fp, #sti.endPtr] // Is startPtr = endPtr?&#13;
            cmp     x19, x2&#13;
            beq     returnValue&#13;
&#13;
// If endPtr is not pointing at a 0 byte, you have&#13;
// junk at the end of the string.&#13;
&#13;
            mov     x1, #2        // Assume junk at end.&#13;
            ldrb    w3, [x2]      // Byte at endPtr.&#13;
            cmp     x3, #0        // Is it zero?&#13;
            bne     returnValue   // Return error if not 0.&#13;
&#13;
// If the return result is 0x7fff_ffff or 0x8000_0000&#13;
// (max long and min long, respectively), and the C&#13;
// global _errno variable contains ERANGE, you have&#13;
// a range error.&#13;
&#13;
            str     w0, [fp, #sti.value] // Get C errno value.&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> getErrno                     // Magic macro&#13;
            mov     x2, x0&#13;
            ldr     w0, [fp, #sti.value]&#13;
&#13;
            mov     x1, 0         // Assume good input.&#13;
            cmp     w2, #ERANGE   // errno = out of range?&#13;
            bne     returnValue&#13;
            mov     x1, #3        // Assume out of range.&#13;
&#13;
            mov     x2, 0xffff&#13;
            movk    x2, 0x7fff, lsl #16&#13;
&#13;
            cmp     w0, w2&#13;
            beq     returnValue&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_361" aria-label="361"/>            mvn     w2, w2        // W2 = 0x8000_0000&#13;
            cmp     w0, w2&#13;
            beq     returnValue&#13;
&#13;
// If you get to this point, it's a good number.&#13;
&#13;
            mov     x0, #0&#13;
&#13;
returnValue:&#13;
            leave&#13;
            endp    strToInt</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">strtol()</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span> function expects a pointer to an end-of-string pointer variable. The <span class="SANS_TheSansMonoCd_W5Regular_11">strToInt</span> procedure reserved space for this pointer in the activation record. This code computes the address of that pointer variable to pass on to the <span class="SANS_TheSansMonoCd_W5Regular_11">strtol()</span> function.</p>&#13;
<p class="TX">Retrieving the C <span class="SANS_TheSansMonoCd_W5Regular_11">errno</span> variable <span class="CodeAnnotation" aria-label="annotation2">❷</span> is done differently in macOS and Linux (or, more likely, in Clang versus GCC). The <span class="SANS_TheSansMonoCd_W5Regular_11">getErrno</span> macro in the <i>aoaa.inc</i> include file generates the appropriate code for the two systems. It returns <span class="SANS_TheSansMonoCd_W5Regular_11">errno</span> in X0.</p>&#13;
<p class="TX">The final section of Listing 7-2 is the main program and the most interesting part of the code, because it demonstrates how to call the <span class="SANS_TheSansMonoCd_W5Regular_11">strToInt</span> function:</p>&#13;
<pre id="pre-556"><code>// Listing7-2.S (cont.)&#13;
//&#13;
// Here's the asmMain procedure:&#13;
&#13;
            proc    asmMain, public&#13;
&#13;
            locals  am&#13;
            dword   am.saveX19              // Nonvolatile&#13;
            byte    am.stackSpace, 64&#13;
            endl    am&#13;
&#13;
            enter   am.size&#13;
            str     x19, [fp, #am.saveX19]  // Must preserve X19.&#13;
&#13;
// Prompt the user to enter a value&#13;
// from 1 to 10:&#13;
&#13;
repeatPgm:  lea     x0, fmtStr1&#13;
            bl      printf&#13;
&#13;
// Get user input:&#13;
&#13;
            lea     x0, buffer&#13;
            mov     x1, #maxLen&#13;
            bl      readLine&#13;
&#13;
            lea     x19, badInput // Initialize state machine.&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> ands    w0, w0, w0    // X0 is -1 on bad input.&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_362" aria-label="362"/>            bmi     hadError       // Only neg value readLine returns.&#13;
&#13;
// Call strtoint to convert string to an integer and&#13;
// check for errors:&#13;
&#13;
            lea     x0, buffer     // Ptr to string to convert&#13;
            bl      strToInt&#13;
            lea     x19, invalid&#13;
            cmp     w1, #1&#13;
            beq     hadError&#13;
            cmp     w1, #2&#13;
            beq     hadError&#13;
&#13;
            lea     x19, range&#13;
            cmp     w1, #3&#13;
            beq     hadError&#13;
&#13;
            lea     x19, unknown&#13;
            cmp     w1, #0&#13;
            bne     hadError&#13;
&#13;
&#13;
// At this point, input is valid and is sitting in X0.&#13;
//&#13;
// First, check to see if the user entered 0 (to quit&#13;
// the program):&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> ands    x0, x0, x0     // Test for zero.&#13;
            beq     allDone&#13;
&#13;
// However, we need to verify that the number is in the&#13;
// range 1-10:&#13;
&#13;
            lea     x19, range&#13;
            cmp     x0, #1&#13;
            blt     hadError&#13;
            cmp     x0, #10&#13;
            bgt     hadError&#13;
&#13;
// Pretend a bunch of work happens here dealing with the&#13;
// input number:&#13;
&#13;
            lea     x19, goodInput&#13;
&#13;
// The different code streams all merge together here to&#13;
// execute some common code (for brevity, we'll pretend that happens;&#13;
// no such code exists here):&#13;
&#13;
hadError:&#13;
&#13;
// At the end of the common code (which mustn't mess with&#13;
// X19), separate into five code streams based&#13;
// on the pointer value in X19:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> br      x19&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_363" aria-label="363"/>// Transfer here if readLine returned an error:&#13;
&#13;
badInput:   lea     x0, badInpStr&#13;
            bl      printf&#13;
            b.al    allDone&#13;
&#13;
// Transfer here if there was a nondigit character&#13;
// in the string:&#13;
&#13;
invalid:    lea     x0, invalidStr&#13;
            bl      printf&#13;
            b.al    repeatPgm&#13;
&#13;
// Transfer here if the input value was out of range:&#13;
&#13;
range:      lea     x0, rangeStr&#13;
            bl      printf&#13;
            b.al    repeatPgm&#13;
&#13;
// Shouldn't ever get here. Happens if strToInt returns&#13;
// a value outside the range 0-3:&#13;
&#13;
unknown:    lea     x0, unknownStr&#13;
            bl      printf&#13;
            b.al    repeatPgm&#13;
&#13;
// Transfer down here on a good user input:&#13;
&#13;
goodInput:  mov     w1, w0&#13;
            lea     x0, goodStr&#13;
            mstr    w1, [sp]&#13;
            bl      printf&#13;
            b.al    repeatPgm&#13;
&#13;
// Branch here when the user selects "quit program" by&#13;
// entering the value 0:&#13;
&#13;
allDone:    ldr     x19, [fp, #am.saveX19] // Must restore before returning.&#13;
            leave&#13;
&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">The main function loads the X19 register with the address of code to execute based on the <span class="SANS_TheSansMonoCd_W5Regular_11">strToInt</span> return results. The <span class="SANS_TheSansMonoCd_W5Regular_11">strToInt</span> function returns one of the following states (see the comments in the previous code for an explanation):</p>&#13;
<ul class="ul">&#13;
<li class="BL">Valid input</li>&#13;
<li class="BL">Illegal characters at the beginning of the string</li>&#13;
<li class="BL">Illegal characters at the end of the string</li>&#13;
<li class="BL">Range error</li>&#13;
</ul>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_364" aria-label="364"/>The program then transfers control to different sections of <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span> based on the value held in X19, which specifies the type of result <span class="SANS_TheSansMonoCd_W5Regular_11">strToInt</span> returns.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">readline</span> function returns –1 <span class="CodeAnnotation" aria-label="annotation1">❶</span> if there was an error reading the line of text from the user, which typically occurs when the end of the file is detected. This is the <i>only</i> negative value that <span class="SANS_TheSansMonoCd_W5Regular_11">readline</span> returns, so rather than test for –1, this code just checks to see if <span class="SANS_TheSansMonoCd_W5Regular_11">readline</span> returned a negative value. The test is a little sneaky, but it’s a standard trick; anytime you AND a value with itself, you get the original value back. In this case, the code uses the <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> instruction, which also sets the Z flag if the value was 0 and sets the N flag if the number was negative <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Therefore, testing the N flag afterward checks for an error condition. Note that a <span class="SANS_TheSansMonoCd_W5Regular_11">cmp x0, #0</span> instruction would serve this same purpose.</p>&#13;
<p class="TX">Once again, this code uses the <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> instruction <span class="CodeAnnotation" aria-label="annotation2">❷</span> to compare the result against 0. This time, it’s actually checking for the value 0 (via the Z flag) by using the <span class="SANS_TheSansMonoCd_W5Regular_11">beq</span> instruction immediately afterward. This is where the program in Listing 7-2 demonstrates using the <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> (branch indirect through register) instruction to implement the logic <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and a sample run of Listing 7-2:</p>&#13;
<pre id="pre-557"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing7-2</span>&#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing7-2</span>&#13;
Calling Listing7-2:&#13;
Enter an integer value between 1 and 10 (0 to quit): <span class="SANS_TheSansMonoCd_W7Bold_11">a123</span>&#13;
The input string was not a proper number&#13;
Enter an integer value between 1 and 10 (0 to quit): <span class="SANS_TheSansMonoCd_W7Bold_11">123a</span>&#13;
The input string was not a proper number&#13;
Enter an integer value between 1 and 10 (0 to quit): <span class="SANS_TheSansMonoCd_W7Bold_11">1234567890123</span>&#13;
The input value was outside the range 1-10&#13;
Enter an integer value between 1 and 10 (0 to quit): <span class="SANS_TheSansMonoCd_W7Bold_11">-1</span>&#13;
The input value was outside the range 1-10&#13;
Enter an integer value between 1 and 10 (0 to quit): <span class="SANS_TheSansMonoCd_W7Bold_11">11</span>&#13;
The input value was outside the range 1-10&#13;
Enter an integer value between 1 and 10 (0 to quit): <span class="SANS_TheSansMonoCd_W7Bold_11">5</span>&#13;
The input value was 5&#13;
Enter an integer value between 1 and 10 (0 to quit): <span class="SANS_TheSansMonoCd_W7Bold_11">0</span>&#13;
Listing7-2 terminated</code></pre>&#13;
<p class="TX">This sample run demonstrates several bad inputs, including nonnumeric inputs, out-of-range values, a legitimate value, and entering <span class="SANS_TheSansMonoCd_W7Bold_11">0</span> to exit the program.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h1-94"/><span class="SANS_Futura_Std_Bold_B_11">7.5 Taking the Address of Symbols in Your Code</span></h3>&#13;
<p class="TNI1">Listing 7-2 computed the address of various symbols throughout the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section in order to load those addresses into a register for later use. Obtaining the runtime address of a symbol in the program is a common operation in assembly language programs, because this is how you access data (and code) indirectly via a register.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_365" aria-label="365"/>This chapter covers control structures, and this section discusses obtaining addresses of statement labels in the program. Much of the information in this section is review material from earlier chapters in this book, but I’ve pulled it together here for reference purposes and extended the discussion.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-133"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.5.1 Revisiting the lea Macro</span></h4>&#13;
<p class="TNI1">Listing 7-2 used the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro to initialize 64-bit registers with the address of a location to jump to via the <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> instruction. This has been the go-to macro for obtaining the address of a symbol throughout this book. However, remember that <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> is a macro and that</p>&#13;
<pre id="pre-558"><code>lea x0, symbol</code></pre>&#13;
<p class="Continued1">translates into this:</p>&#13;
<pre id="pre-559"><code>// Under macOS:&#13;
&#13;
    adrp x0, symbol@PAGE&#13;
    add  x0, x0, symbol@PAGEOFF&#13;
&#13;
// Under Linux:&#13;
&#13;
    adrp x0, symbol&#13;
    add  x0, x0, :lo12:symbol</code></pre>&#13;
<p class="TX">The two-instruction sequence allows the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro to compute the address of a PC-relative symbol anywhere in a ±4GB range. The <span class="SANS_TheSansMonoCd_W5Regular_11">adr</span> instruction can also compute the address of a symbol but it supports only a ±1MB range (see section 1.8.1, <span class="Xref">“</span><span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span><span class="Xref">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">str</span><span class="Xref">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">adr</span><span class="Xref">, and</span> <span class="SANS_TheSansMonoCd_W5Regular_11">adrp</span><span class="Xref">,” on <a href="chapter1.xhtml#pg_23">page 23</a></span>).</p>&#13;
<p class="TX">When taking the address of nearby statement labels in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section, it is going to be more efficient to use the <span class="SANS_TheSansMonoCd_W5Regular_11">adr</span> instruction:</p>&#13;
<pre id="pre-560"><code>adr x0, symbol</code></pre>&#13;
<p class="TX">The only time this will fail is if your <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section is very large and the symbol is more than 1MB away from the <span class="SANS_TheSansMonoCd_W5Regular_11">adr</span> instruction. The main reason for using the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro is to obtain the address of a symbol that is in a different section (especially on macOS, whose PIE/ASLR policy will likely locate that section farther than ±1MB away).</p>&#13;
<p class="TX">If the symbol/memory location whose address you wish to compute is farther than ±4GB away from the current instruction, you’ll have to use one of the approaches in the following sections to obtain its address.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-134"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.5.2 Statically Computing the Address of a Symbol</span></h4>&#13;
<p class="TNI1">Since memory addresses are 64 bits, and the <span class="SANS_TheSansMonoCd_W5Regular_11">.dword</span> directive allows you to initialize a dword object with a 64-bit value, shouldn’t it be possible to initialize such an object with the 64-bit address of another symbol in the program? The answer depends on the OS you’re running under.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_366" aria-label="366"/>Under Linux, it is perfectly legal (even when running PIE code) to do the following</p>&#13;
<pre id="pre-561"><code>varPtr:  .dword <var>variable</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">variable</span> is the name of a symbol appearing in a <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section. When Linux loads the executable program into memory, it will automatically patch this dword memory location with the address of that symbol in memory (wherever Linux has loaded it). Depending on the section, you might be able to directly load the contents of this location in the X0 register by using the following instruction, assuming that the symbol is within the PC-relative range of the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction:</p>&#13;
<pre id="pre-562"><code>ldr x0, varPtr</code></pre>&#13;
<p class="TX">Sadly, this scheme may not work under macOS, where you’re not allowed to use absolute addresses in your <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section. If you move <span class="SANS_TheSansMonoCd_W5Regular_11">varPtr</span> to the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section, macOS will accept the pointer initialization but will reject the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction with the same complaint about an illegal absolute address. Of course, you could use the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro to load the address of <span class="SANS_TheSansMonoCd_W5Regular_11">varPtr</span> into X0 and then fetch <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">variable</span>’s address by using the <span class="SANS_TheSansMonoCd_W5Regular_11">[X0]</span> addressing mode; however, at that point, you may as well use the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> instruction to load the address of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">variable</span> directly into X0. In any case, you’re back to the ±4GB limitation of the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro.</p>&#13;
<p class="TX">You can get around the absolute address limitation of macOS by using a relative address rather than an absolute address. A <i>relative address</i> is just an offset from a fixed point in memory (for example, a PC-relative address is an offset from the address held in the PC register). You can create a self-relative 64-bit pointer by using the following statement:</p>&#13;
<pre id="pre-563"><code>varPtr:  .dword <var>variable</var>-.  // "." is same as "varPtr" here.</code></pre>&#13;
<p class="TX">This initializes this 64-bit memory location with the distance (in bytes) from the <span class="SANS_TheSansMonoCd_W5Regular_11">varPtr</span> object to the desired memory location (<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">variable</span>). This is known as a <i>self-relative pointer</i> because the offset is from the pointer variable itself. As it turns out, macOS’s assembler is perfectly happy with this address expression (even in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section) because it is not an absolute address.</p>&#13;
<aside class="box" aria-label="box-23">&#13;
<p class="BH" id="box-23"><span class="SANS_Dogma_OT_Bold_B_11">MACOS AND INITIALIZED POINTERS</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">MacOS does not allow 64-bit absolute addresses within the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> <span class="SANS_Futura_Std_Book_11">section. They can’t point into the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> <span class="SANS_Futura_Std_Book_11">section or at other sections. No absolute addresses, absolutely.</span></p>&#13;
<p class="BoxBodyLast"><span class="SANS_Futura_Std_Book_11">This restriction does not exist in other sections. You can have initialized 64-bit pointers in a</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> <span class="SANS_Futura_Std_Book_11">section or in an</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> <span class="SANS_Futura_Std_Book_11">section. Those pointers can</span> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_367" aria-label="367"/><span class="SANS_Futura_Std_Book_11">even point at addresses within the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> <span class="SANS_Futura_Std_Book_11">section. I don’t know why absolute pointers are allowed in these other sections but not the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> <span class="SANS_Futura_Std_Book_11">section, but I suspect that an exploit took advantage of a pointer in the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> <span class="SANS_Futura_Std_Book_11">section that doesn’t work if the pointer is in other sections.</span></p>&#13;
</aside>&#13;
<p class="TX">Of course, you cannot simply load these 64 bits into a register and address the memory location at which they point. The value is an offset, not an address. However, if you add the address of <span class="SANS_TheSansMonoCd_W5Regular_11">varPtr</span> to its contents, this will give you the address of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">variable</span>, as demonstrated in the following code:</p>&#13;
<pre id="pre-564"><code>adr x0, varPtr   // Assume varPtr is in .text and nearby.&#13;
ldr x1, varPtr   // Get varPtr address and contents, then&#13;
add x0, x0, x1   // add them together for <var>variable</var>'s address.</code></pre>&#13;
<p class="TX">This sequence solves the problem with addresses under macOS and happens to work just fine under Linux as well. Because this sequence will work under both OSes, this book adopts this scheme when fetching addresses from variables in memory.</p>&#13;
<p class="TX">Under macOS, this sequence requires <span class="SANS_TheSansMonoCd_W5Regular_11">varPtr</span> to be in the same <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section as the instructions. Otherwise, macOS will complain that <span class="SANS_TheSansMonoCd_W5Regular_11">varPtr</span> is an absolute address and will reject this code. Because I’ve written this book assuming the code will generally work under Linux and macOS, I will keep such labels in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section.</p>&#13;
<p class="TX">A single <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction will also work fine under Linux, so if you’re writing Linux-only code, the single <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> is more efficient.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-135"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.5.3 Dynamically Computing the Address of a Memory Object</span></h4>&#13;
<p class="TNI1">Computing the address of a nonstatic memory object is a bit more involved than doing the same for static (<span class="SANS_TheSansMonoCd_W5Regular_11">.data</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span>, and so on) memory objects.</p>&#13;
<p class="TX">Because every ARM machine instruction is exactly 32 bits in length, you can view a <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section containing nothing but machine instructions as an array of words, where the value in each word just happens to be the encoding of a machine instruction. (This view isn’t 100 percent accurate; if the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section contains data as well as instructions, there are limitations to how far you can go with treating the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section as an array of instructions. However, if you limit yourself to those areas that contain only instructions, everything will be fine.)</p>&#13;
<p class="TX">With this in mind, it is possible to manipulate the values in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section by using the techniques for arrays from section 4.7, <span class="Xref">“Arrays,”</span> on <span class="Xref"><a href="chapter4.xhtml#pg_194">page 194</a></span>. This includes techniques such as indexing into arrays and computing the effective address of array elements.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_368" aria-label="368"/>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Section 5.6.2, “Passing by Reference,” on <a href="chapter5.xhtml#pg_256">page 256</a> describes a procedure for computing the effective address of an object you reference via the ARM’s various addressing modes. For data objects, see that discussion.</i></p>&#13;
<p class="TX">Consider the following instruction sequence of arbitrary instructions cut from Listing 7-2:</p>&#13;
<pre id="pre-565"><code>goodInput:  mov     w1, w0&#13;
            lea     x0, goodStr&#13;
            mstr    w1, [sp]&#13;
            bl      printf&#13;
            b.al    repeatPgm</code></pre>&#13;
<p class="TX">The label <span class="SANS_TheSansMonoCd_W5Regular_11">goodInput</span> is the base address of an array of five words containing the five instructions in this short sequence. You can, of course, take the base address of this array by using the <span class="SANS_TheSansMonoCd_W5Regular_11">adr</span> instruction (or <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> if this sequence is too far away). Once you have this base address in a register (such as X0), you can use the array-indexing calculation to compute the address of a particular entry in the array:</p>&#13;
<pre id="pre-566"><code><var>element_address</var> = <var>base_address</var> + <var>index</var> × <var>element_size</var></code></pre>&#13;
<p class="Continued1">The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">element_size</span> value is 4, as each instruction is 32 bits. Index 0 specifies the <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction, index 1 specifies the <span class="SANS_TheSansMonoCd_W5Regular_11">adr</span> instruction, and so on.</p>&#13;
<p class="TX">Given an index value in X1, you can transfer control directly to one of these five instructions by using the following code:</p>&#13;
<pre id="pre-567"><code>adr x0, goodInput&#13;
add x0, x0, x1, lsl #2&#13;
br  x0</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> instruction multiplies the index (X1) by 4 before adding it to the base address. This computes the byte address of the specified instruction in the sequence; then <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> transfers control to the instruction.</p>&#13;
<p class="TX">In many respects, this is similar to a <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> statement, where a unique case is associated with each instruction in the sequence. This chapter considers such control structures in section 7.6.7, <span class="Xref">“</span><span class="SANS_TheSansMonoCd_W5Regular_11">switch...case</span> <span class="Xref">Statements,”</span> on <span class="Xref"><a href="chapter7.xhtml#pg_389">page 389</a></span>. In the meantime, just know that you can dynamically compute the address of one of the instructions in this sequence by using normal effective address calculations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-136"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.5.4 Working with Veneers</span></h4>&#13;
<p class="TNI1">In the rare case you need to branch to a location beyond the range of the conditional branch instructions, you can use an instruction sequence such as the following</p>&#13;
<pre id="pre-568"><code>         b<var>cc</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">opposite</span>  skipJmp&#13;
         lea       x16, destLbl&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_369" aria-label="369"/>         br        x16&#13;
skipJmp:</code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_11">b</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">opposite</span> is the opposite of the branch you want to take. This opposite branch skips over the code that transfers control to the target location. This provides you with the 4GB range of the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro, which should be sufficient if you’re branching to code in your program. The opposite conditional branch transfers control to the normal <i>fall-though point</i> in the code (the code you’d normally fall through to if the condition is false). If the condition is true, control transfers to a memory-indirect jump that jumps to the original target location via a 64-bit pointer.</p>&#13;
<p class="TX">This sequence is known as a <i>veneer</i> (or a <i>trampoline</i>), because a program jumps to this point to move even further in the program—much like jumping on a trampoline lets you jump higher and higher. Veneers are useful for call and unconditional jump instructions that use the PC-relative addressing mode (and thus are limited to a ±1MB range around the current instruction). You’ll rarely use veneers to transfer to another location within your program, since it’s unlikely you’ll write assembly language programs that large.</p>&#13;
<p class="TX">Note the use of the X16 register in this example. The ARM ABI reserves registers X16 and X17 for dynamic linking and veneer use. You’re free to use these two as volatile registers with the expectation that their contents may be changed upon executing a branch instruction (of any kind, though generally a <span class="SANS_TheSansMonoCd_W5Regular_11">bl</span> instruction). Compilers and linkers will typically modify an out-of-range branch instruction to transfer code to a nearby veneer, which then transfers control the full distance to the actual destination. When creating your own veneers, it makes sense to use these registers as temporaries for that purpose.</p>&#13;
<p class="TX">Branching to code outside this range generally means you’re transferring control to a function in a shared (or dynamically linked) library. See the appropriate documentation for your OS for details on such libraries.</p>&#13;
<p class="TX"><a href="chapter7.xhtml#tab7-1">Table 7-1</a> lists the opposite conditions; refer to <span class="Xref"><a href="chapter2.xhtml#tab2-11">Table 2-11</a></span> on <span class="Xref"><a href="chapter2.xhtml#pg_82">page 82</a></span> for the available opposite branch macros in <i>aoaa.inc</i>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_370" aria-label="370"/>&#13;
&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab7-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 7-1:</span></span> <span class="SANS_Futura_Std_Book_11">Opposite Conditions</span></p>&#13;
</caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Branch condition</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Opposite</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">eq</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">ne</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">ne</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">eq</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">hi</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">ls</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">hs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">lo</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">lo</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">hs</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">ls</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">hi</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">gt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">le</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">ge</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">lt</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">lt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">ge</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">le</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">gt</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">cs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">cc</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">cc</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">cs</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">vs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">vc</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">vc</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">vs</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">mi</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">pl</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">pl</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">mi</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">If the destination location is beyond the ±4GB range of the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro, you’ll need to create a 4-byte pointer (offset) to the actual location and use code such as the following:</p>&#13;
<pre id="pre-569"><code>    adr     x16, destPtr&#13;
    ldr     x17, destPtr&#13;
    add     x16, x16, x17&#13;
    br      x16&#13;
destPtr:&#13;
    .dword  destination-.  // Same as "destination-destPtr"</code></pre>&#13;
<p class="TX">This particular sequence is sufficiently useful that the <i>aoaa.inc</i> include file provides a macro that expands to it:</p>&#13;
<pre id="pre-570"><code>goto destination</code></pre>&#13;
<p class="TX">If you need to call a procedure that’s more than ±4GB away, you could emit similar code:</p>&#13;
<pre id="pre-571"><code>    adr     x16, destPtr&#13;
    ldr     x17, destPtr&#13;
    add     x16, x16, x17&#13;
    blr     x16&#13;
    b.al    skipAdrs&#13;
destPtr:&#13;
    .dword  destination-.&#13;
skipAdrs:</code></pre>&#13;
<p class="TX">However, it’s easier to do this:</p>&#13;
<pre id="pre-572"><code>    bl      veneer&#13;
     .&#13;
     .&#13;
     .&#13;
veneer:&#13;
    goto<var> destination</var></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_371" aria-label="371"/>With the discussion of veneers out of the way, the next section can discuss how to implement HLL-like control structures in assembly language.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h1-95"/><span class="SANS_Futura_Std_Bold_B_11">7.6 Implementing Common Control Structures in Assembly Language</span></h3>&#13;
<p class="TNI1">This section shows you how to implement HLL-like control structures such as decisions, loops, and other control constructs by using pure assembly language. It concludes by showing some ARM instructions designed for creating common loops.</p>&#13;
<p class="TX">Throughout many of the following examples, this chapter assumes that various variables are local variables in the activation record (indexed off of the FP register) or static/global variables indexed off the SB (X28) register. We presume that appropriate structure declarations have been made for all the variable’s identifiers and that the FP/SB registers have been properly initialized to point at these structures.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-137"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.6.1 Decisions</span></h4>&#13;
<p class="TNI1">In its most basic form, a <i>decision</i> is a branch within the code that switches between two possible execution paths based on a certain condition. Normally (though not always), conditional instruction sequences are implemented with the conditional jump instructions. Conditional instructions correspond to the following <span class="SANS_TheSansMonoCd_W5Regular_11">if...then...endif</span> statement in an HLL:</p>&#13;
<pre id="pre-573"><code>if(<var>expression</var>) then&#13;
    <var>statements</var>&#13;
endif;</code></pre>&#13;
<p class="TX">To convert this to assembly language, you must write statements that evaluate the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">expression</span> and then branch around the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">statements</span> if the result is false. For example, if you had the C statements</p>&#13;
<pre id="pre-574"><code>if(aa == bb)&#13;
{&#13;
    printf("aa is equal to bb\n");&#13;
}</code></pre>&#13;
<p class="Continued1">you could translate this to assembly as follows:</p>&#13;
<pre id="pre-575"><code>      ldr  w0, [fp, #aa]    // Assume aa and bb are 32-bit integers.&#13;
      ldr  w1, [fp, #bb]&#13;
      cmp  w0, w1&#13;
      bne  aNEb             // Use opposite branch to skip then&#13;
      lea  x0, aIsEqlBstr   // " aa is equal to bb\n".&#13;
      bl   printf&#13;
aNEb:</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_372" aria-label="372"/>In general, conditional statements may be broken into three basic categories: <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statements, <span class="SANS_TheSansMonoCd_W5Regular_11">switch...case</span> statements, and indirect jumps. Next, you’ll learn about these program structures, how to use them, and how to write them in assembly language.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-138"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.6.2 if...then...else Sequences</span></h4>&#13;
<p class="TNI1">The most common conditional statements are the <span class="SANS_TheSansMonoCd_W5Regular_11">if...then...endif</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">if...then...else...endif</span> statements. These two statements take the form shown in <a href="chapter7.xhtml#fig7-1">Figure 7-1</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig7-1" src="../images/Figure7-1.jpg" alt="" width="1133" height="1197"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 7-1: The</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">if...then...else...endif</span> <span class="SANS_Futura_Std_Book_Oblique_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">if...then...endif</span> <span class="SANS_Futura_Std_Book_Oblique_11">statements</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">if...then...endif</span> statement is just a special case of the <span class="SANS_TheSansMonoCd_W5Regular_11">if...then...else...endif</span> statement (with an empty <span class="SANS_TheSansMonoCd_W5Regular_11">else</span> block). The basic implementation of an <span class="SANS_TheSansMonoCd_W5Regular_11">if...then...else...endif</span> statement in ARM assembly language looks something like this</p>&#13;
<pre id="pre-576"><code>    <var>Sequence of statements to test a condition</var>&#13;
          b<var>cc</var> ElseCode;&#13;
&#13;
    <var>Sequence of statements corresponding to the THEN block</var>&#13;
&#13;
          b.al EndOfIf&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_373" aria-label="373"/>ElseCode:&#13;
    <var>Sequence of statements corresponding to the ELSE block</var>&#13;
&#13;
EndOfIf:</code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_11">b</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span> represents a conditional branch instruction (typically the opposite branch of the condition being tested).</p>&#13;
<p class="TX">For example, suppose you want to convert the C/C++ statement into assembly language:</p>&#13;
<pre id="pre-577"><code>if(aa == bb)&#13;
    c = d;&#13;
else&#13;
    bb = bb + 1;</code></pre>&#13;
<p class="TX">To do so, you could use the following ARM code:</p>&#13;
<pre id="pre-578"><code>          ldr  w0, [fp, #aa]   // aa and bb are 32-bit integers&#13;
          ldr  w1, [fp, #bb]   // in the current activation record.&#13;
          cmp  w0, w1&#13;
          bne  ElseBlk         // Use opposite branch to goto else.&#13;
          ldr  w0, [sb, #d]    // Assume c and d are 32-bit static&#13;
          str  w0, [sb, #c]    // variables in the static base&#13;
          b.al EndOfIf         // structure (pointed at by SB).&#13;
&#13;
ElseBlk:&#13;
          ldr w0, [fp, #bb]&#13;
          add w0, w0, #1&#13;
          str w0, [fp, #bb]&#13;
&#13;
EndOfIf:</code></pre>&#13;
<p class="TX">For simple expressions like <span class="SANS_TheSansMonoCd_W5Regular_11">(aa == bb)</span>, generating the proper code for an <span class="SANS_TheSansMonoCd_W5Regular_11">if...then...else...endif</span> statement is easy. Should the expression become more complex, the code complexity increases as well. Consider the following C/C++ <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement:</p>&#13;
<pre id="pre-579"><code>if(((x &gt; y) &amp;&amp; (z &lt; t)) || (aa != bb))&#13;
    c = d;</code></pre>&#13;
<p class="TX">To convert a complex <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement such as this one, break it into a sequence of three <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statements as follows (assuming the use of short-circuit evaluation; see section 7.6.5, <span class="Xref">“Short-Circuit vs. Complete Boolean Evaluation,”</span> on <span class="Xref"><a href="chapter7.xhtml#pg_382">page 382</a></span> for details):</p>&#13;
<pre id="pre-580"><code>if(aa != bb)&#13;
    c = d;&#13;
else if(x &gt; y)&#13;
    if(z &lt; t)&#13;
         c = d;</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_374" aria-label="374"/>This conversion comes from the following C/C++ equivalences:</p>&#13;
<pre id="pre-581"><code>if(<var>expr1</var> &amp;&amp; <var>expr2</var>) <var>stmt</var>;</code></pre>&#13;
<p class="Continued1">is equivalent to</p>&#13;
<pre id="pre-582"><code>if(<var>expr1</var>) if(<var>expr2</var>) <var>stmt</var>;</code></pre>&#13;
<p class="Continued1">and</p>&#13;
<pre id="pre-583"><code>if(expr1 || <var>expr2</var>) <var>stmt</var>;</code></pre>&#13;
<p class="Continued1">is equivalent to</p>&#13;
<pre id="pre-584"><code>if(<var>expr1</var>) <var>stmt</var>;&#13;
else if(<var>expr2</var>) <var>stmt</var>;</code></pre>&#13;
<p class="TX">In assembly language, the former <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement becomes the following:</p>&#13;
<pre id="pre-585"><code>// if(((x &gt; y) &amp;&amp; (z &lt; t)) || (aa != bb))&#13;
//      c = d;&#13;
//&#13;
// Assume x = W0, y = W1, z = W2, t = W3, aa = W4, bb = W5, c = W6, and d = W7&#13;
// and all variables are signed integers.&#13;
&#13;
          cmp  w4, w5     // (aa != bb)?&#13;
          bne  DoIf&#13;
          cmp  w0, w1     // (x &gt; y)?&#13;
          bngt EndOfIf    // Not greater than&#13;
          cmp  w2, w3     // (z &lt; t)?&#13;
          bnlt EndOfIf    // Not less than&#13;
DoIf:&#13;
          mov  w6, w7     // c = d&#13;
EndOfIf:</code></pre>&#13;
<p class="Continued1">Note the use of opposite branches to suggest that falling through is the main condition to consider.</p>&#13;
<p class="TX">The biggest problem with complex conditional statements in assembly language is trying to figure out what you’ve done after you’ve written the code. HLL expressions are much easier to read and comprehend, so well-written comments are essential for clear assembly language implementations of <span class="SANS_TheSansMonoCd_W5Regular_11">if...then...else...endif</span> statements. The following code shows an elegant implementation of the preceding example:</p>&#13;
<pre id="pre-586"><code>// if(((x &gt; y) &amp;&amp; (z &lt; t)) || (aa != bb))&#13;
//      c = d;&#13;
//&#13;
// Assume x = W0, y = W1, z = W2, t = W3, aa = W4, bb = W5, c = W6, &#13;
// and d = W7.&#13;
//&#13;
// Implemented as:&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_375" aria-label="375"/>//&#13;
// if (aa != bb) then goto DoIf&#13;
&#13;
          cmp  w4, w5   // (aa != bb)?&#13;
          bne  DoIf&#13;
&#13;
// if not (x &gt; y) then goto EndOfIf&#13;
&#13;
          cmp  w0, w1   // (x &gt; y)?&#13;
          bngt EndOfIf  // Not greater than&#13;
&#13;
// if not (z &lt; t) then goto EndOfIf&#13;
&#13;
          cmp  w2, w3   // (z &lt; t)?&#13;
          bnlt EndOfIf  // Not less than&#13;
&#13;
// true block:&#13;
&#13;
DoIf:&#13;
          mov w6, w7   // c = d&#13;
EndOfIf:</code></pre>&#13;
<p class="TX">Whenever you’re working in assembly language, don’t forget to step back for a moment and see if you can rethink the solution in assembly language rather than playing “human C/C++ compiler.” When working with a complex Boolean expression, your first thought should be, “Can I use the conditional compare instruction to resolve this?” The following example does just that:</p>&#13;
<pre id="pre-587"><code>// if(((x &gt; y) &amp;&amp; (z &lt; t)) || (aa != bb))&#13;
//      c = d;&#13;
//&#13;
// Assume x = W1, y = W2, z = W3, t = W4, aa = W5, bb = W6, c = W0, and d = W7.&#13;
&#13;
            cmp    w1, w2              // x &gt; y   ? gt : ngt (C ternary ?: op)&#13;
            ccmp   w3, w4, #ccnlt, gt  // x &gt; y   ? gt : ngt&#13;
            ccmp   w5, w6, #ccne, nlt  // nlt   ? (a != bb ? ne : nne) : ne&#13;
            csel   w0, w7, w0, ne      // if(ne) c = d</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction sets the flags for <span class="SANS_TheSansMonoCd_W5Regular_11">(x &gt; y)</span>. The first <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction sets the flags to simulate a signed <span class="SANS_TheSansMonoCd_W5Regular_11">ge</span> (not less than) if <span class="SANS_TheSansMonoCd_W5Regular_11">(x &lt;= y)</span> or based on the comparison of <span class="SANS_TheSansMonoCd_W5Regular_11">(z &lt; t)</span> if <span class="SANS_TheSansMonoCd_W5Regular_11">(x &gt; y)</span>. After executing the first <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction, N ≠ V if <span class="SANS_TheSansMonoCd_W5Regular_11">(x &gt; y) &amp;&amp; (z &lt; t)</span>.</p>&#13;
<p class="TX">Upon executing the second <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction, if N ≠ V (meaning signed less than), the code just sets NZCV to simulate <span class="SANS_TheSansMonoCd_W5Regular_11">ne</span> and doesn’t bother comparing <span class="SANS_TheSansMonoCd_W5Regular_11">aa</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span> (because the left-hand side of the disjunction operator is already true, there is no need to evaluate the third parenthetical expression). Setting Z = 0 means the <span class="SANS_TheSansMonoCd_W5Regular_11">csel</span> instruction will copy <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> (based on the <span class="SANS_TheSansMonoCd_W5Regular_11">ne</span> condition).</p>&#13;
<p class="TX">If N = V when executing the second <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction, the <span class="SANS_TheSansMonoCd_W5Regular_11">ge</span> condition is true, which means that the conjunction operation yielded false and you <span role="doc-pagebreak" epub:type="pagebreak" id="pg_376" aria-label="376"/>must test to see if <span class="SANS_TheSansMonoCd_W5Regular_11">aa</span> does not equal <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span>. That will set the flags appropriately for the <span class="SANS_TheSansMonoCd_W5Regular_11">csel</span> instruction. Listing 7-3 demonstrates the execution of this conditional comparison code.</p>&#13;
<pre id="pre-588"><code>// Listing7-3.S&#13;
//&#13;
// Demonstrate the ccmp instruction&#13;
// handling complex Boolean expressions.&#13;
&#13;
#include    "aoaa.inc"&#13;
&#13;
            .data&#13;
&#13;
xArray:     .word   -1, 0, 1,-1, 0, 1,-1, 0, 1, 1&#13;
yArray:     .word   -1,-1,-1, 0, 0, 0, 1, 1, 1, 0&#13;
zArray:     .word   -1, 0, 1,-1, 0, 1,-1, 0, 1, 0&#13;
tArray:     .word    0, 0, 0, 1, 1, 1,-1,-1,-1, 1&#13;
aArray:     .word    0, 0, 0,-1,-1,-1, 1, 1, 1, 1&#13;
bArray:     .word   -1, 0, 1,-1, 0, 1,-1, 0, 1, 1&#13;
size        =       10&#13;
&#13;
            .text&#13;
            .pool&#13;
ttlStr:     wastr   "Listing 7-3"&#13;
fmtStr1:    .ascii  "((x &gt; y) &amp;&amp; (z &lt; t)) || (aa != bb)\n"&#13;
            .ascii  " x  y  z  t aa bb Result\n"&#13;
            wastr   "-- -- -- -- -- -- ------\n"&#13;
fmtStr2:    wastr   "%2d %2d %2d %2d %2d %2d   %2d\n"&#13;
&#13;
// getTitle&#13;
//&#13;
// Return pointer to program title&#13;
// to the C++ code:&#13;
&#13;
            proc    getTitle, public&#13;
            adr     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle&#13;
&#13;
/////////////////////////////////////////////////////////&#13;
//&#13;
// Here's the asmMain procedure:&#13;
&#13;
            proc    asmMain, public&#13;
&#13;
            locals  am&#13;
            qword   saveX1920&#13;
            qword   saveX2122&#13;
            qword   saveX2324&#13;
            dword   saveX25&#13;
            byte    stackSpace, 64&#13;
            endl    am&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_377" aria-label="377"/>            enter   am.size&#13;
&#13;
// Save nonvolatile registers and initialize&#13;
// them to point at xArray, yArray, zArray,&#13;
// tArray, aArray, and bArray:&#13;
&#13;
            stp     x19, x20, [fp, #saveX1920]&#13;
            stp     x21, x22, [fp, #saveX2122]&#13;
            stp     x23, x24, [fp, #saveX2324]&#13;
            str     x25, [fp, #saveX25]&#13;
&#13;
#define x   x19&#13;
#define y   x20&#13;
#define z   x21&#13;
#define t   x22&#13;
#define aa  x23&#13;
#define bb  x24&#13;
&#13;
            lea     x, xArray&#13;
            lea     y, yArray&#13;
            lea     z, zArray&#13;
            lea     t, tArray&#13;
            lea     aa, aArray&#13;
            lea     bb, bArray&#13;
&#13;
            lea     x0, fmtStr1&#13;
            bl      printf&#13;
&#13;
// Loop through the array elements&#13;
// and print their values along&#13;
// with the result of&#13;
// ((x &gt; y) &amp;&amp; (z &lt; t)) || (aa != bb)&#13;
&#13;
            mov     x25, #0&#13;
rptLp:      ldr     w1, [x, x25, lsl #2]    // W1 = x[X25]&#13;
            ldr     w2, [y, x25, lsl #2]    // W2 = y[X25]&#13;
            ldr     w3, [z, x25, lsl #2]    // W3 = z[X25]&#13;
            ldr     w4, [t, x25, lsl #2]    // W4 = t[X25]&#13;
            ldr     w5, [aa, x25, lsl #2]   // W5 = aa[X25]&#13;
            ldr     w6, [bb, x25, lsl #2]   // W6 = bb[X25]&#13;
&#13;
            cmp     w1, w2&#13;
            ccmp    w3, w4, #ccnlt, gt&#13;
            ccmp    w5, w6, #ccne, nlt&#13;
            cset    w7, ne&#13;
&#13;
            lea     x0, fmtStr2&#13;
            mstr    w1, [sp]&#13;
            mstr    w2, [sp, #8]&#13;
            mstr    w3, [sp, #16]&#13;
            mstr    w4, [sp, #24]&#13;
            mstr    w5, [sp, #32]&#13;
            mstr    w6, [sp, #40]&#13;
            mstr    w7, [sp, #48]&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_378" aria-label="378"/>            bl      printf&#13;
            add     x25, x25, #1&#13;
            cmp     x25, #size&#13;
            blo     rptLp&#13;
&#13;
// Restore nonvolatile register values&#13;
// and return:&#13;
&#13;
            ldp     x19, x20, [fp, #saveX1920]&#13;
            ldp     x21, x22, [fp, #saveX2122]&#13;
            ldp     x23, x24, [fp, #saveX2324]&#13;
            ldr     x25, [fp, #saveX25]&#13;
&#13;
            leave&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for Listing 7-3:</p>&#13;
<pre id="pre-589"><code>$<span class="SANS_TheSansMonoCd_W7Bold_11"> ./build Listing7-3</span>&#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing7-3</span>&#13;
Calling Listing7-3:&#13;
((x &gt; y) &amp;&amp; (z &lt; t)) || (aa != bb)&#13;
 x  y  z  t aa bb Result&#13;
-- -- -- -- -- -- ------&#13;
-1 -1 -1  0  0 -1      1&#13;
 0 -1  0  0  0  0      0&#13;
 1 -1  1  0  0  1      1&#13;
-1  0 -1  1 -1 -1      0&#13;
 0  0  0  1 -1  0      1&#13;
 1  0  1  1 -1  1      1&#13;
-1  1 -1 -1  1 -1      1&#13;
 0  1  0 -1  1  0      1&#13;
 1  1  1 -1  1  1      0&#13;
 1  0  0  1  1  1      1&#13;
Listing7-3 terminated</code></pre>&#13;
<p class="TX">The output shows the truth table for the given expression.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-139"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.6.3 Complex if Statements Using Complete Boolean Evaluation</span></h4>&#13;
<p class="TNI1">Many Boolean expressions involve conjunction (AND) or disjunction (OR) operations. You can convert such Boolean expressions into assembly language in two ways: using <i>complete Boolean evaluation</i> or using <i>short-circuit Boolean evaluation</i>. This section discusses complete Boolean evaluation, and the next discusses short-circuit Boolean evaluation.</p>&#13;
<p class="TX">Conversion via complete Boolean evaluation is almost identical to converting arithmetic expressions into assembly language, as covered in section 6.4, <span class="Xref">“Logical Expressions,”</span> on <span class="Xref"><a href="chapter6.xhtml#pg_312">page 312</a></span>. However, for Boolean evaluation, you do not need to store the result in a variable; once the evaluation of the expression is complete, you check whether you have a false (0) or true (1, or nonzero) result to take whatever action the Boolean expression dictates. Remember that only the <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> instruction sets the zero flag; there is <span role="doc-pagebreak" epub:type="pagebreak" id="pg_379" aria-label="379"/>no <span class="SANS_TheSansMonoCd_W5Regular_11">orrs</span> instruction. Consider the following <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement and its conversion to assembly language using complete Boolean evaluation:</p>&#13;
<pre id="pre-590"><code>//     if(((x &lt; y) &amp;&amp; (z &gt; t)) || (aa != bb))&#13;
//          <var>Stmt1</var> ;&#13;
//&#13;
// Assume all variables are 32-bit integers and are local&#13;
// variables in the activation record.&#13;
&#13;
          ldr  w0, [fp, #x]&#13;
          ldr  w1, [fp, #y]&#13;
          cmp  w0, w1&#13;
          cset w7, lt        // Store x &lt; y in W7.&#13;
          ldr  w0, [fp, #z]&#13;
          ldr  w1, [fp, #t]&#13;
          cmp  w0, w1&#13;
          cset w6, gt        // Store z &gt; t in W6.&#13;
          and  w6, w6, w7    // Put (x &lt; y) &amp;&amp; (z &gt; t) into W6.&#13;
          ldr  w0, [fp, #aa]&#13;
          ldr  w1, [fp, #bb]&#13;
          cmp  w0, w1&#13;
          cset w0, ne        // Store aa != bb into W0.&#13;
          orr  w0, w0, w6    // Put (x &lt; y) &amp;&amp; (z &gt; t) ||&#13;
          cmp  w0, #0        //    (aa != bb) into W0.&#13;
          beq  SkipStmt1     // Branch if result is false.&#13;
&#13;
      <var>Code for Stmt1</var>&#13;
&#13;
SkipStmt1:</code></pre>&#13;
<p class="TX">This code computes a Boolean result in the W0 register and then, at the end of the computation, tests this value to see whether it contains true or false. If the result is false, this sequence skips over the code associated with <span class="SANS_TheSansMonoCd_W5Regular_11">Stmt1</span>. The important thing is that the program will execute every instruction that computes this Boolean result (up to the <span class="SANS_TheSansMonoCd_W5Regular_11">beq</span> instruction).</p>&#13;
<p class="TX">By now you should recognize that we can improve this code by using the <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction:</p>&#13;
<pre id="pre-591"><code>          ldr  w0, [fp, #x]&#13;
          ldr  w1, [fp, #y]&#13;
          cmp  w0, w1&#13;
          ldr  w0, [fp, #z]&#13;
          ldr  w1, [fp, #t]&#13;
          ccmp w0, w1, #ccngt, lt&#13;
          ldr  w0, [fp, #aa]&#13;
          ldr  w1, [fp, #bb]&#13;
          ccmp w0, w1, #cceq, gt&#13;
          beq  SkipStmt1     // Branch if result is false.&#13;
&#13;
      <var>Code for Stmt1</var>&#13;
&#13;
SkipStmt1:</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_380" aria-label="380"/>The code is still a bit longer than usual, but this is the result of using memory variables rather than registers for everything in this example. Even though this example uses the <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction, the code still executes each and every instruction in the sequence, even if the condition becomes false early on and could never become true.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-140"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.6.4 Short-Circuit Boolean Evaluation</span></h4>&#13;
<p class="TNI1">If you are willing to expend a little more effort (and your Boolean expression doesn’t depend on side effects), you can often convert a Boolean expression to a faster sequence of assembly language instructions by using <i>short-circuit Boolean evaluation</i>. This approach attempts to determine whether an expression is true or false by executing only some of the instructions that would compute the complete expression.</p>&#13;
<p class="TX">Consider the expression <span class="SANS_TheSansMonoCd_W5Regular_11">aa &amp;&amp; bb</span>. Once you determine that <span class="SANS_TheSansMonoCd_W5Regular_11">aa</span> is false, there is no need to evaluate <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span> because there is no way the expression can be true. If <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span> represents a complex subexpression rather than a single Boolean variable, it should be clear that evaluating only <span class="SANS_TheSansMonoCd_W5Regular_11">aa</span> is more efficient.</p>&#13;
<p class="TX">As a concrete example, consider the subexpression <span class="SANS_TheSansMonoCd_W5Regular_11">((x &lt; y) &amp;&amp; (z &gt; t))</span>. Once you determine that <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> is not less than <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, there is no need to check whether <span class="SANS_TheSansMonoCd_W5Regular_11">z</span> is greater than <span class="SANS_TheSansMonoCd_W5Regular_11">t</span> because the expression will be false regardless of the values of <span class="SANS_TheSansMonoCd_W5Regular_11">z</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">t</span>. The following code fragment shows how to implement short-circuit Boolean evaluation for this expression:</p>&#13;
<pre id="pre-592"><code>// if((x &lt; y) &amp;&amp; (z &gt; t)) then ...&#13;
&#13;
          ldr  w0, [fp, #x]&#13;
          ldr  w1, [fp, #y]&#13;
          cmp  w0, w1&#13;
          bnlt TestFails&#13;
          ldr  w0, [fp, #z]&#13;
          ldr  w1, [fp, #t]&#13;
          cmp  w0, w1&#13;
          bngt TestFails&#13;
&#13;
<var>      Code for THEN clause of IF statement</var>&#13;
&#13;
TestFails:</code></pre>&#13;
<p class="TX">The code skips any further testing once it determines that <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> is not less than <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>. Of course, if <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> is less than <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, the program has to test <span class="SANS_TheSansMonoCd_W5Regular_11">z</span> to see if it is greater than <span class="SANS_TheSansMonoCd_W5Regular_11">t</span>; if not, the program skips over the <span class="SANS_TheSansMonoCd_W5Regular_11">then</span> clause. Only if the program satisfies both conditions does the code fall through to the <span class="SANS_TheSansMonoCd_W5Regular_11">then</span> clause.</p>&#13;
<p class="TX">For the logical OR operation, the technique is similar. If the first subexpression evaluates to true, there is no need to test the second operand. Whatever the second operand’s value is at that point, the full expression still evaluates to true. The following example demonstrates the use of short-circuit evaluation with disjunction (<span class="SANS_TheSansMonoCd_W5Regular_11">||</span>):</p>&#13;
<pre id="pre-593"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_381" aria-label="381"/>// if(W0 &lt; 'A' || W0 &gt; 'Z')&#13;
//     then printf("Not an uppercase char");&#13;
// endif;&#13;
&#13;
          cmp  w0, #'A'&#13;
          blo  ItsNotUC&#13;
          cmp  w0, #'Z'&#13;
          bnhi ItWasUC&#13;
&#13;
ItsNotUC:&#13;
<var>  Code to process W0 if it's not an uppercase character</var>&#13;
&#13;
ItWasUC:</code></pre>&#13;
<p class="TX">Because the conjunction and disjunction operators are commutative, you can evaluate the left or right operand first if it is more convenient to do so.</p>&#13;
<p class="TX">Be aware that some expressions depend on the leftmost subexpression evaluating one way in order for the rightmost subexpression to be valid; <span class="SANS_TheSansMonoCd_W5Regular_11">if(x != NULL &amp;&amp; x -&gt; y)</span> is a common test in C/C++, for example.</p>&#13;
<p class="TX">As one last example in this section, consider the full Boolean expression from the previous section:</p>&#13;
<pre id="pre-594"><code>// if(((x &lt; y) &amp;&amp; (z &gt; t)) || (aa != bb))  <var>Stmt1 </var>;&#13;
&#13;
          ldr  w0, [sb, #aa]   // Assume aa and bb are globals.&#13;
          ldr  w1, [sb, #bb]&#13;
          cmp  w0, w1&#13;
          bne  DoStmt1&#13;
          ldr  w0, [fp, #x]   // Assume x, y, z, and t&#13;
          ldr  w1, [fp, #y]   // are all locals.&#13;
          cmp  w0, w1&#13;
          bnlt SkipStmt1&#13;
          ldr  w0, [fp, #z]&#13;
          ldr  w1, [fp, #t]&#13;
          cmp  w0, w1&#13;
          bngt SkipStmt1&#13;
&#13;
DoStmt1:&#13;
<var>      Code for Stmt1</var>&#13;
&#13;
SkipStmt1:</code></pre>&#13;
<p class="TX">The code in this example evaluates <span class="SANS_TheSansMonoCd_W5Regular_11">aa != bb</span> first, because it is shorter and faster, and the remaining subexpression last. This is a common technique assembly language programmers use to write better code.</p>&#13;
<p class="TX">This assumes, of course, that all comparisons are equally likely to be true or false. If you can predict that the subexpression <span class="SANS_TheSansMonoCd_W5Regular_11">aa != bb</span> will be false the vast majority of the time, it would be best to test that condition last.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_382" aria-label="382"/>&#13;
<h4 class="H2" id="sec15"><span id="h2-141"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.6.5 Short-Circuit vs. Complete Boolean Evaluation</span></h4>&#13;
<p class="TNI1">When using complete Boolean evaluation, every statement in the sequence for that expression will execute; short-circuit Boolean evaluation, on the other hand, may not require the execution of every statement associated with the Boolean expression. As you’ve seen in the previous two sections, code based on short-circuit evaluation is often shorter and possibly faster.</p>&#13;
<p class="TX">However, short-circuit Boolean evaluation may not produce the correct result in some cases. Given an expression with <i>side effects</i> (changes to variables within the expression), short-circuit Boolean evaluation will produce a different result than complete Boolean evaluation. Consider the following C/C++ example:</p>&#13;
<pre id="pre-595"><code>if((x == y) &amp;&amp; (++z != 0))  <var>Stmt</var>;</code></pre>&#13;
<p class="TX">Using complete Boolean evaluation, you might generate the following:</p>&#13;
<pre id="pre-596"><code>          ldr  w0, [fp, #x]      // See if x == y.&#13;
          ldr  w1, [fp, #y]&#13;
          cmp  w0, w1&#13;
          ldr  w2, [fp, #z]&#13;
          add  w2, w1, 1         // ++z&#13;
          str  w2, [fp, #z]&#13;
          ccmp w2, #0, #cceq, eq&#13;
          beq  SkipStmt&#13;
&#13;
<var>      Code for Stmt</var>&#13;
&#13;
SkipStmt:</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction compares the incremented value of <span class="SANS_TheSansMonoCd_W5Regular_11">z</span> against 0, but only if <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>. If <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> is not equal to <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction sets the Z flag to 1 so that control transfers to <span class="SANS_TheSansMonoCd_W5Regular_11">SkipStmt</span> with the following <span class="SANS_TheSansMonoCd_W5Regular_11">beq</span> instruction.</p>&#13;
<p class="TX">Using short-circuit Boolean evaluation, you might generate the following code:</p>&#13;
<pre id="pre-597"><code>          ldr  w0, [fp, #x]      // See if x == y.&#13;
          ldr  w1, [fp, #y]&#13;
          cmp  w0, w1&#13;
          bne  SkipStmt&#13;
          ldr  w2, [fp, #z]&#13;
          adds w2, w1, 1         // ++z -- sets Z flag if z&#13;
          str  w2, [fp, #z]      // becomes 0.&#13;
          beq  SkipStmt          // See if incremented z is 0.&#13;
&#13;
<var>      Code for Stmt</var>&#13;
&#13;
SkipStmt:</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_383" aria-label="383"/>A subtle but important difference exists between these two conversions: if <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, the first version still <i>increments</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">z</span> <i>and compares it to 0</i> before it executes the code associated with <span class="SANS_TheSansMonoCd_W5Regular_11">Stmt</span>. The short-circuit version, on the other hand, skips the code that increments <span class="SANS_TheSansMonoCd_W5Regular_11">z</span> if it turns out that <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>. Therefore, the behavior of these two code fragments is different if <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>.</p>&#13;
<p class="TX">Neither implementation is wrong; depending on the circumstances, you may or may not want the code to increment <span class="SANS_TheSansMonoCd_W5Regular_11">z</span> if <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>. However, it is important to realize that these two schemes produce different results, so you can choose an appropriate implementation if the effect of this code on <span class="SANS_TheSansMonoCd_W5Regular_11">z</span> matters to your program.</p>&#13;
<p class="TX">Many programs take advantage of short-circuit Boolean evaluation and rely on the program not evaluating certain components of the expression. The following C/C++ code fragment demonstrates perhaps the most common example that requires short-circuit Boolean evaluation:</p>&#13;
<pre id="pre-598"><code>if(pntr != NULL &amp;&amp; *pntr == 'a')  <var>Stmt</var>;</code></pre>&#13;
<p class="TX">If it turns out that <span class="SANS_TheSansMonoCd_W5Regular_11">pntr</span> is NULL, the expression is false, and there is no need to evaluate the remainder of the expression. This statement relies on short-circuit Boolean evaluation for correct operation. Were C/C++ to use complete Boolean evaluation, the second half of the expression would attempt to dereference a <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> pointer, when <span class="SANS_TheSansMonoCd_W5Regular_11">pntr</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>.</p>&#13;
<p class="TX">Consider the translation of this statement using complete Boolean evaluation:</p>&#13;
<pre id="pre-599"><code>// Complete Boolean evaluation:&#13;
&#13;
          ldr  x0, [fp, #pntr]&#13;
          cmp  x0, #0    // Check to see if X0 is 0 (NULL is 0).&#13;
          cset w1, ne    // w1 = pntr != NULL&#13;
          ldrb w0, [x0]  // Get *pntr into W0.&#13;
          cmp  w0, #'a'&#13;
          cset w2, eq&#13;
          ands w1, w1, w2&#13;
          beq  SkipStmt&#13;
&#13;
  <var>    Code for Stmt</var>&#13;
&#13;
SkipStmt:</code></pre>&#13;
<p class="TX">If <span class="SANS_TheSansMonoCd_W5Regular_11">pntr</span> contains <span class="SANS_TheSansMonoCd_W5Regular_11">NULL (0)</span>, this program will attempt to access the data at location 0 in memory via the <span class="SANS_TheSansMonoCd_W5Regular_11">ldrb w0, [x0]</span> instruction. Under most OSes, this will cause a memory access fault (segmentation fault).</p>&#13;
<p class="TX">Now consider the short-circuit Boolean conversion:</p>&#13;
<pre id="pre-600"><code>      ldr  x0, [fp, #pntr] // See if pntr contains NULL (0)&#13;
      cmp  x0, #0          // and immediately skip past Stmt&#13;
      beq  SkipStmt        // if this is the case.&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_384" aria-label="384"/>      ldrb w0, [x0]        // If we get to this point, pntr&#13;
      cmp  w0, #'a'        // contains a non-NULL value, so see&#13;
      bne  SkipStmt        // if it points at the character 'a'.&#13;
&#13;
<var>       Code for Stmt</var>&#13;
&#13;
SkipStmt:</code></pre>&#13;
<p class="TX">In this example, the problem with dereferencing the <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> pointer doesn’t exist. If <span class="SANS_TheSansMonoCd_W5Regular_11">pntr</span> contains <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>, this code skips over the statements that attempt to access the memory address that <span class="SANS_TheSansMonoCd_W5Regular_11">pntr</span> contains.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h2-142"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.6.6 Efficient Implementation of if Statements in Assembly Language</span></h4>&#13;
<p class="TNI1">Encoding <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statements efficiently in assembly language takes a little more thought than simply choosing short-circuit evaluation over complete Boolean evaluation. To write code that executes as quickly as possible in assembly language, you must carefully analyze the situation and generate the code appropriately. The following paragraphs provide suggestions you can apply to your programs to improve their performance.</p>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h5 class="H3" id="sec17"><span class="SANS_Futura_Std_Bold_Condensed_B_11">7.6.6.1 Knowing Your Data</span></h5>&#13;
<p class="TNI1">Programmers often mistakenly assume that data is random. In reality, data is rarely random, and if you know the types of values that your program commonly uses, you can write better code. To see how, consider the following C/C++ statement:</p>&#13;
<pre id="pre-601"><code>if((aa == bb) &amp;&amp; (c &lt; d)) ++i;</code></pre>&#13;
<p class="TX">Because C/C++ uses short-circuit evaluation, this code will test whether <span class="SANS_TheSansMonoCd_W5Regular_11">aa</span> is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span>. If so, it will test whether <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> is less than <span class="SANS_TheSansMonoCd_W5Regular_11">d</span>. If you expect <span class="SANS_TheSansMonoCd_W5Regular_11">aa</span> to be equal to <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span> most of the time but don’t expect <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> to be less than <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> most of the time, this statement will execute slower than it should. Consider the following Gas implementation of this code:</p>&#13;
<pre id="pre-602"><code>          ldr  w0, [fp, #aa]&#13;
          ldr  w1, [fp, #bb]&#13;
          cmp  w0, w1&#13;
          bne  DontIncI&#13;
&#13;
          ldr  w0, [fp, #c]&#13;
          ldr  w1, [fp, #d]&#13;
          cmp  w0, w1&#13;
          bnlt DontIncI&#13;
&#13;
          ldr  w0, [sb, #i]&#13;
          add  w0, w0, #1&#13;
          str  w0, [sb, #i]&#13;
&#13;
DontIncI:</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_385" aria-label="385"/>As you can see, if <span class="SANS_TheSansMonoCd_W5Regular_11">aa</span> is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span> most of the time and <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> is not less than <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> most of the time, you will have to execute the first eight instructions nearly every time in order to determine that the expression is false. Now consider the following implementation that takes advantage of this knowledge and the fact that the <span class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</span> operator is commutative:</p>&#13;
<pre id="pre-603"><code>          ldr  w0, [fp, #c]&#13;
          ldr  w1, [fp, #d]&#13;
          cmp  w0, w1&#13;
          bnlt DontIncI&#13;
&#13;
          ldr  w0, [fp, #aa]&#13;
          ldr  w1, [fp, #bb]&#13;
          cmp  w0, w1&#13;
          bne  DontIncI&#13;
&#13;
          ldr  w0, [sb, #i]&#13;
          add  w0, w0, #1&#13;
          str  w0, [sb, #i]&#13;
&#13;
DontIncI:</code></pre>&#13;
<p class="TX">The code first checks whether <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> is less than <span class="SANS_TheSansMonoCd_W5Regular_11">d</span>. If most of the time <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> is not less than <span class="SANS_TheSansMonoCd_W5Regular_11">d</span>, this code determines that it has to skip to the label <span class="SANS_TheSansMonoCd_W5Regular_11">DontIncI</span> after executing only three instructions in the typical case, compared with seven instructions in the previous example.</p>&#13;
<p class="TX">Optimizations like this are much more obvious in assembly language than in an HLL, one of the main reasons assembly programs are often faster than their HLL counterparts. The key here is to understand the behavior of your data so you can make intelligent decisions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h5 class="H3" id="sec18"><span class="SANS_Futura_Std_Bold_Condensed_B_11">7.6.6.2 Rearranging Expressions</span></h5>&#13;
<p class="TNI1">Even if your data is random, or you can’t determine how the input values will affect your decisions, rearranging the terms in your expressions may still be beneficial. Some calculations take far longer to compute than others. For example, computing the remainder is slower than a simple <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction. Therefore, if you have a statement like the following, you may want to rearrange the expression so that the <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> comes first:</p>&#13;
<pre id="pre-604"><code>if((x % 10 = 0) &amp;&amp; (x != y)) ++x;</code></pre>&#13;
<p class="TX">Converted directly to assembly code, this <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement becomes the following:</p>&#13;
<pre id="pre-605"><code>          ldr   w1, [fp, #x]      // Compute x % 10.&#13;
          mov   w2, #10&#13;
          udiv  w0, w1, w2&#13;
          msub  w0, w0, w2, w1&#13;
          cmp   w0, #0&#13;
          bne   SkipIf&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_386" aria-label="386"/>          ldr   w0, [fp, #x]&#13;
          ldr   w1, [fp, #y]&#13;
          cmp   w0, w1&#13;
          beq   SkipIf&#13;
&#13;
          add   w0, w0, #1        // ++x&#13;
          str   w0, [fp, #x]&#13;
&#13;
SkipIf:</code></pre>&#13;
<p class="TX">The remainder computation is expensive (about one-third the speed of most of the other instructions in this example). Unless it is three times more likely that the remainder is 0 rather than <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, it would be better to do the comparison first and the remainder calculation afterward:</p>&#13;
<pre id="pre-606"><code>          ldr   w1, [fp, #x]      // Compute x % 10.&#13;
          ldr   w1, [fp, #y]&#13;
          cmp   w0, w1&#13;
          beq   SkipIf&#13;
&#13;
          ldr   w1, [fp, #x]&#13;
          mov   w2, #10&#13;
          udiv  w0, w1, w2&#13;
          msub  w0, w0, w2, w1&#13;
          cmp   w0, #0&#13;
          bne   SkipIf&#13;
&#13;
          add   w1, w1, #1        // ++x&#13;
          str   w1, [fp, #x]&#13;
&#13;
SkipIf:</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">||</span> operators are commutative in the mathematical sense that if you evaluate that left or right side first, the logical result is the same. In terms of execution, they are not commutative because the order of evaluation may cause the code to skip the evaluation of the second subexpression; in particular, these operators may not be commutative if side effects occur within the expression. This example works fine because there are no side effects or possible exceptions being shielded by the reordered evaluation of the <span class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</span> operator.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h5 class="H3" id="sec19"><span class="SANS_Futura_Std_Bold_Condensed_B_11">7.6.6.3 Destructuring Code</span></h5>&#13;
<p class="TNI1">Structured code is sometimes less efficient than unstructured code because it introduces code duplication or extra branches that might not be present in unstructured code. Most of the time, this is tolerable because unstructured code is difficult to read and maintain; sacrificing some performance in exchange for maintainable code is often acceptable. In certain instances, however, you may need all the performance you can get and might choose to compromise the readability of your code.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_387" aria-label="387"/>In HLLs, you can often get away with writing structured code because the compiler will optimize it, producing unstructured machine code. Unfortunately, when writing in assembly language, the machine code you get is exactly equivalent to the assembly code you write.</p>&#13;
<p class="TX">Taking previously written structured code and rewriting it in an unstructured fashion to improve performance is known is <i>destructuring code</i>. The difference between unstructured code and destructured code is that unstructured code was written that way in the first place; destructured code started out as structured code and was purposefully written in an unstructured fashion to make it more efficient. Pure unstructured code is usually hard to read and maintain. Destructured code isn’t quite as bad because you limit the damage (unstructuring the code) to only those sections where it is absolutely necessary.</p>&#13;
<p class="TX">One classic way to destructure code is to use <i>code movement</i>, physically moving sections of code elsewhere in the program. You move code that your program rarely uses out of the way of code that executes most of the time.</p>&#13;
<p class="TX">Code movement can improve the efficiency of a program two ways. First, a branch that is taken is more expensive (time-consuming) than a branch that is not taken. If you move the rarely used code to another spot in the program and branch to it on the rare occasion the branch is taken, most of the time you will fall straight through to the code that executes most frequently. Second, sequential machine instructions consume cache storage. If you move rarely executed statements out of the normal code stream to another section of the program that is rarely loaded into cache, this will improve the cache performance of the system.</p>&#13;
<p class="TX">For example, consider the following pseudo C/C++ statement:</p>&#13;
<pre id="pre-607"><code>if(<var>See_If_an_Error_Has_Occurred</var>) &#13;
{&#13;
    <var> Statements to execute if no error</var> &#13;
}&#13;
else &#13;
{&#13;
     <var>Error-handling statements</var> &#13;
}</code></pre>&#13;
<p class="TX">In normal code, you don’t expect errors to be frequent. Therefore, you would typically expect the <span class="SANS_TheSansMonoCd_W5Regular_11">then</span> section of the preceding <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> to execute far more often than the <span class="SANS_TheSansMonoCd_W5Regular_11">else</span> clause. The preceding code could translate into the following assembly code:</p>&#13;
<pre id="pre-608"><code>     cmp <var>See_If_an_Error_Has_Occurred</var>, #true &#13;
     beq HandleTheError &#13;
&#13;
<var>           Statements to execute if no error</var> &#13;
&#13;
     b.al EndOfIf &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_388" aria-label="388"/>HandleTheError: &#13;
    <var>       Error-handling statements</var> &#13;
EndOfIf: </code></pre>&#13;
<p class="TX">If the expression is false, this code falls through to the normal statements and then jumps over the error-handling statements. Instructions that transfer control from one point in your program to another (for example, <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> instructions) tend to be slow. It is much faster to execute a sequential set of instructions than to jump all over the place in your program. Unfortunately, the preceding code doesn’t allow this.</p>&#13;
<p class="TX">One way to rectify this problem is to move the <span class="SANS_TheSansMonoCd_W5Regular_11">else</span> clause of the code somewhere else in your program. You could rewrite the code as follows:</p>&#13;
<pre id="pre-609"><code>     cmp <var>See_If_an_Error_Has_Occurred</var>, #true &#13;
     beq HandleTheError &#13;
&#13;
<var>           Statements to execute if no error</var> &#13;
&#13;
EndOfIf: &#13;
&#13;
  // At some other point in your program (typically after a b.al &#13;
  // or ret instruction), you would insert the following code: &#13;
&#13;
HandleTheError: &#13;
<var>           Error-handling statements</var> &#13;
     b.al EndOfIf </code></pre>&#13;
<p class="TX">The program isn’t any shorter. The <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> you removed from the original sequence winds up at the end of the <span class="SANS_TheSansMonoCd_W5Regular_11">else</span> clause. However, because the <span class="SANS_TheSansMonoCd_W5Regular_11">else</span> clause rarely executes, moving the <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> instruction from the <span class="SANS_TheSansMonoCd_W5Regular_11">then</span> clause (which executes frequently) to the <span class="SANS_TheSansMonoCd_W5Regular_11">else</span> clause is a big performance win, because the <span class="SANS_TheSansMonoCd_W5Regular_11">then</span> clause executes using only straight-line code. This technique is surprisingly effective in many time-critical code segments.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h5 class="H3" id="sec20"><span class="SANS_Futura_Std_Bold_Condensed_B_11">7.6.6.4 Calculating Rather than Branching</span></h5>&#13;
<p class="TNI1">On the ARM processor, branches are expensive compared to many other instructions. For this reason, it is sometimes better to execute more instructions in a sequence than fewer instructions that involve branching.</p>&#13;
<p class="TX">For example, consider the simple assignment <span class="SANS_TheSansMonoCd_W5Regular_11">w0 = abs(w0)</span>. Unfortunately, no ARM instruction computes the absolute value of an integer. The obvious way to handle this is with an instruction sequence that uses a conditional jump to skip over the <span class="SANS_TheSansMonoCd_W5Regular_11">neg</span> instruction (which creates a positive value in W0 if W0 was negative):</p>&#13;
<pre id="pre-610"><code>          cmp w0, #0&#13;
          bpl ItsPositive&#13;
&#13;
          neg w0, w0&#13;
&#13;
ItsPositive:</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_389" aria-label="389"/>Now consider the following sequence that will also do the job:</p>&#13;
<pre id="pre-611"><code>          cmp  w0, #0&#13;
          cneg w0, w0, mi</code></pre>&#13;
<p class="Continued1">Not only is the instruction set shorter, it also doesn’t involve any branches, so it runs faster. This demonstrates why it’s good to know the instruction set!</p>&#13;
<p class="TX">Another example of calculation versus branching that you’ve seen is using the <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction to handle conjunction and disjunction in a Boolean expression (see section 7.6.5, <span class="Xref">“Short-Circuit vs. Complete Boolean Evaluation,”</span> on <span class="Xref"><a href="chapter7.xhtml#pg_382">page 382</a></span>). Though they tend to execute more instructions than short-circuit evaluation, no branching is involved, and this often equates to faster-running code.</p>&#13;
<p class="TX">Sometimes calculation without branching isn’t possible. For certain types of branches (in particular, multiway branches), you can combine calculations with a single branch to handle complex operations, as discussed in the next section.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2" id="sec21"><span id="h2-143"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.6.7 switch...case Statements</span></h4>&#13;
<p class="TNI1">The C/C++ <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement takes the following form:</p>&#13;
<pre id="pre-612"><code>     switch(<var>expression</var>) &#13;
      {&#13;
         case <var>const1</var>: &#13;
           <var>Code to execute if</var> &#13;
<var>               expression equals const1</var> &#13;
&#13;
         case <var>const2</var>: &#13;
           <var>Code to execute if</var> &#13;
<var>               expression equals const2</var> &#13;
           . &#13;
           . &#13;
           . &#13;
         case <var>constn</var>: &#13;
           <var>Code to execute if</var> &#13;
<var>               expression equals constn</var> &#13;
&#13;
         default:  // Note that the default section is optional. &#13;
           <var>Code to execute if expression</var> &#13;
<var>               does not equal any of the case values</var> &#13;
&#13;
      }</code></pre>&#13;
<p class="TX">When this statement executes, it checks the value of the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">expression</span> against the constants <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">const1</span> to <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">constn</span>. If it finds a match, the corresponding statements execute.</p>&#13;
<p class="TX">C/C++ places a few restrictions on the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement. First, it allows only an integer expression (or something whose underlying type can be an integer). Second, all the constants in the <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> clauses must be unique. The <span role="doc-pagebreak" epub:type="pagebreak" id="pg_390" aria-label="390"/>next few subsections describe the semantics of the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement and various implementations and clarify the reasons for the restrictions.</p>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h5 class="H3" id="sec22"><span class="SANS_Futura_Std_Bold_Condensed_B_11">7.6.7.1 switch Statement Semantics</span></h5>&#13;
<p class="TNI1">Most introductory programming texts introduce the <span class="SANS_TheSansMonoCd_W5Regular_11">switch...case</span> statement by explaining it as a sequence of <span class="SANS_TheSansMonoCd_W5Regular_11">if...then...elseif...else...endif</span> statements. They might claim that the following two pieces of C/C++ code are equivalent:</p>&#13;
<pre id="pre-613"><code>switch(<var>w0)</var> &#13;
{&#13;
    case 0: printf("i=0"); break; &#13;
    case 1: printf("i=1"); break; &#13;
    case 2: printf("i=2"); break; &#13;
}&#13;
&#13;
if(w0 == 0) &#13;
    printf("i=0");&#13;
else if(w0 == 1) &#13;
    printf("i=1");&#13;
else if(w0 == 2) &#13;
    printf("i=2");</code></pre>&#13;
<p class="TX">While semantically these two code segments may be the same, their implementation is usually different. Whereas the <span class="SANS_TheSansMonoCd_W5Regular_11">if...then...elseif...else...endif</span> chain does a comparison for each conditional statement in the sequence, the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement normally uses an indirect jump to transfer control to any one of several statements with a single computation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h5 class="H3" id="sec23"><span class="SANS_Futura_Std_Bold_Condensed_B_11">7.6.7.2 if...else Implementation of switch</span></h5>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> (and <span class="SANS_TheSansMonoCd_W5Regular_11">if...else...elseif</span>) statements could be written in assembly language with the following code:</p>&#13;
<pre id="pre-614"><code>// if...then...else...endif form: &#13;
&#13;
          ldr w0, [fp, #i] &#13;
          cmp w0, #0         // Check for 0. &#13;
          bne Not0 &#13;
&#13;
  <var>Code to print "i = 0"</var>&#13;
&#13;
          b.al EndCase &#13;
&#13;
Not0: &#13;
          cmp w0, #1 &#13;
          bne Not1 &#13;
&#13;
<var>  Code to print "i = 1"</var>&#13;
&#13;
          b.al EndCase &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_391" aria-label="391"/>Not1: &#13;
          cmp w0, #2 &#13;
          bne EndCase &#13;
&#13;
  <var>Code to print "i = 2"</var>&#13;
&#13;
EndCase: </code></pre>&#13;
<p class="TX">This code takes longer to determine that the last case should execute than it does to determine whether the first case executes. This is because the <span class="SANS_TheSansMonoCd_W5Regular_11">if...else...elseif</span> version implements a linear search through the case values, checking them one at a time from first to last until it finds a match.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h5 class="H3" id="sec24"><span class="SANS_Futura_Std_Bold_Condensed_B_11">7.6.7.3 Indirect Jump switch Implementation</span></h5>&#13;
<p class="TNI1">A faster implementation of the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement is possible by using an <i>indirect jump table</i> (a table containing target addresses to jump to). This implementation uses the switch expression as an index into a table of addresses; each address points at the target case’s code to execute. The following example demonstrates the use of a jump table:</p>&#13;
<pre id="pre-615"><code>// Indirect jump version &#13;
&#13;
        ldr  w0, [fp, #i]   // Zero-extends into X0! &#13;
      <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> adr  x1, JmpTbl &#13;
      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> ldr  x0, [x1, x0, lsl #3] &#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> add  x0, x0, x1 &#13;
        br   x0 &#13;
&#13;
JmpTbl: .dword Stmt0-JmpTbl, Stmt1-JmpTbl, Stmt2-JmpTbl &#13;
&#13;
Stmt0: &#13;
&#13;
<var>  Code to print "i = 0"</var>&#13;
&#13;
        b.al EndCase &#13;
&#13;
Stmt1: &#13;
&#13;
<var>  Code to print "i = 1"</var>&#13;
&#13;
         b.al EndCase &#13;
&#13;
Stmt2: &#13;
&#13;
<var>  Code to print "i = 2"</var>&#13;
&#13;
EndCase: </code></pre>&#13;
<p class="TX">To use the scaled-indexed addressing mode, this code begins by loading the address of the jump table (<span class="SANS_TheSansMonoCd_W5Regular_11">JmpTbl</span>) into X1 <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Because <span class="SANS_TheSansMonoCd_W5Regular_11">JmpTbl</span> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_392" aria-label="392"/>is in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section (and nearby), the code uses the PC-relative addressing mode.</p>&#13;
<p class="TX">The code fetches the <i>i</i>th entry from <span class="SANS_TheSansMonoCd_W5Regular_11">JmpTbl</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Because each entry in the jump table is 8 bytes long, the code must multiply the index (<span class="SANS_TheSansMonoCd_W5Regular_11">i</span>, which is in X0) by 8, which the <span class="SANS_TheSansMonoCd_W5Regular_11">lsl #3</span> argument handles. The base address (in X1) plus index times 8 gives the address of the appropriate entry in <span class="SANS_TheSansMonoCd_W5Regular_11">JmpTbl</span>.</p>&#13;
<p class="TX">Because the entries in <span class="SANS_TheSansMonoCd_W5Regular_11">JmpTbl</span> are offsets rather than absolute addresses (remember, macOS doesn’t allow absolute addresses in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section), you must convert the offset to an absolute address by adding in the base address of the jump table <span class="CodeAnnotation" aria-label="annotation3">❸</span> (as each entry in the table is an offset from the base address). The following <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> instruction transfers control to the appropriate case in the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement.</p>&#13;
<p class="TX">To begin, a <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement requires that you create an array of pointers, with each element containing the address of a statement label in your code; those labels must be attached to the sequence of instructions to execute for each case in the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement. As noted in the code annotations, macOS does not allow absolute addresses here, so the code uses offsets from the base address of the jump table, which also works for Linux. In this example, the <span class="SANS_TheSansMonoCd_W5Regular_11">JmpTbl</span> array, initialized with the offsets of the statement labels <span class="SANS_TheSansMonoCd_W5Regular_11">Stmt0</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">Stmt1</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">Stmt2</span>, serves this purpose. You must place the jump-table array in a location that will never be executed as code (such as immediately after a <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> instruction, as in this example).</p>&#13;
<p class="TX">The program loads the W0 register with the value of <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> (assuming <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> is a 32-bit unsigned integer, the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction zero-extends W0 into X0). It then uses this value as an index into the <span class="SANS_TheSansMonoCd_W5Regular_11">JmpTbl</span> array (W1 holds the base address of the <span class="SANS_TheSansMonoCd_W5Regular_11">JmpTbl</span> array) and transfers control to the 8-byte address found at the specified location. For example, if W0 contains 0, the <span class="SANS_TheSansMonoCd_W5Regular_11">br x0</span> instruction will fetch the double word at address <span class="SANS_TheSansMonoCd_W5Regular_11">JmpTbl+0</span> (W0 × 8 = 0). Because the first double word in the table contains the offset of <span class="SANS_TheSansMonoCd_W5Regular_11">Stmt0</span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> instruction transfers control to the first instruction following the <span class="SANS_TheSansMonoCd_W5Regular_11">Stmt0</span> label. Likewise, if <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> (and therefore, W0) contains 1, then the indirect <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> instruction fetches the double word at offset 8 from the table and transfers control to the first instruction following the <span class="SANS_TheSansMonoCd_W5Regular_11">Stmt1</span> label (because the offset of <span class="SANS_TheSansMonoCd_W5Regular_11">Stmt1</span> appears at offset 8 in the table). Finally, if <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> (W0) contains 2, then this code fragment transfers control to the statements following the <span class="SANS_TheSansMonoCd_W5Regular_11">Stmt2</span> label because it appears at offset 16 in the <span class="SANS_TheSansMonoCd_W5Regular_11">JmpTbl</span> table.</p>&#13;
<p class="TX">As you add more (consecutive) cases, the jump-table implementation becomes more efficient (in terms of both space and speed) than the <span class="SANS_TheSansMonoCd_W5Regular_11">if...elseif</span> form. Except for simple cases, the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement is almost always faster, and usually by a large margin. As long as the <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> values are consecutive, the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement version is often smaller as well.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h5 class="H3" id="sec25"><span class="SANS_Futura_Std_Bold_Condensed_B_11">7.6.7.4 Noncontiguous Jump-Table Entries and Range Limiting</span></h5>&#13;
<p class="TNI1">What happens if you need to include nonconsecutive <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> labels or can’t be sure the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> value doesn’t go out of range? With the C/C++ <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement, such an occurrence will transfer control to the first statement after the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement (or to a <span class="SANS_TheSansMonoCd_W5Regular_11">default</span> case, if one is present in the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span>).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_393" aria-label="393"/>However, this doesn’t happen in the example in the previous section. If variable <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> does not contain 0, 1, or 2, executing the previous code produces undefined results. For example, if <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> contains 5 when you execute the code, the indirect <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> instruction will fetch the dword at offset 40 (5 × 8) in <span class="SANS_TheSansMonoCd_W5Regular_11">JmpTbl</span> and transfer control to that offset. Unfortunately, <span class="SANS_TheSansMonoCd_W5Regular_11">JmpTbl</span> doesn’t have six entries, so the program will fetch the value of the sixth double word following <span class="SANS_TheSansMonoCd_W5Regular_11">JmpTbl</span> and use that as the target offset, which will often crash your program or transfer control to an unexpected location.</p>&#13;
<p class="TX">The solution is to place a few instructions before the indirect <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> to verify that the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> selection value is within a reasonable range. In the previous example, you’d want to verify that the value of <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> is in the range 0 to 2 before executing the <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> instruction. If the value of <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> is outside this range, the program should simply jump to the <span class="SANS_TheSansMonoCd_W5Regular_11">endcase</span> label, which corresponds to dropping down to the first statement after the entire <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement. The following code provides this modification:</p>&#13;
<pre id="pre-616"><code>        ldr  w0, [fp, #i]  // Zero-extends into X0! &#13;
        cmp  w0, #2        // Default case if i &gt; 2 &#13;
        bhi  EndCase &#13;
        adr  x1, JmpTbl &#13;
        ldr  x0, [x1, x0, lsl #3] &#13;
        add  x0, x0, x1 &#13;
        br   x0 &#13;
&#13;
JmpTbl: .dword Stmt0-JmpTbl, Stmt1-JmpTbl, Stmt2-JmpTbl &#13;
&#13;
Stmt0: &#13;
&#13;
<var>  Code to print "i = 0"</var>&#13;
&#13;
        b.al EndCase &#13;
&#13;
Stmt1: &#13;
&#13;
<var>  Code to print "i = 1"</var>&#13;
&#13;
        b.al EndCase &#13;
&#13;
Stmt2: &#13;
&#13;
<var>  Code to print "i = 2"</var>&#13;
&#13;
EndCase: </code></pre>&#13;
<p class="TX">Although this code handles the problem of selection values being outside the range 0 to 2, it still suffers from two severe restrictions:</p>&#13;
<ul class="ul">&#13;
<li class="BL">The cases must start with the value 0. That is, the minimum <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> constant has to be 0.</li>&#13;
<li class="BL">The case values must be contiguous.</li>&#13;
</ul>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_394" aria-label="394"/>Solving the first problem is easy, and you deal with it in two steps. First, you compare the case selection value against a lower and upper bound before determining whether the case value is legal, as shown in the following example:</p>&#13;
<pre id="pre-617"><code>// SWITCH statement specifying cases 5, 6, and 7: &#13;
// WARNING: This code does *NOT* work. &#13;
// Keep reading to find out why. &#13;
&#13;
        ldr  w0, [fp, #i]  // Zero-extends into X0! &#13;
        cmp  w0, #5        // Verify i is in the range &#13;
        blo  EndCase       // 5 to 7 before indirect &#13;
        cmp  w0, #7        // branch executes. &#13;
        bhi  EndCase &#13;
        adr  x1, JmpTbl &#13;
        ldr  x0, [x1, x0, lsl #3] &#13;
        add  x0, x0, x1 &#13;
        br   x0 &#13;
&#13;
JmpTbl: .dword Stmt5-JmpTbl, Stmt6-JmpTbl, Stmt7-JmpTbl &#13;
&#13;
Stmt5: &#13;
<var>  Code to print "i = 5"</var>&#13;
&#13;
        b.al EndCase &#13;
&#13;
Stmt6: &#13;
<var>  Code to print "i = 6"</var>&#13;
&#13;
        b.al EndCase &#13;
&#13;
Stmt7: &#13;
<var>  Code to print "i = 7"</var>&#13;
&#13;
EndCase: </code></pre>&#13;
<p class="TX">This code adds a pair of extra instructions, <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">blo</span>, to test the selection value to ensure it is in the range 5 to 7. If not, control drops down to the <span class="SANS_TheSansMonoCd_W5Regular_11">EndCase</span> label; otherwise, control transfers via the indirect <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> instruction. Unfortunately, as the comments point out, this code is broken.</p>&#13;
<p class="TX">Consider what happens if variable <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> contains the value 5: the code will verify that 5 is in the range 5 to 7 and then will fetch the dword at offset 40 (5 × 8) and jump to that address. As before, however, this loads 8 bytes outside the bounds of the table and does not transfer control to a defined location. One solution is to subtract the smallest case selection value from W0 before executing the <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> instruction, as shown in the following example:</p>&#13;
<pre id="pre-618"><code>// SWITCH statement specifying cases 5, 6, and 7: &#13;
&#13;
        ldr  w0, [fp, #i]  // Zero-extends into X0! &#13;
        subs w0, w0, #5    // Subtract smallest range. &#13;
        blo  EndCase       // Subtract sets flags same as cmp! &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_395" aria-label="395"/>        cmp  w0, #7-5      // Verify in range 5 to 7. &#13;
        bhi  EndCase &#13;
        adr  x1, JmpTbl &#13;
        ldr  x0, [x1, x0, lsl #3] &#13;
        add  x0, x0, x1 &#13;
        br   x0 &#13;
&#13;
JmpTbl: .dword Stmt5-JmpTbl, Stmt6-JmpTbl, Stmt7-JmpTbl &#13;
&#13;
Stmt5: &#13;
<var>  Code to print "i = 5"</var>&#13;
        b.al EndCase &#13;
&#13;
Stmt6: &#13;
<var>  Code to print "i = 6"</var>&#13;
        b.al EndCase &#13;
&#13;
Stmt7: &#13;
<var>  Code to print "i = 7"</var>&#13;
&#13;
EndCase: </code></pre>&#13;
<p class="TX">By subtracting 5 from the value in W0, the code forces W0 to take on the value 0, 1, or 2 prior to the <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> instruction. Therefore, case-selection value 5 jumps to <span class="SANS_TheSansMonoCd_W5Regular_11">Stmt5</span>, case-selection value 6 transfers control to <span class="SANS_TheSansMonoCd_W5Regular_11">Stmt6</span>, and case-selection value 7 jumps to <span class="SANS_TheSansMonoCd_W5Regular_11">Stmt7</span>.</p>&#13;
<p class="TX">This code has one piece of trickery: the <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span> instruction serves double duty. It not only adjusts the lower bound of the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> expression down to 0 but also serves as the comparison against <span class="SANS_TheSansMonoCd_W5Regular_11">5</span> for the lower bound. Remember, the <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction sets the flags the same way as the <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span> instruction. Therefore, subtracting <span class="SANS_TheSansMonoCd_W5Regular_11">5</span> is the same as comparing against <span class="SANS_TheSansMonoCd_W5Regular_11">5</span> as far as the flag settings are concerned. When comparing the value in W0 against <span class="SANS_TheSansMonoCd_W5Regular_11">7</span>, the code must actually compare against <span class="SANS_TheSansMonoCd_W5Regular_11">2</span> because we’ve subtracted <span class="SANS_TheSansMonoCd_W5Regular_11">5</span> from the original index value.</p>&#13;
<p class="TX">You can handle cases that don’t start with 0 in another way:</p>&#13;
<pre id="pre-619"><code>// SWITCH statement specifying cases 5, 6, and 7: &#13;
&#13;
        ldr  w0, [fp, #i]  // Zero-extends into X0! &#13;
        cmp  w0, #5        // Verify the index is in &#13;
        blo  EndCase       // the range 5 to 7. &#13;
        cmp  w0, #7 &#13;
        bhi  EndCase &#13;
        adr  x1, JmpTbl - 5*8 // Base address - 40 &#13;
        ldr  x0, [x1, x0, lsl #3] &#13;
        add  x0, x0, x1 &#13;
        br   x0 &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_396" aria-label="396"/>JmpTbl: .dword Stmt5-JmpTbl, Stmt6-JmpTbl, Stmt7-JmpTbl &#13;
&#13;
Stmt5: &#13;
&#13;
<var>  Code to print "i = 5"</var>&#13;
&#13;
        b.al EndCase &#13;
&#13;
Stmt6: &#13;
&#13;
<var>  Code to print "i = 6"</var>&#13;
&#13;
        b.al EndCase &#13;
&#13;
Stmt7: &#13;
&#13;
<var>  Code to print "i = 7"</var>&#13;
&#13;
EndCase: </code></pre>&#13;
<p class="TX">This example subtracts 40 (5 × 8) from the base address of the jump table when loading that base address into X1. The index is still in the range 5 to 7, yielding an offset of 40 to 56 into the table; however, because the base address is now specified 40 bytes before the actual table, the array-indexing calculation properly indexes into the jump-table entries.</p>&#13;
<p class="TX">The C/C++ <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement provides a <span class="SANS_TheSansMonoCd_W5Regular_11">default</span> clause that executes if the case-selection value doesn’t match any of the case values. The following <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement includes a <span class="SANS_TheSansMonoCd_W5Regular_11">default</span> clause:</p>&#13;
<pre id="pre-620"><code>switch(<var>expression</var>) &#13;
{&#13;
&#13;
    case 5:  printf("expression = 5"); break; &#13;
    case 6:  printf("expression = 6"); break; &#13;
    case 7:  printf("expression = 7"); break; &#13;
    default: &#13;
        printf("expression does not equal 5, 6, or 7");&#13;
}</code></pre>&#13;
<p class="TX">Implementing the equivalent of the <span class="SANS_TheSansMonoCd_W5Regular_11">default</span> clause in pure assembly language is easy: just use a different target label in the <span class="SANS_TheSansMonoCd_W5Regular_11">blo</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">bhi</span> instructions at the beginning of the code. The following example implements a <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement similar to the preceding one:</p>&#13;
<pre id="pre-621"><code>// SWITCH statement specifying cases 5, 6, and 7: &#13;
&#13;
        ldr  w0, [fp, #i]     // Zero-extends into X0! &#13;
        cmp  w0, #5           // Verify the index is in &#13;
        blo  DefaultCase      // the range 5 to 7. &#13;
        cmp  w0, #7 &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_397" aria-label="397"/>        bhi  DefaultCase &#13;
        adr  x1, JmpTbl - 5 * 8 // Base address - 40 &#13;
        ldr  x0, [x1, x0, lsl #3] &#13;
        add  x0, x0, x1 &#13;
        br   x0 &#13;
&#13;
JmpTbl: .dword Stmt5-JmpTbl, Stmt6-JmpTbl, Stmt7-JmpTbl &#13;
&#13;
Stmt5: &#13;
&#13;
<var>  Code to print "i = 5"</var>&#13;
&#13;
        b.al EndCase &#13;
&#13;
Stmt6: &#13;
&#13;
<var>  Code to print "i = 6"</var>&#13;
&#13;
        b.al EndCase &#13;
&#13;
Stmt7: &#13;
&#13;
<var>  Code to print "i = 7"</var>&#13;
&#13;
        b.al EndCase &#13;
&#13;
DefaultCase: &#13;
&#13;
  <var>Code to print</var> <var>"expression does not equal 5, 6, or 7"</var>&#13;
&#13;
EndCase: </code></pre>&#13;
<p class="TX">The second restriction noted earlier, that the case values need to be contiguous, is easy to handle by inserting extra entries into the jump table. Consider the following C/C++ <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement:</p>&#13;
<pre id="pre-622"><code>switch(i) &#13;
{&#13;
    case 1:  printf("i = 1"); break; &#13;
    case 2:  printf("i = 2"); break; &#13;
    case 4:  printf("i = 4"); break; &#13;
    case 8:  printf("i = 8"); break; &#13;
    default: &#13;
        printf("i is not 1, 2, 4, or 8");&#13;
}</code></pre>&#13;
<p class="TX">The minimum switch value is 1, and the maximum value is 8. Therefore, the code before the indirect <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> instruction needs to compare the value in <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> against 1 and 8. If the value is from 1 to 8, it’s still possible that <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> might not contain a legal case-selection value. However, because the <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> instruction indexes into a table of double words, the table must have eight double-word entries.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_398" aria-label="398"/>To handle the values from 1 to 8 that are not case-selection values, simply put the statement label of the <span class="SANS_TheSansMonoCd_W5Regular_11">default</span> clause (or the label specifying the first instruction after the end of the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> if there is no <span class="SANS_TheSansMonoCd_W5Regular_11">default</span> clause) in each of the jump-table entries that don’t have a corresponding <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> clause. The following code demonstrates this technique:</p>&#13;
<pre id="pre-623"><code>// SWITCH statement specifying cases 1, 2, 4, and 8: &#13;
&#13;
        ldr  w0, [fp, #i]     // Zero-extends into X0! &#13;
        cmp  w0, #1           // Verify the index is in &#13;
        blo  DefaultCase      // the range 1 to 8. &#13;
        cmp  w0, #8 &#13;
        bhi  DefaultCase &#13;
        adr  x1, JmpTbl - 1 * 8 // Base address - 8 &#13;
        ldr  x0, [x1, x0, lsl #3] &#13;
        add  x0, x0, x1 &#13;
        br   x0 &#13;
&#13;
JmpTbl: .dword Stmt1-JmpTbl &#13;
        .dword Stmt2-JmpTbl &#13;
        .dword DefaultCase-JmpTbl // Case 3 &#13;
        .dword Stmt4-JmpTbl &#13;
        .dword DefaultCase-JmpTbl // Case 5 &#13;
        .dword DefaultCase-JmpTbl // Case 6 &#13;
        .dword DefaultCase-JmpTbl // Case 7 &#13;
        .dword Stmt8-JmpTbl &#13;
&#13;
Stmt1: &#13;
&#13;
<var>  Code to print "i = 1"</var>&#13;
&#13;
        b.al EndCase &#13;
&#13;
Stmt2: &#13;
&#13;
<var>  Code to print "i = 2"</var>&#13;
&#13;
        b.al EndCase &#13;
&#13;
Stmt4: &#13;
&#13;
<var>  Code to print "i = 4"</var>&#13;
&#13;
        b.al EndCase &#13;
&#13;
Stmt8: &#13;
&#13;
<var>  Code to print "i = 8"</var>&#13;
&#13;
        b.al EndCase &#13;
&#13;
DefaultCase: &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_399" aria-label="399"/>  <var>Code to print</var> <var>"expression does not equal 1, 2, 4, or 8"</var>&#13;
&#13;
EndCase: </code></pre>&#13;
<p class="TX">This code uses <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instructions to ensure that the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> value is in the range 1 to 8 and transfers control to the <span class="SANS_TheSansMonoCd_W5Regular_11">DefaultCase</span> label if this is the case.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h5 class="H3" id="sec26"><span class="SANS_Futura_Std_Bold_Condensed_B_11">7.6.7.5 Sparse Jump Tables</span></h5>&#13;
<p class="TNI1">The current implementation of the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement has a problem. If the <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> values contain nonconsecutive entries that are widely spaced, the jump table could become exceedingly large. The following <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement would generate an extremely large code file:</p>&#13;
<pre id="pre-624"><code>switch(i) &#13;
{&#13;
    case 1:        <var>Stmt1</var> ; &#13;
    case 100:      <var>Stmt2</var> ; &#13;
    case 1000:     <var>Stmt3</var> ; &#13;
    case 10000:    <var>Stmt4</var> ; &#13;
    default:       <var>Stmt5</var> ; &#13;
&#13;
} </code></pre>&#13;
<p class="TX">In this situation, your program will be much smaller if you implement the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement with a sequence of <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statements rather than using an indirect jump statement. However, the size of the jump table does not normally affect the execution speed of the program. If the jump table contains 2 entries or 2,000, the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement will execute the multiway branch in a constant amount of time. The <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement implementation requires a linearly increasing amount of time for each <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> label appearing in the <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> statement.</p>&#13;
<p class="TX">One of the biggest advantages to using assembly language over an HLL like Swift or C/C++ is that you get to choose the actual implementation of statements like <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span>. In some instances, you can implement a <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement as a sequence of <span class="SANS_TheSansMonoCd_W5Regular_11">if...then...elseif</span> statements, you can implement it as a jump table, or you can use a hybrid of the two. The following code examples demonstrate combining <span class="SANS_TheSansMonoCd_W5Regular_11">if...then...elseif</span> and jump-table implementations for the same control structure:</p>&#13;
<pre id="pre-625"><code>switch(i) &#13;
{&#13;
    case 0:    <var>Stmt0</var> ; &#13;
    case 1:    <var>Stmt1</var> ; &#13;
    case 2:    <var>Stmt2</var> ; &#13;
    case 100:  <var>Stmt3</var> ; &#13;
    default:   <var>Stmt4</var> ; &#13;
&#13;
} </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_400" aria-label="400"/>That code could become the following:</p>&#13;
<pre id="pre-626"><code>        ldr  w0, [fp, #i] &#13;
        cmp  w0, #100         // Special case 100 &#13;
        beq  DoStmt3 &#13;
        cmp  w0, #2 &#13;
        bhi  DefaultCase &#13;
        adr  x1, JmpTbl &#13;
        ldr  x0, [x1, x0, lsl #3] &#13;
        add  x0, x0, x1 &#13;
        br   x0 &#13;
         . &#13;
         . &#13;
         . </code></pre>&#13;
<p class="TX">Some <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statements have sparse cases, but the cases are often grouped into contiguous clusters. Consider the following C/C++ <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement:</p>&#13;
<pre id="pre-627"><code>switch(<var>expression</var>) &#13;
{&#13;
    case 0: &#13;
&#13;
  <var>Code for case 0</var> &#13;
&#13;
        break; &#13;
&#13;
    case 1: &#13;
&#13;
  <var>Code for case 1</var> &#13;
&#13;
        break; &#13;
&#13;
    case 2: &#13;
&#13;
  <var>Code for case 2</var> &#13;
&#13;
        break; &#13;
&#13;
    case 10: &#13;
&#13;
  <var>Code for case 10</var> &#13;
&#13;
        break; &#13;
&#13;
    case 11: &#13;
&#13;
<var>  Code for case 11</var> &#13;
&#13;
        break; &#13;
&#13;
    case 100: &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_401" aria-label="401"/>  <var>Code for case 100</var> &#13;
&#13;
        break; &#13;
&#13;
    case 101: &#13;
&#13;
  <var>Code for case 101</var> &#13;
&#13;
        break; &#13;
&#13;
    case 103: &#13;
&#13;
  <var>Code for case 103</var> &#13;
&#13;
        break; &#13;
&#13;
    case 1000: &#13;
&#13;
  <var>Code for case 1000</var> &#13;
&#13;
        break; &#13;
&#13;
    case 1001: &#13;
&#13;
  <var>Code for case 1001</var> &#13;
&#13;
        break; &#13;
&#13;
    case 1003: &#13;
&#13;
  <var>Code for case 1003</var> &#13;
&#13;
        break; &#13;
&#13;
    default: &#13;
&#13;
<var>  Code for default case</var> &#13;
&#13;
        break; &#13;
} // End switch. </code></pre>&#13;
<p class="TX">You can convert a <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement that consists of widely separated groups of (nearly) contiguous cases to assembly language code using one jump-table implementation for each contiguous group, then use comparison instructions to determine which jump-table instruction sequence to execute. Here’s one possible implementation of the previous C/C++ code:</p>&#13;
<pre id="pre-628"><code>// Assume expression has been computed and is sitting in X0 &#13;
// at this point ... &#13;
&#13;
         cmp   x0, #100 &#13;
         blo   try0_11 &#13;
         cmp   x0, #103 &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_402" aria-label="402"/>         bhi   try1000_1003 &#13;
         adr   x1, jt100 - 100*8 &#13;
         ldr   x0, [x1, x0, lsl #3] &#13;
         add   x0, x0, x1 &#13;
         br    x0 &#13;
&#13;
jt100:   .dword case100-jt100, case101-jt100 &#13;
         .dword default-jt100, case103-jt100 &#13;
&#13;
try0_11: cmp   x0, #11 // Handle cases 0-11 here. &#13;
         bhi   default &#13;
         adr   x1, jt0_11 &#13;
         ldr   x0, [x1, x0, lsl #3] &#13;
         add   x0, x0, x1 &#13;
         br    x0 &#13;
&#13;
jt0_11:  .dword case0-jt0_11, case1-jt0_11, case2-jt0_11 &#13;
         .dword default-jt0_11, default-jt0_11 &#13;
         .dword default-jt0_11, default-jt0_11 &#13;
         .dword default-jt0_11, default-jt0_11 &#13;
         .dword default-jt0_11, case10-jt0_11, case11-jt0_11 &#13;
&#13;
try1000_1003: &#13;
         cmp   x0, #1000 &#13;
         blo   default &#13;
         cmp   x0, #1003 &#13;
         bhi   default &#13;
         adr   x1, jt1000 - 1000*8 &#13;
         ldr   x0, [x1, x0, lsl #3] &#13;
         add   x0, x0, x1 &#13;
         br    x0 &#13;
jt1000:  .dword case1000-jt1000, case1001-jt1000 &#13;
         .dword default-jt1000, case1003-jt1000 &#13;
           . &#13;
           . &#13;
           . &#13;
<var>  Code for the actual cases here</var> </code></pre>&#13;
<p class="TX">This code sequence combines groups 0 to 2 and 10 to 11 into a single group (requiring seven additional jump-table entries) in order to save having to write an additional jump-table sequence. For a set of cases this simple, it’s easier to just use compare-and-branch sequences, but I’ve simplified this example to demonstrate multiple jump tables.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h5 class="H3" id="sec27"><span class="SANS_Futura_Std_Bold_Condensed_B_11">7.6.7.6 Other switch Statement Alternatives</span></h5>&#13;
<p class="TNI1">What happens if the cases are too sparse to do anything but compare the expression’s value case by case? In this situation, the code is not necessarily doomed to being translated into the equivalent of an <span class="SANS_TheSansMonoCd_W5Regular_11">if...elseif...else...endif</span> sequence. However, before considering other alternatives, remember that not all <span class="SANS_TheSansMonoCd_W5Regular_11">if...elseif...else...endif</span> sequences are created equal. Look back at the last example in the previous section (the sparse <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_403" aria-label="403"/>statement). A straightforward implementation might have been something like this:</p>&#13;
<pre id="pre-629"><code>if(unsignedExpression &lt;= 11) &#13;
{&#13;
  <var>Switch for 0 to 11.</var> &#13;
}&#13;
else if(unsignedExpression &gt;= 100 &amp;&amp; unsignedExpression &lt;= 103) &#13;
{&#13;
  <var>Switch for 100 to 103.</var> &#13;
}&#13;
else if(unsignedExpression &gt;= 1000 &amp;&amp; unsignedExpression &lt;= 1003) &#13;
{&#13;
  <var>Switch for 1000 to 1003.</var> &#13;
}&#13;
else &#13;
{&#13;
<var>  Code for default case</var> &#13;
}</code></pre>&#13;
<p class="TX">Instead, the former implementation first tests against the value 100 and branches based on the comparison being less than (cases 0 to 11) or greater than (cases 1000 to 1001), effectively creating a small <i>binary search</i> that reduces the number of comparisons. It’s hard to see the savings in the HLL code, but in assembly code you can count the number of instructions that would be executed in the best and worst cases and see an improvement over the standard <i>linear search</i> approach of simply comparing the values in the cases in the order they appear in the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement. (Of course, if you have many groups in a sparse <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement, a binary search will be much faster, on average, than a linear search.)</p>&#13;
<p class="TX">If your cases are too sparse (no meaningful groups at all), such as the 1, 10, 100, 1,000, 10,000 example given in section 7.6.7.5, <span class="Xref">“Sparse Jump Tables,”</span> on <span class="Xref"><a href="chapter7.xhtml#pg_399">page 399</a></span>, you can’t reasonably implement the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement by using a jump table. Rather than devolving into a straight linear search, which can be slow, a better solution is to sort your cases and test them by using a binary search.</p>&#13;
<p class="TX">With a <i>binary search</i>, you first compare the expression value against the middle case value. If it’s less than the middle value, you repeat the search on the first half of the list of values; if it’s greater than the middle value, you repeat the test on the second half of the values; if it’s equal, obviously you drop into the code to handle that test. The following code shows the binary search version of the 1, 10, 100, ... example:</p>&#13;
<pre id="pre-630"><code>// Assume expression has been calculated into X0. &#13;
&#13;
        cmp x0, #100 &#13;
        blo try1_10 &#13;
        bhi try1000_10000 &#13;
&#13;
<var>    Code to handle case 100</var> &#13;
&#13;
        b.al AllDone &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_404" aria-label="404"/>try1_10: &#13;
        cmp x0, #1 &#13;
        beq case1 &#13;
        cmp x0, #10 &#13;
        bne defaultCase &#13;
&#13;
<var>    Code to handle case 10</var> &#13;
&#13;
        b.al AllDone &#13;
case1: &#13;
  <var>  Code to handle case 1</var> &#13;
&#13;
        b.al AllDone &#13;
&#13;
try1000_10000: &#13;
        cmp x0, #1000 &#13;
        beq case1000 &#13;
        mov x1, #10000   // cmp can't handle 10000. &#13;
        cmp x0, x1 &#13;
        bne defaultCase &#13;
&#13;
<var>    Code to handle case 10,000</var> &#13;
&#13;
        b.al AllDone &#13;
&#13;
case1000: &#13;
&#13;
<var>    Code to handle case 1,000</var> &#13;
&#13;
        b.al AllDone &#13;
&#13;
defaultCase: &#13;
&#13;
<var>    Code to handle defaultCase</var> &#13;
&#13;
AllDone: </code></pre>&#13;
<p class="TX">The techniques presented in this section have many possible alternatives. For example, one common solution is to create a table containing a set of records, with each record entry a two-tuple containing a case value and a jump address. Rather than having a long sequence of compare instructions, a short loop can sequence through all the table elements, searching for the case value and transferring control to the corresponding jump address if a match occurs. This scheme is slower than the other techniques in this section, but it can be much shorter than the traditional <span class="SANS_TheSansMonoCd_W5Regular_11">if...elseif...else...endif</span> implementation. With a little effort, you could use a binary search if the table is sorted.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h5 class="H3" id="sec28"><span class="SANS_Futura_Std_Bold_Condensed_B_11">7.6.7.7 Jump-Table Size Reductions</span></h5>&#13;
<p class="TNI1">All the <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement examples up to this point have used double-word arrays for the jump table. With a 64-bit offset, these jump tables can <span role="doc-pagebreak" epub:type="pagebreak" id="pg_405" aria-label="405"/>transfer control to any location in the ARM’s address space. In reality, this range is almost never necessary. Most offsets will be relatively small numbers (often less than ±128, or ±32,767). This means that the HO bits of the jump-table entries will likely be all 0s or all 1s (if the offset is negative). With a slight modification to the instructions that transfer control through the jump table, cutting the size of the table in half is easy:</p>&#13;
<pre id="pre-631"><code>        adr  x1, JmpTbl &#13;
        ldr  w0, [x1, x0, lsl #2]   // X4 for 32-bit entries &#13;
        add  x0, x1, w0, sxtw       // Sign-extend W0 to 64 bits. &#13;
        br   x0 &#13;
&#13;
JmpTbl: .word Stmt1-JmpTbl, ... </code></pre>&#13;
<p class="TX">This example has three modifications to the other examples in this chapter:</p>&#13;
<ul class="ul">&#13;
<li class="BL">The scaled-indexed addressing mode (<span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction) scales the index (in X0) by 4 instead of 8 (because we’re accessing elements of a word array rather than a dword array).</li>&#13;
<li class="BL">The <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> instruction sign-extends W0 to 64 bits before adding the value with X1.</li>&#13;
<li class="BL">The jump table contains word entries instead of dword entries.</li>&#13;
</ul>&#13;
<p class="TX">This modification limits the range of the case labels to ±2GB around the jump table, rather than the full 64-bit address space—hardly a limitation for most programs. In exchange for this limit, the jump table is now half its original size.</p>&#13;
<p class="TX">Before you get the sneaky idea of reducing the size of the table entries to 16 bits (giving you a ±32K range), be aware that neither macOS’s nor Linux’s object code format—Mach-O and the Executable Linkable Format (ELF), respectively—supports 16-bit relocatable offsets; 32-bit offsets are the best you can do.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h3 class="H1" id="sec29"><span id="h1-96"/><span class="SANS_Futura_Std_Bold_B_11">7.7 State Machines and Indirect Jumps</span></h3>&#13;
<p class="TNI1">Another control structure commonly found in assembly language programs is the state machine. In basic terms, a <i>state machine</i> is a piece of code that keeps track of its execution history by entering and leaving certain states. A state machine uses a <i>state variable</i> to control program flow. The FORTRAN programming language provides this capability with the assigned <span class="SANS_TheSansMonoCd_W5Regular_11">goto</span> statement. Certain variants of C, such as GNU’s GCC from the Free Software Foundation, provide similar features. In assembly language, the indirect jump can implement state machines.</p>&#13;
<p class="TX">In one sense, all programs are state machines. The CPU registers and values in memory constitute the state of that machine. However, this chapter uses a much more constrained definition. For most purposes, only a single variable (or the value in the PC register) will denote the current state.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_406" aria-label="406"/>For a concrete example of a state machine, suppose you have a procedure and want to perform one operation the first time you call it, a different operation the second time you call it, something else the third time you call it, and then something new again on the fourth call. After the fourth call, the code repeats these four operations in order. For example, say you want the procedure to add W0 and W1 the first time, subtract them on the second call, multiply them on the third, and divide them on the fourth. You could implement this procedure as shown in Listing 7-4.</p>&#13;
<pre id="pre-632"><code>// Listing7-4.S&#13;
//&#13;
// A simple state machine example&#13;
&#13;
&#13;
#include    "aoaa.inc"&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> #define     state   x19&#13;
&#13;
            .code&#13;
            .extern printf&#13;
&#13;
ttlStr:     wastr   "Listing 7-4"&#13;
fmtStr0:    .ascii  "Calling StateMachine, "&#13;
            wastr   "state=%d, W20 = 5, W21 = 6\n"&#13;
&#13;
fmtStr0b:   .ascii  "Calling StateMachine, "&#13;
            wastr   "state=%d, W20 = 1, W21 = 2\n"&#13;
&#13;
fmtStrx:    .ascii  "Back from StateMachine, "&#13;
            wastr   "state=%d, W20=%d\n"&#13;
&#13;
fmtStr1:    .ascii  "Calling StateMachine, "&#13;
            wastr   "state=%d, W20 = 50, W21 = 60\n"&#13;
&#13;
fmtStr2:    .ascii  "Calling StateMachine, "&#13;
            wastr   "state=%d, W20 = 10, W21 = 20\n"&#13;
&#13;
fmtStr3:    .ascii  "Calling StateMachine, "&#13;
            wastr   "state=%d, W20 = 50, W21 = 5\n"&#13;
&#13;
// getTitle&#13;
//&#13;
// Return pointer to program title&#13;
// to the C++ code.&#13;
&#13;
            proc    getTitle, public&#13;
            adr     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle&#13;
&#13;
// State machine is a leaf procedure. Don't bother&#13;
// to save LR on stack.&#13;
//&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_407" aria-label="407"/>// Although "state" is technically a nonvolatile&#13;
// register, the whole point of this procedure&#13;
// is to modify it, so we don't preserve it.&#13;
// Likewise, X20 gets modified by this code,&#13;
// so it doesn't preserve its value either.&#13;
&#13;
            proc   StateMachine&#13;
            cmp    state, #0&#13;
            bne    TryState1&#13;
&#13;
// State 0: Add W21 to W20 and switch to state 1:&#13;
&#13;
            add    w20, w20, w21&#13;
            add    state, state, #1  // State 0 becomes state 1.&#13;
            b.al   exit&#13;
&#13;
TryState1:&#13;
            cmp    state, #1&#13;
            bne    TryState2&#13;
&#13;
// State 1: Subtract W21 from W20 and switch to state 2:&#13;
&#13;
            sub    w20, w20, w21&#13;
            add    state, state, 1   // State 1 becomes state 2.&#13;
            b.al   exit&#13;
&#13;
TryState2:  cmp    state, #2&#13;
            bne    MustBeState3&#13;
&#13;
// If this is state 2, multiply W21 by W20 and switch to state 3:&#13;
&#13;
            mul    w20, w20, w21&#13;
            add    state, state, #1  // State 2 becomes state 3.&#13;
            b.al   exit&#13;
&#13;
// If it isn't one of the preceding states, we must be in&#13;
// state 3, so divide W20 by W21 and switch back to state 0.&#13;
&#13;
MustBeState3:&#13;
            sdiv    w20, w20, w21&#13;
            mov     state, #0        // Reset the state back to 0.&#13;
&#13;
exit:       ret&#13;
            endp    StateMachine&#13;
&#13;
/////////////////////////////////////////////////////////&#13;
//&#13;
// Here's the asmMain procedure:&#13;
&#13;
            proc    asmMain, public&#13;
&#13;
            locals  am&#13;
            dword   saveX19&#13;
            dword   saveX2021&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_408" aria-label="408"/>            byte    stackSpace, 64&#13;
            endl    am&#13;
&#13;
            enter   am.size&#13;
&#13;
// Save nonvolatile registers and initialize&#13;
// them to point at xArray, yArray, zArray,&#13;
// tArray, aArray, and bArray:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> str     state, [fp, #saveX19]&#13;
            stp     x20, x21, [fp, #saveX2021]&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> mov     state, #0&#13;
&#13;
// Demonstrate state 0:&#13;
&#13;
            lea     x0, fmtStr0&#13;
            mov     x1, state&#13;
            mstr    x1, [sp]&#13;
            bl      printf&#13;
&#13;
            mov     x20, #5&#13;
            mov     x21, #6&#13;
            bl      StateMachine&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> lea     x0, fmtStrx&#13;
            mov     x1, state&#13;
            mov     x2, x20&#13;
            mstr    x1, [sp]&#13;
            mstr    x2, [sp, #8]&#13;
            bl      printf&#13;
&#13;
// Demonstrate state 1:&#13;
&#13;
            lea     x0, fmtStr1&#13;
            mov     x1, state&#13;
            bl      printf&#13;
&#13;
            mov     x20, #50&#13;
            mov     x21, #60&#13;
            bl      StateMachine&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> lea     x0, fmtStrx&#13;
            mov     x1, state&#13;
            mov     x2, x20&#13;
            mstr    x1, [sp]&#13;
            mstr    x2, [sp, #8]&#13;
            bl      printf&#13;
&#13;
// Demonstrate state 2:&#13;
&#13;
            lea     x0, fmtStr2&#13;
            mov     x1, state&#13;
            mstr    x1, [sp]&#13;
            bl      printf&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_409" aria-label="409"/>            mov     x20, #10&#13;
            mov     x21, #20&#13;
            bl      StateMachine&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> lea     x0, fmtStrx&#13;
            mov     x1, state&#13;
            mov     x2, x20&#13;
            mstr    x1, [sp]&#13;
            mstr    x2, [sp, #8]&#13;
            bl      printf&#13;
&#13;
// Demonstrate state 3:&#13;
&#13;
            lea     x0, fmtStr3&#13;
            mov     x1, state&#13;
            mstr    x1, [sp]&#13;
            bl      printf&#13;
&#13;
            mov     x20, #50&#13;
            mov     x21, #5&#13;
            bl      StateMachine&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> lea     x0, fmtStrx&#13;
            mov     x1, state&#13;
            mov     x2, x20&#13;
            mstr    x1, [sp]&#13;
            mstr    x2, [sp, #8]&#13;
            bl      printf&#13;
&#13;
// Demonstrate back in state 0:&#13;
&#13;
            lea     x0, fmtStr0b&#13;
            mov     x1, state&#13;
            mstr    x1, [sp]&#13;
            bl      printf&#13;
&#13;
            mov     x20, #1&#13;
            mov     x21, #2&#13;
            bl      StateMachine&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> lea     x0, fmtStrx&#13;
            mov     x1, state&#13;
            mov     x2, x20&#13;
            mstr    x1, [sp]&#13;
            mstr    x2, [sp, #8]&#13;
            bl      printf&#13;
&#13;
// Restore nonvolatile register values&#13;
// and return.&#13;
&#13;
            ldr     state, [fp, #saveX19]&#13;
            ldp     x20, x21, [fp, #saveX2021]&#13;
            leave   // Return to C/C++ code.&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_410" aria-label="410"/>This code uses X19 to maintain the <span class="SANS_TheSansMonoCd_W5Regular_11">state</span> variable <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The main program preserves X19 (and X20) <span class="CodeAnnotation" aria-label="annotation2">❷</span> and then initializes the state machine to state 0 <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The code then makes successive calls to the state machine functions and prints the results from state 0 <span class="CodeAnnotation" aria-label="annotation4">❹</span>, 1 <span class="CodeAnnotation" aria-label="annotation5">❺</span>, 2 <span class="CodeAnnotation" aria-label="annotation6">❻</span>, and 3 <span class="CodeAnnotation" aria-label="annotation7">❼</span>. After executing in state 3, the code returns to state 0 and prints the result <span class="CodeAnnotation" aria-label="annotation8">❽</span>.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and program output:</p>&#13;
<pre id="pre-633"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing7-4</span>&#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing7-4</span>&#13;
Calling Listing7-4:&#13;
Calling StateMachine, state=0, W20 = 5, W21 = 6&#13;
Back from StateMachine, state=1, W20 = 11&#13;
Calling StateMachine, state=1, W20 = 50, W21 = 60&#13;
Back from StateMachine, state=2, W20=-10&#13;
Calling StateMachine, state=2, W20 = 10, W21 = 20&#13;
Back from StateMachine, state=3, W20 = 200&#13;
Calling StateMachine, state=3, W20 = 50, W21 = 5&#13;
Back from StateMachine, state=0, W20 = 10&#13;
Calling StateMachine, state=0, W20 = 1, W21 = 2&#13;
Back from StateMachine, state=1, W20 = 3&#13;
Listing7-4 terminated</code></pre>&#13;
<p class="TX">Technically, the <span class="SANS_TheSansMonoCd_W5Regular_11">StateMachine</span> procedure is not the state machine. Instead, the variable <span class="SANS_TheSansMonoCd_W5Regular_11">state</span> and the <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">bne</span> instructions constitute the state machine. The procedure is little more than a <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement implemented via the <span class="SANS_TheSansMonoCd_W5Regular_11">if...then...elseif</span> construct. The only unique thing is that it remembers how many times it has been called (or rather, how many times, modulo 4, it has been called) and behaves differently depending on the number of calls.</p>&#13;
<p class="TX">While this is a <i>correct</i> implementation of the desired state machine, it is not particularly efficient. The astute reader may recognize that this code could be made a little faster by using an actual <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement rather than the <span class="SANS_TheSansMonoCd_W5Regular_11">if...then...elseif...endif</span> implementation. However, an even better solution exists.</p>&#13;
<p class="TX">It’s common to use an indirect jump to implement a state machine in assembly language. Rather than having a <span class="SANS_TheSansMonoCd_W5Regular_11">state</span> variable that contains a value like 0, 1, 2, or 3, we could load the state variable with the <i>address</i> of the code to execute upon entry into the procedure. By simply jumping to that address, the state machine could save the tests needed to select the proper code fragment. Consider the implementation in Listing 7-5 using the indirect jump.</p>&#13;
<pre id="pre-634"><code>// Listing7-5.S&#13;
//&#13;
// An indirect jump state machine example&#13;
&#13;
#include    "aoaa.inc"&#13;
&#13;
#define     state   x19&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_411" aria-label="411"/>            .code&#13;
            .extern printf&#13;
&#13;
ttlStr:     wastr   "Listing 7-5"&#13;
fmtStr0:    .ascii  "Calling StateMachine, "&#13;
            wastr   "state=%d, W20 = 5, W21 = 6\n"&#13;
&#13;
fmtStr0b:   .ascii  "Calling StateMachine, "&#13;
            wastr   "state=%d, W20 = 1, W21 = 2\n"&#13;
&#13;
fmtStrx:    .ascii  "Back from StateMachine, "&#13;
            wastr   "state=%d, W20=%d\n"&#13;
&#13;
fmtStr1:    .ascii  "Calling StateMachine, "&#13;
            wastr   "state=%d, W20 = 50, W21 = 60\n"&#13;
&#13;
fmtStr2:    .ascii  "Calling StateMachine, "&#13;
            wastr   "state=%d, W20 = 10, W21 = 20\n"&#13;
&#13;
fmtStr3:    .ascii  "Calling StateMachine, "&#13;
            wastr   "state=%d, W20 = 50, W21 = 5\n"&#13;
&#13;
// getTitle&#13;
//&#13;
// Return pointer to program title&#13;
// to the C++ code.&#13;
&#13;
            proc    getTitle, public&#13;
            adr     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle&#13;
&#13;
// State machine is a leaf procedure. Don't bother&#13;
// to save LR on stack.&#13;
//&#13;
// Although "state" is technically a nonvolatile&#13;
// register, the whole point of this procedure&#13;
// is to modify it, so we don't preserve it.&#13;
// Likewise, x20 gets modified by this code,&#13;
// so it doesn't preserve its value either.&#13;
&#13;
            proc    StateMachine&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> br      state   // Transfer control to current state.&#13;
&#13;
// State 0: Add W21 to W20 and switch to state 1:&#13;
&#13;
state0:&#13;
            add   w20, w20, w21&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> adr   state, state1   // Set next state.&#13;
            ret&#13;
&#13;
// State 1: Subtract W21 from W20 and switch to state 2:&#13;
&#13;
state1:&#13;
            sub   w20, w20, w21&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_412" aria-label="412"/>            adr   state, state2   // Switch to state 2.&#13;
            ret&#13;
&#13;
&#13;
// If this is state 2, multiply W21 by W20 and switch to state 3:&#13;
&#13;
state2:&#13;
            mul   w20, w20, w21&#13;
            adr   state, state3   // Switch to state 3.&#13;
            ret&#13;
&#13;
// If it isn't one of the preceding states, we must be in&#13;
// state 3, so divide W20 by W21 and switch back to state 0.&#13;
&#13;
state3:&#13;
            sdiv    w20, w20, w21&#13;
            adr     state, state0&#13;
            ret&#13;
            endp    StateMachine&#13;
&#13;
/////////////////////////////////////////////////////////&#13;
//&#13;
// Here's the asmMain procedure:&#13;
&#13;
            proc    asmMain, public&#13;
&#13;
            locals  am&#13;
            dword   saveX19&#13;
            dword   saveX2021&#13;
            byte    stackSpace, 64&#13;
            endl    am&#13;
&#13;
            enter   am.size&#13;
&#13;
// Save nonvolatile registers and initialize&#13;
// them to point at xArray, yArray, zArray,&#13;
// tArray, aArray, and bArray:&#13;
&#13;
            str     state, [fp, #saveX19]&#13;
            stp     x20, x21, [fp, #saveX2021]&#13;
&#13;
// Initialize state machine:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> adr     state, state0&#13;
&#13;
// Demonstrate state 0:&#13;
&#13;
            lea     x0, fmtStr0&#13;
            mov     x1, state&#13;
            mstr    x1, [sp]&#13;
            bl      printf&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_413" aria-label="413"/>            mov     x20, #5&#13;
            mov     x21, #6&#13;
            bl      StateMachine&#13;
&#13;
            lea     x0, fmtStrx&#13;
            mov     x1, state&#13;
            mov     x2, x20&#13;
            mstr    x1, [sp]&#13;
            mstr    x2, [sp, #8]&#13;
            bl      printf&#13;
&#13;
// Demonstrate state 1:&#13;
&#13;
            lea     x0, fmtStr1&#13;
            mov     x1, state&#13;
            bl      printf&#13;
&#13;
            mov     x20, #50&#13;
            mov     x21, #60&#13;
            bl      StateMachine&#13;
&#13;
            lea     x0, fmtStrx&#13;
            mov     x1, state&#13;
            mov     x2, x20&#13;
            mstr    x1, [sp]&#13;
            mstr    x2, [sp, #8]&#13;
            bl      printf&#13;
&#13;
// Demonstrate state 2:&#13;
&#13;
            lea     x0, fmtStr2&#13;
            mov     x1, state&#13;
            mstr    x1, [sp]&#13;
            bl      printf&#13;
&#13;
            mov     x20, #10&#13;
            mov     x21, #20&#13;
            bl      StateMachine&#13;
&#13;
            lea     x0, fmtStrx&#13;
            mov     x1, state&#13;
            mov     x2, x20&#13;
            mstr    x1, [sp]&#13;
            mstr    x2, [sp, #8]&#13;
            bl      printf&#13;
&#13;
// Demonstrate state 3:&#13;
&#13;
            lea     x0, fmtStr3&#13;
            mov     x1, state&#13;
            mstr    x1, [sp]&#13;
            bl      printf&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_414" aria-label="414"/>            mov     x20, #50&#13;
            mov     x21, #5&#13;
            bl      StateMachine&#13;
&#13;
            lea     x0, fmtStrx&#13;
            mov     x1, state&#13;
            mov     x2, x20&#13;
            mstr    x1, [sp]&#13;
            mstr    x2, [sp, #8]&#13;
            bl      printf&#13;
&#13;
// Demonstrate back in state 0:&#13;
&#13;
            lea     x0, fmtStr0b&#13;
            mov     x1, state&#13;
            mstr    x1, [sp]&#13;
            bl      printf&#13;
&#13;
            mov     x20, #1&#13;
            mov     x21, #2&#13;
            bl      StateMachine&#13;
&#13;
            lea     x0, fmtStrx&#13;
            mov     x1, state&#13;
            mov     x2, x20&#13;
            mstr    x1, [sp]&#13;
            mstr    x2, [sp, #8]&#13;
            bl      printf&#13;
&#13;
// Restore nonvolatile register values&#13;
// and return:&#13;
&#13;
            ldr     state, [fp, #saveX19]&#13;
            ldp     x20, x21, [fp, #saveX2021]&#13;
            leave   // Return to C/C++ code.&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">This code has the same structure as Listing 7-4. The main difference is that this code assumes that the target address of the state machine is in X19 rather than a state number.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">br</span> instruction at the beginning of the <span class="SANS_TheSansMonoCd_W5Regular_11">StateMachine</span> procedure <span class="CodeAnnotation" aria-label="annotation1">❶</span> transfers control to the location pointed at by the <span class="SANS_TheSansMonoCd_W5Regular_11">state</span> variable (X19). The first time you call <span class="SANS_TheSansMonoCd_W5Regular_11">StateMachine</span>, it points at the <span class="SANS_TheSansMonoCd_W5Regular_11">state0</span> label. Thereafter, each subsection of code sets the <span class="SANS_TheSansMonoCd_W5Regular_11">state</span> variable to point at the appropriate successor code. Within each state of the state machine <span class="CodeAnnotation" aria-label="annotation2">❷</span>, the code sets X19 to the address of the next entry point of the state machine (rather than setting a state number). The main program initializes the state machine with the address of the <span class="SANS_TheSansMonoCd_W5Regular_11">State0</span> label <span class="CodeAnnotation" aria-label="annotation3">❸</span> rather than the value 0. Otherwise, this main program is largely the same as in Listing 7-4.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_415" aria-label="415"/>Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and program output:</p>&#13;
<pre id="pre-635"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing7-5</span>&#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing7-5</span>&#13;
Calling Listing7-5:&#13;
Calling StateMachine, state=4196420, W20 = 5, W21 = 6&#13;
Back from StateMachine, state=4196432, W20 = 11&#13;
Calling StateMachine, state=4196432, W20 = 50, W21 = 60&#13;
Back from StateMachine, state=4196444, W20=-10&#13;
Calling StateMachine, state=4196444, W20 = 10, W21 = 20&#13;
Back from StateMachine, state=4196456, W20 = 200&#13;
Calling StateMachine, state=4196456, W20 = 50, W21 = 5&#13;
Back from StateMachine, state=4196420, W20 = 10&#13;
Calling StateMachine, state=4196420, W20 = 1, W21 = 2&#13;
Back from StateMachine, state=4196432, W20 = 3&#13;
Listing7-5 terminated</code></pre>&#13;
<p class="TX">This output demonstrates that Listing 7-5 behaves in a manner similar to Listing 7-4.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
&#13;
<h3 class="H1" id="sec30"><span id="h1-97"/><span class="SANS_Futura_Std_Bold_B_11">7.8 Loops</span></h3>&#13;
<p class="TNI1">Loops represent the final basic control structure (sequences, decisions, and loops) that make up a typical program. Most HLLs have implied loop structures hidden away. For example, consider the BASIC statement <span class="SANS_TheSansMonoCd_W5Regular_11">if A$ = B$ then 100</span>. This <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement compares two strings and jumps to statement 100 if they are equal. In assembly language, you would need to write a loop to compare each character in <span class="SANS_TheSansMonoCd_W5Regular_11">A$</span> to the corresponding character in <span class="SANS_TheSansMonoCd_W5Regular_11">B$</span> and then jump to statement 100 if and only if all the characters matched. (The C stdlib provides the <span class="SANS_TheSansMonoCd_W5Regular_11">strcmp</span> routine that compares the strings for you, effectively hiding the loop. However, if you were to write this function yourself, the looping nature of the operation would be obvious.)</p>&#13;
<p class="TX">Program loops consist of three components: an optional initialization component, an optional loop-termination test, and the body of the loop. The order in which you assemble these components can dramatically affect the loop’s operation. Three permutations of these components appear frequently in programs: <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loops, <span class="SANS_TheSansMonoCd_W5Regular_11">repeat...until</span> loops (<span class="SANS_TheSansMonoCd_W5Regular_11">do...while</span> in C/C++), and infinite loops (for example, <span class="SANS_TheSansMonoCd_W5Regular_11">for(;;)</span> in C/C++). This section covers those three loop types along with C-style <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loops (definite loops), register usage in loops, and breaking out of loops.</p>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h4 class="H2" id="sec31"><span id="h2-144"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.8.1 while</span></h4>&#13;
<p class="TNI1">The most generic loop is the <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop. In C/C++, it takes the following form:</p>&#13;
<pre id="pre-636"><code>while(<var>expression</var>) <var>statement(s)</var>; </code></pre>&#13;
<p class="TX">In the <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop, the termination test appears at the beginning of the loop. As a direct consequence of the position of the termination test, the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_416" aria-label="416"/>body of the loop may never execute if the Boolean expression is always false.</p>&#13;
<p class="TX">Consider the following C/C++ <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop:</p>&#13;
<pre id="pre-637"><code>i = 0; &#13;
while(i &lt; 100) &#13;
{&#13;
    ++i; &#13;
}</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">i = 0;</span> statement is the initialization code for this loop. <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> is a loop-control variable, because it controls the execution of the body of the loop. <span class="SANS_TheSansMonoCd_W5Regular_11">i &lt; 100</span> is the loop-termination condition: the loop will not terminate as long as <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> is less than 100. The single statement <span class="SANS_TheSansMonoCd_W5Regular_11">++i;</span> (increment <span class="SANS_TheSansMonoCd_W5Regular_11">i</span>) is the loop body that executes on each loop iteration.</p>&#13;
<p class="TX">A C/C++ <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop can be easily synthesized using <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">goto</span> statements. For example, you may replace the previous C <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop with the following C code:</p>&#13;
<pre id="pre-638"><code>i = 0; &#13;
WhileLp: &#13;
if(i &lt; 100) &#13;
{&#13;
&#13;
    ++i; &#13;
      goto WhileLp; &#13;
&#13;
} </code></pre>&#13;
<p class="TX">More generally, you can construct any <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop as follows:</p>&#13;
<pre id="pre-639"><code><var>Optional initialization code</var> &#13;
&#13;
UniqueLabel: &#13;
if(<var>not_termination_condition</var>) &#13;
{&#13;
    <var>Loop body</var> &#13;
    goto UniqueLabel; &#13;
&#13;
} </code></pre>&#13;
<p class="TX">Therefore, you can use the techniques from earlier in this chapter to convert <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statements to assembly language and add a single <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> instruction to produce a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop. The example in this section translates to the following pure ARM assembly code:</p>&#13;
<pre id="pre-640"><code>          mov  w0, #0 &#13;
WhileLp: &#13;
          cmp  w0, #100 &#13;
          bnlt WhileDone &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_417" aria-label="417"/>      <var>Loop body</var> &#13;
&#13;
          add  w0, w0, #1   // ++i &#13;
          b.al WhileLp &#13;
&#13;
WhileDone: </code></pre>&#13;
<p class="TX">GCC will actually convert most <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> statements to different ARM code than this section presents. The reason for the difference appears in section 7.9.1, <span class="Xref">“Moving the Termination Condition to the End of a Loop,”</span> on <span class="Xref"><a href="chapter7.xhtml#pg_428">page 428</a></span>, which explores how to write more efficient loop code.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
&#13;
<h4 class="H2" id="sec32"><span id="h2-145"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.8.2 repeat...until</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">repeat...until</span> loop, also called the <span class="SANS_TheSansMonoCd_W5Regular_11">do...while</span> loop in C, tests for the termination condition at the end of the loop rather than at the beginning. In Pascal, the <span class="SANS_TheSansMonoCd_W5Regular_11">repeat...until</span> loop takes the following form:</p>&#13;
<pre id="pre-641"><code><var>Optional initialization code</var> &#13;
repeat &#13;
&#13;
    <var>Loop body</var> &#13;
&#13;
until(<var>termination_condition</var>); </code></pre>&#13;
<p class="TX">This is comparable to the following C/C++ <span class="SANS_TheSansMonoCd_W5Regular_11">do...while</span> loop:</p>&#13;
<pre id="pre-642"><code><var>Optional initialization code</var> &#13;
do &#13;
{&#13;
    <var>Loop body</var> &#13;
&#13;
}while(<var>not_termination_condition</var>); </code></pre>&#13;
<p class="TX">This sequence executes the initialization code, then executes the loop body, and finally tests a condition to see whether the loop should repeat. If the Boolean expression evaluates to false, the loop repeats; otherwise, the loop terminates. In the <span class="SANS_TheSansMonoCd_W5Regular_11">repeat...until</span> loop, the termination test appears at the end of the loop and, as a direct consequence, the loop body always executes at least once.</p>&#13;
<p class="TX">Like the <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop, the <span class="SANS_TheSansMonoCd_W5Regular_11">repeat...until</span> loop can be synthesized with an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement and a <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> (branch). The following is an example of just such an implementation:</p>&#13;
<pre id="pre-643"><code><var>Initialization code</var> &#13;
SomeUniqueLabel: &#13;
&#13;
    <var>Loop body</var> &#13;
&#13;
if(<var>not_the_termination_condition</var>) goto SomeUniqueLabel; </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_418" aria-label="418"/>Based on the material presented in the previous sections, you can easily synthesize <span class="SANS_TheSansMonoCd_W5Regular_11">repeat...until</span> loops in assembly language, as shown in the following simple example:</p>&#13;
<pre id="pre-644"><code>     repeat (* Pascal code *)&#13;
&#13;
          write('Enter a number greater than 100:'); &#13;
          readln(i); &#13;
&#13;
     until(i &gt; 100); &#13;
&#13;
// This translates to the following if/jmp code: &#13;
&#13;
     RepeatLabel: &#13;
&#13;
          write('Enter a number greater than 100:'); &#13;
          readln(<var>i</var>); &#13;
&#13;
     if(<var>i</var> &lt;= 100) then goto RepeatLabel; &#13;
&#13;
// It also translates into the following assembly code: &#13;
&#13;
RepeatLabel: &#13;
&#13;
          bl    print &#13;
          wastr "Enter a number greater than 100: "&#13;
          bl    readInt // Function to read integer from user &#13;
&#13;
          cmp   w0, #100 // Assume readInt returns integer in W0. &#13;
          bngt  RepeatLabel </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">repeat...until</span> loop has a slightly more efficient implementation because it combines the loop termination test and the branch back to the beginning of the loop.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h4 class="H2" id="sec33"><span id="h2-146"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.8.3 forever/endfor</span></h4>&#13;
<p class="TNI1">If <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loops test for termination at the beginning of the loop and <span class="SANS_TheSansMonoCd_W5Regular_11">repeat...until</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">do...while</span> loops check for termination at the end of the loop, the only place left to test for termination is in the middle of the loop. The C/C++ high-level <span class="SANS_TheSansMonoCd_W5Regular_11">for(;;)</span> loop, combined with the <span class="SANS_TheSansMonoCd_W5Regular_11">break</span> statement, provides this capability. The C/C++ infinite loop takes the following form:</p>&#13;
<pre id="pre-645"><code>for(;;)&#13;
{&#13;
    <var>Loop body</var> &#13;
&#13;
} </code></pre>&#13;
<p class="TX">There is no explicit termination condition. The <span class="SANS_TheSansMonoCd_W5Regular_11">for(;;)</span> construct forms an infinite loop. A <span class="SANS_TheSansMonoCd_W5Regular_11">break</span> statement usually handles loop termination. Consider the following C++ code that employs a <span class="SANS_TheSansMonoCd_W5Regular_11">for(;;)</span> construct:</p>&#13;
<pre id="pre-646"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_419" aria-label="419"/>for(;;)&#13;
{&#13;
     cin &gt;&gt; <var>character</var>; &#13;
     if(<var>character</var> == '.') break; &#13;
     cout &lt;&lt; <var>character</var>; &#13;
&#13;
} </code></pre>&#13;
<p class="TX">Converting a <span class="SANS_TheSansMonoCd_W5Regular_11">for(;;)</span> loop to pure assembly language is easy: all you need is a label and a <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> instruction. The <span class="SANS_TheSansMonoCd_W5Regular_11">break</span> statement in this example is also nothing more than a <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> instruction (or conditional jump). The pure assembly language version of the preceding code looks something like the following:</p>&#13;
<pre id="pre-647"><code>foreverLabel: &#13;
&#13;
          bl   getchar    // Assume it returns char in W0. &#13;
          cmp  w0, #'.' &#13;
          beq  ForIsDone &#13;
&#13;
          bl   putcchar   // Assume this prints the char in W0. &#13;
          b.al foreverLabel &#13;
&#13;
ForIsDone: </code></pre>&#13;
<p class="TX">As you can see, the forever loop has a very simple implementation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
&#13;
<h4 class="H2" id="sec34"><span id="h2-147"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.8.4 for</span></h4>&#13;
<p class="TNI1">The standard <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop is a special form of the <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop that repeats the loop body a specific number of times, which is known as a <i>definite</i> loop. In C/C++, the <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop takes the following form:</p>&#13;
<pre id="pre-648"><code>for(<var>Initialization_Stmt</var>; <var>Termination_Expression</var>; <var>inc_Stmt</var>) &#13;
{&#13;
    <var>statements</var> &#13;
&#13;
} </code></pre>&#13;
<p class="TX">This is equivalent to the following:</p>&#13;
<pre id="pre-649"><code><var>Initialization_Stmt</var>; &#13;
while(<var>Termination_Expression</var>) &#13;
{&#13;
    <var>statements</var> &#13;
&#13;
    <var>inc_Stmt</var>; &#13;
&#13;
} </code></pre>&#13;
<p class="TX">Traditionally, programs use the <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop to process arrays and other objects accessed in sequential order. You normally initialize a loop-control <span role="doc-pagebreak" epub:type="pagebreak" id="pg_420" aria-label="420"/>variable with the initialization statement, then use the loop-control variable as an index into the array (or other data type), as shown in the following example:</p>&#13;
<pre id="pre-650"><code>for(i = 0; i &lt; 7; ++i) &#13;
{&#13;
    printf("Array Element = %d /n", SomeArray[i]); &#13;
&#13;
} </code></pre>&#13;
<p class="TX">To convert this to pure assembly language, begin by translating the <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop into an equivalent <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop:</p>&#13;
<pre id="pre-651"><code>i = 0; &#13;
while(i &lt; 7) &#13;
{&#13;
    printf("Array Element = %d \n", SomeArray[i]); &#13;
    ++i; &#13;
} </code></pre>&#13;
<p class="TX">Now, using the techniques from section 7.8.1, <span class="Xref">“</span><span class="SANS_TheSansMonoCd_W5Regular_11">while</span><span class="Xref">,”</span> on <span class="Xref"><a href="chapter7.xhtml#pg_415">page 415</a></span>, translate the code into pure assembly language:</p>&#13;
<pre id="pre-652"><code>          mov  x19, #0               // Use X19 to hold loop index. &#13;
WhileLp:  cmp  x19, #7 &#13;
          bnlt EndWhileLp &#13;
&#13;
          lea  x0, fmtStr            // fmtStr = "Array Element = %d\n"&#13;
          lea  x1, SomeArray &#13;
          ldr  w1, [x1, x19, lsl #2] // SomeArray is word array. &#13;
          mstr x1, [sp] &#13;
          bl   printf &#13;
&#13;
          add  x19, x19, #1   // ++i &#13;
          b.al WhileLp; &#13;
&#13;
EndWhileLp: </code></pre>&#13;
<p class="TX">This is a fairly efficient implementation of a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop in assembly language, though for <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loops that execute a fixed number of times, you might consider using the <span class="SANS_TheSansMonoCd_W5Regular_11">cbnz</span> instruction (see section 7.8.6, <span class="Xref">“ARM Looping Instructions,”</span> on <span class="Xref"><a href="chapter7.xhtml#pg_425">page 425</a></span>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
&#13;
<h4 class="H2" id="sec35"><span id="h2-148"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.8.5 break and continue</span></h4>&#13;
<p class="TNI1">The C/C++ <span class="SANS_TheSansMonoCd_W5Regular_11">break</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">continue</span> statements both translate into a single <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> instruction. The <span class="SANS_TheSansMonoCd_W5Regular_11">break</span> statement exits the loop that immediately contains the <span class="SANS_TheSansMonoCd_W5Regular_11">break</span> statement; the <span class="SANS_TheSansMonoCd_W5Regular_11">continue</span> statement restarts the loop that contains the <span class="SANS_TheSansMonoCd_W5Regular_11">continue</span> statement.</p>&#13;
<p class="TX">To convert a <span class="SANS_TheSansMonoCd_W5Regular_11">break</span> statement to pure assembly language, just emit a <span class="SANS_TheSansMonoCd_W5Regular_11">goto</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> instruction that transfers control to the first statement following <span role="doc-pagebreak" epub:type="pagebreak" id="pg_421" aria-label="421"/>the end of the loop to exit. You can do this by placing a label after the loop body and jumping to that label. The following code fragments demonstrate this technique for the various loops:</p>&#13;
<pre id="pre-653"><code>// Breaking out of a FOR(;;) loop: &#13;
&#13;
for(;;)&#13;
{&#13;
<var>      stmts</var> &#13;
      // break; &#13;
      goto BreakFromForever; &#13;
    <var>  stmts</var> &#13;
}&#13;
BreakFromForever: &#13;
&#13;
// Breaking out of a FOR loop: &#13;
&#13;
for(<var>initStmt</var>; <var>expr; incStmt</var>) &#13;
{&#13;
      <var>stmts</var> &#13;
&#13;
      // break; &#13;
      goto BrkFromFor; &#13;
&#13;
      <var>stmts</var> &#13;
}&#13;
BrkFromFor: &#13;
&#13;
// Breaking out of a WHILE loop: &#13;
&#13;
while(<var>expr</var>) &#13;
{&#13;
      <var>stmts</var> &#13;
&#13;
      // break; &#13;
      goto BrkFromWhile; &#13;
&#13;
      <var>stmts</var> &#13;
}&#13;
BrkFromWhile: &#13;
&#13;
// Breaking out of a REPEAT...UNTIL loop (do...while is similar): &#13;
&#13;
repeat &#13;
      <var>stmts</var> &#13;
&#13;
      // break; &#13;
      goto BrkFromRpt; &#13;
&#13;
      <var>stmts</var> &#13;
until(<var>expr</var>); &#13;
BrkFromRpt: </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_422" aria-label="422"/>In pure assembly language, convert the appropriate control structures to assembly and replace the <span class="SANS_TheSansMonoCd_W5Regular_11">goto</span> with a <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> instruction.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">continue</span> statement is slightly more complex than the <span class="SANS_TheSansMonoCd_W5Regular_11">break</span> statement. The implementation is still a single <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> instruction; however, the target label doesn’t wind up going in the same spot for each of the loops. <a href="chapter7.xhtml#fig7-2">Figures 7-2</a> through <a href="chapter7.xhtml#fig7-5">7-5</a> show where the <span class="SANS_TheSansMonoCd_W5Regular_11">continue</span> statement transfers control for each of the loops.</p>&#13;
<p class="TX"><a href="chapter7.xhtml#fig7-2">Figure 7-2</a> shows the <span class="SANS_TheSansMonoCd_W5Regular_11">for(;;)</span> loop with a <span class="SANS_TheSansMonoCd_W5Regular_11">continue</span> statement.</p>&#13;
<figure class="IMG"><img class="img5" id="fig7-2" src="../images/Figure7-2.jpg" alt="" width="666" height="316"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 7-2: The</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">continue</span> <span class="SANS_Futura_Std_Book_Oblique_11">destination and the</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">for(;;)</span> <span class="SANS_Futura_Std_Book_Oblique_11">loop</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="chapter7.xhtml#fig7-3">Figure 7-3</a> shows the <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop with a <span class="SANS_TheSansMonoCd_W5Regular_11">continue</span> statement.</p>&#13;
<figure class="IMG"><img class="img5" id="fig7-3" src="../images/Figure7-3.jpg" alt="" width="687" height="312"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 7-3: The</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">continue</span> <span class="SANS_Futura_Std_Book_Oblique_11">destination and the</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">while</span> <span class="SANS_Futura_Std_Book_Oblique_11">loop</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="chapter7.xhtml#fig7-4">Figure 7-4</a> shows a C/C++ <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop with a <span class="SANS_TheSansMonoCd_W5Regular_11">continue</span> statement.</p>&#13;
<figure class="IMG"><img class="img7" id="fig7-4" src="../images/Figure7-4.jpg" alt="" width="1013" height="311"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 7-4: The</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">continue</span> <span class="SANS_Futura_Std_Book_Oblique_11">destination and the</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">for</span> <span class="SANS_Futura_Std_Book_Oblique_11">loop</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Note in <a href="chapter7.xhtml#fig7-4">Figure 7-4</a> that the <span class="SANS_TheSansMonoCd_W5Regular_11">continue</span> statement forces the execution of <span class="SANS_TheSansMonoCd_W5Regular_11">incStmt</span> and then transfers control to the test for loop termination.</p>&#13;
<p class="TX"><a href="chapter7.xhtml#fig7-5">Figure 7-5</a> shows a <span class="SANS_TheSansMonoCd_W5Regular_11">repeat...until</span> loop with a <span class="SANS_TheSansMonoCd_W5Regular_11">continue</span> statement.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_423" aria-label="423"/>&#13;
<figure class="IMG"><img class="img7" id="fig7-5" src="../images/Figure7-5.jpg" alt="" width="876" height="311"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 7-5: The</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">continue</span> <span class="SANS_Futura_Std_Book_Oblique_11">destination and the</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">repeat... until</span> <span class="SANS_Futura_Std_Book_Oblique_11">loop</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The following code fragments demonstrate how to convert the <span class="SANS_TheSansMonoCd_W5Regular_11">continue</span> statement into an appropriate <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> instruction for each of these loop types:</p>&#13;
<pre id="pre-654"><code>// for(;;)/continue/endfor &#13;
// Conversion of forever loop with continue &#13;
// to pure assembly: &#13;
// for(;;)&#13;
// {&#13;
//      <var>stmts</var> &#13;
//      continue; &#13;
//      <var>stmts</var> &#13;
//}&#13;
//&#13;
// Converted code: &#13;
&#13;
foreverLbl: &#13;
&#13;
      <var>stmts</var> &#13;
&#13;
      // continue; &#13;
      b.al foreverLbl &#13;
&#13;
      <var>stmts</var> &#13;
&#13;
      b.al foreverLbl &#13;
&#13;
// while/continue/endwhile &#13;
// Conversion of while loop with continue &#13;
// into pure assembly: &#13;
//&#13;
// while(expr) &#13;
// {&#13;
//      <var>stmts</var> &#13;
//      continue; &#13;
//      <var>stmts</var> &#13;
//}&#13;
//&#13;
// Converted code: &#13;
&#13;
whlLabel: &#13;
&#13;
<var>  Code to evaluate expr</var> &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_424" aria-label="424"/>      b<var>cc</var> EndOfWhile      // Skip loop on expr failure. &#13;
&#13;
      <var>stmts</var> &#13;
&#13;
      // continue; &#13;
      b.al whlLabel      // Jump to start of loop on continue. &#13;
&#13;
      <var>stmts</var> &#13;
&#13;
      b.al whlLabel      // Repeat the code. &#13;
EndOfWhile: &#13;
&#13;
&#13;
// for/continue/endfor &#13;
// Conversion for a for loop with continue &#13;
// into pure assembly: &#13;
//&#13;
// for(<var>initStmt</var>; <var>expr</var>; <var>incStmt</var>) &#13;
// {&#13;
//      <var>stmts</var> &#13;
//      continue; &#13;
//      <var>stmts</var> &#13;
//}&#13;
//&#13;
// Converted code: &#13;
&#13;
        <var>initStmt</var> &#13;
ForLpLbl: &#13;
&#13;
<var>  Code to evaluate expr</var> &#13;
&#13;
        b<var>cc</var> EndOfFor     // Branch if expression fails. &#13;
&#13;
        <var>stmts</var> &#13;
&#13;
        // continue; &#13;
        b.al ContFor     // Branch to incStmt on continue. &#13;
&#13;
        <var>stmts</var> &#13;
&#13;
ContFor: &#13;
&#13;
        <var>incStmt</var> &#13;
&#13;
        b.al ForLpLbl &#13;
&#13;
EndOfFor: &#13;
&#13;
&#13;
// repeat...continue...until &#13;
// repeat &#13;
//      <var>stmts</var> &#13;
//      continue; &#13;
//      <var>stmts</var> &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_425" aria-label="425"/>// until(<var>expr</var>); &#13;
//&#13;
// do &#13;
// {&#13;
//      <var>stmts</var> &#13;
//      continue; &#13;
//      <var>stmts</var> &#13;
//&#13;
//}while(!<var>expr</var>); &#13;
//&#13;
// Converted code: &#13;
&#13;
RptLpLbl: &#13;
&#13;
      <var>stmts</var> &#13;
&#13;
      // continue; &#13;
      b.al ContRpt     // Continue branches to termination test. &#13;
&#13;
      <var>stmts</var> &#13;
&#13;
ContRpt: &#13;
&#13;
  <var>Code to test expr</var> &#13;
&#13;
      b<var>cc</var> RptLpLbl     // Jumps if expression evaluates false. </code></pre>&#13;
<p class="TX">In each case, the <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> instruction transfers control to the point in the loop where it will test the loop condition and increment the loop control variable (for <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loops), or to the beginning of the loop’s body.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
&#13;
<h4 class="H2" id="sec36"><span id="h2-149"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.8.6 ARM Looping Instructions</span></h4>&#13;
<p class="TNI1">The ARM CPU provides four machine instructions that are useful for creating loops. These instructions violate the RISC principle of “an instruction does only one thing,” but they are quite handy even if they are a little “CISCy.”</p>&#13;
<p class="TX">The first two instructions test a register’s value and branch if that register is equal to, or not equal to, 0. The two instructions are <span class="SANS_TheSansMonoCd_W5Regular_11">cbz</span> (compare and branch if zero) and <span class="SANS_TheSansMonoCd_W5Regular_11">cbnz</span> (compare and branch if not zero). Their syntax is</p>&#13;
<pre id="pre-655"><code>cbz  w<var>n</var>, <var>label</var> &#13;
cbz  x<var>n</var>, <var>label</var> &#13;
cbnz w<var>n</var>, <var>label</var> &#13;
cbnz x<var>n</var>, <var>label</var> </code></pre>&#13;
<p class="Continued1">where X<i>n</i> and W<i>n</i> are the register to compare against 0 and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> is a statement label within ±1MB of the current instruction.</p>&#13;
<p class="TX">These instructions are equivalent to the following:</p>&#13;
<pre id="pre-656"><code>cmp w<var>n</var>, wzr   // cbz w<var>n</var>, <var>label</var> &#13;
beq <var>label</var> &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_426" aria-label="426"/>cmp x<var>n</var>, xzr   // cbz x<var>n</var>, <var>label</var> &#13;
beq <var>label</var> &#13;
&#13;
cmp w<var>n</var>, wzr   // cbnz w<var>n</var>, <var>label</var> &#13;
bne <var>label</var> &#13;
&#13;
cmp x<var>n</var>, xzr   // cbnz x<var>n</var>, <var>label</var> &#13;
bne <var>label</var> </code></pre>&#13;
<p class="TX">Another useful pair of instructions are <span class="SANS_TheSansMonoCd_W5Regular_11">tbz</span> (test bit for 0 and branch) and <span class="SANS_TheSansMonoCd_W5Regular_11">tbnz</span> (test bit for not 0 and branch). These instructions test a bit in a register and branch based on that bit’s value (0 or nonzero). The syntax for these instructions is</p>&#13;
<pre id="pre-657"><code>tbz  w<var>n</var>, #<var>imm</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">6</span>, <var>label</var> &#13;
tbz  x<var>n</var>, #<var>imm</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">6</span>, <var>label</var> &#13;
tbnz w<var>n</var>, #<var>imm</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">6</span>, <var>label</var> &#13;
tbnz x<var>n</var>, #<var>imm</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">6</span>, <var>label</var> </code></pre>&#13;
<p class="Continued1">where X<i>n</i> and W<i>n</i> are the register to test, <i>imm</i><i><sub>6</sub></i> is a bit number in the range 0–63 for 64-bit registers and 0–31 for 32-bit registers, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> is a statement label within ±32KB of the current instruction. The <span class="SANS_TheSansMonoCd_W5Regular_11">tbz</span> instruction branches to the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">label</span> if the specified bit in the register is 0, while the <span class="SANS_TheSansMonoCd_W5Regular_11">tbnz</span> instruction branches if the bit is not 0.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec37">&#13;
&#13;
<h4 class="H2" id="sec37"><span id="h2-150"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.8.7 Register Usage and Loops</span></h4>&#13;
<p class="TNI1">Given that the ARM accesses registers more efficiently than memory locations, registers are the ideal spot to place loop-control variables (especially for small loops). However, registers are a limited resource, despite the many registers available on the ARM. Unlike with memory, you cannot place much data in the registers.</p>&#13;
<p class="TX">Loops present a special challenge for registers. Registers are perfect for loop-control variables because they’re efficient to manipulate and can serve as indexes into arrays and other data structures (a common use for loop-control variables). However, the limited availability of registers often creates problems when using registers in this fashion. This is especially true if you call other functions/procedures within the loops, which limits you to using nonvolatile registers for loop control variables. Consider the following code with nested loops that will not work properly because it attempts to reuse a register (X19) that is already in use, leading to the corruption of the outer loop’s loop-control variable:</p>&#13;
<pre id="pre-658"><code>          mov  w19, #8 &#13;
loop1: &#13;
          mov  w19, #4 &#13;
loop2: &#13;
          <var>stmts</var> &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_427" aria-label="427"/>          subs w19, w19, #1 &#13;
          bne  loop2 &#13;
&#13;
          subs w19, w19, #1 &#13;
          bne  loop1 </code></pre>&#13;
<p class="TX">The intent here was to create a set of nested loops, one loop inside another. The inner loop (<span class="SANS_TheSansMonoCd_W5Regular_11">loop2</span>) should repeat four times for each of the eight executions of the outer loop (<span class="SANS_TheSansMonoCd_W5Regular_11">loop1</span>). Unfortunately, both loops use the same register as a loop-control variable. Therefore, this will form an infinite loop. Because W19 is always 0 upon encountering the second <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span> instruction, control will always transfer to the <span class="SANS_TheSansMonoCd_W5Regular_11">loop1</span> label (because decrementing 0 produces a nonzero result).</p>&#13;
<p class="TX">The solution is to save and restore the W19 register or to use a different register in place of W19 for the outer loop; the following code demonstrates preserving W19 across the execution of the loop:</p>&#13;
<pre id="pre-659"><code>          mov w19, #8 &#13;
loop1: &#13;
          str  w19, [sp, #-16]!   // Push onto stack. &#13;
          mov  w19, #4 &#13;
loop2: &#13;
        <var>  stmts</var> &#13;
&#13;
          subs w19, w19, #1 &#13;
          bne  loop2 &#13;
&#13;
          ldr  w19, [sp], #16     // Pop off the stack. &#13;
          subs w19, w19, #1       // Decrement W19. &#13;
          bne  loop1 &#13;
&#13;
<var>or</var> &#13;
&#13;
          mov  w19,#8 &#13;
loop1: &#13;
          mov  w20, #4 &#13;
loop2: &#13;
          <var>stmts</var> &#13;
&#13;
          subs w20, w20, #1 &#13;
          bne  loop2 &#13;
&#13;
          subs w19, w19, #1 &#13;
          bne  loop1 </code></pre>&#13;
<p class="TX">Register corruption is one of the primary sources of bugs in loops in assembly language programs, so always keep an eye out for this problem.</p>&#13;
<p class="TX">Until this point, this chapter has mainly focused on the correct implementation of various types of loops in assembly language. The next section begins discussing how to write loops efficiently in assembly language.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec38">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_428" aria-label="428"/>&#13;
<h3 class="H1" id="sec38"><span id="h1-98"/><span class="SANS_Futura_Std_Bold_B_11">7.9 Loop Performance Improvements</span></h3>&#13;
<p class="TNI1">Because loops are the primary source of performance problems within a program, they are also the place to look when attempting to speed up your software. A treatise on how to write efficient programs is beyond the scope of this chapter, but you should be aware of the following concepts when designing loops in your programs. They’re all aimed at removing unnecessary instructions from your loops in order to reduce the time it takes to execute a single iteration of the loop.</p>&#13;
<section epub:type="division" aria-labelledby="sec39">&#13;
&#13;
<h4 class="H2" id="sec39"><span id="h2-151"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.9.1 Moving the Termination Condition to the End of a Loop</span></h4>&#13;
<p class="TNI1">As you may have noticed, the <span class="SANS_TheSansMonoCd_W5Regular_11">repeat...until</span> loop is slightly more efficient than a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop. This is because <span class="SANS_TheSansMonoCd_W5Regular_11">repeat...until</span> manages to combine the loop’s Boolean test along with the branch back to the beginning of the loop. You can improve the other loops to be slightly more efficient. Consider the following flow graphs for the three types of loops presented earlier:</p>&#13;
<pre id="pre-660"><code><var>repeat...until loop:</var> &#13;
<var>     Initialization code</var> &#13;
<var>          Loop body</var> &#13;
<var>     Test for termination and branch back if necessary.</var> &#13;
<var>     Code following the loop</var> &#13;
&#13;
<var>while loop:</var> &#13;
<var>     Initialization code</var> &#13;
<var>     Loop-termination test</var> &#13;
<var>          Loop body</var> &#13;
<var>          Jump back to test.</var> &#13;
<var>     Code following the loop</var> &#13;
&#13;
<var>forever/endfor loop:</var> &#13;
<var>     Initialization code</var> &#13;
<var>          Loop body part 1</var> &#13;
<var>          Loop-termination test</var> &#13;
<var>          Loop body part 2</var> &#13;
<var>          Jump back to loop body part 1</var> &#13;
     <var>Code following the loop</var> </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">repeat...until</span> loop is the simplest of the bunch. This is reflected in the assembly language implementation of these loops. Consider the following semantically identical <span class="SANS_TheSansMonoCd_W5Regular_11">repeat...until</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loops:</p>&#13;
<pre id="pre-661"><code>// Example involving a while loop: &#13;
&#13;
         mov  w0, w1 &#13;
         sub  w0, w0, #20 &#13;
&#13;
// while(W0 &lt;= W1) &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_429" aria-label="429"/>whileLp: cmp  w0, w1 &#13;
         bnle endwhile &#13;
&#13;
         <var>stmts</var> &#13;
&#13;
         add  w0, w0, #1 &#13;
         b.al whileLp &#13;
endwhile: &#13;
&#13;
// Example involving a repeat...until loop: &#13;
&#13;
         mov  w0, w1 &#13;
         sub  w0, w0, #20 &#13;
repeatLp: &#13;
&#13;
        <var> stmts</var> &#13;
&#13;
         add  w0, w0, #1 &#13;
         cmp  w0, w1 &#13;
         bngt repeatLp </code></pre>&#13;
<p class="TX">Testing for the termination condition at the end of the loop allows you to remove a <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> instruction from the loop, which can be significant if the loop is nested inside other loops. Given the definition of the loop, you can easily see that the loop will execute exactly 20 times, which suggests that the conversion to a <span class="SANS_TheSansMonoCd_W5Regular_11">repeat...until</span> loop is trivial and always possible. Unfortunately, it’s not always quite this easy.</p>&#13;
<p class="TX">Consider the following C code:</p>&#13;
<pre id="pre-662"><code>while(w0 &lt;= w1) &#13;
{&#13;
    <var>stmts</var> &#13;
&#13;
    ++w0; &#13;
}</code></pre>&#13;
<p class="TX">In this example, you don’t know what W0 contains upon entry into the loop. Therefore, you cannot assume that the loop body will execute at least once. This means you must test for loop termination before executing the body of the loop. The test can be placed at the end of the loop with the inclusion of a single <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> instruction:</p>&#13;
<pre id="pre-663"><code>          b.al WhlTest &#13;
TopOfLoop: &#13;
&#13;
        <var>  stmts</var> &#13;
&#13;
          add  w0, w0, #1 &#13;
WhlTest:  cmp  w0, w1 &#13;
          ble TopOfLoop </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_430" aria-label="430"/>Although the code is as long as the original <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop, the <span class="SANS_TheSansMonoCd_W5Regular_11">b.al</span> instruction executes only once rather than on each repetition of the loop. However, the slight gain in efficiency is obtained via a slight loss in readability, so be sure to comment it. The second code sequence is also closer to spaghetti code than the original implementation. Such is often the price of a small performance gain. Carefully analyze your code to ensure that such a performance boost is worth the loss of clarity.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec40">&#13;
&#13;
<h4 class="H2" id="sec40"><span id="h2-152"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.9.2 Executing the Loop Backward</span></h4>&#13;
<p class="TNI1">Because of the nature of the flags on the ARM, loops that repeat from a number down to (or up to) 0 are more efficient than loops that execute from 0 to another value. Compare the following C/C++ <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop and the comparable assembly language code:</p>&#13;
<pre id="pre-664"><code>for(j = 1; j &lt;= 8; ++j) &#13;
{&#13;
    <var>  stmts</var> &#13;
}&#13;
&#13;
// Conversion to pure assembly (as well as using a &#13;
// REPEAT...UNTIL form): &#13;
&#13;
mov w0, #1     // Assume j = W0. &#13;
ForLp: &#13;
&#13;
      <var>stmts</var> &#13;
&#13;
      add w0, w0, #1 &#13;
      cmp w0, #8 &#13;
      ble ForLp </code></pre>&#13;
<p class="TX">Now consider another loop that also has eight iterations but runs its loop-control variable from 8 down to 1 rather than from 1 up to 8, thereby saving a comparison on each repetition of the loop:</p>&#13;
<pre id="pre-665"><code>     mov  w0, #8  // Assume j = W0. &#13;
LoopLbl: &#13;
&#13;
    <var> stmts</var> &#13;
&#13;
     subs w0, w0, #1 &#13;
     bne  LoopLbl </code></pre>&#13;
<p class="TX">Saving the execution time of the <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction on each iteration of the loop may result in faster code. Unfortunately, you cannot force all loops to run backward. However, with a little effort and some coercion, you should be able to write many <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loops so that they operate backward.</p>&#13;
<p class="TX">The previous example worked out well because the loop ran from 8 down to 1. The loop terminated when the loop-control variable became 0. What happens if you need to execute the loop when the loop-control variable goes <span role="doc-pagebreak" epub:type="pagebreak" id="pg_431" aria-label="431"/>to 0? For example, suppose that the preceding loop needed to range from 7 down to 0. As long as the lower bound is nonnegative, you can substitute the <span class="SANS_TheSansMonoCd_W5Regular_11">bpl</span> instruction in place of the <span class="SANS_TheSansMonoCd_W5Regular_11">bne</span> instruction in the earlier code:</p>&#13;
<pre id="pre-666"><code>     mov  w0, #7   // Assume j = W0. &#13;
LoopLbl: &#13;
&#13;
    <var> stmts</var> &#13;
&#13;
     subs w0, w0, #1 &#13;
     bpl  LoopLbl </code></pre>&#13;
<p class="TX">This loop will repeat eight times, with W0 (<span class="SANS_TheSansMonoCd_W5Regular_11">j</span>) taking on the values 7 to 0. When W0 decrements 0 to –1, it sets the sign flag and the loop terminates.</p>&#13;
<p class="TX">Keep in mind that some values may look positive but are actually negative. If the loop-control variable is a word, values in the range 2,147,483,648 to 4,294,967,295 are negative in the two’s complement system. Therefore, initializing the loop-control variable with any 32-bit value in this range (or, of course, 0) terminates the loop after a single execution. This can get you into trouble if you’re not careful.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec41">&#13;
&#13;
<h4 class="H2" id="sec41"><span id="h2-153"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.9.3 Eliminating Loop-Invariant Calculations</span></h4>&#13;
<p class="TNI1">A <i>loop-invariant computation</i> is a calculation that appears within a loop that always yields the same result. You needn’t do such computations inside the loop but can instead compute them outside the loop and reference the value of the computations inside the loop. The following C code demonstrates an invariant computation:</p>&#13;
<pre id="pre-667"><code>for(i = 0; i &lt; n; ++i) &#13;
{&#13;
    k = (j - 2) + i &#13;
    <var>Other code</var> &#13;
}</code></pre>&#13;
<p class="TX">Because <span class="SANS_TheSansMonoCd_W5Regular_11">j</span> never changes throughout the execution of this loop, the subexpression <span class="SANS_TheSansMonoCd_W5Regular_11">j - 2</span> can be computed outside the loop:</p>&#13;
<pre id="pre-668"><code>jm2 = j - 2; &#13;
for(i = 0; i &lt; n; ++i) &#13;
{&#13;
&#13;
    k = jm2 + i; &#13;
    <var>Other code</var> &#13;
}</code></pre>&#13;
<p class="TX">This translates to the following assembly code, which moves the invariant calculation outside the loop:</p>&#13;
<pre id="pre-669"><code>      ldr  w19, [fp, #j] &#13;
      sub  w19, w19, #2 &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_432" aria-label="432"/>      mov  w20, #0         // Assume W20 = i. &#13;
lp:   cmp  w20, #n &#13;
      bnlt loopDone &#13;
      add  w21, w19, w20   // k = jm2 + i &#13;
      add  w20, w20, #1 &#13;
&#13;
      <var>Other code</var> &#13;
&#13;
      b.al lp &#13;
loopDone: </code></pre>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec42">&#13;
&#13;
<h4 class="H2" id="sec42"><span id="h2-154"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.9.4 Unraveling Loops</span></h4>&#13;
<p class="TNI1">For small loops—those whose bodies are composed of just a few statements—the overhead required to process the loop may constitute a significant percentage of the total processing time. For example, consider the following Pascal code and its associated ARM assembly language code:</p>&#13;
<pre id="pre-670"><code>     for i := 3 downto 0 do A[i] := 0; &#13;
&#13;
          mov  w19, #3       // Assume i = W19. &#13;
          add  x20, fp, #A   // LEA X20,A, assuming A is local. &#13;
LoopLbl: &#13;
          str  wzr, [x20, x19, lsl #2] &#13;
          subs w19, w19, #1 &#13;
          bpl  LoopLbl </code></pre>&#13;
<p class="TX">Three instructions execute on each repetition of the loop. Only one instruction is doing the desired operation (moving a 0 into an element of <span class="SANS_TheSansMonoCd_W5Regular_11">A</span>). The remaining two instructions control the loop. Therefore, it takes 12 instructions to do the operation logically required by 4.</p>&#13;
<p class="TX">While we could make many improvements to this loop based on the information presented thus far, consider carefully exactly what it is that this loop is doing: it’s storing four 0s into <span class="SANS_TheSansMonoCd_W5Regular_11">A[0]</span> through <span class="SANS_TheSansMonoCd_W5Regular_11">A[3]</span>. A more efficient approach is to use four <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instructions to accomplish the same task. For example, if <span class="SANS_TheSansMonoCd_W5Regular_11">A</span> is an array of words, the following code initializes <span class="SANS_TheSansMonoCd_W5Regular_11">A</span> much faster than the preceding code:</p>&#13;
<pre id="pre-671"><code>str  wzr, [fp, #A + 0] &#13;
str  wzr, [fp, #A + 4] &#13;
str  wzr, [fp, #A + 8] &#13;
str  wzr, [fp, #A + 12] </code></pre>&#13;
<p class="TX">Although this is a simple example, it shows the benefit of <i>loop unraveling</i> (also known as <i>loop unrolling</i>), which consists of repeating the loop’s body as source code for each iteration of the loop. If this simple loop appeared buried inside a set of nested loops, the 3:1 instruction reduction could possibly double the performance of that section of your program. (It would be criminal not to mention at this point that you could cut this down to two <span role="doc-pagebreak" epub:type="pagebreak" id="pg_433" aria-label="433"/>instructions by storing XZR, a double word, into <span class="SANS_TheSansMonoCd_W5Regular_11">A + 0</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">A + 8</span>, though that is a different optimization.)</p>&#13;
<p class="TX">Of course, you cannot unravel all loops. Loops that execute a variable number of times are difficult to unravel because there is rarely a way to determine at assembly time the number of loop iterations. Therefore, unraveling a loop is a process best applied to loops that execute a known number of times, with the number of times known at assembly time.</p>&#13;
<p class="TX">Even if you repeat a loop a fixed number of iterations, it may not be a good candidate for loop unraveling. Loop unraveling produces impressive performance improvements when the number of instructions controlling the loop (and handling other overhead operations) represents a significant percentage of the total number of instructions in the loop. Had the previous loop contained 36 instructions in the body (exclusive of the 3 overhead instructions), the performance improvement would be, at best, only 10 percent, compared with the 300 to 400 percent it now enjoys.</p>&#13;
<p class="TX">Therefore, the costs of unraveling a loop—all the extra code that must be inserted into your program—quickly reach a point of diminishing returns as the body of the loop grows larger or as the number of iterations increases. Furthermore, entering that code into your program can become quite a chore. Therefore, loop unraveling is a technique best applied to small loops.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec43">&#13;
&#13;
<h4 class="H2" id="sec43"><span id="h2-155"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">7.9.5 Using Induction Variables</span></h4>&#13;
<p class="TNI1">This section introduces optimizations based on induction variables. An <i>induction variable</i> is one whose value depends entirely on the value of another variable. Consider the following Pascal loop:</p>&#13;
<pre id="pre-672"><code>for i := 0 to 255 do csetVar[i] := [];</code></pre>&#13;
<p class="TX">Here the program is initializing each element of an array of character sets to the empty set. The straightforward code to achieve this is the following:</p>&#13;
<pre id="pre-673"><code>     str  wzr, [fp, #i] &#13;
     lea  x20, csetVar &#13;
FLp: &#13;
&#13;
     // Assume that each element of a csetVar &#13;
     // array contains 16 bytes (256 bits). &#13;
&#13;
     ldr  w19, [fp, #i] &#13;
     lsl  w19, w19, #4     // i * 16 (element size) &#13;
&#13;
     // Set this element to the empty set (all 0 bits). &#13;
&#13;
     str  xzr, [x20, x19]  // Fill in first 8 bytes. &#13;
     add  x20, x20, #8 &#13;
     str  xzr, [x20, x19]  // Initialize second 8 bytes. &#13;
     sub  x20, x20, #8 &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_434" aria-label="434"/>     ldr  w19, [fp, #i] &#13;
     add  w19, w19, #1 &#13;
     str  w19, [fp, #i] &#13;
     cmp  w19, #256     // Quit if at end of array. &#13;
     blo  FLp </code></pre>&#13;
<p class="TX">Although unraveling this code will still improve performance, it will take 2,304 instructions to accomplish this task—too many for all but the most time-critical applications. However, you can reduce the execution time of the loop’s body by using induction variables.</p>&#13;
<p class="TX">In the preceding example, the index into the array <span class="SANS_TheSansMonoCd_W5Regular_11">csetVar</span> tracks the loop-control variable; it’s always equal to the value of the loop-control variable times 16. Because <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> doesn’t appear anywhere else in the loop, there is no sense in performing the computations on <span class="SANS_TheSansMonoCd_W5Regular_11">i</span>. Why not operate directly on the array index value? Furthermore, because the scaled-indexed addressing mode doesn’t support an integer offset component, the code is constantly adding 8 to or subtracting 8 from X20 to initialize the second half of each character set element. This computation can also be worked into the induction of the loop control variable. The following code demonstrates this technique:</p>&#13;
<pre id="pre-674"><code>     lea  x20, csetVar &#13;
     add  x19, x20, #255 * 16  // Compute array ending address. &#13;
FLp: &#13;
&#13;
     // Set current element to the empty set (all 0 bits). &#13;
&#13;
     str  xzr, [x20]       // Fill in first 8 bytes. &#13;
     str  xzr, [x20, #8]   // Fill in second 8 bytes. &#13;
&#13;
     add  w20, x20, #16    // Move on to next element. &#13;
     cmp  x20, x19 &#13;
     blo  FLp </code></pre>&#13;
<p class="TX">The induction that takes place in this example occurs when the code initializes the loop control variable with the address of the array (moved into X20 for efficiency) and then increments it by 16 on each iteration of the loop rather than by 1. This allows the code to use the indirect-plus- offset addressing mode (rather than the scaled-indexed addressing mode), as no shift is required. Once the code can use the indirect-plus-offset mode, it can drop the addition and subtraction of the loop control variable in order to access the second half of each character set array element.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec44">&#13;
&#13;
<h3 class="H1" id="sec44"><span id="h1-99"/><span class="SANS_Futura_Std_Bold_B_11">7.10 Moving On</span></h3>&#13;
<p class="TNI1">After mastering the material in this chapter and the chapters up to this point, you should be capable of translating many HLL programs into assembly code.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_435" aria-label="435"/>This chapter covered several concepts concerning the implementation of loops in assembly language. It discussed statement labels, including working with their addresses, efficiently representing pointers to labels in your programs, using unconditional and indirect branches, working with veneers, and transferring control to statements beyond the range of the ARM branches. It then covered decisions: how to implement <span class="SANS_TheSansMonoCd_W5Regular_11">if...then...else...elseif</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statements, state machines in assembly language, Boolean expressions, and complete/short-circuit evaluation. It also described how to utilize 32-bit PC-relative addresses to reduce jump-table (and pointer) sizes. Finally, this chapter described various kinds of loops, improving loop performance, and the special ARM machine instructions that support loop construction.</p>&#13;
<p class="TX">You’re now prepared to start writing some serious assembly language code. Starting with the next chapter, you’ll learn some intermediate assembly language programming that enables you to write code that is difficult or impossible to write in HLLs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec45">&#13;
&#13;
<h3 class="H1" id="sec45"><span id="h1-100"/><span class="SANS_Futura_Std_Bold_B_11">7.11 For More Information</span></h3>&#13;
<ul class="ul">&#13;
<li class="BL">My book <i>Write Great Code,</i> Volume 2, 2nd edition (No Starch Press, 2020) provides a good discussion of the implementation of various HLL control structures in low-level assembly language. It also discusses optimizations such as induction, unrolling, strength reduction, and so on that apply to optimizing loops.</li>&#13;
</ul>&#13;
<aside class="box" aria-label="box-24">&#13;
<p class="BH" id="box-24"><span class="SANS_Dogma_OT_Bold_B_11">TEST YOURSELF</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  1.  What are the typical mechanisms for obtaining the address of a label appearing in a program?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  2.  What is the form of the indirect branch instruction?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  3.  What is a state machine?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  4.  What is a trampoline?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  5.  Explain the difference between short-circuit and complete Boolean evaluation.</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  6.  Convert the following</span> <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> <span class="SANS_Futura_Std_Book_11">statements to assembly language sequences by using complete Boolean evaluation (assume all variables are unsigned 32-bit integer values):</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  </span></p>&#13;
<pre id="pre-675"><code>if(x == y || z &gt; t)&#13;
{&#13;
 <var>Do something.</var>&#13;
}</code></pre>&#13;
<p class="BoxListLetterSub"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_436" aria-label="436"/><span class="SANS_Futura_Std_Book_11">b.  </span></p>&#13;
<pre id="pre-676"><code>if(x != y &amp;&amp; z &lt; t)&#13;
{&#13;
 <var>then statements</var>&#13;
}&#13;
else&#13;
{&#13;
 <var>else statements</var>&#13;
}</code></pre>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  7.  Convert the preceding statements (a) and (b) to assembly language by using short-circuit Boolean evaluation, assuming all variables are signed 16-bit integer values.</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  8.  Convert the following</span> <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> <span class="SANS_Futura_Std_Book_11">statements to assembly language (assume all variables are unsigned 32-bit integers):</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  </span></p>&#13;
<pre id="pre-677"><code>switch(s)&#13;
{&#13;
 case 0: <var>case 0 code</var> break;&#13;
 case 1: <var>case 1 code</var> break;&#13;
 case 2: <var>case 2 code</var> break;&#13;
 case 3: <var>case 3 code</var> break;&#13;
}</code></pre>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  </span></p>&#13;
<pre id="pre-678"><code>switch(t)&#13;
{&#13;
 case 2: <var>case 2 code</var> break;&#13;
 case 4: <var>case 4 code</var> break;&#13;
 case 5: <var>case 5 code</var> break;&#13;
 case 6: <var>case 6 code</var> break;&#13;
 default: <var>default code</var>&#13;
}</code></pre>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  9.  Convert the following</span> <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> <span class="SANS_Futura_Std_Book_11">loops to assembly code (assume all variables are signed 32-bit integers):</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  </span></p>&#13;
<pre id="pre-679"><code>while(i &lt; j) &#13;
{&#13;
 <var>Code for loop body</var>&#13;
}&#13;
&#13;
do&#13;
{&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_437" aria-label="437"/> <var>Code for loop body</var>&#13;
} while(i != j);</code></pre>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  </span></p>&#13;
<pre id="pre-680"><code>do&#13;
{&#13;
 <var>Code for loop body, part a</var>&#13;
 if(m != 5) continue;&#13;
 <var>Code for loop body, part b</var>&#13;
 if(n == 6) break;&#13;
 <var>Code for loop body, part c</var>&#13;
} while(i &lt; j &amp;&amp; k &gt; j);</code></pre>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  </span></p>&#13;
<pre id="pre-681"><code>for(int i = 0; i &lt; 10; ++i)&#13;
{&#13;
 <var>Code for loop body</var>&#13;
}</code></pre>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>