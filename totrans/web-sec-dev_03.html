<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_7"/><strong><span class="big">2</span></strong><br/><strong>HOW THE INTERNET WORKS</strong></h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="image" width="190" height="190"/></div>&#13;
<p class="noindent">To become an expert on web security, you need a firm grasp of the internet’s underlying web technologies and protocols. This chapter examines the Internet Protocol Suite, which dictates how computers exchange data over the web. You’ll also learn about stateful connections and encryption, which are key elements of the modern web. I’ll highlight where security holes tend to appear along the way.</p>&#13;
<h3 class="h3" id="ch00lev1sec13"><strong>The Internet Protocol Suite</strong></h3>&#13;
<p class="noindent">In the early days of the internet, data exchange wasn’t reliable. The first message sent over the <em>Advanced Research Projects Agency Network (ARPANET)</em>, the predecessor to the internet, was a <code>LOGIN</code> command destined for a remote computer at Stanford University. The network sent the first two letters, <code>LO</code>, and then crashed. This was a problem for the US military, which was <span epub:type="pagebreak" id="page_8"/>looking for a way to connect remote computers so that they could continue to exchange information even if a Soviet nuclear strike took various parts of the network offline.</p>&#13;
<p class="indent">To address this problem, the network engineers developed the <em>Transmission Control Protocol (TCP)</em> to ensure a reliable exchange of information between computers. TCP is one of about 20 network protocols that are collectively referred to as the <em>internet protocol suite</em>. When a computer sends a message to another machine via TCP, the message is split into data packets that are sent toward their eventual destination with a destination address. The computers that make up the internet push each packet toward the destination without having to process the whole message.</p>&#13;
<p class="indent">Once the recipient computer receives the packets, it assembles them back into a usable order according to the <em>sequence number</em> on each packet. Every time the recipient receives a packet, it sends a receipt. If the recipient fails to acknowledge receipt of a packet, the sender resends that packet, possibly along a different network path. In this way, TCP allows computers to deliver data across a network that is expected to be unreliable.</p>&#13;
<p class="indent">TCP has undergone significant improvements as the internet has grown. Packets are now sent with a <em>checksum</em> that allows recipients to detect data corruption and determine whether packets need to be resent. Senders also preemptively adjust the rate at which they send data according to how fast it’s being consumed. (Internet servers are usually magnitudes more powerful than the clients that receive their messages, so they need to be careful not to overwhelm the client’s capacity.)</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>TCP remains the most common protocol because of its delivery guarantees, but nowadays, several other protocols are also used over the internet. The</em> User Datagram Protocol (UDP)<em>, for instance, is a newer protocol that deliberately allows packets to be dropped so that data can be streamed at a constant rate. UDP is commonly used for streaming live video, since consumers prefer a few dropped frames over having their feed delayed when the network gets congested.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec14"><strong><em>Internet Protocol Addresses</em></strong></h4>&#13;
<p class="noindent">Data packets on the internet are sent to <em>Internet Protocol (IP) addresses</em>, numbers assigned to individual internet-connected computers. Each IP address must be unique, so new IP addresses are issued in a structured fashion.</p>&#13;
<p class="indent">At the highest level, the <em>Internet Corporation for Assigned Names and Numbers (ICANN)</em> allots blocks of IP addresses to regional authorities. These regional authorities then grant the blocks of addresses to <em>internet service providers (ISPs)</em> and hosting companies within their region. When you connect your browser to the internet, your ISP assigns your computer an IP address that stays fixed for a few months. (ISPs tend to rotate IP addresses for clients periodically.) Similarly, companies that host content on the internet are assigned an IP address for each server they connect to the network.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_9"/>IP addresses are binary numbers, generally written in <em>IP version 4 (IPv4)</em> syntax, which allows for 2<sup>32</sup> (4,294,967,296) addresses. Google’s domain name server, for instance, has the address <code>8.8.8.8</code>. Because IPv4 addresses are getting used up at a rate that isn’t sustainable, the internet is shifting to <em>IP version 6 (IPv6)</em> addresses to allow for more connected devices, represented as eight groups of four hexadecimal digits separated by colons (for example: <code>2001:0db8:0000:0042:0000:8a2e:0370:7334</code>).</p>&#13;
<h4 class="h4" id="ch00lev1sec15"><strong><em>The Domain Name System</em></strong></h4>&#13;
<p class="noindent">Browsers and other internet-connected software can recognize and route traffic to IP addresses, but IP addresses aren’t particularly memorable for humans. To make website addresses friendlier to users, we use a global directory called the <em>Domain Name System (DNS)</em> to translate human-readable <em>domains</em> like <em><a href="http://example.com">example.com</a></em> to IP addresses like <code>93.184.216.119</code>. Domain names are simply placeholders for IP addresses. Domain names, like IP addresses, are unique, and have to be registered before use with private organizations called <em>domain registrars</em>.</p>&#13;
<p class="indent">When browsers encounter a domain name for the first time, they use a local <em>domain name server</em> (typically hosted by an ISP) to look it up, and then cache the result to prevent time-consuming lookups in the future. This caching behavior means that new domains or changes to existing domains take a while to propagate on the internet. Exactly how long this propagation takes is controlled by the <em>time-to-live (TTL)</em> variable, which is set on the DNS record and instructs DNS caches when to expire the record. DNS caching enables a type of attack called <em>DNS poisoning</em>, whereby a local DNS cache is deliberately corrupted so that data is routed to a server controlled by an attacker.</p>&#13;
<p class="indent">In addition to returning IP addresses for particular domains, domain name servers host records that can describe domain aliases via <em>canonical name (CNAME) records</em> that allow multiple domain names to point to the same IP address. DNS can also help route email by using <em>mail exchange (MX)</em> records. We’ll examine how DNS records can help combat unsolicited email (spam) in <a href="ch16.xhtml#ch16">Chapter 16</a>.</p>&#13;
<h3 class="h3" id="ch00lev1sec16"><strong>Application Layer Protocols</strong></h3>&#13;
<p class="noindent">TCP allows two computers to reliably exchange data on the internet, but it doesn’t dictate how the data being sent should be interpreted. For that to happen, both computers need to agree to exchange information through another, higher-level protocol in the suite. Protocols that build on top of TCP (or UDP) are called <em>application layer protocols</em>. <a href="ch02.xhtml#ch2fig1">Figure 2-1</a> illustrates how application layer protocols sit above TCP in the internet protocol suite.</p>&#13;
<p class="indent">The lower-level protocols of the internet protocol suite provide basic data routing over a network, while the higher-level protocols in the application layer provide more structure for applications exchanging data. Many types of applications use TCP as a transport mechanism on the internet. <span epub:type="pagebreak" id="page_10"/>For example, emails are sent using the Simple Mail Transport Protocol (SMTP), instant messaging software often uses the Extensible Messaging and Presence Protocol (XMPP), file servers make downloads available via the File Transfer Protocol (FTP), and web servers use the HyperText Transfer Protocol (HTTP). Because the web is our chief focus, let’s look at HTTP in more detail.</p>&#13;
<div class="image"><img src="Images/02fig01.jpg" alt="image" width="1389" height="459"/></div>&#13;
<p class="figcap"><a id="ch2fig1"/><em>Figure 2-1: The various layers that make up the internet protocol suite</em></p>&#13;
<h4 class="h4" id="ch00lev1sec17"><strong><em>HyperText Transfer Protocol</em></strong></h4>&#13;
<p class="noindent">Web servers use the <em>HyperText Transfer Protocol (HTTP</em>) to transport web pages and their resources to <em>user agents</em> such as web browsers. In an HTTP conversation, the user agent generates <em>requests</em> for particular resources. Web servers, expecting these requests, return <em>responses</em> containing either the requested resource, or an error code if the request can’t be fulfilled. Both HTTP requests and responses are plaintext messages, though they’re often sent in compressed and encrypted form. All of the exploits described in this book use HTTP in some fashion, so it’s worth knowing how the requests and responses that make up HTTP conversations work in detail.</p>&#13;
<h5 class="h5" id="ch00lev1sec18"><strong>HTTP Requests</strong></h5>&#13;
<p class="noindent">An HTTP request sent by a browser consists of the following elements:</p>&#13;
<p class="noindentf"><strong>Method</strong> Also known as a <em>verb</em>, this describes the action that the user agent wants the server to perform.</p>&#13;
<p class="noindentf"><strong>Universal resource locator (URL)</strong> This describes the resource being manipulated or fetched.</p>&#13;
<p class="noindentf"><strong>Headers</strong> These supply metadata such as the type of content the user agent is expecting or whether it accepts compressed responses.</p>&#13;
<p class="noindentf"><strong>Body</strong> This optional component contains any extra data that needs to be sent to the server.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2list1">Listing 2-1</a> shows an HTTP request.</p>&#13;
<pre>   GET<span class="ent">❶</span> http://example.com/<span class="ent">❷</span><br/><span class="ent">❸</span> User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6)<br/>   AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36<br/><span class="ent">❹</span> Accept: text/html,application/xhtml+xml,application/xml; */*<br/>   <span epub:type="pagebreak" id="page_11"/>Accept-Encoding: gzip, deflate<br/>   Accept-Language: en-GB,en-US;q=0.9,en;q=0.8</pre>&#13;
<p class="caption"><a id="ch2list1"/><em>Listing 2-1: A simple HTTP request</em></p>&#13;
<p class="indent">The method <span class="ent">❶</span> and the URL <span class="ent">❷</span> appear on the first line. These are followed by HTTP headers on separate lines. The <code>User-Agent</code> header <span class="ent">❸</span> tells the website the type of browser that is making the request. The <code>Accept</code> header <span class="ent">❹</span> tells the website the type of content the browser is expecting.</p>&#13;
<p class="indent">Requests that use the <code>GET</code> method—called <code>GET</code> requests for short—are the most common type of request on the internet. <code>GET</code> requests fetch a particular resource on the web server, identified by a specific URL. The response to a <code>GET</code> request will contain a resource: perhaps a web page, an image, or even the results of a search request. The example request in <a href="ch02.xhtml#ch2list1">Listing 2-1</a> represents an attempt to load the home page of <em><a href="http://example.com">example.com</a></em>, and would be generated when a user types <em><a href="http://example.com">example.com</a></em> in the browser’s navigation bar.</p>&#13;
<p class="indent">If the browser needs to send information to the server, rather than just fetch data, it typically uses a <code>POST</code> request. When you fill out a form on a web page and submit it, the browser sends a <code>POST</code> request. Because <code>POST</code> requests contain information sent to the server, the browser sends that information in a <em>request body</em>, after the HTTP headers.</p>&#13;
<p class="indent">In <a href="ch08.xhtml#ch08">Chapter 8</a>, you’ll see why it’s important to use <code>POST</code> rather than <code>GET</code> requests when sending data to your server. Websites that erroneously use <code>GET</code> requests for doing anything other than retrieving resources are vulnerable to cross-site request forgery attacks.</p>&#13;
<p class="indent">When writing a website, you may also encounter <code>PUT</code>, <code>PATCH</code>, and <code>DELETE</code> requests. These are used to upload, edit, or delete resources on the server, respectively, and are typically triggered by JavaScript embedded in a web page. <a href="ch02.xhtml#ch2tab01">Table 2-1</a> documents a handful of other methods that are worth knowing about.</p>&#13;
<p class="tabcap"><a id="ch2tab01"/><strong>Table 2-1:</strong> The Lesser-Known HTTP Methods</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="noindent-th"><strong>HTTP method</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="noindent-th"><strong>Function and implementation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="noindent-th"><code>HEAD</code></p></td>&#13;
<td style="vertical-align: top;"><p class="noindent-th">A <code>HEAD</code> request retrieves the same information as a <code>GET</code> request, but instructs the server to return the response without a body (in other words, the useful part). If you implement a <code>GET</code> method on your web server, the server will generally respond to <code>HEAD</code> requests automatically.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="noindent-th"><code>CONNECT</code></p></td>&#13;
<td style="vertical-align: top;"><p class="noindent-th"><code>CONNECT</code> initiates two-way communications. You’ll use it in your HTTP client code if you ever have to connect through a proxy.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="noindent-th"><code>OPTIONS</code></p></td>&#13;
<td style="vertical-align: top;"><p class="noindent-th">Sending an <code>OPTIONS</code> request lets a user agent ask what other methods are supported by a resource. Your web server will generally respond to <code>OPTIONS</code> requests by inferring which other methods you have implemented.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="noindent-th"><code>TRACE</code></p></td>&#13;
<td style="vertical-align: top;"><p class="noindent-th">A response to a <code>TRACE</code> request will contain an exact copy of the original HTTP request, so the client can see what (if any) alterations were made by intermediate servers. This sounds useful, but it’s generally recommended that you turn off <code>TRACE</code> requests in your web server, because they can act as a security hole. For instance, they can allow malicious JavaScript injected into a page to access cookies that have been deliberately made inaccessible to JavaScript.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_12"/>Once a web server receives an HTTP request, it replies to the user agent with an HTTP response. Let’s break down how responses are structured.</p>&#13;
<h5 class="h5" id="ch00lev1sec19"><strong>HTTP Responses</strong></h5>&#13;
<p class="noindent">HTTP responses sent back by a web server begin with a protocol description, a three-digit <em>status code</em>, and, typically, a <em>status message</em> that indicates whether the request can be fulfilled. The response also contains headers providing metadata that instructs the browser how to treat the content. Finally, most responses contain a body that itself contains the requested resource. <a href="ch02.xhtml#ch2list2">Listing 2-2</a> shows the contents of a simple HTTP response.</p>&#13;
<pre>   HTTP/1.1<span class="ent">❶</span> 200<span class="ent">❷</span> OK<span class="ent">❸</span><br/><span class="ent">❹</span> Content-Encoding: gzip<br/>   Accept-Ranges: bytes<br/>   Cache-Control: max-age=604800<br/>   Content-Type: text/html<br/>   Content-Length: 606<br/><br/><span class="ent">❺</span> &lt;!doctype html&gt;<br/>   &lt;html&gt;<br/>      &lt;head&gt;<br/>         &lt;title&gt;Example Domain&lt;/title&gt;<br/>     <span class="ent">❻</span> &lt;style type="text/css"&gt;<br/>            body {<br/>               background-color: #f0f0f2;<br/>               font-family: "Open Sans", "Helvetica Neue", Helvetica, sans-serif;<br/>            }<br/>            div {<br/>               width: 600px;<br/>               padding: 50px;<br/>               background-color: #fff;<br/>               border-radius: 1em;<br/>            }<br/>         &lt;/style&gt;<br/>      &lt;/head&gt;<br/>  <span class="ent">❼</span> &lt;body&gt;<br/>         &lt;div&gt;<br/>            &lt;h1&gt;Example Domain&lt;/h1&gt;<br/>            &lt;p&gt;This domain is established to be used for illustrative examples.&lt;/p&gt;<br/>            &lt;p&gt;<br/>              &lt;a href="http://www.iana.org/domains/example"&gt;More information...&lt;/a&gt;<br/>            &lt;/p&gt;<br/>         &lt;/div&gt;<br/>      &lt;/body&gt;<br/>   &lt;/html&gt;</pre>&#13;
<p class="caption"><a id="ch2list2"/><em>Listing 2-2: An HTTP response from</em> <a href="http://example.com">example.com</a>, <em>the world’s least interesting website</em></p>&#13;
<p class="indent">The response begins with the protocol description <span class="ent">❶</span>, the status code <span class="ent">❷</span>, and the status message <span class="ent">❸</span>. Status codes formatted as <code>2<span class="codeitalic1">xx</code></span> indicate that the request was understood, accepted, and responded to. Codes formatted as <span epub:type="pagebreak" id="page_13"/><code>3<span class="codeitalic1">xx</code></span> redirect the client to a different URL. Codes formatted as <code>4<span class="codeitalic1">xx</code></span> indicate a client error: the browser generated an apparently invalid request. (The most common error of this type is <code>HTTP 404 Not Found</code>). Codes formatted as <code>5<span class="codeitalic1">xx</code></span> indicate a server error: the request was valid, but the server was unable to fulfill the request.</p>&#13;
<p class="indent">Next are the HTTP headers <span class="ent">❹</span>. Almost all HTTP responses include a <code>Content-Type</code> header that indicates the kind of data being returned. Responses to <code>GET</code> requests also often contain a <code>Cache-Control</code> header to indicate that the client should cache large resources (for example, images) locally.</p>&#13;
<p class="indent">If the HTTP response is successful, the body contains the resource the client was trying to access—often <em>HyperText Markup Language (HTML)</em> <span class="ent">❺</span> describing the structure of the requested web page. In this case, the response contains styling information <span class="ent">❻</span> as well as the page content itself <span class="ent">❼</span>. Other types of responses may return JavaScript code, Cascading Style Sheets (CSS) used for styling HTML, or binary data in the body.</p>&#13;
<h3 class="h3" id="ch00lev1sec20"><strong>Stateful Connections</strong></h3>&#13;
<p class="noindent">Web servers typically deal with many user agents at once, but HTTP does nothing to distinguish which requests are coming from which user agent. This wasn’t an important consideration in the early days of the internet, because web pages were largely read-only. Modern websites, however, often allow users to log in and will track their activity as they visit and interact with different pages. To allow for this, HTTP conversations need to be made stateful. A connection or conversation between a client and a server is <em>stateful</em> when they perform a “handshake” and continue to send packets back and forth until one of the communicating parties decides to terminate the connection.</p>&#13;
<p class="indent">When a web server wants to keep track of which user it’s responding to with each request, and thus achieve a stateful HTTP conversation, it needs to establish a mechanism to track the user agent as it makes the subsequent requests. The entire conversation between a particular user agent and a web server is called an <em>HTTP session</em>. The most common way of tracking sessions is for the server to send back a <code>Set-Cookie</code> header in the initial HTTP response. This asks the user agent receiving the response to store a <em>cookie</em>, a small snippet of text data pertaining to that particular web domain. The user agent then returns the same data in the <code>Cookie</code> header of any subsequent HTTP request to the web server. If implemented correctly, the contents of the cookie being passed back and forth uniquely identify the user agent and hence establish the HTTP session.</p>&#13;
<p class="indent">Session information contained in cookies is a juicy target for hackers. If an attacker steals another user’s cookie, they can pretend to be that user on the website. Similarly, if an attacker successfully persuades a website to accept a forged cookie, they can impersonate any user they please. We’ll look at various methods of stealing and forging cookies in <a href="ch10.xhtml#ch10">Chapter 10</a>.</p>&#13;
<h3 class="h3" id="ch00lev1sec21"><span epub:type="pagebreak" id="page_14"/><strong>Encryption</strong></h3>&#13;
<p class="noindent">When the web was first invented, HTTP requests and responses were sent in plaintext form, which meant they could be read by anyone intercepting the data packets; this kind of interception is known as a <em>man-in-the-middle attack</em>. Because private communication and online transactions are common on the modern web, web servers and browsers protect their users from such attacks by using <em>encryption</em>, a method of disguising the contents of messages from prying eyes by encoding them during transmission.</p>&#13;
<p class="indent">To secure their communications, web servers and browsers send requests and responses by using <em>Transport Layer Security (TLS)</em>, a method of encryption that provides both privacy and data integrity. TLS ensures that packets intercepted by a third party can’t be decrypted without the appropriate encryption keys. It also ensures that any attempt to tamper with the packets will be detectable, which ensures data integrity.</p>&#13;
<p class="indent">HTTP conversations conducted using TLS are called <em>HTTP Secure (HTTPS)</em>. HTTPS requires the client and server to perform a <em>TLS handshake</em> in which both parties agree on an encryption method (a cipher) and exchange encryption keys. Once the handshake is complete, any further messages (both requests and responses) will be opaque to outsiders.</p>&#13;
<p class="indent">Encryption is a complex topic but is key to securing your website. We’ll examine how to enable encryption for your website in <a href="ch13.xhtml#ch13">Chapter 13</a>.</p>&#13;
<h3 class="h3" id="ch00lev1sec22"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you learned about the plumbing of the internet. TCP enables reliable communication between internet-connected computers that each have an IP address. The Domain Name System provides human-readable aliases for IP addresses. HTTP builds on top of TCP to send HTTP requests from user agents (such as web browsers) to web servers, which in turn reply with HTTP responses. Each request is sent to a specific URL, and you learned about various types of HTTP methods. Web servers respond with status codes, and send back cookies to initiate stateful connections. Finally, encryption (in the form of HTTPS) can be used to secure communication between a user agent and a web server.</p>&#13;
<p class="indent">In the next chapter, you’ll take a look at what happens when a web browser receives an HTTP response—how a web page is rendered, and how user actions can generate more HTTP requests.</p>&#13;
</div>



  </body></html>