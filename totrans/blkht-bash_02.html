<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch2">&#13;
<hgroup>&#13;
<h1 class="CHAPTER" id="ch2">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_27" aria-label="27"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">2</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">FLOW CONTROL AND TEXT PROCESSING</span></span>&#13;
</h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="COS">This chapter covers bash concepts that can make your scripts more intelligent. You’ll learn how to test conditions, use loops, consolidate code into functions, send commands to the background, and more. You’ll also learn some ways of customizing your bash environment for penetration testing.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h1-10"/><span class="SANS_Futura_Std_Bold_B_11">Test Operators</span></h2>&#13;
<p class="TNI1">Bash lets us selectively execute commands when certain conditions of interest are met. We can use <i>test operators</i> to craft a wide variety of conditions, such as whether one value equals another value, whether a file is of a certain type, or whether one value is greater than another. We often rely on <span role="doc-pagebreak" epub:type="pagebreak" id="pg_28" aria-label="28"/>such tests to determine whether to continue running a block of code, so being able to construct them is fundamental to bash programming.</p>&#13;
<p class="TX">Bash has multiple kinds of test operators. <i>File test operators</i> allow us to perform tests against files on the filesystem, such as checking whether a file is executable or whether a certain directory exists. <a href="chapter2.xhtml#tab2-1">Table 2-1</a> shows a short list of the available tests.</p>&#13;
<p class="TT" id="tab2-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 2-1:</span></span> <span class="SANS_Futura_Std_Book_11">File Test Operators</span></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Operator</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-d</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether the file is a directory</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-r</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether the file is readable</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-x</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether the file is executable</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-w</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether the file is writable</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-f</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether the file is a regular file</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-s</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether the file size is greater than zero</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">You can find the full list of file test operators at <i><a href="https://ss64.com/bash/test.html">https://ss64.com/bash/test.html</a></i> or by running the <span class="SANS_TheSansMonoCd_W5Regular_11">man test</span> command.</p>&#13;
<p class="TX"><i>String comparison operators</i> allow us to perform tests related to strings, such as testing whether one string is equal to another. <a href="chapter2.xhtml#tab2-2">Table 2-2</a> shows the string comparison operators.</p>&#13;
<p class="TT" id="tab2-2"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 2-2:</span></span> <span class="SANS_Futura_Std_Book_11">String Comparison Operators</span></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Operator</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">=</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether a string is equal to another string</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">==</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Synonym of</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> <span class="SANS_Futura_Std_Book_11">when used within [[]] constructs</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">!=</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether a string is not equal to another string</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&lt;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether a string comes before another string (in alphabetical order)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&gt;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether a string comes after another string (in alphabetical order)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-z</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether a string is null</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-n</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether a string is not null</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><i>Integer comparison operators</i> allow us to perform checks on integers, such as whether an integer is less than or greater than another. <a href="chapter2.xhtml#tab2-3">Table 2-3</a> shows the available operators.</p>&#13;
<p class="TT" id="tab2-3"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_29" aria-label="29"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 2-3:</span></span> <span class="SANS_Futura_Std_Book_11">Integer Comparison Operators</span></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Operator</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-eq</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether a number is equal to another number</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-ne</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether a number is not equal to another number</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-ge</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether a number is greater than or equal to another number</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-gt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether a number is greater than another number</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-lt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether a number is less than another number</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-le</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Checks whether a number is less than or equal to another number</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Let’s use these operators in flow-control mechanisms to decide what code to run next.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h2 class="H1" id="sec2"><span id="h1-11"/><span class="SANS_Futura_Std_Bold_B_11">if Conditions</span></h2>&#13;
<p class="TNI1">In bash, we can use an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> condition to execute code only when a certain condition is met. <a href="chapter2.xhtml#Lis2-1">Listing 2-1</a> shows its syntax.</p>&#13;
<span id="Lis2-1"/><pre><code>if [[<var>condition</var>]]; then&#13;
  # Do something if the condition is met.&#13;
else&#13;
  # Do something if the condition is not met.&#13;
fi&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-1: The structure of an if statement</span></p>&#13;
<p class="TX">We start with the <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> keyword, followed by a test condition between double square brackets (<span class="SANS_TheSansMonoCd_W5Regular_11">[[]]</span>). We then use the <span class="SANS_TheSansMonoCd_W5Regular_11">;</span> character to separate the <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> keyword from the <span class="SANS_TheSansMonoCd_W5Regular_11">then</span> keyword, which allows us to introduce a block of code that runs only if the condition is met.</p>&#13;
<p class="TX">Next, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">else</span> keyword to introduce a fallback code block that runs if the condition is not met. Note that <span class="SANS_TheSansMonoCd_W5Regular_11">else</span> is optional, and you may not always need it. Finally, we close the <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> condition with the <span class="SANS_TheSansMonoCd_W5Regular_11">fi</span> keyword (which is <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> inversed).</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>In some operating systems, such as those often used in containers, the default shell might not necessarily be bash. To account for these cases, you may want to use single square brackets (</i><span class="TheSansMonoCd_W5Regular_Italic_I_11">[...]</span><i>) rather than double to enclose your condition. This use of single brackets meets the Portable Operating System Interface standard and should work on almost any Unix derivative, including Linux.</i></p>&#13;
<p class="TX">Let’s see an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> condition in practice. <a href="chapter2.xhtml#Lis2-2">Listing 2-2</a> uses an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> condition to test whether a file exists and, if not, creates it.</p>&#13;
<span id="Lis2-2"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">test_if_file _exists.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
FILENAME="flow_control_with_if.txt"&#13;
&#13;
if [[-f "${FILENAME}"]]; then&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_30" aria-label="30"/>  echo "${FILENAME} already exists."&#13;
  exit 1&#13;
else&#13;
  touch "${FILENAME}"&#13;
fi&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-2: An if condition to test for the existence of a file</span></p>&#13;
<p class="TX">We first create a variable named <span class="SANS_TheSansMonoCd_W5Regular_11">FILENAME</span> containing the name of the file we need. This saves us from having to repeat the filename in the code. We then introduce the <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement, which includes a condition that uses the <span class="SANS_TheSansMonoCd_W5Regular_11">-f</span> file test operator to test for the existence of the file. If this condition is true, we use <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> to print to the screen a message explaining that the file already exists and then use the status code <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> (failure) to exit the program. In the <span class="SANS_TheSansMonoCd_W5Regular_11">else</span> block, which will execute only if the file does not exist, we create the file by using the <span class="SANS_TheSansMonoCd_W5Regular_11">touch</span> command.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You can download this chapter’s scripts from</i> <span class="note_LinkURL"><a href="https://github.com/dolevf/Black-Hat-Bash/blob/master/ch02">https://github.com/dolevf/Black-Hat-Bash/blob/master/ch02</a></span>.</p>&#13;
<p class="TX">Save the file and execute it. You should see the <i>flow_control_with_if.txt</i> file in your current directory when you run <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span>.</p>&#13;
<p class="TX"><a href="chapter2.xhtml#Lis2-3">Listing 2-3</a> shows a different way of achieving the same outcome: it uses the NOT operator (<span class="SANS_TheSansMonoCd_W5Regular_11">!</span>) to check whether a directory <i>doesn’t</i> exist and, if it doesn’t, creates it. This example has fewer lines of code and eliminates the need for an <span class="SANS_TheSansMonoCd_W5Regular_11">else</span> block altogether.</p>&#13;
<span id="Lis2-3"/><pre><code>#!/bin/bash&#13;
FILENAME="flow_control_with_if.txt"&#13;
&#13;
if [[! -f "${FILENAME}"]]; then&#13;
  touch "${FILENAME}"&#13;
fi&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-3: Using a negative check to test file existence</span></p>&#13;
<p class="TX">Let’s explore <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> conditions that use some of the other kinds of test operators we’ve covered. <a href="chapter2.xhtml#Lis2-4">Listing 2-4</a> shows a string comparison test. It tests whether two variables are equal by performing string comparison with the equal-to operator (<span class="SANS_TheSansMonoCd_W5Regular_11">==</span>).</p>&#13;
<span id="Lis2-4"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">string _comparison.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
VARIABLE_ONE="nostarch"&#13;
VARIABLE_TWO="nostarch"&#13;
&#13;
if [["${VARIABLE_ONE}" == "${VARIABLE_TWO}"]]; then&#13;
  echo "They are equal!"&#13;
else&#13;
  echo "They are not equal!"&#13;
fi&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-4: Comparing two string variables</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_31" aria-label="31"/>The script will compare the two variables, both of which have the value <span class="SANS_TheSansMonoCd_W5Regular_11">nostarch</span>, and print <span class="SANS_TheSansMonoCd_W5Regular_11">They are equal!</span> by using the <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command.</p>&#13;
<p class="TX">Next is an integer comparison test, which takes two integers and checks which one is the larger number (<a href="chapter2.xhtml#Lis2-5">Listing 2-5</a>).</p>&#13;
<span id="Lis2-5"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">integer _comparison.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
VARIABLE_ONE="10"&#13;
VARIABLE_TWO="20"&#13;
&#13;
if [["${VARIABLE_ONE}" -gt "${VARIABLE_TWO}"]]; then&#13;
  echo "${VARIABLE_ONE} is greater than ${VARIABLE_TWO}."&#13;
else&#13;
  echo "${VARIABLE_ONE} is less than ${VARIABLE_TWO}."&#13;
fi&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-5: Comparing integers</span></p>&#13;
<p class="TX">We create two variables, <span class="SANS_TheSansMonoCd_W5Regular_11">VARIABLE_ONE</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">VARIABLE_TWO</span>, and assign them values of 10 and 20, respectively. We then use the <span class="SANS_TheSansMonoCd_W5Regular_11">-gt</span> operator to compare the two values and print the result based on an integer comparison.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h2-19"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Linking Conditions</span></h3>&#13;
<p class="TNI1">So far, we’ve used <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> to check whether a single condition is met. But as with most programming languages, we can also use the OR (<span class="SANS_TheSansMonoCd_W5Regular_11">||</span>) and AND (<span class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</span>) operators to check for multiple conditions at once.</p>&#13;
<p class="TX">For example, what if we want to check that a file exists and that its size is greater than zero? <a href="chapter2.xhtml#Lis2-6">Listing 2-6</a> does so.</p>&#13;
<span id="Lis2-6"/><pre><code>#!/bin/bash&#13;
&#13;
echo "Hello World!" &gt; file.txt&#13;
&#13;
if [[-f "file.txt"]] &amp;&amp; [[-s "file.txt"]]; then&#13;
  echo "The file exists and its size is greater than zero."&#13;
fi&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-6: Using AND to chain two file test conditions</span></p>&#13;
<p class="TX">This code writes content to a file, then checks whether that file exists and whether its size is greater than zero. Both conditions have to be met in order for the <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command to be executed. If either returns false, nothing will happen.</p>&#13;
<p class="TX">To demonstrate an OR condition, <a href="chapter2.xhtml#Lis2-7">Listing 2-7</a> checks whether a variable is either a file or a directory.</p>&#13;
<span id="Lis2-7"/><pre><code>#!/bin/bash&#13;
DIR_NAME="dir_test"&#13;
&#13;
mkdir "${DIR_NAME}"&#13;
&#13;
if [[-f "${DIR_NAME}"]] || [[-d "${DIR_NAME}"]]; then&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_32" aria-label="32"/>  echo "${DIR_NAME} is either a file or a directory."&#13;
fi&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-7: Chaining two file test conditions by using OR</span></p>&#13;
<p class="TX">This code first creates a directory, then uses an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> condition with the OR (<span class="SANS_TheSansMonoCd_W5Regular_11">||</span>) operator to check whether the variable is a file (<span class="SANS_TheSansMonoCd_W5Regular_11">-f</span>) or a directory (<span class="SANS_TheSansMonoCd_W5Regular_11">-d</span>). The second condition should evaluate to true, and the <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command should execute.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H2" id="sec4"><span id="h2-20"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing Command Success</span></h3>&#13;
<p class="TNI1">We can even test the exit code of commands to determine whether they were successful (<a href="chapter2.xhtml#Lis2-8">Listing 2-8</a>).</p>&#13;
<span id="Lis2-8"/><pre><code>if <var>command</var>; then&#13;
  # <var>command</var> was successful.&#13;
fi&#13;
&#13;
if ! <var>command</var>; then&#13;
  # <var>command</var> was unsuccessful.&#13;
fi&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-8: Executing commands based on exit code values</span></p>&#13;
<p class="TX">You’ll often find yourself using this technique in bash, as commands aren’t guaranteed to succeed. Failures could happen for reasons such as these:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">A lack of the necessary permissions when creating resources</li>&#13;
<li class="ListBullet">An attempt to execute a command that is not available on the operating system</li>&#13;
<li class="ListBullet">The disk being full when downloading a file</li>&#13;
<li class="ListBullet">The network being down while executing network utilities</li>&#13;
</ul>&#13;
<p class="TX">To see how this technique works, execute the following in your terminal:</p>&#13;
<pre><code>$ <b>if touch test123; then</b>&#13;
<b>    echo "OK: file created"</b>&#13;
<b>  fi</b>&#13;
&#13;
OK: file created&#13;
</code></pre>&#13;
<p class="TX">We attempt to create a file. Because the file creation succeeds, we print a message to indicate this.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H2" id="sec5"><span id="h2-21"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Checking Subsequent Conditions</span></h3>&#13;
<p class="TNI1">If the first <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> condition fails, you can check for other conditions by using the <span class="SANS_TheSansMonoCd_W5Regular_11">elif</span> keyword (short for <i>else if</i>). To show how this works, let’s write a program that checks the arguments passed to it on the command line. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_33" aria-label="33"/><a href="chapter2.xhtml#Lis2-9">Listing 2-9</a> will output a message clarifying whether the argument is a file or a directory.</p>&#13;
<span id="Lis2-9"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">if_elif.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
USER_INPUT="${1}"&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if [[-z "${USER_INPUT}"]]; then&#13;
  echo "You must provide an argument!"&#13;
  exit 1&#13;
fi&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if [[-f "${USER_INPUT}"]]; then&#13;
  echo "${USER_INPUT} is a file."&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> elif [[-d "${USER_INPUT}"]]; then&#13;
  echo "${USER_INPUT} is a directory."&#13;
else&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> echo "${USER_INPUT} is not a file or a directory."&#13;
fi&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-9: Using if and elif statements</span></p>&#13;
<p class="TX">We begin with an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement that checks whether the variable <span class="SANS_TheSansMonoCd_W5Regular_11">USER_INPUT</span> is null <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This allows us to exit the script early by using <span class="SANS_TheSansMonoCd_W5Regular_11">exit 1</span> if we receive no command line arguments from the user. We then begin a second <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> condition that uses the file test operator to check whether the input is a file <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Below this condition, we use <span class="SANS_TheSansMonoCd_W5Regular_11">elif</span> to test whether the argument is a directory <span class="CodeAnnotation" aria-label="annotation3">❸</span>. This condition won’t be tested unless the file test fails. If neither of these conditions is true, the script responds that the argument is neither a file nor a directory <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h2 class="H1" id="sec6"><span id="h1-12"/><span class="SANS_Futura_Std_Bold_B_11">Functions</span></h2>&#13;
<p class="TNI1"><i>Functions</i> help us reuse blocks of code so we can avoid repeating them. They allow us to run multiple commands and other bash code simultaneously by simply entering the function’s name. To define a new function, enter a name for it, followed by parentheses. Then place the code you would like the function to run within curly brackets (<a href="chapter2.xhtml#Lis2-10">Listing 2-10</a>).</p>&#13;
<span id="Lis2-10"/><pre><code>#!/bin/bash&#13;
&#13;
say_name(){&#13;
  echo "Black Hat Bash"&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-10: Defining a function</span></p>&#13;
<p class="TX">Here, we define a function called <span class="SANS_TheSansMonoCd_W5Regular_11">say_name()</span> that executes a single <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command. To call a function, simply enter its name:</p>&#13;
<pre><code>say_name</code></pre>&#13;
<p class="TX">If the function is not called, the commands within it won’t run.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H2" id="sec7"><span id="h2-22"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_34" aria-label="34"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Returning Values</span></h3>&#13;
<p class="TNI1">Like commands and their exit statuses, functions can return values by using the <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> keyword. If there is no <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> statement, the function will return the exit code of the last command it ran. For example, the function in <a href="chapter2.xhtml#Lis2-11">Listing 2-11</a> returns a different value based on whether the current user is root.</p>&#13;
<span id="Lis2-11"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">check_root _function.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
&#13;
# This function checks if the current user ID equals zero.&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> check_if_root(){&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if [["${EUID}" -eq "0"]]; then&#13;
    return 0&#13;
  else&#13;
    return 1&#13;
  fi&#13;
}&#13;
&#13;
if check_if_root; then&#13;
  echo "User is root!"&#13;
else&#13;
  echo "User is not root!"&#13;
fi&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-11: An if condition to test whether a function returned true or false</span></p>&#13;
<p class="TX">We define the <span class="SANS_TheSansMonoCd_W5Regular_11">check_if_root()</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Within this function, we use an <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> condition with an integer comparison test <span class="CodeAnnotation" aria-label="annotation2">❷</span>, accessing the environment variable <span class="SANS_TheSansMonoCd_W5Regular_11">EUID</span> to get the effective running user’s ID and checking whether it equals 0. If so, the user is root, and the function returns 0; if not, it returns 1. Next, we call the <span class="SANS_TheSansMonoCd_W5Regular_11">check_if_root</span> function and check if it returned 0, which means the user is root. Otherwise, we print that the user is not root.</p>&#13;
<p class="TX">Bash scripts that perform privileged actions often check whether the user is root before attempting to install software, create users, delete groups, and so on. Attempting to perform privileged actions on Linux without the necessary privileges will result in errors, so this check helps handle these cases.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H2" id="sec8"><span id="h2-23"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accepting Arguments</span></h3>&#13;
<p class="TNI1">In <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, we covered the passing of arguments to commands on the command line. Functions can also take arguments by using the same syntax. For example, the function in <a href="chapter2.xhtml#Lis2-12">Listing 2-12</a> prints the first three arguments it receives.</p>&#13;
<span id="Lis2-12"/><pre><code>#!/bin/bash&#13;
&#13;
print_args(){&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_35" aria-label="35"/>  echo "first: ${1}, second: ${2}, third: ${3}"&#13;
}&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> <span class="SANS_TheSansMonoCd_W5Regular_11">print_args No Starch Press</span>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-12: A function with arguments</span></p>&#13;
<p class="TX">To call a function with arguments, enter its name and the arguments separated by spaces <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Save this script as <i>function_with_args.sh</i> and run it:</p>&#13;
<pre><code>$ <b>chmod u+x function_with_args.sh</b>&#13;
$ <b>./function_with_args.sh</b>&#13;
&#13;
first: No, second: Starch, third: Press&#13;
</code></pre>&#13;
<p class="TX">You should see output similar to that shown here.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h2 class="H1" id="sec9"><span id="h1-13"/><span class="SANS_Futura_Std_Bold_B_11">Loops and Loop Controls</span></h2>&#13;
<p class="TNI1">Like many programming languages, bash lets you repeat chunks of code by using <i>loops</i>. Loops can be particularly useful in your penetration-testing adventures because they can help you accomplish tasks such as the following:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Continuously checking whether an IP address is online after a reboot until the IP address is responsive</li>&#13;
<li class="ListBullet">Iterating through a list of hostnames (for example, to run a specific exploit against each of them or determine whether a firewall is protecting them)</li>&#13;
<li class="ListBullet">Testing for a certain condition and then running a loop when it is met (for example, checking whether a host is online and, if so, performing a brute-force attack against it)</li>&#13;
</ul>&#13;
<p class="TX">The following sections introduce you to the three kinds of loops in bash (<span class="SANS_TheSansMonoCd_W5Regular_11">while</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">until</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">for)</span> as well as the <span class="SANS_TheSansMonoCd_W5Regular_11">break</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">continue</span> statements for working with loops.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H2" id="sec10"><span id="h2-24"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">while</span></h3>&#13;
<p class="TNI1">In bash, <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loops allow you to run a code block until a test returns a successful exit status code. You might use them in penetration testing to continuously perform a port scan on a network and pick up any new hosts that join the network, for example.</p>&#13;
<p class="TX"><a href="chapter2.xhtml#Lis2-13">Listing 2-13</a> shows the syntax of a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop.</p>&#13;
<span id="Lis2-13"/><pre><code>while <var>some_condition</var>; do&#13;
  # Run commands while the condition is true.&#13;
done&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-13: A while loop</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_36" aria-label="36"/>This loop starts with the keyword <span class="SANS_TheSansMonoCd_W5Regular_11">while</span>, followed by an expression that describes the condition. We then surround the code to be executed with the <span class="SANS_TheSansMonoCd_W5Regular_11">do</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">done</span> keywords, which define the start and end of the code block.</p>&#13;
<p class="TX">You can use <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loops to run a chunk of code infinitely by using <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> as the condition; because <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> always returns a successful exit code, the code will always run. Let’s use a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop to repeatedly print a command to the screen. Save <a href="chapter2.xhtml#Lis2-14">Listing 2-14</a> to a file named <i>basic_while.sh</i> and run it.</p>&#13;
<span id="Lis2-14"/><pre><code>#!/bin/bash&#13;
&#13;
while true; do&#13;
  echo "Looping..."&#13;
  sleep 2&#13;
done&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-14: Repeatedly running a command at two-second intervals</span></p>&#13;
<p class="TX">You should see the following output:</p>&#13;
<pre><code>$ <b>chmod u+x basic_while.sh</b>&#13;
$ <b>./basic_while.sh</b>&#13;
&#13;
Looping...&#13;
Looping...&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">Next, let’s write a more sophisticated <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop that runs until it finds a specific file on the filesystem (<a href="chapter2.xhtml#Lis2-15">Listing 2-15</a>). Use <small>CTRL</small>-C to stop the code from executing at any point.</p>&#13;
<span id="Lis2-15"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">while_loop.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> SIGNAL_TO_STOP_FILE="stoploop"&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> while [[! -f "${SIGNAL_TO_STOP_FILE}"]]; do&#13;
  echo "The file ${SIGNAL_TO_STOP_FILE} does not yet exist..."&#13;
  echo "Checking again in 2 seconds..."&#13;
  sleep 2&#13;
done&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> <span class="SANS_TheSansMonoCd_W5Regular_11">echo "File was found! Exiting..."</span>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-15: File monitoring</span></p>&#13;
<p class="TX">At <span class="CodeAnnotation" aria-label="annotation1">❶</span>, we define a variable representing the name of the file for which the <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop <span class="CodeAnnotation" aria-label="annotation2">❷</span> checks, using a file test operator. The loop won’t exit until the condition is satisfied. Once the file is available, the loop will stop, and the script will continue to the <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Save this file as <i>while_loop.sh</i> and run it:</p>&#13;
<pre><code>$ <b>chmod u+x while_loop.sh</b>&#13;
$ <b>./while_loop.sh</b>&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_37" aria-label="37"/>The file stoploop does not yet exist...&#13;
Checking again in 2 seconds...&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">While the script is running, open a second terminal in the same directory as the script and create the <i>stoploop</i> file:</p>&#13;
<pre><code>$ <b>touch stoploop</b></code></pre>&#13;
<p class="TX">Once you’ve done so, you should see the script break out of the loop and print the following:</p>&#13;
<pre><code>File was found! Exiting...</code></pre>&#13;
<p class="TX">We can use <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loops to monitor for filesystem events, such as file creations or deletions, or when a process starts. This may come in handy if an application is suffering from a vulnerability we can only temporarily abuse. For example, consider an application that runs daily at a particular hour and checks whether the file <i>/tmp/update.sh</i> exists; if it does, the application executes it as the <i>root</i> user. Using a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop, we can monitor when that application has started and then create the file just in time so our commands are executed by that application.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H2" id="sec11"><span id="h2-25"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">until</span></h3>&#13;
<p class="TNI1">Whereas <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> runs so long as the condition succeeds, <span class="SANS_TheSansMonoCd_W5Regular_11">until</span> runs so long as it fails. <a href="chapter2.xhtml#Lis2-16">Listing 2-16</a> shows the <span class="SANS_TheSansMonoCd_W5Regular_11">until</span> loop syntax.</p>&#13;
<span id="Lis2-16"/><pre><code>until <var>some_condition</var>; do&#13;
  # Run some commands until the condition is no longer false.&#13;
done&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-16: An until loop</span></p>&#13;
<p class="TX"><a href="chapter2.xhtml#Lis2-17">Listing 2-17</a> uses <span class="SANS_TheSansMonoCd_W5Regular_11">until</span> to run some commands until a file’s size is greater than zero (meaning it is not empty).</p>&#13;
<span id="Lis2-17"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">until_loop.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
FILE="output.txt"&#13;
&#13;
touch "${FILE}"&#13;
until [[-s "${FILE}"]]; do&#13;
  echo "${FILE} is empty..."&#13;
  echo "Checking again in 2 seconds..."&#13;
  sleep 2&#13;
done&#13;
&#13;
echo "${FILE} appears to have some content in it!"&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-17: Checking a file’s size</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_38" aria-label="38"/>We first create an empty file, then begin a loop that runs until the file is no longer empty. Within the loop, we print messages to the terminal. Save this file as <i>until_loop.sh</i> and run it:</p>&#13;
<pre><code>$ <b>chmod u+x until_loop.sh</b>&#13;
$ <b>./until_loop.sh</b>&#13;
&#13;
output.txt is empty...&#13;
Checking again in 2 seconds...&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">At this point, the script has created the file <i>output.txt</i>, but it’s an empty file. We can check this by using the <span class="SANS_TheSansMonoCd_W5Regular_11">du</span> (disk usage) command:</p>&#13;
<pre><code>$ <b>du -sb output.txt</b>&#13;
0       output.txt&#13;
</code></pre>&#13;
<p class="TX">Open another terminal and navigate to the location at which your script is saved, then append some content to the file so its size is no longer zero:</p>&#13;
<pre><code>$ <b>echo "until_loop_will_now_stop!" &gt; output.txt</b></code></pre>&#13;
<p class="TX">The script should exit the loop, and you should see it print the following:</p>&#13;
<pre><code>output.txt appears to have some content in it!</code></pre>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H2" id="sec12"><span id="h2-26"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">for</span></h3>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop iterates over a <i>sequence</i>, such as a list of filenames or variables, or even a group of values generated by running a command. Inside the <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop, we define a block of commands that are run against each value in the list, and each value in the list is assigned to a variable name we define.</p>&#13;
<p class="TX"><a href="chapter2.xhtml#Lis2-18">Listing 2-18</a> shows the syntax of a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop.</p>&#13;
<span id="Lis2-18"/><pre><code>for <var>variable_name</var> in <var>LIST</var>; do&#13;
  # Run some commands for each item in the sequence.&#13;
done&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-18: A for loop</span></p>&#13;
<p class="TX">A simple way to use a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop is to execute the same command multiple times. For example, <a href="chapter2.xhtml#Lis2-19">Listing 2-19</a> prints the numbers 1 through 10.</p>&#13;
<span id="Lis2-19"/><pre><code>#!/bin/bash&#13;
&#13;
for index in $(seq 1 10); do&#13;
  echo "${index}"&#13;
done&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-19: Counting to 10 in a for loop</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_39" aria-label="39"/>Save and run this script. You should see the following output:</p>&#13;
<pre><code>1&#13;
2&#13;
3&#13;
4&#13;
5&#13;
6&#13;
7&#13;
8&#13;
9&#13;
10&#13;
</code></pre>&#13;
<p class="TX">A more practical example might use a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop to run commands against a bunch of IP addresses passed on the command line. <a href="chapter2.xhtml#Lis2-20">Listing 2-20</a> retrieves all arguments passed to the script, then iterates through them and prints a message for each.</p>&#13;
<span id="Lis2-20"/><pre><code>#!/bin/bash&#13;
&#13;
for ip_address in "$@"; do&#13;
  echo "Taking some action on IP address ${ip_address}"&#13;
done&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-20: Iterating through command line arguments</span></p>&#13;
<p class="TX">Save this script as <i>for_loop_arguments.sh</i> and run it as follows:</p>&#13;
<pre><code>$ <b>chmod u+x for_loop_arguments.sh</b>&#13;
$ <b>./for_loop_arguments.sh 10.0.0.1 10.0.0.2 192.168.1.1 192.168.1.2</b>&#13;
&#13;
Taking some action on IP address 10.0.0.1&#13;
Taking some action on IP address 10.0.0.2&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">We can even run a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop on the output of commands such as <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span>. In <a href="chapter2.xhtml#Lis2-21">Listing 2-21</a>, we print the names of all files in the current working directory.</p>&#13;
<span id="Lis2-21"/><pre><code>#!/bin/bash&#13;
&#13;
for file in $(ls .); do&#13;
  echo "File: ${file}"&#13;
done&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-21: Iterating through files in the current directory</span></p>&#13;
<p class="TX">We use a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop to iterate over the output of the <span class="SANS_TheSansMonoCd_W5Regular_11">ls .</span> command, which lists the files in the current directory. Each file will be assigned to the <span class="SANS_TheSansMonoCd_W5Regular_11">file</span> variable as part of the <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop, so we can then use <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> to print its name. This technique would be useful, for example, if we wanted to perform an upload of all files in the directory or even rename them in bulk.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h3 class="H2" id="sec13"><span id="h2-27"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_40" aria-label="40"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">break and continue</span></h3>&#13;
<p class="TNI1">Loops can run forever or until a condition is met. But we can also exit a loop at any point by using the <span class="SANS_TheSansMonoCd_W5Regular_11">break</span> keyword. This keyword provides an alternative to the <span class="SANS_TheSansMonoCd_W5Regular_11">exit</span> command, which would cause the entire script, not just the loop, to exit. Using <span class="SANS_TheSansMonoCd_W5Regular_11">break</span>, we can leave the loop and advance to the next code block (<a href="chapter2.xhtml#Lis2-22">Listing 2-22</a>).</p>&#13;
<span id="Lis2-22"/><pre><code>#!/bin/bash&#13;
&#13;
while true; do&#13;
  echo "in the loop"&#13;
  break&#13;
done&#13;
&#13;
echo "This code block will be reached."&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-22: Breaking from a loop</span></p>&#13;
<p class="TX">In this case, the last <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command will be executed.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">continue</span> statement is used to jump to the next iteration of a loop. We can use it to skip a certain value in a sequence. To illustrate this, let’s create three empty files so we can iterate through them:</p>&#13;
<pre><code>$ <b>touch example_file1 example_file2 example_file3</b></code></pre>&#13;
<p class="TX">Next, our <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop will write content to each file, excluding the first one, <i>example_file1</i>, which the loop will leave empty (<a href="chapter2.xhtml#Lis2-23">Listing 2-23</a>).</p>&#13;
<span id="Lis2-23"/><pre><code>#!/bin/bash&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> for file in example_file*; do&#13;
  if [["${file}" == "example_file1"]]; then&#13;
    echo "Skipping the first file"&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> continue&#13;
  fi&#13;
&#13;
  echo "${RANDOM}" &gt; "${file}"&#13;
done&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-23: Skipping an element in a for loop</span></p>&#13;
<p class="TX">We start a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop with the <span class="SANS_TheSansMonoCd_W5Regular_11">example_file*</span> glob, which will expand to match the names of all files starting with <i>example_file</i> in the directory where the script runs <span class="CodeAnnotation" aria-label="annotation1">❶</span>. As a result, the loop should iterate over all three files we created earlier. Within the loop, we use string comparison to check whether the filename is equal to <i>example_file1</i> because we want to skip this file and not make any changes to it. If the condition is met, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">continue</span> statement <span class="CodeAnnotation" aria-label="annotation2">❷</span> to proceed to the next iteration, leaving the file unmodified. Later in the loop, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> command with the environment variable <span class="SANS_TheSansMonoCd_W5Regular_11">${RANDOM}</span> to generate a random number and write it into the file.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_41" aria-label="41"/>Save this script as <i>for_loop_continue.sh</i> and execute it in the same directory as the three files:</p>&#13;
<pre><code>$ <b>chmod u+x for_loop_continue.sh</b>&#13;
$ <b>./for_loop_continue.sh</b>&#13;
&#13;
Skipping the first file&#13;
</code></pre>&#13;
<p class="TX">If you examine the files, you should see that the first file is empty, while the other two contain a random number as a result of the script echoing the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">${RANDOM}</span> environment variable into them.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h2 class="H1" id="sec14"><span id="h1-14"/><span class="SANS_Futura_Std_Bold_B_11">case Statements</span></h2>&#13;
<p class="TNI1">In bash, <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> statements allow you to test multiple conditions in a cleaner way by using more readable syntax. Often, they help you avoid many <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> conditions, which can become harder to read as they grow in size.</p>&#13;
<p class="TX"><a href="chapter2.xhtml#Lis2-24">Listing 2-24</a> shows the <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> statement syntax.</p>&#13;
<span id="Lis2-24"/><pre><code>case <var>EXPRESSION</var> in&#13;
  <var>PATTERN1</var>)&#13;
    # Do something if the first condition is met.&#13;
  ;;&#13;
  <var>PATTERN2</var>)&#13;
    # Do something if the second condition is met.&#13;
  ;;&#13;
esac&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-24: A case statement</span></p>&#13;
<p class="TX">A <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> statement starts with the keyword <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> followed by an expression, such as a variable you want to match a pattern against. <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PATTERN1</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PATTERN2</span> in this example represent a pattern case (such as a regular expression, a string, or an integer) that you want to compare to the expression. To close a case statement, you use the keyword <span class="SANS_TheSansMonoCd_W5Regular_11">esac</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">case</span> inverted).</p>&#13;
<p class="TX">Let’s take a look at an example <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> statement that checks whether an IP address is present in a specific private network (<a href="chapter2.xhtml#Lis2-25">Listing 2-25</a>).</p>&#13;
<span id="Lis2-25"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">case_ip_address _check.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
IP_ADDRESS="${1}"&#13;
&#13;
case ${IP_ADDRESS} in&#13;
  192.168.*)&#13;
    echo "Network is 192.168.x.x"&#13;
  ;;&#13;
  10.0.*)&#13;
    echo "Network is 10.0.x.x"&#13;
  ;;&#13;
  *)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_42" aria-label="42"/>    echo "Could not identify the network"&#13;
  ;;&#13;
esac&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-25: Checking an IP address and determining its network</span></p>&#13;
<p class="TX">We define a variable that expects one command line argument to be passed (<span class="SANS_TheSansMonoCd_W5Regular_11">${1}</span>) and saves it to the <span class="SANS_TheSansMonoCd_W5Regular_11">IP_ADDRESS</span> variable. We then use a pattern to check whether the <span class="SANS_TheSansMonoCd_W5Regular_11">IP_ADDRESS</span> variable starts with <span class="SANS_TheSansMonoCd_W5Regular_11">192.168.</span> and a second pattern to check whether it starts with <span class="SANS_TheSansMonoCd_W5Regular_11">10.0.</span></p>&#13;
<p class="TX">We also define a default wildcard pattern using <span class="SANS_TheSansMonoCd_W5Regular_11">*</span>, which returns a default message to the user if nothing else has matched.</p>&#13;
<p class="TX">Save this file as <i>case_ip_address_check.sh</i> and run it:</p>&#13;
<pre><code>$ <b>chmod u+x case_ip_address_check.sh</b>&#13;
$ <b>./case_ip_address_check.sh 192.168.12.55</b>&#13;
Network is 192.168.x.x&#13;
&#13;
$ <b>./case_ip_address_check.sh 212.199.2.2</b>&#13;
Could not identify the network&#13;
</code></pre>&#13;
<p class="TX">A <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> statement can be used for a variety of use cases. For example, it can be used to run functions based on input the user has entered. Using <span class="SANS_TheSansMonoCd_W5Regular_11">case</span> statements is a great way to handle the evaluation of multiple conditions without sacrificing the readability of the code.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h2 class="H1" id="sec15"><span id="h1-15"/><span class="SANS_Futura_Std_Bold_B_11">Text Processing and Parsing</span></h2>&#13;
<p class="TNI1">One of the most common things you’ll find yourself doing in bash is processing text. You can parse text on the command line by running one-off commands, or use a script to store parsed data in a variable that you can act on in some way. Both approaches are important to many scenarios.</p>&#13;
<p class="TX">To test the commands in this section on your own, download the sample logfile from <i><a href="https://github.com/dolevf/Black-Hat-Bash/blob/master/ch02/log.txt">https://github.com/dolevf/Black-Hat-Bash/blob/master/ch02/log.txt</a></i>. This file is space-separated, and each segment represents a specific data type, such as the client’s source IP address, timestamp, HyperText Transfer Protocol (HTTP) method, HTTP path, HTTP User Agent field, HTTP status code, and more.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h3 class="H2" id="sec16"><span id="h2-28"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Filtering with grep</span></h3>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> command is one of the most popular Linux commands out there today. We use <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> to filter out information of interest from streams. At its most basic form, we can use it as shown in <a href="chapter2.xhtml#Lis2-26">Listing 2-26</a>.</p>&#13;
<span id="Lis2-26"/><pre><code>$ <b>grep "35.237.4.214" log.txt</b></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-26: Filtering for a specific string from a file</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_43" aria-label="43"/>This <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> command will read the file and extract any lines containing the IP address 35.237.4.214 from it.</p>&#13;
<p class="TX">We can even use <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> for multiple patterns simultaneously. The following backslash pipe (<span class="SANS_TheSansMonoCd_W5Regular_11">\|</span>) acts as an OR condition:</p>&#13;
<pre><code>$ <b>grep "35.237.4.214\|13.66.139.0" log.txt</b></code></pre>&#13;
<p class="TX">Alternatively, we could use multiple <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> patterns with the <span class="SANS_TheSansMonoCd_W5Regular_11">-e</span> argument to accomplish the same thing:</p>&#13;
<pre><code>$ <b>grep -e "35.237.4.214" -e "13.66.139.0" log.txt</b></code></pre>&#13;
<p class="TX">As you learned in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, we can use the pipe (<span class="SANS_TheSansMonoCd_W5Regular_11">|</span>) command to provide one command’s output as the input to another. In the following example, we run the <span class="SANS_TheSansMonoCd_W5Regular_11">ps</span> command and use <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> to filter out a specific line. The <span class="SANS_TheSansMonoCd_W5Regular_11">ps</span> command lists the processes on the system:</p>&#13;
<pre><code>$ <b>ps | grep TTY</b></code></pre>&#13;
<p class="TX">By default, <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> is case sensitive. We can make our search case insensitive by using the <span class="SANS_TheSansMonoCd_W5Regular_11">-i</span> flag:</p>&#13;
<pre><code>$ <b>ps | grep -i tty</b></code></pre>&#13;
<p class="TX">We can also use <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> with the <span class="SANS_TheSansMonoCd_W5Regular_11">-v</span> argument to exclude lines containing a certain pattern:</p>&#13;
<pre><code>$ <b>grep -v "35.237.4.214" log.txt</b></code></pre>&#13;
<p class="TX">To print only the matched pattern, and not the entire line at which the matched pattern was found, use <span class="SANS_TheSansMonoCd_W5Regular_11">-o</span>:</p>&#13;
<pre><code>$ <b>grep -o "35.237.4.214" log.txt</b></code></pre>&#13;
<p class="TX">The command also supports regular expressions, anchoring, grouping, and much more. Use the <span class="SANS_TheSansMonoCd_W5Regular_11">man grep</span> command to read more about its capabilities.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h3 class="H2" id="sec17"><span id="h2-29"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Filtering with awk</span></h3>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> command is a data processing and extraction Swiss Army knife. You can use it to identify and return specific fields from a file. To see how <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> works, take another close look at our logfile. What if we need to print just the IP addresses from this file? This is easy to do with <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span>:</p>&#13;
<pre><code>$ <b>awk '{print $1}' log.txt</b></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">$1</span> represents the first field of every line in the file where the IP addresses are. By default, <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> treats spaces or tabs as separators or delimiters.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_44" aria-label="44"/>Using the same syntax, we can print additional fields, such as the timestamps. The following command filters the first three fields of every line in the file:</p>&#13;
<pre><code>$ <b>awk '{print $1,$2,$3}' log.txt</b></code></pre>&#13;
<p class="TX">Using similar syntax, we can print the first and last field simultaneously. In this case, <span class="SANS_TheSansMonoCd_W5Regular_11">NF</span> represents the last field:</p>&#13;
<pre><code>$ <b>awk '{print $1,$NF}' log.txt</b></code></pre>&#13;
<p class="TX">We can also change the default delimiter. For example, if we had a file separated by commas (that is, a CSV, or comma-separated values file), rather than by spaces or tabs, we could pass <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> the <span class="SANS_TheSansMonoCd_W5Regular_11">-F</span> flag to specify the type of delimiter:</p>&#13;
<pre><code>$ <b>awk -F',' '{print $1}' example_csv.txt</b></code></pre>&#13;
<p class="TX">We can even use <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> to print the first 10 lines of a file. This emulates the behavior of the <span class="SANS_TheSansMonoCd_W5Regular_11">head</span> Linux command; <span class="SANS_TheSansMonoCd_W5Regular_11">NR</span> represents the total number of records and is built into <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span>:</p>&#13;
<pre><code>$ <b>awk 'NR &lt; 10' log.txt</b></code></pre>&#13;
<p class="TX">You’ll often find it useful to combine <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span>. For example, you might want to first find the lines in a file containing the IP address 42.236.10.117 and then print the HTTP paths requested by this IP:</p>&#13;
<pre><code>$ <b>grep "42.236.10.117" log.txt | awk '{print $7}'</b></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> command is a superpowerful tool, and we encourage you to dig deeper into its capabilities by running <span class="SANS_TheSansMonoCd_W5Regular_11">man awk</span> for more information.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h3 class="H2" id="sec18"><span id="h2-30"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Editing Streams with sed</span></h3>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">sed</span> (stream editor) command takes actions on text. For example, it can replace the text in a file, modify the text in a command’s output, and even delete selected lines from files.</p>&#13;
<p class="TX">Let’s use <span class="SANS_TheSansMonoCd_W5Regular_11">sed</span> to replace any mentions of the word <i>Mozilla</i> with the word <i>Godzilla</i> in the <i>log.txt</i> file. We use its <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> (substitution) command and <span class="SANS_TheSansMonoCd_W5Regular_11">g</span> (global) command to make the substitution across the whole file, rather than to just the first occurrence:</p>&#13;
<pre><code>$ <b>sed 's/Mozilla/Godzilla/g' log.txt</b></code></pre>&#13;
<p class="TX">This will output the modified version of the file but won’t change the original version. You can redirect the output to a new file to save your changes:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_45" aria-label="45"/>$ <b>sed 's/Mozilla/Godzilla/g' log.txt &gt; newlog.txt</b></code></pre>&#13;
<p class="TX">We could also use <span class="SANS_TheSansMonoCd_W5Regular_11">sed</span> to remove any whitespace from the file with the <span class="SANS_TheSansMonoCd_W5Regular_11">/ //</span> syntax, which will replace whitespace with nothing, removing it from the output altogether:</p>&#13;
<pre><code>$ <b>sed 's/ //g' log.txt</b></code></pre>&#13;
<p class="TX">If you need to delete lines of a file, use the <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> command. In the following command, <span class="SANS_TheSansMonoCd_W5Regular_11">1d</span> deletes (<span class="SANS_TheSansMonoCd_W5Regular_11">d</span>) the first line (<span class="SANS_TheSansMonoCd_W5Regular_11">1</span>):</p>&#13;
<pre><code>$ <b>sed '1d' log.txt</b></code></pre>&#13;
<p class="TX">To delete the last line of a file, use the dollar sign (<span class="SANS_TheSansMonoCd_W5Regular_11">$</span>), which represents the last line, along with <span class="SANS_TheSansMonoCd_W5Regular_11">d</span>:</p>&#13;
<pre><code>$ <b>sed '$d' log.txt</b></code></pre>&#13;
<p class="TX">You can also delete multiple lines, such as lines 5 and 7:</p>&#13;
<pre><code>$ <b>sed '5,7d' log.txt</b></code></pre>&#13;
<p class="TX">Finally, you can print (<span class="SANS_TheSansMonoCd_W5Regular_11">p</span>) specific line ranges, such as lines 2 through 15:</p>&#13;
<pre><code>$ <b>sed -n '2,15 p' log.txt</b></code></pre>&#13;
<p class="TX">When you pass <span class="SANS_TheSansMonoCd_W5Regular_11">sed</span> the <span class="SANS_TheSansMonoCd_W5Regular_11">-i</span> argument, it will make the changes to the file itself rather than create a modified copy:</p>&#13;
<pre><code>$ <b>sed -i '1d' log.txt</b></code></pre>&#13;
<p class="TX">This rich utility can do a whole lot more. Use the <span class="SANS_TheSansMonoCd_W7Bold_B_11">man sed</span> command to find additional ways to use <span class="SANS_TheSansMonoCd_W5Regular_11">sed</span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h2 class="H1" id="sec19"><span id="h1-16"/><span class="SANS_Futura_Std_Bold_B_11">Job Control</span></h2>&#13;
<p class="TNI1">As you become proficient in bash, you’ll start to build complex scripts that take an hour to complete or must run continuously. Not all scripts need to execute in the foreground, blocking execution of other commands. Instead, you may want to run certain scripts as background jobs, either because they take a while to complete or because their runtime output isn’t interesting and you care about only the end result.</p>&#13;
<p class="TX">Commands that you run in a terminal occupy that terminal until the command is finished. These commands are considered <i>foreground jobs</i>. In <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, we used the ampersand character (<span class="SANS_TheSansMonoCd_W5Regular_11">&amp;</span>) to send a command to the background. This command then becomes a <i>background job</i> that allows us to unblock the execution of other commands.</p>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h3 class="H2" id="sec20"><span id="h2-31"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_46" aria-label="46"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Managing the Background and Foreground</span></h3>&#13;
<p class="TNI1">To practice working with background and foreground jobs, let’s run a command directly in the terminal and send it to the background:</p>&#13;
<pre><code>$ <b>sleep 100 &amp;</b></code></pre>&#13;
<p class="TX">Notice that we can continue working on the terminal while this <span class="SANS_TheSansMonoCd_W5Regular_11">sleep</span> command runs for 100 seconds. We can verify that the spawned process is running by using the <span class="SANS_TheSansMonoCd_W5Regular_11">ps</span> command:</p>&#13;
<pre><code>$ <b>ps -ef | grep sleep</b>&#13;
&#13;
user    1827    1752 cons0    19:02:29 /usr/bin/sleep&#13;
</code></pre>&#13;
<p class="TX">Now that this job is in the background, we can use the <span class="SANS_TheSansMonoCd_W5Regular_11">jobs</span> command to see what jobs are currently running:</p>&#13;
<pre><code>$ <b>jobs</b>&#13;
&#13;
[1]+  Running                 sleep 100 &amp;&#13;
</code></pre>&#13;
<p class="TX">The output shows that the <span class="SANS_TheSansMonoCd_W5Regular_11">sleep</span> command is in <span class="SANS_TheSansMonoCd_W5Regular_11">Running</span> state and that its job ID is <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>.</p>&#13;
<p class="TX">We can migrate the job from the background to the foreground by issuing the <span class="SANS_TheSansMonoCd_W5Regular_11">fg</span> command and the job ID:</p>&#13;
<pre><code>$ <b>fg %1</b>&#13;
&#13;
sleep 100&#13;
</code></pre>&#13;
<p class="TX">At this point, the <span class="SANS_TheSansMonoCd_W5Regular_11">sleep</span> command is occupying the terminal, since it’s running in the foreground. You can press <small>CTRL</small>-Z to suspend the process, which will produce the following output in the <span class="SANS_TheSansMonoCd_W5Regular_11">jobs</span> table:</p>&#13;
<pre><code>[1]+  Stopped                 sleep 100</code></pre>&#13;
<p class="TX">To send this job to the background again in a running state, use the <span class="SANS_TheSansMonoCd_W7Bold_B_11">bg</span> command with the job ID:</p>&#13;
<pre><code>$ <b>bg %1</b>&#13;
&#13;
[1]+ sleep 100 &amp;&#13;
</code></pre>&#13;
<p class="TX">Here, we supply the job ID of <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h3 class="H2" id="sec21"><span id="h2-32"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Keeping Jobs Running After Logout</span></h3>&#13;
<p class="TNI1">Whether you send a job to the background or are running a job in the foreground, the process won’t survive if you close the terminal or log out. If you close the terminal, the process will receive a <span class="SANS_TheSansMonoCd_W5Regular_11">SIGHUP</span> signal and terminate.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_47" aria-label="47"/>What if we want to keep running a script in the background even after we’ve logged out of the terminal window or closed it? To do so, we could start a script or command with the <span class="SANS_TheSansMonoCd_W5Regular_11">nohup</span> (no hangup) command prepended:</p>&#13;
<pre><code>$ <b>nohup ./my_script.sh &amp;</b></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">nohup</span> command will create a file named <i>nohup.out</i> with standard output stream data. Make sure you delete this file if you don’t want it on the filesystem.</p>&#13;
<p class="TX">There are additional ways to run background scripts, such as by plugging into system and service managers like <i>systemd</i>. These managers provide additional features, such as monitoring that the process is running, restarting it if it isn’t, and capturing failures. We encourage you to read more about systemd at <i><a href="https://man7.org/linux/man-pages/man1/init.1.html">https://man7.org/linux/man-pages/man1/init.1.html</a></i> if you have such use cases.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h2 class="H1" id="sec22"><span id="h1-17"/><span class="SANS_Futura_Std_Bold_B_11">Bash Customizations for Penetration Testers</span></h2>&#13;
<p class="TNI1">As penetration testers, we often follow standard workflows for all ethical hacking engagements, whether they are consulting work, bug bounty hunting, or red teaming. We can optimize some of this work with a few bash tips and tricks.</p>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h3 class="H2" id="sec23"><span id="h2-33"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Placing Scripts in Searchable Paths</span></h3>&#13;
<p class="TNI1">Bash searches for programs within directories defined by the <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span> environment variable. Commands such as <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> are always available to you because system and user binaries are located in directories that are part of the <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span>.</p>&#13;
<p class="TX">To see your <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span>, run this command:</p>&#13;
<pre><code>$ <b>echo $PATH</b>&#13;
&#13;
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&#13;
</code></pre>&#13;
<p class="TX">The output might look different, depending on your operating system.</p>&#13;
<p class="TX">When you write a bash script, place it in a directory such as <i>/usr/local/bin</i>, which, as you can see, is part of the <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span>. If you don’t do this, you have a few other options available:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Call the script directly, using the full path.</li>&#13;
<li class="ListBullet">Change the directory to the one in which your script lives and execute it from there.</li>&#13;
<li class="ListBullet">Use aliases (shown in the next section).</li>&#13;
<li class="ListBullet">Add paths to the <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span> environment variable.</li>&#13;
</ul>&#13;
<p class="TX">The benefit of placing the script in a searchable path is that you can simply call it by its name. You don’t have to provide the full path or have the terminal be in the same directory.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h3 class="H2" id="sec24"><span id="h2-34"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_48" aria-label="48"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Shortening Commands with Aliases</span></h3>&#13;
<p class="TNI1">When you find yourself frequently using a long Linux command, you can use an <i>alias</i> to map the command to a shorter custom name that will save you time when you need to run it.</p>&#13;
<p class="TX">For example, imagine that you often use Nmap (discussed in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>) with special parameters to scan for all 65,535 ports on a given IP address:</p>&#13;
<pre><code>nmap -vv -T4 -p- -sV --max-retries 5 localhost</code></pre>&#13;
<p class="TX">This command is quite hard to remember. With aliases, we can make it more accessible on the command line or to our scripts. Here, we assign the command to the alias <span class="SANS_TheSansMonoCd_W5Regular_11">quicknmap</span>:</p>&#13;
<pre><code>$ <b>alias quicknmap="nmap -vv -T4 -p- -sV --max-retries 5 localhost"</b></code></pre>&#13;
<p class="TX">Now we can run the aliased command by using the name of the alias:</p>&#13;
<pre><code>$<b> quicknmap</b>&#13;
Starting Nmap (https://nmap.org) at 02-21 22:32 EST&#13;
<var>--snip--</var>&#13;
PORT    STATE SERVICE&#13;
631/tcp open  ipp&#13;
</code></pre>&#13;
<p class="TX">You can even assign an alias to your own scripts:</p>&#13;
<pre><code>$ <b>alias helloworld="bash ~/scripts/helloworld.sh"</b></code></pre>&#13;
<p class="TX">Aliases aren’t permanent, but they can be. In the next section, you’ll learn how to use bash profiles to make permanent changes to your shell.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<h3 class="H2" id="sec25"><span id="h2-35"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Customizing the ~/.bashrc Profile</span></h3>&#13;
<p class="TNI1">We can use the <i>~/.bashrc</i> file to load functions, variables, and just about any other custom bash code we desire into a new bash session. For example, we can create variables containing information we’ll frequently need to access, such as the IP address of a vulnerable host we’re testing.</p>&#13;
<p class="TX">We could append the following to the end of the <i>~/.bashrc</i> file, for instance. These lines define a few custom variables and save our aliased Nmap command:</p>&#13;
<pre><code>VULN_HOST=1.0.0.22&#13;
VULN_ROUTER=10.0.0.254&#13;
&#13;
alias quicknmap="nmap -vv -T4 -p- -sV --max-retries 5 localhost"&#13;
</code></pre>&#13;
<p class="TX">The next time you open a terminal, you’ll be able to access these values. Make these new values available immediately by using the <span class="SANS_TheSansMonoCd_W5Regular_11">source</span> command to reimport the <i>~/.bashrc</i> file:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_49" aria-label="49"/>$ <b>source ~/.bashrc</b>&#13;
&#13;
$ <b>echo ${VULN_HOST}</b>&#13;
10.0.0.22&#13;
&#13;
$ <b>echo ${VULN_ROUTER}</b>&#13;
10.0.0.254&#13;
</code></pre>&#13;
<p class="TX">Now you can use these variables even after you close the terminal and start a new session.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<h3 class="H2" id="sec26"><span id="h2-36"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Importing Custom Scripts</span></h3>&#13;
<p class="TNI1">Another way to introduce changes to your bash session is to create a dedicated script that contains pentesting-related customizations and then have the <i>~/.bashrc</i> file import it by using the <span class="SANS_TheSansMonoCd_W5Regular_11">source</span> command. To achieve this, create a <i>~/.pentest.sh</i> file containing your new logic and then make a one-time modification to <i>~/.bashrc</i> to import <i>pentest.sh</i> at the end of the file:</p>&#13;
<pre><code>source ~/.pentest.sh</code></pre>&#13;
<p class="TX">Note that you can also source a bash file by using the <span class="SANS_TheSansMonoCd_W5Regular_11">.</span> (dot) command:</p>&#13;
<pre><code>. ~/.pentest.sh</code></pre>&#13;
<p class="TX">This command provides an alternative to <span class="SANS_TheSansMonoCd_W5Regular_11">source</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<h3 class="H2" id="sec27"><span id="h2-37"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Capturing Terminal Session Activity</span></h3>&#13;
<p class="TNI1">Penetration testing often involves having dozens of terminals open simultaneously, all running many tools that can produce a lot of output. When we find something of interest, we may need some of that output as evidence for later. To avoid losing track of an important piece of information, we can use some clever bash.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">script</span> command allows us to capture terminal session activity. One approach is to load a small bash script that uses <span class="SANS_TheSansMonoCd_W5Regular_11">script</span> to save every session to a file for later inspection. The script might look like <a href="chapter2.xhtml#Lis2-27">Listing 2-27</a>.</p>&#13;
<span id="Lis2-27"/><pre><code>#!/bin/bash&#13;
&#13;
FILENAME=$(date +%m_%d_%Y_%H:%M:%S).log&#13;
&#13;
if [[! -d ~/sessions]]; then&#13;
  mkdir ~/sessions&#13;
fi&#13;
&#13;
# Starting a script session&#13;
if [[-z $SCRIPT]]; then&#13;
  export SCRIPT="/home/kali/sessions/${FILENAME}"&#13;
  script -q -f "${SCRIPT}"&#13;
fi&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 2-27: Saving terminal activity to a file</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_50" aria-label="50"/>Having <i>~/.bashrc</i> load this script, as shown earlier, will result in the creation of the <i>~/sessions</i> directory, containing each terminal session capture in a separate file. The recording stops when you enter <span class="SANS_TheSansMonoCd_W5Regular_11">exit</span> in the terminal or close the terminal window.</p>&#13;
<p class="HeadAExercise"><span id="exe-2"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 2: Pinging a Domain</span></p>&#13;
<p class="TNI1">In this exercise, you’ll write a bash script that accepts two arguments: a name (for example, <i>mysite</i>) and a target domain (for example, <i>nostarch.com</i>). The script should be able to do the following:</p>&#13;
<p class="NLF">  1.  Throw an error if the arguments are missing and exit using the right exit code.</p>&#13;
<p class="NL">  2.  Ping the domain and return an indication of whether the ping was successful. To learn about the <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span> command, run <span class="SANS_TheSansMonoCd_W7Bold_B_11">man ping</span>.</p>&#13;
<p class="NL">  3.  Write the results to a CSV file containing the following information:</p>&#13;
<p class="NLSUB">  a.  The name provided to the script</p>&#13;
<p class="NLSUB">  b.  The target domain provided to the script</p>&#13;
<p class="NLSUB">  c.  The ping result (either success or failure)</p>&#13;
<p class="NLSUB">  d.  The current date and time</p>&#13;
<p class="TX">As with most tasks in bash, there are multiple ways to achieve this goal. You can find an example solution to this exercise, <i>exercise_solution.sh</i>, in the book’s GitHub repository.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
<h2 class="H1" id="sec28"><span id="h1-18"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h2>&#13;
<p class="TNI1">In this chapter, you learned how to perform flow control by using conditions, loops, and functions; how to control scripts by using jobs; and how to search and parse text. We also highlighted bash tips and tricks for building more effective penetration-testing workflows.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>