["```\nHWND myWindow =\n    FindWindow(NULL, \"Title of the game window here\");\nDWORD PID;\nGetWindowThreadProcessId(myWindow, &PID);\n```", "```\n#include <tlhelp32.h>\n\nPROCESSENTRY32 entry;\nentry.dwSize = sizeof(PROCESSENTRY32); \nHANDLE snapshot =\n    CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);\nif (Process32First(snapshot, &entry) == TRUE) {\n    while (Process32Next(snapshot, &entry) == TRUE) {\n        wstring binPath = entry.szExeFile;\n        if (binPath.find(L\"game.exe\") != wstring::npos) {\n            printf(\"game pid is %d\\n\", entry.th32ProcessID);\n            break;\n        }\n    }\n} \nCloseHandle(snapshot);\n```", "```\nHANDLE OpenProcess(DWORD DesiredAccess, BOOL InheritHandle, DWORD ProcessId);\n```", "```\n   DWORD PID = getGamePID();\n   HANDLE process = OpenProcess(\n       PROCESS_VM_OPERATION |\n           PROCESS_VM_READ |\n           PROCESS_VM_WRITE,\n FALSE,\n       PID \n   );\n➊ if (process == INVALID_HANDLE_VALUE) {\n      printf(\"Failed to open PID %d, error code %d\",\n             PID, GetLastError());\n   }\n```", "```\nCloseHandle(process);\n```", "```\nBOOL ReadProcessMemory(\n    HANDLE Process, LPVOID Address,\n    LPVOID Buffer, DWORD Size,\n    DWORD *NumberOfBytesRead \n);\nBOOL WriteProcessMemory(\n    HANDLE Process, LPVOID Address,\n    LPCVOID Buffer, DWORD Size,\n DWORD *NumberOfBytesWritten \n);\n```", "```\nDWORD val;\nReadProcessMemory(proc, adr, &val, sizeof(DWORD), 0);\nprintf(\"Current mem value is %d\\n\", val);\n\nval++;\n\nWriteProcessMemory(proc, adr, &val, sizeof(DWORD), 0);\nReadProcessMemory(proc, adr, &val, sizeof(DWORD), 0);\nprintf(\"New mem value is confirmed as %d\\n\", val);\n```", "```\n template<typename T>\nT readMemory(HANDLE proc, LPVOID adr) {\n    T val;\n    ReadProcessMemory(proc, adr, &val, sizeof(T), NULL);\n    return val;\n}\n\ntemplate<typename T>\nvoid writeMemory(HANDLE proc, LPVOID adr, T val) {\n    WriteProcessMemory(proc, adr, &val, sizeof(T), NULL);\n}\n```", "```\nDWORD value = readMemory<DWORD>(proc, adr); // read\nwriteMemory<DWORD>(proc, adr, value++);     // increment and write\n```", "```\nBOOL VirtualProtectEx(\n    HANDLE Process, LPVOID Address,\n    DWORD Size, DWORD NewProtect,\n    PDWORD OldProtect \n);\n```", "```\ntemplate<typename T>\nDWORD protectMemory(HANDLE proc, LPVOID adr, DWORD prot) {\n    DWORD oldProt;\n    VirtualProtectEx(proc, adr, sizeof(T), prot, &oldProt);\n    return oldProt;\n}\n```", "```\nprotectMemory<DWORD>(process, address, PAGE_READWRITE)\nwriteMemory<DWORD>(process, address, newValue)\n```", "```\nDWORD oldProt =\n    protectMemory<DWORD>(process, address, PAGE_READWRITE);\nwriteMemory<DWORD>(process, address, newValue);\nprotectMemory<DWORD>(process, address, oldProt);\n```", "```\n> editbin /DYNAMICBASE:NO \"C:\\path\\to\\game.exe\"\n```", "```\n> editbin /DYNAMICBASE \"C:\\path\\to\\game.exe\"\n```", "```\nDWORD rebase(DWORD address, DWORD newBase) {\n    DWORD diff = address - 0x400000;\n    return diff + newBase;\n}\n```", "```\nHANDLE CreateRemoteThread(\n    HANDLE Process,\n    LPSECURITY_ATTRIBUTES ThreadAttributes,\n    DWORD StackSize,\n    LPTHREAD_START_ROUTINE StartAddress,\n    LPVOID Param,\n    DWORD CreationFlags,\n    LPDWORD ThreadId \n);\n```", "```\nDWORD newBase;\n\n// get the address of kernel32.dll\nHMODULE k32 = GetModuleHandle(\"kernel32.dll\");\n\n// get the address of GetModuleHandle()\nLPVOID funcAdr = GetProcAddress(k32, \"GetModuleHandleA\");\nif (!funcAdr)\n    funcAdr = GetProcAddress(k32, \"GetModuleHandleW\");\n\n// create the thread\nHANDLE thread =\n    CreateRemoteThread(process, NULL, NULL,\n        (LPTHREAD_START_ROUTINE)funcAdr,\n        NULL, NULL, NULL);\n // let the thread finish\nWaitForSingleObject(thread, INFINITE);\n\n// get the exit code\nGetExitCodeThread(thread, &newBase);\n\n// clean up the thread handle\nCloseHandle(thread);\n```"]