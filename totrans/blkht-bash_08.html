<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch8">&#13;
<hgroup>&#13;
<h1 class="CHAPTER" id="ch8">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_163" aria-label="163"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">8</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">LOCAL INFORMATION GATHERING</span></span>&#13;
</h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="COS">In the previous two chapters, we gained an initial foothold on several hosts. In this chapter, we’ll perform local reconnaissance to identify assets of interest, leaving no stone unturned on the path to taking over other hosts on the network.</p>&#13;
<p class="TX">Knowing where to find sensitive information once you successfully compromise a host is a critical skill. We’ll focus on key categories of information you can gather: identities (like users and groups), files (including logs and configurations), network information, automation workflows, installed software and firmware, running processes, and security mechanisms. We’ll cover other information, such as credentials, in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>, when we discuss privilege escalation techniques.</p>&#13;
<p class="TX">In real-life scenarios, the post-compromise phase is also where your chances of getting caught by defenders increase, as the information you gather could leave a trail. For this reason, we’ll default as much as possible to using native Linux utilities and files to collect information in an attempt <span role="doc-pagebreak" epub:type="pagebreak" id="pg_164" aria-label="164"/>to <i>live off the land</i>: making do with what’s available on a host while avoiding the use of external tools, which could trigger alerts.</p>&#13;
<p class="TX">Try running the shell commands presented in the chapter on all the hosts you’ve compromised thus far, as well as any new machines you compromise as you progress through the book. You could even build a script from these commands to easily execute the same ones on all machines.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h1-55"/><span class="SANS_Futura_Std_Bold_B_11">The Filesystem Hierarchy Standard</span></h2>&#13;
<p class="TNI1">Data of interest could live in many areas of a Linux filesystem. To efficiently explore the systems on which you’ve obtained shell access, consult the <i>Filesystem Hierarchy Standard (FHS)</i>, which describes the structure of directories and their locations on a Linux system. This hierarchical standard makes it easier for users and programs to search for files of interest, such as log or configuration files.</p>&#13;
<p class="TX">The Linux filesystem’s hierarchy starts at the root (<i>/</i>) directory, which is the entry point into the filesystem directory tree structure. <a href="chapter8.xhtml#tab8-1">Table 8-1</a> shows the main subdirectories under root and their primary uses.</p>&#13;
<p class="TT" id="tab8-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</span></span> <span class="SANS_Futura_Std_Book_11">Filesystem Hierarchy Standard Directory Layout</span></p>&#13;
<p class="Anchor"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_165" aria-label="165"/></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Directory</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Primary parent directory, also called the</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">root directory</span><span class="SANS_Futura_Std_Book_11">.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/var</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory for nonstatic (variable) files. Often contains application logfiles under the</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">/var/log</span> <span class="SANS_Futura_Std_Book_11">directory or contains processed tasks, such as scheduled and print jobs, under</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">/var</span><span class="SANS_Futura_Std_Book_Oblique_I_11">/</span><span class="SANS_Futura_Std_Book_Oblique_I_11">spool</span><span class="SANS_Futura_Std_Book_11">. It may also contain cache files in</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">/var/cache</span> <span class="SANS_Futura_Std_Book_11">and system-related runtime data under</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">/var/run</span><span class="SANS_Futura_Std_Book_11">.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/etc</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory for configuration files. Application software installed on the system keeps dedicated configuration files in this directory (usually with the</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">*.conf</span> <span class="SANS_Futura_Std_Book_11">extension). This directory also contains files such as</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/passwd</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/group</span><span class="SANS_Futura_Std_Book_11">, and</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/shadow</span><span class="SANS_Futura_Std_Book_11">, where user accounts, group information, and password hashes, respectively, exist.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/bin</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory for binary utilities. Commonly used for storing binaries related to system tasks such as navigation commands (</span><span class="SANS_TheSansMonoCd_W5Regular_11">cd</span><span class="SANS_Futura_Std_Book_11">), file copying (</span><span class="SANS_TheSansMonoCd_W5Regular_11">cp</span><span class="SANS_Futura_Std_Book_11">), directory creation (</span><span class="SANS_TheSansMonoCd_W5Regular_11">mkdir</span><span class="SANS_Futura_Std_Book_11">), or file creation (</span><span class="SANS_TheSansMonoCd_W5Regular_11">touch</span><span class="SANS_Futura_Std_Book_11">).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/sbin</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory for system binaries, such as system debugging, disk manipulation, and service management utilities that are intended for use by the system administrator.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/dev</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory that represents and provides access to device files, such as disk partitions, thumb drives, and external hard drives.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/boot</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory for bootloaders, kernel files, and initial random-access memory (RAM) disks (initrd).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/home</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory containing the home directory of local system user accounts. Active system user accounts usually have a subdirectory as their assigned home directory.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/root</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory containing the home directory of the root user account.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/tmp</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory for temporarily written files and directories. The</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">/var/tmp</span> <span class="SANS_Futura_Std_Book_11">directory is another temporary directory often used for temporary files.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/proc</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Virtual filesystem for processes and kernel data. Gets automatically created on system boot.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/usr</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory for user binaries, manual pages, kernel sources, header files, and more (including games, in the past).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/run</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory for runtime data. Describes the state of the system since it was last booted.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/opt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory for software applications. Often hosts data related to third-party software installations.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/mnt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory for mounting network shares or other network devices, mostly used for mounting devices to the local filesystem either temporarily or permanently.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/media</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory for removable devices, such as CD drives. Serves as a mount point.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/lib</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">/lib32</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">/lib64</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory for shared libraries needed to boot the system and run commands.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/srv</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory for data commonly served by network services, such as web servers and file</span> <span class="SANS_Futura_Std_Book_11">servers.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Production systems could have thousands of files scattered across their systems, so it’s important to know what sensitive data to search for and where to search for it.</p>&#13;
<p class="TX">While FHS aims to standardize the layout of the filesystem, systems can deviate from the standard. Additionally, the system administrator can store application files wherever they like. For example, nothing stops a system administrator from serving their entire web server content from a directory such as <i>/mywebsite</i> and writing logs to a directory such as <i>/data/logs</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h2 class="H1" id="sec2"><span id="h1-56"/><span class="SANS_Futura_Std_Bold_B_11">The Shell Environment</span></h2>&#13;
<p class="TNI1">From an information-gathering perspective, the shell environment is important because it can reveal information such as where the system looks for executables to run. Custom applications may add new directory paths to the <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span> environment variable so that the application can run custom libraries and executables from nonstandard locations. You might also find credentials and other secrets in these custom configurations.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h2-109"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Environment Variables</span></h3>&#13;
<p class="TNI1">When compromising a host, it’s often useful to dump its environment variables by using the <span class="SANS_TheSansMonoCd_W5Regular_11">env</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">printenv</span> commands. Administrators tend to store credentials in environment variables to avoid writing the credentials to files on disk. Delivery systems can inject credentials into the application’s runtime via these environment variables, which the application then reads. In addition, you may find other important information in environment variables, such as addresses of adjacent servers and runtime configurations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H2" id="sec4"><span id="h2-110"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sensitive Information in Bash Profiles</span></h3>&#13;
<p class="TNI1">In <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, we used the <i>~/.bashrc</i> file and bash aliases to set up shortcuts to commands. System administrators could easily include credentials in shell scripts such as <i>~/.bashrc</i> to avoid having to manually supply credentials on the command line, so always poke around to see if any customizations were <span role="doc-pagebreak" epub:type="pagebreak" id="pg_166" aria-label="166"/>made; you may find credentials or commands used for administration purposes. Here are some common profile files to look for: <i>/etc/profile</i>, <i>/etc/bashrc</i>, <i>~/.bashrc</i>, <i>~/.profile</i>, <i>~/.bash_profile</i>, <i>~/.env</i>, <i>~/.bash_login</i>, and <i>~/.bash_logout</i>.</p>&#13;
<p class="TX">Shells other than bash, such as the Z Shell, can also exist on a system. In these cases, you might want to look at files such as <i>/etc/zprofile</i>, <i>/etc/zshrc</i>, <i>~/.zprofile</i>, and <i>~/.zshrc</i>.</p>&#13;
<p class="TX">Use the <span class="SANS_TheSansMonoCd_W5Regular_11">man</span> command to learn more about the environment and profile files of the various shells. For example, run <span class="SANS_TheSansMonoCd_W5Regular_11">man bash</span> for the bash shell, <span class="SANS_TheSansMonoCd_W5Regular_11">man zsh</span> for the Z Shell, and <span class="SANS_TheSansMonoCd_W5Regular_11">man csh</span> for the C Shell.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h2 class="H1" id="sec5"><span id="h1-57"/><span class="SANS_Futura_Std_Bold_B_11">Users and Groups</span></h2>&#13;
<p class="TNI1">You should gather information about the various users and groups found on the system. Systems can be provisioned with user accounts for human operators, but you may also run into systems that have no accounts other than the default ones of a Linux machine. This is especially true in environments where hosts are spun up and down many times per day, such as in containerized environments. Short-lived servers aren’t generally managed using local system accounts; rather, orchestration and provisioning tools automate the entire process of rollouts, upgrades, downgrades, scaling in and out, scaling up and down, and so on.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H2" id="sec6"><span id="h2-111"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Local Accounts</span></h3>&#13;
<p class="TNI1">Linux systems come with several default users and groups. You can find user accounts in <i>/etc/passwd</i> and groups in <i>/etc/group</i>, which even low-privileged users should be able to read. These files don’t contain sensitive data but can help you figure out other directories and files to look for, as everything on a Linux system is owned by a user and group.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Hackers frequently go after both</i> <span class="note_Italic">/etc/passwd</span> <i>and</i> <span class="note_Italic">/etc/group</span><i>, so security defenders with proper monitoring in place will watch for any read or write attempts made to these files.</i></p>&#13;
<p class="TX">Let’s view the <i>/etc/passwd</i> files on the compromised hosts. Run the command in <a href="chapter8.xhtml#Lis8-1">Listing 8-1</a> on <i>p-web-01</i> (172.16.10.10), <i>p-web-02</i> (172.16.10.12), and <i>p-jumpbox-01</i> (172.16.10.13) to see the list of users and their properties.</p>&#13;
<span id="Lis8-1"/><pre><code>$ <b>cat /etc/passwd</b>&#13;
&#13;
root:x:0:0:root:/root:/bin/bash&#13;
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin&#13;
<var>--snip--</var>&#13;
messagebus:x:100:101::/nonexistent:/usr/sbin/nologin&#13;
systemd-resolve:x:996:996:systemd Resolver:/:/usr/sbin/nologin&#13;
jmartinez:x:1001:1001::/home/jmartinez:/bin/bash&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 8-1: Viewing users on a system</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_167" aria-label="167"/>As you can see, we get a list of values separated by colons (<span class="SANS_TheSansMonoCd_W5Regular_11">:</span>). Each line is a unique user account, and each field represents specific information about it. Of particular interest to us is the first line in the output, which indicates that there is a <i>root</i> user account. <a href="chapter8.xhtml#tab8-2">Table 8-2</a> breaks this line into its constituent fields.</p>&#13;
<p class="TT" id="tab8-2"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 8-2:</span></span> <span class="SANS_Futura_Std_Book_11">Fields of the</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/passwd</span> <span class="SANS_Futura_Std_Book_11">File</span></p>&#13;
<table class="Basic-Table1">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Account</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Password</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">User ID</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Group ID</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Comment</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Home directory</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Default shell</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">root</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">x</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">root</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/root</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/bin/bash</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">The first field is the account’s username, and the <i>x</i> in the second field represents the password. You can find corresponding password hashes in a separate file named <i>/etc/shadow</i>, which we’ll cover in later chapters when we discuss credential access. The third and fourth fields represent the user’s user ID (UID) and group ID (GID), respectively. The fifth field is a comment field that can contain details about the user (such as their full name, location, and employee ID). The sixth field represents the user’s home directory (in this case, <i>/root</i>), and the seventh field represents their default shell environment (in this case, <i>/bin/bash</i>).</p>&#13;
<p class="TX">Using bash, we can parse the <i>/etc/passwd</i> output to extract certain desired fields. For example, to extract the username (in the first field), the home directory (in the sixth field), and the default shell (in the seventh field) of each user, run the command in <a href="chapter8.xhtml#Lis8-2">Listing 8-2</a>.</p>&#13;
<span id="Lis8-2"/><pre><code>$ <b>awk -F':' '{print $1, $6, $7}' /etc/passwd | sed 's/ /,/g'</b>&#13;
&#13;
root,/root,/bin/bash&#13;
daemon,/usr/sbin,/usr/sbin/nologin&#13;
bin,/bin,/usr/sbin/nologin&#13;
sys,/dev,/usr/sbin/nologin&#13;
sync,/bin,/bin/sync&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 8-2: Extracting key information from</span> <span class="SANS_Futura_Std_Book_11">/etc/passwd</span></p>&#13;
<p class="TX">Because the fields are separated by colons, we can easily use <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">sed</span> to retrieve the fields of interest.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H2" id="sec7"><span id="h2-112"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Local Groups</span></h3>&#13;
<p class="TNI1">Next, run the command in <a href="chapter8.xhtml#Lis8-3">Listing 8-3</a> to see the list of local groups.</p>&#13;
<span id="Lis8-3"/><pre><code>$ <b>cat /etc/group</b>&#13;
&#13;
root:x:0:&#13;
daemon:x:1:&#13;
bin:x:2:&#13;
sys:x:3:&#13;
<b>adm:x:4:ubuntu</b>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_168" aria-label="168"/>tty:x:5:&#13;
disk:x:6:&#13;
lp:x:7:&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 8-3: Viewing groups on a system</span></p>&#13;
<p class="TX">The <i>/etc/group</i> file is formatted as follows: the first field is a unique value representing the group’s name, the second field represents the password, the third field is the GID, and the last field is the list of members of each group, separated by commas. As you can see in the bolded part of the output, the <i>ubuntu</i> user account is part of the <i>adm</i> group, which is a group used for system administration tasks such as viewing logs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H2" id="sec8"><span id="h2-113"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Home Folder Access</span></h3>&#13;
<p class="TNI1">By default, only the user or a superuser, such as the <i>root</i> user, can access that user’s home directory. Run the command in <a href="chapter8.xhtml#Lis8-4">Listing 8-4</a> to list all user home directories and their permissions.</p>&#13;
<span id="Lis8-4"/><pre><code>$ <b>ls -l /home/</b>&#13;
&#13;
total 20&#13;
drwxr-x--- 2 arodriguez arodriguez 4096 May 19 02:28 arodriguez&#13;
drwxr-x--- 2 dbrown     dbrown     4096 May 19 02:28 dbrown&#13;
drwxr-x--- 2 jmartinez  jmartinez  4096 May 19 02:28 jmartinez&#13;
drwxr-x--- 2 ogarcia    ogarcia    4096 May 19 02:28 ogarcia&#13;
drwxr-x--- 2 ubuntu     ubuntu     4096 Apr 20 13:44 ubuntu&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 8-4: Viewing home directories and permissions</span></p>&#13;
<p class="TX">As you can see, each home directory is owned by the user to which it belongs. We’ll discuss directory permissions in more detail in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>.</p>&#13;
<p class="TX">Let’s write a small bash script to check whether we can access users’ home directories. This is useful because permissions can get messed up by mistake, such as when they’re changed recursively or when they’re part of large systems that may have dozens of user accounts.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>This chapter’s scripts are available at</i> <span class="note_LinkURL"><a href="https://github.com/dolevf/Black-Hat-Bash/blob/master/ch08">https://github.com/dolevf/Black-Hat-Bash/blob/master/ch08</a></span>.</p>&#13;
<p class="TX">The script in <a href="chapter8.xhtml#Lis8-5">Listing 8-5</a> will take the following steps: check whether the running user can read <i>/etc/passwd</i>, and if so, read its contents; extract the default home directory path of each user account; check whether the current user can read each home directory; and print the results.</p>&#13;
<span id="Lis8-5"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">home_dir _access_check.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
&#13;
if [[! -r "/etc/passwd"]]; then&#13;
  echo "/etc/passwd must exist and be readable to be able to continue."&#13;
  exit 1&#13;
fi&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_169" aria-label="169"/><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> while read -r line; do&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> account=$(echo "${line}" | awk -F':' '{print $1}')&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> home_dir=$(echo "${line}" | awk -F':' '{print $6}')&#13;
&#13;
  # Target only home directories under /home.&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if echo "${home_dir}" | grep -q "^/home"; then&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> if [[-r "${home_dir}"]]; then&#13;
      echo "Home directory ${home_dir} of ${account} is accessible!"&#13;
    else&#13;
      echo "Home directory ${home_dir} of ${account} is NOT accessible!"&#13;
    fi&#13;
  fi&#13;
done &lt; &lt;(cat "/etc/passwd")&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 8-5: Attempting to access users’ home directories</span></p>&#13;
<p class="TX">In a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> loop, we read the <i>/etc/passwd</i> file line by line <span class="CodeAnnotation" aria-label="annotation1">❶</span>. At <span class="CodeAnnotation" aria-label="annotation2">❷</span> and <span class="CodeAnnotation" aria-label="annotation3">❸</span>, we assign the <span class="SANS_TheSansMonoCd_W5Regular_11">account</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">home_dir</span> variables to the first and sixth fields of each line, respectively. We then check whether the home directory starts with the string <span class="SANS_TheSansMonoCd_W5Regular_11">/home</span> by using the caret (<span class="SANS_TheSansMonoCd_W5Regular_11">^</span>) character <span class="CodeAnnotation" aria-label="annotation4">❹</span> and the <span class="SANS_TheSansMonoCd_W5Regular_11">grep -q</span> (quiet) option so that the output of the command won’t be printed to the standard output stream. At <span class="CodeAnnotation" aria-label="annotation5">❺</span>, if our previous check succeeded, we check whether the home directory is readable with <span class="SANS_TheSansMonoCd_W5Regular_11">-r</span> and print the result to the screen.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H2" id="sec9"><span id="h2-114"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Valid Shells</span></h3>&#13;
<p class="TNI1">We mentioned that the seventh field of <i>/etc/passwd</i> is the user’s default shell. However, the system administrator can assign users an invalid shell as a security hardening measure. For hackers, accounts with real shells (such as <i>/bin/bash</i>) should thus indicate one of two possibilities: that the account belongs to a real user or service with a possible need to log in, or that the account has a possible misconfiguration.</p>&#13;
<p class="TX">When system administrators add an account to a Linux machine by using the command <span class="SANS_TheSansMonoCd_W5Regular_11">useradd</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">adduser</span>, the default shell is determined by the <span class="SANS_TheSansMonoCd_W5Regular_11">SHELL</span> setting in the file <i>/etc/default/useradd</i> or by <span class="SANS_TheSansMonoCd_W5Regular_11">DSHELL</span> in <i>/etc/adduser.conf</i>, as you can see here:</p>&#13;
<pre><code>$ <b>grep -e "#DSHELL" /etc/adduser.conf</b>&#13;
#DSHELL=/bin/bash&#13;
&#13;
$ <b>grep -e "SHELL=" /etc/default/useradd</b>&#13;
SHELL=/bin/sh&#13;
</code></pre>&#13;
<p class="TX">With some advanced bash and <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span>, we can filter for lines containing valid shells such as <i>/bin/bash</i> or <i>/bin/sh</i>, then focus our future efforts on those accounts only (<a href="chapter8.xhtml#Lis8-6">Listing 8-6</a>).</p>&#13;
<span id="Lis8-6"/><pre><code>$ <b>awk -F':' '{if ($7=="/bin/sh" || $7=="/bin/bash") {print $1,$7}}' /etc/passwd</b>&#13;
&#13;
root /bin/bash&#13;
ubuntu /bin/bash&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_170" aria-label="170"/>jmartinez /bin/bash&#13;
dbrown /bin/bash&#13;
ogarcia /bin/bash&#13;
arodriguez /bin/bash&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 8-6: Using advanced awk syntax to find accounts with active shells</span></p>&#13;
<p class="TX">We’ve intentionally made this command slightly more complicated than necessary so you can see how powerful <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> can be for parsing purposes. In <a href="chapter8.xhtml#Lis8-6">Listing 8-6</a>, <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> uses its built-in <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> condition and an OR operator (<span class="SANS_TheSansMonoCd_W5Regular_11">||</span>) to check whether the seventh field of the file equals <i>/bin/sh</i> or <i>/bin/bash</i>. It then prints the first and seventh fields if the expression is true.</p>&#13;
<p class="TX">Just as with anything in bash, you can achieve the same objective with an even simpler command (<a href="chapter8.xhtml#Lis8-7">Listing 8-7</a>).</p>&#13;
<span id="Lis8-7"/><pre><code>$ <b>grep -e "/bin/bash" -e "/bin/sh" /etc/passwd</b></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 8-7: Using grep to find accounts with active shells</span></p>&#13;
<p class="TX">This simpler <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> command is more prone to errors, however, because it will print any field that contains either of the two strings (not specifically the seventh field, where the default shell is defined).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h2 class="H1" id="sec10"><span id="h1-58"/><span class="SANS_Futura_Std_Bold_B_11">Processes</span></h2>&#13;
<p class="TNI1">Enumerating running processes is an extremely important step of successful reconnaissance. Processes help us identify all code that a system is running, allowing us to focus our efforts on specific applications. Processes are also important because they help us understand a host’s defense systems.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H2" id="sec11"><span id="h2-115"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Viewing Process Files</span></h3>&#13;
<p class="TNI1">Each process on a Linux host has a dedicated directory under <i>/proc</i> that is named after its process identifier (PID), which is a numerical value. Let’s run a simple <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> command (using the <span class="SANS_TheSansMonoCd_W5Regular_11">-1</span> option to list one file per line) and <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> with a special regular expression to list all files in this directory that have numbers as their name (<a href="chapter8.xhtml#Lis8-8">Listing 8-8</a>).</p>&#13;
<span id="Lis8-8"/><pre><code>$ <b>ls -1 /proc/ | grep -E '^[0-9]+$'</b>&#13;
&#13;
1&#13;
33&#13;
34&#13;
7&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 8-8: Filtering for PIDs in the</span> <span class="SANS_Futura_Std_Book_11">/proc</span> <span class="Futura_Std_Book_Oblique_I">directory</span></p>&#13;
<p class="TX">Because new processes frequently spawn and then die, you’ll likely see different PID numbers from those in this output (with the exception of <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>, also called the <i>init process</i>, which should always be present). Let’s explore the information available to us in the folder for the init process:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_171" aria-label="171"/>$ <b>ls -1 /proc/1/</b>&#13;
&#13;
arch_status&#13;
attr&#13;
autogroup&#13;
auxv&#13;
cgroup&#13;
clear_refs&#13;
cmdline&#13;
comm&#13;
coredump_filter&#13;
cpu_resctrl_groups&#13;
cpuset&#13;
cwd&#13;
environ&#13;
exe&#13;
fd&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">The folder contains many files, some of which are more interesting than others to penetration testers. For example, the following files contain useful information:</p>&#13;
<p class="RunInPara1"><b><i>/proc/&lt;pid&gt;/cmdline</i></b> Contains the full command used to start the process.</p>&#13;
<p class="RunInPara"><b><i>/proc/&lt;pid&gt;/cwd</i></b> Points to the working directory of the process.</p>&#13;
<p class="RunInPara"><b><i>/proc/&lt;pid&gt;/environ</i></b> Contains the environment variables at the process’s start time.</p>&#13;
<p class="RunInPara"><b><i>/proc/&lt;pid&gt;/exe</i></b> Points to the binary that started the process.</p>&#13;
<p class="RunInPara"><b><i>/proc/&lt;pid&gt;/task</i></b> Contains subdirectories for each thread started by the process.</p>&#13;
<p class="RunInPara"><b><i>/proc/&lt;pid&gt;/status</i></b> Contains information about the process, such as its state, virtual memory size, number of threads, thread ID, and process <i>umask</i> (a four-digit value used to determine the permissions of freshly created files).</p>&#13;
<p class="RunInPara2"><b><i>/proc/&lt;pid&gt;/fd</i></b> Contains the <i>file descriptors</i> in use. File descriptors are nonnegative (unsigned) integers used by processes to describe open files.</p>&#13;
<p class="TX">Let’s explore some of these files to see what they can tell us about PID <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> on the system. On <i>p-web-01</i> (172.16.10.10), run the following command:</p>&#13;
<pre><code>$ <b>cat /proc/1/cmdline</b>&#13;
&#13;
python3-mflaskrun--host=0.0.0.0--port=8081&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_172" aria-label="172"/>As you can see, a <span class="SANS_TheSansMonoCd_W5Regular_11">python3</span> command starts this process. The output is a little hard to read because its elements are separated by null bytes. We can make it more readable by using the following command to replace null bytes with spaces:</p>&#13;
<pre><code>$ <b>cat /proc/1/cmdline | tr '\000' ' '</b>&#13;
&#13;
python3 -m flask run --host=0.0.0.0 --port=8081&#13;
</code></pre>&#13;
<p class="TX">Next, look at the symbolic link <i>/proc/1/cwd</i> to determine the working directory of process <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> by running the following <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span> command:</p>&#13;
<pre><code>$ <b>ls -ld /proc/1/cwd</b>&#13;
&#13;
lrwxrwxrwx 1 root 0 May  4 01:26 /proc/1/cwd -&gt; /app&#13;
</code></pre>&#13;
<p class="TX">The first character in the output is <span class="SANS_TheSansMonoCd_W5Regular_11">l</span>, which stands for a symbolic link. You can also see we have an arrow (<span class="SANS_TheSansMonoCd_W5Regular_11">-&gt;</span>) from <i>/proc/1/cwd</i> to <i>/app</i>, indicating that the <i>cwd</i> symbolic link points to the <i>/app</i> directory.</p>&#13;
<p class="TX">We encourage you to discover any other files that live under the <i>/proc</i> directory and their purposes. You can find a well-explained list of these files in the <span class="SANS_TheSansMonoCd_W5Regular_11">proc</span> manual page (by running <span class="SANS_TheSansMonoCd_W5Regular_11">man proc</span>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H2" id="sec12"><span id="h2-116"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running ps</span></h3>&#13;
<p class="TNI1">Utilities such as <span class="SANS_TheSansMonoCd_W5Regular_11">ps</span> can enable us to explore processes without having to manually navigate the /<i>proc</i> directory. Run the following command to see the list of processes:</p>&#13;
<pre><code>$ <b>ps aux</b>&#13;
&#13;
USER  PID %CPU %MEM    VSZ   RSS TTY    STAT START   TIME COMMAND&#13;
root    1  0.0  0.7  36884 30204 ?      Ss   01:12   0:00 python3 -m flask run --host=0.0.0...&#13;
root    7  0.0  0.0   4508  3900 pts/0  Ss   01:12   0:00 /bin/bash&#13;
root   92  0.0  0.0   8204  3888 pts/0  R+   02:05   0:00 ps aux&#13;
</code></pre>&#13;
<p class="TX">The output is lightweight because the lab runs on containers, and containers are designed to use the smallest number of resources possible. On production systems running non-container-based servers, you’ll likely see many more processes. You can run the same command on your Kali host to see the differences in the output.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ps</span> command uses the <i>/proc</i> virtual filesystem to display process information in a more digestible way. Let’s use some of its built-in filtering capabilities to extract key information from the output, such as the running user, the PID, and the executed command:</p>&#13;
<pre><code>$ <b>ps x -o user -o pid -o cmd</b>&#13;
&#13;
USER         PID CMD&#13;
root           1 python3 -m flask run --host=0.0.0.0 --port=8081&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_173" aria-label="173"/>root           7 /bin/bash&#13;
root         137 ps x -o user -o pid -o cmd&#13;
</code></pre>&#13;
<p class="TX">Run the same command against all boxes we’ve compromised so far and note your results.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h3 class="H2" id="sec13"><span id="h2-117"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Examining Root Processes</span></h3>&#13;
<p class="TNI1">The ownership of processes is also an important element to consider. Processes running as root can lead to privilege escalation vulnerabilities if they are written insecurely. For example, when we compromised the <i>p-web-01</i> web server (172.16.10.10), we landed in the shell as the <i>root</i> user because the <i>root</i> user initialized and started the application.</p>&#13;
<p class="TX">Running applications as a superuser is generally considered bad practice, but it makes our lives as penetration testers much easier. If the application were started with a custom application user, we would have had to seek privilege escalation opportunities. As you may recall, when we compromised the <i>p-web-02</i> (172.16.10.12) machine, we landed as the <i>www-data</i> user, not root.</p>&#13;
<p class="TX">As another example of why using the <i>root</i> user for an application runtime is bad practice, imagine that a bash script executes a file called <i>/tmp/update.sh</i> every 10 minutes as a background job run by root, and say the file also happens to be writable by other system users. In this example, someone could write an instruction inside the file to grant themselves additional permissions, and since the process runs as root, the execution of the <i>update.sh</i> file would also run in the <i>root</i> user context.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h2 class="H1" id="sec14"><span id="h1-59"/><span class="SANS_Futura_Std_Bold_B_11">The Operating System</span></h2>&#13;
<p class="TNI1">The Linux operating system has so many variations that special websites such as <i><a href="https://distrowatch.com">https://distrowatch.com</a></i> are dedicated to tracking them. How do you know exactly which operating system is running on the box you just took over?</p>&#13;
<p class="TX">Operating systems may place information about themselves in different places, but for the most part, you’ll find it under the <i>/etc</i> directory. Check the following locations: <i>/etc/os-release</i>, <i>/etc/issue</i>, <i>/usr/lib/os-release</i>, <i>/proc/version</i>, <i>/etc/*-release</i>, and <i>/etc/*-version</i>. For example, on the Ubuntu-based <i>p-web-01</i> machine (172.16.10.10), you should be able to find information about the operating system in <i>/etc/os-release</i>.</p>&#13;
<p class="TX">In addition to files, some utilities could also help you identify the operating system. Try running <span class="SANS_TheSansMonoCd_W5Regular_11">uname -o</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">uname -a</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">lsb_release</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">hostnamectl</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">hostname</span>. Although commands such as <span class="SANS_TheSansMonoCd_W5Regular_11">hostname</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">hostnamectl</span> aren’t designed to show operating system information, they could reveal it if the system administrator set the machine’s hostname to include the operating type, such as <i>ubuntu-prod-01</i>. The same applies to the built-in environment variable <span class="SANS_TheSansMonoCd_W5Regular_11">$HOSTNAME</span>, which also holds the hostname value.</p>&#13;
<p class="HeadAExercise"><span id="exe-12"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_174" aria-label="174"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 12: Writing a Linux Operating System Detection Script</span></p>&#13;
<p class="TNI1">Try writing a script that can identify the operating system type (such as Ubuntu, Debian, or other) of any Linux-based operating system. To achieve this, the script should look for specific files of interest and extract information from them. Also, because anyone should be able to run the script on any Linux system and expect it to fail gracefully, you need to think about how you’ll handle errors.</p>&#13;
<p class="TX">Here are the steps the script should take:</p>&#13;
<p class="NLF">  1.  The script should use one or more of the available methods to gather the operating system–related information we highlighted earlier, using either a command or a file. You can also perform your own research to implement other local operating system discovery methods.</p>&#13;
<p class="NL">  2.  If you haven’t found an operating system detection method, the script needs to handle this condition and indicate it to the user.</p>&#13;
<p class="NLL">  3.  The script should exit with the correct status code for the runtime result.</p>&#13;
<p class="TX">The script <i>os_detect.sh</i> in this book’s GitHub repository is an example of an operating system detection script.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h2 class="H1" id="sec15"><span id="h1-60"/><span class="SANS_Futura_Std_Bold_B_11">Login Sessions and User Activity</span></h2>&#13;
<p class="TNI1">When a user logs in to a system or opens a new terminal session, the system records this information. This occurs no matter whether the user logs in locally (on a laptop, for example) or remotely, over a protocol such as SSH or Telnet.</p>&#13;
<p class="TX">This information is valuable because it could tell you about previous connections, including source IP addresses used to connect. For example, if a system administrator uses a dedicated management server to connect to other servers, collecting login sessions would reveal the IP address of the management server.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h3 class="H2" id="sec16"><span id="h2-118"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Collecting User Sessions</span></h3>&#13;
<p class="TNI1">To view the current users on a system, use the <span class="SANS_TheSansMonoCd_W5Regular_11">w</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">who</span> commands:</p>&#13;
<pre><code>$ <b>w</b>&#13;
$ <b>who</b>&#13;
</code></pre>&#13;
<p class="TX">These commands show information such as the user’s username, their login time, and the command of their current process. The commands read this information from the <i>/var/run/utmp</i> file.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">last</span> command shows historical logins taken from the file <i>/var/log/wtmp</i>, which contains both current and past user sessions:</p>&#13;
<pre><code>$ <b>last</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_175" aria-label="175"/>Attempt these commands on the <i>p-jumpbox-01</i> machine (172.16.10.13) after logging in via SSH with the backup user.</p>&#13;
<p class="TX">Another useful command is <span class="SANS_TheSansMonoCd_W5Regular_11">lastb</span> (last bad). This command displays a list of bad login attempts, taken from <i>/var/log/btmp</i>, if such a file exists on the filesystem.</p>&#13;
<p class="TX">Files such as <i>/var/run/utmp</i> and <i>/var/log/wtmp</i> are binary files. If you try to read them by using the <span class="SANS_TheSansMonoCd_W5Regular_11">cat</span> command, the output will be garbled. Some systems may have the <span class="SANS_TheSansMonoCd_W5Regular_11">utmpdump</span> command, which takes in these files as arguments and prints them in proper format to the screen.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h3 class="H2" id="sec17"><span id="h2-119"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Investigating Executed Commands</span></h3>&#13;
<p class="TNI1">When a user starts executing commands in the shell, the system captures this information and writes it to <i>history files</i>, which are usually hidden files (those starting with a dot) stored in the user’s home folder. For example, the <i>root</i> user’s history file is located at <i>/root/.bash_history</i>. For normal users, the history file is usually saved under <i>/home/&lt;user&gt;/.bash_history</i>. Different shells may name history files differently. For example, the Z Shell history file is named <i>.zsh_history</i>.</p>&#13;
<p class="TX">History files are interesting because they’re essentially a summary of a user’s actions on the command line. If someone ran a <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> command with credentials to authenticate to a remote website, the command, along with the credentials, would be recorded in the history file. To see the history file of the current user, run the following command:</p>&#13;
<pre><code>$ <b>history</b></code></pre>&#13;
<p class="TX">A quick bash one-liner using <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> can help us search for hidden files with the <i>_history</i> suffix (<a href="chapter8.xhtml#Lis8-9">Listing 8-9</a>).</p>&#13;
<span id="Lis8-9"/><pre><code>$ <b>find / -name ".*_history" -type f</b></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 8-9: Searching for shell command history files</span></p>&#13;
<p class="TX">This command starts the search from the root directory (<i>/</i>) and performs a case-sensitive search of files (<span class="SANS_TheSansMonoCd_W5Regular_11">-type f</span>) whose filenames end with the string <i>_history</i>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h2 class="H1" id="sec18"><span id="h1-61"/><span class="SANS_Futura_Std_Bold_B_11">Networking</span></h2>&#13;
<p class="TNI1">Network information is among the most important data to gather about a system. During penetration tests, you may know of only one network (the one you’re connected to physically if you’re on an on-site engagement, for example), but that doesn’t mean this is the only network available. You may discover new networks if you happen to hack a <i>multi-homed</i> host: a machine with multiple network interfaces connected to different networks.</p>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h3 class="H2" id="sec19"><span id="h2-120"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_176" aria-label="176"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Network Interfaces and Routes</span></h3>&#13;
<p class="TNI1">On a compromised host, a simple way to obtain all network interfaces is by looking at the files under the <i>/sys/class/net</i> directory. Go ahead and try listing files on the compromised boxes. The following examples are from the <i>p-web-01</i> box (172.16.10.10):</p>&#13;
<pre><code>$ <b>ls -l /sys/class/net/</b>&#13;
&#13;
total 0&#13;
lrwxrwxrwx 1 root root 0 May 10 03:13 eth0 -&gt; ../../devices/virtual/net/eth0&#13;
lrwxrwxrwx 1 root root 0 May 10 03:13 lo -&gt; ../../devices/virtual/net/lo&#13;
</code></pre>&#13;
<p class="TX">Each file is a symbolic link containing the name of a network interface, and each link points to a directory under <i>/sys/devices/virtual/net/</i>:</p>&#13;
<pre><code>$ <b>ls -l /sys/devices/virtual/net/</b>&#13;
total 0&#13;
drwxr-xr-x 5 root root 0 May 10 03:13 eth0&#13;
drwxr-xr-x 5 root root 0 May 10 03:13 lo&#13;
</code></pre>&#13;
<p class="TX">You could also use this network interface analysis to identify whether a network device is physical or virtual. It’s worth noting that an administrator can change network interface names, so these aren’t reliable indicators. However, physical network devices should show up differently when you list files under <i>/sys/devices/virtual/net</i>. Run the previous command on your Kali machine. You should see output similar to the following:</p>&#13;
<pre><code>lrwxrwxrwx 1 root root 0 Sep 25 16:15 br_corporate -&gt; ../../devices/virtual/net/br_corporate&#13;
lrwxrwxrwx 1 root root 0 Sep 25 16:15 br_public -&gt; ../../devices/virtual/net/br_public&#13;
lrwxrwxrwx 1 root root 0 Sep 19 21:41 docker0 -&gt; ../../devices/virtual/net/docker0&#13;
lrwxrwxrwx 1 root root 0 Sep 19 21:41 eth0 -&gt; ../../devices/<b>pci0000:00/0000:00:03.0</b>/net/eth0&#13;
lrwxrwxrwx 1 root root 0 Sep 19 21:41 lo -&gt; ../../devices/virtual/net/lo&#13;
</code></pre>&#13;
<p class="TX">As you can see, all devices are virtual except eth0, which has a Peripheral Component Interconnect bus identifier, <span class="SANS_TheSansMonoCd_W5Regular_11">pci0000:00/0000:00:03.0</span>. On your machine, this might look different depending on the network card you’re using.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Definitively identifying a target as a physical or a virtual server requires using multiple heuristics. Network collection can produce false positives.</i></p>&#13;
<p class="TX">Another way to print all network interfaces without using special network utilities is by inspecting the <i>/proc/net/route</i> file, which contains information about network routing. Manually inspecting this file can be useful on hardened hosts or lightweight Linux containers, where you may not have access to common network utilities such as <span class="SANS_TheSansMonoCd_W5Regular_11">ifconfig</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ip</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">netstat</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">ss</span> (socket statistics):</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_177" aria-label="177"/>$ <b>cat /proc/net/route</b>&#13;
&#13;
Iface Destination Gateway Flags RefCnt Use Metric Mask MTU Window IRTT&#13;
eth0 00000000 010A10AC 0003 0 0 0 00000000 0 0 0&#13;
eth0 000A10AC 00000000 0001 0 0 0 00FFFFFF 0 0 0&#13;
</code></pre>&#13;
<p class="TX">The first line of the file is the column headers line, and each subsequent line corresponds to a network route, its network interface, and other routing-related information in hexadecimal format. For example, in the first line, under <span class="SANS_TheSansMonoCd_W5Regular_11">Gateway</span>, the value <span class="SANS_TheSansMonoCd_W5Regular_11">010A10AC</span> represents the gateway IP address of the network interface. If you convert each byte to a decimal value, you should get the following:</p>&#13;
<div class="spc">&#13;
<p class="ListPlain">01<span class="MenuArrow"></span>1</p>&#13;
<p class="ListPlain">0A<span class="MenuArrow"></span>10</p>&#13;
<p class="ListPlain">10<span class="MenuArrow"></span>16</p>&#13;
<p class="ListPlain">AC<span class="MenuArrow"></span>172</p>&#13;
</div>&#13;
<p class="TX">This is 172.16.10.1, the gateway IP address for the interface eth0, in little-endian format. You can use <i><a href="https://ascii.cl/conversion.htm">https://ascii.cl/conversion.htm</a></i> to convert values from hexadecimal to decimal or do so with bash:</p>&#13;
<pre><code>$ <b>echo $((16#AC))</b>&#13;
172&#13;
</code></pre>&#13;
<p class="TX">Using the arithmetic operators <span class="SANS_TheSansMonoCd_W5Regular_11">$(())</span> and the character sequence <span class="SANS_TheSansMonoCd_W5Regular_11">16#</span>, which represents hexadecimal (or <i>base16</i>), you can convert any hexadecimal value to a decimal number.</p>&#13;
<p class="TX">The <i>/proc/net/route</i> file didn’t give us the IP addresses of the network interfaces on the host. However, we can get this information by looking at the <i>/proc/net/fib_trie</i> file. This file contains data that looks like this:</p>&#13;
<pre><code>Main:&#13;
  +-- 0.0.0.0/0 3 0 5&#13;
<var>--snip--</var>&#13;
           |-- 127.0.0.1&#13;
              /32 host LOCAL&#13;
        |-- 127.255.255.255&#13;
           /32 link BROADCAST&#13;
     +-- 172.16.10.0/24 2 0 2&#13;
        +-- 172.16.10.0/28 2 0 2&#13;
           |-- 172.16.10.0&#13;
              /24 link UNICAST&#13;
           |-- 172.16.10.10&#13;
<var>--snip--</var>&#13;
Local:&#13;
  +-- 0.0.0.0/0 3 0 5&#13;
     |-- 0.0.0.0&#13;
        /0 universe UNICAST&#13;
     +-- 127.0.0.0/8 2 0 2&#13;
        +-- 127.0.0.0/31 1 0 0&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_178" aria-label="178"/>           |-- 127.0.0.0&#13;
              /8 host LOCAL&#13;
           |-- 127.0.0.1&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">To parse this output to obtain only the network interface IP addresses, we can use the bash script in <a href="chapter8.xhtml#Lis8-10">Listing 8-10</a>.</p>&#13;
<span id="Lis8-10"/><pre><code>$ <b>awk '/32 host/ {print f} {f=$2}' /proc/net/fib_trie | sort | uniq</b>&#13;
&#13;
127.0.0.1&#13;
172.16.10.10&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 8-10: Extracting the IP addresses of network interfaces</span></p>&#13;
<p class="TX">What about MAC addresses, the physical addresses of the network interfaces? We can get this information through the <i>/sys</i> virtual filesystem too:</p>&#13;
<pre><code>$ <b>cat /sys/class/net/eth0/address</b>&#13;
&#13;
02:42:ac:10:0a:0a&#13;
</code></pre>&#13;
<p class="TX">On nonhardened hosts, you may have access to network utilities such as <span class="SANS_TheSansMonoCd_W5Regular_11">ifconfig</span>, a very popular command found on Linux hosts. This command lets you view all the necessary network information in a more digestible way:</p>&#13;
<pre><code>$ <b>ifconfig</b>&#13;
&#13;
eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500&#13;
        inet 172.16.10.10  netmask 255.255.255.0  broadcast 172.16.10.255&#13;
        ether 02:42:ac:10:0a:0a  txqueuelen 0  (Ethernet)&#13;
        RX packets 97  bytes 211107 (211.1 KB)&#13;
        RX errors 0  dropped 0  overruns 0  frame 0&#13;
        TX packets 83  bytes 5641 (5.6 KB)&#13;
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0&#13;
</code></pre>&#13;
<p class="TX">You should receive information such as MAC addresses, netmask and broadcast addresses, and some network statistics for each interface, such as the number of bytes of transmitted and received packets. By default, <span class="SANS_TheSansMonoCd_W5Regular_11">ifconfig</span> will display only network interfaces that are in an “up” state; use the <span class="SANS_TheSansMonoCd_W5Regular_11">-a</span> flag to display all interfaces.</p>&#13;
<p class="TX">An alternative command to <span class="SANS_TheSansMonoCd_W5Regular_11">ifconfig</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">ip</span>, which displays the same type of information, including routing details. Run <span class="SANS_TheSansMonoCd_W7Bold_B_11">ip addr</span> to show all network interfaces and <span class="SANS_TheSansMonoCd_W7Bold_B_11">ip addr</span> to show all network routes.</p>&#13;
<p class="TX">Try running these commands on the remaining boxes (<i>p-web-02</i> and <i>p-jumpbox-01</i>); you should notice that one of the boxes is connected to another internal network at the address 10.1.0.0/24. This means one of the compromised hosts has a network leg into another network!</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h3 class="H2" id="sec20"><span id="h2-121"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_179" aria-label="179"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Connections and Neighbors</span></h3>&#13;
<p class="TNI1">Networks are talkative; packets move in and out of systems continuously. Hosts that serve a purpose are rarely idle, and you can passively learn about their environment without sending network packets by simply collecting connection information.</p>&#13;
<p class="TX">Try collecting such information directly from the <i>/proc</i> virtual filesystem by using the <i>/proc/net/tcp</i> file:</p>&#13;
<pre><code>$ <b>cat /proc/net/tcp</b>&#13;
&#13;
 sl  local_address rem_address   st tx_queue rx_queue tr tm-&gt;when retrnsmt   uid  timeout inode&#13;
  0: 0B00007F:A0F1 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 4...&#13;
  1: 00000000:1F91 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 4...&#13;
</code></pre>&#13;
<p class="TX">The output of this file is a <i>TCP socket table</i> in which each row represents a connection between two addresses: a local address (<span class="SANS_TheSansMonoCd_W5Regular_11">local_address</span>) and a remote address (<span class="SANS_TheSansMonoCd_W5Regular_11">rem_address</span>). The data is in hexadecimal, so we must once again convert it to decimal to understand the IP addresses and ports behind each connection:</p>&#13;
<pre><code>$ <b>awk '{print $2,$3}' /proc/net/tcp | tail -n +2</b>&#13;
&#13;
0B00007F:A0F1 00000000:0000&#13;
00000000:1F91 00000000:0000&#13;
</code></pre>&#13;
<p class="TX">We use <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> to print the second and third fields only, then pipe these to the <span class="SANS_TheSansMonoCd_W5Regular_11">tail -n</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+2</span> command to remove the table headers from the output. This table will grow as more connections are made between the compromised host and other clients and servers.</p>&#13;
<p class="TX">You can also use Netstat to print network connections. Netstat prettifies the output of each connection and helps highlight which connections are currently active, which ones have timed out, and which PID and program name they are related to. Run the following command on <i>p-web-01</i> (172.16.10.10):</p>&#13;
<pre><code>$ <b>netstat -atnup</b>&#13;
&#13;
Active Internet connections (servers and established)&#13;
Proto Recv-Q Send-Q Local Address           Foreign Address         State      PID/Program name&#13;
tcp        0      0 127.0.0.11:41201        0.0.0.0:*               LISTEN     -&#13;
tcp        0      0 0.0.0.0:8081            0.0.0.0:*               LISTEN     1/python3&#13;
udp        0      0 127.0.0.11:45965        0.0.0.0:*                          -&#13;
</code></pre>&#13;
<p class="TX">Let’s focus on the columns that are most valuable to us. The first column represents the protocol (for example, TCP or UDP), the fourth column is the local address and port, the fifth column is the <i>foreign address</i> (the remote address of the connection), and the sixth column is the program name and PID. Note that when Netstat is executed using a nonroot user, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_180" aria-label="180"/>the PID column may not have information such as the PID and program name populated.</p>&#13;
<p class="TX">When we executed the Netstat command, no connections were being made to the web application. Let’s simulate an incoming connection to see the socket table change. On your Kali host, run the following Netcat command:</p>&#13;
<pre><code>$ <b>nc -v 172.16.10.10 8081</b></code></pre>&#13;
<p class="TX">Next, run the Netstat command we showed previously on the compromised <i>p-web-01</i> host (172.16.10.10):</p>&#13;
<pre><code>$ <b>netstat -atnup</b>&#13;
&#13;
Proto Recv-Q Send-Q Local Address     Foreign Address           State         PID/Program name&#13;
tcp        0      0 172.16.10.10:8081 <b>172.16.10.1:56520</b>         ESTABLISHED   1/python3&#13;
</code></pre>&#13;
<p class="TX">As you can see, a new line was added to the connection table, representing the remote IP address of the client connecting on port 8081. This remote address belongs to the host on which you ran Netcat (in this case, Kali).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h3 class="H2" id="sec21"><span id="h2-122"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Firewall Rules</span></h3>&#13;
<p class="TNI1">Host <i>firewall rules</i> are also a source of network information. A firewall table may include rules that block certain networks or individual IP addresses from communicating with the host. This information can teach us about other nearby networks, servers, or clients.</p>&#13;
<p class="TX">A common host firewall found on Linux servers is iptables. Let’s run the following <span class="SANS_TheSansMonoCd_W5Regular_11">iptables</span> command to see the rules configured on <i>p-web-01</i> (172.16.10.10):</p>&#13;
<pre><code>$ <b>iptables -L --line-numbers  -v</b>&#13;
&#13;
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)&#13;
num   pkts bytes target     prot opt in     out     source      destination&#13;
<b>  1      0     0 DROP       all  --  any    any     10.1.0.0/24 anywhere    /* Block Network */</b>&#13;
&#13;
Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)&#13;
num   pkts bytes target     prot opt in     out     source      destination&#13;
&#13;
Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)&#13;
num   pkts bytes target     prot opt in     out     source      destination&#13;
</code></pre>&#13;
<p class="TX">As you can see, a rule blocks the network 10.1.0.0/24 from connecting to the <i>p-web-01</i> box; this is another indication that an adjacent network at 10.1.0.0/24 exists. Note that reading the rule table with the <span class="SANS_TheSansMonoCd_W5Regular_11">iptables</span> command usually requires elevated permissions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h3 class="H2" id="sec22"><span id="h2-123"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_181" aria-label="181"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Network Interface Configuration Files</span></h3>&#13;
<p class="TNI1">Network interfaces may have dedicated configuration files that, for example, configure a network IP address statically for a specific interface or ensure that a network card is enabled on boot by default. Linux distributions can place their network configurations in different places, but you’ll commonly find them in the following locations: <i>/etc/network/interfaces</i>, <i>/etc/network/interfaces.d/</i>, <i>/etc/netplan/</i>, <i>/lib/netplan/</i>, <i>/run/netplan/</i>, and <i>/etc/sysconfig/network-scripts/</i>.</p>&#13;
<p class="TX">If configured statically, network interfaces can shed light on the DNS servers in use. Network interfaces can also provide information such as the IP scheme, gateway addresses, and more. Here is a static network configuration file available in later versions of Ubuntu-based Linux systems:</p>&#13;
<pre><code>network:&#13;
  version: 2&#13;
  renderer: networkd&#13;
  ethernets:&#13;
    eth0:&#13;
     dhcp4: no&#13;
     addresses: [172.16.10.0/24]&#13;
     gateway4: 172.16.10.1&#13;
     nameservers:&#13;
       addresses: [8.8.8.8,8.8.4.4]&#13;
</code></pre>&#13;
<p class="TX">This file configures the eth0 network interface with a default gateway of 172.16.10.1, as well as Google DNS servers 8.8.8.8 and 8.8.4.4.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h3 class="H2" id="sec23"><span id="h2-124"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Domain Resolvers</span></h3>&#13;
<p class="TNI1">Hosts are usually configured to use DNS to translate domain names, such as <i>example.com</i>, to IP addresses. DNS servers can be hosted locally on the network or in other places, such as public cloud instances. No matter where they’re running, they can be vulnerable.</p>&#13;
<p class="TX">You could find DNS server configurations in a few places on a Linux operating system, including in the <i>/etc/resolv.conf</i> file using a <span class="SANS_TheSansMonoCd_W5Regular_11">nameserver</span> entry, like so:</p>&#13;
<pre><code>$ <b>cat /etc/resolv.conf</b>&#13;
&#13;
nameserver 127.0.0.11&#13;
</code></pre>&#13;
<p class="TX">DNS servers can also be configured within the <i>/etc/hosts</i> configuration file, as shown here for <i>p-web-01</i> (172.16.10.10). This <i>/etc/hosts</i> file may include a list of alternative networks and hosts you could target:</p>&#13;
<pre><code>$ <b>cat /etc/hosts</b>&#13;
127.0.0.1       localhost&#13;
::1     localhost ip6-localhost ip6-loopback&#13;
fe00::0 ip6-localnet&#13;
ff00::0 ip6-mcastprefix&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_182" aria-label="182"/>ff02::1 ip6-allnodes&#13;
ff02::2 ip6-allrouters&#13;
172.16.10.10    p-web-01.acme-hyper-branding.com p-web-01&#13;
</code></pre>&#13;
<p class="TX">DNS servers can also be configured in the individual network interface files, as discussed in the preceding section.</p>&#13;
<p class="TX">DNS servers can also be configured automatically by using a <i>Dynamic Host Configuration Protocol</i> server, a network service responsible for handing out network configurations dynamically, in which case the DNS server won’t be explicitly set in any configuration file.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h2 class="H1" id="sec24"><span id="h1-62"/><span class="SANS_Futura_Std_Bold_B_11">Software Installations</span></h2>&#13;
<p class="TNI1">Unmaintained operating system images tend to suffer from a wide variety of vulnerabilities, especially if they include many packages installed by default. We should investigate the software bundled with an operating system because it can lead us to interesting vulnerabilities that can help us escalate our privileges or obtain access to unauthorized information.</p>&#13;
<p class="TX">One way to investigate installed software is with a package manager. You’ll find a few types of package managers commonly available on Linux operating systems: Advanced Package Tool (APT) on systems such as Debian and Ubuntu, Yellowdog Updater Modified on systems such as Red Hat, CentOS, and Fedora, and Alpine Package Keeper on container-based operating systems such as Alpine Linux.</p>&#13;
<p class="TX">Try running the following <span class="SANS_TheSansMonoCd_W5Regular_11">apt</span> command to list installed packages on any of the compromised hosts:</p>&#13;
<pre><code>$ <b>apt list --installed</b>&#13;
&#13;
Listing... Done&#13;
adduser/lunar,now 3.129ubuntu1 all [installed,automatic]&#13;
apt/lunar,now 2.6.0 amd64 [installed]&#13;
base-files/lunar,now 12.3ubuntu2 amd64 [installed]&#13;
base-passwd/lunar,now 3.6.1 amd64 [installed]&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">You can get a slightly nicer output by using <span class="SANS_TheSansMonoCd_W5Regular_11">dpkg</span> instead. Note that this command is mostly found on Ubuntu- or Debian-based Linux systems:</p>&#13;
<pre><code>$ <b>dpkg -l</b>&#13;
&#13;
<var>--snip--</var>&#13;
ii  adduser            3.129ubuntu1           all        add and remove users and groups&#13;
ii  apt                2.6.0                  amd64      commandline package manager&#13;
ii  base-files         12.3ubuntu2            amd64      Debian base system miscellaneous files&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">To get a list of packages using other software managers, you could try any of the following commands:</p>&#13;
<div class="spc">&#13;
<p class="ListPlain"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_183" aria-label="183"/><span class="SANS_TheSansMonoCd_W5Regular_11">yum list installed</span></p>&#13;
<p class="ListPlain"><span class="SANS_TheSansMonoCd_W5Regular_11">apk list --installed</span></p>&#13;
<p class="ListPlain"><span class="SANS_TheSansMonoCd_W5Regular_11">rpm -qa</span></p>&#13;
</div>&#13;
<p class="TX">We can use bash to parse these package lists and obtain the software’s name and version, as well as do some clever searches. To list only the package names, run this command:</p>&#13;
<pre><code>$ <b>apt list --installed | awk -F'/' '{print $1}'</b></code></pre>&#13;
<p class="TX">Use the following to list only the package versions:</p>&#13;
<pre><code>$ <b>apt list --installed | awk '{print $2}'</b></code></pre>&#13;
<p class="TX">What if we want to search for a specific package and then print its version by using an exact match search? We can do so with <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span>:</p>&#13;
<pre><code>$ <b>apt list --installed | awk -F'[/]' '$1 == "openssl" {print $3}'</b></code></pre>&#13;
<p class="TX">We use an <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> delimiter (<span class="SANS_TheSansMonoCd_W5Regular_11">-F</span>) consisting of a forward slash and a space and surround it with square brackets <span class="SANS_TheSansMonoCd_W5Regular_11">[/]</span> to define more than one delimiter. We then check whether the first field equals <span class="SANS_TheSansMonoCd_W5Regular_11">openssl</span>; if it does, we print the third field, which is the version field.</p>&#13;
<p class="TX">We can even use <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> to partially match package names:</p>&#13;
<pre><code>$ <b>apt list --installed | awk -F'[/]' '$1 ~ /openssl/ {print $3}'</b></code></pre>&#13;
<p class="TX">To see the total number of installed packages, run <span class="SANS_TheSansMonoCd_W5Regular_11">apt list</span> and pipe it to the <span class="SANS_TheSansMonoCd_W5Regular_11">wc</span> (word count) command:</p>&#13;
<pre><code>$ <b>apt list --installed | wc -l</b>&#13;
&#13;
341&#13;
</code></pre>&#13;
<p class="TX">You could use these package names and versions as lookup queries on websites that source vulnerability data, such as the National Vulnerability Database (<i><a href="https://nvd.nist.gov">https://nvd.nist.gov</a></i>) or the MITRE Common Vulnerabilities and Exposures (CVE) database (<i><a href="https://cve.mitre.org">https://cve.mitre.org</a></i>).</p>&#13;
<p class="TX">Note that the package manager might not list all software installed on a server. For example, a server could install Java directly from the source without using package management tools, in which case it won’t be shown in the package list.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<h2 class="H1" id="sec25"><span id="h1-63"/><span class="SANS_Futura_Std_Bold_B_11">Storage</span></h2>&#13;
<p class="TNI1">From a security perspective, server storage is interesting for several reasons. Multiple servers could share the same storage system or use it to share files with end users. And if you can write into storage systems, you might be able <span role="doc-pagebreak" epub:type="pagebreak" id="pg_184" aria-label="184"/>to achieve code execution on adjacent servers if they source files, such as shell scripts, from the compromised storage system.</p>&#13;
<p class="TX">Server storage can be virtual or physical, and servers can run on a single local disk or multiple local disks. Servers can also use multiple disks to form a redundant array of inexpensive disks system, which provides improved redundancy and performance and can back up critical data.</p>&#13;
<p class="TX">Linux systems can mount remote storage systems as local directories (usually under the <i>/mnt</i> directory). These can act as an integral part of the operating system. You’ll see remote storage implemented using network-attached storage or storage area network devices and protocols like Network File System or Common Internet File System.</p>&#13;
<p class="TX">Remote storage is useful to investigate because systems can use it for a variety of purposes: as a data backup location, for centralized security logging, as a remote file share, or even to store remote user home folders. Application logs are often written to remote storage devices in a folder like <i>/mnt/log_storage/</i>, which might be physically connected to a completely different server.</p>&#13;
<p class="TX">Let’s explore ways to identify disks, partitions, and mount points on a compromised host.</p>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<h3 class="H2" id="sec26"><span id="h2-125"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Block Devices</span></h3>&#13;
<p class="TNI1">First, let’s look at which block devices exist by using the command <span class="SANS_TheSansMonoCd_W5Regular_11">lsblk</span>. <i>Block devices</i> are data storage devices such as CDs, floppy disks, and hard disks. The following output is from <i>p-web-01</i> (172.16.10.10):</p>&#13;
<pre><code>$ <b>lsblk</b>&#13;
&#13;
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS&#13;
sr0     11:0    1 1024M  0 rom&#13;
vda    254:0    0   40G  0 disk&#13;
|-vda1 254:1    0   39G  0 part /etc/hosts&#13;
|                               /etc/hostname&#13;
|                               /etc/resolv.conf&#13;
|                               /mnt/scripts&#13;
|-vda2 254:2    0    1K  0 part&#13;
`-vda5 254:5    0  975M  0 part [SWAP]&#13;
</code></pre>&#13;
<p class="TX">As you can see, we have two primary devices: sr0 and vda. The sr0 device is of type rom, and vda is of type disk. The other names you see on the list, such as vda1, vda2, and vda5, are all partitions of the vda disk. Run the same command against the remaining compromised machines you have access to and take note of the findings.</p>&#13;
<p class="TX">Another way to view the list of partitions is by reading <i>/proc/partitions</i>:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_185" aria-label="185"/>$ <b>cat /proc/partitions</b>&#13;
&#13;
major minor  #blocks  name&#13;
&#13;
 254        0   41943040 vda&#13;
 254        1   40941568 vda1&#13;
 254        2          1 vda2&#13;
 254        5     998400 vda5&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">The <i>/proc</i> filesystem also exposes a file named <i>/proc/mounts</i>, which provides a list of all mounts, their mount options, and additional attributes about the mount points:</p>&#13;
<pre><code>$ <b>cat /proc/mounts</b>&#13;
&#13;
<var>--snip--</var>&#13;
shm /dev/shm tmpfs rw,nosuid,nodev,noexec,relatime,size=65536k,inode64 0 0&#13;
/dev/vda1 /mnt/scripts ext4 rw,relatime,errors=remount-ro 0 0&#13;
/dev/vda1 /etc/resolv.conf ext4 rw,relatime,errors=remount-ro 0 0&#13;
/dev/vda1 /etc/hostname ext4 rw,relatime,errors=remount-ro 0 0&#13;
/dev/vda1 /etc/hosts ext4 rw,relatime,errors=remount-ro 0 0&#13;
</code></pre>&#13;
<p class="TX">Alternatively, you could just call the <span class="SANS_TheSansMonoCd_W5Regular_11">mount</span> command to get this information:</p>&#13;
<pre><code>$ <b>mount</b>&#13;
&#13;
<var>--snip--</var>&#13;
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)&#13;
tmpfs on /dev type tmpfs (rw,nosuid,size=65536k,mode=755,inode64)&#13;
/dev/vda1 on /mnt/scripts type ext4 (rw,relatime,errors=remount-ro)&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">A quick way to get a view of the various mounted filesystems is by using the <span class="SANS_TheSansMonoCd_W5Regular_11">df</span> command, which will also indicate the available and total disk sizes of each filesystem:</p>&#13;
<pre><code>$ <b>df -h -T</b>&#13;
&#13;
Filesystem     Type     Size  Used Avail Use% Mounted on&#13;
overlay        overlay   39G   20G   18G  53% /&#13;
tmpfs          tmpfs     64M     0   64M   0% /dev&#13;
shm            tmpfs     64M     0   64M   0% /dev/shm&#13;
/dev/vda1      ext4      39G   20G   18G  53% /mnt/scripts&#13;
</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">-h</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">-T</span> flags will print out a human-readable version of the output and the filesystem type, respectively.</p>&#13;
<p class="TX">You may have noticed a mount point at <i>/mnt/scripts</i> on <i>p-web-01</i> (172.16.10.10). Take note of this, as it will come in handy in later chapters.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<h3 class="H2" id="sec27"><span id="h2-126"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_186" aria-label="186"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Filesystem Tab File</span></h3>&#13;
<p class="TNI1">The <i>/etc/fstab</i> file is a static configuration file that controls the mounting of devices and partitions. Mounting devices and partitions without the necessary security measures can lead to filesystem-level vulnerabilities.</p>&#13;
<p class="TX">You can mount a device or partition at specific filesystem locations by using special options that control what can and cannot be done using the mount point. For example, you could configure a volume from a remote storage system to be mounted on <i>/mnt/external_storage</i> upon system boot. You could also configure it to be a read-only filesystem, which wouldn’t allow writes, or remove execution options, so users won’t be able to run binaries from it.</p>&#13;
<p class="TX">Here are a few mount options that can be beneficial to know about as penetration testers:</p>&#13;
<p class="RunInPara1"><span class="SANS_TheSansMonoCd_W7Bold_B_11">dev</span> Interprets special block devices, such as device files.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">nodev</span> The opposite of <span class="SANS_TheSansMonoCd_W5Regular_11">dev</span>; will not interpret special block devices.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">noexec</span> Forbids the execution of binaries. Scripts such as bash will still be allowed.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">suid</span> Allows the use of programs set with the <span class="SANS_TheSansMonoCd_W5Regular_11">setuid</span> flag, which lets users execute a program by using the permissions of the file’s user or group owner.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">nosuid</span> The opposite of the <span class="SANS_TheSansMonoCd_W5Regular_11">suid</span> option; won’t allow the use of programs set with the <span class="SANS_TheSansMonoCd_W5Regular_11">setuid</span> flag.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">exec</span> Allows the execution of binaries and other types of files.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">ro</span> Forbids writing into the filesystem; in other words, creates a read-only filesystem.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">rw</span> Allows writing into the filesystem as well as reading.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">nosymfollow</span> Restricts the following of symbolic links created on the filesystem. This option would still allow creating symbolic links.</p>&#13;
<p class="RunInPara2"><span class="SANS_TheSansMonoCd_W7Bold_B_11">defaults</span> Uses the following mount options: <span class="SANS_TheSansMonoCd_W5Regular_11">rw</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">suid</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">dev</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">exec</span>, and a few others.</p>&#13;
<p class="TX">If you return to the <span class="SANS_TheSansMonoCd_W5Regular_11">mount</span> command output shown previously, you’ll see what mount options are set on each mount point, if defined.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
<h2 class="H1" id="sec28"><span id="h1-64"/><span class="SANS_Futura_Std_Bold_B_11">Logs</span></h2>&#13;
<p class="TNI1">Applications usually generate some sort of runtime output, and this output is sometimes written into logfiles. The content of these logfiles will vary depending on the application but generally indicates whether everything is working correctly or if an error has occurred.</p>&#13;
<p class="TX">Certain logfiles are part of the Linux operating system, while others are related to third-party applications such as web servers and databases. Additionally, you might find custom application logs written by the company against which you’re performing a penetration test.</p>&#13;
<p class="TX">On Linux systems, both system and application logfiles are usually written to the <i>/var/log</i> directory. Custom applications can write their logs <span role="doc-pagebreak" epub:type="pagebreak" id="pg_187" aria-label="187"/>anywhere but generally write them to files under the <i>/var</i> directory too. Here is an example <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> command that can search for logfiles:</p>&#13;
<pre><code>$ <b>find / -name "*.log" -o -name "*.txt" -o -name "*.out" -type f 2&gt; /dev/null</b></code></pre>&#13;
<p class="TX">This command finds files with the extensions <i>.log</i> and <i>.out</i>.</p>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
<h3 class="H2" id="sec29"><span id="h2-127"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">System Logs</span></h3>&#13;
<p class="TNI1">Here is a list of common system logs on Linux systems:</p>&#13;
<div class="spc">&#13;
<p class="ListPlain"><i>/var/log/auth.log                     /var/log/faillog</i></p>&#13;
<p class="ListPlain"><i>/var/log/secure                       /var/log/lastlog</i></p>&#13;
<p class="ListPlain"><i>/var/log/audit/audit.log         /var/log/dpkg</i></p>&#13;
<p class="ListPlain"><i>/var/log/dmesg                      /var/log/boot.log</i></p>&#13;
<p class="ListPlain"><i>/var/log/messages                 /var/log/cron</i></p>&#13;
<p class="ListPlain"><i>/var/log/syslog</i></p>&#13;
</div>&#13;
<p class="TX">Of particular interest are files such as <i>/var/log/auth.log</i>, <i>/var/log/secure</i>, and <i>/var/log/lastlog</i>, which are related to authentication and can contain juicy information regarding clients connecting to servers. The <i>/var/log/audit/audit.log</i> file is used by auditing systems such as Auditd to log events such as command line activity, authentication attempts, and general system calls.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
<h3 class="H2" id="sec30"><span id="h2-128"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Application Logs</span></h3>&#13;
<p class="TNI1">Application logs can also contain interesting information for penetration testers. For example, if a server is running a website, the web engine may generate logs about clients connecting to it and the web paths they are requesting. This could reveal other clients and servers that are on the network.</p>&#13;
<p class="TX">Web servers like Apache and nginx usually write their logs to directories such as <i>/var/log/apache2/</i>, <i>/var/log/httpd/</i>, or <i>/var/log/nginx/</i>. Other types of applications, such as proxies, email servers, printer servers, file transfer servers, relational databases, message queues, and cache databases, also produce logs you’ll want to look out for. <a href="chapter8.xhtml#tab8-3">Table 8-3</a> lists the locations of common application logs you may run into.</p>&#13;
<p class="TT" id="tab8-3"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 8-3:</span></span> <span class="SANS_Futura_Std_Book_11">Log Locations</span></p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_188" aria-label="188"/>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Log type</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Logfiles</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Web servers</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/var/log/apache2/access.log<br/>/var/log/httpd/access.log<br/>/var/log/nginx/access.log<br/>/var/log/lighttpd/access.log</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Databases</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/var/log/mysql/mysql.log<br/>/var/log/postgresql<br/>/var/log/redis<br/>/var/log/mongodb/mongod.log<br/>/var/log/elasticsearch/elasticsearch.log</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Printer servers</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/var/log/cups</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">File transfer servers</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/var/log/vsftpd<br/>/var/log/proftpd</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Monitoring systems</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/var/log/icinga2<br/>/var/log/zabbix<br/>/var/log/logstash<br/>/var/log/nagios/nagios.log<br/>/var/log/cacti</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Note that some logs will require elevated privileges because of their sensitivity.</p>&#13;
<p class="HeadAExercise"><span id="exe-13"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 13: Recursively Searching for Readable Logfiles</span></p>&#13;
<p class="TNI1">In this exercise, you’ll write a script that looks for logfiles. It should do the following:</p>&#13;
<p class="NLF">  1.  Take a path as command line input. By default, it should use <i>/var/log</i> if no argument is specified.</p>&#13;
<p class="NL">  2.  Recursively walk through the path to find readable files.</p>&#13;
<p class="NL">  3.  Copy these files into a centralized directory of your choice.</p>&#13;
<p class="NLL">  4.  Compress the folder by using the <span class="SANS_TheSansMonoCd_W5Regular_11">tar</span> command.</p>&#13;
<p class="TX">To aid your script writing, we recommend looking into the <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> command, which has many powerful built-in features that allow you to search by user and group ownership.</p>&#13;
<p class="TX">You can find a full solution, <i>recursive_file_search.sh</i>, in the book’s GitHub repository.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
<h2 class="H1" id="sec31"><span id="h1-65"/><span class="SANS_Futura_Std_Bold_B_11">Kernels and Bootloaders</span></h2>&#13;
<p class="TNI1">The main component of operating systems such as Linux is called the <i>kernel</i>. The kernel is responsible for core functionalities such as process and memory management, drivers, security, and more. It is a highly complex piece of software and, as such, is prone to vulnerabilities. One example of a kernel exploit is the <i>Dirty COW vulnerability</i> (CVE-2016-5195), which allowed remote execution and the ability to obtain root access without leaving system traces.</p>&#13;
<p class="TX">Discovering the version of the kernel running on a system may allow you to escalate privileges with kernel exploits. To check the kernel version, use the following command:</p>&#13;
<pre><code>$ <b>uname -r</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_189" aria-label="189"/>As the lab machines are based on Docker, they share the host’s (Kali’s) kernel, and running <span class="SANS_TheSansMonoCd_W5Regular_11">uname</span> will print Kali’s kernel version.</p>&#13;
<p class="TX">A Linux system could have more than one kernel version installed to allow for rollbacks in cases of system failure. Kernel files are located under the <i>/boot</i> directory. You can also find out which kernels are installed by running either of the following commands:</p>&#13;
<pre><code>$ <b>rpm -qa | grep kernel</b>&#13;
$ <b>ls -l /boot | grep "vmlinuz-"</b>&#13;
</code></pre>&#13;
<p class="TX">Make sure to use the correct package manager command for the host system.</p>&#13;
<p class="TX">Unstable kernel exploits are dangerous to run and can crash and take down a server if they aren’t tested properly. We recommend obtaining explicit authorization before attempting to run these types of exploits.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
<h2 class="H1" id="sec32"><span id="h1-66"/><span class="SANS_Futura_Std_Bold_B_11">Configuration Files</span></h2>&#13;
<p class="TNI1">We’ve already highlighted a few types of configuration files in this chapter. Though these files are highly application dependent, they can often include sensitive data. During local reconnaissance, you’ll want to go after them, especially those that are related to web applications, which generally rely on many services as part of their normal operations. The web applications need to connect to these services, usually with some form of authentication, so you’ll probably find credentials nearby.</p>&#13;
<p class="TX">Configuration files primarily live under the <i>/etc</i> directory and may or may not have an associated file extension, such as <i>*.conf</i>, <i>*.cfg</i>, <i>*.ini *</i>, <i>.cnf</i>, and <i>*.cf</i>. You might also find configuration files under users’ hidden directories, such as <i>/home/user/.config/</i> or <i>/home/user/.local</i>. To perform a wide search for configuration files, use this command:</p>&#13;
<pre><code>$ <b>find / -name "*.conf" -o -name "*.cf" -o -name "*.ini" -o -name "*.cfg" -type f 2&gt; /dev/null</b></code></pre>&#13;
<p class="TX">To search a specific folder, change the <span class="SANS_TheSansMonoCd_W5Regular_11">find /</span> portion of the command to another directory, such as <span class="SANS_TheSansMonoCd_W5Regular_11">find /etc</span>. You can even chain multiple directories together, like so:</p>&#13;
<pre><code>$ <b>find /etc /usr /var/www-name "*.conf" -o -name "*.cf" -o -name "*.ini" -o –</b><b>name "*.cfg"</b>&#13;
<b>-type f 2&gt; /dev/null</b>&#13;
</code></pre>&#13;
<p class="TX">Third-party software also tends to include custom configuration that can be interesting. For example, WordPress usually uses a database for storing blog-related data, and its config file, <i>wp-config.php</i>, usually contains credentials related to databases such as MySQL:</p>&#13;
<pre><code>// ** MySQL settings - You can get this info from your web host ** //&#13;
/** The name of the database for WordPress */&#13;
define('DB_NAME', 'database_name_here');&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_190" aria-label="190"/>/** MySQL database username */&#13;
define('DB_USER', 'username_here');&#13;
&#13;
/** MySQL database password */&#13;
define('DB_PASSWORD', 'password_here');&#13;
</code></pre>&#13;
<p class="TX">The location of this file depends on where WordPress was installed because it usually resides within the application’s root directory, such as <i>/var/www/html/wp-config.php</i>. As you can see, it has a.<i>php</i> extension, because WordPress is written in the PHP language. The search we used earlier wouldn’t have caught this file, but we can tweak our command to search for files with the word <i>config</i> in them:</p>&#13;
<pre><code>$ <b>find / -name "*config*" 2&gt; /dev/null</b></code></pre>&#13;
<p class="TX">We already know that the <i>p-web-02</i> server (172.16.10.12) runs WordPress; can you find its configuration file? Hint: it lives alongside the application in the web root directory.</p>&#13;
<p class="TX">Being aware of common configuration files and their locations helps when you identify services of interest that are running on the host. <a href="chapter8.xhtml#tab8-4">Table 8-4</a> lists some examples.</p>&#13;
<p class="TT" id="tab8-4"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 8-4:</span></span> <span class="SANS_Futura_Std_Book_11">Common Configuration File Locations</span></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Server type</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">File location</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Web servers</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/httpd/httpd.conf<br/>/etc/httpd/conf/httpd.conf<br/>/etc/apache2/apach2.conf<br/>/etc/lighttpd/lighttpd.conf <br/>/etc/nginx/nginx.conf</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">File-sharing and file-transfer servers</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/vsftpd/vsftpd.conf <br/>/etc/protftpd.conf /usr/local<br/>/etc/proftpd.conf <br/>/etc/samba/smb.conf</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Databases</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/mysql/my.cnf <br/>/etc/my.cnf <br/>/etc/redis/redis.conf <br/>/etc/mongo.conf <br/>/etc/cassandra</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Domain name servers</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/bind/named.conf</span> <span class="SANS_Futura_Std_Book_Oblique_I_11"><br/>/etc/dnsmasq.conf</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Mail servers</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/postfix/main.cf <br/>/etc/mail/sendmail.cf <br/>/etc/dovecot/dovecot.conf</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Virtual private network servers</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/openvpn <br/>/etc/ipsec.conf</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">This table isn’t comprehensive, but it should give you an idea of where popular network servers commonly store their configurations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
<h2 class="H1" id="sec33"><span id="h1-67"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_191" aria-label="191"/><span class="SANS_Futura_Std_Bold_B_11">Scheduled Tasks</span></h2>&#13;
<p class="TNI1"><i>Scheduled tasks</i> allow you to specify a command or script for the system to run automatically at a specified interval. They’re interesting from a penetration-testing standpoint because they can often be written in a way that allows for privilege escalation conditions.</p>&#13;
<p class="TX">For example, a task could read and execute instructions from world-writable files, and if a malicious user is able to write malicious instructions into them, the system might execute them with elevated privileges. A user could then take malicious actions, such as creating a privileged user, changing the folder permissions of a protected folder like <i>/root</i>, adding permissions to the existing user, starting custom malicious processes, and deleting or overwriting sensitive information in files.</p>&#13;
<p class="TX">On Linux, we have two common mechanisms for scheduling tasks: Cron and At.</p>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
<h3 class="H2" id="sec34"><span id="h2-129"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Cron</span></h3>&#13;
<p class="TNI1">Let’s write a small script that creates a file and appends the current date and time to it (<a href="chapter8.xhtml#Lis8-11">Listing 8-11</a>).</p>&#13;
<span id="Lis8-11"/><pre><code>#!/bin/bash&#13;
job_name="my_scheduled_job"&#13;
&#13;
echo "The time now is $(date)" &gt;&gt; "/tmp/${job_name}"&#13;
&#13;
exit 0&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 8-11: A simple cron job</span></p>&#13;
<p class="TX">Save this file and give it the name <i>cron_task.sh</i>. Make sure it is executable by using <span class="SANS_TheSansMonoCd_W7Bold_B_11">chmod u+x cron_task.sh</span>.</p>&#13;
<p class="TX">Next, we’ll use Cron to run this script every minute. Run the following to open a text editor:</p>&#13;
<pre><code>$ <b>crontab -e</b></code></pre>&#13;
<p class="TX">Now append the following to the end of the <i>/etc/crontab</i> file and save it. Make sure you change the path to the place where you saved your script:</p>&#13;
<pre><code>* * * * * bash /path/to/cron_task.sh</code></pre>&#13;
<p class="TX">You may be asking yourself what those five asterisks (<span class="SANS_TheSansMonoCd_W5Regular_11">*</span>) are all about. Cron has special syntax to describe its execution schedule. The format is as follows:</p>&#13;
<pre><code>Minutes (0-59), Hours (0-23), Days of the month (1-31), Month (1-12), Days of the week (0-6)</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_192" aria-label="192"/>For instance, the following syntax describes an <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span> task that will run every day at 11:30 <small>PM</small>:</p>&#13;
<pre><code>30 23 * * * echo "It is 23:30!" &gt;&gt; /tmp/cron.log</code></pre>&#13;
<p class="TX">The Cron process should execute the script. To make sure it worked, run <span class="SANS_TheSansMonoCd_W7Bold_B_11">ls</span> in the <i>/tmp</i> folder. You should see the file <i>/tmp/my_scheduled_job</i> containing updates about the time:</p>&#13;
<pre><code>$ <b>cat /tmp/my_scheduled_job</b>&#13;
&#13;
The time now is Mon May 22 03:11:01&#13;
The time now is Mon May 22 03:12:01&#13;
The time now is Mon May 22 03:13:01&#13;
</code></pre>&#13;
<p class="TX">In the context of penetration testing, cron jobs can be insecure. For example, a task may copy sensitive files to paths that are world-readable, allowing untrusted local users to obtain access to them. Here is an example of a backup job that is very insecure if it runs with the context of the <i>root</i> user:</p>&#13;
<pre><code>30 23 1 * * tar czvf /home/backup.tar.gz /etc /var</code></pre>&#13;
<p class="TX">Cron jobs like this will copy the sensitive directories <i>/etc</i> and <i>/var</i> to the <i>/home</i> directory. Since the <i>/home</i> directory is accessible to all local users, anyone with read access can copy this file or view it.</p>&#13;
<p class="TX"><a href="chapter8.xhtml#tab8-5">Table 8-5</a> lists additional files that Cron uses for its runtime.</p>&#13;
<p class="TT" id="tab8-5"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 8-5:</span></span> <span class="SANS_Futura_Std_Book_11">Cron Files</span></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Purpose</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Files</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Cron logs</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/var/spool/cron <br/>/var/spool/cron/crontab</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Job configuration</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/crontab <br/>/etc/cron.d <br/>/etc/cron.hourly <br/>/etc/cron.daily <br/>/etc/cron.weekly <br/>/etc/cron.monthly</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Cron security</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/cron.deny <br/>/etc/cron.allow</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">A user’s cron jobs are usually stored in <i>/var/spool/cron/crontab/USER</i>, and system-wide cron jobs are defined at <i>/etc/crontab</i>. Directories such as <i>/etc/cron.hourly</i>, <i>/etc/cron.daily</i>, <i>/etc/cron.weekly</i>, and <i>/etc/cron.monthly</i> contain shell scripts executed by the Cron process, and the <i>/etc/crontab</i> file defines the intervals at which scripts in these directories are executed.</p>&#13;
<p class="TX">System administrators can restrict users from creating cron jobs. Two access control files define who can run the <span class="SANS_TheSansMonoCd_W5Regular_11">crontab</span> command: <i>/etc/cron.allow</i> and <i>/etc/cron.deny</i>. If the <i>/etc/cron.allow</i> file exists, users listed in this file will be able to schedule tasks with Cron. If it doesn’t exist, all users can schedule <span role="doc-pagebreak" epub:type="pagebreak" id="pg_193" aria-label="193"/>tasks except for any user listed in <i>/etc/cron.deny</i>. If neither file exists, only privileged users can schedule tasks. If a user is listed in both the allow and deny files, the user will still be able to schedule tasks.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
<h3 class="H2" id="sec35"><span id="h2-130"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">At</span></h3>&#13;
<p class="TNI1"><i>At</i> is another job-scheduling tool in Linux, though it’s less common than Cron and uses a simpler approach. It works by specifying the shell command in the <span class="SANS_TheSansMonoCd_W5Regular_11">at</span> prompt or piping the command to <span class="SANS_TheSansMonoCd_W5Regular_11">at</span> as standard input by using <span class="SANS_TheSansMonoCd_W5Regular_11">|</span>. The following example uses the <span class="SANS_TheSansMonoCd_W5Regular_11">at</span> prompt to schedule a task:</p>&#13;
<pre><code>$ <b>at now + 1 minute</b>&#13;
&#13;
warning: commands will be executed using /bin/sh&#13;
at Sat May 27 22:15:00&#13;
at&gt; <b>rm -rf /home/user/.bash_history</b>&#13;
</code></pre>&#13;
<p class="TX">We start by specifying the schedule, using <span class="SANS_TheSansMonoCd_W5Regular_11">now</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> <span class="SANS_TheSansMonoCd_W5Regular_11">1 minute</span> to tell At to run commands one minute from now. At also takes in schedule syntax in additional formats. Here are a few examples of schedule definitions:</p>&#13;
<pre><code>$ <b>at 22:00</b>&#13;
$ <b>at 11pm + 3 days</b>&#13;
$ <b>at tomorrow</b>&#13;
$ <b>at Sunday</b>&#13;
$ <b>at May 27 2050</b>&#13;
</code></pre>&#13;
<p class="TX">The first example schedules commands to run at 10 <small>PM</small> in military time. The second example runs at 11 <small>PM</small> three days from today. The third example runs commands tomorrow at the current time, and the fourth on Sunday at the current time. The final example runs on May 27, 2050.</p>&#13;
<p class="TX">After specifying the time, At will drop your shell into a dedicated command prompt (<span class="SANS_TheSansMonoCd_W5Regular_11">at&gt;</span>), where you can enter shell commands line by line. To save the job, use <small>CTRL</small>-D.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">at</span> command also provides a way to see the queue of jobs (by using <span class="SANS_TheSansMonoCd_W5Regular_11">atq</span>) and remove them (by using <span class="SANS_TheSansMonoCd_W5Regular_11">atrm</span>). To list all queued At jobs, run the following command:</p>&#13;
<pre><code>$ <b>atq</b>&#13;
&#13;
1 Sun May 28 22:20:00 a root&#13;
2 Sun May 29 23:20:00 a root&#13;
</code></pre>&#13;
<p class="TX">Each job has an ID (<span class="SANS_TheSansMonoCd_W5Regular_11">1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">2</span> in this case), the time at which they will execute, and the user who scheduled it. After a job is submitted, you can generally find the job definition located under <i>/var/spool/cron/atjobs</i>:</p>&#13;
<pre><code>$ <b>ls -l /var/spool/cron/atjobs/</b>&#13;
total 8&#13;
-rwx------ 1 root daemon 2405 May 28 02:32 a0000101ac9454&#13;
-rwx------ 1 root daemon 2405 May 28 02:32 a0000201ac9454&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_194" aria-label="194"/>By default, unprivileged users cannot read this directory. Other possible At job directories include <i>/var/spool/cron/atspool</i>, <i>/var/spool/at</i>, and <i>/var/spool/ at/spool</i>.</p>&#13;
<p class="TX">You can remove queued jobs by using <span class="SANS_TheSansMonoCd_W5Regular_11">atrm</span> followed by the job ID:</p>&#13;
<pre><code>$ <b>atrm 1</b></code></pre>&#13;
<p class="TX">Like Cron, At uses deny (<i>/etc/at.deny</i>) and allow (<i>/etc/at.allow</i>) files to determine which users can schedule jobs.</p>&#13;
<p class="HeadAExercise"><span id="exe-14"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 14: Writing a Cron Job Script to Find Credentials</span></p>&#13;
<p class="TNI1">The objective of this exercise is to write a monitoring cron job script. This script should periodically search the system for files containing credentials. Create a cron job to do the following:</p>&#13;
<p class="NLF">  1.  Run every 10 minutes, every day of the week, all year.</p>&#13;
<p class="NL">  2.  Look for files containing the words <i>username</i> or <i>password</i> under the <i>/tmp</i> directory.</p>&#13;
<p class="NLL">  3.  When such a file is found, run <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> on the line containing the strings to write only the strings to a writable location of your choice.</p>&#13;
<p class="TX">To test your script, you can create a fake file containing the string <span class="SANS_TheSansMonoCd_W5Regular_11">username=administrator</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">password=12345</span> and save it into the <i>/tmp</i> directory. If your cron job is working as expected, you should be able to see these two strings in the destination directory.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
<h2 class="H1" id="sec36"><span id="h1-68"/><span class="SANS_Futura_Std_Bold_B_11">Hardware</span></h2>&#13;
<p class="TNI1">You can collect hardware-related information, such as memory allocation details, the number of CPUs and cores, and the manufacturer of hardware components such as the motherboard, network card, and other peripherals. To collect these details, you use commands such as <span class="SANS_TheSansMonoCd_W5Regular_11">lshw</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">dmidecode</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">hwinfo</span>.</p>&#13;
<p class="TX">These commands may show only partial information when run using a nonprivileged user, because they often read from system files accessible only to the <i>root</i> user. They also may not necessarily be installed by default, so you might have to manually gather hardware information by looking at specific files and directories under <i>/proc</i>, <i>/dev</i>, and <i>/sys</i>.</p>&#13;
<p class="TX">Let’s take a look at the output we get by running <span class="SANS_TheSansMonoCd_W5Regular_11">lshw</span> on one of the lab machines, such as <i>p-web-01</i> (172.16.10.10):</p>&#13;
<pre><code>$ <b>lshw</b></code></pre>&#13;
<p class="TX">Remember that our lab is virtual, so the output may not accurately report the underlying physical hardware, such as the size of the memory, motherboard vendor, and sound card.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_195" aria-label="195"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">lshw</span> command takes a <span class="SANS_TheSansMonoCd_W5Regular_11">-class</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">-C</span>) argument, which allows you to view specific classes of hardware, such as disk (<span class="SANS_TheSansMonoCd_W5Regular_11">-C disk</span>), processor (<span class="SANS_TheSansMonoCd_W5Regular_11">-C cpu</span>), and network (<span class="SANS_TheSansMonoCd_W5Regular_11">-C network</span>):</p>&#13;
<pre><code>$ <b>lshw -C disk</b>&#13;
&#13;
  *-disk&#13;
       description: ATA Disk&#13;
       product: VBOX HARDDISK&#13;
       vendor: VirtualBox&#13;
       size: 80GiB (86GB)&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">In this disk example, you can see that the vendor name is VirtualBox, which hints that we ran this command in a virtual machine.</p>&#13;
<p class="TX">Hardware utilities gather information from various files. <a href="chapter8.xhtml#tab8-6">Table 8-6</a> compiles some of the files and directories from which these tools aggregate hardware information.</p>&#13;
<p class="TT" id="tab8-6"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 8-6:</span></span> <span class="SANS_Futura_Std_Book_11">Hardware Information Locations in the Filesystem</span></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Virtual filesystem</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Files and directories</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/proc</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/proc/bus/usb/devices <br/>/proc/dma <br/>/proc/interrupts <br/>/proc/partitions <br/>/proc/modules <br/>/proc/cpuinfo <br/>/proc/devices-tree <br/>/proc/devices <br/>/proc/efi/systab <br/>/proc/ide <br/>/proc/kcore <br/>/proc/mounts <br/>/proc/net/dev <br/>/proc/scsi <br/>/proc/sys <br/>/proc/sys/abi <br/>/proc/sys/dev/sensors</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/sys</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/sys/bus <br/>/sys/class <br/>/sys/devices <br/>/sys/firmware <br/>/sys/firmware/dmi/tables/DMI</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/dev</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/dev/cdrom<br/>/dev/input<br/>/dev/fb*<br/>/dev/machines<br/>/dev/snd<br/>/dev/mem<br/>/dev/scsi*</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec37">&#13;
<h2 class="H1" id="sec37"><span id="h1-69"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_196" aria-label="196"/><span class="SANS_Futura_Std_Bold_B_11">Virtualization</span></h2>&#13;
<p class="TNI1">Administrators could install an operating system directly on a physical server or run a hypervisor (such as VirtualBox, Microsoft Hyper-V, or VMware ESXi) to host multiple virtual machines on the same hardware. Alternatively, they might use containerization technology to run virtual servers as containers.</p>&#13;
<p class="TX">Determining whether an environment is virtual or physical is often important in the context of defense evasion. For example, malicious software often implements checks for virtual environments so they can evade reverse engineering attempts, since analysts often examine malware in such virtual environments.</p>&#13;
<p class="TX">As in previous scenarios, we can use dedicated tools as well as living-off-the-land approaches to find this information. We’ll explore both options.</p>&#13;
<section epub:type="division" aria-labelledby="sec38">&#13;
<h3 class="H2" id="sec38"><span id="h2-131"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Dedicated Tools</span></h3>&#13;
<p class="TNI1">Tools such as <span class="SANS_TheSansMonoCd_W5Regular_11">virt-who</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">virt-what</span> can examine a system to determine whether it is physical or virtual. Here is the output of <span class="SANS_TheSansMonoCd_W5Regular_11">virt-what</span> when run on Kali in VirtualBox:</p>&#13;
<pre><code>$ <b>sudo apt install -y virt-what</b>&#13;
$ <b>sudo virt-what</b>&#13;
&#13;
virtualbox&#13;
kvm&#13;
</code></pre>&#13;
<p class="TX">Another useful tool, <span class="SANS_TheSansMonoCd_W5Regular_11">systemd-detect-virt</span>, offers a comprehensive list of enumeration techniques to identify virtual environments for systemd-based systems. It can fingerprint numerous hypervisors and container runtime environments, a list of which you can find here: <i><a href="https://www.freedesktop.org/software/systemd/man/systemd-detect-virt.html">https://www.freedesktop.org/software/systemd/man/systemd-detect-virt.html</a></i>.</p>&#13;
<p class="TX">Try running <span class="SANS_TheSansMonoCd_W5Regular_11">systemd-detect-virt</span> on any of the lab machines to see the output:</p>&#13;
<pre><code>$ <b>systemd-detect-virt</b>&#13;
&#13;
docker&#13;
</code></pre>&#13;
<p class="TX">Using the <span class="SANS_TheSansMonoCd_W5Regular_11">dmesg</span> command, you can also read virtualization information from the kernel ring buffer log:</p>&#13;
<pre><code>$ <b>dmesg | grep  "Detected virtualization"</b>&#13;
&#13;
[1075720.226245] systemd[1]: Detected virtualization oracle.&#13;
</code></pre>&#13;
<p class="TX">In this example, <span class="SANS_TheSansMonoCd_W5Regular_11">oracle</span> is the virtualization software, as we’re running VirtualBox, which is developed and maintained by Oracle.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec39">&#13;
<h3 class="H2" id="sec39"><span id="h2-132"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_197" aria-label="197"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Living Off the Land</span></h3>&#13;
<p class="TNI1">Let’s highlight a few of the ways we can determine whether a system is running virtually.</p>&#13;
<p class="TX">The Desktop Management Interface (DMI) is a management and tracking framework for hardware and software in a system. Under the <i>/sys/class/dmi/id</i> directory, a few files related to DMI could give away information about the various virtualization vendors. These files include <i>product_name</i>, <i>sys_vendor</i>, <i>board_vendor</i>, <i>bios_vendor</i>, and <i>product_version</i>. Take a look at their contents:</p>&#13;
<pre><code>$ <b>cat /sys/class/dmi/id/product_name</b>&#13;
VirtualBox&#13;
&#13;
$ <b>cat /sys/class/dmi/id/board_vendor</b>&#13;
Oracle Corporation&#13;
</code></pre>&#13;
<p class="TX">The file <i>/sys/hypervisor/type</i> might also hint at the underlying hypervisor. For example, The Xen hypervisor might insert the value <span class="SANS_TheSansMonoCd_W5Regular_11">xen</span> in that file, whereas Microsoft Hyper-V would use <span class="SANS_TheSansMonoCd_W5Regular_11">Hyper-V</span>.</p>&#13;
<p class="TX">Another file, accessible only to the <i>root</i> user, <i>/proc/1/environ</i>, may contain an environment variable named <span class="SANS_TheSansMonoCd_W5Regular_11">container=</span> with relevant information. For example, Linux containers may use <span class="SANS_TheSansMonoCd_W5Regular_11">container=lxc</span>, while Podman containers may use <span class="SANS_TheSansMonoCd_W5Regular_11">container=podman</span>.</p>&#13;
<p class="TX">Some container technologies, including Podman and Docker, use <i>env</i> files placed in specific locations. The existence of either of these would indicate a container environment:</p>&#13;
<div class="spc">&#13;
<p class="ListPlain"><i>/run/.containerenv</i></p>&#13;
<p class="ListPlain"><i>/.dockerenv</i></p>&#13;
</div>&#13;
<p class="TX">On systemd systems, the <i>/run/systemd/container</i> file may exist:</p>&#13;
<pre><code>$ <b>cat /run/systemd/container</b>&#13;
&#13;
Docker&#13;
</code></pre>&#13;
<p class="TX">Try running this command in any of the lab machines you have access to.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec40">&#13;
<h2 class="H1" id="sec40"><span id="h1-70"/><span class="SANS_Futura_Std_Bold_B_11">Automating Information Gathering with LinEnum</span></h2>&#13;
<p class="TNI1">By now, you should realize that valuable information can live anywhere on the operating system. To efficiently cover certain base areas, including users and groups, cron jobs, processes, and so on, we can run information-gathering scripts, which rely on the predictability of file locations and common search patterns.</p>&#13;
<p class="TX"><i>LinEnum</i> is a local information-gathering shell script used to automatically gather data from a host. It covers collection areas such as system information, user information, services and processes, versions, and privileges.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_198" aria-label="198"/>Let’s use LinEnum to collect files locally in an automated fashion. First, we need to get LinEnum onto the compromised machine. As it’s a single shell script file, we can simply copy and paste it into a new file on the machine. Copy the content of <i>/home/kali/tools/LinEnum.sh</i> and save the file as <i>LinEnum.sh</i> on the compromised machines.</p>&#13;
<p class="TX">Now run LinEnum with <span class="SANS_TheSansMonoCd_W5Regular_11">-t</span> (thorough collection) and <span class="SANS_TheSansMonoCd_W5Regular_11">-r</span> (report) to specify a file to send the output to:</p>&#13;
<pre><code>$ <b>chmod u+x LinEnum.sh</b>&#13;
$ <b>./LinEnum.sh -t -r report.txt</b>&#13;
&#13;
#########################################################&#13;
# Local Linux Enumeration &amp; Privilege Escalation Script #&#13;
#########################################################&#13;
<var>--snip--</var>&#13;
[-] Debug Info&#13;
[+] Report name = report.txt&#13;
[+] Thorough tests = Disabled&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">Read through the findings to see the kind of information that was collected. In the following exercise, you’ll read LinEnum’s code, build new functionality, and tailor it to your needs.</p>&#13;
<p class="HeadAExercise"><span id="exe-15"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 15: Adding Custom Functionality to LinEnum</span></p>&#13;
<p class="TNI1">During penetration testing, you may find yourself repurposing proof-of-concept exploit code and scripts to suit a particular use case. This is an important skill to master because if you can avoid writing scripts from scratch, you can save a lot of time.</p>&#13;
<p class="TX">In this exercise, your goal is to modify the LinEnum source code to build new features into it:</p>&#13;
<p class="NLF">  1.  Carefully read the LinEnum script’s source code. While it contains roughly 1,300 lines, it should be pretty simple to understand because it follows a consistent pattern, such as executing commands and then saving the output to variables.</p>&#13;
<p class="NL">  2.  Modify the source code to collect the content of files that you are interested in and that it doesn’t already collect. Alternatively, implement your own idea for a new feature.</p>&#13;
<p class="NLL">  3.  Add another command line option to LinEnum to compress (<span class="SANS_TheSansMonoCd_W5Regular_11">-c</span>) the report into a <i>tar.gz</i> file by using the <span class="SANS_TheSansMonoCd_W5Regular_11">tar</span> command.</p>&#13;
<p class="TX">Reading foreign code is just as important as writing code. Everyone has their own style of writing and way of implementing logic, and you can learn a lot about the internal plumbing of tools as well as ways to tailor them to your needs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec41">&#13;
<h2 class="H1" id="sec41"><span id="h1-71"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_199" aria-label="199"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h2>&#13;
<p class="TNI1">In this chapter, we highlighted the major categories of data collection you can conduct on a compromised host, such as the operating system and kernel, adjacent networks and connections, running processes and user activity sessions, environment data, user and group identities, system and third-party logfiles, and configuration files. In addition, we used Cron and At to schedule the execution of shell scripts.</p>&#13;
<p class="TX">As you progress through the book, you’ll continue collecting data to aid with privilege escalation, credential access, and other nefarious hacking activities.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>