- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bench Time: Fault Injection Lab'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Fault injection is a wonderful method of attacking embedded systems, and this
    chapter focuses on its practical aspects. We describe not only how to perform
    the actual injection, but how to get started on your own. While you could perform
    fault injections on a huge world of devices, we concentrate on a few specific
    examples here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We present our fault injection attacks in three acts, and these acts will be
    relatively reproducible. With the same hardware, you should expect to be able
    to achieve the given results. The first act demonstrates how to use a spark to
    inject a fault into a device. We write a program that includes a simple loop and
    then show how to inject a glitch into the loop. The second act applies two different
    fault injection methods: crowbar injection and mux (multiplexor) injection. Finally,
    the third act applies fault injection to corrupt the otherwise perfect and secure
    math that underpins modern cryptography.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-1](#figure6-1) is a diagram showing all of these acts (this same
    diagram appears in Chapter 4 as Figure 4-3).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f06001](image_fi/278748c06/f06001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: The connections between PC, fault injector, and target'
  prefs: []
  type: TYPE_NORMAL
- en: Remember when reading through the examples that all these acts will have the
    same components. A *target* will be running some code that we will insert the
    fault into, but the three acts will all use different targets. The *fault injector*
    will be how we insert the fault; we’ll show you a few different fault injectors
    as well in the different acts. Finally, a *PC* will be involved to monitor or
    control the entire operation.
  prefs: []
  type: TYPE_NORMAL
- en: The actual connections between devices will vary between the acts. In the first
    act, for example, we won’t need precise timing. This means the “trigger” signal
    in [Figure 6-1](#figure6-1) may be optional; one of the fault injectors we’ll
    use won’t have any sort of trigger at all. In later acts, we’ll have more precise
    timing requirements, so the trigger signal will be used to delay the fault such
    that it is inserted at a very specific point in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Act 1: A Simple Loop'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll start with the most basic glitch you can perform to show how you might
    start fault injection on a new target. A typical task when facing a new device
    is to run very simple loop code (see [Listing 6-1](#listing6-1)) on the target
    device.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-1: This simple C code is a good first example to glitch.'
  prefs: []
  type: TYPE_NORMAL
- en: This code has several features designed to make glitching easy. Three variables,
    at 1 and 2, are declared `volatile`, providing lots of static RAM (SRAM) access
    and thereby an attack surface. An optional `trigger_high()` command 3 can be used
    to trigger external hardware to insert a glitch. The double-loop structure 4 offers
    many opportunities for glitching to affect the program. If a variable is corrupted
    or an instruction is skipped, the result will be that the variables `i`, `j`,
    and `cnt` could all have incorrect values. Their values are printed 5 so you can
    see the results of your fault injection.
  prefs: []
  type: TYPE_NORMAL
- en: The `cnt` variable is the most likely to be noticeably corrupted. If the value
    of `j` is corrupted, for example, it will be observed as a corrupt value only
    if the corruption happens to occur on the last iteration of the outer loop over
    `i`. This simple loop not only shows whether you’re injecting faults, but you
    also can see various types of faults by observing how the output changes.
  prefs: []
  type: TYPE_NORMAL
- en: You may need to modify the code in [Listing 6-1](#listing6-1) slightly to compile
    on your target platform, but it’s designed to have minimal requirements besides
    a simple string print command.
  prefs: []
  type: TYPE_NORMAL
- en: How do you actually perform an attack on a simple loop? This is a lab chapter
    after all. We’ll show you three methods of performing the attack, all for around
    $50 worth of hardware, but you might already have some of the needed gear on hand
    anyway. The first method uses an Arduino as a target device and a BBQ lighter
    to insert a fault. The next two methods will be based on voltage glitching; we’ll
    show you how to generate a voltage glitch using both a crowbar and a multiplexor
    circuit. To drive these circuits, we’ll make use of the ChipWhisperer-Nano (or
    ChipWhisperer-Lite) in this lab, but you can drive the circuits from other pulse
    sources. Let’s get faultin’ (as they say).
  prefs: []
  type: TYPE_NORMAL
- en: A BBQ Lighter of Pain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is probably the more dangerous one, but for absolute cheapness,
    it’s hard to beat. We need to compile the code from [Listing 6-1](#listing6-1)
    onto an Arduino. That code is almost ready as is. You need to set up the serial
    port first, and then replace the `puts()` call with `Serial.write()`. You may
    want to adjust the loop iteration counters to make the output slower as well (see
    [Figure 6-2](#figure6-2)). The program also marks successful glitches for you.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06002](image_fi/278748c06/f06002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: Implementing the code on an Arduino Metro Mini'
  prefs: []
  type: TYPE_NORMAL
- en: We’re using the Arduino Metro Mini for this example, Adafruit part number 2590,
    because it has an ATmega328P in a QFN package. We need the QFN package because
    it has the least amount of material between the top of the chip surface (where
    we are generating our electromagnetic glitch pulse) and the die itself. An ATmega328P
    in a DIP package, for example, will be too thick, and you likely won’t have as
    much success, if any at all.
  prefs: []
  type: TYPE_NORMAL
- en: The isolator on the right in [Figure 6-3](#figure6-3) is from Adafruit, part
    number 2107, but you could use any other isolator or even just an isolated serial
    port. The fault injection method also can easily damage your target device since
    you’ll be playing with very high voltages!
  prefs: []
  type: TYPE_NORMAL
- en: '![f06003](image_fi/278748c06/f06003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-3: An isolator from Adafruit (PCB on the right) and our target (PCB
    on the left)'
  prefs: []
  type: TYPE_NORMAL
- en: Alright, enough warning. If you rip open a BBQ lighter, you will find the piezoelectric
    ignitor, as shown in [Figure 6-4](#figure6-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06004](image_fi/278748c06/f06004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-4: A piezoelectric ignitor generates a high voltage.'
  prefs: []
  type: TYPE_NORMAL
- en: This element generates a high voltage (careful not to shock yourself) when the
    plunger on the right end is depressed into the housing until a click is heard.
    If you carefully bend the high voltage wire (that is, the wire that would go to
    the BBQ lighter end) to be near the end cap, it will generate a spark. In our
    case, we’ve routed the two wires to make a small spark gap, maybe in the 0.5 mm
    to 2 mm range. The gap is held in place by some polyimide tape.
  prefs: []
  type: TYPE_NORMAL
- en: This alone is enough to provide a fault injection mechanism. We’ll try to force
    the spark to be generated somewhere “interesting” in our attack on an Arduino.
    The spark gap is placed above a surface mount Arduino package (see [Figure 6-5](#figure6-5)).
  prefs: []
  type: TYPE_NORMAL
- en: The polyimide tape (Adafruit part number 3057, and often sold under the Kapton
    brand name) on top of the chip insulates it. If the spark connects to the microcontroller
    pins, you’ll kill the device instantly, and if your isolator isn’t working or
    you exceed the voltage limits, you may also kill the computer.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06005](image_fi/278748c06/f06005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-5: Polyimide tape helps (but doesn’t fully stop) our device from blowing
    up due to the high voltage.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, run the program and start sparking. With any luck, you’ll get some corrupted
    output, as shown on the screen in [Figure 6-2](#figure6-2). You also may see some
    resets if the overall counter resets back to zero. While still a bit of a fault,
    this is not the interesting kind of fault you’ll want. A reset means your fault
    is too powerful; try adding some spacing between the spark gap or changing the
    location.
  prefs: []
  type: TYPE_NORMAL
- en: This act has briefly shown how a simple loop and a spark can insert a fault
    into a device. Where timing is not important, such sparks can result in useful
    attacks. In Arun Magesh’s blog post “Bypassing Android MDM Using Electromagnetic
    Fault Injection by a Gas Lighter for $1.5,” this type of attack is used on a smartphone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Act 2: Inserting Useful Glitches'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maybe you aren’t willing to kill your target device or computer, in which case,
    you’ll need some more subtle fault injection methods. In this act, we describe
    using a fault injection attack on a read protection configuration word stored
    in flash in a device. If we manage to change this configuration word, it allows
    reading out flash contents we should normally not have access to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two less-aggressive-yet-not-less-effective fault injection methods we apply
    in this second act are crowbar glitching and mux (multiplexor) fault injection.
    We also introduce a new glitching target: the Olimex LPC-P1114 development board.
    The development board’s user manual will help you understand the modifications
    and interconnections we describe here.'
  prefs: []
  type: TYPE_NORMAL
- en: The glitching method used in this act can achieve the same glitch using the
    simple loop test code in the Arduino microprocessor that we glitched in the previous
    section. If you want to test a glitch setup, we recommend starting with the simple
    loop code from [Listing 6-1](#listing6-1) being compiled for the target. To avoid
    such repetition in this book, however, we’ll jump directly to the end goal, which
    is corruption of the security configuration. Now let’s walk through how to actually
    see some sort of useful glitch!
  prefs: []
  type: TYPE_NORMAL
- en: Crowbar Glitching to Fault a Configuration Word
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll apply the crowbar glitching method to fault a configuration word on the
    microcontroller (see Chapter 5 for an introduction to crowbar glitching). This
    will build on Chris Gerlinsky’s presentation “Breaking Code Read Protection on
    the NXP LPC-Family Microcontrollers” (REcon Brussels 2017), which covered the
    initial work, including details of how the fault works and can be generated. Here,
    we show a slightly easier method of injecting the fault, which is to attach a
    “crowbar” across the power supply. This method has been demonstrated to work against
    a variety of devices, including more advanced targets like the Raspberry Pi and
    field-programmable gate array (FPGA) boards. For more details, see Colin O’Flynn’s
    “Fault Injection Using Crowbars on Embedded Systems” (IACR Cryptology ePrint Archive,
    2016), which introduced the crowbar fault injection method.
  prefs: []
  type: TYPE_NORMAL
- en: The end goal is to attack the code read-protection, which is the mechanism that
    prevents someone from copying the binary code out of the device. In the LPC device,
    the code read-protection is a special word in memory that defines what level of
    protection the microcontroller has. These code read-protection bytes are part
    of the “option bytes” that contain various configurations for the microcontroller.
    [Table 6-1](#table6-1) lists the potential valid values for the option bytes as
    related to the code read-protection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-1: Valid Values for the Option Bytes as Related to the Code Read-Protection'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mode** | Option bytes value | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NO_ISP | 0x4E697370 | Disables the “ISP Entry” pin. |'
  prefs: []
  type: TYPE_TB
- en: '| CRP1 | 0x12345678 | SWD interface is disabled. Partial flash updates are
    allowed only via ISP. |'
  prefs: []
  type: TYPE_TB
- en: '| CRP2 | 0x87654321 | SWD interface is disabled. Must perform full chip erase
    before most other commands are available. |'
  prefs: []
  type: TYPE_TB
- en: '| CRP3 | 0x43218765 | SWD interface is disabled; ISP interface is disabled.
    Device is inaccessible unless user implements call to bootloader via alternate
    method. |'
  prefs: []
  type: TYPE_TB
- en: '| UNLOCKED | Any other value | No protection enabled (full JTAG and bootloader
    access). |'
  prefs: []
  type: TYPE_TB
- en: The critical flaw in the design is that the “unlocked” level is the default,
    and only when the word is set to one of several specific values do you have code
    read-protection. This means if you were to corrupt the value of the code read-protection
    word in flash, you have no code protection at all! We can use a glitch to corrupt
    this value as it is being read from flash. Let’s see what you need for this.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Equipment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, we need a target device (mounted on a target board) on which to attempt
    to break the code read-protection, and, second, we need a tool capable of inserting
    the faults to cause the program to read a value incorrectly and remove the read-protection.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-6](#figure6-6) shows a sample setup. The LPC1114 target board is
    at the top of the photograph, and the ChipWhisperer-Nano (used for performing
    fault injection) is at the bottom of the photograph, which is where you can see
    the interconnection between the two (more details on this interconnection shortly).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f06006](image_fi/278748c06/f06006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-6: The LPC1114 processor target with a ChipWhisperer-Nano for performing
    fault injection'
  prefs: []
  type: TYPE_NORMAL
- en: Besides the ChipWhisperer-Nano providing the programming and timing of the injected
    fault, its only real feature we are using is a simple “crowbar” mechanism, which
    you could substitute if you wish to with an external MOSFET or similar.
  prefs: []
  type: TYPE_NORMAL
- en: ChipWhisperer-Nano vs. ChipWhisperer-Lite
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re using the ChipWhisperer-Nano due its lower cost ($50), even though it
    has more limited resolution on the glitch timing than what the ChipWhisperer-Lite
    ($250) has. The ChipWhisperer-Lite tends to be more reliable for this attack.
  prefs: []
  type: TYPE_NORMAL
- en: If you use the ChipWhisperer-Nano connected as shown in [Figure 6-6](#figure6-6),
    remember that the ChipWhisperer-Nano has a built-in STM32F0 microcontroller that’s
    used as a target. You can remove the target side (it’s designed to be scored and
    broken off), but the less-destructive option is simply to erase it. For the attack
    we are about to do, the physical presence of the STM32F0 target doesn’t affect
    our usage. We just need to ensure it’s not running code that would get in the
    way of our I/O lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a short example of how to do this in Python using the Jupyter Notebook
    interface (see the notebook for this chapter at [https://nostarch.com/hardwarehacking/](https://nostarch.com/hardwarehacking/)
    for more detail):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we just erase the flash of the device using the bootloader interface
    to ensure the serial data lines are free. If we had code running on the ChipWhisperer-Nano
    target, it might corrupt our bootloader access.
  prefs: []
  type: TYPE_NORMAL
- en: Modifications and Interconnections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The nice thing about this attack is how dead simple we can make it. We need
    to create a momentary short across the power supply to the LPC1114 target, so
    we make a few modifications on the LPC1114 development board’s PCB. Basically,
    we need a connection from the crowbar mechanism to the power rails, and we must
    remove the capacitors that otherwise would smooth out glitches on those power
    rails. We aim for a circuit, as shown in the schematic in [Figure 6-7](#figure6-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06007](image_fi/278748c06/f06007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-7: Schematic showing part of the LPC1114 development kit'
  prefs: []
  type: TYPE_NORMAL
- en: The schematic shows the GLITCH connection to indicate how we insert the fault.
    The actual Q1 component is built into the ChipWhisperer-Nano in the example we
    are providing, but if you want to implement this function separately, you could
    route the power to a similar fault injection module, such as a MOSFET driven by
    a signal generator. [Figure 6-8](#figure6-8) shows the physical implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06008](image_fi/278748c06/f06008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-8: The LPC1114 development board modified for fault injection'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list provides the step-by-step instructions for making the modifications
    on the development board shown in [Figure 6-8](#figure6-8):'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the decoupling capacitor C4 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the decoupling capacitor C1 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disconnect the 3.3 V CORE_E VDD from the LPC1114 by cutting through trace jumper
    3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disconnect the 3.3 V IO_E VDD from the LPC1114 by cutting through trace jumper
    4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert a 12 Ω resistor across the trace jumper 3. The PCB power supply VDD now
    runs through this resistor to the LPC1114.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the “chip side” of the 3.3 V CORE_E VDD and 3.3 V IO_E VDD power supplies
    together using a link 5, going from a pad of the trace jumper 4 and a pad of the
    capacitor placement C4 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the 3.3 V CORE_E VDD and 3.3 V IO_E VDD power supplies to a connector
    7 together using a link 6 (here the connector is an SMA connector, but any type
    works).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set PIO0_1 to ground just by mounting the header at BLD_E 9.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set PIO0_3 to GND, which requires soldering a wire (the short orange wire a)
    to ground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a three-pin header at 8 and route the RST connection to all of these three
    pins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the nReset OUT line from the ChipWhisperer at J3-5 and the Trigger In
    line at J3-16 to the RST input on the development board with the header you mounted
    at 8.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect GND from the ChipWhisperer at J3-2 to pin UEXT-2 on the development
    board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect VCC from the ChipWhisperer at J3-3 to pin UEXT-1 on the development
    board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect TXD from the ChipWhisperer at J3-10 to pin UEXT-3 on the development
    board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect RXD from the ChipWhisperer at J3-12 to pin UEXT-4 on the development
    board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Table 6-2](#table6-2) provides a summary of the interconnections between the
    target and the ChipWhisperer-Nano. (You should also be able to determine the interconnections
    for a standalone type of attack from this list.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-2: Interconnections of ChipWhisperer-Nano Board to Glitch Generator'
  prefs: []
  type: TYPE_NORMAL
- en: '| **LPC1114 development board** | **ChipWhisperer-Nano** | **Description**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| UEXT-1 | J3-3 | VCC |'
  prefs: []
  type: TYPE_TB
- en: '| UEXT-2 | J3-2 | GND |'
  prefs: []
  type: TYPE_TB
- en: '| UEXT-3 | J3-10 | TXD |'
  prefs: []
  type: TYPE_TB
- en: '| UEXT-4 | J3-12 | RXD |'
  prefs: []
  type: TYPE_TB
- en: '| RST | J3-5 | Reset OUT |'
  prefs: []
  type: TYPE_TB
- en: '| RST | J3-16 | Trigger in |'
  prefs: []
  type: TYPE_TB
- en: '| VCC_CORE | Glitch connector middle pin | VCC glitch inserted here |'
  prefs: []
  type: TYPE_TB
- en: '| GND | Glitch connected side pin | Second GND (for glitch) |'
  prefs: []
  type: TYPE_TB
- en: The RST line on the development board is both an output (gets toggled to reset
    the device) and an input (serves as a reference for when to insert the fault),
    which is required because the ChipWhisperer-Nano uses GPIO4 as the trigger input.
  prefs: []
  type: TYPE_NORMAL
- en: The Timing Is Everything
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As the LPC1114 device is coming out of reset, it will read the configuration
    word from flash memory, and we need to insert our fault at that moment. If we
    can corrupt the read of the memory, the device will come up as unlocked, which
    isn’t what the designer intended.
  prefs: []
  type: TYPE_NORMAL
- en: We use the reset pin to time the fault. The rising edge of the reset pin (since
    the reset is active-low) indicates when the boot sequence begins. If you were
    controlling everything from a single device (such as your own FPGA or microcontroller),
    you could, of course, time the glitch based on when you drove the reset pin high.
  prefs: []
  type: TYPE_NORMAL
- en: The reset pin tells us only when the device begins the boot process, but not
    the finishing time and not at what point the value of the code read-protection
    is fetched from flash memory. We’ll need to sweep the glitch insertion from the
    start of the boot until the boot is finished to target every possible clock cycle
    when the flash read could be happening.
  prefs: []
  type: TYPE_NORMAL
- en: While the reset pin gives us the starting time, we would like to have a finishing
    time when we know the device is finished booting (and if we didn’t break code
    protection by then, the glitch was clearly ineffective). To determine this “ending
    time,” we could write a simple program that toggles an I/O pin and load it onto
    the microcontroller. When the I/O pin starts toggling, we know the microcontroller
    is running our own code and the booting has completed.
  prefs: []
  type: TYPE_NORMAL
- en: The boot time is thus the time between the reset pin becoming inactive (going
    high) and the I/O pin toggling. Somewhere between the reset pin going high and
    the I/O pin toggling is when the microcontroller boot code must be reading the
    read-protect value from flash memory and acting on the value. Our glitch must
    be targeted somewhere in that time frame.
  prefs: []
  type: TYPE_NORMAL
- en: Bootloader Protocol
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To understand how to find a useful glitch, here’s a short primer on the bootloader
    in this device. We’ll use the bootloader to determine whether things are actually
    going according to plan.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bootloader protocol is very simple. A serial protocol is used to communicate
    with the device, allowing us to experiment with the bootloader via a serial terminal.
    The communication works as follows: we send some setup information followed by
    a read/write to memory to load and verify code.'
  prefs: []
  type: TYPE_NORMAL
- en: The protocol automatically determines the baud rate during the first character’s
    transfer. The rest of the setup confirms baud rate synchronization and informs
    the bootloader of the external crystal speed in case it’s needed for any additional
    setup. You can see some of the setup commands in the output example from [Listing
    6-3](#listing6-3), which we’ll look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Several commands erase, read, and write memory, but we care only about a memory
    read attempt, because if the device is locked, a memory read will fail. We can
    perform a memory read with `R 0 4\r\n`, which attempts to read 4 bytes from address
    0\. If the device is locked, we’ll get a response of `19`, which is the error
    code for access not being allowed. Ultimately, we need to script a method of continuously
    testing to see whether the device is unlocked.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we now need to corrupt the “option bytes” that store the code read-protection
    codes. They aren’t continuously checked, but they are read only upon reset. As
    mentioned, we need to time our attack from reset.
  prefs: []
  type: TYPE_NORMAL
- en: Device Setup
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, we need to get communication working with the bootloader. While we could
    implement the entire bootloader protocol, instead we’re going to use an existing
    library called `nxpprog` (available at [https://github.com/ulfen/nxpprog/](https://github.com/ulfen/nxpprog/))
    that can talk to these devices.
  prefs: []
  type: TYPE_NORMAL
- en: The following examples reference the companion Jupyter Notebook provided as
    part of this book’s resources, which implements the full attack and provides required
    setup details. Suggested installation instructions also are available online.
    We’ll walk through the code and attack here, though, so you can see how it works
    without needing to install anything.
  prefs: []
  type: TYPE_NORMAL
- en: The `nxpprog` library requires the `isp_mode()`, `write()`, and `readline()`
    support functions. The `isp_mode()` function enters the in-system programming
    (ISP) mode by setting an entry pin and resetting the device. In this example,
    the ISP mode entry pin is soldered to GND to force ISP mode entry (refer to [Figure
    6-8](#figure6-8)). The `isp_mode()` function simply resets the device, which begins
    a new bootloader iteration. The other two functions talk on the serial port to
    the bootloader. If a ChipWhisperer device is used, this routes data out from the
    ChipWhisperer. See the Jupyter Notebook for more details on those functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-2](#listing6-2) shows an example of attempting to connect to the
    device and read the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-2: Using `nxpprog` to connect and read memory'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-3](#listing6-3) contains the expected output with debug information
    showing the serial port `read` and `write` instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-3: The output of running the `nxpprog` connect script from [Listing
    6-2](#listing6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we get a `CODE_READ_PROTECTION_ENABLED` error, which is what we
    are looking for. If we had used a new development board, however, it wouldn’t
    yet have code read-protection enabled. This means in order to imitate the real
    world, we need to turn that on before we can continue with the tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: The read-protect code bytes are located at address 0x2FC and consist of 4 bytes.
    To program the code protection, we need to erase an entire page of memory (4,096
    bytes) and reprogram the new page with our configuration word set to enable read-protection.
    In a real situation, we would need to know what should be programmed in all other
    bytes in the page, but if we don’t need to run the code and instead are simply
    performing a proof of concept, we can program in zeros (or any other data).
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-4](#listing6-4) shows how the sample implementation defaults to
    opening the *lpc1114_first4096.bin* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-4: Erase and reprogram an entire page of memory.'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have this file, you could simply set the value of `image = [0]*4096`,
    which would overwrite the flash page with zeros (0s). This means the code will
    no longer run, but we don’t care about the code running; we care only about whether
    we can bypass the code read-protection.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-5](#listing6-5) uses the data from [Listing 6-4](#listing6-4) to
    lock the device so we can perform an attack as it would be done in the real world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-5: Locking the device using the ISP API interface'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a locked device, we can begin to investigate further and scope
    our attack.
  prefs: []
  type: TYPE_NORMAL
- en: Using Power Analysis to Determine Fault Injection Timing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this case, we’re going to cheat and begin with a “good” power waveform to
    see around what time we should be inserting our glitch. [Figure 6-8](#figure6-8)
    shows that we inserted a 12 Ω shunt resistor. Its function is not only to facilitate
    fault injection, but also to allow us to look at the power waveforms. In our crowbar
    attack example, we connect an oscilloscope across the shunt resistor and record
    the DC level of the power rail, as shown in the middle trace in [Figure 6-9](#figure6-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06009](image_fi/278748c06/f06009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-9: Power rail traces while booting'
  prefs: []
  type: TYPE_NORMAL
- en: Halfway along this trace is the glitch that the crowbar injected. The bottom
    row shows a zoomed-in look at the variations on the power rail on either side
    of the glitch, which we call the power trace. The top row shows a trace of the
    LPC1114’s reset output. The variations in the power trace make it possible to
    see different operations executed on the CPU. The specific part that we want to
    interrupt is the process of loading the word that locks the flash from memory.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, using the power trace is critical for understanding what sort
    of glitch parameters cause the device to misbehave. One thing we want to watch
    out for is too strong a glitch, which resets the device and restarts the device
    again; that would not be very informative for us!
  prefs: []
  type: TYPE_NORMAL
- en: Beyond looking at the power trace on an oscilloscope, [Listing 6-6](#listing6-6)
    shows a simple script that enables the ChipWhisperer-Nano to capture the power
    trace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-6: Python script to capture boot power trace'
  prefs: []
  type: TYPE_NORMAL
- en: The trace is shown in [Figure 6-10](#figure6-10). The higher-end ChipWhisperer-Lite
    and ChipWhisperer-Pro will provide a more detailed power trace, but even this
    $50 ChipWhisperer-Nano has enough for us to see the details of the boot process.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06010](image_fi/278748c06/f06010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-10: Power trace of the LPC1114’s boot process, as measured in [Listing
    6-6](#listing6-6)'
  prefs: []
  type: TYPE_NORMAL
- en: What does this information provide? First, it enables us to examine and characterize
    the effect of a potentially useful glitch. Second, we use the ChipWhisperer-Nano
    to trigger the glitch insertion by running the code in [Listing 6-7](#listing6-7)
    (if you’re using ChipWhisperer-Lite, see the companion notebook).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-7: Turning on a glitch on the ChipWhisperer-Nano'
  prefs: []
  type: TYPE_NORMAL
- en: In the code from [Listing 6-7](#listing6-7), the `scope.glitch.repeat` parameter
    is how many cycles the glitch is “applied” for (the glitch width from Chapter
    5). The `scope.glitch.ext_offset` parameter is the offset from the trigger event
    until the glitch is inserted, which defines the timing of where the glitch occurs.
    The parameters are somewhat “unitless” here because the numbers represent a number
    of cycles’ delay based on the microcontroller’s internal oscillator. We rarely
    care about the “actual” values; we just want to be able to re-create them.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `repeat` (glitch width) and `ext_offset` (glitch offset) settings are
    locked in, they will automatically be applied on the next trigger. If we run [Listing
    6-6](#listing6-6) again (after first having run [Listing 6-7](#listing6-7)), we
    now get a power waveform with a glitch inserted at some point. [Figure 6-11](#figure6-11)
    shows the results.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, it looks like we’re using too aggressive of a glitch inserted
    around clock cycle 250\. The glitch is probably too wide. After the glitch is
    inserted, the device seems to have muted. The power trace no longer looks like
    it’s executing code, which is bad since we have probably tripped a brown-out detector
    or otherwise reset the device. We’ll need to adjust parameters and try again.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06011](image_fi/278748c06/f06011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-11: A glitch inserted around cycle 250 has caused the device to reset.'
  prefs: []
  type: TYPE_NORMAL
- en: Compare this to when we change the value of `scope.glitch.repeat` in [Listing
    6-7](#listing6-7), setting the `repeat` to 10\. [Figure 6-12](#figure6-12) shows
    the power trace.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06012](image_fi/278748c06/f06012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-12: A glitch inserted around cycle 250 has not interrupted the normal
    boot.'
  prefs: []
  type: TYPE_NORMAL
- en: We still see the glitch inserted around cycle 250, but it seems that the device
    has continued to execute code! We want to sweep around glitch widths just between
    those that are too wide (causing a reset) and those that seem to let the device
    run as normal. This power analysis measurement allows us to characterize the board
    and understand what glitch widths we need for the next step. In this case, a width
    (`scope.glitch.repeat` setting) of 14 was about the upper limit before the device
    often would reset. This means for the sample board, we’d try widths in the range
    of 9 to 14 first (the lower end is somewhat arbitrary; you might need to reduce
    the lower end even further, but at some point, the glitch is too narrow and has
    no effect). Again, these units are relatively arbitrary; we don’t care about the
    exact measurement because we simply found the range between where the device reset
    and where the device seemed to operate normally. You may find these numbers vary
    on your target and setup.
  prefs: []
  type: TYPE_NORMAL
- en: If you are trying to re-create this glitch insertion using some other signal
    generator besides the ChipWhisperer-Nano, you can easily check with an oscilloscope
    to see whether the device is resetting after your glitch or is continuing to boot.
    Using this method, it’s easy to tune the glitch parameters to reduce the search
    space.
  prefs: []
  type: TYPE_NORMAL
- en: In future chapters, we’ll look at power analysis and how to use it to show where
    in the device program certain values are being processed. Performing a “power
    analysis attack” is possible on the configuration word in that we can measure
    when these words are actually loaded. If you’re interested in seeing that code,
    the LPC1114 example as part of ChipWhisperer-Jupyter repository on GitHub ([https://github.com/newaetech/chipwhisperer-jupyter/](https://github.com/newaetech/chipwhisperer-jupyter/))
    goes into more details.
  prefs: []
  type: TYPE_NORMAL
- en: From Fault Attack to Memory Dump
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we can see the device booting, we are basically ready to insert a fault.
    All we’ll do is make a script to sweep the timing of the glitch and see whether
    the device comes up as unlocked. If the device does come up unlocked, we can take
    the full step of dumping the entire flash memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-8](#listing6-8) shows the important parts (see the Jupyter Notebook
    for the full example). Here we specify an offset range that we can sweep along
    to find the useful information. You should know that the 100 percent success of
    the code depends on your physical connections; you may need to run this multiple
    times before it works. We’ve also cheated by giving a very narrow range of the
    offset, which helps by allowing us to repeat the attack multiple times.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-8: Sweeping the glitch width and offset while attempting to read
    the CRP status'
  prefs: []
  type: TYPE_NORMAL
- en: After each glitch attempt, an attempt is made to read from memory 1. If successful,
    the entire flash memory is read out, and you then have complete access to and
    control over the LPC1114 processor. If you don’t have success, first check the
    timing using a power trace. We empirically found that around 51µs was required
    on the LPC1114, but that will change with voltage, temperature, and production
    batch.
  prefs: []
  type: TYPE_NORMAL
- en: Also check what the glitch waveform looks like, which will vary with longer
    or shorter wires. Because the ChipWhisperer-Nano has more limited resolution on
    the glitch width and offset, the attack is less successful with any given hardware
    setup than on the ChipWhisperer-Lite. You may find you need to use longer or shorter
    wires, for example, to adjust the glitch parameters physically. But before you
    go to the effort of further tuning, let it run for some time. Letting the attack
    run for an hour or two may result in a successful parameter set, as shown in [Listing
    6-9](#listing6-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-9: Output of running script with a successful glitch'
  prefs: []
  type: TYPE_NORMAL
- en: Once the attack is successful, it’s simply a matter of performing the flash
    read, which requires looping through all memory to read out the chip. Using the
    `nxpprog` library makes this even easier; see the companion GitHub repository
    for this book for examples of achieving this task, this is linked from [https://nostarch.com/hardwarehacking](https://nostarch.com/hardwarehacking).
    You could also unlock the device by reprogramming the configuration words, which
    should even allow you to attack a device with a full lock that disables the ISP
    and JTAG.
  prefs: []
  type: TYPE_NORMAL
- en: Never mind all the possibilities; simply receiving the success message indicates
    that you were able to corrupt the configuration word and thus bypass read protection!
    If you are relying on such security methods, it’s a useful exercise to perform
    to help you understand how others might bypass them.
  prefs: []
  type: TYPE_NORMAL
- en: Mux Fault Injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve gone through an example using a crowbar, but it’s also useful to look
    at other methods of performing the voltage fault injection. The most common of
    these other methods is to use a multiplexor (mux) that switches between the regular
    operating voltage and the “glitch” voltage. The only problem with using the mux
    is that it may increase the chance of damaging the target. If you are glitching
    the device to a negative voltage, for example, you might discover that the negative
    voltage is too far out of spec. In our case, we’ll use in-range voltages to avoid
    that risk.
  prefs: []
  type: TYPE_NORMAL
- en: Mux Hardware Setup
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We discussed the mux as a fault injection method for the voltage-switching-based
    injector in Chapter 5, so see that chapter for details of how to build the fault
    injector circuitry using a multiplexor.
  prefs: []
  type: TYPE_NORMAL
- en: To use a multiplexor for this example, we use the same LPC1114 development board
    as shown in [Figure 6-8](#figure6-8), but this time without the 12 Ω shunt resistor
    that connected the input voltage to the core voltage. Remove it if it is already
    mounted. The trace must be cut so that the core voltage for the microcontroller
    is now coming entirely from an external source. We’ll be connecting the mux output
    to the core voltage of the LPC1114 development board, meaning that LPC1114 is
    always being powered from the mux output.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’re going for a two-chip solution using a complementary
    pair of analog switches: the TS12A4514 is normally open, and the TS12A4515 is
    a normally closed switch. [Figure 6-13](#figure6-13) shows the schematic for this
    solution.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f06013](image_fi/278748c06/f06013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-13: Schematic showing a simple multiplexor for mux glitching'
  prefs: []
  type: TYPE_NORMAL
- en: The TS12A4514 feeds the standard 3.3 V VCC from the ChipWhisperer-Nano through
    to the LPC1114, while the TS12A4515 feeds through a lesser voltage, as determined
    by the voltage set by the variable resistor VR1\. This means with each toggle
    of the ChipWhisperer-Nano’s I/O pin, we toggle each analog switch at pin 6 and
    cause the voltage fed through to the LPC1114 to switch between the standard VCC
    on the TS12A4514 and the adjusted VCC on the TS12A4515\. In comparison with the
    crowbar glitch schematic in [Figure 6-7](#figure6-7), only connections to VDD
    change; the serial and triggering connections remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: In our build, we stacked a TS12A4514 (bottom) and TS12A4515 (top) and soldered
    them together. The two switched voltage pins (pin 8 of U2 and U3) are the only
    pins not soldered together, as they have different connections; see [Figure 6-14](#figure6-14)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06014](image_fi/278748c06/f06014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-14: A TS12A4514 (bottom) and TS12A4515 (top) stacked (hacked) together'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-15](#figure6-15) shows the mux-based fault injection setup; we’ll
    go through the low-level details of each part next.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f06015](image_fi/278748c06/f06015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-15: The complete setup for performing a mux attack'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, note that the 12 Ω resistor has been removed from the target 1, as previously
    mentioned. For the switching-based glitch using a multiplexor, we need to specify
    two voltages: the regular voltage and the “glitch” voltage. In this case, to make
    life a bit easier, we’ll use similar voltages to those we used in the previous
    crowbar section. The regular voltage is the standard 3.3 V supply, taken off the
    JTAG connector from the LPC1114 board. The glitch voltage is similar to the crowbar
    setup where we tried to bring the power supply to ground (0 V). Going right to
    0 V might reset the device too quickly, so instead we put a variable resistor
    (VR1) in the path. Because the target device typically has some capacitance on
    the positive rails, using a resistor means the volage is not driven down to 0
    V (GND) as quickly. In the figure, we’re using a standard variable resistor 3.'
  prefs: []
  type: TYPE_NORMAL
- en: On the ChipWhisperer-Nano, we unsolder the two solder jumpers on the target
    side 2. This step is required because we’ll now be using the glitch output to
    drive the mux, but we’ll still want to use the measurement capability. By default,
    the glitch output and measurement are tied together on the target board. This
    setup was okay in the previous section when the glitch output was directly connected
    to the target voltage. Now we need to decouple the measurement and glitch from
    each other. Separating off the target side of the ChipWhisperer-Nano would accomplish
    the same goal and ensure no conflict of the I/O lines. Simply unsoldering the
    solder jumpers, however, may be less aggressive in case you still want to use
    the included target.
  prefs: []
  type: TYPE_NORMAL
- en: To trigger the mux switch, we simply need a digital I/O signal that sweeps along
    a timeline, thereby inserting a voltage switch at different points in the target’s
    boot sequence. We could use an external FPGA or signal generator, but in this
    example, we’ll use the same ChipWhisperer-Nano or ChipWhisperer-Lite glitch output
    that we used in the crowbar example. The glitch trigger output only drives low,
    so a 1 kΩ resistor pulls the line high when it is not being driven low. We can
    use this glitch trigger output as an input to the mux select line, remembering
    that it is “active-low” when we want to insert a glitch the line drives low.
  prefs: []
  type: TYPE_NORMAL
- en: The TS12A4515P switches the preset glitch voltage (as set by VR1) through to
    the LPC1114 power rail when its input (at the combined pins 6) from the ChipWhisperer-Nano
    glitch trigger is low. Conversely, the TS12A4514P switches the normal 3.3 V VCC
    through to the LPC1114 power rail when its input (also at combined pins 6) from
    the ChipWhisperer-Nano glitch trigger is high. Whenever the glitch output trigger
    from the ChipWhisperer is low, the glitch voltage is switched through to the LPC1114
    power rail by the mux, at any time and for any length of time, as programmed in
    and controlled by the ChipWhisperer.
  prefs: []
  type: TYPE_NORMAL
- en: To view the mux output together with the boot waveforms in progress at and around
    the time of the glitch, similar to what’s shown in [Figure 6-9](#figure6-9), you
    can measure pin 1 of the mux. This is essential for tuning the glitch moment and
    width. In this example, instead of relying on an oscilloscope, we set the ChipWhisperer-Nano
    to capture the power line signal, as in the crowbar example. One caveat of the
    ChipWhisperer-Nano is that it has a fixed input gain; you may find that the power
    line signal is swamping the input, making it difficult to observe. For this reason,
    a 220 Ω resistor (R3) has been inserted, which forms a voltage divider with the
    ChipWhisperer-Nano measurement input. You may need to adjust this resistor depending
    on the multiplexor you’re using. The ChipWhisperer-Lite allows adjusting the gain,
    so it does not require this same change and can directly observe the LPC1114 core
    voltage.
  prefs: []
  type: TYPE_NORMAL
- en: Tuning Glitch Settings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As in the crowbar fault injection example, we’ll need to adjust the glitch settings.
    Previously, we had to adjust only the glitch width; now we also need to adjust
    the glitch voltage. In doing so, to keep things simple, we use a variable resistor
    to adjust the glitch “strength” rather than applying a specific voltage setting.
    We tune this resistor, view or capture a power measurement again during the boot
    process, and see how inserting various different glitch voltages affects it.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using the ChipWhisperer-Nano, this means running the script shown
    in [Listing 6-6](#listing6-6). As before, you can see how to adjust the glitch
    width in [Listing 6-7](#listing6-7). Switching between a very narrow glitch (`scope.glitch.repeat
    = 1`) and a wider glitch (`scope.glitch.repeat = 50`) should result in the narrow
    glitch not resetting the target and the wider glitch resetting the target.
  prefs: []
  type: TYPE_NORMAL
- en: You can also adjust resistor VR1 to see how it affects the results. You should
    find that a larger VR1 value allows you to use a wider glitch setting before the
    device resets. Again, see Figures 6-11 and 6-12 for examples of what the power
    trace looks like in both reset and non-reset situations. The addition of the resistor
    gives us another item to tweak. Imagine if the setting of `scope.glitch.repeat
    = 6` allowed the device to work normally and `scope.glitch.repeat = 7` always
    caused a reset. We want a setting that *almost* resets the device. A reset isn’t
    useful, but you could tweak the resistor value to the point where it doesn’t always
    reset the device.
  prefs: []
  type: TYPE_NORMAL
- en: As a sanity check, first connect both mux inputs to +3.3 V, and you should see
    that the target won’t glitch. Then connect one of the mux inputs directly to GND,
    and you should find that even narrow glitches cause the target to reset. From
    there, use the variable resistor to find the ideal in-between setting.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve found a good setting for the voltage that has been set by the variable
    resistor (in our experiment, the “good” setting was a resistance of 34 Ω), you
    can again find the setting for the glitch width where the target is becoming unstable
    and resetting. When we dialed in the resistance setting, we were using a very
    wide glitch, so now we want to fine-tune the width to reduce our search space
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the crowbar glitch, we found a slightly narrower glitch was required.
    [Listing 6-10](#listing6-10) shows an example of the successful dump output; note
    that the timing offset is about the same as that determined by the crowbar insertion
    but that the width is different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-10: Using a mux results in the same successful glitch output as when
    using a crowbar.'
  prefs: []
  type: TYPE_NORMAL
- en: If you do adjust the regular operating voltage, the timing of the glitch will
    change. The operating voltage of the device changes the internal oscillator frequency
    slightly (in addition to natural variations between devices). This means that
    running the target at 2.5 V instead of 3.3 V will likely have a pronounced effect
    on the moment in the boot process where the glitch ends up being inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Act 3: Differential Fault Analysis'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whereas the previous acts used fault injection to impact a result, this act
    uses fault injection to corrupt the otherwise perfect and secure math that underpins
    modern cryptography. In particular, we are going to attack RSA using a particularly
    common RSA implementation. These types of faults make it possible to use a *differential
    fault analysis (DFA)* attack. DFA attacks rely on an attacker being able to run
    the cryptographic operation while a fault is inserted and to compare the result
    of the faulty operation with the normal operation.
  prefs: []
  type: TYPE_NORMAL
- en: A Bit of RSA Math
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The 2001 paper “On the Importance of Eliminating Errors in Cryptographic Computations,”
    by Dan Boneh, Richard A. DeMillo, and Richard J. Lipton, introduced the Bellcore
    DFA attack on RSA. It must be one of the most effective DFA attacks, so in this
    act, we’ll take you on the ride called “Single Fault, All Key Bits.” Although
    this is a magical outcome, it is not super complicated mathematically. The Bellcore
    attack focuses on a particular variant of RSA, called the *RSA-CRT (Chinese Remainder
    Theorem)*. RSA-CRT was invented to speed up calculating RSA signatures by doing
    the RSA modular integer arithmetic on smaller numbers, while (of course) leading
    to the same result.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll discuss textbook RSA and then show how RSA-CRT is implemented.
    We’ll discuss RSA again in Chapter 8 when we introduce the power analysis attack.
    Understanding how RSA works for a fault attack needs more details than for power
    analysis, so this section goes a little deeper than what you’ll need for Chapter
    8 (in case the following math throws you off). Since this is a hardware book,
    refer to your favorite crypto textbook for more details. If you don’t yet have
    a favorite, Jean-Philippe Aumasson’s *Serious Cryptography* (No Starch Press,
    2018) is a good candidate, and it covers RSA in Chapter 10\. The following math
    has tons of cryptographic and number theory background, but all you really need
    is high-school-level algebra to understand why the attacks work.
  prefs: []
  type: TYPE_NORMAL
- en: The workings of RSA start off with two prime numbers, *p* and *q*, which together
    form the basis for the *private key*. The *public key* is simply *n*, with *n*  =  *pq*.
    The secrecy of *p*  and *q* is due to the inherent difficulty in factorization
    of very large numbers, meaning no known efficient algorithms exist for recovering
    *p* and *q* from only *n*. The next component of RSA is in choosing a number called
    the *public exponent* *e*. A common choice is 2^(16) + 1\. The *private exponent*
    *d* is now calculated as *d*  =  *e*^(–1) mod  λ(*n*), where λ is Carmichael’s
    totient function (its implementation isn’t relevant for the following attack,
    so you can simply nod knowingly about the existence of this function).
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using RSA to sign a given message, the message *m* is what the RSA
    signature protects. RSA signing is done by calculating *s*  =  *m*^(*d*)  mod  *n*.
    The message *m* is simply an integer (number). In practice, we have a *padding
    scheme* that converts from a typical string or binary message to the integer *m*.
  prefs: []
  type: TYPE_NORMAL
- en: RSA is pretty computationally expensive. Consider that the private exponent
    is, for modern-day security, at least 2,048 bits long and that the complexity
    of the modular exponentiation *m*^(*d*) mod *n* increases with the cube of the
    number of bits in *n*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the Chinese Remainder Theorem. The idea is to split the calculation into
    two parts, leveraging the fact that *n* is a product of two primes. The private
    key in RSA-CRT is based on the primes *p* and *q*, mentioned previously. We could
    represent this key, still based only on the values of *p* and *q*, as three numbers:
    *d*[*P*]  =  *d*  mod  *p* – 1,  *d*[*Q*]  =  *d*  mod  *q* – 1, and *q*[inv]
    =  *q*^(–1)  mod  *p*. With this implementation, we now can calculate a signature
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*s*[*P*] = *m*^(*d*)^([*P*])mod *p*'
  prefs: []
  type: TYPE_NORMAL
- en: '*s*[*Q*] = *m*^(*d*)^([*Q*])mod *q*'
  prefs: []
  type: TYPE_NORMAL
- en: '*s* = *s*[*Q*] + *q*(*q*[inv](*s*[*P*] – *s*[*Q*])mod *p*)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the moduli (*p* and *q*) are now half the number of bits, calculating
    a signature is roughly four times faster (that’s good). Also, a differential fault
    analysis (DFA) attack can now be performed with just one fault (that’s bad). To
    appreciate why, consider that we inject a fault, any fault, during the calculation
    of *s*[*P*], and let’s call the faulty result *s''*[*P*]. We’ll also have a corrupted
    signature as a result, *s''*. Next, we can do a bit of algebraic magic:'
  prefs: []
  type: TYPE_NORMAL
- en: '*s''* = *s*[*Q*] + *q*(*q*[inv](*s''*[*P*] – *s*[*Q*])mod *p*)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we subtract *s''* from *s*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*s* – *s''* = *s*[*Q*] + *q*(*q*[inv](*s*[*P*] – *s*[*Q*])mod *p*) – *s*[*Q*]
    – *q*(*q*[inv](*s''*[*P*] – *s*[*Q*])mod *p*)'
  prefs: []
  type: TYPE_NORMAL
- en: 'and we remove *s*[*Q*] from both sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '*s* – *s*'' = *q*(*q*[inv](*s*[*P*] – *s*[*Q*])mod *p*) – *q*(*q*[inv](*s''*[*P*]
    – *s*[*Q*])mod *p*)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we recognize that *q* times some integer, minus *q* times some other integer,
    can be written as
  prefs: []
  type: TYPE_NORMAL
- en: '*s* – *s''* = *qk*[1] – *qk*[2] = *kq*'
  prefs: []
  type: TYPE_NORMAL
- en: where *k*[1], *k*[2],and *k* are some (unknown) integers. This is for a fault
    in *s*[*P*]. If you happen to fault during the calculation of *s*[*Q*], you end
    up with *s* – *s'* =  *kp*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use an efficient algorithm for calculating the *greatest common divisor
    (GCD)*. The GCD of two integers *i* and *j* gives the largest positive integer
    that divides into both numbers. For example, the GCD of 36 and 24 is 12, because
    12 divides into both 36 and 24\. No number greater than 12 divides both 36 and
    24\. We’ll write this as GCD(36, 24) = 12.
  prefs: []
  type: TYPE_NORMAL
- en: A prime number, by definition, can be divided only by itself and 1\. In RSA,
    the modulus of *n* = *pq*, so it’s divisible only by 1, *p*, and *q*. Since GCD(*q*,
    *n*) = GCD(*q*, *pq*) =  *q*, the GCD of *n* and any integer *kq* (with *k* less
    than *p*) is *q*.
  prefs: []
  type: TYPE_NORMAL
- en: From our attack, we can calculate *s* – *s'*, and we know it’s a multiple *k*
    of *q* (with *k* less than *p*). We calculate GCD(*s* – *s'*, *n*) = GCD(*kq*,
    *pq*) =  *q*. This works because *p* and *q* are primes, so no other divisors
    exist for *n*. Now, since we have *q*, we easily calculate *p* =  *n* ÷ *q*, and
    we have both private primes and thus the RSA private key!
  prefs: []
  type: TYPE_NORMAL
- en: Note that for this attack to work, we need both *s* and *s'*, which means signing
    the same message *m* twice and corrupting one of the two signature calculations.
    Doing that may not always be possible in practice, because padding schemes like
    *Optimal Asymmetric Encryption Padding (OAEP)*, such as used in the PKCS#1 cryptographic
    standard, randomizes part of the message *m* on the signer’s end. Luckily, Arjen
    Lenstra, a famous cryptographer, wrote a memo to the Bellcore authors showing
    a successful attack that requires only the corrupted signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is fairly similar to the preceding one, where we did some algebra
    to derive a value for which the GCD with *n* gives one of the primes. The difference
    with before is that we don’t have an *s*, only an *s''*. We can use our previously
    derived equation that relates them:'
  prefs: []
  type: TYPE_NORMAL
- en: '*s* − *s*′ = *kq*'
  prefs: []
  type: TYPE_NORMAL
- en: '*s* = *s*′ + *kq*'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we’ll substitute the *s* as follows in the RSA message equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*m* = *s*^(*e*)mod *n* = (*s*′ + *kq*)^(*e*)mod *n*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the binomial theorem to do some rewriting. The binomial theorem
    states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![e06001](image_fi/278748c06/e06001.png)'
  prefs: []
  type: TYPE_IMG
- en: So, we’ll write
  prefs: []
  type: TYPE_NORMAL
- en: '![e06002](image_fi/278748c06/e06002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'and we’ll bring out the expression for *i* = 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![e06003](image_fi/278748c06/e06003.png)![e06004](image_fi/278748c06/e06004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ll also divide one of the *kq* terms out of the summation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![e06005](image_fi/278748c06/e06005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We replace the summation with *x*, where *x* is some integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*m* = [*s*''^(*e*) + *kqx*]mod *n*'
  prefs: []
  type: TYPE_NORMAL
- en: '*m* − *s*^(''*e*) = *kqx* mod *n*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then find *q* with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: GCD(*m* − *s*'^(*e*), *n*) = GCD(*kqx*, *n*) = GCD(*kqx*, *pq*) = *q*
  prefs: []
  type: TYPE_NORMAL
- en: Since *p*  =  *n* ÷ *q*, we have the full private key. As before, this works
    symmetrically for a fault in *s*[*Q*].
  prefs: []
  type: TYPE_NORMAL
- en: Getting a Correct Signature from the Target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this example, we’ll use this chapter’s Jupyter Notebook, which has an RSA-CRT
    fault simulator and can also run on the ChipWhisperer-Lite with a 32-bit ARM (NAE-CWLITE-ARM)
    target. You can configure your choice at the top of the notebook. For the hardware,
    it walks you through loading the firmware, getting a signature from the device,
    and verifying it is correct.
  prefs: []
  type: TYPE_NORMAL
- en: You can use whatever other target you want; all you need to do is build a fault
    injection setup with the target and implement an RSA-CRT on the target. The RSA-CRT
    takes in a message *m* and returns the signature *s*. You can modify the code
    from the notebook for your firmware and build setup.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting the Fault in the Simulator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For the simulator in the notebook, we implement the RSA-CRT computation as
    described in the earlier formulae. Just like on the real hardware, we’re signing
    a PKCS#1 v1.5 padded hash of the message. Luckily, this standard’s fairly simple.
    PKCS#1 v1.5 padding looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `ff...` part is a string of `ff` bytes long enough to make the size
    of the padded message the same size as *n*, while `hash_prefix` is an identifier
    number for the hash algorithm used on `message_hash`. In our case, SHA-256 has
    the hash prefix of `3031300d060960864801650304020105000420`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Altogether, the padded and hashed message “Hello World!” looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the final message, we push that through the RSA-CRT computation,
    but not without first simulating some faults. For this, we flip a number of bits
    in *s*[*P*] at random to obtain *s'*[*P*]. As the preceding attack explains, it’s
    not important what the fault really is. We could have also set *s*[*P*] to the
    binary expansion of π, 0, or our pet’s birthday. Next, we calculate the faulty
    signature *s'*.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting the Fault on Hardware
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For hardware, the relaxed conditions on when and where to fault also help us:
    any fault will do, as long as it’s sometime during the calculation of *s*[*P*]
    or *s*[*Q*]. Since these calculations take up almost the entire RSA-CRT calculation,
    most of the time between receiving the message and calculating the signature is
    spent on the calculation of *s*[*P*]and *s*[*Q*]. This means you can try your
    luck and blindly inject faults somewhere within the time window of the signature
    calculation.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want a bit more visibility as to what you’re doing, take a power trace
    to see the timing of the RSA operation. For example, the power trace in [Figure
    6-16](#figure6-16) is from an STM32F30, where the operation is split into two
    main sub-operations.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06016](image_fi/278748c06/f06016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-16: MBED-TLS running an RSA signature operation'
  prefs: []
  type: TYPE_NORMAL
- en: You can see the two halves of the signature calculation split around cycle 500,000,
    separated by a small blip. This pattern is very common for RSA-CRT, and, in fact,
    seeing it can make it obvious that a device is running RSA-CRT without any internal
    knowledge of the device. We’ll look more at power analysis in the next chapter
    as well as how to use it to recover secret information from a device.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the timing down, we can inject faults. In the notebook for this exercise,
    we’ve selected a range between 7,000,000 and 7,100,000 in which to inject faults,
    which is somewhere in the middle of the second half of the signature computation.
    From earlier characterization of the device, we know some possible fault parameters
    we could use, and we hardcode these in the notebook. If we are unsure on the timing,
    we can simply sweep through some approximate timings, as this snippet of code
    shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We use a loop to get the target to perform signature operations while we inject
    faults. We would then need to check the result to see whether the target returned
    something that looks like a corrupted signature, rather than a target crash or
    hard error. The code to check whether the output is valid for each timing is in
    the companion notebook.
  prefs: []
  type: TYPE_NORMAL
- en: We identify candidate signature corruptions by the fact that the signature returned
    from the device has the correct length but does not pass RSA verification. If
    it has an incorrect length, we most likely corrupted something besides the signature
    calculation, so we can discard those instances.
  prefs: []
  type: TYPE_NORMAL
- en: In the notebook, we cheat and simply check to see whether the “expected” output
    does not appear in the signature (the expected output being the result of a correct
    signature). It’s an even easier way of checking whether the signature doesn’t
    validate.
  prefs: []
  type: TYPE_NORMAL
- en: After running this code, we’ll have captured a faulty signature that we can
    use to recover the primes. Usually, this method will work. If you encounter a
    corner case where it doesn’t, it’s easy to grab another faulty signature and try
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you aren’t going the ChipWhisperer route and have your own setup or target,
    make sure to characterize first: find fault injection parameters that will result
    in some visible corruption of the signature. The telltale sign of a useful corruption
    is when the data returned for the signature changes without the length of the
    signature changing. The amusing part of this attack is that a successful characterization
    will already yield a corrupted signature, which means we’re done with the fault
    injection part.'
  prefs: []
  type: TYPE_NORMAL
- en: Completing the Attack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once we have the glitched signature, either from hardware or the RSA-CRT simulator,
    we’ve still got a little work to do. Let’s assume we have a variable called `s_crt`
    that is the correct signature and a variable called `s_crt_x` that is the corrupted
    signature. These are just big numbers. As an example, the value of `s_crt_x` when
    printed in hex looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Earlier, we had the simple equation for calculating the primes *p* and *q* out
    of the corrupted signature and either the correct signature or the message. The
    notebook implements both methods for recovering the primes using the GCD. As you’ll
    see, this computation takes only a fraction of a second to complete before printing
    out the private primes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take one of the implementations from the notebook for finding the private
    primes using the corrupted signature and the correct signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this block shows the calculated values of `p` and `q`. To confirm
    that they’re correct, we simply check whether multiplying them together gives
    us the (public and, thus, known) value of `N`. The following shows an example
    of running the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Et voilà! We’ve factored `N` from one corrupted signature and know the private
    primes `p` and `q`. All it took was a single fault inserted at almost an arbitrary
    time during the signature operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hardened implementations have one more trick that we should bypass in real
    life, however: the actual `mbedTLS` library checks whether it’s returning a faulty
    signature, which it does simply by checking that the signature works as expected.
    In the sample firmware, we’ve commented out that line. In reality, you would use
    fault injection to bypass the check. Although a double-fault sounds tricky, it’s
    made easier because the initial fault (in the RSA operation) requires almost no
    precision on the timing, so the only complicated part is timing the fault on the
    signature validation check.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we walked through three different examples of performing fault
    injection attacks, starting with the most basic scenario of a fault attack on
    a loop and finishing with how you can dump RSA keys using fault attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that fault injection in practice is a stochastic process. The specific
    type of fault and resulting effect will vary considerably, and even can change
    with different device lock codes and as manufacturers work to protect devices
    against fault attacks.
  prefs: []
  type: TYPE_NORMAL
- en: If you are performing the experiments in this chapter yourself, don’t despair
    if things don’t work reliably the first time. Try multiple methods of performing
    the fault injection, and more important, experiment with some of the simple examples
    first to see what variety of faults you can inject.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll step things up and attack an off-the-shelf device.
  prefs: []
  type: TYPE_NORMAL
