- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: 'Bench Time: Fault Injection Lab'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基准时间：故障注入实验室
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Fault injection is a wonderful method of attacking embedded systems, and this
    chapter focuses on its practical aspects. We describe not only how to perform
    the actual injection, but how to get started on your own. While you could perform
    fault injections on a huge world of devices, we concentrate on a few specific
    examples here.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 故障注入是一种攻击嵌入式系统的绝妙方法，本章重点介绍其实际应用。我们不仅描述了如何进行实际的注入，还介绍了如何开始自己的故障注入实验。尽管你可以在大量设备上进行故障注入，但在这里我们集中讨论一些特定的例子。
- en: 'We present our fault injection attacks in three acts, and these acts will be
    relatively reproducible. With the same hardware, you should expect to be able
    to achieve the given results. The first act demonstrates how to use a spark to
    inject a fault into a device. We write a program that includes a simple loop and
    then show how to inject a glitch into the loop. The second act applies two different
    fault injection methods: crowbar injection and mux (multiplexor) injection. Finally,
    the third act applies fault injection to corrupt the otherwise perfect and secure
    math that underpins modern cryptography.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的故障注入攻击分为三个部分，这些部分是相对可重现的。使用相同的硬件，你应该能够达到预期的结果。第一部分展示了如何使用火花注入故障到设备中。我们编写一个包含简单循环的程序，然后展示如何将故障注入到循环中。第二部分应用了两种不同的故障注入方法：撬棍注入和多路复用器（mux）注入。最后，第三部分应用故障注入来破坏支撑现代密码学的完美且安全的数学原理。
- en: '[Figure 6-1](#figure6-1) is a diagram showing all of these acts (this same
    diagram appears in Chapter 4 as Figure 4-3).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-1](#figure6-1)是一个显示所有这些操作的示意图（同一图示在第4章中作为图4-3出现）。'
- en: '![f06001](image_fi/278748c06/f06001.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![f06001](image_fi/278748c06/f06001.png)'
- en: 'Figure 6-1: The connections between PC, fault injector, and target'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1：PC、故障注入器与目标之间的连接
- en: Remember when reading through the examples that all these acts will have the
    same components. A *target* will be running some code that we will insert the
    fault into, but the three acts will all use different targets. The *fault injector*
    will be how we insert the fault; we’ll show you a few different fault injectors
    as well in the different acts. Finally, a *PC* will be involved to monitor or
    control the entire operation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读这些例子时，请记住，所有这些操作都会有相同的组成部分。一个*目标*将运行一些我们要注入故障的代码，但这三种操作将使用不同的目标。*故障注入器*是我们插入故障的方式；在不同的操作中，我们将向你展示几种不同的故障注入器。最后，*PC*将参与监控或控制整个操作。
- en: The actual connections between devices will vary between the acts. In the first
    act, for example, we won’t need precise timing. This means the “trigger” signal
    in [Figure 6-1](#figure6-1) may be optional; one of the fault injectors we’ll
    use won’t have any sort of trigger at all. In later acts, we’ll have more precise
    timing requirements, so the trigger signal will be used to delay the fault such
    that it is inserted at a very specific point in time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 设备之间的实际连接在各部分之间会有所不同。例如，在第一部分中，我们不需要精确的时序。这意味着[图6-1](#figure6-1)中的“触发”信号可能是可选的；我们将使用的其中一个故障注入器根本没有任何触发器。在后续部分中，我们会有更精确的时序要求，因此将使用触发信号来延迟故障，以确保它在非常特定的时间点被插入。
- en: 'Act 1: A Simple Loop'
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分：一个简单的循环
- en: We’ll start with the most basic glitch you can perform to show how you might
    start fault injection on a new target. A typical task when facing a new device
    is to run very simple loop code (see [Listing 6-1](#listing6-1)) on the target
    device.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从你可以执行的最基本的故障注入开始，展示如何在新目标上开始故障注入。面对新设备时，一个典型的任务是运行非常简单的循环代码（参见[清单6-1](#listing6-1)）在目标设备上。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 6-1: This simple C code is a good first example to glitch.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-1：这段简单的C代码是一个很好的故障注入示例。
- en: This code has several features designed to make glitching easy. Three variables,
    at 1 and 2, are declared `volatile`, providing lots of static RAM (SRAM) access
    and thereby an attack surface. An optional `trigger_high()` command 3 can be used
    to trigger external hardware to insert a glitch. The double-loop structure 4 offers
    many opportunities for glitching to affect the program. If a variable is corrupted
    or an instruction is skipped, the result will be that the variables `i`, `j`,
    and `cnt` could all have incorrect values. Their values are printed 5 so you can
    see the results of your fault injection.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有几个设计特点，使得故障注入变得容易。两个变量，在第1和第2行，声明为`volatile`，提供了大量的静态RAM（SRAM）访问，从而增加了攻击面。可选的`trigger_high()`命令在第3行可以用来触发外部硬件插入故障。双重循环结构第4行提供了多次故障影响程序的机会。如果一个变量被破坏或某条指令被跳过，结果可能是变量`i`、`j`和`cnt`的值都会不正确。它们的值会在第5行打印出来，以便你查看故障注入的结果。
- en: The `cnt` variable is the most likely to be noticeably corrupted. If the value
    of `j` is corrupted, for example, it will be observed as a corrupt value only
    if the corruption happens to occur on the last iteration of the outer loop over
    `i`. This simple loop not only shows whether you’re injecting faults, but you
    also can see various types of faults by observing how the output changes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`cnt`变量最可能会明显被破坏。例如，如果`j`的值被破坏，只有在外循环对`i`的最后一次迭代发生破坏时，才会观察到`j`值被破坏。这个简单的循环不仅显示你是否在注入故障，还可以通过观察输出变化来查看各种类型的故障。'
- en: You may need to modify the code in [Listing 6-1](#listing6-1) slightly to compile
    on your target platform, but it’s designed to have minimal requirements besides
    a simple string print command.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要稍微修改[清单6-1](#listing6-1)中的代码，以便在目标平台上编译，但它的设计目标是除了简单的字符串打印命令外，几乎不需要其他要求。
- en: How do you actually perform an attack on a simple loop? This is a lab chapter
    after all. We’ll show you three methods of performing the attack, all for around
    $50 worth of hardware, but you might already have some of the needed gear on hand
    anyway. The first method uses an Arduino as a target device and a BBQ lighter
    to insert a fault. The next two methods will be based on voltage glitching; we’ll
    show you how to generate a voltage glitch using both a crowbar and a multiplexor
    circuit. To drive these circuits, we’ll make use of the ChipWhisperer-Nano (or
    ChipWhisperer-Lite) in this lab, but you can drive the circuits from other pulse
    sources. Let’s get faultin’ (as they say).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何在一个简单的循环上执行攻击呢？毕竟这是一个实验章节。我们将展示三种执行攻击的方法，所有这些方法的硬件成本大约是50美元，但你可能已经有了一些所需的设备。第一种方法使用Arduino作为目标设备，并通过BBQ打火机插入故障。接下来的两种方法将基于电压故障注入；我们将向你展示如何使用短路棒和多路复用电路来生成电压故障。为了驱动这些电路，我们将在本实验中使用ChipWhisperer-Nano（或ChipWhisperer-Lite），但你也可以使用其他脉冲源来驱动这些电路。让我们开始注入故障吧（正如他们所说的）。
- en: A BBQ Lighter of Pain
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一只痛苦的BBQ打火机
- en: This method is probably the more dangerous one, but for absolute cheapness,
    it’s hard to beat. We need to compile the code from [Listing 6-1](#listing6-1)
    onto an Arduino. That code is almost ready as is. You need to set up the serial
    port first, and then replace the `puts()` call with `Serial.write()`. You may
    want to adjust the loop iteration counters to make the output slower as well (see
    [Figure 6-2](#figure6-2)). The program also marks successful glitches for you.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能是更危险的，但从成本角度来看，它几乎是无可匹敌的。我们需要将代码从[清单6-1](#listing6-1)编译到一个Arduino上。那段代码几乎可以直接使用。你需要先设置串口，然后将`puts()`调用替换为`Serial.write()`。你可能还想调整循环迭代计数器，以使输出变得更慢一些（参见[图6-2](#figure6-2)）。该程序还会为你标记成功的故障注入。
- en: '![f06002](image_fi/278748c06/f06002.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![f06002](image_fi/278748c06/f06002.png)'
- en: 'Figure 6-2: Implementing the code on an Arduino Metro Mini'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2：在Arduino Metro Mini上实现代码
- en: We’re using the Arduino Metro Mini for this example, Adafruit part number 2590,
    because it has an ATmega328P in a QFN package. We need the QFN package because
    it has the least amount of material between the top of the chip surface (where
    we are generating our electromagnetic glitch pulse) and the die itself. An ATmega328P
    in a DIP package, for example, will be too thick, and you likely won’t have as
    much success, if any at all.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中我们使用的是Arduino Metro Mini，Adafruit零件号2590，因为它配有ATmega328P芯片，采用QFN封装。我们需要QFN封装，因为它在芯片表面（我们生成电磁故障脉冲的地方）和芯片本体之间的材料最少。例如，ATmega328P的DIP封装太厚，可能无法成功注入故障，甚至可能完全失败。
- en: The isolator on the right in [Figure 6-3](#figure6-3) is from Adafruit, part
    number 2107, but you could use any other isolator or even just an isolated serial
    port. The fault injection method also can easily damage your target device since
    you’ll be playing with very high voltages!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](#figure6-3)右侧的隔离器来自Adafruit，零件号2107，但你可以使用任何其他隔离器，甚至只是一个隔离的串口。故障注入方法也很容易损坏你的目标设备，因为你将使用非常高的电压！'
- en: '![f06003](image_fi/278748c06/f06003.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![f06003](image_fi/278748c06/f06003.png)'
- en: 'Figure 6-3: An isolator from Adafruit (PCB on the right) and our target (PCB
    on the left)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-3：来自Adafruit的隔离器（右侧是PCB），我们的目标（左侧是PCB）
- en: Alright, enough warning. If you rip open a BBQ lighter, you will find the piezoelectric
    ignitor, as shown in [Figure 6-4](#figure6-4).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，警告够多了。如果你撕开一个烧烤点火器，你会发现压电点火器，如[图 6-4](#figure6-4)所示。
- en: '![f06004](image_fi/278748c06/f06004.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![f06004](image_fi/278748c06/f06004.png)'
- en: 'Figure 6-4: A piezoelectric ignitor generates a high voltage.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-4：压电点火器产生高电压。
- en: This element generates a high voltage (careful not to shock yourself) when the
    plunger on the right end is depressed into the housing until a click is heard.
    If you carefully bend the high voltage wire (that is, the wire that would go to
    the BBQ lighter end) to be near the end cap, it will generate a spark. In our
    case, we’ve routed the two wires to make a small spark gap, maybe in the 0.5 mm
    to 2 mm range. The gap is held in place by some polyimide tape.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该元件在右端的推动器被压入外壳，直到听到“咔哒”声时，会产生高电压（小心不要电到自己）。如果你小心地将高压线（即连接到烧烤点火器端的电线）弯曲，使其接近端盖，它将产生火花。在我们的案例中，我们已经将两根电线连接起来，形成一个小的火花间隙，可能在0.5毫米到2毫米之间。间隙通过一些聚酰亚胺胶带固定。
- en: This alone is enough to provide a fault injection mechanism. We’ll try to force
    the spark to be generated somewhere “interesting” in our attack on an Arduino.
    The spark gap is placed above a surface mount Arduino package (see [Figure 6-5](#figure6-5)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身足以提供一个故障注入机制。我们将尝试强制火花在攻击Arduino时在某个“有趣”的地方生成。火花间隙位于表面贴装的Arduino封装上方（见[图
    6-5](#figure6-5)）。
- en: The polyimide tape (Adafruit part number 3057, and often sold under the Kapton
    brand name) on top of the chip insulates it. If the spark connects to the microcontroller
    pins, you’ll kill the device instantly, and if your isolator isn’t working or
    you exceed the voltage limits, you may also kill the computer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 芯片上方的聚酰亚胺胶带（Adafruit零件号3057，通常以Kapton品牌出售）为其提供绝缘保护。如果火花连接到微控制器的引脚，你会立刻烧毁设备，如果你的绝缘体不起作用或者超出了电压限制，也可能烧毁计算机。
- en: '![f06005](image_fi/278748c06/f06005.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![f06005](image_fi/278748c06/f06005.png)'
- en: 'Figure 6-5: Polyimide tape helps (but doesn’t fully stop) our device from blowing
    up due to the high voltage.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-5：聚酰亚胺胶带有助于（但不能完全防止）我们的设备因高电压而爆炸。
- en: Next, run the program and start sparking. With any luck, you’ll get some corrupted
    output, as shown on the screen in [Figure 6-2](#figure6-2). You also may see some
    resets if the overall counter resets back to zero. While still a bit of a fault,
    this is not the interesting kind of fault you’ll want. A reset means your fault
    is too powerful; try adding some spacing between the spark gap or changing the
    location.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行程序并开始打火。运气好的话，你会得到一些损坏的输出，如[图 6-2](#figure6-2)屏幕上所示。如果总计数器重置为零，你可能还会看到一些重置。虽然这仍然是一种故障，但这并不是你想要的那种有趣的故障。重置意味着你的故障太强大；尝试在火花间隙中增加一些间距或更改位置。
- en: This act has briefly shown how a simple loop and a spark can insert a fault
    into a device. Where timing is not important, such sparks can result in useful
    attacks. In Arun Magesh’s blog post “Bypassing Android MDM Using Electromagnetic
    Fault Injection by a Gas Lighter for $1.5,” this type of attack is used on a smartphone.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分简要展示了一个简单的循环和火花如何向设备插入故障。当时序不重要时，这种火花可以导致有用的攻击。在Arun Magesh的博客文章“通过燃气打火器进行电磁故障注入绕过Android
    MDM，费用为1.5美元”中，这种类型的攻击被用在智能手机上。
- en: 'Act 2: Inserting Useful Glitches'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2部分：插入有用的故障
- en: Maybe you aren’t willing to kill your target device or computer, in which case,
    you’ll need some more subtle fault injection methods. In this act, we describe
    using a fault injection attack on a read protection configuration word stored
    in flash in a device. If we manage to change this configuration word, it allows
    reading out flash contents we should normally not have access to.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你不愿意烧毁目标设备或计算机，在这种情况下，你将需要一些更微妙的故障注入方法。在这一部分中，我们描述了如何使用故障注入攻击设备中存储在闪存中的读取保护配置字。如果我们成功改变这个配置字，就能读取我们通常无法访问的闪存内容。
- en: 'The two less-aggressive-yet-not-less-effective fault injection methods we apply
    in this second act are crowbar glitching and mux (multiplexor) fault injection.
    We also introduce a new glitching target: the Olimex LPC-P1114 development board.
    The development board’s user manual will help you understand the modifications
    and interconnections we describe here.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们应用了两种较不激进但同样有效的故障注入方法：破坏器故障注入和多路复用器（mux）故障注入。我们还介绍了一个新的故障注入目标：Olimex
    LPC-P1114开发板。开发板的用户手册将帮助你理解我们在这里描述的修改和互连。
- en: The glitching method used in this act can achieve the same glitch using the
    simple loop test code in the Arduino microprocessor that we glitched in the previous
    section. If you want to test a glitch setup, we recommend starting with the simple
    loop code from [Listing 6-1](#listing6-1) being compiled for the target. To avoid
    such repetition in this book, however, we’ll jump directly to the end goal, which
    is corruption of the security configuration. Now let’s walk through how to actually
    see some sort of useful glitch!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的故障注入方法可以通过之前部分中我们所破坏的Arduino微处理器中的简单循环测试代码来实现相同的故障。如果你想测试故障设置，我们建议从[清单6-1](#listing6-1)中的简单循环代码开始，并将其编译为目标代码。然而，为了避免本书中的重复，我们将直接跳到最终目标，即破坏安全配置。现在让我们一起走过如何实际看到一些有用的故障！
- en: Crowbar Glitching to Fault a Configuration Word
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用破坏器故障注入来破坏配置字
- en: We’ll apply the crowbar glitching method to fault a configuration word on the
    microcontroller (see Chapter 5 for an introduction to crowbar glitching). This
    will build on Chris Gerlinsky’s presentation “Breaking Code Read Protection on
    the NXP LPC-Family Microcontrollers” (REcon Brussels 2017), which covered the
    initial work, including details of how the fault works and can be generated. Here,
    we show a slightly easier method of injecting the fault, which is to attach a
    “crowbar” across the power supply. This method has been demonstrated to work against
    a variety of devices, including more advanced targets like the Raspberry Pi and
    field-programmable gate array (FPGA) boards. For more details, see Colin O’Flynn’s
    “Fault Injection Using Crowbars on Embedded Systems” (IACR Cryptology ePrint Archive,
    2016), which introduced the crowbar fault injection method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用破坏性故障注入方法来破坏微控制器的配置字（有关破坏性故障注入的介绍，请参见第5章）。这将基于Chris Gerlinsky的演讲“在NXP LPC系列微控制器上破解代码读保护”（REcon布鲁塞尔2017），该演讲涵盖了初步工作，包括故障如何工作及如何生成的细节。在这里，我们展示了一种稍微更简单的注入故障的方法，即通过电源引入一个“破坏器”。该方法已被证明能够对各种设备起作用，包括更高级的目标，如树莓派和现场可编程门阵列（FPGA）板。欲了解更多细节，请参见Colin
    O'Flynn的《在嵌入式系统上使用破坏器进行故障注入》（IACR Cryptology ePrint Archive，2016），该文介绍了破坏器故障注入方法。
- en: The end goal is to attack the code read-protection, which is the mechanism that
    prevents someone from copying the binary code out of the device. In the LPC device,
    the code read-protection is a special word in memory that defines what level of
    protection the microcontroller has. These code read-protection bytes are part
    of the “option bytes” that contain various configurations for the microcontroller.
    [Table 6-1](#table6-1) lists the potential valid values for the option bytes as
    related to the code read-protection.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最终目标是攻击代码读保护机制，这是防止他人将二进制代码从设备中复制出来的机制。在LPC设备中，代码读保护是内存中的一个特殊字，定义了微控制器具有的保护级别。这些代码读保护字节是“选项字节”的一部分，选项字节包含了微控制器的各种配置。[表6-1](#table6-1)列出了与代码读保护相关的选项字节的有效值。
- en: 'Table 6-1: Valid Values for the Option Bytes as Related to the Code Read-Protection'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-1：与代码读保护相关的选项字节的有效值
- en: '| **Mode** | Option bytes value | **Description** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | 选项字节值 | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| NO_ISP | 0x4E697370 | Disables the “ISP Entry” pin. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| NO_ISP | 0x4E697370 | 禁用“ISP入口”引脚。 |'
- en: '| CRP1 | 0x12345678 | SWD interface is disabled. Partial flash updates are
    allowed only via ISP. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| CRP1 | 0x12345678 | 禁用SWD接口。仅通过ISP允许部分闪存更新。 |'
- en: '| CRP2 | 0x87654321 | SWD interface is disabled. Must perform full chip erase
    before most other commands are available. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| CRP2 | 0x87654321 | 禁用SWD接口。在大多数其他命令可用之前，必须执行完整芯片擦除。 |'
- en: '| CRP3 | 0x43218765 | SWD interface is disabled; ISP interface is disabled.
    Device is inaccessible unless user implements call to bootloader via alternate
    method. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| CRP3 | 0x43218765 | 禁用SWD接口；禁用ISP接口。除非用户通过替代方法实现引导加载程序调用，否则设备无法访问。 |'
- en: '| UNLOCKED | Any other value | No protection enabled (full JTAG and bootloader
    access). |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 解锁 | 任何其他值 | 没有启用保护（完全的JTAG和引导加载程序访问）。 |'
- en: The critical flaw in the design is that the “unlocked” level is the default,
    and only when the word is set to one of several specific values do you have code
    read-protection. This means if you were to corrupt the value of the code read-protection
    word in flash, you have no code protection at all! We can use a glitch to corrupt
    this value as it is being read from flash. Let’s see what you need for this.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 设计中的关键漏洞在于，“解锁”级别是默认值，只有当该字设置为几个特定值之一时，才会启用代码读取保护。这意味着，如果你在从闪存读取代码读取保护字时破坏了该值，就完全没有代码保护！我们可以使用故障注入来破坏这个值。接下来，我们来看一下需要哪些工具。
- en: Setting Up the Equipment
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置设备
- en: First, we need a target device (mounted on a target board) on which to attempt
    to break the code read-protection, and, second, we need a tool capable of inserting
    the faults to cause the program to read a value incorrectly and remove the read-protection.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个目标设备（安装在目标板上），用于尝试破解代码读取保护；其次，我们需要一个能够插入故障的工具，以使程序错误读取值并移除读取保护。
- en: '[Figure 6-6](#figure6-6) shows a sample setup. The LPC1114 target board is
    at the top of the photograph, and the ChipWhisperer-Nano (used for performing
    fault injection) is at the bottom of the photograph, which is where you can see
    the interconnection between the two (more details on this interconnection shortly).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-6](#figure6-6)展示了一个示例设置。LPC1114目标板位于照片的顶部，ChipWhisperer-Nano（用于执行故障注入）位于照片的底部，可以看到两者之间的互联（稍后会详细介绍这种互联）。'
- en: '![f06006](image_fi/278748c06/f06006.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![f06006](image_fi/278748c06/f06006.png)'
- en: 'Figure 6-6: The LPC1114 processor target with a ChipWhisperer-Nano for performing
    fault injection'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-6：使用ChipWhisperer-Nano进行故障注入的LPC1114处理器目标
- en: Besides the ChipWhisperer-Nano providing the programming and timing of the injected
    fault, its only real feature we are using is a simple “crowbar” mechanism, which
    you could substitute if you wish to with an external MOSFET or similar.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了ChipWhisperer-Nano提供的编程和故障注入时序，其唯一真正使用的功能是简单的“短路”机制，如果需要的话，你可以用外部MOSFET或类似设备来替代。
- en: ChipWhisperer-Nano vs. ChipWhisperer-Lite
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ChipWhisperer-Nano与ChipWhisperer-Lite的比较
- en: We’re using the ChipWhisperer-Nano due its lower cost ($50), even though it
    has more limited resolution on the glitch timing than what the ChipWhisperer-Lite
    ($250) has. The ChipWhisperer-Lite tends to be more reliable for this attack.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用ChipWhisperer-Nano是因为它的成本较低（$50），尽管它在故障注入时的时序分辨率不如ChipWhisperer-Lite（$250）。ChipWhisperer-Lite在执行这种攻击时更为可靠。
- en: If you use the ChipWhisperer-Nano connected as shown in [Figure 6-6](#figure6-6),
    remember that the ChipWhisperer-Nano has a built-in STM32F0 microcontroller that’s
    used as a target. You can remove the target side (it’s designed to be scored and
    broken off), but the less-destructive option is simply to erase it. For the attack
    we are about to do, the physical presence of the STM32F0 target doesn’t affect
    our usage. We just need to ensure it’s not running code that would get in the
    way of our I/O lines.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照[图6-6](#figure6-6)中的连接方式使用ChipWhisperer-Nano，请记住，ChipWhisperer-Nano内置了一个STM32F0微控制器，作为目标设备。你可以移除目标端（它设计成可以剪切和断开），但更不具破坏性的方法是将其擦除。对于我们即将进行的攻击，STM32F0目标的物理存在不会影响我们的使用。我们只需要确保它没有运行任何会干扰我们的I/O线路的代码。
- en: 'Here’s a short example of how to do this in Python using the Jupyter Notebook
    interface (see the notebook for this chapter at [https://nostarch.com/hardwarehacking/](https://nostarch.com/hardwarehacking/)
    for more detail):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简短的Python示例，演示如何通过Jupyter Notebook接口执行此操作（有关更多细节，请参见本章节的笔记本 [https://nostarch.com/hardwarehacking/](https://nostarch.com/hardwarehacking/)）：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, we just erase the flash of the device using the bootloader interface
    to ensure the serial data lines are free. If we had code running on the ChipWhisperer-Nano
    target, it might corrupt our bootloader access.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们仅通过引导加载程序接口擦除设备的闪存，以确保串行数据线是空闲的。如果ChipWhisperer-Nano目标上运行了代码，可能会破坏我们的引导加载程序访问。
- en: Modifications and Interconnections
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改和互联
- en: The nice thing about this attack is how dead simple we can make it. We need
    to create a momentary short across the power supply to the LPC1114 target, so
    we make a few modifications on the LPC1114 development board’s PCB. Basically,
    we need a connection from the crowbar mechanism to the power rails, and we must
    remove the capacitors that otherwise would smooth out glitches on those power
    rails. We aim for a circuit, as shown in the schematic in [Figure 6-7](#figure6-7).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击的优点在于我们可以做到极其简单。我们需要在 LPC1114 目标的电源之间创建一个瞬时短路，因此我们对 LPC1114 开发板的 PCB 做了一些修改。基本上，我们需要一个来自过电流保护机制到电源轨的连接，并且必须移除那些会平滑电源轨上故障的电容器。我们目标是如
    [图 6-7](#figure6-7) 所示的电路。
- en: '![f06007](image_fi/278748c06/f06007.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![f06007](image_fi/278748c06/f06007.png)'
- en: 'Figure 6-7: Schematic showing part of the LPC1114 development kit'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-7：显示 LPC1114 开发套件部分原理图
- en: The schematic shows the GLITCH connection to indicate how we insert the fault.
    The actual Q1 component is built into the ChipWhisperer-Nano in the example we
    are providing, but if you want to implement this function separately, you could
    route the power to a similar fault injection module, such as a MOSFET driven by
    a signal generator. [Figure 6-8](#figure6-8) shows the physical implementation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 原理图显示了 GLITCH 连接，指示我们如何插入故障。在我们提供的示例中，实际的 Q1 组件集成在 ChipWhisperer-Nano 中，但如果你想单独实现此功能，可以将电源路由到类似的故障注入模块，例如由信号发生器驱动的
    MOSFET。[图 6-8](#figure6-8) 显示了物理实现。
- en: '![f06008](image_fi/278748c06/f06008.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![f06008](image_fi/278748c06/f06008.png)'
- en: 'Figure 6-8: The LPC1114 development board modified for fault injection'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-8：为故障注入而修改的 LPC1114 开发板
- en: 'The following list provides the step-by-step instructions for making the modifications
    on the development board shown in [Figure 6-8](#figure6-8):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表提供了对开发板进行修改的逐步说明，见 [图 6-8](#figure6-8)：
- en: Remove the decoupling capacitor C4 1.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除去耦电容 C4 1。
- en: Remove the decoupling capacitor C1 2.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除去耦电容 C1 2。
- en: Disconnect the 3.3 V CORE_E VDD from the LPC1114 by cutting through trace jumper
    3.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过切断跳线 3，将 3.3 V CORE_E VDD 从 LPC1114 中断开。
- en: Disconnect the 3.3 V IO_E VDD from the LPC1114 by cutting through trace jumper
    4.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过切断跳线 4，将 3.3 V IO_E VDD 从 LPC1114 中断开。
- en: Insert a 12 Ω resistor across the trace jumper 3. The PCB power supply VDD now
    runs through this resistor to the LPC1114.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在跳线 3 上插入一个 12 Ω 电阻。现在，PCB 电源 VDD 通过该电阻连接到 LPC1114。
- en: Connect the “chip side” of the 3.3 V CORE_E VDD and 3.3 V IO_E VDD power supplies
    together using a link 5, going from a pad of the trace jumper 4 and a pad of the
    capacitor placement C4 1.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过链接 5 将 3.3 V CORE_E VDD 和 3.3 V IO_E VDD 电源的“芯片端”连接在一起，从跳线 4 的焊盘和电容器 C4 1
    的焊盘连接。
- en: Connect the 3.3 V CORE_E VDD and 3.3 V IO_E VDD power supplies to a connector
    7 together using a link 6 (here the connector is an SMA connector, but any type
    works).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 3.3 V CORE_E VDD 和 3.3 V IO_E VDD 电源通过连接器 7 使用链接 6（这里连接器是 SMA 连接器，但任何类型的连接器均可）连接在一起。
- en: Set PIO0_1 to ground just by mounting the header at BLD_E 9.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需在 BLD_E 9 上安装插头，将 PIO0_1 接地。
- en: Set PIO0_3 to GND, which requires soldering a wire (the short orange wire a)
    to ground.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 PIO0_3 设置为 GND，这需要将一根电线（短橙色电线 a）焊接到地面。
- en: Add a three-pin header at 8 and route the RST connection to all of these three
    pins.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 8 处添加一个三针插头，并将 RST 连接路由到这三根引脚。
- en: Connect the nReset OUT line from the ChipWhisperer at J3-5 and the Trigger In
    line at J3-16 to the RST input on the development board with the header you mounted
    at 8.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将来自 ChipWhisperer 的 nReset OUT 线路在 J3-5 和触发输入线 J3-16 连接到开发板上的 RST 输入，连接时使用你在
    8 处安装的插头。
- en: Connect GND from the ChipWhisperer at J3-2 to pin UEXT-2 on the development
    board.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将来自 ChipWhisperer 的 GND 在 J3-2 引脚连接到开发板上的 UEXT-2 引脚。
- en: Connect VCC from the ChipWhisperer at J3-3 to pin UEXT-1 on the development
    board.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将来自 ChipWhisperer 的 VCC 在 J3-3 引脚连接到开发板上的 UEXT-1 引脚。
- en: Connect TXD from the ChipWhisperer at J3-10 to pin UEXT-3 on the development
    board.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将来自 ChipWhisperer 的 TXD 在 J3-10 引脚连接到开发板上的 UEXT-3 引脚。
- en: Connect RXD from the ChipWhisperer at J3-12 to pin UEXT-4 on the development
    board.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将来自 ChipWhisperer 的 RXD 在 J3-12 引脚连接到开发板上的 UEXT-4 引脚。
- en: '[Table 6-2](#table6-2) provides a summary of the interconnections between the
    target and the ChipWhisperer-Nano. (You should also be able to determine the interconnections
    for a standalone type of attack from this list.)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-2](#table6-2) 提供了目标设备与 ChipWhisperer-Nano 之间连接的总结。（你也应该能够从此列表中确定独立攻击类型的连接方式。）'
- en: 'Table 6-2: Interconnections of ChipWhisperer-Nano Board to Glitch Generator'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-2：ChipWhisperer-Nano 开发板与故障生成器的连接
- en: '| **LPC1114 development board** | **ChipWhisperer-Nano** | **Description**
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **LPC1114 开发板** | **ChipWhisperer-Nano** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| UEXT-1 | J3-3 | VCC |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| UEXT-1 | J3-3 | VCC |'
- en: '| UEXT-2 | J3-2 | GND |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| UEXT-2 | J3-2 | GND |'
- en: '| UEXT-3 | J3-10 | TXD |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| UEXT-3 | J3-10 | TXD |'
- en: '| UEXT-4 | J3-12 | RXD |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| UEXT-4 | J3-12 | RXD |'
- en: '| RST | J3-5 | Reset OUT |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| RST | J3-5 | 重置输出 |'
- en: '| RST | J3-16 | Trigger in |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| RST | J3-16 | 触发输入 |'
- en: '| VCC_CORE | Glitch connector middle pin | VCC glitch inserted here |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| VCC_CORE | 故障连接器中间引脚 | 在此插入 VCC 故障 |'
- en: '| GND | Glitch connected side pin | Second GND (for glitch) |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| GND | 故障连接侧引脚 | 第二个 GND（用于故障） |'
- en: The RST line on the development board is both an output (gets toggled to reset
    the device) and an input (serves as a reference for when to insert the fault),
    which is required because the ChipWhisperer-Nano uses GPIO4 as the trigger input.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 开发板上的 RST 引脚既是输出（切换来重置设备）也是输入（作为插入故障的参考），这是必需的，因为 ChipWhisperer-Nano 使用 GPIO4
    作为触发输入。
- en: The Timing Is Everything
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 时机就是一切
- en: As the LPC1114 device is coming out of reset, it will read the configuration
    word from flash memory, and we need to insert our fault at that moment. If we
    can corrupt the read of the memory, the device will come up as unlocked, which
    isn’t what the designer intended.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当 LPC1114 设备从重置中恢复时，它将从闪存读取配置字，我们需要在这一时刻插入故障。如果我们能够破坏内存读取，设备将被解锁，这不是设计者的初衷。
- en: We use the reset pin to time the fault. The rising edge of the reset pin (since
    the reset is active-low) indicates when the boot sequence begins. If you were
    controlling everything from a single device (such as your own FPGA or microcontroller),
    you could, of course, time the glitch based on when you drove the reset pin high.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用重置引脚来计时故障。重置引脚的上升沿（由于重置是低电平有效的）指示引导序列的开始。如果你控制的是单一设备（例如你自己的 FPGA 或微控制器），你当然可以根据你将重置引脚拉高的时间来控制故障。
- en: The reset pin tells us only when the device begins the boot process, but not
    the finishing time and not at what point the value of the code read-protection
    is fetched from flash memory. We’ll need to sweep the glitch insertion from the
    start of the boot until the boot is finished to target every possible clock cycle
    when the flash read could be happening.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重置引脚只告诉我们设备何时开始引导过程，但不能告诉我们结束时间，也不能告诉我们读取保护值何时从闪存中获取。我们需要在从引导开始到结束的过程中扫过故障插入点，瞄准可能发生闪存读取的每个时钟周期。
- en: While the reset pin gives us the starting time, we would like to have a finishing
    time when we know the device is finished booting (and if we didn’t break code
    protection by then, the glitch was clearly ineffective). To determine this “ending
    time,” we could write a simple program that toggles an I/O pin and load it onto
    the microcontroller. When the I/O pin starts toggling, we know the microcontroller
    is running our own code and the booting has completed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然重置引脚为我们提供了开始时间，但我们希望在设备完成引导时能够知道一个结束时间（如果到那时我们没有破坏代码保护，那么故障显然是无效的）。为了确定这个“结束时间”，我们可以编写一个简单的程序，切换一个
    I/O 引脚并将其加载到微控制器中。当 I/O 引脚开始切换时，我们知道微控制器正在运行我们的代码，且引导过程已完成。
- en: The boot time is thus the time between the reset pin becoming inactive (going
    high) and the I/O pin toggling. Somewhere between the reset pin going high and
    the I/O pin toggling is when the microcontroller boot code must be reading the
    read-protect value from flash memory and acting on the value. Our glitch must
    be targeted somewhere in that time frame.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，引导时间是从重置引脚变为非活动状态（变为高电平）到 I/O 引脚切换之间的时间。在重置引脚变为高电平和 I/O 引脚切换之间，微控制器的引导代码必须正在从闪存读取读取保护值并对该值采取行动。我们的故障必须瞄准这个时间段中的某个时刻。
- en: Bootloader Protocol
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 引导加载程序协议
- en: To understand how to find a useful glitch, here’s a short primer on the bootloader
    in this device. We’ll use the bootloader to determine whether things are actually
    going according to plan.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解如何找到一个有效的故障，这里有一个简短的设备引导加载程序入门。我们将使用引导加载程序来判断事情是否按计划进行。
- en: 'The bootloader protocol is very simple. A serial protocol is used to communicate
    with the device, allowing us to experiment with the bootloader via a serial terminal.
    The communication works as follows: we send some setup information followed by
    a read/write to memory to load and verify code.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序协议非常简单。使用串行协议与设备通信，允许我们通过串行终端实验引导加载程序。通信流程如下：我们发送一些设置信息，接着进行内存读写操作以加载和验证代码。
- en: The protocol automatically determines the baud rate during the first character’s
    transfer. The rest of the setup confirms baud rate synchronization and informs
    the bootloader of the external crystal speed in case it’s needed for any additional
    setup. You can see some of the setup commands in the output example from [Listing
    6-3](#listing6-3), which we’ll look at next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 协议在传输第一个字符时自动确定波特率。其余的设置确认波特率同步，并通知引导加载程序外部晶体的速度，以防需要进行任何额外的设置。你可以在[清单 6-3](#listing6-3)的输出示例中看到一些设置命令，我们接下来会查看这些命令。
- en: Several commands erase, read, and write memory, but we care only about a memory
    read attempt, because if the device is locked, a memory read will fail. We can
    perform a memory read with `R 0 4\r\n`, which attempts to read 4 bytes from address
    0\. If the device is locked, we’ll get a response of `19`, which is the error
    code for access not being allowed. Ultimately, we need to script a method of continuously
    testing to see whether the device is unlocked.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 几个命令用于擦除、读取和写入内存，但我们只关心内存读取尝试，因为如果设备被锁定，内存读取会失败。我们可以使用`R 0 4\r\n`执行内存读取，这将尝试从地址
    0 读取 4 字节。如果设备被锁定，我们会得到`19`的响应，这是访问不被允许的错误代码。最终，我们需要编写一个脚本方法，不断测试设备是否解锁。
- en: With that, we now need to corrupt the “option bytes” that store the code read-protection
    codes. They aren’t continuously checked, but they are read only upon reset. As
    mentioned, we need to time our attack from reset.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们现在需要破坏存储代码读保护代码的“选项字节”。它们不会被持续检查，但只会在重置时读取。如前所述，我们需要从重置开始计时我们的攻击。
- en: Device Setup
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设备设置
- en: First, we need to get communication working with the bootloader. While we could
    implement the entire bootloader protocol, instead we’re going to use an existing
    library called `nxpprog` (available at [https://github.com/ulfen/nxpprog/](https://github.com/ulfen/nxpprog/))
    that can talk to these devices.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使引导加载程序的通信正常工作。虽然我们可以实现整个引导加载程序协议，但我们将使用一个现有的库，叫做`nxpprog`（可在[https://github.com/ulfen/nxpprog/](https://github.com/ulfen/nxpprog/)找到），它能够与这些设备进行通信。
- en: The following examples reference the companion Jupyter Notebook provided as
    part of this book’s resources, which implements the full attack and provides required
    setup details. Suggested installation instructions also are available online.
    We’ll walk through the code and attack here, though, so you can see how it works
    without needing to install anything.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例参考了本书资源中提供的配套 Jupyter Notebook，该 Notebook 实现了完整的攻击过程并提供了所需的设置细节。建议的安装说明也可以在线获取。不过，我们将在这里一起走一遍代码和攻击过程，这样你就能看到它是如何工作的，而无需安装任何东西。
- en: The `nxpprog` library requires the `isp_mode()`, `write()`, and `readline()`
    support functions. The `isp_mode()` function enters the in-system programming
    (ISP) mode by setting an entry pin and resetting the device. In this example,
    the ISP mode entry pin is soldered to GND to force ISP mode entry (refer to [Figure
    6-8](#figure6-8)). The `isp_mode()` function simply resets the device, which begins
    a new bootloader iteration. The other two functions talk on the serial port to
    the bootloader. If a ChipWhisperer device is used, this routes data out from the
    ChipWhisperer. See the Jupyter Notebook for more details on those functions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`nxpprog`库需要支持函数`isp_mode()`、`write()`和`readline()`。`isp_mode()`函数通过设置进入引脚并重置设备，进入在系统编程（ISP）模式。在这个示例中，ISP模式入口引脚被焊接到
    GND 以强制进入 ISP 模式（参见[图 6-8](#figure6-8)）。`isp_mode()`函数仅重置设备，从而开始一个新的引导加载程序迭代。其他两个函数则通过串口与引导加载程序通信。如果使用的是
    ChipWhisperer 设备，则数据将从 ChipWhisperer 输出。有关这些函数的更多细节，请参阅 Jupyter Notebook。'
- en: '[Listing 6-2](#listing6-2) shows an example of attempting to connect to the
    device and read the output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-2](#listing6-2)显示了尝试连接设备并读取输出的示例：'
- en: '[PRE2]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 6-2: Using `nxpprog` to connect and read memory'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-2：使用`nxpprog`连接并读取内存
- en: '[Listing 6-3](#listing6-3) contains the expected output with debug information
    showing the serial port `read` and `write` instructions.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-3](#listing6-3)包含预期的输出和调试信息，显示了串口`read`和`write`指令。'
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 6-3: The output of running the `nxpprog` connect script from [Listing
    6-2](#listing6-2)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-3：运行`nxpprog`连接脚本的输出，来自[清单 6-2](#listing6-2)
- en: In this case, we get a `CODE_READ_PROTECTION_ENABLED` error, which is what we
    are looking for. If we had used a new development board, however, it wouldn’t
    yet have code read-protection enabled. This means in order to imitate the real
    world, we need to turn that on before we can continue with the tutorial.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The read-protect code bytes are located at address 0x2FC and consist of 4 bytes.
    To program the code protection, we need to erase an entire page of memory (4,096
    bytes) and reprogram the new page with our configuration word set to enable read-protection.
    In a real situation, we would need to know what should be programmed in all other
    bytes in the page, but if we don’t need to run the code and instead are simply
    performing a proof of concept, we can program in zeros (or any other data).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-4](#listing6-4) shows how the sample implementation defaults to
    opening the *lpc1114_first4096.bin* file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 6-4: Erase and reprogram an entire page of memory.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have this file, you could simply set the value of `image = [0]*4096`,
    which would overwrite the flash page with zeros (0s). This means the code will
    no longer run, but we don’t care about the code running; we care only about whether
    we can bypass the code read-protection.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-5](#listing6-5) uses the data from [Listing 6-4](#listing6-4) to
    lock the device so we can perform an attack as it would be done in the real world:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 6-5: Locking the device using the ISP API interface'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a locked device, we can begin to investigate further and scope
    our attack.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Using Power Analysis to Determine Fault Injection Timing
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this case, we’re going to cheat and begin with a “good” power waveform to
    see around what time we should be inserting our glitch. [Figure 6-8](#figure6-8)
    shows that we inserted a 12 Ω shunt resistor. Its function is not only to facilitate
    fault injection, but also to allow us to look at the power waveforms. In our crowbar
    attack example, we connect an oscilloscope across the shunt resistor and record
    the DC level of the power rail, as shown in the middle trace in [Figure 6-9](#figure6-9).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![f06009](image_fi/278748c06/f06009.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-9: Power rail traces while booting'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Halfway along this trace is the glitch that the crowbar injected. The bottom
    row shows a zoomed-in look at the variations on the power rail on either side
    of the glitch, which we call the power trace. The top row shows a trace of the
    LPC1114’s reset output. The variations in the power trace make it possible to
    see different operations executed on the CPU. The specific part that we want to
    interrupt is the process of loading the word that locks the flash from memory.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, using the power trace is critical for understanding what sort
    of glitch parameters cause the device to misbehave. One thing we want to watch
    out for is too strong a glitch, which resets the device and restarts the device
    again; that would not be very informative for us!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Beyond looking at the power trace on an oscilloscope, [Listing 6-6](#listing6-6)
    shows a simple script that enables the ChipWhisperer-Nano to capture the power
    trace.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 6-6: Python script to capture boot power trace'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The trace is shown in [Figure 6-10](#figure6-10). The higher-end ChipWhisperer-Lite
    and ChipWhisperer-Pro will provide a more detailed power trace, but even this
    $50 ChipWhisperer-Nano has enough for us to see the details of the boot process.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![f06010](image_fi/278748c06/f06010.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-10: Power trace of the LPC1114’s boot process, as measured in [Listing
    6-6](#listing6-6)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: What does this information provide? First, it enables us to examine and characterize
    the effect of a potentially useful glitch. Second, we use the ChipWhisperer-Nano
    to trigger the glitch insertion by running the code in [Listing 6-7](#listing6-7)
    (if you’re using ChipWhisperer-Lite, see the companion notebook).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 6-7: Turning on a glitch on the ChipWhisperer-Nano'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: In the code from [Listing 6-7](#listing6-7), the `scope.glitch.repeat` parameter
    is how many cycles the glitch is “applied” for (the glitch width from Chapter
    5). The `scope.glitch.ext_offset` parameter is the offset from the trigger event
    until the glitch is inserted, which defines the timing of where the glitch occurs.
    The parameters are somewhat “unitless” here because the numbers represent a number
    of cycles’ delay based on the microcontroller’s internal oscillator. We rarely
    care about the “actual” values; we just want to be able to re-create them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Once the `repeat` (glitch width) and `ext_offset` (glitch offset) settings are
    locked in, they will automatically be applied on the next trigger. If we run [Listing
    6-6](#listing6-6) again (after first having run [Listing 6-7](#listing6-7)), we
    now get a power waveform with a glitch inserted at some point. [Figure 6-11](#figure6-11)
    shows the results.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: In this example, it looks like we’re using too aggressive of a glitch inserted
    around clock cycle 250\. The glitch is probably too wide. After the glitch is
    inserted, the device seems to have muted. The power trace no longer looks like
    it’s executing code, which is bad since we have probably tripped a brown-out detector
    or otherwise reset the device. We’ll need to adjust parameters and try again.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![f06011](image_fi/278748c06/f06011.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-11: A glitch inserted around cycle 250 has caused the device to reset.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Compare this to when we change the value of `scope.glitch.repeat` in [Listing
    6-7](#listing6-7), setting the `repeat` to 10\. [Figure 6-12](#figure6-12) shows
    the power trace.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![f06012](image_fi/278748c06/f06012.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-12: A glitch inserted around cycle 250 has not interrupted the normal
    boot.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: We still see the glitch inserted around cycle 250, but it seems that the device
    has continued to execute code! We want to sweep around glitch widths just between
    those that are too wide (causing a reset) and those that seem to let the device
    run as normal. This power analysis measurement allows us to characterize the board
    and understand what glitch widths we need for the next step. In this case, a width
    (`scope.glitch.repeat` setting) of 14 was about the upper limit before the device
    often would reset. This means for the sample board, we’d try widths in the range
    of 9 to 14 first (the lower end is somewhat arbitrary; you might need to reduce
    the lower end even further, but at some point, the glitch is too narrow and has
    no effect). Again, these units are relatively arbitrary; we don’t care about the
    exact measurement because we simply found the range between where the device reset
    and where the device seemed to operate normally. You may find these numbers vary
    on your target and setup.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然看到故障大约在250周期左右插入，但似乎设备继续执行代码！我们想要扫描那些故障宽度，这些宽度既不太宽（导致重置），也不至于让设备恢复正常运行。这种功率分析测量允许我们对电路板进行表征，了解下一步所需的故障宽度。在这种情况下，宽度（`scope.glitch.repeat`设置）为14，大约是设备经常重置之前的上限。这意味着对于该样本电路板，我们首先会尝试9到14之间的宽度（下限有些是任意的；你可能需要进一步减少下限，但在某个点上，故障会太窄而没有效果）。再次强调，这些单位是相对任意的；我们不关心精确的测量，因为我们只是找到了设备重置和设备似乎正常运行之间的范围。你可能会发现这些数字在你的目标和设置中会有所不同。
- en: If you are trying to re-create this glitch insertion using some other signal
    generator besides the ChipWhisperer-Nano, you can easily check with an oscilloscope
    to see whether the device is resetting after your glitch or is continuing to boot.
    Using this method, it’s easy to tune the glitch parameters to reduce the search
    space.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用除了ChipWhisperer-Nano之外的其他信号发生器重新创建此故障插入，可以很容易地使用示波器检查设备在故障发生后是重置了还是继续启动。通过这种方法，你可以轻松调整故障参数，减少搜索空间。
- en: In future chapters, we’ll look at power analysis and how to use it to show where
    in the device program certain values are being processed. Performing a “power
    analysis attack” is possible on the configuration word in that we can measure
    when these words are actually loaded. If you’re interested in seeing that code,
    the LPC1114 example as part of ChipWhisperer-Jupyter repository on GitHub ([https://github.com/newaetech/chipwhisperer-jupyter/](https://github.com/newaetech/chipwhisperer-jupyter/))
    goes into more details.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨功率分析以及如何利用它来显示设备程序中某些值处理的具体位置。执行“功率分析攻击”是可能的，我们可以测量这些配置字何时实际被加载。如果你有兴趣查看相关代码，可以参考GitHub上的ChipWhisperer-Jupyter仓库中的LPC1114示例([https://github.com/newaetech/chipwhisperer-jupyter/](https://github.com/newaetech/chipwhisperer-jupyter/))，里面有更多的细节。
- en: From Fault Attack to Memory Dump
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从故障攻击到内存转储
- en: Now that we can see the device booting, we are basically ready to insert a fault.
    All we’ll do is make a script to sweep the timing of the glitch and see whether
    the device comes up as unlocked. If the device does come up unlocked, we can take
    the full step of dumping the entire flash memory.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到设备启动，我们基本上已经准备好插入故障。我们要做的就是编写一个脚本，扫描故障的时序，看设备是否能解锁。如果设备成功解锁，我们就可以进行下一步，转储整个闪存。
- en: '[Listing 6-8](#listing6-8) shows the important parts (see the Jupyter Notebook
    for the full example). Here we specify an offset range that we can sweep along
    to find the useful information. You should know that the 100 percent success of
    the code depends on your physical connections; you may need to run this multiple
    times before it works. We’ve also cheated by giving a very narrow range of the
    offset, which helps by allowing us to repeat the attack multiple times.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表6-8](#listing6-8)展示了重要部分（查看Jupyter笔记本中的完整示例）。在这里，我们指定了一个偏移范围，可以沿着这个范围进行扫描，找到有用的信息。你需要知道，代码的100%成功率取决于你的物理连接；你可能需要多次运行此代码才能成功。我们还通过给出一个非常狭窄的偏移范围作弊，这有助于我们多次重复攻击。'
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 6-8: Sweeping the glitch width and offset while attempting to read
    the CRP status'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-8：在尝试读取CRP状态时，扫描故障宽度和偏移量
- en: After each glitch attempt, an attempt is made to read from memory 1. If successful,
    the entire flash memory is read out, and you then have complete access to and
    control over the LPC1114 processor. If you don’t have success, first check the
    timing using a power trace. We empirically found that around 51µs was required
    on the LPC1114, but that will change with voltage, temperature, and production
    batch.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每次故障尝试后，都会尝试从内存 1 中读取数据。如果成功，整个闪存会被读取出来，你就可以完全访问和控制 LPC1114 处理器。如果没有成功，首先检查使用功率跟踪的时序。我们通过实验发现，LPC1114
    需要大约 51µs，但这会随着电压、温度和生产批次的变化而变化。
- en: Also check what the glitch waveform looks like, which will vary with longer
    or shorter wires. Because the ChipWhisperer-Nano has more limited resolution on
    the glitch width and offset, the attack is less successful with any given hardware
    setup than on the ChipWhisperer-Lite. You may find you need to use longer or shorter
    wires, for example, to adjust the glitch parameters physically. But before you
    go to the effort of further tuning, let it run for some time. Letting the attack
    run for an hour or two may result in a successful parameter set, as shown in [Listing
    6-9](#listing6-9).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 还要检查故障波形的形状，它会随着更长或更短的电线而变化。由于 ChipWhisperer-Nano 在故障宽度和偏移上的分辨率较低，因此与 ChipWhisperer-Lite
    相比，任何给定硬件设置下的攻击成功率较低。例如，你可能需要使用更长或更短的电线来物理调整故障参数。但在进一步调整之前，可以让攻击运行一段时间。让攻击运行一到两个小时，可能会得到一个成功的参数设置，如[列表
    6-9](#listing6-9)所示。
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 6-9: Output of running script with a successful glitch'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-9：运行脚本时成功故障的输出
- en: Once the attack is successful, it’s simply a matter of performing the flash
    read, which requires looping through all memory to read out the chip. Using the
    `nxpprog` library makes this even easier; see the companion GitHub repository
    for this book for examples of achieving this task, this is linked from [https://nostarch.com/hardwarehacking](https://nostarch.com/hardwarehacking).
    You could also unlock the device by reprogramming the configuration words, which
    should even allow you to attack a device with a full lock that disables the ISP
    and JTAG.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦攻击成功，接下来就是执行闪存读取，这需要循环读取所有内存以获取芯片数据。使用`nxpprog`库可以让这一过程更简单；有关如何完成此任务的示例，请查看本书的配套
    GitHub 仓库，链接地址为[https://nostarch.com/hardwarehacking](https://nostarch.com/hardwarehacking)。你还可以通过重新编程配置字来解锁设备，这应该能够让你攻击一个完全锁定的设备，解禁
    ISP 和 JTAG。
- en: Never mind all the possibilities; simply receiving the success message indicates
    that you were able to corrupt the configuration word and thus bypass read protection!
    If you are relying on such security methods, it’s a useful exercise to perform
    to help you understand how others might bypass them.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不必担心所有可能性；只要收到成功消息，就意味着你已经能够破坏配置字，从而绕过读取保护！如果你依赖于这样的安全方法，执行这一练习是有用的，它能帮助你理解别人是如何绕过这些安全措施的。
- en: Mux Fault Injection
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多路复用故障注入
- en: We’ve gone through an example using a crowbar, but it’s also useful to look
    at other methods of performing the voltage fault injection. The most common of
    these other methods is to use a multiplexor (mux) that switches between the regular
    operating voltage and the “glitch” voltage. The only problem with using the mux
    is that it may increase the chance of damaging the target. If you are glitching
    the device to a negative voltage, for example, you might discover that the negative
    voltage is too far out of spec. In our case, we’ll use in-range voltages to avoid
    that risk.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用起重棒进行了一个示例，但查看其他执行电压故障注入的方法也很有帮助。最常见的其他方法是使用多路复用器（mux），它在常规操作电压和“故障”电压之间切换。使用多路复用器的问题是，它可能会增加损坏目标的风险。例如，如果你正在对设备进行负电压故障注入，你可能会发现负电压超出了规格范围。在我们的例子中，我们将使用范围内的电压来避免这种风险。
- en: Mux Hardware Setup
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多路复用硬件设置
- en: We discussed the mux as a fault injection method for the voltage-switching-based
    injector in Chapter 5, so see that chapter for details of how to build the fault
    injector circuitry using a multiplexor.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 5 章中讨论了将多路复用器作为电压切换注入器的故障注入方法，详细内容请参见该章节，了解如何使用多路复用器构建故障注入电路。
- en: To use a multiplexor for this example, we use the same LPC1114 development board
    as shown in [Figure 6-8](#figure6-8), but this time without the 12 Ω shunt resistor
    that connected the input voltage to the core voltage. Remove it if it is already
    mounted. The trace must be cut so that the core voltage for the microcontroller
    is now coming entirely from an external source. We’ll be connecting the mux output
    to the core voltage of the LPC1114 development board, meaning that LPC1114 is
    always being powered from the mux output.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’re going for a two-chip solution using a complementary
    pair of analog switches: the TS12A4514 is normally open, and the TS12A4515 is
    a normally closed switch. [Figure 6-13](#figure6-13) shows the schematic for this
    solution.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![f06013](image_fi/278748c06/f06013.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-13: Schematic showing a simple multiplexor for mux glitching'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The TS12A4514 feeds the standard 3.3 V VCC from the ChipWhisperer-Nano through
    to the LPC1114, while the TS12A4515 feeds through a lesser voltage, as determined
    by the voltage set by the variable resistor VR1\. This means with each toggle
    of the ChipWhisperer-Nano’s I/O pin, we toggle each analog switch at pin 6 and
    cause the voltage fed through to the LPC1114 to switch between the standard VCC
    on the TS12A4514 and the adjusted VCC on the TS12A4515\. In comparison with the
    crowbar glitch schematic in [Figure 6-7](#figure6-7), only connections to VDD
    change; the serial and triggering connections remain the same.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: In our build, we stacked a TS12A4514 (bottom) and TS12A4515 (top) and soldered
    them together. The two switched voltage pins (pin 8 of U2 and U3) are the only
    pins not soldered together, as they have different connections; see [Figure 6-14](#figure6-14)
    for details.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![f06014](image_fi/278748c06/f06014.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-14: A TS12A4514 (bottom) and TS12A4515 (top) stacked (hacked) together'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-15](#figure6-15) shows the mux-based fault injection setup; we’ll
    go through the low-level details of each part next.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![f06015](image_fi/278748c06/f06015.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-15: The complete setup for performing a mux attack'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'First, note that the 12 Ω resistor has been removed from the target 1, as previously
    mentioned. For the switching-based glitch using a multiplexor, we need to specify
    two voltages: the regular voltage and the “glitch” voltage. In this case, to make
    life a bit easier, we’ll use similar voltages to those we used in the previous
    crowbar section. The regular voltage is the standard 3.3 V supply, taken off the
    JTAG connector from the LPC1114 board. The glitch voltage is similar to the crowbar
    setup where we tried to bring the power supply to ground (0 V). Going right to
    0 V might reset the device too quickly, so instead we put a variable resistor
    (VR1) in the path. Because the target device typically has some capacitance on
    the positive rails, using a resistor means the volage is not driven down to 0
    V (GND) as quickly. In the figure, we’re using a standard variable resistor 3.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: On the ChipWhisperer-Nano, we unsolder the two solder jumpers on the target
    side 2. This step is required because we’ll now be using the glitch output to
    drive the mux, but we’ll still want to use the measurement capability. By default,
    the glitch output and measurement are tied together on the target board. This
    setup was okay in the previous section when the glitch output was directly connected
    to the target voltage. Now we need to decouple the measurement and glitch from
    each other. Separating off the target side of the ChipWhisperer-Nano would accomplish
    the same goal and ensure no conflict of the I/O lines. Simply unsoldering the
    solder jumpers, however, may be less aggressive in case you still want to use
    the included target.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: To trigger the mux switch, we simply need a digital I/O signal that sweeps along
    a timeline, thereby inserting a voltage switch at different points in the target’s
    boot sequence. We could use an external FPGA or signal generator, but in this
    example, we’ll use the same ChipWhisperer-Nano or ChipWhisperer-Lite glitch output
    that we used in the crowbar example. The glitch trigger output only drives low,
    so a 1 kΩ resistor pulls the line high when it is not being driven low. We can
    use this glitch trigger output as an input to the mux select line, remembering
    that it is “active-low” when we want to insert a glitch the line drives low.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The TS12A4515P switches the preset glitch voltage (as set by VR1) through to
    the LPC1114 power rail when its input (at the combined pins 6) from the ChipWhisperer-Nano
    glitch trigger is low. Conversely, the TS12A4514P switches the normal 3.3 V VCC
    through to the LPC1114 power rail when its input (also at combined pins 6) from
    the ChipWhisperer-Nano glitch trigger is high. Whenever the glitch output trigger
    from the ChipWhisperer is low, the glitch voltage is switched through to the LPC1114
    power rail by the mux, at any time and for any length of time, as programmed in
    and controlled by the ChipWhisperer.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: To view the mux output together with the boot waveforms in progress at and around
    the time of the glitch, similar to what’s shown in [Figure 6-9](#figure6-9), you
    can measure pin 1 of the mux. This is essential for tuning the glitch moment and
    width. In this example, instead of relying on an oscilloscope, we set the ChipWhisperer-Nano
    to capture the power line signal, as in the crowbar example. One caveat of the
    ChipWhisperer-Nano is that it has a fixed input gain; you may find that the power
    line signal is swamping the input, making it difficult to observe. For this reason,
    a 220 Ω resistor (R3) has been inserted, which forms a voltage divider with the
    ChipWhisperer-Nano measurement input. You may need to adjust this resistor depending
    on the multiplexor you’re using. The ChipWhisperer-Lite allows adjusting the gain,
    so it does not require this same change and can directly observe the LPC1114 core
    voltage.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Tuning Glitch Settings
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As in the crowbar fault injection example, we’ll need to adjust the glitch settings.
    Previously, we had to adjust only the glitch width; now we also need to adjust
    the glitch voltage. In doing so, to keep things simple, we use a variable resistor
    to adjust the glitch “strength” rather than applying a specific voltage setting.
    We tune this resistor, view or capture a power measurement again during the boot
    process, and see how inserting various different glitch voltages affects it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using the ChipWhisperer-Nano, this means running the script shown
    in [Listing 6-6](#listing6-6). As before, you can see how to adjust the glitch
    width in [Listing 6-7](#listing6-7). Switching between a very narrow glitch (`scope.glitch.repeat
    = 1`) and a wider glitch (`scope.glitch.repeat = 50`) should result in the narrow
    glitch not resetting the target and the wider glitch resetting the target.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: You can also adjust resistor VR1 to see how it affects the results. You should
    find that a larger VR1 value allows you to use a wider glitch setting before the
    device resets. Again, see Figures 6-11 and 6-12 for examples of what the power
    trace looks like in both reset and non-reset situations. The addition of the resistor
    gives us another item to tweak. Imagine if the setting of `scope.glitch.repeat
    = 6` allowed the device to work normally and `scope.glitch.repeat = 7` always
    caused a reset. We want a setting that *almost* resets the device. A reset isn’t
    useful, but you could tweak the resistor value to the point where it doesn’t always
    reset the device.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: As a sanity check, first connect both mux inputs to +3.3 V, and you should see
    that the target won’t glitch. Then connect one of the mux inputs directly to GND,
    and you should find that even narrow glitches cause the target to reset. From
    there, use the variable resistor to find the ideal in-between setting.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve found a good setting for the voltage that has been set by the variable
    resistor (in our experiment, the “good” setting was a resistance of 34 Ω), you
    can again find the setting for the glitch width where the target is becoming unstable
    and resetting. When we dialed in the resistance setting, we were using a very
    wide glitch, so now we want to fine-tune the width to reduce our search space
    as well.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the crowbar glitch, we found a slightly narrower glitch was required.
    [Listing 6-10](#listing6-10) shows an example of the successful dump output; note
    that the timing offset is about the same as that determined by the crowbar insertion
    but that the width is different.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 6-10: Using a mux results in the same successful glitch output as when
    using a crowbar.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: If you do adjust the regular operating voltage, the timing of the glitch will
    change. The operating voltage of the device changes the internal oscillator frequency
    slightly (in addition to natural variations between devices). This means that
    running the target at 2.5 V instead of 3.3 V will likely have a pronounced effect
    on the moment in the boot process where the glitch ends up being inserted.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Act 3: Differential Fault Analysis'
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whereas the previous acts used fault injection to impact a result, this act
    uses fault injection to corrupt the otherwise perfect and secure math that underpins
    modern cryptography. In particular, we are going to attack RSA using a particularly
    common RSA implementation. These types of faults make it possible to use a *differential
    fault analysis (DFA)* attack. DFA attacks rely on an attacker being able to run
    the cryptographic operation while a fault is inserted and to compare the result
    of the faulty operation with the normal operation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: A Bit of RSA Math
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The 2001 paper “On the Importance of Eliminating Errors in Cryptographic Computations,”
    by Dan Boneh, Richard A. DeMillo, and Richard J. Lipton, introduced the Bellcore
    DFA attack on RSA. It must be one of the most effective DFA attacks, so in this
    act, we’ll take you on the ride called “Single Fault, All Key Bits.” Although
    this is a magical outcome, it is not super complicated mathematically. The Bellcore
    attack focuses on a particular variant of RSA, called the *RSA-CRT (Chinese Remainder
    Theorem)*. RSA-CRT was invented to speed up calculating RSA signatures by doing
    the RSA modular integer arithmetic on smaller numbers, while (of course) leading
    to the same result.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll discuss textbook RSA and then show how RSA-CRT is implemented.
    We’ll discuss RSA again in Chapter 8 when we introduce the power analysis attack.
    Understanding how RSA works for a fault attack needs more details than for power
    analysis, so this section goes a little deeper than what you’ll need for Chapter
    8 (in case the following math throws you off). Since this is a hardware book,
    refer to your favorite crypto textbook for more details. If you don’t yet have
    a favorite, Jean-Philippe Aumasson’s *Serious Cryptography* (No Starch Press,
    2018) is a good candidate, and it covers RSA in Chapter 10\. The following math
    has tons of cryptographic and number theory background, but all you really need
    is high-school-level algebra to understand why the attacks work.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The workings of RSA start off with two prime numbers, *p* and *q*, which together
    form the basis for the *private key*. The *public key* is simply *n*, with *n*  =  *pq*.
    The secrecy of *p*  and *q* is due to the inherent difficulty in factorization
    of very large numbers, meaning no known efficient algorithms exist for recovering
    *p* and *q* from only *n*. The next component of RSA is in choosing a number called
    the *public exponent* *e*. A common choice is 2^(16) + 1\. The *private exponent*
    *d* is now calculated as *d*  =  *e*^(–1) mod  λ(*n*), where λ is Carmichael’s
    totient function (its implementation isn’t relevant for the following attack,
    so you can simply nod knowingly about the existence of this function).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using RSA to sign a given message, the message *m* is what the RSA
    signature protects. RSA signing is done by calculating *s*  =  *m*^(*d*)  mod  *n*.
    The message *m* is simply an integer (number). In practice, we have a *padding
    scheme* that converts from a typical string or binary message to the integer *m*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: RSA is pretty computationally expensive. Consider that the private exponent
    is, for modern-day security, at least 2,048 bits long and that the complexity
    of the modular exponentiation *m*^(*d*) mod *n* increases with the cube of the
    number of bits in *n*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the Chinese Remainder Theorem. The idea is to split the calculation into
    two parts, leveraging the fact that *n* is a product of two primes. The private
    key in RSA-CRT is based on the primes *p* and *q*, mentioned previously. We could
    represent this key, still based only on the values of *p* and *q*, as three numbers:
    *d*[*P*]  =  *d*  mod  *p* – 1,  *d*[*Q*]  =  *d*  mod  *q* – 1, and *q*[inv]
    =  *q*^(–1)  mod  *p*. With this implementation, we now can calculate a signature
    as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '*s*[*P*] = *m*^(*d*)^([*P*])mod *p*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '*s*[*Q*] = *m*^(*d*)^([*Q*])mod *q*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '*s* = *s*[*Q*] + *q*(*q*[inv](*s*[*P*] – *s*[*Q*])mod *p*)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the moduli (*p* and *q*) are now half the number of bits, calculating
    a signature is roughly four times faster (that’s good). Also, a differential fault
    analysis (DFA) attack can now be performed with just one fault (that’s bad). To
    appreciate why, consider that we inject a fault, any fault, during the calculation
    of *s*[*P*], and let’s call the faulty result *s''*[*P*]. We’ll also have a corrupted
    signature as a result, *s''*. Next, we can do a bit of algebraic magic:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '*s''* = *s*[*Q*] + *q*(*q*[inv](*s''*[*P*] – *s*[*Q*])mod *p*)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we subtract *s''* from *s*:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '*s* – *s''* = *s*[*Q*] + *q*(*q*[inv](*s*[*P*] – *s*[*Q*])mod *p*) – *s*[*Q*]
    – *q*(*q*[inv](*s''*[*P*] – *s*[*Q*])mod *p*)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'and we remove *s*[*Q*] from both sides:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '*s* – *s*'' = *q*(*q*[inv](*s*[*P*] – *s*[*Q*])mod *p*) – *q*(*q*[inv](*s''*[*P*]
    – *s*[*Q*])mod *p*)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Next, we recognize that *q* times some integer, minus *q* times some other integer,
    can be written as
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '*s* – *s''* = *qk*[1] – *qk*[2] = *kq*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: where *k*[1], *k*[2],and *k* are some (unknown) integers. This is for a fault
    in *s*[*P*]. If you happen to fault during the calculation of *s*[*Q*], you end
    up with *s* – *s'* =  *kp*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use an efficient algorithm for calculating the *greatest common divisor
    (GCD)*. The GCD of two integers *i* and *j* gives the largest positive integer
    that divides into both numbers. For example, the GCD of 36 and 24 is 12, because
    12 divides into both 36 and 24\. No number greater than 12 divides both 36 and
    24\. We’ll write this as GCD(36, 24) = 12.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: A prime number, by definition, can be divided only by itself and 1\. In RSA,
    the modulus of *n* = *pq*, so it’s divisible only by 1, *p*, and *q*. Since GCD(*q*,
    *n*) = GCD(*q*, *pq*) =  *q*, the GCD of *n* and any integer *kq* (with *k* less
    than *p*) is *q*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: From our attack, we can calculate *s* – *s'*, and we know it’s a multiple *k*
    of *q* (with *k* less than *p*). We calculate GCD(*s* – *s'*, *n*) = GCD(*kq*,
    *pq*) =  *q*. This works because *p* and *q* are primes, so no other divisors
    exist for *n*. Now, since we have *q*, we easily calculate *p* =  *n* ÷ *q*, and
    we have both private primes and thus the RSA private key!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Note that for this attack to work, we need both *s* and *s'*, which means signing
    the same message *m* twice and corrupting one of the two signature calculations.
    Doing that may not always be possible in practice, because padding schemes like
    *Optimal Asymmetric Encryption Padding (OAEP)*, such as used in the PKCS#1 cryptographic
    standard, randomizes part of the message *m* on the signer’s end. Luckily, Arjen
    Lenstra, a famous cryptographer, wrote a memo to the Bellcore authors showing
    a successful attack that requires only the corrupted signature.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is fairly similar to the preceding one, where we did some algebra
    to derive a value for which the GCD with *n* gives one of the primes. The difference
    with before is that we don’t have an *s*, only an *s''*. We can use our previously
    derived equation that relates them:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '*s* − *s*′ = *kq*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '*s* = *s*′ + *kq*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we’ll substitute the *s* as follows in the RSA message equation:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '*m* = *s*^(*e*)mod *n* = (*s*′ + *kq*)^(*e*)mod *n*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the binomial theorem to do some rewriting. The binomial theorem
    states the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![e06001](image_fi/278748c06/e06001.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: So, we’ll write
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![e06002](image_fi/278748c06/e06002.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: 'and we’ll bring out the expression for *i* = 0:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![e06003](image_fi/278748c06/e06003.png)![e06004](image_fi/278748c06/e06004.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: 'We’ll also divide one of the *kq* terms out of the summation:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![e06005](image_fi/278748c06/e06005.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: 'We replace the summation with *x*, where *x* is some integer:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '*m* = [*s*''^(*e*) + *kqx*]mod *n*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '*m* − *s*^(''*e*) = *kqx* mod *n*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'We then find *q* with the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: GCD(*m* − *s*'^(*e*), *n*) = GCD(*kqx*, *n*) = GCD(*kqx*, *pq*) = *q*
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Since *p*  =  *n* ÷ *q*, we have the full private key. As before, this works
    symmetrically for a fault in *s*[*Q*].
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Getting a Correct Signature from the Target
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this example, we’ll use this chapter’s Jupyter Notebook, which has an RSA-CRT
    fault simulator and can also run on the ChipWhisperer-Lite with a 32-bit ARM (NAE-CWLITE-ARM)
    target. You can configure your choice at the top of the notebook. For the hardware,
    it walks you through loading the firmware, getting a signature from the device,
    and verifying it is correct.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: You can use whatever other target you want; all you need to do is build a fault
    injection setup with the target and implement an RSA-CRT on the target. The RSA-CRT
    takes in a message *m* and returns the signature *s*. You can modify the code
    from the notebook for your firmware and build setup.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Injecting the Fault in the Simulator
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For the simulator in the notebook, we implement the RSA-CRT computation as
    described in the earlier formulae. Just like on the real hardware, we’re signing
    a PKCS#1 v1.5 padded hash of the message. Luckily, this standard’s fairly simple.
    PKCS#1 v1.5 padding looks like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the `ff...` part is a string of `ff` bytes long enough to make the size
    of the padded message the same size as *n*, while `hash_prefix` is an identifier
    number for the hash algorithm used on `message_hash`. In our case, SHA-256 has
    the hash prefix of `3031300d060960864801650304020105000420`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Altogether, the padded and hashed message “Hello World!” looks like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have the final message, we push that through the RSA-CRT computation,
    but not without first simulating some faults. For this, we flip a number of bits
    in *s*[*P*] at random to obtain *s'*[*P*]. As the preceding attack explains, it’s
    not important what the fault really is. We could have also set *s*[*P*] to the
    binary expansion of π, 0, or our pet’s birthday. Next, we calculate the faulty
    signature *s'*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Injecting the Fault on Hardware
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For hardware, the relaxed conditions on when and where to fault also help us:
    any fault will do, as long as it’s sometime during the calculation of *s*[*P*]
    or *s*[*Q*]. Since these calculations take up almost the entire RSA-CRT calculation,
    most of the time between receiving the message and calculating the signature is
    spent on the calculation of *s*[*P*]and *s*[*Q*]. This means you can try your
    luck and blindly inject faults somewhere within the time window of the signature
    calculation.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: If you want a bit more visibility as to what you’re doing, take a power trace
    to see the timing of the RSA operation. For example, the power trace in [Figure
    6-16](#figure6-16) is from an STM32F30, where the operation is split into two
    main sub-operations.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![f06016](image_fi/278748c06/f06016.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-16: MBED-TLS running an RSA signature operation'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: You can see the two halves of the signature calculation split around cycle 500,000,
    separated by a small blip. This pattern is very common for RSA-CRT, and, in fact,
    seeing it can make it obvious that a device is running RSA-CRT without any internal
    knowledge of the device. We’ll look more at power analysis in the next chapter
    as well as how to use it to recover secret information from a device.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'With the timing down, we can inject faults. In the notebook for this exercise,
    we’ve selected a range between 7,000,000 and 7,100,000 in which to inject faults,
    which is somewhere in the middle of the second half of the signature computation.
    From earlier characterization of the device, we know some possible fault parameters
    we could use, and we hardcode these in the notebook. If we are unsure on the timing,
    we can simply sweep through some approximate timings, as this snippet of code
    shows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We use a loop to get the target to perform signature operations while we inject
    faults. We would then need to check the result to see whether the target returned
    something that looks like a corrupted signature, rather than a target crash or
    hard error. The code to check whether the output is valid for each timing is in
    the companion notebook.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: We identify candidate signature corruptions by the fact that the signature returned
    from the device has the correct length but does not pass RSA verification. If
    it has an incorrect length, we most likely corrupted something besides the signature
    calculation, so we can discard those instances.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: In the notebook, we cheat and simply check to see whether the “expected” output
    does not appear in the signature (the expected output being the result of a correct
    signature). It’s an even easier way of checking whether the signature doesn’t
    validate.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: After running this code, we’ll have captured a faulty signature that we can
    use to recover the primes. Usually, this method will work. If you encounter a
    corner case where it doesn’t, it’s easy to grab another faulty signature and try
    again.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'If you aren’t going the ChipWhisperer route and have your own setup or target,
    make sure to characterize first: find fault injection parameters that will result
    in some visible corruption of the signature. The telltale sign of a useful corruption
    is when the data returned for the signature changes without the length of the
    signature changing. The amusing part of this attack is that a successful characterization
    will already yield a corrupted signature, which means we’re done with the fault
    injection part.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Completing the Attack
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once we have the glitched signature, either from hardware or the RSA-CRT simulator,
    we’ve still got a little work to do. Let’s assume we have a variable called `s_crt`
    that is the correct signature and a variable called `s_crt_x` that is the corrupted
    signature. These are just big numbers. As an example, the value of `s_crt_x` when
    printed in hex looks like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Earlier, we had the simple equation for calculating the primes *p* and *q* out
    of the corrupted signature and either the correct signature or the message. The
    notebook implements both methods for recovering the primes using the GCD. As you’ll
    see, this computation takes only a fraction of a second to complete before printing
    out the private primes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take one of the implementations from the notebook for finding the private
    primes using the corrupted signature and the correct signature:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of this block shows the calculated values of `p` and `q`. To confirm
    that they’re correct, we simply check whether multiplying them together gives
    us the (public and, thus, known) value of `N`. The following shows an example
    of running the preceding code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Et voilà! We’ve factored `N` from one corrupted signature and know the private
    primes `p` and `q`. All it took was a single fault inserted at almost an arbitrary
    time during the signature operation.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Hardened implementations have one more trick that we should bypass in real
    life, however: the actual `mbedTLS` library checks whether it’s returning a faulty
    signature, which it does simply by checking that the signature works as expected.
    In the sample firmware, we’ve commented out that line. In reality, you would use
    fault injection to bypass the check. Although a double-fault sounds tricky, it’s
    made easier because the initial fault (in the RSA operation) requires almost no
    precision on the timing, so the only complicated part is timing the fault on the
    signature validation check.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we walked through three different examples of performing fault
    injection attacks, starting with the most basic scenario of a fault attack on
    a loop and finishing with how you can dump RSA keys using fault attacks.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that fault injection in practice is a stochastic process. The specific
    type of fault and resulting effect will vary considerably, and even can change
    with different device lock codes and as manufacturers work to protect devices
    against fault attacks.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: If you are performing the experiments in this chapter yourself, don’t despair
    if things don’t work reliably the first time. Try multiple methods of performing
    the fault injection, and more important, experiment with some of the simple examples
    first to see what variety of faults you can inject.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll step things up and attack an off-the-shelf device.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
