- en: Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![CONSTANTS, VARIABLES, AND DATA TYPES](tagoreillycom20100401nostarchimages577853.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Chapter 2](ch02.html "Chapter 2. DATA REPRESENTATION") discussed the basic
    format for data in memory. [Chapter 3](ch03.html "Chapter 3. MEMORY ACCESS AND
    ORGANIZATION") covered how a computer system physically organizes that data in
    memory. This chapter finishes the discussion by connecting the concept of *data
    representation* to its actual physical representation. As the title implies, this
    chapter concerns itself with three main topics: constants, variables, and data
    structures. This chapter does not assume that you''ve had a formal course in data
    structures, though such experience would be useful.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discusses how to declare and use constants, scalar variables, integers,
    data types, pointers, arrays, records/structures, unions, and namespaces. You
    must master these subjects before going on to the next chapter. Declaring and
    accessing arrays, in particular, seems to present a multitude of problems to beginning
    assembly language programmers. However, the rest of this text depends on your
    understanding of these data structures and their memory representation. Do not
    try to skim over this material with the expectation that you will pick it up as
    you need it later. You will need it right away, and trying to learn this material
    along with later material will only confuse you more.
  prefs: []
  type: TYPE_NORMAL
- en: '4.1 Some Additional Instructions: intmul, bound, into'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces arrays and other concepts that will require the expansion
    of your 80x86 instruction set knowledge. In particular, you will need to learn
    how to multiply two values; hence the first instruction we will look at is the
    `intmul` (integer multiply) instruction. Another common task when accessing arrays
    is to check to see if an array index is within bounds. The 80x86 `bound` instruction
    provides a convenient way to check a register's value to see if it is within some
    range. Finally, the `into` (interrupt on overflow) instruction provides a quick
    check for signed arithmetic overflow. Although `into` isn't really necessary for
    array (or other data type) access, its function is very similar to `bound`; hence
    the presentation of it at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `intmul` instruction takes one of the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that the syntax of the `intmul` instruction is different from that of the
    `add` and `sub` instructions. In particular, the destination operand must be a
    register (`add` and `sub` both allow a memory operand as a destination). Also
    note that `intmul` allows three operands when the first operand is a constant.
    Another important difference is that the `intmul` instruction allows only 16-bit
    and 32-bit operands; it does not multiply 8-bit operands.
  prefs: []
  type: TYPE_NORMAL
- en: intmul computes the product of its specified operands and stores the result
    into the destination register. If an overflow occurs (which is always a signed
    overflow, because `intmul` multiplies only signed integer values), then this instruction
    sets both the carry and overflow flags. `intmul` leaves the other condition code
    flags undefined (so, for example, you cannot meaningfully check the sign flag
    or the zero flag after executing `intmul`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bound` instruction checks a 16-bit or 32-bit register to see if it is
    between two values. If the value is outside this range, the program raises an
    exception and aborts. This instruction is particularly useful for checking to
    see if an array index is within a given range. The `bound` instruction takes one
    of the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bound` instruction compares its register operand against an unsigned lower
    bound value and an unsigned upper bound value to ensure that the register is in
    the range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The form of the `bound` instruction with three operands compares the register
    against the second and third parameters (the lower bound and upper bound, respectively).^([[47](#ftn.CHP-4-FN-1)])
    The `bound` instruction with two operands checks the register against one of the
    following ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the specified register is not within the given range, then the 80x86 raises
    an exception. You can trap this exception using the HLA `try..endtry` exception-handling
    statement. The *excepts.hhf* header file defines an exception, `ex.BoundInstr`,
    specifically for this purpose. The program in [Example 4-1](ch04.html#demonstration_of_the_bound_instruction
    "Example 4-1. Demonstration of the bound instruction") demonstrates how to use
    the `bound` instruction to check some user input.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1. Demonstration of the `bound` instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `into` instruction, like `bound`, also generates an exception under certain
    conditions. Specifically, `into` generates an exception if the overflow flag is
    set. Normally, you would use `into` immediately after a signed arithmetic operation
    (e.g., `intmul`) to see if an overflow occurs. If the overflow flag is not set,
    the system ignores `into`; however, if the overflow flag is set, then the `into`
    instruction raises the `ex.IntoInstr` exception. The program in [Example 4-2](ch04.html#demonstration_of_the_into_instruction
    "Example 4-2. Demonstration of the into instruction") demonstrates the use of
    the `into` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-2. Demonstration of the `into` instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[47](#CHP-4-FN-1)]) This form isn't a true 80x86 instruction. HLA converts
    this form of the bound instruction to the two-operand form by creating two `readonly`
    memory variables initialized with the specified constants.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 HLA Constant and Value Declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HLA's `const` and `val` sections let you declare symbolic constants. The `const`
    section lets you declare identifiers whose value is constant throughout compilation
    and runtime; the `val` section lets you declare symbolic constants whose values
    can change at compile time but whose values are constant at runtime (that is,
    the same name can have a different value at several points in the source code,
    but the value of a `val` symbol at a given point in the program cannot change
    while the program is running).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `const` section appears in the same area of your program as the `static`,
    `readonly`, `storage`, and `var` sections. It begins with the `const` reserved
    word and has a syntax that is nearly identical to the `readonly` section; that
    is, the `const` section contains a list of identifiers followed by a type and
    a constant expression. The following example will give you an idea of what the
    `const` section looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once you declare these constants in this manner, you may use the symbolic identifiers
    anywhere the corresponding literal constant is legal. These constants are known
    as manifest constants. A *manifest constant* is a symbolic representation of a
    constant that allows you to substitute the literal value for the symbol anywhere
    in the program. Contrast this with `readonly` variables; a `readonly` variable
    is certainly a constant value because you cannot change such values at runtime.
    However, there is a memory location associated with `readonly` variables, and
    the operating system, not the HLA compiler, enforces the read-only attribute.
    Although it will certainly crash your program when it runs, it is perfectly legal
    to write an instruction like `mov( eax, ReadOnlyVar );`. On the other hand, it
    is no more legal to write `mov( eax, MaxIndex );` (using the declaration above)
    than it is to write `mov( eax, 15 );`. In fact, both of these statements are equivalent
    because the compiler substitutes `15` for `MaxIndex` whenever it encounters this
    manifest constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is absolutely no ambiguity about a constant''s type, then you may
    declare a constant by specifying only the name and the constant''s value, omitting
    the type specification. In the example earlier, the `pi`, `Delimiter`, `MaxIndex`,
    and `DebugActive` constants could use the following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Symbol constants that have an integer literal constant are always given the
    smallest possible unsigned type if the constant is zero or positive, or the smallest
    possible integer type (`int8`, `int16`, and so on) if the value is negative.
  prefs: []
  type: TYPE_NORMAL
- en: Constant declarations are great for defining "magic" numbers that might possibly
    change during program modification. The program in [Example 4-3](ch04s02.html#data_alignment_program_rewritten_using_c
    "Example 4-3. Data alignment program rewritten using const definitions") provides
    an example of using constants to parameterize "magic" values in the program. In
    this particular case, the program defines manifest constants for the amount of
    memory to allocate for the test, the (mis)alignment, and the number of loop and
    data repetitions. This program demonstrates the performance reduction that occurs
    on misaligned data accesses. Adjust the `MainRepetitions` constant if the program
    is too fast or too slow.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-3. Data alignment program rewritten using `const` definitions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 4.2.1 Constant Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Manifest constants can be any of the HLA primitive types plus a few of the composite
    types this chapter discusses. [Chapter 1](ch01.html "Chapter 1. HELLO, WORLD OF
    ASSEMBLY LANGUAGE"), [Chapter 2](ch02.html "Chapter 2. DATA REPRESENTATION"),
    and [Chapter 3](ch03.html "Chapter 3. MEMORY ACCESS AND ORGANIZATION") discussed
    most of the primitive types; the primitive types include the following:^([[48](#ftn.CHP-4-FN-2)])
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean` constants (true or false)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uns8` constants (0..255)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uns16` constants (0..65,535)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uns32` constants (0..4,294,967,295)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int8` constants (−128..+127)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int16` constants (−32,768..+32,767)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int32` constants (−2,147,483,648..+2,147,483,647)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char` constants (any ASCII character with a character code in the range 0..255)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte` constants (any 8-bit value including integers, booleans, and characters)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`word` constants (any 16-bit value)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dword` constants (any 32-bit value)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`real32` constants (floating-point values)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`real64` constants (floating-point values)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`real80` constants (floating-point values)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to the constant types appearing above, the `const` section supports
    six additional constant types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`string` constants'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text` constants'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerated constant values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Record/Union constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character set constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These data types are the subject of this chapter, and the discussion of most
    of them appears a little later. However, the string and text constants are sufficiently
    important to warrant an early discussion of these constant types.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.2 String and Character Literal Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HLA, like most programming languages, draws a distinction between a sequence
    of characters, a *string*, and a single character. This distinction is present
    both in the type declarations and in the syntax for literal character and string
    constants. Until now, this text has not drawn a fine distinction between character
    and string literal constants; now is the time to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'String literal constants consist of a sequence of zero or more characters surrounded
    by ASCII quote characters. The following are examples of legal literal string
    constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A string of length 1 is not the same thing as a character constant. HLA uses
    two completely different internal representations for character and string values.
    Hence, `"a"` is not a character; it is a string that just happens to contain a
    single character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character literal constants take a couple forms, but the most common form consists
    of a single character surrounded by ASCII apostrophe characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As this section notes earlier, `"a"` and `'a'` are not equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Those who are familiar with C, C++, or Java probably recognize these literal
    constant forms, because they are similar to the character and string constants
    in C/C++/Java. In fact, this text has made a tacit assumption to this point that
    you are somewhat familiar with C/C++ insofar as examples appearing up to this
    point use character and string constants without an explicit definition of them.
  prefs: []
  type: TYPE_NORMAL
- en: Another similarity between C/C++ strings and HLA's is the automatic concatenation
    of adjacent literal string constants within your program. For example, HLA concatenates
    the two string constants
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: to form the single-string constant
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Beyond these few similarities, however, HLA strings and C/C++ strings differ.
    For example, C/C++ strings let you specify special character values using the
    escape character sequence consisting of a backslash character followed by one
    or more special characters; HLA does not use this escape character mechanism.
    HLA does provide, however, several other ways to insert special characters into
    a string or character constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because HLA does not allow escape character sequences in literal string and
    character constants, the first question you might ask is, "How does one embed
    quote characters in string constants and apostrophe characters in character constants?"
    To solve this problem, HLA uses the same technique as Pascal and many other languages:
    You insert two quotes in a string constant to represent a single quote, or you
    place two apostrophes in a character constant to represent a single apostrophe
    character. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The above is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As [Chapter 1](ch01.html "Chapter 1. HELLO, WORLD OF ASSEMBLY LANGUAGE") pointed
    out, to create a single apostrophe character constant, you place two adjacent
    apostrophes within a pair of apostrophes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'HLA provides a couple of other features that eliminate the need for escape
    characters. In addition to concatenating two adjacent string constants to form
    a longer string constant, HLA will also concatenate any combination of adjacent
    character and string constants to form a single string constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that the two *He wrote* strings in the previous examples are identical
    in HLA.
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA provides a second way to specify character constants that handles all the
    other C/C++ escape character sequences: the ASCII code literal character constant.
    This literal character constant form uses the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This form creates a character constant whose value is the ASCII code specified
    by `integer_constant`. The numeric constant can be a decimal, hexadecimal, or
    binary value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Because you may concatenate character literals with strings, and the `#constant`
    form is a character literal, the following are all legal strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Because $22 is the ASCII code for the quote character, this last example is
    yet a third form of the *He wrote* string literal.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.3 String and Text Constants in the const Section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'String and text constants in the `const` section use the following declaration
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Other than the data type of these two constants, their declarations are identical.
    However, their behavior in an HLA program is quite different.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever HLA encounters a symbolic string constant within your program, it substitutes
    the string literal constant in place of the string name. So a statement like `stdout.put(
    AStringConst );` prints the string `123` to the display. No real surprise here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever HLA encounters a symbolic text constant within your program, it substitutes
    the text of that string (rather than the string literal constant) for the identifier.
    That is, HLA substitutes the characters between the delimiting quotes in place
    of the symbolic text constant. Therefore, the following statement is perfectly
    legal given the declarations above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that substituting `AStringConst` for `ATextConst` in this example is illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This latter example is illegal because you cannot move a string literal constant
    into the AL register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever HLA encounters a symbolic text constant in your program, it immediately
    substitutes the value of the text constant''s string for that text constant and
    continues the compilation as though you had written the text constant''s value
    rather than the symbolic identifier in your program. This can save some typing
    and help make your programs a little more readable if you often enter some sequence
    of text in your program. For example, consider the `nl` (newline) text constant
    declaration found in the HLA *stdio.hhf* library header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever HLA encounters the symbol `nl`, it immediately substitutes the value
    of the string "`#$d #$a`" for the `nl` identifier. When HLA sees the `#$d` (carriage
    return) character constant followed by the `#$a` (line feed) character constants,
    it concatenates the two to form the string containing the Windows newline sequence
    (a carriage return followed by a line feed). Consider the following two statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '(Notice that the second statement above does not separate the string literal
    and the `nl` symbol with a comma.) In the first example, HLA emits code that prints
    the string `Hello World` and then emits some additional code that prints a newline
    sequence. In the second example, HLA expands the `nl` symbol as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now HLA sees a string literal constant (`Hello World`) followed by two character
    constants. It concatenates the three of them together to form a single string
    and then prints this string with a single call. Therefore, leaving off the comma
    between the string literal and the `nl` symbol produces slightly more efficient
    code. Keep in mind that this works only with string literal constants. You cannot
    concatenate string variables, or a string variable with a string literal, by using
    this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Linux, FreeBSD, and Mac OS X users should note that the Unix end-of-line sequence
    is just a single line-feed character. Therefore, the declaration for `nl` is slightly
    different in those operating systems (to always guarantee that `nl` expands to
    a string constant rather than a character constant).
  prefs: []
  type: TYPE_NORMAL
- en: In the constant section, if you specify only a constant identifier and a string
    constant (that is, you do not supply a type), HLA defaults to type `string`. If
    you want to declare a `text` constant, you must explicitly supply the type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 4.2.4 Constant Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thus far, this chapter has given the impression that a symbolic constant definition
    consists of an identifier, an optional type, and a literal constant. Actually,
    HLA constant declarations can be a lot more sophisticated than this because HLA
    allows the assignment of a constant expression, not just a literal constant, to
    a symbolic constant. The generic constant declaration takes one of the following
    two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Constant expressions take the familiar form you're used to in high-level languages
    like C/C++ and Pascal. They may contain literal constant values, previously declared
    symbolic constants, and various arithmetic operators. [Table 4-1](ch04s02.html#operations_allowed_in_constant_expressio
    "Table 4-1. Operations Allowed in Constant Expressions") lists some of the operations
    possible in a constant expression.
  prefs: []
  type: TYPE_NORMAL
- en: The constant expression operators follow standard precedence rules; you may
    use the parentheses to override the precedence if necessary. See the HLA reference
    at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) or [http://artofasm.com/](http://artofasm.com/)
    for the exact precedence relationships. In general, if the precedence isn't obvious,
    use parentheses to exactly state the order of evaluation. HLA actually provides
    a few more operators than these, though the ones above are the ones you will most
    commonly use; the HLA documentation provides a complete list of constant expression
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1. Operations Allowed in Constant Expressions
  prefs: []
  type: TYPE_NORMAL
- en: '| Arithmetic Operators |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| `−` (unary negation) | Negates the expression immediately following `"-"`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Multiplies the integer or real values around the asterisk. |'
  prefs: []
  type: TYPE_TB
- en: '| `div` | Divides the left integer operand by the right integer operand, producing
    an integer (truncated) result. |'
  prefs: []
  type: TYPE_TB
- en: '| `mod` | Divides the left integer operand by the right integer operand, producing
    an integer remainder. |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | Divides the left numeric operand by the second numeric operand, producing
    a floating point result. |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Adds the left and right numeric operands. |'
  prefs: []
  type: TYPE_TB
- en: '| `−` | Subtracts the right numeric operand from the left numeric operand.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Comparison Operators |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| `=`, `==` | Compares left operand with right operand. Returns true if equal.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<>`, `!=` | Compares left operand with right operand. Returns true if not
    equal. |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | Returns true if left operand is less than right operand. |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | Returns true if left operand is <= right operand. |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | Returns true if left operand is greater than right operand. |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | Returns true if left operand is >= right operand. |'
  prefs: []
  type: TYPE_TB
- en: '| Logical Operators^([[a](#ftn.CHP-4-TFN-1)]) |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | For boolean operands, returns the logical `and` of the two operands.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | For boolean operands, returns the logical `or` of the two operands.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | For boolean operands, returns the logical exclusive-or. |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | Returns the logical not of the single operand following `"!"`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[a](#CHP-4-TFN-1)]) Note to C/C++ and Java users: HLA''s constant expressions
    use complete boolean evaluation rather than short-circuit boolean evaluation.
    Hence, HLA constant expressions do not behave identically to C/C++/Java expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Bitwise Logical Operators |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | For integer numeric operands, returns bitwise `and` of the operands.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | For integer numeric operands, returns bitwise `or` of the operands.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | For integer numeric operands, returns bitwise `xor` of the operands.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | For an integer numeric operand, returns bitwise `not` of the operand.
    |'
  prefs: []
  type: TYPE_TB
- en: '| String Operators |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| `''+''` | Returns the concatenation of the left and right string operands.
    |'
  prefs: []
  type: TYPE_TB
- en: 'If an identifier appears in a constant expression, that identifier must be
    a constant identifier that you have previously defined in your program in a const
    or `val` section. You may not use variable identifiers in a constant expression;
    their values are not defined at compile time when HLA evaluates the constant expression.
    Also, don''t confuse compile-time and runtime operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: HLA directly interprets the value of a constant expression during compilation.
    It does not emit any machine instructions to compute `x + y` in the constant expression
    above. Instead, it directly computes the sum of these two constant values. From
    that point forward in the program, HLA associates the value 11 with the constant
    `Sum` just as if the program had contained the statement `Sum := 11;` rather than
    `Sum := x + y;`. On the other hand, HLA does not precompute the value 11 in AL
    for the `mov` and `add` instructions above; it faithfully emits the object code
    for these two instructions and the 80x86 computes their sum when the program is
    run (sometime after the compilation is complete).
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, constant expressions don''t get very sophisticated in assembly
    language programs. Usually, you''re adding, subtracting, or multiplying two integer
    values. For example, the following `const` section defines a set of constants
    that have consecutive values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The constants above have the following values: `TapeDAT=0`, `Tape8mm=1`, `TapeQIC80=2`,
    `TapeTravan=3`, and `TapeDLT=4`.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.5 Multiple const Sections and Their Order in an HLA Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although `const` sections must appear in the declaration section of an HLA program
    (for example, between the program *`pgmname`*`;` header and the corresponding
    `begin` *`pgmname`*`;` statement), they do not have to appear before or after
    any other items in the declaration section. In fact, like the variable declaration
    sections, you can place multiple `const` sections in a declaration section. The
    only restriction on HLA constant declarations is that you must declare any constant
    symbol before you use it in your program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some C/C++ programmers, for example, are more comfortable writing their constant
    declarations as follows (because this is closer to C/C++''s syntax for declaring
    constants):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The placement of the `const` section in a program seems to be a personal issue
    among programmers. Other than the requirement of defining all constants before
    you use them, you may feel free to insert the `const` declaration section anywhere
    in the declaration section.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.6 The HLA val Section
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You cannot change the value of a constant you define in the `const` section.
    While this seems perfectly reasonable (constants after all, are supposed to be,
    well, constant), there are different ways we can define the term *constant*, and
    `const` objects follow the rules of only one specific definition. HLA's `val`
    section lets you define constant objects that follow slightly different rules.
    This section discusses the `val` section and the difference between `val` constants
    and `const` constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of "`const`-ness" can exist at two different times: while HLA is
    compiling your program and later when your program executes (and HLA is no longer
    running). All reasonable definitions of a constant require that a value not change
    while the program is running. Whether or not the value of a "constant" can change
    during compilation is a separate issue. The difference between HLA `const` objects
    and HLA `val` objects is whether the value can change during compilation.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you define a constant in the `const` section, the value of that constant
    is immutable from that point forward *both at runtime and while HLA is compiling
    your program*. Therefore, an instruction like `mov( SymbolicCONST, eax );` always
    moves the same value into EAX, regardless of where this instruction appears in
    the HLA main program. Once you define the symbol `SymbolicCONST` in the `const`
    section, this symbol has the same value from that point forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HLA `val` section lets you declare symbolic constants, just like the `const`
    section. However, HLA `val` constants can change their value throughout the source
    code in your program. The following HLA declarations are perfectly legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: All of the symbols appearing in the `const` sections use the symbolic value
    `InitialValue` as part of the definition. Note, however, that `InitialValue` has
    different values at various points in this code sequence; at the beginning of
    the code sequence `InitialValue` has the value 0, while later it has the value
    100.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, at runtime a `val` object is not a variable; it is still a manifest
    constant and HLA will substitute the current value of a `val` identifier for that
    identifier.^([[49](#ftn.CHP-4-FN-3)]) Statements like `mov( 25, InitialValue );`
    are no more legal than `mov( 25, 0 );` or `mov( 25, 100 );`.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.7 Modifying val Objects at Arbitrary Points in Your Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you declare all your `val` objects in the declaration section, it would seem
    that you would not be able to change the value of a `val` object between the `begin`
    and `end` statements of your program. After all, the `val` section must appear
    in the declaration section of the program, and the declaration section ends before
    the `begin` statement. In [Chapter 9](ch09.html "Chapter 9. MACROS AND THE HLA
    COMPILE-TIME LANGUAGE"), you will learn that most `val` object modifications occur
    between the `begin` and `end` statements; hence, HLA must provide some way to
    change the value of a `val` object outside the declaration section. The mechanism
    to do this is the `?` operator. Not only does HLA allow you to change the value
    of a `val` object outside the declaration section, but it also allows you to change
    the value of a `val` object almost *anywhere* in the program. Anywhere a space
    is allowed inside an HLA program, you can insert a statement of the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This means that you could write a short program like the one appearing in [Example 4-4](ch04s02.html#demonstration_of_val_redefinition_using
    "Example 4-4. Demonstration of val redefinition using the ? operator").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-4. Demonstration of `val` redefinition using the `?` operator
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[48](#CHP-4-FN-2)]) This is not a complete list. HLA also supports 64-bit
    and 128-bit data types. We'll discuss those in [Chapter 8](ch08.html "Chapter 8. ADVANCED
    ARITHMETIC").
  prefs: []
  type: TYPE_NORMAL
- en: ^([[49](#CHP-4-FN-3)]) In this context, *current* means the value last assigned
    to a `val` object looking backward in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 The HLA Type Section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you simply do not like the names that HLA uses for declaring
    `byte`, `word`, `dword`, `real`, and other variables. Let''s say that you prefer
    Pascal''s naming convention or perhaps C''s naming convention. You want to use
    terms like `integer`, `float`, `double`, or whatever. If HLA were Pascal, you
    could redefine the names in the `type` section of the program. With C you could
    use a `#define` or a `typedef` statement to accomplish the task. Well, HLA, like
    Pascal, has its own `type` statement that also lets you create aliases of these
    names. The following example demonstrates how to set up some C/C++/Pascal-compatible
    names in your HLA programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can declare your variables with more meaningful statements like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you program in Ada, C/C++, or FORTRAN (or any other language, for that matter),
    you can pick type names you''re more comfortable with. Of course, this doesn''t
    change how the 80x86 or HLA reacts to these variables one iota, but it does let
    you create programs that are easier to read and understand because the type names
    are more indicative of the actual underlying types. One warning for C/C++ programmers:
    don''t get too excited and go off and define an `int` data type. Unfortunately,
    `int` is an 80x86 machine instruction (interrupt), and therefore this is a reserved
    word in HLA.'
  prefs: []
  type: TYPE_NORMAL
- en: The `type` section is useful for much more than creating type isomorphism (that
    is, giving a new name to an existing type). The following sections demonstrate
    many of the possible things you can do in the `type` section.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 enum and HLA Enumerated Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a previous section discussing constants and constant expressions, you saw
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates how to use constant expressions to develop a set of
    constants that contain unique, consecutive values. There are, however, a couple
    of problems with this approach. First, it involves a lot of typing (and extra
    reading when reviewing this program). Second, it's very easy to make a mistake
    when creating long lists of unique constants and reuse or skip some values. The
    HLA `enum` type provides a better way to create a list of constants with unique
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '`enum` is an HLA type declaration that lets you associate a list of names with
    a new type. HLA associates a unique value with each name (that is, it *enumerates*
    the list). The `enum` keyword typically appears in the `type` section, and you
    use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The symbol *`enumTypeID`* becomes a new type whose values are specified by
    a list of names. As a concrete example, consider the data type `TapeDrives` and
    a corresponding variable declaration of type `TapeDrives`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: By default, HLA reserves 1 byte of storage for enumerated data types. So the
    `BackupUnit` variable will consume 1 byte of memory, and you would typically use
    an 8-bit register to access it.^([[50](#ftn.CHP-4-FN-4)]) As for the constants,
    HLA associates consecutive `uns8` constant values starting at 0 with each of the
    enumerated identifiers. In the `TapeDrives` example, the tape drive identifiers
    would have the values `TapeDAT=0`, `Tape8mm=1`, `TapeQIC80=2`, `TapeTravan=3`,
    and `TapeDLT=4`. You may use these constants exactly as though you had defined
    them with these values in a `const` section.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[50](#CHP-4-FN-4)]) HLA provides a mechanism by which you can specify that
    enumerated data types consume 2 or 4 bytes of memory. See the HLA documentation
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 Pointer Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've probably experienced pointers firsthand in the Pascal, C, or Ada programming
    languages, and you're probably getting worried right now. Almost everyone has
    a bad experience when they first encounter pointers in a high-level language.
    Well, fear not! Pointers are actually *easier* to deal with in assembly language
    than in high-level languages. Besides, most of the problems you had with pointers
    probably had nothing to do with pointers but rather with the linked list and tree
    data structures you were trying to implement with them. Pointers, on the other
    hand, have many uses in assembly language that have nothing to do with linked
    lists, trees, and other scary data structures. Indeed, simple data structures
    like arrays and records often involve the use of pointers. So if you have some
    deep-rooted fear about pointers, forget everything you know about them. You're
    going to learn how *great* pointers really are.
  prefs: []
  type: TYPE_NORMAL
- en: Probably the best place to start is with the definition of a pointer. Just exactly
    what is a pointer, anyway? Unfortunately, high-level languages like Pascal tend
    to hide the simplicity of pointers behind a wall of abstraction. This added complexity
    (which exists for good reason, by the way) tends to frighten programmers because
    *they don't understand what's going on*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re afraid of pointers, let''s just ignore them for the time being and
    work with an array. Consider the following array declaration in Pascal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Even if you don't know Pascal, the concept here is pretty easy to understand.
    `M` is an array with 1,024 integers in it, indexed from `M[0]` to `M[1023]`. Each
    one of these array elements can hold an integer value that is independent of all
    the others. In other words, this array gives you 1,024 different integer variables,
    each of which you refer to by number (the array index) rather than by name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you encounter a program that has the statement `M[0]:=100;`, you probably
    won''t have to think at all about what is happening with this statement. It is
    storing the value 100 into the first element of the array `M`. Now consider the
    following two statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You should agree, without too much hesitation, that these two statements perform
    the same operation as `M[0]:=100`;. Indeed, you''re probably willing to agree
    that you can use any integer expression in the range 0..1,023 as an index into
    this array. The following statements still perform the same operation as our single
    assignment to index 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '"Okay, so what''s the point?" you''re probably thinking. "Anything that produces
    an integer in the range 0..1,023 is legal. So what?" Okay, how about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Whoa! Now that takes a few moments to digest. However, if you take it slowly,
    it makes sense and you'll discover that these two instructions perform the exact
    same operation you've been doing all along. The first statement stores 0 into
    array element `M[1]`. The second statement fetches the value of `M[1]`, which
    is an integer so you can use it as an array index into `M`, and uses that value
    (0) to control where it stores the value 100.
  prefs: []
  type: TYPE_NORMAL
- en: If you're willing to accept the above as reasonable, perhaps bizarre, but usable
    nonetheless, then you'll have no problems with pointers. *Because* *`M[1]`* *is
    a pointer!* Well, not really, but if you were to change `M` to "memory" and treat
    this array as all of memory, this is the exact definition of a pointer. A pointer
    is simply a memory location whose value is the address (or index, if you prefer)
    of some other memory location. Pointers are very easy to declare and use in an
    assembly language program. You don't even have to worry about array indices or
    anything like that.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.1 Using Pointers in Assembly Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An HLA pointer is a 32-bit value that may contain the address of some other
    variable. If you have a `dword` variable `p` that contains $1000_0000, then `p`
    "points" at memory location $1000_0000\. To access the `dword` that `p` points
    at, you could use code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: By loading the value of `p` into EBX, this code loads the value $1000_0000 into
    EBX (assuming `p` contains $1000_0000 and, therefore, points at memory location
    $1000_0000). The second instruction above loads the EAX register with the `dword`
    starting at the location whose offset appears in EBX. Because EBX now contains
    $1000_0000, this will load EAX from locations $1000_0000 through $1000_0003.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why not just load EAX directly from location $1000_0000 using an instruction
    like `mov( mem, eax )`; (assuming `mem` is at address $1000_0000)? Well, there
    are a lot of reasons. But the primary reason is that this `mov` instruction always
    loads EAX from location `mem`. You cannot change the address from where it loads
    EAX. The former instructions, however, always load EAX from the location where
    `p` is pointing. This is very easy to change under program control. In fact, the
    simple instruction `mov( &mem2, p );` will cause those same two instructions above
    to load EAX from `mem2` the next time they execute. Consider the following instruction
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This short example demonstrates two execution paths through the program. The
    first path loads the variable `p` with the address of the variable `i`. The second
    path through the code loads `p` with the address of the variable `j`. Both execution
    paths converge on the last two `mov` instructions that load EAX with `i` or `j`
    depending upon which execution path was taken. In many respects, this is like
    a *parameter* to a procedure in a high-level language like Pascal. Executing the
    same instructions accesses different variables depending on whose address (`i`
    or `j`) winds up in `p`.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.2 Declaring Pointers in HLA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because pointers are 32-bits long, you could simply use the `dword` type to
    allocate storage for your pointers. However, there is a much better way to do
    this: HLA provides the `pointer to` phrase specifically for declaring pointer
    variables. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates that it is possible to initialize as well as declare
    pointer variables in HLA. Note that you may only take addresses of static variables
    (`static`, `readonly`, and `storage` objects) with the address-of operator, so
    you can only initialize pointer variables with the addresses of static objects.
  prefs: []
  type: TYPE_NORMAL
- en: You can also define your own pointer types in the `type` section of an HLA program.
    For example, if you often use pointers to characters, you'll probably want to
    use a `type` declaration like the one in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 4.5.3 Pointer Constants and Pointer Constant Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HLA allows two literal pointer constant forms: the address-of operator followed
    by the name of a static variable or the constant `NULL`. In addition to these
    two literal pointer constants, HLA also supports simple pointer constant expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: The `NULL` pointer is the constant 0\. Zero is an illegal address that will
    raise an exception if you try to access it under modern operating systems. Programs
    typically initialize pointers with `NULL` to indicate that a pointer has explicitly
    *not* been initialized with a valid address.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to simple address literals and the value 0, HLA allows very simple
    constant expressions wherever a pointer constant is legal. Pointer constant expressions
    take one of the three following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The *`PureConstantExpression`* term is a numeric constant expression that does
    not involve any pointer constants. This type of expression produces a memory address
    that is the specified number of bytes before or after (`−` or `+`, respectively)
    the *`StaticVarName`* variable in memory. Note that the first two forms above
    are semantically equivalent; they both return a pointer constant whose address
    is the sum of the static variable and the constant expression.
  prefs: []
  type: TYPE_NORMAL
- en: Because you can create pointer constant expressions, it should come as no surprise
    to discover that HLA lets you define manifest pointer constants in the `const`
    section. The program in [Example 4-5](ch04s05.html#pointer_constant_expressions_in_an_hla_p
    "Example 4-5. Pointer constant expressions in an HLA program") demonstrates how
    you can do this.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-5. Pointer constant expressions in an HLA program
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Upon execution, this program prints the value of the byte just beyond `b` in
    memory (which contains the value $01).
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.4 Pointer Variables and Dynamic Memory Allocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pointer variables are the perfect place to store the return result from the
    HLA Standard Library `mem.alloc` function. The `mem.alloc` function returns the
    address of the storage it allocates in the EAX register; therefore, you can store
    the address directly into a pointer variable with a single `mov` instruction immediately
    after a call to `mem.alloc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 4.5.5 Common Pointer Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Programmers encounter five common problems when using pointers. Some of these
    errors will cause your programs to immediately stop with a diagnostic message;
    other problems are more subtle, yielding incorrect results without otherwise reporting
    an error or simply affecting the performance of your program without displaying
    an error. These five problems are:'
  prefs: []
  type: TYPE_NORMAL
- en: Using an uninitialized pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a pointer that contains an illegal value (e.g., `NULL`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuing to use `mem.alloc`'d storage after that storage has been freed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failing to `mem.free` storage once the program is finished using it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing indirect data using the wrong data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first problem above is using a pointer variable before you have assigned
    a valid memory address to the pointer. Beginning programmers often don't realize
    that declaring a pointer variable reserves storage only for the pointer itself;
    it does not reserve storage for the data that the pointer references. The short
    program in [Example 4-6](ch04s05.html#uninitialized_pointer_demonstration "Example 4-6. Uninitialized
    pointer demonstration") demonstrates this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-6. Uninitialized pointer demonstration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Although variables you declare in the `static` section are, technically, initialized,
    static initialization still doesn't initialize the pointer in this program with
    a valid address (it initializes them with `0`, which is `NULL`).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there is no such thing as a truly uninitialized variable on the 80x86\.
    What you really have are variables that you've explicitly given an initial value
    and variables that just happen to inherit whatever bit pattern was in memory when
    storage for the variable was allocated. Much of the time, these garbage bit patterns
    lying around in memory don't correspond to a valid memory address. Attempting
    to *dereference* such a pointer (that is, access the data in memory at which it
    points) typically raises a *Memory Access Violation* exception.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, however, those random bits in memory just happen to correspond to
    a valid memory location you can access. In this situation, the CPU will access
    the specified memory location without aborting the program. Although to a naive
    programmer this situation may seem preferable to stopping the program, in reality
    this is far worse because your defective program continues to run without alerting
    you to the problem. If you store data through an uninitialized pointer, you may
    very well overwrite the values of other important variables in memory. This defect
    can produce some very difficult-to-locate problems in your program.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem programmers have with pointers is storing invalid address
    values into a pointer. The first problem above is actually a special case of this
    second problem (with garbage bits in memory supplying the invalid address rather
    than you producing it via a miscalculation). The effects are the same; if you
    attempt to dereference a pointer containing an invalid address, either you will
    get a Memory Access Violation exception or you will access an unexpected memory
    location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third problem listed above is also known as the dangling pointer problem.
    To understand this problem, consider the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this example you will note that the program allocates 256 bytes of storage
    and saves the address of that storage in the `ptr` variable. Then the code uses
    this block of 256 bytes for a while and frees the storage, returning it to the
    system for other uses. Note that calling `mem.free` does not change the value
    of `ptr` in any way; `ptr` still points at the block of memory allocated by `mem.alloc`
    earlier. Indeed, `mem.free` does not change any data in this block, so upon return
    from `mem.free`, `ptr` still points at the data stored into the block by this
    code. However, note that the call to `mem.free` tells the system that the program
    no longer needs this 256-byte block of memory and the system can use this region
    of memory for other purposes. The `mem.free` function cannot enforce the fact
    that you will never access this data again; you are simply promising that you
    won't. Of course, the code fragment above breaks this promise; as you can see
    in the last two instructions above, the program fetches the value in `ptr` and
    accesses the data it points at in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The biggest problem with dangling pointers is that you can get away with using
    them a good part of the time. As long as the system doesn''t reuse the storage
    you''ve freed, using a dangling pointer produces no ill effects in your program.
    However, with each new call to `mem.alloc`, the system may decide to reuse the
    memory released by that previous call to `mem.free`. When this happens, any attempt
    to dereference the dangling pointer may produce some unintended consequences.
    The problems range from reading data that has been overwritten (by the new, legal
    use of the data storage), to overwriting the new data, to (the worst case) overwriting
    system heap management pointers (doing so will probably cause your program to
    crash). The solution is clear: *Never use a pointer value once you free the storage
    associated with that pointer*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of all the problems, the fourth (failing to free allocated storage) will probably
    have the least impact on the proper operation of your program. The following code
    fragment demonstrates this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this example the program allocates 256 bytes of storage and references this
    storage using the `ptr` variable. At some later time the program allocates another
    block of bytes and overwrites the value in `ptr` with the address of this new
    block. Note that the former value in `ptr` is lost. Because the program no longer
    has this address value, there is no way to call `mem.free` to return the storage
    for later use. As a result, this memory is no longer available to your program.
    While making 256 bytes of memory inaccessible to your program may not seem like
    a big deal, imagine that this code is in a loop that repeats over and over again.
    With each execution of the loop the program loses another 256 bytes of memory.
    After a sufficient number of loop iterations, the program will exhaust the memory
    available on the heap. This problem is often called a *memory leak* because the
    effect is the same as though the memory bits were leaking out of your computer
    (yielding less and less available storage) during program execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory leaks are far less damaging than dangling pointers. Indeed, there are
    only two problems with memory leaks: the danger of running out of heap space (which,
    ultimately, may cause the program to abort, though this is rare) and performance
    problems due to virtual memory page swapping. Nevertheless, you should get in
    the habit of always freeing all storage once you have finished using it. When
    your program quits, the operating system reclaims all storage, including the data
    lost via memory leaks. Therefore, memory lost via a leak is lost only to your
    program, not the whole system.'
  prefs: []
  type: TYPE_NORMAL
- en: The last problem with pointers is the lack of type-safe access. This can occur
    because HLA cannot and does not enforce pointer type checking. For example, consider
    the program in [Example 4-7](ch04s05.html#type-unsafe_pointer_access_example "Example 4-7. Type-unsafe
    pointer access example").
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-7. Type-unsafe pointer access example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This program reads in data from the user as character values and then displays
    the data as double-word hexadecimal values. While a powerful feature of assembly
    language is that it lets you ignore data types at will and automatically coerce
    the data without any effort, this power is a two-edged sword. If you make a mistake
    and access indirect data using the wrong data type, HLA and the 80x86 may not
    catch the mistake and your program may produce inaccurate results. Therefore,
    you need to take care when using pointers and indirection in your programs that
    you use the data consistently with respect to data type.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 Composite Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composite data types, also known as *aggregate* data types, are those that are
    built up from other (generally scalar) data types. This chapter covers several
    of the more important composite data types—character strings, character sets,
    arrays, records, and unions. A string is a good example of a composite data type;
    it is a data structure built up from a sequence of individual characters and some
    other data.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7 Character Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After integer values, character strings are probably the most common data type
    that modern programs use. The 80x86 does support a handful of string instructions,
    but these instructions are really intended for block memory operations, not a
    specific implementation of a character string. Therefore, this section will concentrate
    mainly on the HLA definition of character strings and will also discuss the string-handling
    routines available in the HLA Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, a character string is a sequence of ASCII characters that possesses
    two main attributes: a *length* and some *character data*. Different languages
    use different data structures to represent strings. To better understand the reasoning
    behind the design of HLA strings, it is probably instructive to look at two different
    string representations popularized by various high-level languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without question, *zero-terminated strings* are probably the most common string
    representation in use today because this is the native string format for C, C++,
    C#, Java, and other languages. A zero-terminated string consists of a sequence
    of zero or more ASCII characters ending with a 0 byte. For example, in C/C++,
    the string `"abc"` requires 4 bytes: the three characters `''a''`, `''b''`, and
    `''c''` followed by a 0\. As you''ll soon see, HLA character strings are upward
    compatible with zero-terminated strings, but in the meantime you should note that
    it is very easy to create zero-terminated strings in HLA. The easiest place to
    do this is in the `static` section using code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Remember, when using the `@nostorage` option, HLA doesn't reserve any space
    for the variable, so the `zeroTerminatedString` variable's address in memory corresponds
    to the first character in the following `byte` directive. Whenever a character
    string appears in the `byte` directive as it does here, HLA emits each character
    in the string to successive memory locations. The 0 value at the end of the string
    terminates this string.
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA supports a `zstring` data type. However, those objects are double word
    pointers that contain the address of a `zstring`, not the zero-terminated string
    itself. Here is an example of a `zstring` declaration (and static initialization):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Zero-terminated strings have two principal attributes: They are very simple
    to implement, and the strings can be any length. On the other hand, zero-terminated
    strings have a few drawbacks. First, though not usually important, zero-terminated
    strings cannot contain the NUL character (whose ASCII code is 0). Generally, this
    isn''t a problem, but it does create havoc once in a while. The second problem
    with zero-terminated strings is that many operations on them are somewhat inefficient.
    For example, to compute the length of a zero-terminated string, you must scan
    the entire string looking for that 0 byte (counting characters up to the 0). The
    following program fragment demonstrates how to compute the length of the string
    above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this code, the time it takes to compute the length of the
    string is proportional to the length of the string; as the string gets longer,
    it takes longer to compute its length.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second string format, *length-prefixed strings*, overcomes some of the problems
    with zero-terminated strings. Length-prefixed strings are common in languages
    like Pascal; they generally consist of a length byte followed by zero or more
    character values. The first byte specifies the string length, and the following
    bytes (up to the specified length) are the character data. In a length-prefixed
    scheme, the string `abc` would consist of the 4 bytes `$03` (the string length)
    followed by `a`, `b`, and `c`. You can create length-prefixed strings in HLA using
    code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Counting the characters ahead of time and inserting them into the byte statement,
    as was done here, may seem like a major pain. Fortunately, there are ways to have
    HLA automatically compute the string length for you.
  prefs: []
  type: TYPE_NORMAL
- en: Length-prefixed strings solve the two major problems associated with zero-terminated
    strings. It is possible to include the NUL character in length-prefixed strings,
    and those operations on zero-terminated strings that are relatively inefficient
    (e.g., string length) are more efficient when using length-prefixed strings. However,
    length-prefixed strings have their own drawbacks. The principal drawback is that
    they are limited to a maximum of 255 characters in length (assuming a 1-byte length
    prefix).
  prefs: []
  type: TYPE_NORMAL
- en: HLA uses an expanded scheme for strings that is upward compatible with both
    zero-terminated and length-prefixed strings. HLA strings enjoy the advantages
    of both zero-terminated and length-prefixed strings without the disadvantages.
    In fact, the only drawback to HLA strings over these other formats is that HLA
    strings consume a few additional bytes (the overhead for an HLA string is 9 to
    12 bytes compared to 1 byte for zero-terminated or length-prefixed strings, the
    overhead being the number of bytes needed above and beyond the actual characters
    in the string).
  prefs: []
  type: TYPE_NORMAL
- en: An HLA string value consists of four components. The first element is a double-word
    value that specifies the maximum number of characters that the string can hold.
    The second element is a double-word value specifying the current length of the
    string. The third component is the sequence of characters in the string. The final
    component is a zero-terminating byte. You could create an HLA-compatible string
    in the `static` section using code like the following:^([[51](#ftn.CHP-4-FN-5)])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that the address associated with the HLA string is the address of the first
    character, not the maximum or current length values.
  prefs: []
  type: TYPE_NORMAL
- en: '"So what is the difference between the current and maximum string lengths?"
    you''re probably wondering. In a literal string they are usually the same. However,
    when you allocate storage for a string variable at runtime, you will normally
    specify the maximum number of characters that can go into the string. When you
    store actual string data into the string, the number of characters you store must
    be less than or equal to this maximum value. The HLA Standard Library string routines
    will raise an exception if you attempt to exceed this maximum length (something
    the C/C++ and Pascal formats can''t do).'
  prefs: []
  type: TYPE_NORMAL
- en: The terminating 0 byte at the end of the HLA string lets you treat an HLA string
    as a zero-terminated string if it is more efficient or more convenient to do so.
    For example, most calls to Windows, Mac OS X, FreeBSD, and Linux require zero-terminated
    strings for their string parameters. Placing a 0 at the end of an HLA string ensures
    compatibility with the operating system and other library modules that use zero-terminated
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[51](#CHP-4-FN-5)]) Actually, there are some restrictions on the placement
    of HLA strings in memory. This text will not cover those issues. See the HLA documentation
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8 HLA Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the previous section notes, HLA strings consist of four components: a maximum
    length, a current string length, character data, and a zero-terminating byte.
    However, HLA never requires you to create string data by manually emitting these
    components yourself. HLA is smart enough to automatically construct this data
    for you whenever it sees a string literal constant. So if you use a string constant
    like the following, understand that somewhere HLA is creating the four-component
    string in memory for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'HLA doesn''t actually work directly with the string data described in the previous
    section. Instead, when HLA sees a string object, it always works with a *pointer*
    to that object rather than working directly with the object. Without question,
    this is the most important fact to know about HLA strings and is the biggest source
    of problems beginning HLA programmers have with strings in HLA: *Strings are pointers!*
    A string variable consumes exactly 4 bytes, the same as a pointer (because it
    is a pointer!). Having said all that, let''s look at a simple string variable
    declaration in HLA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Because a string variable is a pointer, you must initialize it before you can
    use it. There are three general ways you may initialize a string variable with
    a legal string address: using static initializers, using the `str.alloc` routine,
    or calling some other HLA Standard Library function that initializes a string
    or returns a pointer to a string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In one of the static declaration sections that allow initialized variables
    (`static` and `readonly`) you can initialize a string variable using the standard
    initialization syntax. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Note that this does not initialize the string variable with the string data.
    Instead, HLA creates the string data structure (see [4.7 Character Strings](ch04s07.html
    "4.7 Character Strings")) in a special, hidden, memory segment and initializes
    the `InitializedString` variable with the address of the first character in this
    string (the `T` in `This`). *Remember, strings are pointers!* The HLA compiler
    places the actual string data in a read-only memory segment. Therefore, you cannot
    modify the characters of this string literal at runtime. However, because the
    string variable (a pointer, remember) is in the `static` section, you can change
    the string variable so that it points at different string data.
  prefs: []
  type: TYPE_NORMAL
- en: Because string variables are pointers, you can load the value of a string variable
    into a 32-bit register. The pointer itself points at the first character position
    of the string. You can find the current string length in the double-word 4 bytes
    prior to this address, and you can find the maximum string length in the double-word
    8 bytes prior to this address. The program in [Example 4-8](ch04s08.html#accessing_the_length_and_maximum_length
    "Example 4-8. Accessing the length and maximum length fields of a string") demonstrates
    one way to access this data.^([[52](#ftn.CHP-4-FN-6)])
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-8. Accessing the length and maximum length fields of a string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: When accessing the various fields of a string variable, it is not wise to access
    them using fixed numeric offsets as done in [Example 4-8](ch04s08.html#accessing_the_length_and_maximum_length
    "Example 4-8. Accessing the length and maximum length fields of a string"). In
    the future, the definition of an HLA string may change slightly. In particular,
    the offsets to the maximum length and length fields are subject to change. A safer
    way to access string data is to coerce your string pointer using the `str.strRec`
    data type. The `str.strRec` data type is a `record` data type (see [4.25 Records](ch04s25.html
    "4.25 Records")) that defines symbolic names for the offsets of the length and
    maximum length fields in the `string` data type. If the offsets to the length
    and maximum length fields were to change in a future version of HLA, then the
    definitions in `str.strRec` would also change. So if you use `str.strRec`, then
    recompiling your program would automatically make any necessary changes to your
    program.
  prefs: []
  type: TYPE_NORMAL
- en: To use the `str.strRec` data type properly, you must first load the string pointer
    into a 32-bit register; for example, `mov( SomeString, ebx );`. Once the pointer
    to the string data is in a register, you can coerce that register to the `str.strRec`
    data type using the HLA construct `(type str.strRec [ebx])`. Finally, to access
    the length or maximum length fields, you would use either `(type str.strRec [ebx]).length`
    or `(type str.strRec [ebx]).maxlen` (respectively). Although there is a little
    more typing involved (versus using simple offsets like −4 or −8), these forms
    are far more descriptive and much safer than straight numeric offsets. The program
    in [Example 4-9](ch04s08.html#correct_way_to_access_the_length_and_max "Example 4-9. Correct
    way to access the length and maxlen fields of a string") corrects the example
    in [Example 4-8](ch04s08.html#accessing_the_length_and_maximum_length "Example 4-8. Accessing
    the length and maximum length fields of a string") by using the `str.strRec` data
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-9. Correct way to access the `length` and `maxlen` fields of a string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'A second way to manipulate strings in HLA is to allocate storage on the heap
    to hold string data. Because strings can''t directly use pointers returned by
    `mem.alloc` (string operations access the 8 bytes prior to the address), you shouldn''t
    use `mem.alloc` to allocate storage for string data. Fortunately, the HLA Standard
    Library memory module provides a memory allocation routine specifically designed
    to allocate storage for strings: `str.alloc`. Like `mem.alloc`, `str.alloc` expects
    a single double-word parameter. This value specifies the maximum number of characters
    allowed in the string. The `str.alloc` routine will allocate the specified number
    of bytes of memory, plus between 9 and 13 additional bytes to hold the extra string
    information.^([[53](#ftn.CHP-4-FN-7)])'
  prefs: []
  type: TYPE_NORMAL
- en: The `str.alloc` routine will allocate storage for a string, initialize the maximum
    length to the value passed as the `str.alloc` parameter, initialize the current
    length to 0, and store a zero-terminating byte in the first character position
    of the string. After this, `str.alloc` returns the address of the zero-terminating
    byte (that is, the address of the first character element) in the EAX register.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've allocated storage for a string, you can call various string-manipulation
    routines in the HLA Standard Library to manipulate the string. The next section
    discusses a few of the HLA string routines in detail; this section introduces
    a couple of string-related routines for the sake of example. The first such routine
    is the `stdin.gets(` *`strvar`* `);`. This routine reads a string from the user
    and stores the string data into the string storage pointed at by the string parameter
    (*`strvar`* in this case). If the user attempts to enter more characters than
    the maximum the string allows, then `stdin.gets` raises the `ex.StringOverflow`
    exception. The program in [Example 4-10](ch04s08.html#reading_a_string_from_the_user
    "Example 4-10. Reading a string from the user") demonstrates the use of `str.alloc`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-10. Reading a string from the user
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: If you look closely, you'll see a slight defect in the program above. It allocates
    storage for the string by calling `str.alloc`, but it never frees the storage
    allocated. Even though the program immediately exits after the last use of the
    string variable, and the operating system will deallocate the storage, it's always
    a good idea to explicitly free up any storage you allocate. Doing so keeps you
    in the habit of freeing allocated storage (so you don't forget to do it when it's
    important); also, programs have a way of growing such that an innocent defect
    that doesn't affect anything in today's program becomes a show-stopping defect
    in tomorrow's version.
  prefs: []
  type: TYPE_NORMAL
- en: To free storage you allocate via `str.alloc`, you must call the `str.free` routine,
    passing the string pointer as the single parameter. The program in [Example 4-11](ch04s08.html#corrected_program_that_reads_a_string_fr
    "Example 4-11. Corrected program that reads a string from the user") is a correction
    of the program [Example 4-10](ch04s08.html#reading_a_string_from_the_user "Example 4-10. Reading
    a string from the user") with this defect corrected.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-11. Corrected program that reads a string from the user
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: When looking at this corrected program, please take note that the `stdin.gets`
    routine expects you to pass it a string parameter that points at an allocated
    string object. Without question, one of the most common mistakes beginning HLA
    programmers make is to call `stdin.gets` and pass it a string variable that they
    have not initialized. This may be getting old now, but keep in mind that *strings
    are pointers!* Like pointers, if you do not initialize a string with a valid address,
    your program will probably crash when you attempt to manipulate that string object.
    The call to `str.alloc` and the following `mov` instruction is how the programs
    above initialize the string pointer. If you are going to use string variables
    in your programs, you must ensure that you allocate storage for the string data
    prior to writing data to the string object.
  prefs: []
  type: TYPE_NORMAL
- en: Allocating storage for a string is such a common operation that many HLA Standard
    Library routines will automatically allocate the storage for you. Generally, such
    routines have an `a_` prefix as part of their name. For example, the `stdin.a_gets`
    combines a call to `str.alloc` and `stdin.gets` into the same routine. This routine,
    which doesn't have any parameters, reads a line of text from the user, allocates
    a string object to hold the input data, and then returns a pointer to the string
    in the EAX register. [Example 4-12](ch04s08.html#reading_a_string_from_the_user_with_stdi
    "Example 4-12. Reading a string from the user with stdin.a_gets") presents an
    adaptation of the two programs in [Example 4-10](ch04s08.html#reading_a_string_from_the_user
    "Example 4-10. Reading a string from the user") and [Example 4-11](ch04s08.html#corrected_program_that_reads_a_string_fr
    "Example 4-11. Corrected program that reads a string from the user") that uses
    `stdin.a_gets`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-12. Reading a string from the user with `stdin.a_gets`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Note that, as before, you must still free up the storage `stdin.a_gets` allocates
    by calling the `str.free` routine. One big difference between this routine and
    the previous two is the fact that HLA will automatically allocate exactly enough
    space for the string read from the user. In the previous programs, the call to
    `str.alloc` allocates only 16 bytes. If the user types more than 16 characters,
    then the program raises an exception and quits. If the user types fewer than 16
    characters, then some space at the end of the string is wasted. The `stdin.a_gets`
    routine, on the other hand, always allocates the minimum necessary space for the
    string read from the user. Because it allocates the storage, there is little chance
    of overflow.^([[54](#ftn.CHP-4-FN-8)])
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[52](#CHP-4-FN-6)]) Note that this scheme is not recommended. If you need
    to extract the length information from a string, use the routines provided in
    the HLA string library for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[53](#CHP-4-FN-7)]) `str.alloc` may allocate more than 9 bytes for the overhead
    data because the memory allocated to an HLA string must always be double-word
    aligned, and the total length of the data structure must be a multiple of 4.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[54](#CHP-4-FN-8)]) Actually, there are limits on the maximum number of characters
    that `stdin.a_gets` will allocate. This is typically between 1,024 bytes and 4,096
    bytes. See the HLA Standard Library source listings and your operating system
    documentation for the exact value.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9 Accessing the Characters Within a String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extracting individual characters from a string is a very common task. It is
    so easy that HLA doesn't provide any specific procedure or language syntax to
    accomplish this—you simply use machine instructions to accomplish this. Once you
    have a pointer to the string data, a simple indexed addressing mode will do the
    rest of the work for you.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the most important thing to keep in mind is that *strings are pointers*.
    Therefore, you cannot apply an indexed addressing mode directly to a string variable
    and expect to extract characters from the string. That is, if `s` is a string
    variable, then `mov( s[ebx], al )`; does not fetch the character at position EBX
    in string `s` and place it in the AL register. Remember, `s` is just a pointer
    variable; an addressing mode like `s[ebx]` will simply fetch the byte at offset
    EBX in memory starting at the address of `s` (see [Figure 4-1](ch04s09.html#incorrectly_indexing_off_a_string_variab
    "Figure 4-1. Incorrectly indexing off a string variable")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Incorrectly indexing off a string variable](tagoreillycom20100401nostarchimages577979.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1. Incorrectly indexing off a string variable
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 4-1](ch04s09.html#incorrectly_indexing_off_a_string_variab "Figure 4-1. Incorrectly
    indexing off a string variable"), assuming EBX contains 3, `s[ebx]` does not access
    the fourth character in the string `s`; instead it fetches the fourth byte of
    the pointer to the string data. It is very unlikely that this is what you would
    want. [Figure 4-2](ch04s09.html#correctly_indexing_off_the_value_of_a_st "Figure 4-2. Correctly
    indexing off the value of a string variable") shows the operation that is necessary
    to fetch a character from the string, assuming EBX contains the value of `s`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Correctly indexing off the value of a string variable](tagoreillycom20100401nostarchimages577981.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2. Correctly indexing off the value of a string variable
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 4-2](ch04s09.html#correctly_indexing_off_the_value_of_a_st "Figure 4-2. Correctly
    indexing off the value of a string variable") EBX contains the value of string
    `s`. The value of `s` is a pointer to the actual string data in memory. Therefore,
    EBX will point at the first character of the string when you load the value of
    `s` into EBX. The following code demonstrates how to access the fourth character
    of string `s` in this fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to load the character at a variable, rather than fixed, offset
    into the string, then you can use one of the 80x86''s scaled indexed addressing
    modes to fetch the character. For example, if an `uns32` variable `index` contains
    the desired offset into the string, you could use the following code to access
    the character at `s[index]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'There is only one problem with the code above—it does not check to ensure that
    the character at offset `index` actually exists. If `index` is greater than the
    current length of the string, then this code will fetch a garbage byte from memory.
    Unless you can a priori determine that `index` is always less than the length
    of the string, code like this is dangerous to use. A better solution is to check
    the index against the string''s current length before attempting to access the
    character. The following code provides one way to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In the `else` portion of this `if` statement you could take corrective action,
    print an error message, or raise an exception. If you want to explicitly raise
    an exception, you can use the HLA `raise` statement to accomplish this. The syntax
    for the `raise` statement is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the *`integer_constant`* or 32-bit register must be an exception
    number. Usually, this is one of the predefined constants in the *excepts.hhf*
    header file. An appropriate exception to raise when a string index is greater
    than the length of the string is `ex.StringIndexError`. The following code demonstrates
    raising this exception if the string index is out of bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 4.10 The HLA String Module and Other String-Related Routines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although HLA provides a powerful definition for string data, the real power
    behind HLA's string capabilities lies in the HLA Standard Library, not in the
    definition of HLA string data. HLA provides hundreds of string-manipulation routines
    that far exceed the capabilities found in standard high-level languages like C/C++,
    Java, or Pascal; indeed, HLA's string-handling capabilities rival those in string-processing
    languages like Icon or SNOBOL4\. This chapter discusses several of the string
    functions that the HLA Standard Library provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most basic string operation you will need is to assign one string
    to another. There are three different ways to assign strings in HLA: by reference,
    by copying a string, and by duplicating a string. Of these, assignment by reference
    is the fastest and easiest. If you have two strings and you wish to assign one
    string to the other, a simple and fast way to do this is to copy the string pointer.
    The following code fragment demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: String assignment by reference is very efficient because it involves only two
    simple `mov` instructions regardless of the string length. Assignment by reference
    works great if you never modify the string data after the assignment operation.
    Do keep in mind, though, that both string variables (`string1` and `string2` in
    the example above) *wind up pointing at the same data*. So if you make a change
    to the data pointed at by one string variable, you will change the string data
    pointed at by the second string object because both objects point at the same
    data. [Example 4-13](ch04s10.html#problem_with_string_assignment_by_copyin "Example 4-13. Problem
    with string assignment by copying pointers") provides a program that demonstrates
    this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-13. Problem with string assignment by copying pointers
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Because both `string1` and `string2` point at the same string data in this example,
    any change you make to one string is reflected in the other. While this is sometimes
    acceptable, most programmers expect assignment to produce a different copy of
    a string; that is, they expect the semantics of string assignment to produce two
    unique copies of the string data.
  prefs: []
  type: TYPE_NORMAL
- en: An important point to remember when using *copy by reference* (this term means
    copying a pointer) is that you have created an alias of the string data. The term
    *alias* means that you have two names for the same object in memory (for example,
    in the program above, `string1` and `string2` are two different names for the
    same string data). When you read a program, it is reasonable to expect that different
    variables refer to different memory objects. Aliases violate this rule, thus making
    your program harder to read and understand because you have to remember that aliases
    do not refer to different objects in memory. Failing to keep this in mind can
    lead to subtle bugs in your program. For instance, in the example above you have
    to remember that `string1` and `string2` are aliases so as not to free both objects
    at the end of the program. Worse still, you have to remember that `string1` and
    `string2` are aliases so that you don't continue to use `string2` after freeing
    `string1` because `string2` would be a dangling reference at that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because using copy by reference makes your programs harder to read and increases
    the possibility that you might introduce subtle defects into your programs, you
    might wonder why someone would use copy by reference at all. There are two reasons
    for this: First, copy by reference is very efficient; it involves only the execution
    of two `mov` instructions. Second, some algorithms actually depend on copy-by-reference
    semantics. Nevertheless, before using this technique you should carefully consider
    whether copying string pointers is the appropriate way to do a string assignment
    in your program.'
  prefs: []
  type: TYPE_NORMAL
- en: The second way to assign one string to another is to copy the string data. The
    HLA Standard Library `str.cpy` routine provides this capability. A call to the
    `str.cpy` procedure uses the following call syntax:^([[55](#ftn.CHP-4-FN-9)])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The source and destination strings must be string variables (pointers) or 32-bit
    registers containing the addresses of the string data in memory.
  prefs: []
  type: TYPE_NORMAL
- en: The `str.cpy` routine first checks the maximum length field of the destination
    string to ensure that it is at least as big as the source string's current length.
    If it is not, then `str.cpy` raises the `ex.StringOverflow` exception. If the
    destination string's maximum length is large enough, then `str.cpy` copies the
    string length, the characters, and the zero-terminating byte from the source string
    to the destination string. When this process is complete, the two strings point
    at identical data, but they do not point at the same data in memory.^([[56](#ftn.CHP-4-FN-10)])
    The program in [Example 4-14](ch04s10.html#copying_strings_using_str.cpy "Example 4-14. Copying
    strings using str.cpy") is a rework of the example in [Example 4-13](ch04s10.html#problem_with_string_assignment_by_copyin
    "Example 4-13. Problem with string assignment by copying pointers") using `str.cpy`
    rather than copy by reference.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-14. Copying strings using `str.cpy`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: There are two important things to note about the program in [Example 4-14](ch04s10.html#copying_strings_using_str.cpy
    "Example 4-14. Copying strings using str.cpy"). First, note that this program
    begins by allocating storage for `string2`. Remember, the `str.cpy` routine does
    not allocate storage for the destination string; it assumes that the destination
    string already has storage allocated. Keep in mind that `str.cpy` does not initialize
    `string2`; it only copies data to the location where `string2` is pointing. It
    is the program's responsibility to initialize the string by allocating sufficient
    memory before calling `str.cpy`. The second thing to notice here is that the program
    calls `str.free` to free up the storage for both `string1` and `string2` before
    the program quits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Allocating storage for a string variable prior to calling `str.cpy` is so common
    that the HLA Standard Library provides a routine that allocates and copies the
    string: `str.a_cpy`. This routine uses the following call syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is no destination string. This routine looks at the length of
    the source string, allocates sufficient storage, makes a copy of the string, and
    then returns a pointer to the new string in the EAX register. The program in [Example 4-15](ch04s10.html#copying_strings_using_str.a_underscore_c
    "Example 4-15. Copying strings using str.a_cpy") demonstrates how to do the same
    thing as the program in [Example 4-14](ch04s10.html#copying_strings_using_str.cpy
    "Example 4-14. Copying strings using str.cpy") using the `str.a_cpy` procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-15. Copying strings using `str.a_cpy`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever you use copy by reference or `str.a_cpy` to assign a string, don't
    forget to free the storage associated with the string when you have (completely)
    finished with that string's data. Failure to do so may produce a memory leak if
    you do not have another pointer to the previous string data lying around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtaining the length of a character string is so common that the HLA Standard
    Library provides a `str.length` routine specifically for this purpose. Of course,
    you can fetch the length by using the `str.strRec` data type to access the length
    field directly, but constant use of this mechanism can be tiring because it involves
    a lot of typing. The `str.length` routine provides a more compact and convenient
    way to fetch the length information. You call `str.length` using one of the following
    two formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This routine returns the current string length in the EAX register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another pair of useful string routines is the `str.cat` and `str.a_cat` procedures.
    They use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: These two routines concatenate two strings (that is, they create a new string
    by joining the two strings together). The `str.cat` procedure concatenates the
    source string to the end of the destination string. Before the concatenation actually
    takes place, `str.cat` checks to make sure that the destination string is large
    enough to hold the concatenated result, and it raises the `ex.StringOverflow`
    exception if the destination string's maximum length is too small.
  prefs: []
  type: TYPE_NORMAL
- en: The `str.a_cat` routine, as its name suggests, allocates storage for the resulting
    string before doing the concatenation. This routine will allocate sufficient storage
    to hold the concatenated result, then it will copy the `srcLStr` to the allocated
    storage, next it will append the string data pointed at by `srcRStr` to the end
    of this new string, and then it will return a pointer to the new string in the
    EAX register.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note a potential source of confusion. The `str.cat` procedure concatenates its
    first operand to the end of the second operand. Therefore, `str.cat` follows the
    standard `(src, dest)` operand format present in many HLA statements. The `str.a_cat`
    routine, on the other hand, has two source operands rather than a source operand
    and a destination operand. The `str.a_cat` routine concatenates its two operands
    in an intuitive left-to-right fashion. This is the opposite of `str.cat`. Keep
    this in mind when using these two routines.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-16](ch04s10.html#demonstration_of_str.cat_and_str.a_under "Example 4-16. Demonstration
    of str.cat and str.a_cat routines") demonstrates the use of the `str.cat` and
    `str.a_cat` routines.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-16. Demonstration of `str.cat` and `str.a_cat` routines
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `str.insert` and `str.a_insert` routines are similar to the string-concatenation
    procedures. However, the `str.insert` and `str.a_insert` routines let you insert
    one string anywhere into another string, not just at the end of the string. The
    calling sequences for these two routines are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: These two routines insert the source string (*`src`*) into the destination string
    (*`dest`*) starting at character position *`index`*. The `str.insert` routine
    inserts the source string directly into the destination string; if the destination
    string is not large enough to hold both strings, `str.insert` raises an `ex.StringOverflow`
    exception. The `str.a_insert` routine first allocates storage for a new string
    on the heap, copies the destination string (*`src`*) to the new string, and then
    inserts the source string (*`dest`*) into this new string at the specified offset;
    `str.a_insert` returns a pointer to the new string in the EAX register.
  prefs: []
  type: TYPE_NORMAL
- en: Indexes into a string are zero based. This means that if you supply the value
    0 as the index in `str.insert` or `str.a_insert`, then these routines will insert
    the source string before the first character of the destination string. Likewise,
    if the *`index`* is equal to the length of the string, then these routines will
    simply concatenate the source string to the end of the destination string.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `index` is greater than the length of the string, the `str.insert` and
    `str.a_insert` procedures will not raise an exception; instead, they will simply
    append the source string to the end of the destination string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `str.delete` and `str.a_delete` routines let you remove characters from
    a string. They use the following calling sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Both routines delete *`Length`* characters starting at character position *`StartIndex`*
    in string *`strng`*. The difference between the two is that `str.delete` deletes
    the characters directly from *`strng`*, whereas `str.a_delete` first allocates
    storage and copies *`strng`* and then deletes the characters from the new string
    (leaving *`strng`* untouched). The `str.a_delete` routine returns a pointer to
    the new string in the EAX register.
  prefs: []
  type: TYPE_NORMAL
- en: The `str.delete` and `str.a_delete` routines are very forgiving with respect
    to the values you pass in *`StartIndex`* and *`Length`*. If *`StartIndex`* is
    greater than the current length of the string, these routines do not delete any
    characters from the string. If *`StartIndex`* is less than the current length
    of the string, but *`StartIndex`*+*`Length`* is greater than the length of the
    string, then these routines will delete all characters from *`StartIndex`* to
    the end of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very common string operation is the need to copy a portion of a string
    to another string without otherwise affecting the source string. The `str.substr`
    and `str.a_substr` routines provide this capability. These routines use the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `str.substr` routine copies *`Length`* characters, starting at position
    *`StartIndex`*, from the *`src`* string to the *`dest`* string. The dest string
    must have sufficient storage to hold the new string or `str.substr` will raise
    an `ex.StringOverflow` exception. If the *`StartIndex`* value is greater than
    the length of the string, then `str.substr` will raise an `ex.StringIndexError`
    exception. If *`StartIndex`*+*`Length`* is greater than the length of the source
    string, but *`StartIndex`* is less than the length of the string, then `str.substr`
    will extract only those characters from *`StartIndex`* to the end of the string.
  prefs: []
  type: TYPE_NORMAL
- en: The `str.a_substr` procedure behaves in a fashion nearly identical to `str.substr`,
    except it allocates storage on the heap for the destination string. `str.a_substr`
    handles exceptions identically to `str.substr`, except it never raises a string
    overflow exception because this will never occur.^([[57](#ftn.CHP-4-FN-11)]) As
    you can probably guess by now, `str.a_substr` returns a pointer to the newly allocated
    string in the EAX register.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have been working with string data for a little while, the need will
    invariably arise to compare two strings. A first attempt at string comparison,
    using the standard HLA relational operators, will compile but not necessarily
    produce the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, *strings are pointers*. This code compares the two pointers to see
    if they are equal. If they are equal, clearly the two strings are equal (because
    both `s1` and `s2` point at the exact same string data). However, the fact that
    the two pointers are different doesn''t necessarily mean that the strings are
    not equivalent. Both `s1` and `s2` could contain different values (that is, they
    point at different addresses in memory), yet the string data at those two addresses
    could be identical. Most programmers expect a string comparison for equality to
    be true if the data for the two strings is the same. Clearly a pointer comparison
    does not provide this type of comparison. To overcome this problem, the HLA Standard
    Library provides a set of string-comparison routines that will compare the string
    data, not just their pointers. These routines use the following calling sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these routines compares the *`src1`* string to the *`src2`* string
    and returns true (1) or false (0) in the EAX register depending on the comparison.
    For example, `str.eq( s1, s2);` returns true in EAX if `s1` is equal to `s2`.
    HLA provides a small extension that allows you to use the string-comparison routines
    within an `if` statement.^([[58](#ftn.CHP-4-FN-12)]) The following code demonstrates
    the use of some of these comparison routines within an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the string the user enters in this example must exactly match `Hello`,
    including the use of an uppercase *H* at the beginning of the string. When processing
    user input, it is best to ignore alphabetic case in string comparisons because
    different users have different ideas about when they should be pressing the SHIFT
    key on the keyboard. An easy solution is to use the HLA case-insensitive string-comparison
    functions. These routines compare two strings, ignoring any differences in alphabetic
    case. These routines use the following calling sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Other than they treat uppercase characters the same as their lowercase equivalents,
    these routines behave exactly like the former routines, returning true or false
    in EAX depending on the result of the comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Like most high-level languages, HLA compares strings using *lexicographical
    ordering*. This means that two strings are equal if and only if their lengths
    are the same and the corresponding characters in the two strings are exactly the
    same. For less-than or greater-than comparisons, lexicographical ordering corresponds
    to the way words appear in a dictionary. That is, `a` is less than `b` is less
    than `c`, and so on. Actually, HLA compares the strings using the ASCII numeric
    codes for the characters, so if you are unsure whether `a` is less than a period,
    simply consult the ASCII character chart (incidentally, `a` is greater than a
    period in the ASCII character set, just in case you were wondering).
  prefs: []
  type: TYPE_NORMAL
- en: If two strings have different lengths, lexicographical ordering worries about
    the length only if the two strings exactly match through the length of the shorter
    string. If this is the case, then the longer string is greater than the shorter
    string (and, conversely, the shorter string is less than the longer string). Note,
    however, that if the characters in the two strings do not match at all, then HLA's
    string-comparison routines ignore the length of the string; for example, `z` is
    always greater than `aaaaa`, even though it is shorter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `str.eq` routine checks to see if two strings are equal. Sometimes, however,
    you might want to know whether one string *contains* another string. For example,
    you may want to know if some string contains the substring `north` or `south`
    to determine some action to take in a game. The HLA `str.index` routine lets you
    check to see if one string is contained as a substring of another. The `str.index`
    routine uses the following calling sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This function returns, in EAX, the offset into *`StrToSearch`* where *`SubstrToSearchFor`*
    appears. This routine returns −1 in EAX if *`SubstrToSearchFor`* is not present
    in *`StrToSearch`*. Note that `str.index` will do a case-sensitive search. Therefore,
    the strings must exactly match. There is no case-insensitive variant of `str.index`
    you can use.^([[59](#ftn.CHP-4-FN-13)])
  prefs: []
  type: TYPE_NORMAL
- en: The HLA `strings` module contains hundreds of routines besides those appearing
    in this section. Space limitations and prerequisite knowledge prevent the presentation
    of all those functions here; however, this does not mean that the remaining string
    functions are unimportant. You should definitely take a look at the HLA Standard
    Library documentation to learn everything you can about the powerful HLA string
    library routines.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[55](#CHP-4-FN-9)]) Warning to C/C++ users: note that the order of the operands
    is opposite that of the C Standard Library `strcpy` function.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[56](#CHP-4-FN-10)]) Unless, of course, both string pointers contained the
    same address to begin with, in which case `str.cpy` copies the string data over
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[57](#CHP-4-FN-11)]) Technically, `str.a_substr`, like all routines that
    call `mem.alloc` to allocate storage, can raise an `ex.MemoryAllocationFailure`
    exception, but this is very unlikely to occur.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[58](#CHP-4-FN-12)]) This extension is actually a little more general than
    this section describes. [Chapter 7](ch07.html "Chapter 7. LOW-LEVEL CONTROL STRUCTURES")
    explains it fully.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[59](#CHP-4-FN-13)]) However, HLA does provide routines that will convert
    all the characters in a string to one case or another. So you can make copies
    of the strings, convert all the characters in both copies to lowercase, and then
    search using these converted strings. This will achieve the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 4.11 In-Memory Conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HLA Standard Library''s `string` module contains dozens of routines for
    converting between strings and other data formats. Although it''s a little premature
    in this text to present a complete description of those functions, it would be
    rather criminal not to discuss at least one of the available functions: the `str.put`
    routine. This routine encapsulates the capabilities of many of the other string-conversion
    functions, so if you learn how to use this one, you''ll have most of the capabilities
    of those other routines at your disposal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You use the `str.put` routine in a manner very similar to the `stdout.put`
    routine. The only difference is that the `str.put` routine "writes" its data to
    a string instead of the standard output device. A call to `str.put` has the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of a call to `str.put`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally, you would not put a newline character sequence at the end of the
    string as you would if you were printing the string to the standard output device.
  prefs: []
  type: TYPE_NORMAL
- en: The *`destString`* parameter at the beginning of the `str.put` parameter list
    must be a string variable, and it must already have storage associated with it.
    If `str.put` attempts to store more characters than allowed into the *`destString`*
    parameter, then this function raises the `ex.StringOverflow` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time you won't know the length of the string that `str.put` will
    produce. In those instances, you should allocate storage for a very large string,
    one that is much larger than you expect, and use this string object as the first
    parameter of the `str.put` call. This will prevent an exception from crashing
    your program. Generally, if you expect to produce about one screen line of text,
    then you should probably allocate at least 256 characters for the destination
    string. If you're creating longer strings, you should probably use a default of
    1,024 characters (or more, if you're going to produce *really* large strings).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `str.put` routine to convert any data to a string that you can
    print using `stdout.put`. You will probably find this routine invaluable for common
    value-to-string conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 4.12 Character Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Character sets are another composite data type, like strings, built upon the
    character data type. A character set is a mathematical set of characters with
    the most important attribute being membership. That is, a character is either
    a member of a set or it is not a member of a set. The concept of sequence (for
    example, whether one character comes before another, as in a string) doesn't apply
    to character sets. Also, membership is a binary relation; a character is either
    in the set or it is not in the set; you cannot have multiple copies of the same
    character in a character set. Various operations are possible on character sets,
    including the mathematical set operations of union, intersection, difference,
    and membership test.
  prefs: []
  type: TYPE_NORMAL
- en: HLA implements a restricted form of character sets that allows set members to
    be any of the 128 standard ASCII characters (that is, HLA's character set facilities
    do not support extended character codes in the range 128..255). Despite this restriction,
    HLA's character set facilities are very powerful and are handy when writing programs
    that work with string data. The following sections describe the implementation
    and use of HLA's character set facilities so you may take advantage of character
    sets in your own programs.
  prefs: []
  type: TYPE_NORMAL
- en: 4.13 Character Set Implementation in HLA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different ways to represent character sets in an assembly language
    program. HLA implements character sets using an array of 128 boolean values. Each
    boolean value determines whether the corresponding character is a member of the
    character set; that is, a true boolean value indicates that the corresponding
    character is a member of the set, whereas a false value indicates that the character
    is not a member of the set. To conserve memory, HLA allocates only a single bit
    for each character in the set; therefore, HLA character sets consume 16 bytes
    of memory because there are 128 bits in 16 bytes. This array of 128 bits is organized
    in memory as shown in [Figure 4-3](ch04s13.html#bit_layout_of_a_character_set_object
    "Figure 4-3. Bit layout of a character set object").
  prefs: []
  type: TYPE_NORMAL
- en: '![Bit layout of a character set object](tagoreillycom20100401nostarchimages577983.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3. Bit layout of a character set object
  prefs: []
  type: TYPE_NORMAL
- en: Bit 0 of byte 0 corresponds to ASCII code 0 (the NUL character). If this bit
    is 1, then the character set contains the NUL character; if this bit contains
    false, then the character set does not contain the NUL character. Likewise, bit
    0 of byte 1 (the ninth bit in the 128-bit array) corresponds to the backspace
    character (ASCII code is 8). Bit 1 of byte 8 corresponds to ASCII code 65, an
    uppercase `A`. Bit 65 will contain a 1 if `A` is a current member of the character
    set; it will contain 0 if `A` is not a member of the set.
  prefs: []
  type: TYPE_NORMAL
- en: While there are other possible ways to implement character sets, with this bit-vector
    implementation it is very easy to implement set operations such as union, intersection,
    difference comparison, and membership tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA supports character set variables using the `cset` data type. To declare
    a character set variable, you would use a declaration like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This declaration will reserve 16 bytes of storage to hold the 128 bits needed
    to represent a set of ASCII characters.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is possible to manipulate the bits in a character set using instructions
    like `and`, `or`, `xor`, and so on, the 80x86 instruction set includes several
    bit test, set, reset, and complement instructions that are nearly perfect for
    manipulating character sets. The `bt` (bit test) instruction, for example, will
    copy a single bit in memory to the carry flag. The `bt` instruction allows the
    following syntactical forms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The first operand holds a bit number, and the second operand specifies a register
    or memory location whose bit should be copied into the carry flag. If the second
    operand is a register, the first operand must contain a value in the range 0..*n*−1,
    where *n* is the number of bits in the second operand. If the first operand is
    a constant and the second operand is a memory location, the constant must be in
    the range 0..255\. Here are some examples of these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bt` instruction turns out to be quite useful for testing set membership.
    For example, to see if the character `A` is a member of a character set, you could
    use a code sequence like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The `bts` (bit test and set), `btr` (bit test and reset), and `btc` (bit test
    and complement) instructions are also useful for manipulating character set variables.
    Like the `bt` instruction, these instructions copy the specified bit into the
    carry flag; after copying the specified bit, these instructions will set (`bts`),
    reset/clear (`btr`), or complement/invert (`btc`) the specified bit. Therefore,
    you can use the `bts` instruction to add a character to a character set via set
    union (that is, it adds a character to the set if the character was not already
    a member of the set; otherwise the set is unaffected). You can use the `btr` instruction
    to remove a character from a character set via set intersection (that is, it removes
    a character from the set if and only if it was previously in the set; otherwise
    it has no effect on the set). The `btc` instruction lets you add a character to
    the set if it wasn't previously in the set; it removes the character from the
    set if it was previously a member (that is, it toggles the membership of that
    character in the set).
  prefs: []
  type: TYPE_NORMAL
- en: 4.14 HLA Character Set Constants and Character Set Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HLA supports literal character set constants. These `cset` constants make it
    easy to initialize `cset` variables at compile time and allow you to easily pass
    character set constants as procedure parameters. An HLA character set constant
    takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of a simple character set holding the numeric digit
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'When specifying a character set literal that has several contiguous values,
    HLA lets you concisely specify the values using only the starting and ending values
    of the range thusly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'You may combine characters and various ranges within the same character set
    constant. For example, the following character set constant is all the alphanumeric
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use these `cset` literal constants as initializers in the `const` and
    `val` sections. The following example demonstrates how to create the symbolic
    constant `AlphaNumeric` using the character set above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: After the above declaration, you can use the identifier `AlphaNumeric` anywhere
    the character set literal is legal.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use character set literals (and, of course, character set symbolic
    constants) as the initializer field for a `static` or `readonly` variable. The
    following code fragment demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Anywhere you can use a character set literal constant, a character set constant
    expression is also legal. [Table 4-2](ch04s14.html#hla_character_set_operators
    "Table 4-2. HLA Character Set Operators") shows the operators that HLA supports
    in character set constant expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-2. HLA Character Set Operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CSetConst1 + CSetConst2` | Computes the union of the two sets. The set union
    is the set of all characters that are in either set. |'
  prefs: []
  type: TYPE_TB
- en: '| `CSetConst1 * CSetConst2` | Computes the intersection of the two sets. The
    set intersection is the set of all characters that appear in both operand sets.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `CSetConst1 - CSetConst2` | Computes the set difference of the two sets.
    The set difference is the set of characters that appear in the first set but do
    not appear in the second set. |'
  prefs: []
  type: TYPE_TB
- en: '| `-CSetConst` | Computes the set complement. The set complement is the set
    of all characters not in the set. |'
  prefs: []
  type: TYPE_TB
- en: Note that these operators produce only compile-time results. That is, the expressions
    above are computed by the compiler during compilation; they do not emit any machine
    code. If you want to perform these operations on two different sets while your
    program is running, the HLA Standard Library provides routines you can call to
    achieve the results you desire. HLA also provides other compile-time character
    set operators.
  prefs: []
  type: TYPE_NORMAL
- en: 4.15 Character Set Support in the HLA Standard Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HLA Standard Library provides several character set routines you may find
    useful. The character set support routines fall into four categories: standard
    character set functions, character set tests, character set conversions, and character
    set I/O. This section describes these routines in the HLA Standard Library.'
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, let's consider the Standard Library routines that help you construct
    character sets. These routines include `cs.empty`, `cs.cpy`, `cs.charToCset`,
    `cs.unionChar`, `cs.removeChar`, `cs.rangeChar`, `cs.strToCset`, and `cs.unionStr`.
    These procedures let you build up character sets at runtime using character and
    string objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.empty` procedure initializes a character set variable with the empty
    set by setting all the bits in the character set to 0\. This procedure call uses
    the following syntax (*`CSvar`* is a character set variable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cs.cpy` procedure copies one character set to another, replacing any data
    previously held by the destination character set. The syntax for `cs.cpy` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The `cs.cpy` source character set can be either a character set constant or
    a character set variable. The destination character set must be a character set
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.unionChar` procedure adds a character to a character set. It uses the
    following calling sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This call will add the first parameter, a character, to the set via set union.
    Note that you could use the `bts` instruction to achieve this same result; however,
    the `cs.unionChar` call is often more convenient. The character value must be
    in the range #0..#127.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.charToCset` function creates a singleton set (a set containing a single
    character). The calling format for this function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The first operand, the character value *`CharValue`*, can be an 8-bit register,
    a constant, or a character variable that holds a value in the range #0..#127\.
    The second operand (*`CSvar`*) must be a character set variable. This function
    clears the destination character set to all zeros and then unions the specified
    character into the character set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.removeChar` procedure lets you remove a single character from a character
    set without affecting the other characters in the set. This function uses the
    same syntax as `cs.charToCset`, and the parameters have the same attributes. The
    calling sequence is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Note that if the character was not in the *`CSVar`* set to begin with, `cs.removeChar`
    will not affect the set. This function roughly corresponds to the `btr` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.rangeChar` constructs a character set containing all the characters
    between two characters you pass as parameters. This function sets all bits outside
    the range of these two characters to 0\. The calling sequence is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The *`LowerBoundChar`* and *`UpperBoundChar`* parameters can be constants,
    registers, or character variables. The values held in *`LowerBoundChar`* and *`UpperBoundChar`*
    must be in the range #0..#127\. `CSVar`, the destination character set, must be
    a `cset` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.strToCset` procedure creates a new character set containing the union
    of all the characters in a character string. This procedure begins by setting
    the destination character set to the empty set, and then it unions in the characters
    in the string one by one until it exhausts all characters in the string. The calling
    sequence is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Technically, the *`StringValue`* parameter can be a string constant as well
    as a string variable; however, it doesn't make any sense to call `cs.strToCset`
    this way because `cs.cpy` is a much more efficient way to initialize a character
    set with a constant set of characters. As usual, the destination character set
    must be a `cset` variable. Typically, you'd use this function to create a character
    set based on a string input by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.unionStr` procedure will add the characters in a string to an existing
    character set. Like `cs.strToCset`, you''d normally use this function to union
    characters into a set based on a string input by the user. The calling sequence
    for this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Standard set operations include union, intersection, and set difference. The
    HLA Standard Library routines `cs.setunion`, `cs.intersection`, and `cs.difference`
    provide these operations, respectively.^([[60](#ftn.CHP-4-FN-14)]) These routines
    all use the same calling sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter can be a character set constant or a character set variable.
    The second parameter must be a character set variable. These procedures compute
    *`destCset`* `:=` *`destCset op srcCset`* where *`op`* represents set union, intersection,
    or difference, depending on the function call.
  prefs: []
  type: TYPE_NORMAL
- en: The third category of character set routines test character sets in various
    ways. They typically return a boolean value indicating the result of the test.
    The HLA character set routines in this category include `cs.IsEmpty`, `cs.member`,
    `cs.subset`, `cs.psubset`, `cs.superset`, `cs.psuperset`, `cs.eq`, and `cs.ne`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.IsEmpty` function tests a character set to see if it is the empty set.
    The function returns true or false in the EAX register. This function uses the
    following calling sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The single parameter may be a constant or a character set variable, although
    it doesn't make much sense to pass a character set constant to this procedure
    (because you would know at compile time whether this set is empty).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.member` function tests to see if a character value is a member of a
    set. This function returns true in the EAX register if the character is a member
    of the set. Note that you can use the `bt` instruction to test this same condition.
    However, the `cs.member` function is probably a little more convenient to use
    if the character argument is not a constant. The calling sequence for `cs.member`
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is an 8-bit register, character variable, or a constant.
    The second parameter is either a character set constant or a character set variable.
    It would be unusual for both parameters to be constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.subset`*,* `cs.psubset` (proper subset), `cs.superset`*,* and `cs.psuperset`
    (proper superset) functions let you check to see if one character set is a subset
    or superset of another. The calling sequence for these four routines is nearly
    identical; it is one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: These routines compare the first parameter against the second parameter and
    return true or false in the EAX register depending upon the result. One set is
    a subset of another if all the members of the first character set are present
    in the second character set. It is a proper subset if the second (right) character
    set also contains characters not found in the first (left) character set. Likewise,
    one character set is a superset of another if it contains all the characters in
    the second set (and possibly more). A proper superset contains additional characters
    beyond those found in the second set. The parameters can be either character set
    variables or character set constants; however, it would be unusual for both parameters
    to be character set constants (because you can determine this at compile time,
    there would be no need to call a runtime function to compute this).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.eq` and `cs.ne` functions check to see if two sets are equal or not
    equal. These functions return true or false in EAX depending upon the set comparison.
    The calling sequence is identical to the sub/superset functions above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Note that there are no functions that test for less than, less than or equal,
    greater than, or greater than or equal. The subset and proper subset functions
    are the equivalent of less than or equal and less than (respectively); likewise,
    the superset and proper superset functions are equivalent to greater than or equal
    and greater than (respectively).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.extract` routine removes an arbitrary character from a character set
    and returns that character in the EAX register.^([[61](#ftn.CHP-4-FN-15)]) The
    calling sequence is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: The single parameter must be a character set variable. Note that this function
    will modify the character set variable by removing some character from the character
    set. This function returns $FFFF_FFFF (−1) in EAX if the character set was empty
    prior to the call.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the routines found in the `cset.hhf` (character set) library
    module, the string and standard output modules also provide functions that allow
    or expect character set parameters. For example, if you supply a character set
    value as a parameter to `stdout.put`, the `stdout.put` routine will print the
    characters currently in the set. See the HLA Standard Library documentation for
    more details on character set-handling procedures.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[60](#CHP-4-FN-14)]) `cs.setunion` was used rather than `cs.union` because
    *union* is an HLA reserved word.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[61](#CHP-4-FN-15)]) This routine returns the character in AL and zeros out
    the H.O. 3 bytes of EAX.
  prefs: []
  type: TYPE_NORMAL
- en: 4.16 Using Character Sets in Your HLA Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Character sets are valuable for many different purposes in your programs. For
    example, one common use of character sets is to validate user input. This section
    will also present a couple of other applications for character sets to help you
    start thinking about how you could use them in your program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following short code segment that gets a yes/no-type answer from
    the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'A major problem with this code sequence is that it will stop only if the user
    types a lowercase *n* character. If the user types anything other than *n* (including
    uppercase *N*), the program will treat this as an affirmative answer and transfer
    back to the beginning of the `repeat..until` loop. A better solution would be
    to validate the user input before the `until` clause above to ensure that the
    user has only typed *n*, *N*, *y*, or *Y*. The following code sequence will accomplish
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 4.17 Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with strings, arrays are probably the most commonly used composite data.
    Yet most beginning programmers don't understand how arrays operate internally
    and their associated efficiency trade-offs. It's surprising how many novice (and
    even advanced!) programmers view arrays from a completely different perspective
    once they learn how to deal with arrays at the machine level.
  prefs: []
  type: TYPE_NORMAL
- en: Abstractly, an array is an aggregate data type whose members (elements) are
    all the same type. Selection of a member from the array is by an integer index.^([[62](#ftn.CHP-4-FN-16)])
    Different indices select unique elements of the array. This text assumes that
    the integer indices are contiguous (though this is by no means required). That
    is, if the number *x* is a valid index into the array and *y* is also a valid
    index, with *x* < *y*, then all *i* such that *x* < *i* < *y* are valid indices.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you apply the indexing operator to an array, the result is the specific
    array element chosen by that index. For example, *`A`*`[`*`i`*`]` chooses the
    *i*th element from array `A`. Note that there is no formal requirement that element
    *`i`* be anywhere near element *`i`*`+1` in memory. As long as *`A`*`[`*`i`*`]`
    always refers to the same memory location and *`A`*`[`*`i+1`*`]` always refers
    to its corresponding location (and the two are different), the definition of an
    array is satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: In this text, we assume that array elements occupy contiguous locations in memory.
    An array with five elements will appear in memory as [Figure 4-4](ch04s17.html#array_layout_in_memory
    "Figure 4-4. Array layout in memory") shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Array layout in memory](tagoreillycom20100401nostarchimages577985.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4. Array layout in memory
  prefs: []
  type: TYPE_NORMAL
- en: The *base address* of an array is the address of the first element on the array
    and always appears in the lowest memory location. The second array element directly
    follows the first in memory, the third element follows the second, and so on.
    Note that there is no requirement that the indices start at 0\. They may start
    with any number as long as they are contiguous. However, for the purposes of discussion,
    this book will start all indexes at 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access an element of an array, you need a function that translates an array
    index to the address of the indexed element. For a single-dimensional array, this
    function is very simple. It is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: where *`Initial_Index`* is the value of the first index in the array (which
    you can ignore if 0) and the value *`Element_Size`* is the size, in bytes, of
    an individual array element.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[62](#CHP-4-FN-16)]) Or it could be some value whose underlying representation
    is integer, such as character, enumerated, and boolean types.
  prefs: []
  type: TYPE_NORMAL
- en: 4.18 Declaring Arrays in Your HLA Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you can access elements of an array, you need to set aside storage for
    that array. Fortunately, array declarations build on the declarations you''ve
    already seen. To allocate `n` elements in an array, you would use a declaration
    like the following in one of the variable declaration sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '*`ArrayName`* is the name of the array variable and *`basetype`* is the type
    of an element of that array. This sets aside storage for the array. To obtain
    the base address of the array, just use *`ArrayName`*.'
  prefs: []
  type: TYPE_NORMAL
- en: The `[n]` suffix tells HLA to duplicate the object `n` times. Now let's look
    at some specific examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'These examples all allocate storage for uninitialized arrays. You may also
    specify that the elements of the arrays be initialized using declarations like
    the following in the `static` and `readonly` sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: These definitions both create arrays with eight elements. The first definition
    initializes each 4-byte real value to 1.0, the second declaration initializes
    each `int32` element to 1\. Note that the number of constants within the square
    brackets must exactly match the size of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This initialization mechanism is fine if you want each element of the array
    to have the same value. What if you want to initialize each element of the array
    with a (possibly) different value? No sweat, just specify a different set of values
    in the list surrounded by the square brackets in the example above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 4.19 HLA Array Constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last few examples in the previous section demonstrate the use of HLA array
    constants. An HLA array constant is nothing more than a list of values surrounded
    by a pair of brackets. The following are all legal array constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: (Note that this last array constant contains four double-word pointers to the
    four HLA strings appearing elsewhere in memory.)
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in the previous section, you can use array constants in the `static`
    and `readonly` sections to provide initial values for array variables. The number
    of comma-separated items in an array constant must exactly match the number of
    array elements in the variable declaration. Likewise, the type of each of the
    array constant's elements must match the array variable's declared base type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using array constants to initialize small arrays is very convenient. Of course,
    if your array has several thousand elements, entering them will be tedious. Most
    arrays initialized this way have no more than a couple hundred entries and generally
    far less than 100\. It is reasonable to use an array constant to initialize such
    variables. However, at some point initializing arrays in this manner will become
    far too tedious and error prone. You probably would not want to manually initialize
    an array with 1,000 different elements using an array constant. However, if you
    want to initialize all the elements of an array with the same value, HLA does
    provide a special array constant syntax for doing so. Consider the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration creates a 1,000-element integer array initializing each element
    to one. The `1000 dup [ 1 ]` expression tells HLA to create an array constant
    by duplicating the single value `[ 1 ]` one thousand times. You can even use the
    `dup` operator to duplicate a series of values (rather than a single value), as
    the following example indicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: This example initializes `SixteenInts` with four copies of the sequence `1,2,3,4`,
    yielding a total of 16 different integers (i.e., 1, 2, 3, 4, 1, 2, 3, 4, 1, 2,
    3, 4, 1, 2, 3, 4).
  prefs: []
  type: TYPE_NORMAL
- en: You will see some more possibilities with the `dup` operator when looking at
    multidimensional arrays in [4.22 Multidimensional Arrays](ch04s22.html "4.22 Multidimensional
    Arrays").
  prefs: []
  type: TYPE_NORMAL
- en: 4.20 Accessing Elements of a Single-Dimensional Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To access an element of a zero-based array, you can use the simplified formula
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'For the *`Base_Address`* entry you can use the name of the array (because HLA
    associates the address of the first element of an array with the name of that
    array). The *`Element_Size`* entry is the number of bytes for each array element.
    If the object is an array of bytes, the *`Element_Size`* field is 1 (resulting
    in a very simple computation). If each element of the array is a word (or other
    2-byte type), then *`Element_Size`* is 2, and so on. To access an element of the
    `SixteenInts` array in the previous section, you''d use the following formula
    (the size is 4 because each element is an *`int32`* object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The 80x86 code equivalent to the statement `eax :=` *`SixteenInts`*`[`*`index`*`]`
    is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: There are two important things to notice here. First of all, this code uses
    the `shl` instruction rather than the `intmul` instruction to compute `4*index`.
    The main reason for choosing `shl` is that it was more efficient. It turns out
    that `shl` is a *lot* faster than `intmul` on many processors.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing to note about this instruction sequence is that it does not
    explicitly compute the sum of the base address plus the index times 4\. Instead,
    it relies on the indexed addressing mode to implicitly compute this sum. The instruction
    `mov( SixteenInts[ ebx ], eax );` loads EAX from location `SixteenInts + ebx`,
    which is the base address plus `index*4` (because EBX contains `index*4`). Sure,
    you could have used
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: in place of the previous sequence, but why use five instructions where three
    will do the same job? This is a good example of why you should know your addressing
    modes inside and out. Choosing the proper addressing mode can reduce the size
    of your program, thereby speeding it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, as long as we''re discussing efficiency improvements, it''s worth
    pointing out that the 80x86 scaled indexed addressing modes let you automatically
    multiply an index by 1, 2, 4, or 8\. Because this current example multiplies the
    index by 4, we can simplify the code even more by using the scaled indexed addressing
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Note, however, that if you need to multiply by some constant other than 1, 2,
    4 or 8, then you cannot use the scaled indexed addressing modes. Similarly, if
    you need to multiply by some element size that is not a power of 2, you will not
    be able to use the `shl` instruction to multiply the index by the element size;
    instead, you will have to use `intmul` or some other instruction sequence to do
    the multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: The indexed addressing mode on the 80x86 is a natural for accessing elements
    of a single-dimensional array. Indeed, its syntax even suggests an array access.
    The important thing to keep in mind is that you must remember to multiply the
    index by the size of an element. Failure to do so will produce incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: 4.21 Sorting an Array of Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every textbook on this planet gives an example of a sort when introducing
    arrays. Because you've probably seen how to do a sort in high-level languages
    already, it's probably instructive to take a quick look at a sort in HLA. The
    example code in this section will use a variant of the bubble sort, which is great
    for short lists of data and lists that are nearly sorted but horrible for just
    about everything else.^([[63](#ftn.CHP-4-FN-17)])
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The bubble sort works by comparing adjacent elements in an array. The interesting
    thing to note in this code fragment is how it compares adjacent elements. You
    will note that the `if` statement compares EAX (which contains `DataToSort[ebx*4]`)
    against `DataToSort[ebx*4 + 4]`. Because each element of this array is 4 bytes
    (`uns32`), the index `[ebx*4 + 4]` references the next element beyond `[ebx*4]`.
  prefs: []
  type: TYPE_NORMAL
- en: As is typical for a bubble sort, this algorithm terminates if the innermost
    loop completes without swapping any data. If the data is already presorted, then
    the bubble sort is very efficient, making only one pass over the data. Unfortunately,
    if the data is not sorted (worst case, if the data is sorted in reverse order),
    then this algorithm is extremely inefficient. Indeed, although it is possible
    to modify the code above so that, on the average, it runs about twice as fast,
    such optimizations are wasted on such a poor algorithm. However, the bubble sort
    is very easy to implement and understand (which is why introductory texts continue
    to use it in examples).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[63](#CHP-4-FN-17)]) Fear not, you'll see some better sorting algorithms
    in [Chapter 5](ch05.html "Chapter 5. PROCEDURES AND UNITS").
  prefs: []
  type: TYPE_NORMAL
- en: 4.22 Multidimensional Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The 80x86 hardware can easily handle single-dimensional arrays. Unfortunately,
    there is no magic addressing mode that lets you easily access elements of multidimensional
    arrays. That's going to take some work and several instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Before discussing how to declare or access multidimensional arrays, it would
    be a good idea to figure out how to implement them in memory. The first problem
    is to figure out how to store a multidimensional object into a one-dimensional
    memory space.
  prefs: []
  type: TYPE_NORMAL
- en: Consider for a moment a Pascal array of the form `A:array[0..3,0..3] of char;`.
    This array contains 16 bytes organized as four rows of four characters. Somehow
    you've got to draw a correspondence with each of the 16 bytes in this array and
    16 contiguous bytes in main memory. [Figure 4-5](ch04s22.html#mapping_a_4x4_array_to_sequential_memory
    "Figure 4-5. Mapping a 4x4 array to sequential memory locations") shows one way
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mapping a 4x4 array to sequential memory locations](tagoreillycom20100401nostarchimages577987.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5. Mapping a 4x4 array to sequential memory locations
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual mapping is not important as long as two things occur: (1) Each element
    maps to a unique memory location (that is, no two entries in the array occupy
    the same memory locations), and (2) the mapping is consistent. That is, a given
    element in the array always maps to the same memory location. So what you really
    need is a function with two input parameters (row and column) that produces an
    offset into a linear array of 16 memory locations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now any function that satisfies the above constraints will work fine. Indeed,
    you could randomly choose a mapping as long as it was consistent. However, what
    you really want is a mapping that is efficient to compute at runtime and works
    for any size array (not just 4x4 or even limited to two dimensions). While a large
    number of possible functions fit this bill, there are two functions in particular
    that most programmers and high-level languages use: *row-major ordering* and *column-major
    ordering*.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.22.1 Row-Major Ordering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Row-major ordering assigns successive elements, moving across the rows and then
    down the columns, to successive memory locations. This mapping is demonstrated
    in [Figure 4-6](ch04s22.html#row-major_array_element_ordering "Figure 4-6. Row-major
    array element ordering").
  prefs: []
  type: TYPE_NORMAL
- en: '![Row-major array element ordering](tagoreillycom20100401nostarchimages577989.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6. Row-major array element ordering
  prefs: []
  type: TYPE_NORMAL
- en: Row-major ordering is the method most high-level programming languages employ.
    It is very easy to implement and use in machine language. You start with the first
    row (row 0) and then concatenate the second row to its end. You then concatenate
    the third row to the end of the list, then the fourth row, and so on (see [Figure 4-7](ch04s22.html#another_view_of_row-major_ordering_for_a
    "Figure 4-7. Another view of row-major ordering for a 4×4 array")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Another view of row-major ordering for a 4×4 array](tagoreillycom20100401nostarchimages577991.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-7. Another view of row-major ordering for a 4×4 array
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual function that converts a list of index values into an offset is
    a slight modification of the formula for computing the address of an element of
    a single-dimensional array. The formula to compute the offset for a two-dimensional
    row-major ordered array is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, *`Base_Address`* is the address of the first element of the array
    (`A[0][0]` in this case), and *`Element_Size`* is the size of an individual element
    of the array, in bytes. *`colindex`* is the leftmost index, and *`rowindex`* is
    the rightmost index into the array. *`row_size`* is the number of elements in
    one row of the array (four, in this case, because each row has four elements).
    Assuming *`Element_Size`* is 1, this formula computes the following offsets from
    the base address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'For a three-dimensional array, the formula to compute the offset into memory
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '*`col_size`* is the number of items in a column, and `row_size` is the number
    of items in a row. In C/C++, if you''ve declared the array as *`type`* `A[i] [j]
    [k];`, then *`row_size`* is equal to `k` and *`col_size`* is equal to `j`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a four-dimensional array, declared in C/C++ as *`type`* `A[i] [j] [k] [m];`,
    the formula for computing the address of an array element is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '*`depth_size`* is equal to `j`, *`col_size`* is equal to `k`, and *`row_size`*
    is equal to `m`. *`LeftIndex`* represents the value of the leftmost index.'
  prefs: []
  type: TYPE_NORMAL
- en: By now you're probably beginning to see a pattern. There is a generic formula
    that will compute the offset into memory for an array with *any* number of dimensions;
    however, you'll rarely use more than four.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another convenient way to think of row-major arrays is as arrays of arrays.
    Consider the following single-dimensional Pascal array definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Assume that *`sometype`* is the type *`sometype`* `= array [0..3] of char;`.
  prefs: []
  type: TYPE_NORMAL
- en: '`A` is a single-dimensional array. Its individual elements happen to be arrays,
    but you can safely ignore that for the time being. The formula to compute the
    address of an element of a single-dimensional array is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: In this case *`Element_Size`* happens to be 4 because each element of *`A`*
    is an array of four characters. So what does this formula compute? It computes
    the base address of each row in this 4x4 array of characters (see [Figure 4-8](ch04s22.html#viewing_a_4x4_array_as_an_array_of_array
    "Figure 4-8. Viewing a 4x4 array as an array of arrays")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing a 4x4 array as an array of arrays](tagoreillycom20100401nostarchimages577993.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-8. Viewing a 4x4 array as an array of arrays
  prefs: []
  type: TYPE_NORMAL
- en: Of course, once you compute the base address of a row, you can reapply the single-dimensional
    formula to get the address of a particular element. While this doesn't affect
    the computation, it's probably a little easier to deal with several single-dimensional
    computations rather than a complex multidimensional array computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a Pascal array defined as `A:array [0..3] [0..3] [0..3] [0..3] [0..3]
    of char;`. You can view this five-dimensional array as a single-dimensional array
    of arrays. The following HLA code provides such a definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The size of `OneD` is 4 bytes. Because `TwoD` contains four `OneD` arrays,
    its size is 16 bytes. Likewise, `ThreeD` is four `TwoD`s, so it is 64 bytes long.
    Finally, `FourD` is four `ThreeDs`, so it is 256 bytes long. To compute the address
    of `A [b, c, d, e, f]`, you could use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute the address of `A [b]` as *`Base`* `+ b *` *`size`*. Here size is 256
    bytes. Use this result as the new base address in the next computation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute the address of `A [b, c]` by the formula *`Base`* `+ c *` *`size`*,
    where *`Base`* is the value obtained in the previous step and *`size`* is 64\.
    Use the result as the new base in the next computation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute the base address of `A [b, c, d]` by *`Base`* `+ d *` *`size`*, with
    *`Base`* coming from the previous computation and *`size`* is 16\. Use the result
    as the new base in the next computation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute the address of `A [b, c, d, e]` with the formula *`Base`* `+ e *` *`size`*,
    with *`Base`* from the previous step with a size of 4\. Use this value as the
    base for the next computation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, compute the address of `A [b, c, d, e, f]` using the formula *`Base`*
    `+ f *` *`size`*, where *`Base`* comes from the previous computation and *`size`*
    is 1 (obviously you can simply ignore this final multiplication). The result you
    obtain at this point is the address of the desired element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the main reasons you won't find higher-dimensional arrays in assembly
    language is that assembly language emphasizes the inefficiencies associated with
    such access. It's easy to enter something like `A [b, c, d, e, f]` into a Pascal
    program, not realizing what the compiler is doing with the code. Assembly language
    programmers are not so cavalier—they see the mess you wind up with when you use
    higher-dimensional arrays. Indeed, good assembly language programmers try to avoid
    two-dimensional arrays and often resort to tricks in order to access data in such
    an array when its use becomes absolutely mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 4.22.2 Column-Major Ordering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Column-major ordering is the other function high-level languages frequently
    used to compute the address of an array element. FORTRAN and various dialects
    of BASIC (e.g., older versions of Microsoft BASIC) use this method.
  prefs: []
  type: TYPE_NORMAL
- en: In row-major ordering the rightmost index increases the fastest as you move
    through consecutive memory locations. In column-major ordering the leftmost index
    increases the fastest. Pictorially, a column-major ordered array is organized
    as shown in [Figure 4-9](ch04s22.html#column-major_array_element_ordering "Figure 4-9. Column-major
    array element ordering").
  prefs: []
  type: TYPE_NORMAL
- en: '![Column-major array element ordering](tagoreillycom20100401nostarchimages577995.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-9. Column-major array element ordering
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula for computing the address of an array element when using column-major
    ordering is very similar to that for row-major ordering. You simply reverse the
    indexes and sizes in the computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 4.23 Allocating Storage for Multidimensional Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have an *`m`* x *`n`* array, it will have *`m`* * *`n`* elements and
    require *`m`* * *`n`* * *`Element_Size`* bytes of storage. To allocate storage
    for an array you must reserve this memory. As usual, there are several different
    ways of accomplishing this task. Fortunately, HLA''s array-declaration syntax
    is very similar to high-level language array-declaration syntax, so C/C++, Java,
    BASIC, and Pascal programmers will feel right at home. To declare a multidimensional
    array in HLA, you use a declaration like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, here is a declaration for a 4x4 array of characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example that shows how to declare a three-dimensional array
    of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Remember, string objects are really pointers, so this array declaration reserves
    storage for 18 double-word pointers (2 * 3 * 3 = 18).
  prefs: []
  type: TYPE_NORMAL
- en: 'As was the case with single-dimensional arrays, you may initialize every element
    of the array to a specific value by following the declaration with the assignment
    operator and an array constant. Array constants ignore dimension information;
    all that matters is that the number of elements in the array constant corresponds
    to the number of elements in the actual array. The following example shows the
    `GameGrid` declaration with an initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Note that HLA ignores the indentation and extra whitespace characters (e.g.,
    newlines) appearing in this declaration. It was laid out to enhance readability
    (which is always a good idea). HLA does not interpret the four separate lines
    as representing rows of data in the array. Humans do, which is why it's good to
    write the data in this manner. All that matters is that there are 16 (4 * 4) characters
    in the array constant. You'll probably agree that this is much easier to read
    than
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if you have a large array, an array with really large rows, or an
    array with many dimensions, there is little hope for winding up with something
    readable. That's when comments that carefully explain everything come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for single-dimensional arrays, you can use the `dup` operator to initialize
    each element of a large array with the same value. The following example initializes
    a 256x64 array of bytes so that each byte contains the value $FF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of a constant expression to compute the number of array elements
    rather than simply using the constant 16,384 (256 * 64). The use of the constant
    expression more clearly suggests that this code is initializing each element of
    a 256x64 element array than does the simple literal constant 16,384.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another HLA trick you can use to improve the readability of your programs is
    to use *nested array constants*. The following is an example of an HLA nested
    array constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever HLA encounters an array constant nested inside another array constant,
    it simply removes the brackets surrounding the nested array constant and treats
    the whole constant as a single-array constant. For example, HLA converts this
    nested array constant to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'You can take advantage of this fact to help make your programs a little more
    readable. For multidimensional array constants you can enclose each row of the
    constant in square brackets to denote that the data in each row is grouped and
    separate from the other rows. Consider the following declaration for the `GameGrid`
    array that is identical (as far as HLA is concerned) to the earlier declaration
    for `GameGrid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: This declaration makes it clearer that the array constant is a 4x4 array rather
    than just a 16-element one-dimensional array whose elements wouldn't fit all on
    one line of source code. Little aesthetic improvements like this are what separate
    mediocre programmers from good programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 4.24 Accessing Multidimensional Array Elements in Assembly Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, you've seen the formulas for computing the address of a multidimensional
    array element. Now it's time to see how to access elements of those arrays using
    assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: The `mov`, `shl`, and `intmul` instructions make short work of the various equations
    that compute offsets into multidimensional arrays. Let's consider a two-dimensional
    array first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Note that this code does *not* require the use of a two-register addressing
    mode on the 80x86\. Although an addressing mode like `TwoD[ebx][esi]` looks like
    it should be a natural for accessing two-dimensional arrays, that isn't the purpose
    of this addressing mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider a second example that uses a three-dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Note that this code uses the `intmul` instruction to multiply the value in EBX
    by 5\. Remember, the `shl` instruction can only multiply a register by a power
    of 2\. While there are ways to multiply the value in a register by a constant
    other than a power of 2, the `intmul` instruction is more convenient.^([[64](#ftn.CHP-4-FN-18)])
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[64](#CHP-4-FN-18)]) A full discussion of multiplication by constants other
    than a power of 2 appears in [Chapter 4](ch04.html "Chapter 4. CONSTANTS, VARIABLES,
    AND DATA TYPES").
  prefs: []
  type: TYPE_NORMAL
- en: 4.25 Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another major composite data structure is the Pascal record or C/C++/C# structure.^([[65](#ftn.CHP-4-FN-19)])
    The Pascal terminology is probably better, because it tends to avoid confusion
    with the more general term *data structure*. Because HLA uses the term *record*,
    we'll adopt that term here.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas an array is homogeneous, whose elements are all the same type, the elements
    in a record can have different types. Arrays let you select a particular element
    via an integer index. With records, you must select an element (known as a *field*)
    by name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole purpose of a record is to let you encapsulate different, though logically
    related, data into a single package. The Pascal record declaration for a student
    is a typical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Most Pascal compilers allocate each field in a record to contiguous memory locations.
    This means that Pascal will reserve the first 65 bytes for the name,^([[66](#ftn.CHP-4-FN-20)])
    the next 2 bytes hold the major code, the next 12 bytes hold the Social Security
    number, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In HLA, you can also create record types using the `record`/`endrecord` declaration.
    You would encode the above record in HLA as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the HLA declaration is very similar to the Pascal declaration.
    Note that, to be true to the Pascal declaration, this example uses character arrays
    rather than strings for the `Name` and `SSN` (US Social Security number) fields.
    In a real HLA record declaration you'd probably use a string type for at least
    the name (keeping in mind that a string variable is only a 4-byte pointer).
  prefs: []
  type: TYPE_NORMAL
- en: The field names within the record must be unique. That is, the same name may
    not appear two or more times in the same record. However, all field names are
    local to that record. Therefore, you may reuse those field names elsewhere in
    the program or in different records.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `record`/`endrecord` declaration may appear in a variable declaration section
    (e.g., `static` or `var`) or in a `type` declaration section. In the previous
    example the `Student` declaration appears in the `type` section, so this does
    not actually allocate any storage for a `Student` variable. Instead, you have
    to explicitly declare a variable of type `Student`. The following example demonstrates
    how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: This allocates 81 bytes of storage laid out in memory as shown in [Figure 4-10](ch04s25.html#student_data_structure_storage_in_memory
    "Figure 4-10. Student data structure storage in memory").
  prefs: []
  type: TYPE_NORMAL
- en: '![Student data structure storage in memory](tagoreillycom20100401nostarchimages577997.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-10. Student data structure storage in memory
  prefs: []
  type: TYPE_NORMAL
- en: If the label `John` corresponds to the *base address* of this record, then the
    `Name` field is at offset `John+0`, the `Major` field is at offset `John+65`,
    the `SSN` field is at offset `John+67`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To access an element of a structure, you need to know the offset from the beginning
    of the structure to the desired field. For example, the `Major` field in the variable
    `John` is at offset 65 from the base address of `John`. Therefore, you could store
    the value in AX into this field using the instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, memorizing all the offsets to fields in a record defeats the
    whole purpose of using them in the first place. After all, if you have to deal
    with these numeric offsets, why not just use an array of bytes instead of a record?
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, HLA lets you refer to field names in a record using the same mechanism
    C/C++/C# and Pascal use: the dot operator. To store AX into the `Major` field,
    you could use `mov( ax, John.Major );` instead of the previous instruction. This
    is much more readable and certainly easier to use.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the use of the dot operator does *not* introduce a new addressing
    mode. The instruction `mov( ax, John.Major );` still uses the displacement-only
    addressing mode. HLA simply adds the base address of `John` with the offset to
    the `Major` field (65) to get the actual displacement to encode into the instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like any type declaration, HLA requires all record type declarations to appear
    in the program before you use them. However, you don''t have to define all records
    in the `type` section to create record variables. You can use the `record`/`endrecord`
    declaration directly in a variable declaration section. This is convenient if
    you have only one instance of a given record object in your program. The following
    example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[65](#CHP-4-FN-19)]) It also goes by some other names in other languages,
    but most people recognize at least one of these names.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[66](#CHP-4-FN-20)]) Strings require an extra byte, in addition to all the
    characters in the string, to encode the length.
  prefs: []
  type: TYPE_NORMAL
- en: 4.26 Record Constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HLA lets you define record constants. In fact, HLA supports both manifest (symbolic)
    record constants and literal record constants. Record constants are useful as
    initializers for static record variables. They are also quite useful as compile-time
    data structures when using the HLA compile-time language (see the HLA reference
    manual for more details on the HLA compile-time language). This section discusses
    how to create record constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'A literal record constant takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: The *`RecordTypeName`* is the name of a record data type you've defined in an
    HLA `type` section prior to using the constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constant list appearing between the brackets is the data for each of the
    fields in the specified record. The first item in the list corresponds to the
    first field of the record, the second item in the list corresponds to the second
    field, and so on. The data types of each of the constants appearing in this list
    must match their respective field types. The following example demonstrates how
    to use a literal record constant to initialize a record variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: This declaration initializes `Vector.x` with 1, `Vector.y` with −2, and `Vector.z`
    with 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create manifest record constants by declaring record objects in
    the `const` or `val` sections of your program. You access fields of these symbolic
    record constants just as you would access the field of a record variable, using
    the dot operator. Because the object is a constant, you can specify the field
    of a record constant anywhere a constant of that field''s type is legal. You can
    also employ symbolic record constants as variable initializers. The following
    example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 4.27 Arrays of Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is a perfectly reasonable operation to create an array of records. To do
    so, you simply create a record type and then use the standard array declaration
    syntax. The following example demonstrates how you could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'To access an element of this array you use the standard array indexing techniques.
    Because *`recArray`* is a single-dimensional array, you''d compute the address
    of an element of this array using the formula *`baseAddress`* `+` *`index`*`*@size(`
    *`recElement`* `)`. For example, to access an element of *`recArray`* you''d use
    code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Note that the index specification follows the entire variable name; remember,
    this is assembly, not a high-level language (in a high-level language you'd probably
    use *`recArray`*`[i].`*`someField`*).
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, you can create multidimensional arrays of records as well. You would
    use the row-major or column-major order functions to compute the address of an
    element within such records. The only thing that really changes (from the discussion
    of arrays) is that the size of each element is the size of the record object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 4.28 Arrays/Records as Record Fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Records may contain other records or arrays as fields. Consider the following
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition above defines a single point with a 32-bit color component.
    When initializing an object of type `Pixel`, the first initializer corresponds
    to the `Pt` field, *not the* *`x-coordinate`* *field*. The following definition
    is incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the first field (5) is not an object of type `point`. Therefore,
    the assembler generates an error when encountering this statement. HLA will allow
    you to initialize the fields of `Pixel` using declarations like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing `Pixel` fields is very easy. As in a high-level language, you use
    a single period to reference the `Pt` field and a second period to access the
    `x`, `y`, and `z` fields of `point`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also declare arrays as record fields. The following record creates
    a data type capable of representing an object with eight points (for example,
    a cube):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'This record allocates storage for eight different points. Accessing an element
    of the `Pts` array requires that you know the size of an object of type `point`
    (remember, you must multiply the index into the array by the size of one element,
    12 in this particular case). Suppose, for example, that you have a variable `Cube`
    of type `Object8`. You could access elements of the `Pts` array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'The one unfortunate aspect of all this is that you must know the size of each
    element of the `Pts` array. Fortunately, you can rewrite the code above using
    `@size` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Note in this example that the index specification (`[ebx]`) follows the whole
    object name even though the array is `Pts`, not `x`. Remember, the `[ebx]` specification
    is an indexed addressing mode, not an array index. Indexes always follow the entire
    name, so you do not attach them to the array component as you would in a high-level
    language like C/C++ or Pascal. This produces the correct result because addition
    is commutative, and the dot operator (as well as the index operator) corresponds
    to addition. In particular, the expression `Cube.Pts.x[ebx]` tells HLA to compute
    the sum of `Cube` (the base address of the object) plus the offset to the `Pts`
    field, plus the offset to the `x` field, plus the value of EBX. Technically, we're
    really computing offset(`Cube`) + offset(`Pts`) + EBX + offset(`x`), but we can
    rearrange this because addition is commutative.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also define two-dimensional arrays within a record. Accessing elements
    of such arrays is no different than accessing any other two-dimensional array
    other than the fact that you must specify the array''s field name as the base
    address for the array. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: The code above uses the standard row-major calculation to index into a 4x5 array
    of double words. The only difference between this example and a standalone array
    access is the fact that the base address is `recVar.aField`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two common ways to nest record definitions. As this section notes,
    you can create a record type in a `type` section and then use that type name as
    the data type of some field within a record (e.g., the `Pt:point` field in the
    `Pixel` data type above). It is also possible to declare a record directly within
    another record without creating a separate data type for that record; the following
    example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Generally, it's a better idea to create a separate type rather than embed records
    directly in other records, but nesting them is perfectly legal.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an array of records and one of the fields of that record type is
    an array, you must compute the indexes into the arrays independently of one another
    and then use the sum of these indexes as the ultimate index. The following example
    demonstrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the base plus scaled indexed addressing mode to simplify this
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 4.29 Aligning Fields Within a Record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To achieve maximum performance in your programs, or to ensure that HLA''s records
    properly map to records or structures in some high-level language, you will often
    need to be able to control the alignment of fields within a record. For example,
    you might want to ensure that a double-word field''s offset is an even multiple
    of 4\. You use the `align` directive to do this. The following example shows how
    to align some fields on important boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever HLA encounters the `align` directive within a record declaration,
    it automatically adjusts the following field''s offset so that it is an even multiple
    of the value the `align` directive specifies. It accomplishes this by increasing
    the offset of that field, if necessary. In the example above, the fields would
    have the following offsets: `c:0`, `d:4`, `b:8`, `w:10`. Note that HLA inserts
    3 bytes of padding between `c` and `d`, and it inserts 1 byte of padding between
    `b` and `w`. It goes without saying that you should never assume that this padding
    is present. If you want to use those extra bytes, then you must declare fields
    for them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that specifying alignment within a record declaration does not guarantee
    that the field will be aligned on that boundary in memory; it only ensures that
    the field''s offset is a multiple of the value you specify. If a variable of type
    `PaddedRecord` starts at an odd address in memory, then the `d` field will also
    start at an odd address (because any odd address plus 4 is an odd address). If
    you want to ensure that the fields are aligned on appropriate boundaries in memory,
    you must also use the `align` directive before variable declarations of that record
    type. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: The value of the `align` operand should be an even value that is divisible by
    the largest `align` expression within the record type (4 is the largest value
    in this case, and it's already divisible by 2).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to ensure that the record''s size is a multiple of some value,
    then simply stick an `align` directive as the last item in the record declaration.
    HLA will emit an appropriate number of bytes of padding at the end of the record
    to fill it in to the appropriate size. The following example demonstrates how
    to ensure that the record''s size is a multiple of 4 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: HLA provides some additional alignment directives for records that let you easily
    control the alignment of all fields within a record and the starting offset of
    the fields in a record. If you're interested in more information, please consult
    the HLA reference manual.
  prefs: []
  type: TYPE_NORMAL
- en: 4.30 Pointers to Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During execution, your program may refer to record objects indirectly using
    a pointer. When you use a pointer to access fields of a structure, you must load
    one of the 80x86''s 32-bit registers with the address of the desired record. Suppose
    you have the following variable declarations (assuming the `Object8` structure
    from an earlier section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '`CubePtr` contains the address of (that is, it is a pointer to) the `Cube`
    object. To access the `Color` field of the `Cube` object, you could use an instruction
    like `mov( Cube.Color, eax );`. When accessing a field via a pointer, you first
    need to load the address of the object into a 32-bit register such as EBX. The
    instruction `mov( CubePtr, ebx );` will do the trick. After doing so, you can
    access fields of the `Cube` object using the `[ebx+offset]` addressing mode. The
    only problem is, "How do you specify which field to access?" Consider briefly
    the following *incorrect* code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Because field names are local to a structure and it's possible to reuse a field
    name in two or more structures, how does HLA determine which offset `Color` represents?
    When accessing structure members directly (e.g., `mov( Cube.Color, eax )`;), there
    is no ambiguity because `Cube` has a specific type that the assembler can check.
    `[ebx]`, on the other hand, can point at *anything*. In particular, it can point
    at any structure that contains a `Color` field. So the assembler cannot, on its
    own, decide which offset to use for the `Color` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA resolves this ambiguity by requiring that you explicitly supply a type.
    To do this, you must coerce `[ebx]` to type `Cube`. Once you do this, you can
    use the normal dot operator notation to access the `Color` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a pointer to a record and one of that record''s fields is an array,
    the easiest way to access elements of that field is by using the base-plus-indexed
    addressing mode. To do so, you just load the pointer''s value into one register
    and compute the index into the array in a second register. Then you combine these
    two registers in the address expression. In the example above, the `Pts` field
    is an array of eight `point` objects. To access field `x` of the `i`th element
    of the `Cube.Pts` field, you''d use code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use a pointer to a particular record type frequently in your program,
    typing a coercion operator like `(type Object8 [ebx])` can get old very quickly.
    One way to reduce the typing needed to coerce EBX is to use a `text` constant.
    Consider the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'With this statement at the beginning of your program, you can use `O8ptr` in
    place of the type coercion operator, and HLA will automatically substitute the
    appropriate text. With a text constant like the above, the former example becomes
    a little more readable and writable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 4.31 Unions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A record definition assigns different offsets to each field in the record according
    to the size of those fields. This behavior is quite similar to the allocation
    of memory offsets in a `var` or `static` section. HLA provides a second type of
    structure declaration, the `union`, that does not assign different addresses to
    each object; instead, each field in a `union` declaration has the same offset—0\.
    The following example demonstrates the syntax for a `union` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'You access the fields of a `union` exactly the same way you access the fields
    of a record: using dot notation and field names. The following is a concrete example
    of a `union` type declaration and a variable of the `union` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'The important thing to note about `union` objects is that all the fields of
    a `union` have the same offset in the structure. In the example above, the `number.u`,
    `number.i`, and `number.r` fields all have the same offset: 0\. Therefore, the
    fields of a `union` overlap in memory; this is very similar to the way the 80x86
    8-, 16-, and 32-bit registers overlap one another. Usually, you may access only
    one field of a `union` at a time; that is, you do not manipulate separate fields
    of a particular `union` variable concurrently because writing to one field overwrites
    the other fields. In the example above, any modification of `number.u` would also
    change `number.i` and `number.r`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmers typically use unions for two different reasons: to conserve memory
    or to create aliases. Memory conservation is the intended use of this data structure
    facility. To see how this works, let''s compare the `numeric union` above with
    a corresponding record type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: If you declare a variable, say `n`, of type `numericRec`, you access the fields
    as `n.i`, `n.u`, and `n.r` exactly as though you had declared the variable to
    be type `numeric`. The difference between the two is that `numericRec` variables
    allocate separate storage for each field of the record, whereas `numeric` (union)
    objects allocate the same storage for all fields. Therefore, `@size(numericRec)`
    is 16 because the record contains two double-word fields and a quad word (`real64`)
    field. `@size(numeric)`, however, is 8\. This is because all the fields of a `union`
    occupy the same memory locations, and the size of a `union` object is the size
    of the largest field of that object (see [Figure 4-11](ch04s31.html#layout_of_a_union_versus_a_record_variab
    "Figure 4-11. Layout of a union versus a record variable")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Layout of a union versus a record variable](tagoreillycom20100401nostarchimages577999.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-11. Layout of a `union` versus a `record` variable
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to conserving memory, programmers often use unions to create aliases
    in their code. As you may recall, an alias is a different name for the same memory
    object. Aliases are often a source of confusion in a program, so you should use
    them sparingly; sometimes, however, using an alias can be quite convenient. For
    example, in some section of your program you might need to constantly use type
    coercion to refer to an object using a different type. Although you can use an
    HLA `text` constant to simplify this process, another way to do this is to use
    a `union` variable with the fields representing the different types you want to
    use for the object. As an example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: With a declaration like the above, you can manipulate an `uns32` object by accessing
    `v.u`. If, at some point, you need to treat the L.O. byte of this `uns32` variable
    as a character, you can do so by simply accessing the `v.c` variable, for example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: You can use unions exactly the same way you use records in an HLA program. In
    particular, `union` declarations may appear as fields in records, `record` declarations
    may appear as fields in unions, array declarations may appear within unions, you
    can create arrays of unions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 4.32 Anonymous Unions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within a `record` declaration you can place a `union` declaration without specifying
    a fieldname for the `union` object. The following example demonstrates the syntax
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever an anonymous union appears within a `record` you can access the fields
    of the `union` as though they were direct fields of the `record`. In the example
    above, for example, you would access `v`''s `u` and `i` fields using the syntax
    `v.u` and `v.i`, respectively. The `u` and `i` fields have the same offset in
    the record (8, because they follow a `real64` object). The fields of `v` have
    the following offsets from `v`''s base address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '`@size(v)` is 16 because the `u` and `i` fields consume only 4 bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: HLA also allows anonymous records within unions. Please see the HLA documentation
    for more details, though the syntax and usage are identical to anonymous unions
    within records.
  prefs: []
  type: TYPE_NORMAL
- en: 4.33 Variant Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One big use of unions in programs is to create *variant* types. A variant variable
    can change its type dynamically while the program is running. A variant object
    can be an integer at one point in the program, switch to a string at a different
    part of the program, and then change to a real value at a later time. Many very-high-level
    language (VHLL) systems use a dynamic type system (that is, variant objects) to
    reduce the overall complexity of the program; indeed, proponents of many VHLLs
    insist that the use of a dynamic typing system is one of the reasons you can write
    complex programs with so few lines of code using those languages. Of course, if
    you can create variant objects in a VHLL, you can certainly do it in assembly
    language. In this section we'll look at how we can use the `union` structure to
    create variant types.
  prefs: []
  type: TYPE_NORMAL
- en: 'At any one given instant during program execution, a variant object has a specific
    type, but under program control the variable can switch to a different type. Therefore,
    when the program processes a variant object, it must use an `if` statement or
    `switch` statement (or something similar) to execute different instructions based
    on the object''s current type. Very-high-level languages do this transparently.
    In assembly language you will have to provide the code to test the type yourself.
    To achieve this, the variant type needs some additional information beyond the
    object''s value. Specifically, the variant object needs a field that specifies
    the current type of the object. This field (often known as the `tag` field) is
    an enumerated type or integer that specifies the object''s type at any given instant.
    The following code demonstrates how to create a variant type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: The program would test the `v.tag` field to determine the current type of the
    `v` object. Based on this test, the program would manipulate the `v.i`, `v.u`,
    or `v.r` field.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, when operating on variant objects, the program's code must constantly
    be testing the `tag` field and executing a separate sequence of instructions for
    `uns32`, `int32`, or `real64` values. If you use the variant fields often, it
    makes a lot of sense to write procedures to handle these operations for you (e.g.,
    *`vadd`*, *`vsub`*, *`vmul`*, and *`vdiv`*).
  prefs: []
  type: TYPE_NORMAL
- en: 4.34 Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One really nice feature of records and unions is that the field names are local
    to a given `record` or `union` declaration. That is, you can reuse field names
    in different records or unions. This is an important feature of HLA because it
    helps avoid *namespace pollution*. Namespace pollution occurs when you use up
    all the "good" names within your program and you have to start creating nondescriptive
    names for objects because you've already used the most appropriate name for something
    else. We use the term *namespace* to describe how HLA associates names with a
    particular object. The field names of a `record` have a namespace that is limited
    to objects of that record type. HLA provides a generalization of this namespace
    mechanism that lets you create arbitrary namespaces. These namespace objects let
    you shield the names of constants, types, variables, and other objects so their
    names do not interfere with other declarations in your program.
  prefs: []
  type: TYPE_NORMAL
- en: 'An HLA `namespace` section encapsulates a set of generic declarations in much
    the same way that a `record` encapsulates a set of variable declarations. A `namespace`
    declaration takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: The *`name`* identifier provides the name for the `namespace`. The identifier
    after the `end` clause must exactly match the identifier after `namespace`. Note
    that a `namespace` declaration section is a section unto itself. It does not have
    to appear in a `type` or `var` section. A `namespace` may appear anywhere one
    of the HLA declaration sections is legal. A program may contain any number of
    `namespace` declarations; in fact, the namespace identifiers don't even have to
    be unique, as you will soon see.
  prefs: []
  type: TYPE_NORMAL
- en: 'The declarations that appear between the `namespace` and `end` clauses are
    all the standard HLA declaration sections except that you cannot nest `namespace`
    declarations. You may, however, put `const`, `val`, `type`, `static`, `readonly`,
    and `storage` sections within a `namespace`.^([[67](#ftn.CHP-4-FN-21)]) The following
    code provides an example of a typical `namespace` declaration in an HLA program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the fields of a namespace you use the same dot notation that records
    and unions use. For example, to access the fields of `myNames` outside of the
    namespace, you''d use the following identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'This example also demonstrates an important point about `namespace` declarations:
    Within a namespace you may reference other identifiers in that same `namespace`
    declaration without using the dot notation. For example, the `i` field above uses
    type `integer` from the `myNames` namespace without the `mynames`. prefix.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What is not obvious from the example above is that `namespace` declarations
    create a clean symbol table whenever you open up a namespace. The only external
    symbols that HLA recognizes in a `namespace` declaration are the predefined type
    identifiers (e.g., `int32`, `uns32`, and `char`). HLA does not recognize any symbols
    you''ve declared outside the namespace while it is processing your `namespace`
    declaration. This creates a problem if you want to use symbols from outside the
    namespace when declaring other symbols inside the namespace. For example, suppose
    the type `integer` had been defined outside `myNames` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to attempt to compile this code, HLA would complain that the symbol
    `integer` is undefined. Clearly `integer` is defined in this program, but HLA
    hides all external symbols when creating a namespace so that you can reuse (and
    redefine) those symbols within the namespace. Of course, this doesn''t help much
    if you actually want to use a name that you''ve defined outside `myNames` within
    that namespace. HLA provides a solution to this problem: the `@global:` operator.
    If, within a `namespace` declaration section, you prefix a name with `@global:`,
    then HLA will use the global definition of that name rather than the local definition
    (if a local definition even exists). To correct the problem in the previous example,
    you''d use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: With the `@global:` prefix, the `i` variable will be type `int32` even if a
    different declaration of `integer` appears within the `myNames` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot nest `namespace` declarations. Logically, there doesn't seem to be
    any need for this, hence its omission from the HLA language.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have multiple `namespace` declarations in the same program that use
    the same namespace identifier. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: When HLA encounters a second `namespace` declaration for a given identifier,
    it simply appends the declarations in the second group to the end of the symbol
    list it created for the first group. Therefore, after processing the two `namespace`
    declarations, the `ns` namespace would contain the set of all symbols you've declared
    in both `namespace` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most common use of namespaces is in library modules. If you create
    a set of library routines to use in various projects or distribute to others,
    you have to be careful about the names you choose for your functions and other
    objects. If you use common names like `get` and `put`, the users of your module
    will complain when your names collide with theirs. An easy solution is to put
    all your code in a `namespace` block. Then the only name you have to worry about
    is the `namespace` identifier itself. This is the only name that will collide
    with other users' identifiers. This can happen, but it's much less likely to happen
    than if you don't use a namespace and your library module introduces dozens, if
    not hundreds, of new names into the global namespace.^([[68](#ftn.CHP-4-FN-22)])
    The HLA Standard Library provides many good examples of namespaces in use. The
    HLA Standard Library defines several namespaces like `stdout`, `stdin`, `str`,
    `cs`, and `chars`. You refer to functions in these namespaces using names like
    `stdout.put`, `stdin.get`, `cs.intersection`, `str.eq`, and `chars.toUpper`. The
    use of namespaces in the HLA Standard Library prevents conflicts with similar
    names in your own programs.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[67](#CHP-4-FN-21)]) Procedure declarations, the subject of [Chapter 5](ch05.html
    "Chapter 5. PROCEDURES AND UNITS"), are also legal within a `namespace` declaration
    section.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[68](#CHP-4-FN-22)]) The global namespace is the global section of your program.
  prefs: []
  type: TYPE_NORMAL
- en: 4.35 Dynamic Arrays in Assembly Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One problem with arrays as this chapter describes them is that their size is
    static. That is, the number of elements in all of the examples was chosen when
    writing the program; it was not selected while the program runs (that is, dynamically).
    Alas, sometimes you simply don't know how big an array needs to be when you're
    writing the program; you can only determine the size of the array while the program
    is running. This section describes how to allocate storage for arrays dynamically
    so you can set their size at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Allocating storage for a single-dimensional array, and accessing elements of
    that array, is a nearly trivial task at runtime. All you need to do is call the
    HLA Standard Library `mem.alloc` routine, specifying the size of the array in
    bytes. `mem.alloc` will return a pointer to the base address of the new array
    in the EAX register. Typically, you would save this address in a pointer variable
    and use that value as the base address of the array in all future array accesses.
  prefs: []
  type: TYPE_NORMAL
- en: To access an element of a single-dimensional dynamic array, you would generally
    load the base address into a register and compute the index in a second register.
    Then you could use the base-indexed addressing mode to access elements of that
    array. This is not a whole lot more work than accessing elements of a statically
    allocated array. The following code fragment demonstrates how to allocate and
    access elements of a single-dimensional dynamic array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Dynamically allocating storage for a multidimensional array is fairly straightforward.
    The number of elements in a multidimensional array is the product of all the dimension
    values; for example, a 4x5 array has 20 elements. So if you get the bounds for
    each dimension from the user, all you need to do is compute the product of all
    of these bound values and multiply the result by the size of a single element.
    This computes the total number of bytes in the array, the value that `mem.alloc`
    expects.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing elements of multidimensional arrays is a little more problematic.
    The problem is that you need to keep the dimension information (that is, the bounds
    on each dimension) around because these values are needed when computing the row-major
    (or column-major) index into the array.^([[69](#ftn.CHP-4-FN-23)]) The conventional
    solution is to store these bounds into a static array (generally you know the
    *arity*, or number of dimensions, at compile time, so it is possible to statically
    allocate storage for this array of dimension bounds). This array of dynamic array
    bounds is known as a *dope vector*. The following code fragment shows how to allocate
    storage for a two-dimensional dynamic array using a simple dope vector.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[69](#CHP-4-FN-23)]) Technically, you don't need the value of the leftmost
    dimension bound to compute an index into the array; however, if you want to check
    the index bounds using the `bound` instruction (or some other technique), you
    will need this value around at runtime as well.
  prefs: []
  type: TYPE_NORMAL
- en: 4.36 For More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the electronic edition of this book, which you'll find at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/), you will find additional
    information about data types. The HLA Standard Library documentation describes
    the HLA arrays package that provides support for dynamically allocated (and statically
    allocated) arrays, indexing into arrays, and many other array options. You should
    consult the HLA stdlib documentation for more details about this array package.
    For additional information about data structure representation in memory, you
    should consider reading my book *Write Great Code, Volume 1* (No Starch Press,
    2004). For an in-depth discussion of data types, you should consult a textbook
    on data structures and algorithms.
  prefs: []
  type: TYPE_NORMAL
