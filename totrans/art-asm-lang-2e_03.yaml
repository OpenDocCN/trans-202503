- en: Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 常量、变量和数据类型
- en: '![CONSTANTS, VARIABLES, AND DATA TYPES](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![常量、变量和数据类型](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: '[Chapter 2](ch02.html "Chapter 2. DATA REPRESENTATION") discussed the basic
    format for data in memory. [Chapter 3](ch03.html "Chapter 3. MEMORY ACCESS AND
    ORGANIZATION") covered how a computer system physically organizes that data in
    memory. This chapter finishes the discussion by connecting the concept of *data
    representation* to its actual physical representation. As the title implies, this
    chapter concerns itself with three main topics: constants, variables, and data
    structures. This chapter does not assume that you''ve had a formal course in data
    structures, though such experience would be useful.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html "第2章 数据表示")讨论了内存中数据的基本格式。[第3章](ch03.html "第3章 内存访问与组织")介绍了计算机系统如何在物理上组织这些数据。本章通过将
    *数据表示* 与其实际物理表示连接起来，完成了讨论。正如标题所示，本章主要涉及三个主题：常量、变量和数据结构。本章并不假设你已经接受过正式的数据结构课程，尽管这样的经验会有所帮助。'
- en: This chapter discusses how to declare and use constants, scalar variables, integers,
    data types, pointers, arrays, records/structures, unions, and namespaces. You
    must master these subjects before going on to the next chapter. Declaring and
    accessing arrays, in particular, seems to present a multitude of problems to beginning
    assembly language programmers. However, the rest of this text depends on your
    understanding of these data structures and their memory representation. Do not
    try to skim over this material with the expectation that you will pick it up as
    you need it later. You will need it right away, and trying to learn this material
    along with later material will only confuse you more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论如何声明和使用常量、标量变量、整数、数据类型、指针、数组、记录/结构体、联合体和命名空间。在进入下一章之前，必须掌握这些内容。特别是声明和访问数组似乎给初学汇编语言的程序员带来了很多问题。然而，本文的其余部分依赖于你对这些数据结构及其内存表示的理解。不要抱有以后慢慢学到这些内容的期望，试图跳过这些材料会让你感到困惑。你马上就会用到这些内容，试图与后续的内容一起学习只会增加困惑。
- en: '4.1 Some Additional Instructions: intmul, bound, into'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 一些额外的指令：intmul、bound、into
- en: This chapter introduces arrays and other concepts that will require the expansion
    of your 80x86 instruction set knowledge. In particular, you will need to learn
    how to multiply two values; hence the first instruction we will look at is the
    `intmul` (integer multiply) instruction. Another common task when accessing arrays
    is to check to see if an array index is within bounds. The 80x86 `bound` instruction
    provides a convenient way to check a register's value to see if it is within some
    range. Finally, the `into` (interrupt on overflow) instruction provides a quick
    check for signed arithmetic overflow. Although `into` isn't really necessary for
    array (or other data type) access, its function is very similar to `bound`; hence
    the presentation of it at this point.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了数组和其他需要扩展你对 80x86 指令集知识的概念。特别是，你需要学习如何将两个值相乘；因此我们首先要介绍的是 `intmul`（整数乘法）指令。另一个在访问数组时常见的任务是检查数组索引是否在范围内。80x86
    的 `bound` 指令提供了一种方便的方式，检查寄存器的值是否在某个范围内。最后，`into`（溢出时中断）指令提供了一种快速检查有符号算术溢出的方法。虽然在数组（或其他数据类型）访问中并不一定需要
    `into`，但它的功能与 `bound` 非常相似，因此在这一点上介绍它。
- en: 'The `intmul` instruction takes one of the following forms:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`intmul` 指令有以下几种形式：'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the syntax of the `intmul` instruction is different from that of the
    `add` and `sub` instructions. In particular, the destination operand must be a
    register (`add` and `sub` both allow a memory operand as a destination). Also
    note that `intmul` allows three operands when the first operand is a constant.
    Another important difference is that the `intmul` instruction allows only 16-bit
    and 32-bit operands; it does not multiply 8-bit operands.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`intmul` 指令的语法与 `add` 和 `sub` 指令不同。特别是，目标操作数必须是寄存器（`add` 和 `sub` 都允许内存操作数作为目标）。还要注意，当第一个操作数是常量时，`intmul`
    允许三个操作数。另一个重要的区别是，`intmul` 指令仅允许 16 位和 32 位操作数；它不支持 8 位操作数的乘法。
- en: intmul computes the product of its specified operands and stores the result
    into the destination register. If an overflow occurs (which is always a signed
    overflow, because `intmul` multiplies only signed integer values), then this instruction
    sets both the carry and overflow flags. `intmul` leaves the other condition code
    flags undefined (so, for example, you cannot meaningfully check the sign flag
    or the zero flag after executing `intmul`).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`intmul` 计算指定操作数的乘积并将结果存储到目标寄存器中。如果发生溢出（这总是一个有符号溢出，因为 `intmul` 仅乘以有符号整数值），那么此指令会设置进位标志和溢出标志。`intmul`
    会使其他条件码标志未定义（例如，执行 `intmul` 后你不能有意义地检查符号标志或零标志）。'
- en: 'The `bound` instruction checks a 16-bit or 32-bit register to see if it is
    between two values. If the value is outside this range, the program raises an
    exception and aborts. This instruction is particularly useful for checking to
    see if an array index is within a given range. The `bound` instruction takes one
    of the following forms:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`bound` 指令检查 16 位或 32 位寄存器，查看它是否在两个值之间。如果该值超出此范围，程序会引发异常并中止。此指令特别适用于检查数组索引是否在给定范围内。`bound`
    指令有以下几种形式：'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `bound` instruction compares its register operand against an unsigned lower
    bound value and an unsigned upper bound value to ensure that the register is in
    the range:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`bound` 指令将其寄存器操作数与无符号下界值和无符号上界值进行比较，以确保寄存器的值在范围内：'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The form of the `bound` instruction with three operands compares the register
    against the second and third parameters (the lower bound and upper bound, respectively).^([[47](#ftn.CHP-4-FN-1)])
    The `bound` instruction with two operands checks the register against one of the
    following ranges:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 带有三个操作数的 `bound` 指令将寄存器与第二和第三个参数（分别是下界和上界）进行比较。^([[47](#ftn.CHP-4-FN-1)]) 带有两个操作数的
    `bound` 指令将寄存器与以下一个范围进行比较：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the specified register is not within the given range, then the 80x86 raises
    an exception. You can trap this exception using the HLA `try..endtry` exception-handling
    statement. The *excepts.hhf* header file defines an exception, `ex.BoundInstr`,
    specifically for this purpose. The program in [Example 4-1](ch04.html#demonstration_of_the_bound_instruction
    "Example 4-1. Demonstration of the bound instruction") demonstrates how to use
    the `bound` instruction to check some user input.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的寄存器不在给定范围内，则 80x86 会引发异常。你可以使用 HLA 的 `try..endtry` 异常处理语句捕获此异常。*excepts.hhf*
    头文件为此目的定义了一个异常 `ex.BoundInstr`。[示例 4-1](ch04.html#demonstration_of_the_bound_instruction
    "示例 4-1. `bound` 指令的演示") 程序展示了如何使用 `bound` 指令检查某些用户输入。
- en: Example 4-1. Demonstration of the `bound` instruction
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-1. `bound` 指令的演示
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `into` instruction, like `bound`, also generates an exception under certain
    conditions. Specifically, `into` generates an exception if the overflow flag is
    set. Normally, you would use `into` immediately after a signed arithmetic operation
    (e.g., `intmul`) to see if an overflow occurs. If the overflow flag is not set,
    the system ignores `into`; however, if the overflow flag is set, then the `into`
    instruction raises the `ex.IntoInstr` exception. The program in [Example 4-2](ch04.html#demonstration_of_the_into_instruction
    "Example 4-2. Demonstration of the into instruction") demonstrates the use of
    the `into` instruction.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`into` 指令与 `bound` 指令类似，也会在某些条件下生成异常。具体而言，`into` 会在溢出标志被设置时生成异常。通常，你会在有符号算术操作（例如
    `intmul`）之后立即使用 `into` 来检查是否发生溢出。如果溢出标志未设置，系统会忽略 `into`；但是，如果溢出标志被设置，则 `into`
    指令会引发 `ex.IntoInstr` 异常。[示例 4-2](ch04.html#demonstration_of_the_into_instruction
    "示例 4-2. `into` 指令的演示") 程序演示了如何使用 `into` 指令。'
- en: Example 4-2. Demonstration of the `into` instruction
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-2. `into` 指令的演示
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '* * *'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[47](#CHP-4-FN-1)]) This form isn't a true 80x86 instruction. HLA converts
    this form of the bound instruction to the two-operand form by creating two `readonly`
    memory variables initialized with the specified constants.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[47](#CHP-4-FN-1)]) 这种形式并不是一个真正的 80x86 指令。HLA 会通过创建两个初始化为指定常量的 `readonly`
    内存变量，将这种形式的 `bound` 指令转换为双操作数形式。
- en: 4.2 HLA Constant and Value Declarations
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2 HLA 常量和数值声明
- en: HLA's `const` and `val` sections let you declare symbolic constants. The `const`
    section lets you declare identifiers whose value is constant throughout compilation
    and runtime; the `val` section lets you declare symbolic constants whose values
    can change at compile time but whose values are constant at runtime (that is,
    the same name can have a different value at several points in the source code,
    but the value of a `val` symbol at a given point in the program cannot change
    while the program is running).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 的 `const` 和 `val` 部分允许你声明符号常量。`const` 部分允许你声明在编译和运行时其值都恒定不变的标识符；`val` 部分允许你声明在编译时值可以变化，但在运行时值不变的符号常量（也就是说，相同的名称可以在源代码的不同地方有不同的值，但在程序运行时，`val`
    符号的值在特定的程序点不能改变）。
- en: 'The `const` section appears in the same area of your program as the `static`,
    `readonly`, `storage`, and `var` sections. It begins with the `const` reserved
    word and has a syntax that is nearly identical to the `readonly` section; that
    is, the `const` section contains a list of identifiers followed by a type and
    a constant expression. The following example will give you an idea of what the
    `const` section looks like:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 部分出现在程序中的位置与 `static`、`readonly`、`storage` 和 `var` 部分相同。它以 `const`
    保留字开始，语法几乎与 `readonly` 部分相同；也就是说，`const` 部分包含一个标识符列表，后跟类型和常量表达式。以下示例将给你一个关于 `const`
    部分的基本概念：'
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once you declare these constants in this manner, you may use the symbolic identifiers
    anywhere the corresponding literal constant is legal. These constants are known
    as manifest constants. A *manifest constant* is a symbolic representation of a
    constant that allows you to substitute the literal value for the symbol anywhere
    in the program. Contrast this with `readonly` variables; a `readonly` variable
    is certainly a constant value because you cannot change such values at runtime.
    However, there is a memory location associated with `readonly` variables, and
    the operating system, not the HLA compiler, enforces the read-only attribute.
    Although it will certainly crash your program when it runs, it is perfectly legal
    to write an instruction like `mov( eax, ReadOnlyVar );`. On the other hand, it
    is no more legal to write `mov( eax, MaxIndex );` (using the declaration above)
    than it is to write `mov( eax, 15 );`. In fact, both of these statements are equivalent
    because the compiler substitutes `15` for `MaxIndex` whenever it encounters this
    manifest constant.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦以这种方式声明了这些常量，你可以在任何符号常量合法的地方使用这些符号标识符。这些常量被称为显式常量。*显式常量*是常量的符号表示，允许你在程序中的任何地方将字面值替换为符号。与
    `readonly` 变量进行对比；`readonly` 变量当然是常量值，因为在运行时你不能改变这些值。然而，`readonly` 变量有一个内存位置，操作系统，而不是
    HLA 编译器，强制执行只读属性。尽管在程序运行时，它肯定会导致程序崩溃，但写出像 `mov( eax, ReadOnlyVar );` 这样的指令是完全合法的。另一方面，写
    `mov( eax, MaxIndex );`（使用上面的声明）和写 `mov( eax, 15 );` 是一样不合法的。实际上，这两个语句是等效的，因为编译器在遇到这个显式常量时，会用
    `15` 替换 `MaxIndex`。
- en: 'If there is absolutely no ambiguity about a constant''s type, then you may
    declare a constant by specifying only the name and the constant''s value, omitting
    the type specification. In the example earlier, the `pi`, `Delimiter`, `MaxIndex`,
    and `DebugActive` constants could use the following declarations:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果常量的类型完全没有歧义，那么你可以仅指定名称和常量值来声明常量，省略类型说明。在之前的示例中，`pi`、`Delimiter`、`MaxIndex`
    和 `DebugActive` 常量可以使用以下声明：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Symbol constants that have an integer literal constant are always given the
    smallest possible unsigned type if the constant is zero or positive, or the smallest
    possible integer type (`int8`, `int16`, and so on) if the value is negative.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 具有整数字面常量的符号常量，如果常量为零或正数，则始终使用最小的无符号类型；如果值为负数，则使用最小的整数类型（`int8`、`int16` 等）。
- en: Constant declarations are great for defining "magic" numbers that might possibly
    change during program modification. The program in [Example 4-3](ch04s02.html#data_alignment_program_rewritten_using_c
    "Example 4-3. Data alignment program rewritten using const definitions") provides
    an example of using constants to parameterize "magic" values in the program. In
    this particular case, the program defines manifest constants for the amount of
    memory to allocate for the test, the (mis)alignment, and the number of loop and
    data repetitions. This program demonstrates the performance reduction that occurs
    on misaligned data accesses. Adjust the `MainRepetitions` constant if the program
    is too fast or too slow.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 常量声明非常适合定义可能在程序修改过程中发生变化的“魔法”数字。[示例 4-3](ch04s02.html#data_alignment_program_rewritten_using_c
    "示例 4-3. 使用 const 定义重写的数据对齐程序")中的程序展示了如何使用常量来参数化程序中的“魔法”值。在这个具体案例中，程序定义了清单常量来指定为测试分配的内存量、（错误的）对齐方式，以及循环和数据重复的次数。该程序展示了在数据访问未对齐时性能的下降。如果程序运行太快或太慢，可以调整
    `MainRepetitions` 常量。
- en: Example 4-3. Data alignment program rewritten using `const` definitions
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-3. 使用 `const` 定义重写的数据对齐程序
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 4.2.1 Constant Types
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.1 常量类型
- en: Manifest constants can be any of the HLA primitive types plus a few of the composite
    types this chapter discusses. [Chapter 1](ch01.html "Chapter 1. HELLO, WORLD OF
    ASSEMBLY LANGUAGE"), [Chapter 2](ch02.html "Chapter 2. DATA REPRESENTATION"),
    and [Chapter 3](ch03.html "Chapter 3. MEMORY ACCESS AND ORGANIZATION") discussed
    most of the primitive types; the primitive types include the following:^([[48](#ftn.CHP-4-FN-2)])
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 清单常量可以是任何 HLA 基本类型，以及本章讨论的一些复合类型。[第 1 章](ch01.html "第 1 章. 汇编语言的世界"), [第 2 章](ch02.html
    "第 2 章. 数据表示"), 和 [第 3 章](ch03.html "第 3 章. 内存访问与组织") 讨论了大多数基本类型；基本类型包括以下几种：^([[48](#ftn.CHP-4-FN-2)])
- en: '`boolean` constants (true or false)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean` 常量（true 或 false）'
- en: '`uns8` constants (0..255)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uns8` 常量（0..255）'
- en: '`uns16` constants (0..65,535)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uns16` 常量（0..65,535）'
- en: '`uns32` constants (0..4,294,967,295)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uns32` 常量（0..4,294,967,295）'
- en: '`int8` constants (−128..+127)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int8` 常量（−128..+127）'
- en: '`int16` constants (−32,768..+32,767)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int16` 常量（−32,768..+32,767）'
- en: '`int32` constants (−2,147,483,648..+2,147,483,647)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int32` 常量（−2,147,483,648..+2,147,483,647）'
- en: '`char` constants (any ASCII character with a character code in the range 0..255)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char` 常量（任何 ASCII 字符，字符代码范围为 0..255）'
- en: '`byte` constants (any 8-bit value including integers, booleans, and characters)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte` 常量（任何 8 位值，包括整数、布尔值和字符）'
- en: '`word` constants (any 16-bit value)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`word` 常量（任何 16 位值）'
- en: '`dword` constants (any 32-bit value)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dword` 常量（任何 32 位值）'
- en: '`real32` constants (floating-point values)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`real32` 常量（浮点值）'
- en: '`real64` constants (floating-point values)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`real64` 常量（浮点值）'
- en: '`real80` constants (floating-point values)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`real80` 常量（浮点值）'
- en: 'In addition to the constant types appearing above, the `const` section supports
    six additional constant types:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上面出现的常量类型外，`const` 部分还支持六种额外的常量类型：
- en: '`string` constants'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string` 常量'
- en: '`text` constants'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text` 常量'
- en: Enumerated constant values
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举常量值
- en: Array constants
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组常量
- en: Record/Union constants
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录/联合常量
- en: Character set constants
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符集常量
- en: These data types are the subject of this chapter, and the discussion of most
    of them appears a little later. However, the string and text constants are sufficiently
    important to warrant an early discussion of these constant types.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据类型是本章的主题，关于它们的大部分讨论稍后会出现。然而，字符串和文本常量足够重要，值得早期讨论这些常量类型。
- en: 4.2.2 String and Character Literal Constants
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.2 字符串和字符字面常量
- en: HLA, like most programming languages, draws a distinction between a sequence
    of characters, a *string*, and a single character. This distinction is present
    both in the type declarations and in the syntax for literal character and string
    constants. Until now, this text has not drawn a fine distinction between character
    and string literal constants; now is the time to do so.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 和大多数编程语言一样，区分字符序列（*字符串*）和单个字符。这一区别在类型声明和字面字符与字符串常量的语法中都存在。到目前为止，本书尚未对字符和字符串字面常量做出精细区分；现在是时候进行区分了。
- en: 'String literal constants consist of a sequence of zero or more characters surrounded
    by ASCII quote characters. The following are examples of legal literal string
    constants:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面常量由零个或多个字符组成，这些字符被 ASCII 引号字符包围。以下是合法的字面字符串常量的示例：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A string of length 1 is not the same thing as a character constant. HLA uses
    two completely different internal representations for character and string values.
    Hence, `"a"` is not a character; it is a string that just happens to contain a
    single character.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 长度为 1 的字符串与字符常量并不相同。HLA 对字符和字符串值使用了两种完全不同的内部表示方式。因此，`"a"` 不是一个字符；它是一个字符串，只不过恰好包含一个字符。
- en: 'Character literal constants take a couple forms, but the most common form consists
    of a single character surrounded by ASCII apostrophe characters:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 字符字面量常量有几种形式，但最常见的形式是由一个字符包围在 ASCII 撇号字符中：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As this section notes earlier, `"a"` and `'a'` are not equivalent.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节前面所述，`"a"` 和 `'a'` 并不等价。
- en: Those who are familiar with C, C++, or Java probably recognize these literal
    constant forms, because they are similar to the character and string constants
    in C/C++/Java. In fact, this text has made a tacit assumption to this point that
    you are somewhat familiar with C/C++ insofar as examples appearing up to this
    point use character and string constants without an explicit definition of them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那些熟悉 C、C++ 或 Java 的人可能会认出这些字面常量形式，因为它们与 C/C++/Java 中的字符和字符串常量相似。事实上，到目前为止，本文已经默认假设你对
    C/C++ 有一定的了解，因为到目前为止的示例中使用了字符和字符串常量，而没有明确地对它们进行定义。
- en: Another similarity between C/C++ strings and HLA's is the automatic concatenation
    of adjacent literal string constants within your program. For example, HLA concatenates
    the two string constants
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 字符串和 HLA 字符串之间的另一个相似之处是自动连接程序中的相邻字面量字符串常量。例如，HLA 会将两个字符串常量连接起来
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: to form the single-string constant
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 形成一个单一的字符串常量
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Beyond these few similarities, however, HLA strings and C/C++ strings differ.
    For example, C/C++ strings let you specify special character values using the
    escape character sequence consisting of a backslash character followed by one
    or more special characters; HLA does not use this escape character mechanism.
    HLA does provide, however, several other ways to insert special characters into
    a string or character constant.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了这些相似之处，HLA 字符串和 C/C++ 字符串还是有所不同。例如，C/C++ 字符串允许你使用转义字符序列来指定特殊字符值，该序列由反斜杠字符后跟一个或多个特殊字符组成；而
    HLA 不使用这种转义字符机制。然而，HLA 提供了其他几种方法将特殊字符插入字符串或字符常量中。
- en: 'Because HLA does not allow escape character sequences in literal string and
    character constants, the first question you might ask is, "How does one embed
    quote characters in string constants and apostrophe characters in character constants?"
    To solve this problem, HLA uses the same technique as Pascal and many other languages:
    You insert two quotes in a string constant to represent a single quote, or you
    place two apostrophes in a character constant to represent a single apostrophe
    character. For example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 HLA 不允许在字面量字符串和字符常量中使用转义字符序列，你可能首先会问：“如何在字符串常量中嵌入引号字符，在字符常量中嵌入撇号字符？”为了解决这个问题，HLA
    使用与 Pascal 和许多其他语言相同的技术：在字符串常量中插入两个引号以表示单个引号，或者在字符常量中插入两个撇号以表示单个撇号字符。例如：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The above is equivalent to:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容等价于：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As [Chapter 1](ch01.html "Chapter 1. HELLO, WORLD OF ASSEMBLY LANGUAGE") pointed
    out, to create a single apostrophe character constant, you place two adjacent
    apostrophes within a pair of apostrophes:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第1章](ch01.html "第1章。汇编语言的世界")所指出的，要创建一个单一的撇号字符常量，你需要在一对撇号中放入两个相邻的撇号：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'HLA provides a couple of other features that eliminate the need for escape
    characters. In addition to concatenating two adjacent string constants to form
    a longer string constant, HLA will also concatenate any combination of adjacent
    character and string constants to form a single string constant:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 提供了其他一些功能，消除了对转义字符的需求。除了将两个相邻的字符串常量连接成一个更长的字符串常量外，HLA 还可以将任何相邻的字符常量和字符串常量的组合连接成一个单一的字符串常量：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the two *He wrote* strings in the previous examples are identical
    in HLA.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面示例中的两个*He wrote*字符串在 HLA 中是完全相同的。
- en: 'HLA provides a second way to specify character constants that handles all the
    other C/C++ escape character sequences: the ASCII code literal character constant.
    This literal character constant form uses the syntax:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 提供了第二种指定字符常量的方法，可以处理所有其他 C/C++ 转义字符序列：ASCII 码字面量字符常量。这个字面量字符常量的形式使用以下语法：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This form creates a character constant whose value is the ASCII code specified
    by `integer_constant`. The numeric constant can be a decimal, hexadecimal, or
    binary value. For example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该形式创建一个字符常量，其值为由`integer_constant`指定的ASCII码。数字常量可以是十进制、十六进制或二进制值。例如：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Because you may concatenate character literals with strings, and the `#constant`
    form is a character literal, the following are all legal strings:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你可以将字符字面量与字符串连接，而`#constant`形式是一个字符字面量，所以下列字符串都是合法的：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Because $22 is the ASCII code for the quote character, this last example is
    yet a third form of the *He wrote* string literal.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因为$22是引号字符的ASCII码，所以这个最后的示例是*He wrote*字符串字面量的第三种形式。
- en: 4.2.3 String and Text Constants in the const Section
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.3 `const`部分中的字符串和文本常量
- en: 'String and text constants in the `const` section use the following declaration
    syntax:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`部分中的字符串和文本常量使用以下声明语法：'
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Other than the data type of these two constants, their declarations are identical.
    However, their behavior in an HLA program is quite different.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两个常量的数据类型外，它们的声明是相同的。然而，它们在HLA程序中的行为却完全不同。
- en: Whenever HLA encounters a symbolic string constant within your program, it substitutes
    the string literal constant in place of the string name. So a statement like `stdout.put(
    AStringConst );` prints the string `123` to the display. No real surprise here.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每当HLA在程序中遇到符号字符串常量时，它会用字符串字面量常量替换字符串名称。所以像`stdout.put( AStringConst );`这样的语句会将字符串`123`打印到显示屏上。这里没有什么意外。
- en: 'Whenever HLA encounters a symbolic text constant within your program, it substitutes
    the text of that string (rather than the string literal constant) for the identifier.
    That is, HLA substitutes the characters between the delimiting quotes in place
    of the symbolic text constant. Therefore, the following statement is perfectly
    legal given the declarations above:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每当HLA在程序中遇到符号文本常量时，它会用该字符串的文本内容（而不是字符串字面量常量）替换标识符。也就是说，HLA会将定界引号之间的字符替换为符号文本常量。因此，考虑以下语句，根据上述声明，它是完全合法的：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that substituting `AStringConst` for `ATextConst` in this example is illegal:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个示例中，将`AStringConst`替换为`ATextConst`是非法的：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This latter example is illegal because you cannot move a string literal constant
    into the AL register.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个后续示例是非法的，因为你不能将字符串字面量常量移入AL寄存器。
- en: 'Whenever HLA encounters a symbolic text constant in your program, it immediately
    substitutes the value of the text constant''s string for that text constant and
    continues the compilation as though you had written the text constant''s value
    rather than the symbolic identifier in your program. This can save some typing
    and help make your programs a little more readable if you often enter some sequence
    of text in your program. For example, consider the `nl` (newline) text constant
    declaration found in the HLA *stdio.hhf* library header file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每当HLA在你的程序中遇到符号文本常量时，它会立即将文本常量的字符串值替换为该文本常量，并继续编译，就像你在程序中写入的是文本常量的值而不是符号标识符一样。如果你经常在程序中输入某些文本序列，这可以节省一些输入工作，并使你的程序更具可读性。例如，考虑在HLA
    *stdio.hhf*库头文件中找到的`nl`（换行）文本常量声明：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Whenever HLA encounters the symbol `nl`, it immediately substitutes the value
    of the string "`#$d #$a`" for the `nl` identifier. When HLA sees the `#$d` (carriage
    return) character constant followed by the `#$a` (line feed) character constants,
    it concatenates the two to form the string containing the Windows newline sequence
    (a carriage return followed by a line feed). Consider the following two statements:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '每当HLA遇到符号`nl`时，它会立即将字符串"`#$d #$a`"的值替换为`nl`标识符。当HLA看到`#$d`（回车）字符常量后跟`#$a`（换行）字符常量时，它会将这两个字符连接成一个字符串，形成Windows换行序列（回车后跟换行）。考虑以下两个语句：'
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '(Notice that the second statement above does not separate the string literal
    and the `nl` symbol with a comma.) In the first example, HLA emits code that prints
    the string `Hello World` and then emits some additional code that prints a newline
    sequence. In the second example, HLA expands the `nl` symbol as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，上述第二个语句没有用逗号分隔字符串字面量和`nl`符号。）在第一个示例中，HLA生成代码打印字符串`Hello World`，然后生成一些额外的代码打印换行符序列。在第二个示例中，HLA将`nl`符号扩展如下：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now HLA sees a string literal constant (`Hello World`) followed by two character
    constants. It concatenates the three of them together to form a single string
    and then prints this string with a single call. Therefore, leaving off the comma
    between the string literal and the `nl` symbol produces slightly more efficient
    code. Keep in mind that this works only with string literal constants. You cannot
    concatenate string variables, or a string variable with a string literal, by using
    this technique.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 HLA 看到一个字符串字面常量（`Hello World`），后面跟着两个字符常量。它将这三者连接起来，形成一个单一的字符串，并通过一个调用来打印这个字符串。因此，省略字符串字面常量和
    `nl` 符号之间的逗号可以生成略微更高效的代码。请记住，这仅适用于字符串字面常量。你不能通过这种技巧连接字符串变量，或将字符串变量与字符串字面常量连接起来。
- en: Linux, FreeBSD, and Mac OS X users should note that the Unix end-of-line sequence
    is just a single line-feed character. Therefore, the declaration for `nl` is slightly
    different in those operating systems (to always guarantee that `nl` expands to
    a string constant rather than a character constant).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Linux、FreeBSD 和 Mac OS X 用户应注意，Unix 的行尾序列仅是一个单一的换行符。因此，在这些操作系统中，`nl` 的声明略有不同（以确保
    `nl` 始终展开为字符串常量，而不是字符常量）。
- en: In the constant section, if you specify only a constant identifier and a string
    constant (that is, you do not supply a type), HLA defaults to type `string`. If
    you want to declare a `text` constant, you must explicitly supply the type.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在常量部分，如果只指定常量标识符和字符串常量（即未提供类型），HLA 默认类型为 `string`。如果你想声明一个 `text` 常量，必须显式地提供类型。
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 4.2.4 Constant Expressions
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.4 常量表达式
- en: 'Thus far, this chapter has given the impression that a symbolic constant definition
    consists of an identifier, an optional type, and a literal constant. Actually,
    HLA constant declarations can be a lot more sophisticated than this because HLA
    allows the assignment of a constant expression, not just a literal constant, to
    a symbolic constant. The generic constant declaration takes one of the following
    two forms:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章给人的印象是符号常量定义由标识符、可选类型和字面常量组成。实际上，HLA 常量声明可以比这复杂得多，因为 HLA 允许将常量表达式（而不仅仅是字面常量）赋值给符号常量。通用常量声明有以下两种形式：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Constant expressions take the familiar form you're used to in high-level languages
    like C/C++ and Pascal. They may contain literal constant values, previously declared
    symbolic constants, and various arithmetic operators. [Table 4-1](ch04s02.html#operations_allowed_in_constant_expressio
    "Table 4-1. Operations Allowed in Constant Expressions") lists some of the operations
    possible in a constant expression.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 常量表达式采用你在 C/C++ 和 Pascal 等高级语言中常见的形式。它们可以包含字面常量值、先前声明的符号常量和各种算术运算符。[表 4-1](ch04s02.html#operations_allowed_in_constant_expressio
    "表 4-1. 常量表达式中允许的运算") 列出了常量表达式中可能的一些运算。
- en: The constant expression operators follow standard precedence rules; you may
    use the parentheses to override the precedence if necessary. See the HLA reference
    at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) or [http://artofasm.com/](http://artofasm.com/)
    for the exact precedence relationships. In general, if the precedence isn't obvious,
    use parentheses to exactly state the order of evaluation. HLA actually provides
    a few more operators than these, though the ones above are the ones you will most
    commonly use; the HLA documentation provides a complete list of constant expression
    operators.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 常量表达式运算符遵循标准的优先级规则；如果需要，你可以使用括号来覆盖优先级。有关确切的优先级关系，请参见 HLA 参考手册 [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    或 [http://artofasm.com/](http://artofasm.com/)。一般来说，如果优先级不明显，可以使用括号明确指出计算顺序。虽然
    HLA 提供了比这些更多的运算符，但上述运算符是你最常用的；HLA 文档提供了常量表达式运算符的完整列表。
- en: Table 4-1. Operations Allowed in Constant Expressions
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1. 常量表达式中允许的运算
- en: '| Arithmetic Operators |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 算术运算符 |'
- en: '| --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `−` (unary negation) | Negates the expression immediately following `"-"`.
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `−`（一元取反） | 对紧随其后的表达式执行取反操作。 |'
- en: '| `*` | Multiplies the integer or real values around the asterisk. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 乘法运算，作用于星号两边的整数或实数值。 |'
- en: '| `div` | Divides the left integer operand by the right integer operand, producing
    an integer (truncated) result. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `div` | 将左侧整数操作数除以右侧整数操作数，产生一个整数（截断）结果。 |'
- en: '| `mod` | Divides the left integer operand by the right integer operand, producing
    an integer remainder. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `mod` | 用于将左侧整数操作数除以右侧整数操作数，产生一个整数余数。 |'
- en: '| `/` | Divides the left numeric operand by the second numeric operand, producing
    a floating point result. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 将左侧数字操作数除以第二个数字操作数，返回浮点结果。 |'
- en: '| `+` | Adds the left and right numeric operands. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 将左右两个数字操作数相加。 |'
- en: '| `−` | Subtracts the right numeric operand from the left numeric operand.
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `−` | 从左操作数中减去右操作数。 |'
- en: '| Comparison Operators |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 比较运算符 |'
- en: '| --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `=`, `==` | Compares left operand with right operand. Returns true if equal.
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `=`, `==` | 比较左操作数和右操作数。如果相等，返回真。 |'
- en: '| `<>`, `!=` | Compares left operand with right operand. Returns true if not
    equal. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `<>`, `!=` | 比较左操作数和右操作数。如果不相等，返回真。 |'
- en: '| `<` | Returns true if left operand is less than right operand. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 如果左操作数小于右操作数，则返回真。 |'
- en: '| `<=` | Returns true if left operand is <= right operand. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 如果左操作数小于或等于右操作数，则返回真。 |'
- en: '| `>` | Returns true if left operand is greater than right operand. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 如果左操作数大于右操作数，则返回真。 |'
- en: '| `>=` | Returns true if left operand is >= right operand. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 如果左操作数大于或等于右操作数，则返回真。 |'
- en: '| Logical Operators^([[a](#ftn.CHP-4-TFN-1)]) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑运算符^([[a](#ftn.CHP-4-TFN-1)]) |'
- en: '| --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `&` | For boolean operands, returns the logical `and` of the two operands.
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 对于布尔操作数，返回两个操作数的逻辑`与`。 |'
- en: '| `&#124;` | For boolean operands, returns the logical `or` of the two operands.
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 对于布尔操作数，返回两个操作数的逻辑`或`。 |'
- en: '| `^` | For boolean operands, returns the logical exclusive-or. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 对于布尔操作数，返回逻辑异或。 |'
- en: '| `!` | Returns the logical not of the single operand following `"!"`. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 返回紧随 `"!"` 后的单一操作数的逻辑`非`。 |'
- en: '|'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '^([[a](#CHP-4-TFN-1)]) Note to C/C++ and Java users: HLA''s constant expressions
    use complete boolean evaluation rather than short-circuit boolean evaluation.
    Hence, HLA constant expressions do not behave identically to C/C++/Java expressions.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[a](#CHP-4-TFN-1)]) 提示给C/C++和Java用户：HLA的常量表达式使用完整的布尔求值，而不是短路布尔求值。因此，HLA的常量表达式与C/C++/Java表达式的行为不同。
- en: '|'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Bitwise Logical Operators |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 按位逻辑运算符 |'
- en: '| --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `&` | For integer numeric operands, returns bitwise `and` of the operands.
    |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 对于整数数字操作数，返回操作数的按位`与`。 |'
- en: '| `&#124;` | For integer numeric operands, returns bitwise `or` of the operands.
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 对于整数数字操作数，返回操作数的按位`或`。 |'
- en: '| `^` | For integer numeric operands, returns bitwise `xor` of the operands.
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 对于整数数字操作数，返回操作数的按位`异或`。 |'
- en: '| `!` | For an integer numeric operand, returns bitwise `not` of the operand.
    |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 对于整数数字操作数，返回该操作数的按位`取反`。 |'
- en: '| String Operators |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 字符串运算符 |'
- en: '| --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `''+''` | Returns the concatenation of the left and right string operands.
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `''+''` | 返回左侧和右侧字符串操作数的连接结果。 |'
- en: 'If an identifier appears in a constant expression, that identifier must be
    a constant identifier that you have previously defined in your program in a const
    or `val` section. You may not use variable identifiers in a constant expression;
    their values are not defined at compile time when HLA evaluates the constant expression.
    Also, don''t confuse compile-time and runtime operations:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果常量表达式中出现标识符，则该标识符必须是你在程序中的`const`或`val`部分之前定义的常量标识符。你不能在常量表达式中使用变量标识符，因为在HLA求值常量表达式时，变量的值在编译时并未定义。另外，请不要混淆编译时操作和运行时操作：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: HLA directly interprets the value of a constant expression during compilation.
    It does not emit any machine instructions to compute `x + y` in the constant expression
    above. Instead, it directly computes the sum of these two constant values. From
    that point forward in the program, HLA associates the value 11 with the constant
    `Sum` just as if the program had contained the statement `Sum := 11;` rather than
    `Sum := x + y;`. On the other hand, HLA does not precompute the value 11 in AL
    for the `mov` and `add` instructions above; it faithfully emits the object code
    for these two instructions and the 80x86 computes their sum when the program is
    run (sometime after the compilation is complete).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: HLA在编译期间直接解释常量表达式的值。它不会发出任何机器指令来计算上面常量表达式中的`x + y`。相反，它会直接计算这两个常量值的和。从那时起，HLA将常量`Sum`与值11关联，就像程序中包含了语句`Sum
    := 11;`而不是`Sum := x + y;`一样。另一方面，HLA不会在AL中预计算指令`mov`和`add`的值；它忠实地发出这两个指令的目标代码，80x86将在程序运行时（编译完成后某个时刻）计算它们的和。
- en: 'In general, constant expressions don''t get very sophisticated in assembly
    language programs. Usually, you''re adding, subtracting, or multiplying two integer
    values. For example, the following `const` section defines a set of constants
    that have consecutive values:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，常量表达式在汇编语言程序中不会非常复杂。通常，你只是对两个整数值进行加法、减法或乘法。例如，以下 `const` 区段定义了一组具有连续值的常量：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The constants above have the following values: `TapeDAT=0`, `Tape8mm=1`, `TapeQIC80=2`,
    `TapeTravan=3`, and `TapeDLT=4`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上述常量具有以下值：`TapeDAT=0`、`Tape8mm=1`、`TapeQIC80=2`、`TapeTravan=3` 和 `TapeDLT=4`。
- en: 4.2.5 Multiple const Sections and Their Order in an HLA Program
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.5 HLA 程序中的多个 `const` 区段及其顺序
- en: Although `const` sections must appear in the declaration section of an HLA program
    (for example, between the program *`pgmname`*`;` header and the corresponding
    `begin` *`pgmname`*`;` statement), they do not have to appear before or after
    any other items in the declaration section. In fact, like the variable declaration
    sections, you can place multiple `const` sections in a declaration section. The
    only restriction on HLA constant declarations is that you must declare any constant
    symbol before you use it in your program.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `const` 区段必须出现在 HLA 程序的声明区段中（例如，在程序 *`pgmname`*`;` 头部和相应的 `begin` *`pgmname`*`;`
    语句之间），但它不必出现在声明区段中的其他任何位置之前或之后。事实上，和变量声明区段一样，你可以在声明区段中放置多个 `const` 区段。HLA 常量声明的唯一限制是，必须在程序中使用任何常量符号之前先声明该符号。
- en: 'Some C/C++ programmers, for example, are more comfortable writing their constant
    declarations as follows (because this is closer to C/C++''s syntax for declaring
    constants):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 C/C++ 程序员，例如，更习惯于按如下方式编写常量声明（因为这更接近 C/C++ 声明常量的语法）：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The placement of the `const` section in a program seems to be a personal issue
    among programmers. Other than the requirement of defining all constants before
    you use them, you may feel free to insert the `const` declaration section anywhere
    in the declaration section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，`const` 区段的位置似乎是程序员个人的问题。除了要求在使用常量之前定义所有常量外，你可以随意将 `const` 声明区段插入到声明区段的任何位置。
- en: 4.2.6 The HLA val Section
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.6 HLA `val` 区段
- en: You cannot change the value of a constant you define in the `const` section.
    While this seems perfectly reasonable (constants after all, are supposed to be,
    well, constant), there are different ways we can define the term *constant*, and
    `const` objects follow the rules of only one specific definition. HLA's `val`
    section lets you define constant objects that follow slightly different rules.
    This section discusses the `val` section and the difference between `val` constants
    and `const` constants.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能更改在 `const` 区段中定义的常量的值。虽然这似乎是完全合理的（毕竟常量应该是常量），但我们可以通过不同的方式来定义 "*常量*" 这个术语，而
    `const` 对象遵循的是一个特定定义的规则。HLA 的 `val` 区段允许你定义遵循略有不同规则的常量对象。本节讨论了 `val` 区段及 `val`
    常量与 `const` 常量之间的区别。
- en: 'The concept of "`const`-ness" can exist at two different times: while HLA is
    compiling your program and later when your program executes (and HLA is no longer
    running). All reasonable definitions of a constant require that a value not change
    while the program is running. Whether or not the value of a "constant" can change
    during compilation is a separate issue. The difference between HLA `const` objects
    and HLA `val` objects is whether the value can change during compilation.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '"`const` 属性" 可以在两个不同的时刻存在：当 HLA 正在编译程序时，以及程序执行时（此时 HLA 不再运行）。所有合理的常量定义都要求常量的值在程序运行时保持不变。至于常量的值是否可以在编译时发生变化，这是一个单独的问题。HLA
    `const` 对象和 HLA `val` 对象的区别在于，常量的值是否可以在编译时发生变化。'
- en: Once you define a constant in the `const` section, the value of that constant
    is immutable from that point forward *both at runtime and while HLA is compiling
    your program*. Therefore, an instruction like `mov( SymbolicCONST, eax );` always
    moves the same value into EAX, regardless of where this instruction appears in
    the HLA main program. Once you define the symbol `SymbolicCONST` in the `const`
    section, this symbol has the same value from that point forward.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在 `const` 区段中定义了常量，该常量的值从此以后将不可更改，*无论是在运行时还是在 HLA 编译程序时*。因此，像 `mov( SymbolicCONST,
    eax );` 这样的指令始终将相同的值移动到 EAX 寄存器中，无论该指令在 HLA 主程序中出现的位置如何。一旦你在 `const` 区段中定义了符号
    `SymbolicCONST`，从那时起该符号的值就始终不变。
- en: 'The HLA `val` section lets you declare symbolic constants, just like the `const`
    section. However, HLA `val` constants can change their value throughout the source
    code in your program. The following HLA declarations are perfectly legal:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: HLA的`val`部分允许你声明符号常量，就像`const`部分一样。然而，HLA的`val`常量可以在程序的整个源代码中更改其值。以下HLA声明是完全合法的：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All of the symbols appearing in the `const` sections use the symbolic value
    `InitialValue` as part of the definition. Note, however, that `InitialValue` has
    different values at various points in this code sequence; at the beginning of
    the code sequence `InitialValue` has the value 0, while later it has the value
    100.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有出现在`const`部分的符号都使用符号值`InitialValue`作为定义的一部分。然而，请注意，`InitialValue`在这段代码序列中的不同位置有不同的值；在代码序列的开始，`InitialValue`的值为0，而在后面它的值为100。
- en: Remember, at runtime a `val` object is not a variable; it is still a manifest
    constant and HLA will substitute the current value of a `val` identifier for that
    identifier.^([[49](#ftn.CHP-4-FN-3)]) Statements like `mov( 25, InitialValue );`
    are no more legal than `mov( 25, 0 );` or `mov( 25, 100 );`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在运行时，`val`对象不是变量；它仍然是一个常量，HLA会用`val`标识符当前的值替代该标识符。^([[49](#ftn.CHP-4-FN-3)])
    像`mov( 25, InitialValue );`这样的语句和`mov( 25, 0 );`或`mov( 25, 100 );`一样不合法。
- en: 4.2.7 Modifying val Objects at Arbitrary Points in Your Programs
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.7 在程序中的任意位置修改`val`对象
- en: If you declare all your `val` objects in the declaration section, it would seem
    that you would not be able to change the value of a `val` object between the `begin`
    and `end` statements of your program. After all, the `val` section must appear
    in the declaration section of the program, and the declaration section ends before
    the `begin` statement. In [Chapter 9](ch09.html "Chapter 9. MACROS AND THE HLA
    COMPILE-TIME LANGUAGE"), you will learn that most `val` object modifications occur
    between the `begin` and `end` statements; hence, HLA must provide some way to
    change the value of a `val` object outside the declaration section. The mechanism
    to do this is the `?` operator. Not only does HLA allow you to change the value
    of a `val` object outside the declaration section, but it also allows you to change
    the value of a `val` object almost *anywhere* in the program. Anywhere a space
    is allowed inside an HLA program, you can insert a statement of the form
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在声明部分声明了所有的`val`对象，看起来你就无法在程序的`begin`和`end`语句之间更改`val`对象的值。毕竟，`val`部分必须出现在程序的声明部分，而声明部分在`begin`语句之前就结束了。在[第9章](ch09.html
    "第9章. 宏和HLA编译时语言")中，你将学到，大多数`val`对象的修改发生在`begin`和`end`语句之间；因此，HLA必须提供某种方式来在声明部分之外更改`val`对象的值。实现这一点的机制是`?`操作符。HLA不仅允许你在声明部分之外更改`val`对象的值，而且还允许你几乎在程序的*任何地方*更改`val`对象的值。在HLA程序中，凡是允许空格的位置，你都可以插入如下形式的语句
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This means that you could write a short program like the one appearing in [Example 4-4](ch04s02.html#demonstration_of_val_redefinition_using
    "Example 4-4. Demonstration of val redefinition using the ? operator").
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以编写一个像[示例4-4](ch04s02.html#demonstration_of_val_redefinition_using "示例4-4.
    使用?操作符演示val重新定义")中出现的简短程序。
- en: Example 4-4. Demonstration of `val` redefinition using the `?` operator
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4-4：使用`?`操作符演示`val`重新定义
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '* * *'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[48](#CHP-4-FN-2)]) This is not a complete list. HLA also supports 64-bit
    and 128-bit data types. We'll discuss those in [Chapter 8](ch08.html "Chapter 8. ADVANCED
    ARITHMETIC").
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[48](#CHP-4-FN-2)]) 这不是一个完整的列表，HLA还支持64位和128位数据类型。我们将在[第8章](ch08.html "第8章.
    高级算术")中讨论这些类型。
- en: ^([[49](#CHP-4-FN-3)]) In this context, *current* means the value last assigned
    to a `val` object looking backward in the source code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[49](#CHP-4-FN-3)]) 在此上下文中，*当前*指的是回顾源代码时最后一次赋值给`val`对象的值。
- en: 4.3 The HLA Type Section
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.3 HLA类型部分
- en: 'Let''s say that you simply do not like the names that HLA uses for declaring
    `byte`, `word`, `dword`, `real`, and other variables. Let''s say that you prefer
    Pascal''s naming convention or perhaps C''s naming convention. You want to use
    terms like `integer`, `float`, `double`, or whatever. If HLA were Pascal, you
    could redefine the names in the `type` section of the program. With C you could
    use a `#define` or a `typedef` statement to accomplish the task. Well, HLA, like
    Pascal, has its own `type` statement that also lets you create aliases of these
    names. The following example demonstrates how to set up some C/C++/Pascal-compatible
    names in your HLA programs:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你就是不喜欢HLA用来声明`byte`、`word`、`dword`、`real`和其他变量的名称。假设你更喜欢Pascal的命名约定，或者可能是C的命名约定。你希望使用诸如`integer`、`float`、`double`等术语。如果HLA像Pascal一样，你可以在程序的`type`部分重新定义这些名称。如果是C，你可以使用`#define`或`typedef`语句来完成这项任务。好吧，HLA和Pascal一样，也有自己的`type`语句，它也允许你创建这些名称的别名。以下示例演示了如何在HLA程序中设置一些与C/C++/Pascal兼容的名称：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now you can declare your variables with more meaningful statements like these:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以用更有意义的语句声明你的变量，例如：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you program in Ada, C/C++, or FORTRAN (or any other language, for that matter),
    you can pick type names you''re more comfortable with. Of course, this doesn''t
    change how the 80x86 or HLA reacts to these variables one iota, but it does let
    you create programs that are easier to read and understand because the type names
    are more indicative of the actual underlying types. One warning for C/C++ programmers:
    don''t get too excited and go off and define an `int` data type. Unfortunately,
    `int` is an 80x86 machine instruction (interrupt), and therefore this is a reserved
    word in HLA.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Ada、C/C++或FORTRAN（或其他任何语言），你可以选择你更习惯的类型名称。当然，这并不会改变80x86或HLA对这些变量的反应，但它确实让你创建的程序更易于阅读和理解，因为类型名称更能反映实际的底层类型。给C/C++程序员的一个警告：不要太兴奋，去定义一个`int`数据类型。不幸的是，`int`是80x86的机器指令（中断），因此它在HLA中是一个保留字。
- en: The `type` section is useful for much more than creating type isomorphism (that
    is, giving a new name to an existing type). The following sections demonstrate
    many of the possible things you can do in the `type` section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`部分不仅仅用于创建类型同构（即，为现有类型指定新名称）。以下部分演示了你可以在`type`部分执行的许多操作。'
- en: 4.4 enum and HLA Enumerated Data Types
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.4 `enum`与HLA枚举数据类型
- en: 'In a previous section discussing constants and constant expressions, you saw
    the following example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前讨论常量和常量表达式的部分，你看到了以下示例：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This example demonstrates how to use constant expressions to develop a set of
    constants that contain unique, consecutive values. There are, however, a couple
    of problems with this approach. First, it involves a lot of typing (and extra
    reading when reviewing this program). Second, it's very easy to make a mistake
    when creating long lists of unique constants and reuse or skip some values. The
    HLA `enum` type provides a better way to create a list of constants with unique
    values.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例演示了如何使用常量表达式来开发一组包含独特、连续值的常量。然而，这种方法存在一些问题。首先，它涉及大量的输入（以及在复查该程序时额外的阅读工作）。其次，在创建长列表的独特常量时，很容易犯错，可能会重复使用或跳过某些值。HLA的`enum`类型提供了一种更好的方法来创建具有独特值的常量列表。
- en: '`enum` is an HLA type declaration that lets you associate a list of names with
    a new type. HLA associates a unique value with each name (that is, it *enumerates*
    the list). The `enum` keyword typically appears in the `type` section, and you
    use it as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`是HLA的一种类型声明，它允许你将一系列名称与新类型关联。HLA会将一个独特的值与每个名称关联（即，它对列表进行*枚举*）。`enum`关键字通常出现在`type`部分，你可以按照以下方式使用它：'
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The symbol *`enumTypeID`* becomes a new type whose values are specified by
    a list of names. As a concrete example, consider the data type `TapeDrives` and
    a corresponding variable declaration of type `TapeDrives`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 符号*`enumTypeID`*成为一个新类型，其值由名称列表指定。作为一个具体的例子，考虑数据类型`TapeDrives`及其对应的变量声明类型`TapeDrives`：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By default, HLA reserves 1 byte of storage for enumerated data types. So the
    `BackupUnit` variable will consume 1 byte of memory, and you would typically use
    an 8-bit register to access it.^([[50](#ftn.CHP-4-FN-4)]) As for the constants,
    HLA associates consecutive `uns8` constant values starting at 0 with each of the
    enumerated identifiers. In the `TapeDrives` example, the tape drive identifiers
    would have the values `TapeDAT=0`, `Tape8mm=1`, `TapeQIC80=2`, `TapeTravan=3`,
    and `TapeDLT=4`. You may use these constants exactly as though you had defined
    them with these values in a `const` section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，HLA 为枚举数据类型保留 1 字节的存储空间。因此，`BackupUnit` 变量将消耗 1 字节的内存，你通常会使用一个 8 位寄存器来访问它。^([[50](#ftn.CHP-4-FN-4)])
    至于常量，HLA 将从 0 开始依次为每个枚举标识符分配 `uns8` 常量值。在 `TapeDrives` 示例中，磁带驱动器标识符的值为 `TapeDAT=0`、`Tape8mm=1`、`TapeQIC80=2`、`TapeTravan=3`
    和 `TapeDLT=4`。你可以像在 `const` 部分定义这些常量并赋值一样，直接使用这些常量。
- en: '* * *'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[50](#CHP-4-FN-4)]) HLA provides a mechanism by which you can specify that
    enumerated data types consume 2 or 4 bytes of memory. See the HLA documentation
    for more details.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[50](#CHP-4-FN-4)]) HLA 提供了一种机制，你可以通过它指定枚举数据类型消耗 2 或 4 字节的内存。有关更多细节，请参见 HLA
    文档。
- en: 4.5 Pointer Data Types
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.5 指针数据类型
- en: You've probably experienced pointers firsthand in the Pascal, C, or Ada programming
    languages, and you're probably getting worried right now. Almost everyone has
    a bad experience when they first encounter pointers in a high-level language.
    Well, fear not! Pointers are actually *easier* to deal with in assembly language
    than in high-level languages. Besides, most of the problems you had with pointers
    probably had nothing to do with pointers but rather with the linked list and tree
    data structures you were trying to implement with them. Pointers, on the other
    hand, have many uses in assembly language that have nothing to do with linked
    lists, trees, and other scary data structures. Indeed, simple data structures
    like arrays and records often involve the use of pointers. So if you have some
    deep-rooted fear about pointers, forget everything you know about them. You're
    going to learn how *great* pointers really are.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在 Pascal、C 或 Ada 等编程语言中亲身体验过指针，而且现在可能有些担心。几乎每个人第一次接触指针时都会有糟糕的体验。别怕！指针在汇编语言中的处理实际上比在高级语言中要*简单*。此外，你在使用指针时遇到的许多问题，可能与指针本身无关，而是你尝试用它们实现的链表和树形数据结构的问题。另一方面，指针在汇编语言中的用途非常广泛，且与链表、树和其他复杂的数据结构无关。实际上，像数组和记录这样简单的数据结构也常常涉及使用指针。所以，如果你对指针有根深蒂固的恐惧，忘掉你对它们的所有认知吧。你将会发现，指针其实是*很棒*的。
- en: Probably the best place to start is with the definition of a pointer. Just exactly
    what is a pointer, anyway? Unfortunately, high-level languages like Pascal tend
    to hide the simplicity of pointers behind a wall of abstraction. This added complexity
    (which exists for good reason, by the way) tends to frighten programmers because
    *they don't understand what's going on*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最好的入门方式是从指针的定义开始。指针究竟是什么呢？不幸的是，高级语言像 Pascal 常常将指针的简单性隐藏在抽象的墙后。这种额外的复杂性（顺便说一下，这是有充分理由的）往往会让程序员感到害怕，因为*他们不理解发生了什么*。
- en: 'If you''re afraid of pointers, let''s just ignore them for the time being and
    work with an array. Consider the following array declaration in Pascal:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你害怕指针，那就暂时忽略它们，先使用数组。考虑下面这个 Pascal 数组声明：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Even if you don't know Pascal, the concept here is pretty easy to understand.
    `M` is an array with 1,024 integers in it, indexed from `M[0]` to `M[1023]`. Each
    one of these array elements can hold an integer value that is independent of all
    the others. In other words, this array gives you 1,024 different integer variables,
    each of which you refer to by number (the array index) rather than by name.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不知道 Pascal，理解这个概念也非常简单。`M` 是一个包含 1,024 个整数的数组，索引从 `M[0]` 到 `M[1023]`。这些数组元素中的每一个都可以保存一个整数值，并且每个值都与其他元素的值无关。换句话说，这个数组为你提供了
    1,024 个不同的整数变量，每个变量都通过数字（数组索引）而非名称来访问。
- en: 'If you encounter a program that has the statement `M[0]:=100;`, you probably
    won''t have to think at all about what is happening with this statement. It is
    storing the value 100 into the first element of the array `M`. Now consider the
    following two statements:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到一个程序，其中有语句 `M[0]:=100;`，你大概不需要多想就知道这条语句在做什么。它正在把值 100 存储到数组 `M` 的第一个元素中。现在考虑以下两条语句：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You should agree, without too much hesitation, that these two statements perform
    the same operation as `M[0]:=100`;. Indeed, you''re probably willing to agree
    that you can use any integer expression in the range 0..1,023 as an index into
    this array. The following statements still perform the same operation as our single
    assignment to index 0:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该不太犹豫就同意，这两条语句执行的操作和`M[0]:=100`;是一样的。实际上，你可能会同意，你可以使用任何范围在0到1,023之间的整数表达式作为这个数组的索引。以下语句依然执行与我们对索引0的单一赋值相同的操作：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '"Okay, so what''s the point?" you''re probably thinking. "Anything that produces
    an integer in the range 0..1,023 is legal. So what?" Okay, how about the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: “好了，那么重点是什么？”你可能在想。“任何生成0到1,023范围内整数的东西都是合法的，那又怎么样？”好吧，那以下的情况怎么样：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Whoa! Now that takes a few moments to digest. However, if you take it slowly,
    it makes sense and you'll discover that these two instructions perform the exact
    same operation you've been doing all along. The first statement stores 0 into
    array element `M[1]`. The second statement fetches the value of `M[1]`, which
    is an integer so you can use it as an array index into `M`, and uses that value
    (0) to control where it stores the value 100.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这一点可能需要一点时间消化。不过，如果你慢慢来，它是有道理的，你会发现这两条指令实际上执行的是你一直在做的相同操作。第一条语句将0存储到数组元素`M[1]`中。第二条语句取出`M[1]`的值，这是一个整数，因此你可以将其用作数组`M`的索引，并使用该值（0）来控制它存储100的地方。
- en: If you're willing to accept the above as reasonable, perhaps bizarre, but usable
    nonetheless, then you'll have no problems with pointers. *Because* *`M[1]`* *is
    a pointer!* Well, not really, but if you were to change `M` to "memory" and treat
    this array as all of memory, this is the exact definition of a pointer. A pointer
    is simply a memory location whose value is the address (or index, if you prefer)
    of some other memory location. Pointers are very easy to declare and use in an
    assembly language program. You don't even have to worry about array indices or
    anything like that.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意接受上述内容作为合理的，或许有些奇怪，但依然可用的情况，那么你就不会对指针有任何问题了。*因为* *`M[1]`* *就是一个指针！* 其实不完全是，但如果你将`M`看作“内存”，并将这个数组视为整个内存，那么这就是指针的确切定义。指针仅仅是一个内存位置，其值是某个其他内存位置的地址（或者说索引，如果你喜欢这样称呼的话）。在汇编语言程序中，指针的声明和使用非常简单，你甚至不必担心数组索引之类的问题。
- en: 4.5.1 Using Pointers in Assembly Language
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5.1 在汇编语言中使用指针
- en: 'An HLA pointer is a 32-bit value that may contain the address of some other
    variable. If you have a `dword` variable `p` that contains $1000_0000, then `p`
    "points" at memory location $1000_0000\. To access the `dword` that `p` points
    at, you could use code like the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: HLA指针是一个32位的值，可能包含某个其他变量的地址。如果你有一个`dword`类型的变量`p`，它的值是$1000_0000，那么`p`“指向”内存位置$1000_0000。要访问`p`所指向的`dword`，你可以使用类似以下的代码：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: By loading the value of `p` into EBX, this code loads the value $1000_0000 into
    EBX (assuming `p` contains $1000_0000 and, therefore, points at memory location
    $1000_0000). The second instruction above loads the EAX register with the `dword`
    starting at the location whose offset appears in EBX. Because EBX now contains
    $1000_0000, this will load EAX from locations $1000_0000 through $1000_0003.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`p`的值加载到EBX中，这段代码将$1000_0000的值加载到EBX中（假设`p`包含$1000_0000，因此指向内存位置$1000_0000）。上面第二条指令将EAX寄存器加载为从EBX中偏移量所指向的位置开始的`dword`。因为EBX现在包含$1000_0000，所以这将从$1000_0000到$1000_0003的位置加载EAX。
- en: 'Why not just load EAX directly from location $1000_0000 using an instruction
    like `mov( mem, eax )`; (assuming `mem` is at address $1000_0000)? Well, there
    are a lot of reasons. But the primary reason is that this `mov` instruction always
    loads EAX from location `mem`. You cannot change the address from where it loads
    EAX. The former instructions, however, always load EAX from the location where
    `p` is pointing. This is very easy to change under program control. In fact, the
    simple instruction `mov( &mem2, p );` will cause those same two instructions above
    to load EAX from `mem2` the next time they execute. Consider the following instruction
    sequence:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接使用像`mov( mem, eax )`这样的指令从位置$1000_0000加载EAX？（假设`mem`位于地址$1000_0000）其实有很多原因。不过最主要的原因是，这条`mov`指令总是从位置`mem`加载EAX。你无法更改它加载EAX的地址。然而，前面的指令总是从`p`所指向的位置加载EAX。这在程序控制下非常容易改变。实际上，简单的指令`mov(
    &mem2, p );`会使得上面那两条指令在下次执行时，从`mem2`加载EAX。考虑以下指令序列：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This short example demonstrates two execution paths through the program. The
    first path loads the variable `p` with the address of the variable `i`. The second
    path through the code loads `p` with the address of the variable `j`. Both execution
    paths converge on the last two `mov` instructions that load EAX with `i` or `j`
    depending upon which execution path was taken. In many respects, this is like
    a *parameter* to a procedure in a high-level language like Pascal. Executing the
    same instructions accesses different variables depending on whose address (`i`
    or `j`) winds up in `p`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单示例演示了程序的两条执行路径。第一条路径将变量 `p` 加载为变量 `i` 的地址。第二条路径通过代码将 `p` 加载为变量 `j` 的地址。这两条执行路径在最后两条
    `mov` 指令处汇合，根据执行路径的不同，将 `i` 或 `j` 加载到 EAX 寄存器中。在许多方面，这就像在高级语言（如 Pascal）中的*参数*。执行相同的指令时，取决于哪个地址（`i`
    或 `j`）最终存储在 `p` 中，程序访问不同的变量。
- en: 4.5.2 Declaring Pointers in HLA
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5.2 在 HLA 中声明指针
- en: 'Because pointers are 32-bits long, you could simply use the `dword` type to
    allocate storage for your pointers. However, there is a much better way to do
    this: HLA provides the `pointer to` phrase specifically for declaring pointer
    variables. Consider the following example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于指针是 32 位长，您可以简单地使用 `dword` 类型为指针分配存储空间。但是，有一种更好的方法：HLA 提供了 `pointer to` 短语专门用于声明指针变量。考虑以下示例：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This example demonstrates that it is possible to initialize as well as declare
    pointer variables in HLA. Note that you may only take addresses of static variables
    (`static`, `readonly`, and `storage` objects) with the address-of operator, so
    you can only initialize pointer variables with the addresses of static objects.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例演示了在 HLA 中初始化和声明指针变量是可能的。请注意，您只能使用取地址符号（address-of operator）获取静态变量（`static`、`readonly`
    和 `storage` 对象）的地址，因此只能使用静态对象的地址来初始化指针变量。
- en: You can also define your own pointer types in the `type` section of an HLA program.
    For example, if you often use pointers to characters, you'll probably want to
    use a `type` declaration like the one in the following example.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在 HLA 程序的 `type` 部分定义自己的指针类型。例如，如果您经常使用指向字符的指针，您可能希望使用如下所示的 `type` 声明。
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 4.5.3 Pointer Constants and Pointer Constant Expressions
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5.3 指针常量与指针常量表达式
- en: 'HLA allows two literal pointer constant forms: the address-of operator followed
    by the name of a static variable or the constant `NULL`. In addition to these
    two literal pointer constants, HLA also supports simple pointer constant expressions.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 允许两种字面指针常量形式：取地址符号后跟静态变量的名称，或者常量 `NULL`。除了这两种字面指针常量外，HLA 还支持简单的指针常量表达式。
- en: The `NULL` pointer is the constant 0\. Zero is an illegal address that will
    raise an exception if you try to access it under modern operating systems. Programs
    typically initialize pointers with `NULL` to indicate that a pointer has explicitly
    *not* been initialized with a valid address.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`NULL` 指针是常量 0。零是一个非法地址，如果您在现代操作系统下尝试访问它，会引发异常。程序通常用 `NULL` 初始化指针，以表示指针显式地*未*初始化为有效地址。'
- en: 'In addition to simple address literals and the value 0, HLA allows very simple
    constant expressions wherever a pointer constant is legal. Pointer constant expressions
    take one of the three following forms:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的地址字面量和值 0 之外，HLA 还允许在任何指针常量合法的地方使用非常简单的常量表达式。指针常量表达式有以下三种形式之一：
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The *`PureConstantExpression`* term is a numeric constant expression that does
    not involve any pointer constants. This type of expression produces a memory address
    that is the specified number of bytes before or after (`−` or `+`, respectively)
    the *`StaticVarName`* variable in memory. Note that the first two forms above
    are semantically equivalent; they both return a pointer constant whose address
    is the sum of the static variable and the constant expression.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*`PureConstantExpression`* 术语指的是不涉及任何指针常量的数字常量表达式。这种类型的表达式生成一个内存地址，该地址是 *`StaticVarName`*
    变量在内存中指定字节数之前或之后（分别为 `−` 或 `+`）。请注意，上面两种形式在语义上是等效的；它们都返回一个指针常量，其地址是静态变量和常量表达式的总和。'
- en: Because you can create pointer constant expressions, it should come as no surprise
    to discover that HLA lets you define manifest pointer constants in the `const`
    section. The program in [Example 4-5](ch04s05.html#pointer_constant_expressions_in_an_hla_p
    "Example 4-5. Pointer constant expressions in an HLA program") demonstrates how
    you can do this.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可以创建指针常量表达式，发现HLA允许你在`const`部分定义指针常量并不令人惊讶。程序在[示例 4-5](ch04s05.html#pointer_constant_expressions_in_an_hla_p
    "示例 4-5. HLA程序中的指针常量表达式")中演示了如何实现这一点。
- en: Example 4-5. Pointer constant expressions in an HLA program
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-5. HLA程序中的指针常量表达式
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Upon execution, this program prints the value of the byte just beyond `b` in
    memory (which contains the value $01).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，该程序打印出位于内存中`b`之后的字节的值（该字节的值为$01）。
- en: 4.5.4 Pointer Variables and Dynamic Memory Allocation
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5.4 指针变量与动态内存分配
- en: 'Pointer variables are the perfect place to store the return result from the
    HLA Standard Library `mem.alloc` function. The `mem.alloc` function returns the
    address of the storage it allocates in the EAX register; therefore, you can store
    the address directly into a pointer variable with a single `mov` instruction immediately
    after a call to `mem.alloc`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 指针变量是存储HLA标准库`mem.alloc`函数返回结果的理想地方。`mem.alloc`函数返回分配的存储空间的地址，存储在EAX寄存器中；因此，你可以在调用`mem.alloc`后，立即使用单条`mov`指令将地址直接存储到指针变量中：
- en: '[PRE49]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 4.5.5 Common Pointer Problems
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5.5 常见指针问题
- en: 'Programmers encounter five common problems when using pointers. Some of these
    errors will cause your programs to immediately stop with a diagnostic message;
    other problems are more subtle, yielding incorrect results without otherwise reporting
    an error or simply affecting the performance of your program without displaying
    an error. These five problems are:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员在使用指针时常常会遇到五个常见的问题。这些错误中的一些会导致程序立即停止，并显示诊断信息；其他问题则更加隐蔽，可能导致程序结果不正确，但不会报告错误，或者仅影响程序的性能，而不显示错误。以下是这五个问题：
- en: Using an uninitialized pointer
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未初始化的指针
- en: Using a pointer that contains an illegal value (e.g., `NULL`)
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包含非法值（例如，`NULL`）的指针
- en: Continuing to use `mem.alloc`'d storage after that storage has been freed
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在该存储空间被释放后，继续使用通过`mem.alloc`分配的存储空间
- en: Failing to `mem.free` storage once the program is finished using it
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序使用完存储空间后未调用`mem.free`释放该存储空间
- en: Accessing indirect data using the wrong data type
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用错误的数据类型访问间接数据
- en: The first problem above is using a pointer variable before you have assigned
    a valid memory address to the pointer. Beginning programmers often don't realize
    that declaring a pointer variable reserves storage only for the pointer itself;
    it does not reserve storage for the data that the pointer references. The short
    program in [Example 4-6](ch04s05.html#uninitialized_pointer_demonstration "Example 4-6. Uninitialized
    pointer demonstration") demonstrates this problem.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 上述第一个问题是使用指针变量时，尚未为指针分配有效的内存地址。初学者通常没有意识到，声明一个指针变量只是为指针本身保留存储空间；它并不为指针引用的数据保留存储空间。[示例
    4-6](ch04s05.html#uninitialized_pointer_demonstration "示例 4-6. 未初始化指针演示")中的简短程序演示了这个问题。
- en: Example 4-6. Uninitialized pointer demonstration
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-6. 未初始化指针演示
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Although variables you declare in the `static` section are, technically, initialized,
    static initialization still doesn't initialize the pointer in this program with
    a valid address (it initializes them with `0`, which is `NULL`).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你在`static`部分声明的变量在技术上是初始化的，但静态初始化仍然未能为该程序中的指针赋予有效地址（它们被初始化为`0`，即`NULL`）。
- en: Of course, there is no such thing as a truly uninitialized variable on the 80x86\.
    What you really have are variables that you've explicitly given an initial value
    and variables that just happen to inherit whatever bit pattern was in memory when
    storage for the variable was allocated. Much of the time, these garbage bit patterns
    lying around in memory don't correspond to a valid memory address. Attempting
    to *dereference* such a pointer (that is, access the data in memory at which it
    points) typically raises a *Memory Access Violation* exception.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在80x86中并没有真正的未初始化变量。你真正拥有的是已经显式赋予初始值的变量，以及那些恰好继承了在分配变量存储空间时内存中所存储的位模式的变量。大多数情况下，这些在内存中残留的垃圾位模式并不对应有效的内存地址。试图*解引用*这样的指针（即访问它所指向的内存中的数据）通常会引发*内存访问违规*异常。
- en: Sometimes, however, those random bits in memory just happen to correspond to
    a valid memory location you can access. In this situation, the CPU will access
    the specified memory location without aborting the program. Although to a naive
    programmer this situation may seem preferable to stopping the program, in reality
    this is far worse because your defective program continues to run without alerting
    you to the problem. If you store data through an uninitialized pointer, you may
    very well overwrite the values of other important variables in memory. This defect
    can produce some very difficult-to-locate problems in your program.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时候，内存中的随机位恰好可能对应一个有效的内存位置，你可以访问。在这种情况下，CPU会访问指定的内存位置，而不会终止程序。虽然对于一个天真的程序员来说，这种情况似乎比停止程序要好，但实际上这是更糟糕的，因为你的缺陷程序会继续运行，而不会提醒你发生了问题。如果你通过一个未初始化的指针存储数据，你很可能会覆盖内存中其他重要变量的值。这个缺陷可能会在你的程序中产生一些非常难以定位的问题。
- en: The second problem programmers have with pointers is storing invalid address
    values into a pointer. The first problem above is actually a special case of this
    second problem (with garbage bits in memory supplying the invalid address rather
    than you producing it via a miscalculation). The effects are the same; if you
    attempt to dereference a pointer containing an invalid address, either you will
    get a Memory Access Violation exception or you will access an unexpected memory
    location.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员在使用指针时的第二个问题是将无效的地址值存储到指针中。上述第一个问题实际上是第二个问题的一个特例（内存中的垃圾位提供了无效地址，而不是由于计算错误由你自己产生的）。其影响是相同的；如果你尝试解引用一个包含无效地址的指针，要么会触发内存访问违规（Memory
    Access Violation）异常，要么会访问到一个意外的内存位置。
- en: 'The third problem listed above is also known as the dangling pointer problem.
    To understand this problem, consider the following code fragment:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列出的第三个问题也被称为悬空指针问题。要理解这个问题，请考虑以下代码片段：
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this example you will note that the program allocates 256 bytes of storage
    and saves the address of that storage in the `ptr` variable. Then the code uses
    this block of 256 bytes for a while and frees the storage, returning it to the
    system for other uses. Note that calling `mem.free` does not change the value
    of `ptr` in any way; `ptr` still points at the block of memory allocated by `mem.alloc`
    earlier. Indeed, `mem.free` does not change any data in this block, so upon return
    from `mem.free`, `ptr` still points at the data stored into the block by this
    code. However, note that the call to `mem.free` tells the system that the program
    no longer needs this 256-byte block of memory and the system can use this region
    of memory for other purposes. The `mem.free` function cannot enforce the fact
    that you will never access this data again; you are simply promising that you
    won't. Of course, the code fragment above breaks this promise; as you can see
    in the last two instructions above, the program fetches the value in `ptr` and
    accesses the data it points at in memory.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你会注意到程序分配了256字节的存储空间，并将该存储空间的地址保存在`ptr`变量中。然后代码使用这一块256字节的内存一段时间，释放了存储空间，将其交还给系统以供其他用途。请注意，调用`mem.free`并不会以任何方式改变`ptr`的值；`ptr`仍然指向之前通过`mem.alloc`分配的内存块。实际上，`mem.free`并不会改变这块内存中的任何数据，因此在从`mem.free`返回后，`ptr`仍然指向代码存入该内存块的数据。然而，需要注意的是，调用`mem.free`是告诉系统程序不再需要这块256字节的内存，系统可以将这块内存用于其他用途。`mem.free`函数并不能强制保证你将永远不会再访问这些数据；你只是承诺不会这么做。当然，上述代码片段违反了这个承诺；正如你在上面的最后两条指令中看到的，程序获取了`ptr`中的值并访问了它所指向的内存数据。
- en: 'The biggest problem with dangling pointers is that you can get away with using
    them a good part of the time. As long as the system doesn''t reuse the storage
    you''ve freed, using a dangling pointer produces no ill effects in your program.
    However, with each new call to `mem.alloc`, the system may decide to reuse the
    memory released by that previous call to `mem.free`. When this happens, any attempt
    to dereference the dangling pointer may produce some unintended consequences.
    The problems range from reading data that has been overwritten (by the new, legal
    use of the data storage), to overwriting the new data, to (the worst case) overwriting
    system heap management pointers (doing so will probably cause your program to
    crash). The solution is clear: *Never use a pointer value once you free the storage
    associated with that pointer*.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 悬挂指针的最大问题是，您可以在很大一部分时间里不出问题地使用它们。只要系统没有重用您已释放的存储，使用悬挂指针对程序没有不良影响。然而，每次调用 `mem.alloc`
    时，系统可能决定重用先前通过 `mem.free` 释放的内存。当发生这种情况时，任何试图解引用悬挂指针的操作可能会导致一些意外后果。问题的范围从读取已被覆盖的数据（由数据存储的合法新用途覆盖），到覆盖新数据，再到（最糟糕的情况）覆盖系统堆管理指针（这样做可能会导致程序崩溃）。解决方案很明确：*一旦释放与指针相关联的存储，就永远不要再使用该指针值*。
- en: 'Of all the problems, the fourth (failing to free allocated storage) will probably
    have the least impact on the proper operation of your program. The following code
    fragment demonstrates this problem:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 所有问题中，第四个问题（未释放分配的存储）对程序正常运行的影响可能最小。以下代码片段演示了这个问题：
- en: '[PRE52]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example the program allocates 256 bytes of storage and references this
    storage using the `ptr` variable. At some later time the program allocates another
    block of bytes and overwrites the value in `ptr` with the address of this new
    block. Note that the former value in `ptr` is lost. Because the program no longer
    has this address value, there is no way to call `mem.free` to return the storage
    for later use. As a result, this memory is no longer available to your program.
    While making 256 bytes of memory inaccessible to your program may not seem like
    a big deal, imagine that this code is in a loop that repeats over and over again.
    With each execution of the loop the program loses another 256 bytes of memory.
    After a sufficient number of loop iterations, the program will exhaust the memory
    available on the heap. This problem is often called a *memory leak* because the
    effect is the same as though the memory bits were leaking out of your computer
    (yielding less and less available storage) during program execution.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，程序分配了 256 字节的存储，并通过 `ptr` 变量引用该存储。稍后，程序又分配了另一个内存块，并将 `ptr` 中的值覆盖为这个新内存块的地址。请注意，`ptr`
    中的原始值丢失了。由于程序不再拥有这个地址值，因此无法调用 `mem.free` 来释放存储以供后续使用。结果，这块内存不再对程序可用。虽然使 256 字节的内存对程序不可访问看起来不算大问题，但请想象这段代码在一个不断重复的循环中。每次执行循环时，程序都会丢失另外
    256 字节的内存。在足够多次的循环迭代后，程序将耗尽堆上可用的内存。这个问题通常被称为 *内存泄漏*，因为其效果就像是内存数据在程序执行过程中从计算机中“泄漏”出去（导致可用存储空间越来越少）。
- en: 'Memory leaks are far less damaging than dangling pointers. Indeed, there are
    only two problems with memory leaks: the danger of running out of heap space (which,
    ultimately, may cause the program to abort, though this is rare) and performance
    problems due to virtual memory page swapping. Nevertheless, you should get in
    the habit of always freeing all storage once you have finished using it. When
    your program quits, the operating system reclaims all storage, including the data
    lost via memory leaks. Therefore, memory lost via a leak is lost only to your
    program, not the whole system.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏的危害远小于悬挂指针。实际上，内存泄漏只有两个问题：一是堆空间耗尽的危险（最终可能导致程序中止，尽管这种情况很少发生），二是由于虚拟内存页面交换导致的性能问题。尽管如此，您应该养成在使用完所有存储后立即释放它们的习惯。当您的程序退出时，操作系统会回收所有存储，包括因内存泄漏而丢失的数据。因此，通过泄漏丢失的内存仅对您的程序丢失，而非整个系统。
- en: The last problem with pointers is the lack of type-safe access. This can occur
    because HLA cannot and does not enforce pointer type checking. For example, consider
    the program in [Example 4-7](ch04s05.html#type-unsafe_pointer_access_example "Example 4-7. Type-unsafe
    pointer access example").
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的最后一个问题是缺乏类型安全的访问。这可能是因为 HLA 无法且不强制执行指针类型检查。例如，考虑 [示例 4-7](ch04s05.html#type-unsafe_pointer_access_example
    "示例 4-7. 类型不安全的指针访问示例") 中的程序。
- en: Example 4-7. Type-unsafe pointer access example
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This program reads in data from the user as character values and then displays
    the data as double-word hexadecimal values. While a powerful feature of assembly
    language is that it lets you ignore data types at will and automatically coerce
    the data without any effort, this power is a two-edged sword. If you make a mistake
    and access indirect data using the wrong data type, HLA and the 80x86 may not
    catch the mistake and your program may produce inaccurate results. Therefore,
    you need to take care when using pointers and indirection in your programs that
    you use the data consistently with respect to data type.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 Composite Data Types
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composite data types, also known as *aggregate* data types, are those that are
    built up from other (generally scalar) data types. This chapter covers several
    of the more important composite data types—character strings, character sets,
    arrays, records, and unions. A string is a good example of a composite data type;
    it is a data structure built up from a sequence of individual characters and some
    other data.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 4.7 Character Strings
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After integer values, character strings are probably the most common data type
    that modern programs use. The 80x86 does support a handful of string instructions,
    but these instructions are really intended for block memory operations, not a
    specific implementation of a character string. Therefore, this section will concentrate
    mainly on the HLA definition of character strings and will also discuss the string-handling
    routines available in the HLA Standard Library.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, a character string is a sequence of ASCII characters that possesses
    two main attributes: a *length* and some *character data*. Different languages
    use different data structures to represent strings. To better understand the reasoning
    behind the design of HLA strings, it is probably instructive to look at two different
    string representations popularized by various high-level languages.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Without question, *zero-terminated strings* are probably the most common string
    representation in use today because this is the native string format for C, C++,
    C#, Java, and other languages. A zero-terminated string consists of a sequence
    of zero or more ASCII characters ending with a 0 byte. For example, in C/C++,
    the string `"abc"` requires 4 bytes: the three characters `''a''`, `''b''`, and
    `''c''` followed by a 0\. As you''ll soon see, HLA character strings are upward
    compatible with zero-terminated strings, but in the meantime you should note that
    it is very easy to create zero-terminated strings in HLA. The easiest place to
    do this is in the `static` section using code like the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Remember, when using the `@nostorage` option, HLA doesn't reserve any space
    for the variable, so the `zeroTerminatedString` variable's address in memory corresponds
    to the first character in the following `byte` directive. Whenever a character
    string appears in the `byte` directive as it does here, HLA emits each character
    in the string to successive memory locations. The 0 value at the end of the string
    terminates this string.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当使用 `@nostorage` 选项时，HLA 不为变量保留任何空间，因此 `zeroTerminatedString` 变量在内存中的地址对应于以下
    `byte` 指令中的第一个字符。每当字符字符串出现在 `byte` 指令中时，如同这里所示，HLA 会将字符串中的每个字符依次输出到连续的内存位置。字符串末尾的
    0 值终止了这个字符串。
- en: 'HLA supports a `zstring` data type. However, those objects are double word
    pointers that contain the address of a `zstring`, not the zero-terminated string
    itself. Here is an example of a `zstring` declaration (and static initialization):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 支持 `zstring` 数据类型。然而，这些对象是双字指针，包含一个指向 `zstring` 的地址，而不是零终止字符串本身。以下是 `zstring`
    声明（和静态初始化）的示例：
- en: '[PRE55]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Zero-terminated strings have two principal attributes: They are very simple
    to implement, and the strings can be any length. On the other hand, zero-terminated
    strings have a few drawbacks. First, though not usually important, zero-terminated
    strings cannot contain the NUL character (whose ASCII code is 0). Generally, this
    isn''t a problem, but it does create havoc once in a while. The second problem
    with zero-terminated strings is that many operations on them are somewhat inefficient.
    For example, to compute the length of a zero-terminated string, you must scan
    the entire string looking for that 0 byte (counting characters up to the 0). The
    following program fragment demonstrates how to compute the length of the string
    above:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 零终止字符串有两个主要特点：它们非常容易实现，并且字符串长度没有限制。另一方面，零终止字符串也有一些缺点。首先，虽然通常不重要，零终止字符串不能包含 NUL
    字符（其 ASCII 码为 0）。通常这不是问题，但偶尔会带来麻烦。零终止字符串的第二个问题是，许多操作相对低效。例如，为了计算零终止字符串的长度，你必须扫描整个字符串，寻找那个
    0 字节（即计算字符直到遇到 0）。下面的程序片段演示了如何计算上述字符串的长度：
- en: '[PRE56]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see from this code, the time it takes to compute the length of the
    string is proportional to the length of the string; as the string gets longer,
    it takes longer to compute its length.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从这段代码中看到的，计算字符串长度所需的时间与字符串的长度成正比；随着字符串变长，计算其长度所需的时间也会增加。
- en: 'A second string format, *length-prefixed strings*, overcomes some of the problems
    with zero-terminated strings. Length-prefixed strings are common in languages
    like Pascal; they generally consist of a length byte followed by zero or more
    character values. The first byte specifies the string length, and the following
    bytes (up to the specified length) are the character data. In a length-prefixed
    scheme, the string `abc` would consist of the 4 bytes `$03` (the string length)
    followed by `a`, `b`, and `c`. You can create length-prefixed strings in HLA using
    code like the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种字符串格式，*长度前缀字符串*，克服了零终止字符串的一些问题。长度前缀字符串在像 Pascal 这样的语言中很常见；它们通常由一个长度字节和零个或多个字符值组成。第一个字节指定字符串的长度，接下来的字节（直到指定的长度）是字符数据。在长度前缀方案中，字符串`abc`将由4个字节组成，分别是
    `$03`（字符串长度）后跟 `a`、`b` 和 `c`。你可以在 HLA 中使用如下代码创建长度前缀字符串：
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Counting the characters ahead of time and inserting them into the byte statement,
    as was done here, may seem like a major pain. Fortunately, there are ways to have
    HLA automatically compute the string length for you.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 提前计算字符数并将其插入到字节声明中，如同这里所做的那样，可能看起来是一项麻烦的工作。幸运的是，有一些方法可以让 HLA 自动计算字符串的长度。
- en: Length-prefixed strings solve the two major problems associated with zero-terminated
    strings. It is possible to include the NUL character in length-prefixed strings,
    and those operations on zero-terminated strings that are relatively inefficient
    (e.g., string length) are more efficient when using length-prefixed strings. However,
    length-prefixed strings have their own drawbacks. The principal drawback is that
    they are limited to a maximum of 255 characters in length (assuming a 1-byte length
    prefix).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 长度前缀字符串解决了与零终止字符串相关的两个主要问题。可以在长度前缀字符串中包含 NUL 字符，并且那些在零终止字符串上相对低效的操作（例如，计算字符串长度）在使用长度前缀字符串时更高效。然而，长度前缀字符串也有它们自己的缺点。主要的缺点是它们的长度最大限制为
    255 个字符（假设使用 1 字节长度前缀）。
- en: HLA uses an expanded scheme for strings that is upward compatible with both
    zero-terminated and length-prefixed strings. HLA strings enjoy the advantages
    of both zero-terminated and length-prefixed strings without the disadvantages.
    In fact, the only drawback to HLA strings over these other formats is that HLA
    strings consume a few additional bytes (the overhead for an HLA string is 9 to
    12 bytes compared to 1 byte for zero-terminated or length-prefixed strings, the
    overhead being the number of bytes needed above and beyond the actual characters
    in the string).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: An HLA string value consists of four components. The first element is a double-word
    value that specifies the maximum number of characters that the string can hold.
    The second element is a double-word value specifying the current length of the
    string. The third component is the sequence of characters in the string. The final
    component is a zero-terminating byte. You could create an HLA-compatible string
    in the `static` section using code like the following:^([[51](#ftn.CHP-4-FN-5)])
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that the address associated with the HLA string is the address of the first
    character, not the maximum or current length values.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '"So what is the difference between the current and maximum string lengths?"
    you''re probably wondering. In a literal string they are usually the same. However,
    when you allocate storage for a string variable at runtime, you will normally
    specify the maximum number of characters that can go into the string. When you
    store actual string data into the string, the number of characters you store must
    be less than or equal to this maximum value. The HLA Standard Library string routines
    will raise an exception if you attempt to exceed this maximum length (something
    the C/C++ and Pascal formats can''t do).'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The terminating 0 byte at the end of the HLA string lets you treat an HLA string
    as a zero-terminated string if it is more efficient or more convenient to do so.
    For example, most calls to Windows, Mac OS X, FreeBSD, and Linux require zero-terminated
    strings for their string parameters. Placing a 0 at the end of an HLA string ensures
    compatibility with the operating system and other library modules that use zero-terminated
    strings.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: ^([[51](#CHP-4-FN-5)]) Actually, there are some restrictions on the placement
    of HLA strings in memory. This text will not cover those issues. See the HLA documentation
    for more details.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 4.8 HLA Strings
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the previous section notes, HLA strings consist of four components: a maximum
    length, a current string length, character data, and a zero-terminating byte.
    However, HLA never requires you to create string data by manually emitting these
    components yourself. HLA is smart enough to automatically construct this data
    for you whenever it sees a string literal constant. So if you use a string constant
    like the following, understand that somewhere HLA is creating the four-component
    string in memory for you:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'HLA doesn''t actually work directly with the string data described in the previous
    section. Instead, when HLA sees a string object, it always works with a *pointer*
    to that object rather than working directly with the object. Without question,
    this is the most important fact to know about HLA strings and is the biggest source
    of problems beginning HLA programmers have with strings in HLA: *Strings are pointers!*
    A string variable consumes exactly 4 bytes, the same as a pointer (because it
    is a pointer!). Having said all that, let''s look at a simple string variable
    declaration in HLA:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Because a string variable is a pointer, you must initialize it before you can
    use it. There are three general ways you may initialize a string variable with
    a legal string address: using static initializers, using the `str.alloc` routine,
    or calling some other HLA Standard Library function that initializes a string
    or returns a pointer to a string.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'In one of the static declaration sections that allow initialized variables
    (`static` and `readonly`) you can initialize a string variable using the standard
    initialization syntax. For example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note that this does not initialize the string variable with the string data.
    Instead, HLA creates the string data structure (see [4.7 Character Strings](ch04s07.html
    "4.7 Character Strings")) in a special, hidden, memory segment and initializes
    the `InitializedString` variable with the address of the first character in this
    string (the `T` in `This`). *Remember, strings are pointers!* The HLA compiler
    places the actual string data in a read-only memory segment. Therefore, you cannot
    modify the characters of this string literal at runtime. However, because the
    string variable (a pointer, remember) is in the `static` section, you can change
    the string variable so that it points at different string data.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Because string variables are pointers, you can load the value of a string variable
    into a 32-bit register. The pointer itself points at the first character position
    of the string. You can find the current string length in the double-word 4 bytes
    prior to this address, and you can find the maximum string length in the double-word
    8 bytes prior to this address. The program in [Example 4-8](ch04s08.html#accessing_the_length_and_maximum_length
    "Example 4-8. Accessing the length and maximum length fields of a string") demonstrates
    one way to access this data.^([[52](#ftn.CHP-4-FN-6)])
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-8. Accessing the length and maximum length fields of a string
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: When accessing the various fields of a string variable, it is not wise to access
    them using fixed numeric offsets as done in [Example 4-8](ch04s08.html#accessing_the_length_and_maximum_length
    "Example 4-8. Accessing the length and maximum length fields of a string"). In
    the future, the definition of an HLA string may change slightly. In particular,
    the offsets to the maximum length and length fields are subject to change. A safer
    way to access string data is to coerce your string pointer using the `str.strRec`
    data type. The `str.strRec` data type is a `record` data type (see [4.25 Records](ch04s25.html
    "4.25 Records")) that defines symbolic names for the offsets of the length and
    maximum length fields in the `string` data type. If the offsets to the length
    and maximum length fields were to change in a future version of HLA, then the
    definitions in `str.strRec` would also change. So if you use `str.strRec`, then
    recompiling your program would automatically make any necessary changes to your
    program.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: To use the `str.strRec` data type properly, you must first load the string pointer
    into a 32-bit register; for example, `mov( SomeString, ebx );`. Once the pointer
    to the string data is in a register, you can coerce that register to the `str.strRec`
    data type using the HLA construct `(type str.strRec [ebx])`. Finally, to access
    the length or maximum length fields, you would use either `(type str.strRec [ebx]).length`
    or `(type str.strRec [ebx]).maxlen` (respectively). Although there is a little
    more typing involved (versus using simple offsets like −4 or −8), these forms
    are far more descriptive and much safer than straight numeric offsets. The program
    in [Example 4-9](ch04s08.html#correct_way_to_access_the_length_and_max "Example 4-9. Correct
    way to access the length and maxlen fields of a string") corrects the example
    in [Example 4-8](ch04s08.html#accessing_the_length_and_maximum_length "Example 4-8. Accessing
    the length and maximum length fields of a string") by using the `str.strRec` data
    type.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-9. Correct way to access the `length` and `maxlen` fields of a string
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'A second way to manipulate strings in HLA is to allocate storage on the heap
    to hold string data. Because strings can''t directly use pointers returned by
    `mem.alloc` (string operations access the 8 bytes prior to the address), you shouldn''t
    use `mem.alloc` to allocate storage for string data. Fortunately, the HLA Standard
    Library memory module provides a memory allocation routine specifically designed
    to allocate storage for strings: `str.alloc`. Like `mem.alloc`, `str.alloc` expects
    a single double-word parameter. This value specifies the maximum number of characters
    allowed in the string. The `str.alloc` routine will allocate the specified number
    of bytes of memory, plus between 9 and 13 additional bytes to hold the extra string
    information.^([[53](#ftn.CHP-4-FN-7)])'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The `str.alloc` routine will allocate storage for a string, initialize the maximum
    length to the value passed as the `str.alloc` parameter, initialize the current
    length to 0, and store a zero-terminating byte in the first character position
    of the string. After this, `str.alloc` returns the address of the zero-terminating
    byte (that is, the address of the first character element) in the EAX register.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Once you've allocated storage for a string, you can call various string-manipulation
    routines in the HLA Standard Library to manipulate the string. The next section
    discusses a few of the HLA string routines in detail; this section introduces
    a couple of string-related routines for the sake of example. The first such routine
    is the `stdin.gets(` *`strvar`* `);`. This routine reads a string from the user
    and stores the string data into the string storage pointed at by the string parameter
    (*`strvar`* in this case). If the user attempts to enter more characters than
    the maximum the string allows, then `stdin.gets` raises the `ex.StringOverflow`
    exception. The program in [Example 4-10](ch04s08.html#reading_a_string_from_the_user
    "Example 4-10. Reading a string from the user") demonstrates the use of `str.alloc`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-10. Reading a string from the user
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you look closely, you'll see a slight defect in the program above. It allocates
    storage for the string by calling `str.alloc`, but it never frees the storage
    allocated. Even though the program immediately exits after the last use of the
    string variable, and the operating system will deallocate the storage, it's always
    a good idea to explicitly free up any storage you allocate. Doing so keeps you
    in the habit of freeing allocated storage (so you don't forget to do it when it's
    important); also, programs have a way of growing such that an innocent defect
    that doesn't affect anything in today's program becomes a show-stopping defect
    in tomorrow's version.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: To free storage you allocate via `str.alloc`, you must call the `str.free` routine,
    passing the string pointer as the single parameter. The program in [Example 4-11](ch04s08.html#corrected_program_that_reads_a_string_fr
    "Example 4-11. Corrected program that reads a string from the user") is a correction
    of the program [Example 4-10](ch04s08.html#reading_a_string_from_the_user "Example 4-10. Reading
    a string from the user") with this defect corrected.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-11. Corrected program that reads a string from the user
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: When looking at this corrected program, please take note that the `stdin.gets`
    routine expects you to pass it a string parameter that points at an allocated
    string object. Without question, one of the most common mistakes beginning HLA
    programmers make is to call `stdin.gets` and pass it a string variable that they
    have not initialized. This may be getting old now, but keep in mind that *strings
    are pointers!* Like pointers, if you do not initialize a string with a valid address,
    your program will probably crash when you attempt to manipulate that string object.
    The call to `str.alloc` and the following `mov` instruction is how the programs
    above initialize the string pointer. If you are going to use string variables
    in your programs, you must ensure that you allocate storage for the string data
    prior to writing data to the string object.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Allocating storage for a string is such a common operation that many HLA Standard
    Library routines will automatically allocate the storage for you. Generally, such
    routines have an `a_` prefix as part of their name. For example, the `stdin.a_gets`
    combines a call to `str.alloc` and `stdin.gets` into the same routine. This routine,
    which doesn't have any parameters, reads a line of text from the user, allocates
    a string object to hold the input data, and then returns a pointer to the string
    in the EAX register. [Example 4-12](ch04s08.html#reading_a_string_from_the_user_with_stdi
    "Example 4-12. Reading a string from the user with stdin.a_gets") presents an
    adaptation of the two programs in [Example 4-10](ch04s08.html#reading_a_string_from_the_user
    "Example 4-10. Reading a string from the user") and [Example 4-11](ch04s08.html#corrected_program_that_reads_a_string_fr
    "Example 4-11. Corrected program that reads a string from the user") that uses
    `stdin.a_gets`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-12. Reading a string from the user with `stdin.a_gets`
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note that, as before, you must still free up the storage `stdin.a_gets` allocates
    by calling the `str.free` routine. One big difference between this routine and
    the previous two is the fact that HLA will automatically allocate exactly enough
    space for the string read from the user. In the previous programs, the call to
    `str.alloc` allocates only 16 bytes. If the user types more than 16 characters,
    then the program raises an exception and quits. If the user types fewer than 16
    characters, then some space at the end of the string is wasted. The `stdin.a_gets`
    routine, on the other hand, always allocates the minimum necessary space for the
    string read from the user. Because it allocates the storage, there is little chance
    of overflow.^([[54](#ftn.CHP-4-FN-8)])
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: ^([[52](#CHP-4-FN-6)]) Note that this scheme is not recommended. If you need
    to extract the length information from a string, use the routines provided in
    the HLA string library for this purpose.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: ^([[53](#CHP-4-FN-7)]) `str.alloc` may allocate more than 9 bytes for the overhead
    data because the memory allocated to an HLA string must always be double-word
    aligned, and the total length of the data structure must be a multiple of 4.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: ^([[54](#CHP-4-FN-8)]) Actually, there are limits on the maximum number of characters
    that `stdin.a_gets` will allocate. This is typically between 1,024 bytes and 4,096
    bytes. See the HLA Standard Library source listings and your operating system
    documentation for the exact value.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 4.9 Accessing the Characters Within a String
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extracting individual characters from a string is a very common task. It is
    so easy that HLA doesn't provide any specific procedure or language syntax to
    accomplish this—you simply use machine instructions to accomplish this. Once you
    have a pointer to the string data, a simple indexed addressing mode will do the
    rest of the work for you.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the most important thing to keep in mind is that *strings are pointers*.
    Therefore, you cannot apply an indexed addressing mode directly to a string variable
    and expect to extract characters from the string. That is, if `s` is a string
    variable, then `mov( s[ebx], al )`; does not fetch the character at position EBX
    in string `s` and place it in the AL register. Remember, `s` is just a pointer
    variable; an addressing mode like `s[ebx]` will simply fetch the byte at offset
    EBX in memory starting at the address of `s` (see [Figure 4-1](ch04s09.html#incorrectly_indexing_off_a_string_variab
    "Figure 4-1. Incorrectly indexing off a string variable")).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![Incorrectly indexing off a string variable](tagoreillycom20100401nostarchimages577979.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1. Incorrectly indexing off a string variable
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 4-1](ch04s09.html#incorrectly_indexing_off_a_string_variab "Figure 4-1. Incorrectly
    indexing off a string variable"), assuming EBX contains 3, `s[ebx]` does not access
    the fourth character in the string `s`; instead it fetches the fourth byte of
    the pointer to the string data. It is very unlikely that this is what you would
    want. [Figure 4-2](ch04s09.html#correctly_indexing_off_the_value_of_a_st "Figure 4-2. Correctly
    indexing off the value of a string variable") shows the operation that is necessary
    to fetch a character from the string, assuming EBX contains the value of `s`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![Correctly indexing off the value of a string variable](tagoreillycom20100401nostarchimages577981.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2. Correctly indexing off the value of a string variable
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 4-2](ch04s09.html#correctly_indexing_off_the_value_of_a_st "Figure 4-2. Correctly
    indexing off the value of a string variable") EBX contains the value of string
    `s`. The value of `s` is a pointer to the actual string data in memory. Therefore,
    EBX will point at the first character of the string when you load the value of
    `s` into EBX. The following code demonstrates how to access the fourth character
    of string `s` in this fashion:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If you want to load the character at a variable, rather than fixed, offset
    into the string, then you can use one of the 80x86''s scaled indexed addressing
    modes to fetch the character. For example, if an `uns32` variable `index` contains
    the desired offset into the string, you could use the following code to access
    the character at `s[index]`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'There is only one problem with the code above—it does not check to ensure that
    the character at offset `index` actually exists. If `index` is greater than the
    current length of the string, then this code will fetch a garbage byte from memory.
    Unless you can a priori determine that `index` is always less than the length
    of the string, code like this is dangerous to use. A better solution is to check
    the index against the string''s current length before attempting to access the
    character. The following code provides one way to do this:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the `else` portion of this `if` statement you could take corrective action,
    print an error message, or raise an exception. If you want to explicitly raise
    an exception, you can use the HLA `raise` statement to accomplish this. The syntax
    for the `raise` statement is
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The value of the *`integer_constant`* or 32-bit register must be an exception
    number. Usually, this is one of the predefined constants in the *excepts.hhf*
    header file. An appropriate exception to raise when a string index is greater
    than the length of the string is `ex.StringIndexError`. The following code demonstrates
    raising this exception if the string index is out of bounds:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 4.10 The HLA String Module and Other String-Related Routines
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although HLA provides a powerful definition for string data, the real power
    behind HLA's string capabilities lies in the HLA Standard Library, not in the
    definition of HLA string data. HLA provides hundreds of string-manipulation routines
    that far exceed the capabilities found in standard high-level languages like C/C++,
    Java, or Pascal; indeed, HLA's string-handling capabilities rival those in string-processing
    languages like Icon or SNOBOL4\. This chapter discusses several of the string
    functions that the HLA Standard Library provides.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most basic string operation you will need is to assign one string
    to another. There are three different ways to assign strings in HLA: by reference,
    by copying a string, and by duplicating a string. Of these, assignment by reference
    is the fastest and easiest. If you have two strings and you wish to assign one
    string to the other, a simple and fast way to do this is to copy the string pointer.
    The following code fragment demonstrates this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: String assignment by reference is very efficient because it involves only two
    simple `mov` instructions regardless of the string length. Assignment by reference
    works great if you never modify the string data after the assignment operation.
    Do keep in mind, though, that both string variables (`string1` and `string2` in
    the example above) *wind up pointing at the same data*. So if you make a change
    to the data pointed at by one string variable, you will change the string data
    pointed at by the second string object because both objects point at the same
    data. [Example 4-13](ch04s10.html#problem_with_string_assignment_by_copyin "Example 4-13. Problem
    with string assignment by copying pointers") provides a program that demonstrates
    this problem.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-13. Problem with string assignment by copying pointers
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Because both `string1` and `string2` point at the same string data in this example,
    any change you make to one string is reflected in the other. While this is sometimes
    acceptable, most programmers expect assignment to produce a different copy of
    a string; that is, they expect the semantics of string assignment to produce two
    unique copies of the string data.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: An important point to remember when using *copy by reference* (this term means
    copying a pointer) is that you have created an alias of the string data. The term
    *alias* means that you have two names for the same object in memory (for example,
    in the program above, `string1` and `string2` are two different names for the
    same string data). When you read a program, it is reasonable to expect that different
    variables refer to different memory objects. Aliases violate this rule, thus making
    your program harder to read and understand because you have to remember that aliases
    do not refer to different objects in memory. Failing to keep this in mind can
    lead to subtle bugs in your program. For instance, in the example above you have
    to remember that `string1` and `string2` are aliases so as not to free both objects
    at the end of the program. Worse still, you have to remember that `string1` and
    `string2` are aliases so that you don't continue to use `string2` after freeing
    `string1` because `string2` would be a dangling reference at that point.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'Because using copy by reference makes your programs harder to read and increases
    the possibility that you might introduce subtle defects into your programs, you
    might wonder why someone would use copy by reference at all. There are two reasons
    for this: First, copy by reference is very efficient; it involves only the execution
    of two `mov` instructions. Second, some algorithms actually depend on copy-by-reference
    semantics. Nevertheless, before using this technique you should carefully consider
    whether copying string pointers is the appropriate way to do a string assignment
    in your program.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: The second way to assign one string to another is to copy the string data. The
    HLA Standard Library `str.cpy` routine provides this capability. A call to the
    `str.cpy` procedure uses the following call syntax:^([[55](#ftn.CHP-4-FN-9)])
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The source and destination strings must be string variables (pointers) or 32-bit
    registers containing the addresses of the string data in memory.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: The `str.cpy` routine first checks the maximum length field of the destination
    string to ensure that it is at least as big as the source string's current length.
    If it is not, then `str.cpy` raises the `ex.StringOverflow` exception. If the
    destination string's maximum length is large enough, then `str.cpy` copies the
    string length, the characters, and the zero-terminating byte from the source string
    to the destination string. When this process is complete, the two strings point
    at identical data, but they do not point at the same data in memory.^([[56](#ftn.CHP-4-FN-10)])
    The program in [Example 4-14](ch04s10.html#copying_strings_using_str.cpy "Example 4-14. Copying
    strings using str.cpy") is a rework of the example in [Example 4-13](ch04s10.html#problem_with_string_assignment_by_copyin
    "Example 4-13. Problem with string assignment by copying pointers") using `str.cpy`
    rather than copy by reference.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-14. Copying strings using `str.cpy`
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: There are two important things to note about the program in [Example 4-14](ch04s10.html#copying_strings_using_str.cpy
    "Example 4-14. Copying strings using str.cpy"). First, note that this program
    begins by allocating storage for `string2`. Remember, the `str.cpy` routine does
    not allocate storage for the destination string; it assumes that the destination
    string already has storage allocated. Keep in mind that `str.cpy` does not initialize
    `string2`; it only copies data to the location where `string2` is pointing. It
    is the program's responsibility to initialize the string by allocating sufficient
    memory before calling `str.cpy`. The second thing to notice here is that the program
    calls `str.free` to free up the storage for both `string1` and `string2` before
    the program quits.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Allocating storage for a string variable prior to calling `str.cpy` is so common
    that the HLA Standard Library provides a routine that allocates and copies the
    string: `str.a_cpy`. This routine uses the following call syntax:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note that there is no destination string. This routine looks at the length of
    the source string, allocates sufficient storage, makes a copy of the string, and
    then returns a pointer to the new string in the EAX register. The program in [Example 4-15](ch04s10.html#copying_strings_using_str.a_underscore_c
    "Example 4-15. Copying strings using str.a_cpy") demonstrates how to do the same
    thing as the program in [Example 4-14](ch04s10.html#copying_strings_using_str.cpy
    "Example 4-14. Copying strings using str.cpy") using the `str.a_cpy` procedure.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-15. Copying strings using `str.a_cpy`
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Warning
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever you use copy by reference or `str.a_cpy` to assign a string, don't
    forget to free the storage associated with the string when you have (completely)
    finished with that string's data. Failure to do so may produce a memory leak if
    you do not have another pointer to the previous string data lying around.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtaining the length of a character string is so common that the HLA Standard
    Library provides a `str.length` routine specifically for this purpose. Of course,
    you can fetch the length by using the `str.strRec` data type to access the length
    field directly, but constant use of this mechanism can be tiring because it involves
    a lot of typing. The `str.length` routine provides a more compact and convenient
    way to fetch the length information. You call `str.length` using one of the following
    two formats:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This routine returns the current string length in the EAX register.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'Another pair of useful string routines is the `str.cat` and `str.a_cat` procedures.
    They use the following syntax:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: These two routines concatenate two strings (that is, they create a new string
    by joining the two strings together). The `str.cat` procedure concatenates the
    source string to the end of the destination string. Before the concatenation actually
    takes place, `str.cat` checks to make sure that the destination string is large
    enough to hold the concatenated result, and it raises the `ex.StringOverflow`
    exception if the destination string's maximum length is too small.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: The `str.a_cat` routine, as its name suggests, allocates storage for the resulting
    string before doing the concatenation. This routine will allocate sufficient storage
    to hold the concatenated result, then it will copy the `srcLStr` to the allocated
    storage, next it will append the string data pointed at by `srcRStr` to the end
    of this new string, and then it will return a pointer to the new string in the
    EAX register.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note a potential source of confusion. The `str.cat` procedure concatenates its
    first operand to the end of the second operand. Therefore, `str.cat` follows the
    standard `(src, dest)` operand format present in many HLA statements. The `str.a_cat`
    routine, on the other hand, has two source operands rather than a source operand
    and a destination operand. The `str.a_cat` routine concatenates its two operands
    in an intuitive left-to-right fashion. This is the opposite of `str.cat`. Keep
    this in mind when using these two routines.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-16](ch04s10.html#demonstration_of_str.cat_and_str.a_under "Example 4-16. Demonstration
    of str.cat and str.a_cat routines") demonstrates the use of the `str.cat` and
    `str.a_cat` routines.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-16. Demonstration of `str.cat` and `str.a_cat` routines
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `str.insert` and `str.a_insert` routines are similar to the string-concatenation
    procedures. However, the `str.insert` and `str.a_insert` routines let you insert
    one string anywhere into another string, not just at the end of the string. The
    calling sequences for these two routines are:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: These two routines insert the source string (*`src`*) into the destination string
    (*`dest`*) starting at character position *`index`*. The `str.insert` routine
    inserts the source string directly into the destination string; if the destination
    string is not large enough to hold both strings, `str.insert` raises an `ex.StringOverflow`
    exception. The `str.a_insert` routine first allocates storage for a new string
    on the heap, copies the destination string (*`src`*) to the new string, and then
    inserts the source string (*`dest`*) into this new string at the specified offset;
    `str.a_insert` returns a pointer to the new string in the EAX register.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Indexes into a string are zero based. This means that if you supply the value
    0 as the index in `str.insert` or `str.a_insert`, then these routines will insert
    the source string before the first character of the destination string. Likewise,
    if the *`index`* is equal to the length of the string, then these routines will
    simply concatenate the source string to the end of the destination string.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `index` is greater than the length of the string, the `str.insert` and
    `str.a_insert` procedures will not raise an exception; instead, they will simply
    append the source string to the end of the destination string.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'The `str.delete` and `str.a_delete` routines let you remove characters from
    a string. They use the following calling sequence:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Both routines delete *`Length`* characters starting at character position *`StartIndex`*
    in string *`strng`*. The difference between the two is that `str.delete` deletes
    the characters directly from *`strng`*, whereas `str.a_delete` first allocates
    storage and copies *`strng`* and then deletes the characters from the new string
    (leaving *`strng`* untouched). The `str.a_delete` routine returns a pointer to
    the new string in the EAX register.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The `str.delete` and `str.a_delete` routines are very forgiving with respect
    to the values you pass in *`StartIndex`* and *`Length`*. If *`StartIndex`* is
    greater than the current length of the string, these routines do not delete any
    characters from the string. If *`StartIndex`* is less than the current length
    of the string, but *`StartIndex`*+*`Length`* is greater than the length of the
    string, then these routines will delete all characters from *`StartIndex`* to
    the end of the string.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very common string operation is the need to copy a portion of a string
    to another string without otherwise affecting the source string. The `str.substr`
    and `str.a_substr` routines provide this capability. These routines use the following
    syntax:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `str.substr` routine copies *`Length`* characters, starting at position
    *`StartIndex`*, from the *`src`* string to the *`dest`* string. The dest string
    must have sufficient storage to hold the new string or `str.substr` will raise
    an `ex.StringOverflow` exception. If the *`StartIndex`* value is greater than
    the length of the string, then `str.substr` will raise an `ex.StringIndexError`
    exception. If *`StartIndex`*+*`Length`* is greater than the length of the source
    string, but *`StartIndex`* is less than the length of the string, then `str.substr`
    will extract only those characters from *`StartIndex`* to the end of the string.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: The `str.a_substr` procedure behaves in a fashion nearly identical to `str.substr`,
    except it allocates storage on the heap for the destination string. `str.a_substr`
    handles exceptions identically to `str.substr`, except it never raises a string
    overflow exception because this will never occur.^([[57](#ftn.CHP-4-FN-11)]) As
    you can probably guess by now, `str.a_substr` returns a pointer to the newly allocated
    string in the EAX register.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have been working with string data for a little while, the need will
    invariably arise to compare two strings. A first attempt at string comparison,
    using the standard HLA relational operators, will compile but not necessarily
    produce the desired result:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Remember, *strings are pointers*. This code compares the two pointers to see
    if they are equal. If they are equal, clearly the two strings are equal (because
    both `s1` and `s2` point at the exact same string data). However, the fact that
    the two pointers are different doesn''t necessarily mean that the strings are
    not equivalent. Both `s1` and `s2` could contain different values (that is, they
    point at different addresses in memory), yet the string data at those two addresses
    could be identical. Most programmers expect a string comparison for equality to
    be true if the data for the two strings is the same. Clearly a pointer comparison
    does not provide this type of comparison. To overcome this problem, the HLA Standard
    Library provides a set of string-comparison routines that will compare the string
    data, not just their pointers. These routines use the following calling sequences:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Each of these routines compares the *`src1`* string to the *`src2`* string
    and returns true (1) or false (0) in the EAX register depending on the comparison.
    For example, `str.eq( s1, s2);` returns true in EAX if `s1` is equal to `s2`.
    HLA provides a small extension that allows you to use the string-comparison routines
    within an `if` statement.^([[58](#ftn.CHP-4-FN-12)]) The following code demonstrates
    the use of some of these comparison routines within an `if` statement:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Note that the string the user enters in this example must exactly match `Hello`,
    including the use of an uppercase *H* at the beginning of the string. When processing
    user input, it is best to ignore alphabetic case in string comparisons because
    different users have different ideas about when they should be pressing the SHIFT
    key on the keyboard. An easy solution is to use the HLA case-insensitive string-comparison
    functions. These routines compare two strings, ignoring any differences in alphabetic
    case. These routines use the following calling sequences:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Other than they treat uppercase characters the same as their lowercase equivalents,
    these routines behave exactly like the former routines, returning true or false
    in EAX depending on the result of the comparison.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Like most high-level languages, HLA compares strings using *lexicographical
    ordering*. This means that two strings are equal if and only if their lengths
    are the same and the corresponding characters in the two strings are exactly the
    same. For less-than or greater-than comparisons, lexicographical ordering corresponds
    to the way words appear in a dictionary. That is, `a` is less than `b` is less
    than `c`, and so on. Actually, HLA compares the strings using the ASCII numeric
    codes for the characters, so if you are unsure whether `a` is less than a period,
    simply consult the ASCII character chart (incidentally, `a` is greater than a
    period in the ASCII character set, just in case you were wondering).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: If two strings have different lengths, lexicographical ordering worries about
    the length only if the two strings exactly match through the length of the shorter
    string. If this is the case, then the longer string is greater than the shorter
    string (and, conversely, the shorter string is less than the longer string). Note,
    however, that if the characters in the two strings do not match at all, then HLA's
    string-comparison routines ignore the length of the string; for example, `z` is
    always greater than `aaaaa`, even though it is shorter.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'The `str.eq` routine checks to see if two strings are equal. Sometimes, however,
    you might want to know whether one string *contains* another string. For example,
    you may want to know if some string contains the substring `north` or `south`
    to determine some action to take in a game. The HLA `str.index` routine lets you
    check to see if one string is contained as a substring of another. The `str.index`
    routine uses the following calling sequence:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This function returns, in EAX, the offset into *`StrToSearch`* where *`SubstrToSearchFor`*
    appears. This routine returns −1 in EAX if *`SubstrToSearchFor`* is not present
    in *`StrToSearch`*. Note that `str.index` will do a case-sensitive search. Therefore,
    the strings must exactly match. There is no case-insensitive variant of `str.index`
    you can use.^([[59](#ftn.CHP-4-FN-13)])
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: The HLA `strings` module contains hundreds of routines besides those appearing
    in this section. Space limitations and prerequisite knowledge prevent the presentation
    of all those functions here; however, this does not mean that the remaining string
    functions are unimportant. You should definitely take a look at the HLA Standard
    Library documentation to learn everything you can about the powerful HLA string
    library routines.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '^([[55](#CHP-4-FN-9)]) Warning to C/C++ users: note that the order of the operands
    is opposite that of the C Standard Library `strcpy` function.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: ^([[56](#CHP-4-FN-10)]) Unless, of course, both string pointers contained the
    same address to begin with, in which case `str.cpy` copies the string data over
    itself.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: ^([[57](#CHP-4-FN-11)]) Technically, `str.a_substr`, like all routines that
    call `mem.alloc` to allocate storage, can raise an `ex.MemoryAllocationFailure`
    exception, but this is very unlikely to occur.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: ^([[58](#CHP-4-FN-12)]) This extension is actually a little more general than
    this section describes. [Chapter 7](ch07.html "Chapter 7. LOW-LEVEL CONTROL STRUCTURES")
    explains it fully.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: ^([[59](#CHP-4-FN-13)]) However, HLA does provide routines that will convert
    all the characters in a string to one case or another. So you can make copies
    of the strings, convert all the characters in both copies to lowercase, and then
    search using these converted strings. This will achieve the same result.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 4.11 In-Memory Conversions
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HLA Standard Library''s `string` module contains dozens of routines for
    converting between strings and other data formats. Although it''s a little premature
    in this text to present a complete description of those functions, it would be
    rather criminal not to discuss at least one of the available functions: the `str.put`
    routine. This routine encapsulates the capabilities of many of the other string-conversion
    functions, so if you learn how to use this one, you''ll have most of the capabilities
    of those other routines at your disposal.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'You use the `str.put` routine in a manner very similar to the `stdout.put`
    routine. The only difference is that the `str.put` routine "writes" its data to
    a string instead of the standard output device. A call to `str.put` has the following
    syntax:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here''s an example of a call to `str.put`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Warning
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally, you would not put a newline character sequence at the end of the
    string as you would if you were printing the string to the standard output device.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: The *`destString`* parameter at the beginning of the `str.put` parameter list
    must be a string variable, and it must already have storage associated with it.
    If `str.put` attempts to store more characters than allowed into the *`destString`*
    parameter, then this function raises the `ex.StringOverflow` exception.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time you won't know the length of the string that `str.put` will
    produce. In those instances, you should allocate storage for a very large string,
    one that is much larger than you expect, and use this string object as the first
    parameter of the `str.put` call. This will prevent an exception from crashing
    your program. Generally, if you expect to produce about one screen line of text,
    then you should probably allocate at least 256 characters for the destination
    string. If you're creating longer strings, you should probably use a default of
    1,024 characters (or more, if you're going to produce *really* large strings).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: You can use the `str.put` routine to convert any data to a string that you can
    print using `stdout.put`. You will probably find this routine invaluable for common
    value-to-string conversions.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 4.12 Character Sets
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Character sets are another composite data type, like strings, built upon the
    character data type. A character set is a mathematical set of characters with
    the most important attribute being membership. That is, a character is either
    a member of a set or it is not a member of a set. The concept of sequence (for
    example, whether one character comes before another, as in a string) doesn't apply
    to character sets. Also, membership is a binary relation; a character is either
    in the set or it is not in the set; you cannot have multiple copies of the same
    character in a character set. Various operations are possible on character sets,
    including the mathematical set operations of union, intersection, difference,
    and membership test.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: HLA implements a restricted form of character sets that allows set members to
    be any of the 128 standard ASCII characters (that is, HLA's character set facilities
    do not support extended character codes in the range 128..255). Despite this restriction,
    HLA's character set facilities are very powerful and are handy when writing programs
    that work with string data. The following sections describe the implementation
    and use of HLA's character set facilities so you may take advantage of character
    sets in your own programs.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 4.13 Character Set Implementation in HLA
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different ways to represent character sets in an assembly language
    program. HLA implements character sets using an array of 128 boolean values. Each
    boolean value determines whether the corresponding character is a member of the
    character set; that is, a true boolean value indicates that the corresponding
    character is a member of the set, whereas a false value indicates that the character
    is not a member of the set. To conserve memory, HLA allocates only a single bit
    for each character in the set; therefore, HLA character sets consume 16 bytes
    of memory because there are 128 bits in 16 bytes. This array of 128 bits is organized
    in memory as shown in [Figure 4-3](ch04s13.html#bit_layout_of_a_character_set_object
    "Figure 4-3. Bit layout of a character set object").
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '![Bit layout of a character set object](tagoreillycom20100401nostarchimages577983.png.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3. Bit layout of a character set object
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Bit 0 of byte 0 corresponds to ASCII code 0 (the NUL character). If this bit
    is 1, then the character set contains the NUL character; if this bit contains
    false, then the character set does not contain the NUL character. Likewise, bit
    0 of byte 1 (the ninth bit in the 128-bit array) corresponds to the backspace
    character (ASCII code is 8). Bit 1 of byte 8 corresponds to ASCII code 65, an
    uppercase `A`. Bit 65 will contain a 1 if `A` is a current member of the character
    set; it will contain 0 if `A` is not a member of the set.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: While there are other possible ways to implement character sets, with this bit-vector
    implementation it is very easy to implement set operations such as union, intersection,
    difference comparison, and membership tests.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA supports character set variables using the `cset` data type. To declare
    a character set variable, you would use a declaration like the following:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This declaration will reserve 16 bytes of storage to hold the 128 bits needed
    to represent a set of ASCII characters.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Although it is possible to manipulate the bits in a character set using instructions
    like `and`, `or`, `xor`, and so on, the 80x86 instruction set includes several
    bit test, set, reset, and complement instructions that are nearly perfect for
    manipulating character sets. The `bt` (bit test) instruction, for example, will
    copy a single bit in memory to the carry flag. The `bt` instruction allows the
    following syntactical forms.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The first operand holds a bit number, and the second operand specifies a register
    or memory location whose bit should be copied into the carry flag. If the second
    operand is a register, the first operand must contain a value in the range 0..*n*−1,
    where *n* is the number of bits in the second operand. If the first operand is
    a constant and the second operand is a memory location, the constant must be in
    the range 0..255\. Here are some examples of these instructions:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `bt` instruction turns out to be quite useful for testing set membership.
    For example, to see if the character `A` is a member of a character set, you could
    use a code sequence like the following:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `bts` (bit test and set), `btr` (bit test and reset), and `btc` (bit test
    and complement) instructions are also useful for manipulating character set variables.
    Like the `bt` instruction, these instructions copy the specified bit into the
    carry flag; after copying the specified bit, these instructions will set (`bts`),
    reset/clear (`btr`), or complement/invert (`btc`) the specified bit. Therefore,
    you can use the `bts` instruction to add a character to a character set via set
    union (that is, it adds a character to the set if the character was not already
    a member of the set; otherwise the set is unaffected). You can use the `btr` instruction
    to remove a character from a character set via set intersection (that is, it removes
    a character from the set if and only if it was previously in the set; otherwise
    it has no effect on the set). The `btc` instruction lets you add a character to
    the set if it wasn't previously in the set; it removes the character from the
    set if it was previously a member (that is, it toggles the membership of that
    character in the set).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 4.14 HLA Character Set Constants and Character Set Expressions
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HLA supports literal character set constants. These `cset` constants make it
    easy to initialize `cset` variables at compile time and allow you to easily pass
    character set constants as procedure parameters. An HLA character set constant
    takes the following form:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The following is an example of a simple character set holding the numeric digit
    characters:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'When specifying a character set literal that has several contiguous values,
    HLA lets you concisely specify the values using only the starting and ending values
    of the range thusly:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You may combine characters and various ranges within the same character set
    constant. For example, the following character set constant is all the alphanumeric
    characters:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'You can use these `cset` literal constants as initializers in the `const` and
    `val` sections. The following example demonstrates how to create the symbolic
    constant `AlphaNumeric` using the character set above:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: After the above declaration, you can use the identifier `AlphaNumeric` anywhere
    the character set literal is legal.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use character set literals (and, of course, character set symbolic
    constants) as the initializer field for a `static` or `readonly` variable. The
    following code fragment demonstrates this:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Anywhere you can use a character set literal constant, a character set constant
    expression is also legal. [Table 4-2](ch04s14.html#hla_character_set_operators
    "Table 4-2. HLA Character Set Operators") shows the operators that HLA supports
    in character set constant expressions.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-2. HLA Character Set Operators
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
- en: '| `CSetConst1 + CSetConst2` | Computes the union of the two sets. The set union
    is the set of all characters that are in either set. |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
- en: '| `CSetConst1 * CSetConst2` | Computes the intersection of the two sets. The
    set intersection is the set of all characters that appear in both operand sets.
    |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
- en: '| `CSetConst1 - CSetConst2` | Computes the set difference of the two sets.
    The set difference is the set of characters that appear in the first set but do
    not appear in the second set. |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
- en: '| `-CSetConst` | Computes the set complement. The set complement is the set
    of all characters not in the set. |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
- en: Note that these operators produce only compile-time results. That is, the expressions
    above are computed by the compiler during compilation; they do not emit any machine
    code. If you want to perform these operations on two different sets while your
    program is running, the HLA Standard Library provides routines you can call to
    achieve the results you desire. HLA also provides other compile-time character
    set operators.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 4.15 Character Set Support in the HLA Standard Library
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HLA Standard Library provides several character set routines you may find
    useful. The character set support routines fall into four categories: standard
    character set functions, character set tests, character set conversions, and character
    set I/O. This section describes these routines in the HLA Standard Library.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, let's consider the Standard Library routines that help you construct
    character sets. These routines include `cs.empty`, `cs.cpy`, `cs.charToCset`,
    `cs.unionChar`, `cs.removeChar`, `cs.rangeChar`, `cs.strToCset`, and `cs.unionStr`.
    These procedures let you build up character sets at runtime using character and
    string objects.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.empty` procedure initializes a character set variable with the empty
    set by setting all the bits in the character set to 0\. This procedure call uses
    the following syntax (*`CSvar`* is a character set variable):'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The `cs.cpy` procedure copies one character set to another, replacing any data
    previously held by the destination character set. The syntax for `cs.cpy` is:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The `cs.cpy` source character set can be either a character set constant or
    a character set variable. The destination character set must be a character set
    variable.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.unionChar` procedure adds a character to a character set. It uses the
    following calling sequence:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This call will add the first parameter, a character, to the set via set union.
    Note that you could use the `bts` instruction to achieve this same result; however,
    the `cs.unionChar` call is often more convenient. The character value must be
    in the range #0..#127.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.charToCset` function creates a singleton set (a set containing a single
    character). The calling format for this function is:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The first operand, the character value *`CharValue`*, can be an 8-bit register,
    a constant, or a character variable that holds a value in the range #0..#127\.
    The second operand (*`CSvar`*) must be a character set variable. This function
    clears the destination character set to all zeros and then unions the specified
    character into the character set.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.removeChar` procedure lets you remove a single character from a character
    set without affecting the other characters in the set. This function uses the
    same syntax as `cs.charToCset`, and the parameters have the same attributes. The
    calling sequence is:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Note that if the character was not in the *`CSVar`* set to begin with, `cs.removeChar`
    will not affect the set. This function roughly corresponds to the `btr` instruction.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.rangeChar` constructs a character set containing all the characters
    between two characters you pass as parameters. This function sets all bits outside
    the range of these two characters to 0\. The calling sequence is:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The *`LowerBoundChar`* and *`UpperBoundChar`* parameters can be constants,
    registers, or character variables. The values held in *`LowerBoundChar`* and *`UpperBoundChar`*
    must be in the range #0..#127\. `CSVar`, the destination character set, must be
    a `cset` variable.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.strToCset` procedure creates a new character set containing the union
    of all the characters in a character string. This procedure begins by setting
    the destination character set to the empty set, and then it unions in the characters
    in the string one by one until it exhausts all characters in the string. The calling
    sequence is:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Technically, the *`StringValue`* parameter can be a string constant as well
    as a string variable; however, it doesn't make any sense to call `cs.strToCset`
    this way because `cs.cpy` is a much more efficient way to initialize a character
    set with a constant set of characters. As usual, the destination character set
    must be a `cset` variable. Typically, you'd use this function to create a character
    set based on a string input by the user.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.unionStr` procedure will add the characters in a string to an existing
    character set. Like `cs.strToCset`, you''d normally use this function to union
    characters into a set based on a string input by the user. The calling sequence
    for this is:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Standard set operations include union, intersection, and set difference. The
    HLA Standard Library routines `cs.setunion`, `cs.intersection`, and `cs.difference`
    provide these operations, respectively.^([[60](#ftn.CHP-4-FN-14)]) These routines
    all use the same calling sequence:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The first parameter can be a character set constant or a character set variable.
    The second parameter must be a character set variable. These procedures compute
    *`destCset`* `:=` *`destCset op srcCset`* where *`op`* represents set union, intersection,
    or difference, depending on the function call.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: The third category of character set routines test character sets in various
    ways. They typically return a boolean value indicating the result of the test.
    The HLA character set routines in this category include `cs.IsEmpty`, `cs.member`,
    `cs.subset`, `cs.psubset`, `cs.superset`, `cs.psuperset`, `cs.eq`, and `cs.ne`.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.IsEmpty` function tests a character set to see if it is the empty set.
    The function returns true or false in the EAX register. This function uses the
    following calling sequence:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The single parameter may be a constant or a character set variable, although
    it doesn't make much sense to pass a character set constant to this procedure
    (because you would know at compile time whether this set is empty).
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.member` function tests to see if a character value is a member of a
    set. This function returns true in the EAX register if the character is a member
    of the set. Note that you can use the `bt` instruction to test this same condition.
    However, the `cs.member` function is probably a little more convenient to use
    if the character argument is not a constant. The calling sequence for `cs.member`
    is:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The first parameter is an 8-bit register, character variable, or a constant.
    The second parameter is either a character set constant or a character set variable.
    It would be unusual for both parameters to be constants.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.subset`*,* `cs.psubset` (proper subset), `cs.superset`*,* and `cs.psuperset`
    (proper superset) functions let you check to see if one character set is a subset
    or superset of another. The calling sequence for these four routines is nearly
    identical; it is one of the following:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: These routines compare the first parameter against the second parameter and
    return true or false in the EAX register depending upon the result. One set is
    a subset of another if all the members of the first character set are present
    in the second character set. It is a proper subset if the second (right) character
    set also contains characters not found in the first (left) character set. Likewise,
    one character set is a superset of another if it contains all the characters in
    the second set (and possibly more). A proper superset contains additional characters
    beyond those found in the second set. The parameters can be either character set
    variables or character set constants; however, it would be unusual for both parameters
    to be character set constants (because you can determine this at compile time,
    there would be no need to call a runtime function to compute this).
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.eq` and `cs.ne` functions check to see if two sets are equal or not
    equal. These functions return true or false in EAX depending upon the set comparison.
    The calling sequence is identical to the sub/superset functions above:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Note that there are no functions that test for less than, less than or equal,
    greater than, or greater than or equal. The subset and proper subset functions
    are the equivalent of less than or equal and less than (respectively); likewise,
    the superset and proper superset functions are equivalent to greater than or equal
    and greater than (respectively).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cs.extract` routine removes an arbitrary character from a character set
    and returns that character in the EAX register.^([[61](#ftn.CHP-4-FN-15)]) The
    calling sequence is the following:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The single parameter must be a character set variable. Note that this function
    will modify the character set variable by removing some character from the character
    set. This function returns $FFFF_FFFF (−1) in EAX if the character set was empty
    prior to the call.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the routines found in the `cset.hhf` (character set) library
    module, the string and standard output modules also provide functions that allow
    or expect character set parameters. For example, if you supply a character set
    value as a parameter to `stdout.put`, the `stdout.put` routine will print the
    characters currently in the set. See the HLA Standard Library documentation for
    more details on character set-handling procedures.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: ^([[60](#CHP-4-FN-14)]) `cs.setunion` was used rather than `cs.union` because
    *union* is an HLA reserved word.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: ^([[61](#CHP-4-FN-15)]) This routine returns the character in AL and zeros out
    the H.O. 3 bytes of EAX.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: 4.16 Using Character Sets in Your HLA Programs
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Character sets are valuable for many different purposes in your programs. For
    example, one common use of character sets is to validate user input. This section
    will also present a couple of other applications for character sets to help you
    start thinking about how you could use them in your program.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following short code segment that gets a yes/no-type answer from
    the user:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'A major problem with this code sequence is that it will stop only if the user
    types a lowercase *n* character. If the user types anything other than *n* (including
    uppercase *N*), the program will treat this as an affirmative answer and transfer
    back to the beginning of the `repeat..until` loop. A better solution would be
    to validate the user input before the `until` clause above to ensure that the
    user has only typed *n*, *N*, *y*, or *Y*. The following code sequence will accomplish
    this:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 4.17 Arrays
  id: totrans-519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with strings, arrays are probably the most commonly used composite data.
    Yet most beginning programmers don't understand how arrays operate internally
    and their associated efficiency trade-offs. It's surprising how many novice (and
    even advanced!) programmers view arrays from a completely different perspective
    once they learn how to deal with arrays at the machine level.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: Abstractly, an array is an aggregate data type whose members (elements) are
    all the same type. Selection of a member from the array is by an integer index.^([[62](#ftn.CHP-4-FN-16)])
    Different indices select unique elements of the array. This text assumes that
    the integer indices are contiguous (though this is by no means required). That
    is, if the number *x* is a valid index into the array and *y* is also a valid
    index, with *x* < *y*, then all *i* such that *x* < *i* < *y* are valid indices.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you apply the indexing operator to an array, the result is the specific
    array element chosen by that index. For example, *`A`*`[`*`i`*`]` chooses the
    *i*th element from array `A`. Note that there is no formal requirement that element
    *`i`* be anywhere near element *`i`*`+1` in memory. As long as *`A`*`[`*`i`*`]`
    always refers to the same memory location and *`A`*`[`*`i+1`*`]` always refers
    to its corresponding location (and the two are different), the definition of an
    array is satisfied.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: In this text, we assume that array elements occupy contiguous locations in memory.
    An array with five elements will appear in memory as [Figure 4-4](ch04s17.html#array_layout_in_memory
    "Figure 4-4. Array layout in memory") shows.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '![Array layout in memory](tagoreillycom20100401nostarchimages577985.png)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4. Array layout in memory
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: The *base address* of an array is the address of the first element on the array
    and always appears in the lowest memory location. The second array element directly
    follows the first in memory, the third element follows the second, and so on.
    Note that there is no requirement that the indices start at 0\. They may start
    with any number as long as they are contiguous. However, for the purposes of discussion,
    this book will start all indexes at 0.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: 'To access an element of an array, you need a function that translates an array
    index to the address of the indexed element. For a single-dimensional array, this
    function is very simple. It is:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: where *`Initial_Index`* is the value of the first index in the array (which
    you can ignore if 0) and the value *`Element_Size`* is the size, in bytes, of
    an individual array element.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: ^([[62](#CHP-4-FN-16)]) Or it could be some value whose underlying representation
    is integer, such as character, enumerated, and boolean types.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: 4.18 Declaring Arrays in Your HLA Programs
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you can access elements of an array, you need to set aside storage for
    that array. Fortunately, array declarations build on the declarations you''ve
    already seen. To allocate `n` elements in an array, you would use a declaration
    like the following in one of the variable declaration sections:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '*`ArrayName`* is the name of the array variable and *`basetype`* is the type
    of an element of that array. This sets aside storage for the array. To obtain
    the base address of the array, just use *`ArrayName`*.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: The `[n]` suffix tells HLA to duplicate the object `n` times. Now let's look
    at some specific examples.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'These examples all allocate storage for uninitialized arrays. You may also
    specify that the elements of the arrays be initialized using declarations like
    the following in the `static` and `readonly` sections:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: These definitions both create arrays with eight elements. The first definition
    initializes each 4-byte real value to 1.0, the second declaration initializes
    each `int32` element to 1\. Note that the number of constants within the square
    brackets must exactly match the size of the array.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: 'This initialization mechanism is fine if you want each element of the array
    to have the same value. What if you want to initialize each element of the array
    with a (possibly) different value? No sweat, just specify a different set of values
    in the list surrounded by the square brackets in the example above:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 4.19 HLA Array Constants
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last few examples in the previous section demonstrate the use of HLA array
    constants. An HLA array constant is nothing more than a list of values surrounded
    by a pair of brackets. The following are all legal array constants:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: (Note that this last array constant contains four double-word pointers to the
    four HLA strings appearing elsewhere in memory.)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in the previous section, you can use array constants in the `static`
    and `readonly` sections to provide initial values for array variables. The number
    of comma-separated items in an array constant must exactly match the number of
    array elements in the variable declaration. Likewise, the type of each of the
    array constant's elements must match the array variable's declared base type.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: 'Using array constants to initialize small arrays is very convenient. Of course,
    if your array has several thousand elements, entering them will be tedious. Most
    arrays initialized this way have no more than a couple hundred entries and generally
    far less than 100\. It is reasonable to use an array constant to initialize such
    variables. However, at some point initializing arrays in this manner will become
    far too tedious and error prone. You probably would not want to manually initialize
    an array with 1,000 different elements using an array constant. However, if you
    want to initialize all the elements of an array with the same value, HLA does
    provide a special array constant syntax for doing so. Consider the following declaration:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'This declaration creates a 1,000-element integer array initializing each element
    to one. The `1000 dup [ 1 ]` expression tells HLA to create an array constant
    by duplicating the single value `[ 1 ]` one thousand times. You can even use the
    `dup` operator to duplicate a series of values (rather than a single value), as
    the following example indicates:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This example initializes `SixteenInts` with four copies of the sequence `1,2,3,4`,
    yielding a total of 16 different integers (i.e., 1, 2, 3, 4, 1, 2, 3, 4, 1, 2,
    3, 4, 1, 2, 3, 4).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: You will see some more possibilities with the `dup` operator when looking at
    multidimensional arrays in [4.22 Multidimensional Arrays](ch04s22.html "4.22 Multidimensional
    Arrays").
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 4.20 Accessing Elements of a Single-Dimensional Array
  id: totrans-554
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To access an element of a zero-based array, you can use the simplified formula
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'For the *`Base_Address`* entry you can use the name of the array (because HLA
    associates the address of the first element of an array with the name of that
    array). The *`Element_Size`* entry is the number of bytes for each array element.
    If the object is an array of bytes, the *`Element_Size`* field is 1 (resulting
    in a very simple computation). If each element of the array is a word (or other
    2-byte type), then *`Element_Size`* is 2, and so on. To access an element of the
    `SixteenInts` array in the previous section, you''d use the following formula
    (the size is 4 because each element is an *`int32`* object):'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The 80x86 code equivalent to the statement `eax :=` *`SixteenInts`*`[`*`index`*`]`
    is
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: There are two important things to notice here. First of all, this code uses
    the `shl` instruction rather than the `intmul` instruction to compute `4*index`.
    The main reason for choosing `shl` is that it was more efficient. It turns out
    that `shl` is a *lot* faster than `intmul` on many processors.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: The second thing to note about this instruction sequence is that it does not
    explicitly compute the sum of the base address plus the index times 4\. Instead,
    it relies on the indexed addressing mode to implicitly compute this sum. The instruction
    `mov( SixteenInts[ ebx ], eax );` loads EAX from location `SixteenInts + ebx`,
    which is the base address plus `index*4` (because EBX contains `index*4`). Sure,
    you could have used
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: in place of the previous sequence, but why use five instructions where three
    will do the same job? This is a good example of why you should know your addressing
    modes inside and out. Choosing the proper addressing mode can reduce the size
    of your program, thereby speeding it up.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, as long as we''re discussing efficiency improvements, it''s worth
    pointing out that the 80x86 scaled indexed addressing modes let you automatically
    multiply an index by 1, 2, 4, or 8\. Because this current example multiplies the
    index by 4, we can simplify the code even more by using the scaled indexed addressing
    mode:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Note, however, that if you need to multiply by some constant other than 1, 2,
    4 or 8, then you cannot use the scaled indexed addressing modes. Similarly, if
    you need to multiply by some element size that is not a power of 2, you will not
    be able to use the `shl` instruction to multiply the index by the element size;
    instead, you will have to use `intmul` or some other instruction sequence to do
    the multiplication.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: The indexed addressing mode on the 80x86 is a natural for accessing elements
    of a single-dimensional array. Indeed, its syntax even suggests an array access.
    The important thing to keep in mind is that you must remember to multiply the
    index by the size of an element. Failure to do so will produce incorrect results.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 4.21 Sorting an Array of Values
  id: totrans-569
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every textbook on this planet gives an example of a sort when introducing
    arrays. Because you've probably seen how to do a sort in high-level languages
    already, it's probably instructive to take a quick look at a sort in HLA. The
    example code in this section will use a variant of the bubble sort, which is great
    for short lists of data and lists that are nearly sorted but horrible for just
    about everything else.^([[63](#ftn.CHP-4-FN-17)])
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The bubble sort works by comparing adjacent elements in an array. The interesting
    thing to note in this code fragment is how it compares adjacent elements. You
    will note that the `if` statement compares EAX (which contains `DataToSort[ebx*4]`)
    against `DataToSort[ebx*4 + 4]`. Because each element of this array is 4 bytes
    (`uns32`), the index `[ebx*4 + 4]` references the next element beyond `[ebx*4]`.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: As is typical for a bubble sort, this algorithm terminates if the innermost
    loop completes without swapping any data. If the data is already presorted, then
    the bubble sort is very efficient, making only one pass over the data. Unfortunately,
    if the data is not sorted (worst case, if the data is sorted in reverse order),
    then this algorithm is extremely inefficient. Indeed, although it is possible
    to modify the code above so that, on the average, it runs about twice as fast,
    such optimizations are wasted on such a poor algorithm. However, the bubble sort
    is very easy to implement and understand (which is why introductory texts continue
    to use it in examples).
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: ^([[63](#CHP-4-FN-17)]) Fear not, you'll see some better sorting algorithms
    in [Chapter 5](ch05.html "Chapter 5. PROCEDURES AND UNITS").
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: 4.22 Multidimensional Arrays
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The 80x86 hardware can easily handle single-dimensional arrays. Unfortunately,
    there is no magic addressing mode that lets you easily access elements of multidimensional
    arrays. That's going to take some work and several instructions.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: Before discussing how to declare or access multidimensional arrays, it would
    be a good idea to figure out how to implement them in memory. The first problem
    is to figure out how to store a multidimensional object into a one-dimensional
    memory space.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: Consider for a moment a Pascal array of the form `A:array[0..3,0..3] of char;`.
    This array contains 16 bytes organized as four rows of four characters. Somehow
    you've got to draw a correspondence with each of the 16 bytes in this array and
    16 contiguous bytes in main memory. [Figure 4-5](ch04s22.html#mapping_a_4x4_array_to_sequential_memory
    "Figure 4-5. Mapping a 4x4 array to sequential memory locations") shows one way
    to do this.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '![Mapping a 4x4 array to sequential memory locations](tagoreillycom20100401nostarchimages577987.png)'
  id: totrans-580
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5. Mapping a 4x4 array to sequential memory locations
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual mapping is not important as long as two things occur: (1) Each element
    maps to a unique memory location (that is, no two entries in the array occupy
    the same memory locations), and (2) the mapping is consistent. That is, a given
    element in the array always maps to the same memory location. So what you really
    need is a function with two input parameters (row and column) that produces an
    offset into a linear array of 16 memory locations.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: 'Now any function that satisfies the above constraints will work fine. Indeed,
    you could randomly choose a mapping as long as it was consistent. However, what
    you really want is a mapping that is efficient to compute at runtime and works
    for any size array (not just 4x4 or even limited to two dimensions). While a large
    number of possible functions fit this bill, there are two functions in particular
    that most programmers and high-level languages use: *row-major ordering* and *column-major
    ordering*.'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: 4.22.1 Row-Major Ordering
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Row-major ordering assigns successive elements, moving across the rows and then
    down the columns, to successive memory locations. This mapping is demonstrated
    in [Figure 4-6](ch04s22.html#row-major_array_element_ordering "Figure 4-6. Row-major
    array element ordering").
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '![Row-major array element ordering](tagoreillycom20100401nostarchimages577989.png)'
  id: totrans-586
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6. Row-major array element ordering
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Row-major ordering is the method most high-level programming languages employ.
    It is very easy to implement and use in machine language. You start with the first
    row (row 0) and then concatenate the second row to its end. You then concatenate
    the third row to the end of the list, then the fourth row, and so on (see [Figure 4-7](ch04s22.html#another_view_of_row-major_ordering_for_a
    "Figure 4-7. Another view of row-major ordering for a 4×4 array")).
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '![Another view of row-major ordering for a 4×4 array](tagoreillycom20100401nostarchimages577991.png.jpg)'
  id: totrans-589
  prefs: []
  type: TYPE_IMG
- en: Figure 4-7. Another view of row-major ordering for a 4×4 array
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual function that converts a list of index values into an offset is
    a slight modification of the formula for computing the address of an element of
    a single-dimensional array. The formula to compute the offset for a two-dimensional
    row-major ordered array is:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'As usual, *`Base_Address`* is the address of the first element of the array
    (`A[0][0]` in this case), and *`Element_Size`* is the size of an individual element
    of the array, in bytes. *`colindex`* is the leftmost index, and *`rowindex`* is
    the rightmost index into the array. *`row_size`* is the number of elements in
    one row of the array (four, in this case, because each row has four elements).
    Assuming *`Element_Size`* is 1, this formula computes the following offsets from
    the base address:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'For a three-dimensional array, the formula to compute the offset into memory
    is the following:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '*`col_size`* is the number of items in a column, and `row_size` is the number
    of items in a row. In C/C++, if you''ve declared the array as *`type`* `A[i] [j]
    [k];`, then *`row_size`* is equal to `k` and *`col_size`* is equal to `j`.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: 'For a four-dimensional array, declared in C/C++ as *`type`* `A[i] [j] [k] [m];`,
    the formula for computing the address of an array element is:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '*`depth_size`* is equal to `j`, *`col_size`* is equal to `k`, and *`row_size`*
    is equal to `m`. *`LeftIndex`* represents the value of the leftmost index.'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: By now you're probably beginning to see a pattern. There is a generic formula
    that will compute the offset into memory for an array with *any* number of dimensions;
    however, you'll rarely use more than four.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: 'Another convenient way to think of row-major arrays is as arrays of arrays.
    Consider the following single-dimensional Pascal array definition:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Assume that *`sometype`* is the type *`sometype`* `= array [0..3] of char;`.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '`A` is a single-dimensional array. Its individual elements happen to be arrays,
    but you can safely ignore that for the time being. The formula to compute the
    address of an element of a single-dimensional array is:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: In this case *`Element_Size`* happens to be 4 because each element of *`A`*
    is an array of four characters. So what does this formula compute? It computes
    the base address of each row in this 4x4 array of characters (see [Figure 4-8](ch04s22.html#viewing_a_4x4_array_as_an_array_of_array
    "Figure 4-8. Viewing a 4x4 array as an array of arrays")).
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing a 4x4 array as an array of arrays](tagoreillycom20100401nostarchimages577993.png)'
  id: totrans-608
  prefs: []
  type: TYPE_IMG
- en: Figure 4-8. Viewing a 4x4 array as an array of arrays
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: Of course, once you compute the base address of a row, you can reapply the single-dimensional
    formula to get the address of a particular element. While this doesn't affect
    the computation, it's probably a little easier to deal with several single-dimensional
    computations rather than a complex multidimensional array computation.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a Pascal array defined as `A:array [0..3] [0..3] [0..3] [0..3] [0..3]
    of char;`. You can view this five-dimensional array as a single-dimensional array
    of arrays. The following HLA code provides such a definition:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The size of `OneD` is 4 bytes. Because `TwoD` contains four `OneD` arrays,
    its size is 16 bytes. Likewise, `ThreeD` is four `TwoD`s, so it is 64 bytes long.
    Finally, `FourD` is four `ThreeDs`, so it is 256 bytes long. To compute the address
    of `A [b, c, d, e, f]`, you could use the following steps:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: Compute the address of `A [b]` as *`Base`* `+ b *` *`size`*. Here size is 256
    bytes. Use this result as the new base address in the next computation.
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute the address of `A [b, c]` by the formula *`Base`* `+ c *` *`size`*,
    where *`Base`* is the value obtained in the previous step and *`size`* is 64\.
    Use the result as the new base in the next computation.
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute the base address of `A [b, c, d]` by *`Base`* `+ d *` *`size`*, with
    *`Base`* coming from the previous computation and *`size`* is 16\. Use the result
    as the new base in the next computation.
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute the address of `A [b, c, d, e]` with the formula *`Base`* `+ e *` *`size`*,
    with *`Base`* from the previous step with a size of 4\. Use this value as the
    base for the next computation.
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, compute the address of `A [b, c, d, e, f]` using the formula *`Base`*
    `+ f *` *`size`*, where *`Base`* comes from the previous computation and *`size`*
    is 1 (obviously you can simply ignore this final multiplication). The result you
    obtain at this point is the address of the desired element.
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the main reasons you won't find higher-dimensional arrays in assembly
    language is that assembly language emphasizes the inefficiencies associated with
    such access. It's easy to enter something like `A [b, c, d, e, f]` into a Pascal
    program, not realizing what the compiler is doing with the code. Assembly language
    programmers are not so cavalier—they see the mess you wind up with when you use
    higher-dimensional arrays. Indeed, good assembly language programmers try to avoid
    two-dimensional arrays and often resort to tricks in order to access data in such
    an array when its use becomes absolutely mandatory.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: 4.22.2 Column-Major Ordering
  id: totrans-620
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Column-major ordering is the other function high-level languages frequently
    used to compute the address of an array element. FORTRAN and various dialects
    of BASIC (e.g., older versions of Microsoft BASIC) use this method.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: In row-major ordering the rightmost index increases the fastest as you move
    through consecutive memory locations. In column-major ordering the leftmost index
    increases the fastest. Pictorially, a column-major ordered array is organized
    as shown in [Figure 4-9](ch04s22.html#column-major_array_element_ordering "Figure 4-9. Column-major
    array element ordering").
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: '![Column-major array element ordering](tagoreillycom20100401nostarchimages577995.png)'
  id: totrans-623
  prefs: []
  type: TYPE_IMG
- en: Figure 4-9. Column-major array element ordering
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula for computing the address of an array element when using column-major
    ordering is very similar to that for row-major ordering. You simply reverse the
    indexes and sizes in the computation:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 4.23 Allocating Storage for Multidimensional Arrays
  id: totrans-627
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have an *`m`* x *`n`* array, it will have *`m`* * *`n`* elements and
    require *`m`* * *`n`* * *`Element_Size`* bytes of storage. To allocate storage
    for an array you must reserve this memory. As usual, there are several different
    ways of accomplishing this task. Fortunately, HLA''s array-declaration syntax
    is very similar to high-level language array-declaration syntax, so C/C++, Java,
    BASIC, and Pascal programmers will feel right at home. To declare a multidimensional
    array in HLA, you use a declaration like the following:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'For example, here is a declaration for a 4x4 array of characters:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Here is another example that shows how to declare a three-dimensional array
    of strings:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Remember, string objects are really pointers, so this array declaration reserves
    storage for 18 double-word pointers (2 * 3 * 3 = 18).
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: 'As was the case with single-dimensional arrays, you may initialize every element
    of the array to a specific value by following the declaration with the assignment
    operator and an array constant. Array constants ignore dimension information;
    all that matters is that the number of elements in the array constant corresponds
    to the number of elements in the actual array. The following example shows the
    `GameGrid` declaration with an initializer:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Note that HLA ignores the indentation and extra whitespace characters (e.g.,
    newlines) appearing in this declaration. It was laid out to enhance readability
    (which is always a good idea). HLA does not interpret the four separate lines
    as representing rows of data in the array. Humans do, which is why it's good to
    write the data in this manner. All that matters is that there are 16 (4 * 4) characters
    in the array constant. You'll probably agree that this is much easier to read
    than
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Of course, if you have a large array, an array with really large rows, or an
    array with many dimensions, there is little hope for winding up with something
    readable. That's when comments that carefully explain everything come in handy.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: 'As for single-dimensional arrays, you can use the `dup` operator to initialize
    each element of a large array with the same value. The following example initializes
    a 256x64 array of bytes so that each byte contains the value $FF:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Note the use of a constant expression to compute the number of array elements
    rather than simply using the constant 16,384 (256 * 64). The use of the constant
    expression more clearly suggests that this code is initializing each element of
    a 256x64 element array than does the simple literal constant 16,384.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: 'Another HLA trick you can use to improve the readability of your programs is
    to use *nested array constants*. The following is an example of an HLA nested
    array constant:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Whenever HLA encounters an array constant nested inside another array constant,
    it simply removes the brackets surrounding the nested array constant and treats
    the whole constant as a single-array constant. For example, HLA converts this
    nested array constant to the following:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'You can take advantage of this fact to help make your programs a little more
    readable. For multidimensional array constants you can enclose each row of the
    constant in square brackets to denote that the data in each row is grouped and
    separate from the other rows. Consider the following declaration for the `GameGrid`
    array that is identical (as far as HLA is concerned) to the earlier declaration
    for `GameGrid`:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: This declaration makes it clearer that the array constant is a 4x4 array rather
    than just a 16-element one-dimensional array whose elements wouldn't fit all on
    one line of source code. Little aesthetic improvements like this are what separate
    mediocre programmers from good programmers.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: 4.24 Accessing Multidimensional Array Elements in Assembly Language
  id: totrans-650
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, you've seen the formulas for computing the address of a multidimensional
    array element. Now it's time to see how to access elements of those arrays using
    assembly language.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: The `mov`, `shl`, and `intmul` instructions make short work of the various equations
    that compute offsets into multidimensional arrays. Let's consider a two-dimensional
    array first.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Note that this code does *not* require the use of a two-register addressing
    mode on the 80x86\. Although an addressing mode like `TwoD[ebx][esi]` looks like
    it should be a natural for accessing two-dimensional arrays, that isn't the purpose
    of this addressing mode.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider a second example that uses a three-dimensional array:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Note that this code uses the `intmul` instruction to multiply the value in EBX
    by 5\. Remember, the `shl` instruction can only multiply a register by a power
    of 2\. While there are ways to multiply the value in a register by a constant
    other than a power of 2, the `intmul` instruction is more convenient.^([[64](#ftn.CHP-4-FN-18)])
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: ^([[64](#CHP-4-FN-18)]) A full discussion of multiplication by constants other
    than a power of 2 appears in [Chapter 4](ch04.html "Chapter 4. CONSTANTS, VARIABLES,
    AND DATA TYPES").
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: 4.25 Records
  id: totrans-660
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another major composite data structure is the Pascal record or C/C++/C# structure.^([[65](#ftn.CHP-4-FN-19)])
    The Pascal terminology is probably better, because it tends to avoid confusion
    with the more general term *data structure*. Because HLA uses the term *record*,
    we'll adopt that term here.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: Whereas an array is homogeneous, whose elements are all the same type, the elements
    in a record can have different types. Arrays let you select a particular element
    via an integer index. With records, you must select an element (known as a *field*)
    by name.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole purpose of a record is to let you encapsulate different, though logically
    related, data into a single package. The Pascal record declaration for a student
    is a typical example:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Most Pascal compilers allocate each field in a record to contiguous memory locations.
    This means that Pascal will reserve the first 65 bytes for the name,^([[66](#ftn.CHP-4-FN-20)])
    the next 2 bytes hold the major code, the next 12 bytes hold the Social Security
    number, and so on.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: 'In HLA, you can also create record types using the `record`/`endrecord` declaration.
    You would encode the above record in HLA as follows:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: As you can see, the HLA declaration is very similar to the Pascal declaration.
    Note that, to be true to the Pascal declaration, this example uses character arrays
    rather than strings for the `Name` and `SSN` (US Social Security number) fields.
    In a real HLA record declaration you'd probably use a string type for at least
    the name (keeping in mind that a string variable is only a 4-byte pointer).
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: The field names within the record must be unique. That is, the same name may
    not appear two or more times in the same record. However, all field names are
    local to that record. Therefore, you may reuse those field names elsewhere in
    the program or in different records.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: 'The `record`/`endrecord` declaration may appear in a variable declaration section
    (e.g., `static` or `var`) or in a `type` declaration section. In the previous
    example the `Student` declaration appears in the `type` section, so this does
    not actually allocate any storage for a `Student` variable. Instead, you have
    to explicitly declare a variable of type `Student`. The following example demonstrates
    how to do this:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: This allocates 81 bytes of storage laid out in memory as shown in [Figure 4-10](ch04s25.html#student_data_structure_storage_in_memory
    "Figure 4-10. Student data structure storage in memory").
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '![Student data structure storage in memory](tagoreillycom20100401nostarchimages577997.png)'
  id: totrans-673
  prefs: []
  type: TYPE_IMG
- en: Figure 4-10. Student data structure storage in memory
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: If the label `John` corresponds to the *base address* of this record, then the
    `Name` field is at offset `John+0`, the `Major` field is at offset `John+65`,
    the `SSN` field is at offset `John+67`, and so on.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: To access an element of a structure, you need to know the offset from the beginning
    of the structure to the desired field. For example, the `Major` field in the variable
    `John` is at offset 65 from the base address of `John`. Therefore, you could store
    the value in AX into this field using the instruction
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Unfortunately, memorizing all the offsets to fields in a record defeats the
    whole purpose of using them in the first place. After all, if you have to deal
    with these numeric offsets, why not just use an array of bytes instead of a record?
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, HLA lets you refer to field names in a record using the same mechanism
    C/C++/C# and Pascal use: the dot operator. To store AX into the `Major` field,
    you could use `mov( ax, John.Major );` instead of the previous instruction. This
    is much more readable and certainly easier to use.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: Note that the use of the dot operator does *not* introduce a new addressing
    mode. The instruction `mov( ax, John.Major );` still uses the displacement-only
    addressing mode. HLA simply adds the base address of `John` with the offset to
    the `Major` field (65) to get the actual displacement to encode into the instruction.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: 'Like any type declaration, HLA requires all record type declarations to appear
    in the program before you use them. However, you don''t have to define all records
    in the `type` section to create record variables. You can use the `record`/`endrecord`
    declaration directly in a variable declaration section. This is convenient if
    you have only one instance of a given record object in your program. The following
    example demonstrates this:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '* * *'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: ^([[65](#CHP-4-FN-19)]) It also goes by some other names in other languages,
    but most people recognize at least one of these names.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: ^([[66](#CHP-4-FN-20)]) Strings require an extra byte, in addition to all the
    characters in the string, to encode the length.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: 4.26 Record Constants
  id: totrans-686
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HLA lets you define record constants. In fact, HLA supports both manifest (symbolic)
    record constants and literal record constants. Record constants are useful as
    initializers for static record variables. They are also quite useful as compile-time
    data structures when using the HLA compile-time language (see the HLA reference
    manual for more details on the HLA compile-time language). This section discusses
    how to create record constants.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: 'A literal record constant takes the following form:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The *`RecordTypeName`* is the name of a record data type you've defined in an
    HLA `type` section prior to using the constant.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: 'The constant list appearing between the brackets is the data for each of the
    fields in the specified record. The first item in the list corresponds to the
    first field of the record, the second item in the list corresponds to the second
    field, and so on. The data types of each of the constants appearing in this list
    must match their respective field types. The following example demonstrates how
    to use a literal record constant to initialize a record variable:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: This declaration initializes `Vector.x` with 1, `Vector.y` with −2, and `Vector.z`
    with 3.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create manifest record constants by declaring record objects in
    the `const` or `val` sections of your program. You access fields of these symbolic
    record constants just as you would access the field of a record variable, using
    the dot operator. Because the object is a constant, you can specify the field
    of a record constant anywhere a constant of that field''s type is legal. You can
    also employ symbolic record constants as variable initializers. The following
    example demonstrates this:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 4.27 Arrays of Records
  id: totrans-696
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is a perfectly reasonable operation to create an array of records. To do
    so, you simply create a record type and then use the standard array declaration
    syntax. The following example demonstrates how you could do this:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'To access an element of this array you use the standard array indexing techniques.
    Because *`recArray`* is a single-dimensional array, you''d compute the address
    of an element of this array using the formula *`baseAddress`* `+` *`index`*`*@size(`
    *`recElement`* `)`. For example, to access an element of *`recArray`* you''d use
    code like the following:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Note that the index specification follows the entire variable name; remember,
    this is assembly, not a high-level language (in a high-level language you'd probably
    use *`recArray`*`[i].`*`someField`*).
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, you can create multidimensional arrays of records as well. You would
    use the row-major or column-major order functions to compute the address of an
    element within such records. The only thing that really changes (from the discussion
    of arrays) is that the size of each element is the size of the record object.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 4.28 Arrays/Records as Record Fields
  id: totrans-704
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Records may contain other records or arrays as fields. Consider the following
    definition:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'The definition above defines a single point with a 32-bit color component.
    When initializing an object of type `Pixel`, the first initializer corresponds
    to the `Pt` field, *not the* *`x-coordinate`* *field*. The following definition
    is incorrect:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The value of the first field (5) is not an object of type `point`. Therefore,
    the assembler generates an error when encountering this statement. HLA will allow
    you to initialize the fields of `Pixel` using declarations like the following:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Accessing `Pixel` fields is very easy. As in a high-level language, you use
    a single period to reference the `Pt` field and a second period to access the
    `x`, `y`, and `z` fields of `point`:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'You can also declare arrays as record fields. The following record creates
    a data type capable of representing an object with eight points (for example,
    a cube):'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'This record allocates storage for eight different points. Accessing an element
    of the `Pts` array requires that you know the size of an object of type `point`
    (remember, you must multiply the index into the array by the size of one element,
    12 in this particular case). Suppose, for example, that you have a variable `Cube`
    of type `Object8`. You could access elements of the `Pts` array as follows:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'The one unfortunate aspect of all this is that you must know the size of each
    element of the `Pts` array. Fortunately, you can rewrite the code above using
    `@size` as follows:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Note in this example that the index specification (`[ebx]`) follows the whole
    object name even though the array is `Pts`, not `x`. Remember, the `[ebx]` specification
    is an indexed addressing mode, not an array index. Indexes always follow the entire
    name, so you do not attach them to the array component as you would in a high-level
    language like C/C++ or Pascal. This produces the correct result because addition
    is commutative, and the dot operator (as well as the index operator) corresponds
    to addition. In particular, the expression `Cube.Pts.x[ebx]` tells HLA to compute
    the sum of `Cube` (the base address of the object) plus the offset to the `Pts`
    field, plus the offset to the `x` field, plus the value of EBX. Technically, we're
    really computing offset(`Cube`) + offset(`Pts`) + EBX + offset(`x`), but we can
    rearrange this because addition is commutative.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also define two-dimensional arrays within a record. Accessing elements
    of such arrays is no different than accessing any other two-dimensional array
    other than the fact that you must specify the array''s field name as the base
    address for the array. For example:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: The code above uses the standard row-major calculation to index into a 4x5 array
    of double words. The only difference between this example and a standalone array
    access is the fact that the base address is `recVar.aField`.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two common ways to nest record definitions. As this section notes,
    you can create a record type in a `type` section and then use that type name as
    the data type of some field within a record (e.g., the `Pt:point` field in the
    `Pixel` data type above). It is also possible to declare a record directly within
    another record without creating a separate data type for that record; the following
    example demonstrates this:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Generally, it's a better idea to create a separate type rather than embed records
    directly in other records, but nesting them is perfectly legal.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an array of records and one of the fields of that record type is
    an array, you must compute the indexes into the arrays independently of one another
    and then use the sum of these indexes as the ultimate index. The following example
    demonstrates how to do this:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Note the use of the base plus scaled indexed addressing mode to simplify this
    operation.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: 4.29 Aligning Fields Within a Record
  id: totrans-729
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To achieve maximum performance in your programs, or to ensure that HLA''s records
    properly map to records or structures in some high-level language, you will often
    need to be able to control the alignment of fields within a record. For example,
    you might want to ensure that a double-word field''s offset is an even multiple
    of 4\. You use the `align` directive to do this. The following example shows how
    to align some fields on important boundaries:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Whenever HLA encounters the `align` directive within a record declaration,
    it automatically adjusts the following field''s offset so that it is an even multiple
    of the value the `align` directive specifies. It accomplishes this by increasing
    the offset of that field, if necessary. In the example above, the fields would
    have the following offsets: `c:0`, `d:4`, `b:8`, `w:10`. Note that HLA inserts
    3 bytes of padding between `c` and `d`, and it inserts 1 byte of padding between
    `b` and `w`. It goes without saying that you should never assume that this padding
    is present. If you want to use those extra bytes, then you must declare fields
    for them.'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that specifying alignment within a record declaration does not guarantee
    that the field will be aligned on that boundary in memory; it only ensures that
    the field''s offset is a multiple of the value you specify. If a variable of type
    `PaddedRecord` starts at an odd address in memory, then the `d` field will also
    start at an odd address (because any odd address plus 4 is an odd address). If
    you want to ensure that the fields are aligned on appropriate boundaries in memory,
    you must also use the `align` directive before variable declarations of that record
    type. For example:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: The value of the `align` operand should be an even value that is divisible by
    the largest `align` expression within the record type (4 is the largest value
    in this case, and it's already divisible by 2).
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to ensure that the record''s size is a multiple of some value,
    then simply stick an `align` directive as the last item in the record declaration.
    HLA will emit an appropriate number of bytes of padding at the end of the record
    to fill it in to the appropriate size. The following example demonstrates how
    to ensure that the record''s size is a multiple of 4 bytes:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: HLA provides some additional alignment directives for records that let you easily
    control the alignment of all fields within a record and the starting offset of
    the fields in a record. If you're interested in more information, please consult
    the HLA reference manual.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: 4.30 Pointers to Records
  id: totrans-739
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During execution, your program may refer to record objects indirectly using
    a pointer. When you use a pointer to access fields of a structure, you must load
    one of the 80x86''s 32-bit registers with the address of the desired record. Suppose
    you have the following variable declarations (assuming the `Object8` structure
    from an earlier section):'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '`CubePtr` contains the address of (that is, it is a pointer to) the `Cube`
    object. To access the `Color` field of the `Cube` object, you could use an instruction
    like `mov( Cube.Color, eax );`. When accessing a field via a pointer, you first
    need to load the address of the object into a 32-bit register such as EBX. The
    instruction `mov( CubePtr, ebx );` will do the trick. After doing so, you can
    access fields of the `Cube` object using the `[ebx+offset]` addressing mode. The
    only problem is, "How do you specify which field to access?" Consider briefly
    the following *incorrect* code:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Because field names are local to a structure and it's possible to reuse a field
    name in two or more structures, how does HLA determine which offset `Color` represents?
    When accessing structure members directly (e.g., `mov( Cube.Color, eax )`;), there
    is no ambiguity because `Cube` has a specific type that the assembler can check.
    `[ebx]`, on the other hand, can point at *anything*. In particular, it can point
    at any structure that contains a `Color` field. So the assembler cannot, on its
    own, decide which offset to use for the `Color` symbol.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA resolves this ambiguity by requiring that you explicitly supply a type.
    To do this, you must coerce `[ebx]` to type `Cube`. Once you do this, you can
    use the normal dot operator notation to access the `Color` field:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'If you have a pointer to a record and one of that record''s fields is an array,
    the easiest way to access elements of that field is by using the base-plus-indexed
    addressing mode. To do so, you just load the pointer''s value into one register
    and compute the index into the array in a second register. Then you combine these
    two registers in the address expression. In the example above, the `Pts` field
    is an array of eight `point` objects. To access field `x` of the `i`th element
    of the `Cube.Pts` field, you''d use code like the following:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'If you use a pointer to a particular record type frequently in your program,
    typing a coercion operator like `(type Object8 [ebx])` can get old very quickly.
    One way to reduce the typing needed to coerce EBX is to use a `text` constant.
    Consider the following statement:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'With this statement at the beginning of your program, you can use `O8ptr` in
    place of the type coercion operator, and HLA will automatically substitute the
    appropriate text. With a text constant like the above, the former example becomes
    a little more readable and writable:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 4.31 Unions
  id: totrans-753
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A record definition assigns different offsets to each field in the record according
    to the size of those fields. This behavior is quite similar to the allocation
    of memory offsets in a `var` or `static` section. HLA provides a second type of
    structure declaration, the `union`, that does not assign different addresses to
    each object; instead, each field in a `union` declaration has the same offset—0\.
    The following example demonstrates the syntax for a `union` declaration:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'You access the fields of a `union` exactly the same way you access the fields
    of a record: using dot notation and field names. The following is a concrete example
    of a `union` type declaration and a variable of the `union` type:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'The important thing to note about `union` objects is that all the fields of
    a `union` have the same offset in the structure. In the example above, the `number.u`,
    `number.i`, and `number.r` fields all have the same offset: 0\. Therefore, the
    fields of a `union` overlap in memory; this is very similar to the way the 80x86
    8-, 16-, and 32-bit registers overlap one another. Usually, you may access only
    one field of a `union` at a time; that is, you do not manipulate separate fields
    of a particular `union` variable concurrently because writing to one field overwrites
    the other fields. In the example above, any modification of `number.u` would also
    change `number.i` and `number.r`.'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmers typically use unions for two different reasons: to conserve memory
    or to create aliases. Memory conservation is the intended use of this data structure
    facility. To see how this works, let''s compare the `numeric union` above with
    a corresponding record type.'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: If you declare a variable, say `n`, of type `numericRec`, you access the fields
    as `n.i`, `n.u`, and `n.r` exactly as though you had declared the variable to
    be type `numeric`. The difference between the two is that `numericRec` variables
    allocate separate storage for each field of the record, whereas `numeric` (union)
    objects allocate the same storage for all fields. Therefore, `@size(numericRec)`
    is 16 because the record contains two double-word fields and a quad word (`real64`)
    field. `@size(numeric)`, however, is 8\. This is because all the fields of a `union`
    occupy the same memory locations, and the size of a `union` object is the size
    of the largest field of that object (see [Figure 4-11](ch04s31.html#layout_of_a_union_versus_a_record_variab
    "Figure 4-11. Layout of a union versus a record variable")).
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: '![Layout of a union versus a record variable](tagoreillycom20100401nostarchimages577999.png)'
  id: totrans-762
  prefs: []
  type: TYPE_IMG
- en: Figure 4-11. Layout of a `union` versus a `record` variable
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to conserving memory, programmers often use unions to create aliases
    in their code. As you may recall, an alias is a different name for the same memory
    object. Aliases are often a source of confusion in a program, so you should use
    them sparingly; sometimes, however, using an alias can be quite convenient. For
    example, in some section of your program you might need to constantly use type
    coercion to refer to an object using a different type. Although you can use an
    HLA `text` constant to simplify this process, another way to do this is to use
    a `union` variable with the fields representing the different types you want to
    use for the object. As an example, consider the following code:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: With a declaration like the above, you can manipulate an `uns32` object by accessing
    `v.u`. If, at some point, you need to treat the L.O. byte of this `uns32` variable
    as a character, you can do so by simply accessing the `v.c` variable, for example,
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: You can use unions exactly the same way you use records in an HLA program. In
    particular, `union` declarations may appear as fields in records, `record` declarations
    may appear as fields in unions, array declarations may appear within unions, you
    can create arrays of unions, and so on.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: 4.32 Anonymous Unions
  id: totrans-769
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within a `record` declaration you can place a `union` declaration without specifying
    a fieldname for the `union` object. The following example demonstrates the syntax
    for this:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Whenever an anonymous union appears within a `record` you can access the fields
    of the `union` as though they were direct fields of the `record`. In the example
    above, for example, you would access `v`''s `u` and `i` fields using the syntax
    `v.u` and `v.i`, respectively. The `u` and `i` fields have the same offset in
    the record (8, because they follow a `real64` object). The fields of `v` have
    the following offsets from `v`''s base address:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '`@size(v)` is 16 because the `u` and `i` fields consume only 4 bytes.'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: HLA also allows anonymous records within unions. Please see the HLA documentation
    for more details, though the syntax and usage are identical to anonymous unions
    within records.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: 4.33 Variant Types
  id: totrans-776
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One big use of unions in programs is to create *variant* types. A variant variable
    can change its type dynamically while the program is running. A variant object
    can be an integer at one point in the program, switch to a string at a different
    part of the program, and then change to a real value at a later time. Many very-high-level
    language (VHLL) systems use a dynamic type system (that is, variant objects) to
    reduce the overall complexity of the program; indeed, proponents of many VHLLs
    insist that the use of a dynamic typing system is one of the reasons you can write
    complex programs with so few lines of code using those languages. Of course, if
    you can create variant objects in a VHLL, you can certainly do it in assembly
    language. In this section we'll look at how we can use the `union` structure to
    create variant types.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: 'At any one given instant during program execution, a variant object has a specific
    type, but under program control the variable can switch to a different type. Therefore,
    when the program processes a variant object, it must use an `if` statement or
    `switch` statement (or something similar) to execute different instructions based
    on the object''s current type. Very-high-level languages do this transparently.
    In assembly language you will have to provide the code to test the type yourself.
    To achieve this, the variant type needs some additional information beyond the
    object''s value. Specifically, the variant object needs a field that specifies
    the current type of the object. This field (often known as the `tag` field) is
    an enumerated type or integer that specifies the object''s type at any given instant.
    The following code demonstrates how to create a variant type:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: The program would test the `v.tag` field to determine the current type of the
    `v` object. Based on this test, the program would manipulate the `v.i`, `v.u`,
    or `v.r` field.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: Of course, when operating on variant objects, the program's code must constantly
    be testing the `tag` field and executing a separate sequence of instructions for
    `uns32`, `int32`, or `real64` values. If you use the variant fields often, it
    makes a lot of sense to write procedures to handle these operations for you (e.g.,
    *`vadd`*, *`vsub`*, *`vmul`*, and *`vdiv`*).
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: 4.34 Namespaces
  id: totrans-782
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One really nice feature of records and unions is that the field names are local
    to a given `record` or `union` declaration. That is, you can reuse field names
    in different records or unions. This is an important feature of HLA because it
    helps avoid *namespace pollution*. Namespace pollution occurs when you use up
    all the "good" names within your program and you have to start creating nondescriptive
    names for objects because you've already used the most appropriate name for something
    else. We use the term *namespace* to describe how HLA associates names with a
    particular object. The field names of a `record` have a namespace that is limited
    to objects of that record type. HLA provides a generalization of this namespace
    mechanism that lets you create arbitrary namespaces. These namespace objects let
    you shield the names of constants, types, variables, and other objects so their
    names do not interfere with other declarations in your program.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: 'An HLA `namespace` section encapsulates a set of generic declarations in much
    the same way that a `record` encapsulates a set of variable declarations. A `namespace`
    declaration takes the following form:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: The *`name`* identifier provides the name for the `namespace`. The identifier
    after the `end` clause must exactly match the identifier after `namespace`. Note
    that a `namespace` declaration section is a section unto itself. It does not have
    to appear in a `type` or `var` section. A `namespace` may appear anywhere one
    of the HLA declaration sections is legal. A program may contain any number of
    `namespace` declarations; in fact, the namespace identifiers don't even have to
    be unique, as you will soon see.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: 'The declarations that appear between the `namespace` and `end` clauses are
    all the standard HLA declaration sections except that you cannot nest `namespace`
    declarations. You may, however, put `const`, `val`, `type`, `static`, `readonly`,
    and `storage` sections within a `namespace`.^([[67](#ftn.CHP-4-FN-21)]) The following
    code provides an example of a typical `namespace` declaration in an HLA program:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'To access the fields of a namespace you use the same dot notation that records
    and unions use. For example, to access the fields of `myNames` outside of the
    namespace, you''d use the following identifiers:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'This example also demonstrates an important point about `namespace` declarations:
    Within a namespace you may reference other identifiers in that same `namespace`
    declaration without using the dot notation. For example, the `i` field above uses
    type `integer` from the `myNames` namespace without the `mynames`. prefix.'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: 'What is not obvious from the example above is that `namespace` declarations
    create a clean symbol table whenever you open up a namespace. The only external
    symbols that HLA recognizes in a `namespace` declaration are the predefined type
    identifiers (e.g., `int32`, `uns32`, and `char`). HLA does not recognize any symbols
    you''ve declared outside the namespace while it is processing your `namespace`
    declaration. This creates a problem if you want to use symbols from outside the
    namespace when declaring other symbols inside the namespace. For example, suppose
    the type `integer` had been defined outside `myNames` as follows:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'If you were to attempt to compile this code, HLA would complain that the symbol
    `integer` is undefined. Clearly `integer` is defined in this program, but HLA
    hides all external symbols when creating a namespace so that you can reuse (and
    redefine) those symbols within the namespace. Of course, this doesn''t help much
    if you actually want to use a name that you''ve defined outside `myNames` within
    that namespace. HLA provides a solution to this problem: the `@global:` operator.
    If, within a `namespace` declaration section, you prefix a name with `@global:`,
    then HLA will use the global definition of that name rather than the local definition
    (if a local definition even exists). To correct the problem in the previous example,
    you''d use the following code:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: With the `@global:` prefix, the `i` variable will be type `int32` even if a
    different declaration of `integer` appears within the `myNames` namespace.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: You cannot nest `namespace` declarations. Logically, there doesn't seem to be
    any need for this, hence its omission from the HLA language.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have multiple `namespace` declarations in the same program that use
    the same namespace identifier. For example:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: When HLA encounters a second `namespace` declaration for a given identifier,
    it simply appends the declarations in the second group to the end of the symbol
    list it created for the first group. Therefore, after processing the two `namespace`
    declarations, the `ns` namespace would contain the set of all symbols you've declared
    in both `namespace` blocks.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most common use of namespaces is in library modules. If you create
    a set of library routines to use in various projects or distribute to others,
    you have to be careful about the names you choose for your functions and other
    objects. If you use common names like `get` and `put`, the users of your module
    will complain when your names collide with theirs. An easy solution is to put
    all your code in a `namespace` block. Then the only name you have to worry about
    is the `namespace` identifier itself. This is the only name that will collide
    with other users' identifiers. This can happen, but it's much less likely to happen
    than if you don't use a namespace and your library module introduces dozens, if
    not hundreds, of new names into the global namespace.^([[68](#ftn.CHP-4-FN-22)])
    The HLA Standard Library provides many good examples of namespaces in use. The
    HLA Standard Library defines several namespaces like `stdout`, `stdin`, `str`,
    `cs`, and `chars`. You refer to functions in these namespaces using names like
    `stdout.put`, `stdin.get`, `cs.intersection`, `str.eq`, and `chars.toUpper`. The
    use of namespaces in the HLA Standard Library prevents conflicts with similar
    names in your own programs.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: ^([[67](#CHP-4-FN-21)]) Procedure declarations, the subject of [Chapter 5](ch05.html
    "Chapter 5. PROCEDURES AND UNITS"), are also legal within a `namespace` declaration
    section.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: ^([[68](#CHP-4-FN-22)]) The global namespace is the global section of your program.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: 4.35 Dynamic Arrays in Assembly Language
  id: totrans-805
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One problem with arrays as this chapter describes them is that their size is
    static. That is, the number of elements in all of the examples was chosen when
    writing the program; it was not selected while the program runs (that is, dynamically).
    Alas, sometimes you simply don't know how big an array needs to be when you're
    writing the program; you can only determine the size of the array while the program
    is running. This section describes how to allocate storage for arrays dynamically
    so you can set their size at runtime.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: Allocating storage for a single-dimensional array, and accessing elements of
    that array, is a nearly trivial task at runtime. All you need to do is call the
    HLA Standard Library `mem.alloc` routine, specifying the size of the array in
    bytes. `mem.alloc` will return a pointer to the base address of the new array
    in the EAX register. Typically, you would save this address in a pointer variable
    and use that value as the base address of the array in all future array accesses.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: To access an element of a single-dimensional dynamic array, you would generally
    load the base address into a register and compute the index in a second register.
    Then you could use the base-indexed addressing mode to access elements of that
    array. This is not a whole lot more work than accessing elements of a statically
    allocated array. The following code fragment demonstrates how to allocate and
    access elements of a single-dimensional dynamic array.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Dynamically allocating storage for a multidimensional array is fairly straightforward.
    The number of elements in a multidimensional array is the product of all the dimension
    values; for example, a 4x5 array has 20 elements. So if you get the bounds for
    each dimension from the user, all you need to do is compute the product of all
    of these bound values and multiply the result by the size of a single element.
    This computes the total number of bytes in the array, the value that `mem.alloc`
    expects.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: Accessing elements of multidimensional arrays is a little more problematic.
    The problem is that you need to keep the dimension information (that is, the bounds
    on each dimension) around because these values are needed when computing the row-major
    (or column-major) index into the array.^([[69](#ftn.CHP-4-FN-23)]) The conventional
    solution is to store these bounds into a static array (generally you know the
    *arity*, or number of dimensions, at compile time, so it is possible to statically
    allocate storage for this array of dimension bounds). This array of dynamic array
    bounds is known as a *dope vector*. The following code fragment shows how to allocate
    storage for a two-dimensional dynamic array using a simple dope vector.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '* * *'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: ^([[69](#CHP-4-FN-23)]) Technically, you don't need the value of the leftmost
    dimension bound to compute an index into the array; however, if you want to check
    the index bounds using the `bound` instruction (or some other technique), you
    will need this value around at runtime as well.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: 4.36 For More Information
  id: totrans-815
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the electronic edition of this book, which you'll find at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/), you will find additional
    information about data types. The HLA Standard Library documentation describes
    the HLA arrays package that provides support for dynamically allocated (and statically
    allocated) arrays, indexing into arrays, and many other array options. You should
    consult the HLA stdlib documentation for more details about this array package.
    For additional information about data structure representation in memory, you
    should consider reading my book *Write Great Code, Volume 1* (No Starch Press,
    2004). For an in-depth discussion of data types, you should consult a textbook
    on data structures and algorithms.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
