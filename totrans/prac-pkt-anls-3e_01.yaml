- en: '**1**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1**'
- en: '**PACKET ANALYSIS AND NETWORK BASICS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据包分析与网络基础**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: A million different things can go wrong with a computer network on any given
    day—from a simple spyware infection to a complex router configuration error—and
    it’s impossible to solve every problem immediately. The best we can hope for is
    to be fully prepared with the knowledge and tools we need to respond to these
    types of issues.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每天，计算机网络中可能出现无数种问题——从简单的间谍软件感染到复杂的路由器配置错误——而且不可能立即解决每个问题。我们能做的最好的准备就是拥有应对这些问题所需的知识和工具。
- en: To truly understand network problems, we go to the packet level. All network
    problems stem from this level, where even the prettiest-looking applications can
    reveal their horrible implementations and seemingly trustworthy protocols can
    prove malicious. Here, nothing is hidden from us. Nothing is obscured by misleading
    menu structures, eye-catching graphics, or untrustworthy employees—there are no
    true secrets (only encrypted ones). The more we can do at the packet level, the
    more we can control our network and solve problems. This is the world of packet
    analysis.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解网络问题，我们需要从数据包级别入手。所有的网络问题都源自这个层次，在这里，即便是最美观的应用程序也能揭示它们糟糕的实现，而看似值得信任的协议也可能证明是恶意的。在这里，什么都不会被隐藏。没有什么能够通过误导性的菜单结构、引人注目的图形或不可信的员工而被掩盖——没有真正的秘密（只有加密的秘密）。我们在数据包级别上能做的越多，我们就能越多地控制我们的网络并解决问题。这就是数据包分析的世界。
- en: This book dives into this world headfirst. Through real-world scenarios, you’ll
    learn how to tackle slow network communication, identify application bottlenecks,
    and even track hackers. By the time you’ve finished reading this book, you should
    be able to implement packet analysis techniques that will help you solve even
    the most difficult problems in your own network.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将深入探讨这个领域。通过真实场景，你将学习如何解决网络通信缓慢、识别应用程序瓶颈，甚至追踪黑客。读完本书后，你应该能够实施数据包分析技术，帮助你解决自己网络中最棘手的问题。
- en: In this chapter, we’ll begin with the basics, focusing on network communication.
    The material here will help you gain the tools you’ll need to examine different
    scenarios.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从基础知识开始，重点介绍网络通信。本部分内容将帮助你获得分析不同场景所需的工具。
- en: '**Packet Analysis and Packet Sniffers**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据包分析和数据包嗅探器**'
- en: '*Packet analysis*, often referred to as packet sniffing or protocol analysis,
    describes the process of capturing and interpreting live data as it flows across
    a network in order to better understand what is happening on that network. Packet
    analysis is typically performed by a *packet sniffer*, a tool used to capture
    raw network data going across the wire.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据包分析*，通常称为数据包嗅探或协议分析，描述了捕获和解读网络中实时数据流动的过程，目的是更好地理解网络上发生的事情。数据包分析通常由*数据包嗅探器*执行，这是一种用于捕获通过网络传输的原始数据的工具。'
- en: 'Packet analysis can help with the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包分析可以帮助完成以下任务：
- en: •     Understanding network characteristics
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: •     理解网络特性
- en: •     Learning who is on a network
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: •     了解谁在网络上
- en: •     Determining who or what is utilizing available bandwidth
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: •     确定谁或什么在使用可用带宽
- en: •     Identifying peak network usage times
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: •     识别网络使用的高峰时间
- en: •     Identifying malicious activity
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: •     识别恶意活动
- en: •     Finding unsecured and bloated applications
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: •     寻找不安全且臃肿的应用程序
- en: There are various types of packet-sniffing programs, including both free and
    commercial ones. Each program is designed with different goals in mind. A few
    popular packet analysis programs are tcpdump, OmniPeek, and Wireshark (we’ll primarily
    be using Wireshark in this book). OmniPeek and Wireshark have graphical user interfaces
    (GUIs), while tcpdump is a command line program.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种类型的数据包嗅探程序，包括免费和商业版的。每个程序都有不同的目标。一些流行的数据包分析程序包括tcpdump、OmniPeek和Wireshark（本书主要使用Wireshark）。OmniPeek和Wireshark具有图形用户界面（GUI），而tcpdump是一个命令行程序。
- en: '***Evaluating a Packet Sniffer***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***评估数据包嗅探器***'
- en: 'You need to consider a number of factors when selecting a packet sniffer, including
    the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择数据包嗅探器时，你需要考虑多个因素，包括以下几点：
- en: '**Supported protocols**   All packet sniffers can interpret various protocols.
    Most can interpret common network protocols (such as IPv4 and ICMP), transport
    protocols (such as TCP and UDP), and even application protocols (such as DNS and
    HTTP). However, they may not support nontraditional, newer, or more complex protocols
    (such as IPv6, SMBv2, and SIP). When choosing a sniffer, make sure that it supports
    the protocols you’re going to use.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持的协议**   所有数据包嗅探器都能够解读各种协议。大多数能够解读常见的网络协议（如IPv4和ICMP）、传输协议（如TCP和UDP），甚至应用程序协议（如DNS和HTTP）。然而，它们可能不支持非传统的、更复杂的或较新的协议（如IPv6、SMBv2和SIP）。在选择嗅探器时，确保它支持你将要使用的协议。'
- en: '**User friendliness**   Consider the packet sniffer’s layout, ease of installation,
    and general workflow. The program you choose should fit your level of expertise.
    If you have very little packet analysis experience, you may want to avoid the
    more advanced command line packet sniffers like tcpdump. On the other hand, if
    you are a packet analysis veteran, you may find an advanced program more useful.
    As you gain experience, you may even find it useful to combine multiple packet-sniffing
    programs to fit particular scenarios.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户友好性**   考虑数据包嗅探器的布局、安装的简便性以及整体工作流程。你选择的程序应该适合你的专业水平。如果你在数据包分析方面经验很少，你可能想避免使用像tcpdump这样的高级命令行数据包嗅探器。另一方面，如果你是数据包分析的老手，你可能会发现一个高级程序更为有用。随着经验的积累，你甚至可能会发现结合多个数据包嗅探程序以应对特定场景是非常有用的。'
- en: '**Cost**   The great thing about packet sniffers is that there are many free
    ones that rival any commercial products. The most notable difference between commercial
    products and their free alternatives is their reporting engines. Commercial products
    typically include some form of fancy report generation module, while free applications
    either lack this capability or offer only very limited reporting.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**成本**   数据包嗅探器的一个好处是有许多免费的嗅探器，它们的性能可以媲美任何商业产品。商业产品与其免费的替代品之间最显著的区别在于它们的报告引擎。商业产品通常包括某种形式的精美报告生成模块，而免费应用程序通常没有这种功能，或者仅提供非常有限的报告功能。'
- en: '**Program support**   Even after you have mastered the basics of a sniffing
    program, you may occasionally need support to solve new problems as they arise.
    When evaluating available support, look for developer documentation, public forums,
    and mailing lists. Although there may be a lack of formalized commercial support
    for free packet-sniffing programs like Wireshark, communities of users and contributors
    often provide active discussion boards, wikis, and blogs to help you get more
    out of your packet sniffer.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序支持**   即使你已经掌握了嗅探程序的基础知识，你可能仍然需要支持来解决随着新问题的出现而产生的挑战。在评估可用支持时，寻找开发者文档、公共论坛和邮件列表。虽然像Wireshark这样的免费数据包嗅探程序可能缺乏正式的商业支持，但用户和贡献者社区通常会提供活跃的讨论板、维基和博客，帮助你更好地使用数据包嗅探器。'
- en: '**Source code access**   Some packet sniffers are open source software. This
    means that you can view the source code of the program and, in some cases, even
    suggest and make changes to that source code. If you have a very specific or advanced
    use case for a sniffing application, this might be an appealing feature. Most
    commercial applications don’t provide source code access.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码访问**   一些数据包嗅探器是开源软件。这意味着你可以查看程序的源代码，在某些情况下，甚至可以提出建议并对源代码进行更改。如果你有非常具体或高级的嗅探应用需求，这可能是一个非常吸引人的特点。大多数商业应用程序不提供源代码访问。'
- en: '**Operating system support**   Unfortunately, not all packet sniffers support
    every operating system. Choose one that will work on all the operating systems
    that you need to support. If you are a consultant, you may be required to capture
    and analyze packets on a variety of operating systems, so you’ll need a tool that
    runs on most of them. Also, keep in mind that you’ll sometimes capture packets
    on one machine and review them on another. Variations between operating systems
    may force you to use a different application for each device.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作系统支持**   不幸的是，并不是所有数据包嗅探器都支持每一个操作系统。请选择一个可以在所有你需要支持的操作系统上运行的工具。如果你是顾问，你可能需要在多种操作系统上捕获和分析数据包，因此你需要一个可以在大多数操作系统上运行的工具。另外，请记住，你有时可能会在一台机器上捕获数据包，并在另一台机器上进行查看。操作系统之间的差异可能迫使你在每个设备上使用不同的应用程序。'
- en: '***How Packet Sniffers Work***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数据包嗅探器的工作原理***'
- en: 'The packet-sniffing process involves a cooperative effort between software
    and hardware. This process can be broken down into three steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包嗅探过程涉及软件和硬件的协同工作。这个过程可以分为三个步骤：
- en: '**Collection:** First, the packet sniffer collects raw binary data from the
    wire. Typically this is done by switching the selected network interface into
    *promiscuous mode*. In this mode, the network card can listen to all traffic on
    a network segment, not only the traffic that is addressed to it.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**收集：** 首先，数据包嗅探器从网络中收集原始的二进制数据。通常通过将选定的网络接口切换到*混杂模式*来实现。在此模式下，网络卡可以监听网络段上的所有流量，而不仅仅是发送给它的流量。'
- en: '**Conversion:** Next, the captured binary data is converted into a readable
    form. This is as far as most advanced command line packet sniffers can go. At
    this point, the network data can be interpreted only on a very basic level, leaving
    the majority of the analysis to the end user.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**转换：** 接下来，将捕获的二进制数据转换为可读形式。这是大多数高级命令行数据包嗅探器能够做到的极限。在此阶段，网络数据只能在非常基础的层面进行解读，剩下的大部分分析则交由最终用户完成。'
- en: '**Analysis:** Finally, the packet sniffer conducts an analysis of the captured
    and converted data. The sniffer verifies the protocol of the captured network
    data based on the information extracted and begins its analysis of that protocol’s
    specific features.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分析：** 最后，数据包嗅探器对捕获并转换后的数据进行分析。嗅探器根据提取的信息验证捕获的网络数据的协议，并开始分析该协议的特定特性。'
- en: '**How Computers Communicate**'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**计算机如何通信**'
- en: To fully understand packet analysis, you must know exactly how computers communicate
    with each other. In this section, we’ll examine the basics of network protocols,
    the Open Systems Interconnections (OSI) model, network data frames, and the hardware
    that supports it all.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解数据包分析，你必须了解计算机是如何相互通信的。在本节中，我们将研究网络协议的基础知识、开放系统互联（OSI）模型、网络数据帧以及支撑这一切的硬件。
- en: '***Protocols***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***协议***'
- en: Modern networks are made up of a variety of systems running on many different
    platforms. To communicate between systems, we use a set of common languages called
    *protocols*. Common protocols include Transmission Control Protocol (TCP), Internet
    Protocol (IP), Address Resolution Protocol (ARP), and Dynamic Host Configuration
    Protocol (DHCP). A logical grouping of protocols that work together is called
    a *protocol stack*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络由运行在多种不同平台上的各种系统组成。为了在系统之间进行通信，我们使用一套称为*协议*的通用语言。常见的协议包括传输控制协议（TCP）、互联网协议（IP）、地址解析协议（ARP）和动态主机配置协议（DHCP）。多个协同工作的协议组合被称为*协议栈*。
- en: It might help to think of protocols as similar to the rules that govern human
    language. Every language has rules such as how to conjugate verbs, how to greet
    people, and even how to properly thank someone. Protocols work in much the same
    fashion, allowing us to define how packets should be routed, how to initiate a
    connection, and how to acknowledge the receipt of data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可以把协议想象成类似于控制人类语言的规则。每种语言都有一些规则，比如动词变位、如何打招呼，甚至如何恰当地表达感谢。协议的工作方式也类似，允许我们定义数据包应该如何路由，如何初始化连接，以及如何确认接收数据。
- en: 'A protocol can be extremely simple or highly complex, depending on its function.
    Although the various protocols can differ significantly, many protocols address
    the following issues:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 协议可以是非常简单的，也可以是高度复杂的，具体取决于其功能。尽管各种协议可能存在显著差异，但许多协议都涉及以下问题：
- en: '**Connection initiation**   Is it the client or server initiating the connection?
    What information must be exchanged prior to communication?'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接初始化**  是客户端还是服务器发起了连接？在通信之前必须交换哪些信息？'
- en: '**Negotiation of connection characteristics**   Is the communication of the
    protocol encrypted? How are encryption keys transmitted between communicating
    hosts?'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接特征的协商**  协议的通信是否经过加密？加密密钥是如何在通信主机之间传输的？'
- en: '**Data formatting**   How is the data contained within the packet organized?
    In what order is the data processed by the devices receiving it?'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据格式化**  数据包内的数据是如何组织的？接收设备处理数据的顺序是怎样的？'
- en: '**Error detection and correction**   What happens in the event that a packet
    takes too long to reach its destination? How does a client recover if it cannot
    establish communication with a server for a short duration?'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误检测与修正**  如果数据包在传输过程中花费太长时间才到达目的地，会发生什么情况？如果客户端在短时间内无法与服务器建立通信，如何恢复？'
- en: '**Connection termination**   How does one host signify to the other that communication
    has ended? What final information must be transmitted in order to gracefully terminate
    communication?'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接终止**  一个主机如何向另一个主机表示通信已经结束？为了优雅地终止通信，必须传输哪些最终信息？'
- en: '***The Seven-Layer OSI Model***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***七层OSI模型***'
- en: Protocols are separated according to their functions based on the industry-standard
    OSI reference model. This hierarchical model, with seven distinct layers, is very
    helpful for understanding network communications. In [Figure 1-1](ch01.xhtml#ch01fig1),
    the layers of the OSI model are on the right, and the proper terminology for data
    at each of these layers is on the left. The application layer at the top represents
    the programs used to access network resources. The bottom layer is the physical
    layer, through which the network data travels. The protocols at each layer work
    together to ensure data is properly handled by the protocols at layers directly
    above and below.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 协议根据其功能根据行业标准的OSI参考模型进行分离。这个七层的分层模型有助于理解网络通信。在[图1-1](ch01.xhtml#ch01fig1)中，OSI模型的层级位于右侧，而每一层的数据术语位于左侧。顶部的应用层代表用于访问网络资源的程序。最底层是物理层，网络数据通过它传输。每一层的协议共同作用，确保数据在上下层协议之间得到正确处理。
- en: '**NOTE**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The OSI model was originally published in 1983 by the International Organization
    for Standardization (ISO) as a document called ISO 7498\. The OSI model is no
    more than an industry-recommended standard. Protocol developers are not required
    to follow it exactly. In fact, the OSI model is not the only networking model;
    for example, some people prefer the Department of Defense (DoD) model, also known
    as the TCP/IP model.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*OSI模型最初由国际标准化组织（ISO）于1983年发布，作为名为ISO 7498的文档。OSI模型只是一个行业推荐的标准。协议开发人员并不要求严格遵循它。事实上，OSI模型并不是唯一的网络模型；例如，有些人更倾向于使用国防部（DoD）模型，也称为TCP/IP模型。*'
- en: '![image](../images/f05-01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-01.jpg)'
- en: '*Figure 1-1: A hierarchical view of the seven layers of the OSI model*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-1：OSI模型七层的分层视图*'
- en: 'Each OSI model layer has a specific function, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个OSI模型层都有特定的功能，如下所示：
- en: '**Application layer (layer 7)**   The topmost layer of the OSI model provides
    a means for users to access network resources. This is the only layer typically
    seen by end users, as it provides the interface that is the base for all of their
    network activities.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用层（第7层）**  OSI模型的最顶层为用户提供访问网络资源的方式。这是终端用户通常看到的唯一一层，因为它提供了所有网络活动的基础接口。'
- en: '**Presentation layer (layer 6)**   This layer transforms the data it receives
    into a format that can be read by the application layer. The data encoding and
    decoding done here depends on the application layer protocol that is sending or
    receiving the data. The presentation layer also handles several forms of encryption
    and decryption used to secure data.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**表示层（第6层）**  该层将接收到的数据转化为应用层可以读取的格式。这里的数据编码和解码依赖于发送或接收数据的应用层协议。表示层还处理几种形式的加密和解密，用于保护数据安全。'
- en: '**Session layer (layer 5)**   This layer manages the *dialogue*, or session,
    between two computers. It establishes, manages, and terminates this connection
    among all communicating devices. The session layer is also responsible for establishing
    whether a connection is duplex (two-way) or half-duplex (one-way) and for gracefully
    closing a connection between hosts rather than dropping it abruptly.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**会话层（第5层）**  该层管理两台计算机之间的*对话*，或会话。它在所有通信设备之间建立、管理和终止连接。会话层还负责确定连接是双工（双向）还是半双工（单向），并且负责优雅地关闭主机之间的连接，而不是突然中断连接。'
- en: '**Transport layer (layer 4)**   The primary purpose of the transport layer
    is to provide reliable data transport services to lower layers. Through flow control,
    segmentation/desegmentation, and error control, the transport layer makes sure
    data gets from point to point error-free. Because ensuring reliable data transportation
    can be extremely cumbersome, the OSI model devotes an entire layer to it. The
    transport layer utilizes both connection-oriented and connectionless protocols.
    Certain firewalls and proxy servers operate at this layer.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输层（第4层）**  传输层的主要目的是为下层提供可靠的数据传输服务。通过流量控制、分段/重组和错误控制，传输层确保数据从源点到目的点无误传输。由于确保可靠的数据传输可能非常繁琐，OSI模型专门为此设立了一个层级。传输层使用面向连接和无连接的协议。某些防火墙和代理服务器在这一层工作。'
- en: '**Network layer (layer 3)**   This layer, one of the most complex of the OSI
    layers, is responsible for routing data between physical networks. It sees to
    the logical addressing of network hosts (for example, through an IP address).
    It also handles splitting data streams into smaller fragments and, in some cases,
    error detection. Routers operate at this layer.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络层（第 3 层）**  这一层是 OSI 模型中最复杂的层之一，负责在物理网络之间路由数据。它负责网络主机的逻辑寻址（例如，通过 IP 地址）。它还处理将数据流分割成较小的片段，并在某些情况下进行错误检测。路由器在这一层操作。'
- en: '**Data link layer (layer 2)**   This layer provides a means of transporting
    data across a physical network. Its primary purpose is to provide an addressing
    scheme that can be used to identify physical devices (for example, MAC addresses).
    Bridges and switches are physical devices that operate at the data link layer.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据链路层（第 2 层）**  这一层提供了一种在物理网络中传输数据的方法。其主要目的是提供一种可以用来识别物理设备的寻址方案（例如，MAC 地址）。桥接器和交换机是操作在数据链路层的物理设备。'
- en: '**Physical layer (layer 1)**   The layer at the bottom of the OSI model is
    the physical medium through which network data is transferred. This layer defines
    the physical and electrical nature of all hardware used, including voltages, hubs,
    network adapters, repeaters, and cabling specifications. The physical layer establishes
    and terminates connections, provides a means of sharing communication resources,
    and converts signals from digital to analog and vice versa.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**物理层（第 1 层）**  OSI 模型最底层是网络数据传输的物理介质。此层定义了所有硬件的物理和电气特性，包括电压、集线器、网络适配器、中继器和电缆规格。物理层建立和终止连接，提供共享通信资源的方式，并将信号从数字转换为模拟，反之亦然。'
- en: '**NOTE**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A common mnemonic device for remembering the layers of the OSI model is* Please
    Do Not Throw Sausage Pizza Away. *The first letter of each word refers to each
    layer of the OSI model, starting with the first layer.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*记忆 OSI 模型各层的一种常用助记符是* Please Do Not Throw Sausage Pizza Away. *每个单词的首字母代表
    OSI 模型的每一层，从第一层开始。*'
- en: '[Table 1-1](ch01.xhtml#ch01tab1) lists some of the more common protocols used
    at each layer of the OSI model.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-1](ch01.xhtml#ch01tab1) 列出了 OSI 模型各层中常用的一些协议。'
- en: '**Table 1-1:** Typical Protocols Used at Each Layer of the OSI Model'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-1：** OSI 模型各层中常用的协议'
- en: '| **Layer** | **Protocols** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **层级** | **协议** |'
- en: '| --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Application | HTTP, SMTP, FTP, Telnet |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 应用层 | HTTP, SMTP, FTP, Telnet |'
- en: '| Presentation | ASCII, MPEG, JPEG, MIDI |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 表现层 | ASCII, MPEG, JPEG, MIDI |'
- en: '| Session | NetBIOS, SAP, SDP, NWLink |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 会话层 | NetBIOS, SAP, SDP, NWLink |'
- en: '| Transport | TCP, UDP, SPX |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 传输层 | TCP, UDP, SPX |'
- en: '| Network | IP, IPX |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 网络层 | IP, IPX |'
- en: '| Data link | Ethernet, Token Ring, FDDI, AppleTalk |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 数据链路层 | 以太网, 令牌环, FDDI, AppleTalk |'
- en: '| Physical | wired, wireless |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 物理层 | 有线, 无线 |'
- en: Although the OSI model is no more than a recommended standard, you should know
    it by heart as it provides a useful vocabulary for thinking about and describing
    network problems. As we progress through this book, you will find that router
    issues soon become “layer 3 problems” and software issues are readily recognized
    as “layer 7 problems.”
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 OSI 模型仅仅是一个推荐标准，但你应该将它记住，因为它为思考和描述网络问题提供了有用的词汇。随着我们深入本书，你会发现路由器问题很快就成为“第
    3 层问题”，而软件问题则被迅速识别为“第 7 层问题”。
- en: '**NOTE**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A colleague once told me about a user who complained that he could not access
    a network resource. The issue was the result of the user’s entering an incorrect
    password. My colleague referred to this as a* layer 8 issue. *Layer 8 is the unofficial
    user layer. This term is commonly used among those who live at the packet level.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*有一次，一位同事告诉我，某用户抱怨无法访问网络资源。问题的根本原因是用户输入了错误的密码。我的同事将此称为* 第 8 层问题。 *第 8 层是非官方的用户层。这个术语在那些生活在数据包层次的人中非常常见。*'
- en: '**Data Flow Through the OSI Model**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**数据流通过 OSI 模型**'
- en: The initial data transfer on a network begins at the application layer of the
    transmitting system. Data works its way down the seven layers of the OSI model
    until it reaches the physical layer, at which point the physical layer of the
    transmitting system sends the data to the receiving system. The receiving system
    picks up the data at its physical layer, and the data proceeds up the layers of
    the receiving system to the application layer at the top.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上的初始数据传输始于发送系统的应用层。数据逐层通过 OSI 模型的七个层级，直到到达物理层，此时发送系统的物理层将数据发送到接收系统。接收系统在其物理层接收数据，然后数据沿着接收系统的各层向上传递，最终到达最上层的应用层。
- en: Each layer in the OSI model is capable of communicating only with the layers
    directly above and below it. For example, layer 2 can send and receive data only
    from layers 1 and 3.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: OSI 模型中的每一层只能与其上下直接相邻的层进行通信。例如，第 2 层只能与第 1 层和第 3 层进行数据交换。
- en: None of the services provided by various protocols at any given level of the
    OSI is redundant. For example, if a protocol at one layer provides a particular
    service, then no other protocol at any other layer will provide this same service.
    Protocols at different levels may have features with similar goals, but they will
    function a bit differently.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OSI 的任何给定层级中，各种协议提供的服务都不是冗余的。例如，如果某一层的协议提供了特定服务，那么其他层级的协议将不会提供相同的服务。不同层级的协议可能具有类似的目标，但它们的实现方式会有所不同。
- en: Protocols at corresponding layers on the sending and receiving devices are complementary.
    So, for example, if a protocol at layer 7 of the sending device is responsible
    for formatting the data being transmitted, the corresponding protocol at layer
    7 of the receiving device is expected to be responsible for reading that formatted
    data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 发送和接收设备上对应层次的协议是互补的。例如，如果发送设备第 7 层的协议负责格式化传输的数据，那么接收设备第 7 层的对应协议则应负责读取这些格式化的数据。
- en: '[Figure 1-2](ch01.xhtml#ch01fig2) is a graphical representation of the OSI
    model as it relates to two communicating devices. You can see communication going
    from top to bottom on one device and then reversing when it reaches the second
    device.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-2](ch01.xhtml#ch01fig2) 是 OSI 模型与两个通信设备相关的图示。你可以看到数据从一个设备的顶部向下传输，随后当数据到达第二个设备时，传输方向会反转。'
- en: '![image](../images/f07-01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f07-01.jpg)'
- en: '*Figure 1-2: Protocols working at the same layer on both the sending and receiving
    systems*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-2：发送和接收系统中相同层次工作的协议*'
- en: '**Data Encapsulation**'
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**数据封装**'
- en: The protocols at different layers of the OSI model pass data between each other
    with the aid of *data encapsulation*. Each layer in the stack is responsible for
    adding a header or footer—extra bits of information that allow the layers to communicate—to
    the data being transferred. For example, when the transport layer receives data
    from the session layer, the transport layer adds its own header information to
    that data before passing it to the network layer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: OSI 模型中不同层次的协议通过*数据封装*相互传递数据。堆栈中的每一层都负责在传输的数据上添加一个头部或尾部——这些附加的位置信息允许各层之间进行通信。例如，当传输层从会话层接收数据时，传输层会在传输的数据上添加自己的头部信息，然后将其传递给网络层。
- en: The encapsulation process creates a protocol data unit (PDU), which includes
    the data being sent and all header or footer information added to it. As data
    moves down the OSI model and the various protocols add header and footer information,
    the PDU changes and grows. The PDU is in its final form when it reaches the physical
    layer, at which point it is sent to the destination device. The receiving device
    strips the protocol headers and footers from the PDU as the data climbs up the
    OSI layers in the reverse of the order they were added. Once the PDU reaches the
    top layer of the OSI model, only the original application layer data remains.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 封装过程会创建一个协议数据单元（PDU），它包括被发送的数据和所有附加的头部或尾部信息。随着数据沿着 OSI 模型向下流动，各种协议会添加头部和尾部信息，PDU
    会发生变化并不断增长。当 PDU 到达物理层时，它已处于最终形式，此时它将被发送到目标设备。接收设备在数据沿着 OSI 层次反向流动时，会去除 PDU 中的协议头部和尾部。最终，当
    PDU 到达 OSI 模型的顶层时，只剩下原始的应用层数据。
- en: '**NOTE**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The OSI model uses specific terms to describe packaged data at each layer.
    The physical layer contains bits, the data link layer contains frames, the network
    layer contains packets, and the transport layer contains segments. The top three
    layers simply use the term* data. *This nomenclature isn’t used much in practice,
    so we’ll generally just use the term* packet *to refer to a complete or partial
    PDU that includes header and footer information from a few or many layers of the
    OSI model.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*OSI 模型使用特定的术语来描述每个层次中的封装数据。物理层包含比特，数据链路层包含帧，网络层包含数据包，传输层包含段。前三层仅使用数据一词。*这种命名法在实践中并不常用，因此我们通常仅使用数据包*一词来指代包括来自一个或多个
    OSI 模型层的头部和尾部信息的完整或部分 PDU。*'
- en: To illustrate how encapsulation of data works, we’ll look at a simplified practical
    example of a packet being built, transmitted, and received in relation to the
    OSI model. Keep in mind that as analysts, we don’t often talk about the session
    or presentation layers, so those will be absent in this example (and the rest
    of this book).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明数据封装是如何工作的，我们将通过一个简化的实际示例来展示数据包的构建、传输和接收过程，这与 OSI 模型有关。请记住，作为分析师，我们通常不会讨论会话层或表现层，因此在这个示例中（以及本书的其余部分）这两个层将不涉及。
- en: In this scenario, we are attempting to browse to *[http://www.google.com/](http://www.google.com/)*.
    First, we must generate a request packet that is transmitted from our source client
    computer to the destination server computer. This scenario assumes that a TCP/IP
    communication session has already been initiated. [Figure 1-3](ch01.xhtml#ch01fig3)
    illustrates the data encapsulation process in this example.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景中，我们正在尝试浏览* [http://www.google.com/](http://www.google.com/) *。首先，我们必须生成一个请求数据包，该数据包从我们的源客户端计算机传输到目标服务器计算机。此场景假设
    TCP/IP 通信会话已经建立。[图1-3](ch01.xhtml#ch01fig3)展示了此示例中的数据封装过程。
- en: We begin on our client computer at the application layer. We are browsing to
    a website, so the application layer protocol being used is HTTP; the HTTP protocol
    will issue a command to download the file *index.html* from *[google.com](http://google.com)*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从客户端计算机的应用层开始。我们正在浏览一个网站，因此所使用的应用层协议是 HTTP；HTTP 协议将发出命令，从* [google.com](http://google.com)
    *下载文件* index.html*。
- en: '**NOTE**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In practice, the browser will request the website document root first, signified
    by a forward slash (/). When the web server receives this request, it will redirect
    the browser to whatever file it is configured to serve upon receiving a document
    root request. This is usually something like* index.html *or* index.php. *We’ll
    cover this more in [Chapter 9](ch09.xhtml#ch09) when we discuss HTTP.*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*在实际操作中，浏览器首先会请求网站的文档根目录，这通常用斜杠（/）表示。当 web 服务器收到此请求时，它会将浏览器重定向到配置文件中指定的文件，通常是*
    index.html *或* index.php。 *我们将在[第9章](ch09.xhtml#ch09)讨论HTTP时进一步介绍这一过程。*'
- en: Once our application layer protocol has sent the command, our concern is with
    getting the packet to its destination. The data in our packet is passed down the
    OSI stack to the transport layer. HTTP is an application layer protocol that uses
    (or *sits on*) TCP, so TCP serves as the transport layer protocol used to ensure
    reliable delivery of the packet. A TCP header is generated and added to the PDU,
    as shown in the transport layer of [Figure 1-3](ch01.xhtml#ch01fig3). This TCP
    header includes sequence numbers and other data that are appended to the packet,
    ensuring that the packet is properly delivered.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的应用层协议发送了命令，我们关注的就是如何将数据包送达目标。数据包中的数据会沿着 OSI 协议栈向下传递到传输层。HTTP 是一个应用层协议，它使用（或*基于*）TCP，因此
    TCP 作为传输层协议，确保数据包的可靠传输。生成一个 TCP 头，并将其添加到 PDU 中，如[图1-3](ch01.xhtml#ch01fig3)所示。此
    TCP 头包含序列号及其他数据，这些信息会附加到数据包中，确保数据包的正确传送。
- en: '![image](../images/f09-01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f09-01.jpg)'
- en: '*Figure 1-3: A graphical representation of encapsulation of data between client
    and server*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-3：客户端和服务器之间数据封装的图形表示*'
- en: '**NOTE**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We often say that one protocol “sits on” or “rides on” another protocol because
    of the top-down design of the OSI model. An application protocol such as HTTP
    provides a particular service and relies on TCP to ensure reliable delivery of
    its service. Both of those services rely on the IP protocol at the network level
    to address and deliver their data. Therefore, HTTP sits on TCP, which sits on
    IP.*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们常说一个协议“依赖于”或“建立在”另一个协议之上，因为OSI模型的自上而下设计。例如，像HTTP这样的应用协议提供特定服务，并依赖TCP确保其服务的可靠交付。这两种服务都依赖网络层的IP协议来寻址和传递数据。因此，HTTP建立在TCP之上，而TCP则建立在IP之上。*'
- en: Having done its job, TCP hands the packet off to IP, which is the layer 3 protocol
    responsible for the logical addressing of the packet. IP creates a header containing
    logical addressing information, adds it to the PDU, and passes the packet along
    to the Ethernet on the data link layer. Physical Ethernet addresses are stored
    in the Ethernet header. The packet is now fully assembled and passed to the physical
    layer, where it is transmitted as zeros and ones across the network.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完成其工作后，TCP将数据包交给IP，后者是负责数据包逻辑寻址的第三层协议。IP创建一个包含逻辑寻址信息的头部，将其添加到PDU中，并将数据包传递到数据链路层的以太网。物理以太网地址存储在以太网头部中。数据包现在已经完全组装好，并传递到物理层，在那里它以零和一的形式穿越网络。
- en: The completed packet traverses the network cabling system, eventually reaching
    the Google web server. The web server begins by reading the packet from the bottom
    up, meaning that it first reads the data link layer, which contains the physical
    Ethernet addressing information that the network card uses to determine that the
    packet is intended for a particular server. Once this information is processed,
    the layer 2 information is stripped away, and the layer 3 information is processed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的数据包穿过网络布线系统，最终到达Google Web服务器。Web服务器首先从底层向上读取数据包，这意味着它首先读取数据链路层，其中包含网络卡用来确定数据包是否指向特定服务器的物理以太网地址信息。一旦这些信息处理完毕，第二层信息会被去除，接着处理第三层信息。
- en: The layer 3 IP addressing information is read to ensure that the packet is properly
    addressed and is not fragmented. This data is also stripped away so that the next
    layer can be processed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第3层的IP寻址信息被读取，以确保数据包地址正确并且未被分段。此数据也会被去除，以便处理下一个层次的信息。
- en: Layer 4 TCP information is now read to ensure that the packet has arrived in
    sequence. Then the layer 4 header information is stripped away to leave only the
    application layer data, which can be passed to the web server application hosting
    the website. In response to this packet from the client, the server should transmit
    a TCP acknowledgment packet so the client knows its request was received, followed
    by the *index.html* file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第4层TCP信息现在被读取，以确保数据包按顺序到达。然后，第4层的头部信息被去除，只留下应用层数据，这些数据可以传递给托管网站的Web服务器应用程序。为了响应来自客户端的数据包，服务器应该传输一个TCP确认数据包，以便客户端知道它的请求已被接收，随后是*index.html*文件。
- en: All packets are built and processed as described in this example, regardless
    of which protocols are used. But at the same time, keep in mind that not every
    packet on a network is generated from an application layer protocol, so you will
    see packets that contain only information from layer 2, 3, or 4 protocols.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的数据包都是按照这个示例中的描述构建和处理的，无论使用什么协议。但是，同时请记住，并非每个网络上的数据包都是由应用层协议生成的，因此你会看到只包含第二层、第三层或第四层协议信息的数据包。
- en: '***Network Hardware***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***网络硬件***'
- en: 'Now it’s time to look at network hardware, where the dirty work is done. We’ll
    focus on just a few of the more common pieces of network hardware: hubs, switches,
    and routers.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看网络硬件了，这是完成“脏活”的地方。我们将重点介绍一些常见的网络硬件：集线器、交换机和路由器。
- en: '**Hubs**'
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**集线器**'
- en: A *hub* is generally a box with multiple RJ-45 ports, like the NETGEAR hub shown
    in [Figure 1-4](ch01.xhtml#ch01fig4). Hubs range from very small 4-port devices
    to larger 48-port devices designed for rack mounting in a corporate environment.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*集线器*通常是一个带有多个RJ-45端口的盒子，像[图 1-4](ch01.xhtml#ch01fig4)所示的NETGEAR集线器。集线器的大小从非常小的4端口设备到设计用于在企业环境中机架安装的更大48端口设备不等。'
- en: '![image](../images/f10-01.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f10-01.jpg)'
- en: '*Figure 1-4: A typical 4-port Ethernet hub*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-4：典型的4端口以太网集线器*'
- en: Because hubs can generate a lot of unnecessary network traffic and are capable
    of operating only in *half-duplex mode* (they cannot send and receive data at
    the same time), you won’t typically see them used in most modern or high-density
    networks; switches are used instead (discussed in the next section). However,
    you should know how hubs work, since they will be very important to packet analysis
    when using the “hubbing out” technique discussed in [Chapter 2](ch02.xhtml#ch02).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: A hub is no more than a *repeating device* that operates on the physical layer
    of the OSI model. It takes packets sent from one port and transmits (repeats)
    them to every other port on the device, and it’s up to the receiving device to
    accept or reject each packet. For example, if a computer on port 1 of a 4-port
    hub needs to send data to a computer on port 2, the hub sends those packets to
    ports 2, 3, and 4\. The clients connected to ports 3 and 4 examine the destination
    Media Access Control (MAC) address field in the Ethernet header of the packet
    and see that the packet is not for them, so they *drop* (discard) the packet.
    [Figure 1-5](ch01.xhtml#ch01fig5) illustrates an example in which computer A is
    transmitting data to computer B. When computer A sends this data, all computers
    connected to the hub receive it. However, only computer B actually accepts the
    data; the other computers discard it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f11-01.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-5: The flow of traffic when computer A transmits data to computer
    B through a hub*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: As an analogy, suppose that you sent an email with the subject line “Attention
    all marketing staff” to every employee in your company, rather than to only those
    people who work in the marketing department. The marketing department employees
    see the email is for them and open it. The other employees see it’s not for them
    and discard it. You can see how this approach to communication would result in
    a lot of unnecessary traffic and wasted time, yet this is exactly how a hub functions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The best alternatives to hubs in production and high-density networks are *switches*,
    which are *full-duplex devices* that can send and receive data synchronously.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '**Switches**'
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Like a hub, a switch is designed to repeat packets. However, unlike a hub, rather
    than broadcasting data to every port, a switch sends data to only the computer
    for which the data is intended. Switches look just like hubs, as shown in [Figure
    1-6](ch01.xhtml#ch01fig6).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f12-01.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-6: A rack-mountable 48-port Ethernet switch*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Several larger switches on the market, such as Cisco-branded ones, are managed
    via specialized, vendor-specific software or web interfaces. These switches are
    commonly referred to as *managed switches*. Managed switches provide several features
    that can be useful in network management, including the ability to enable or disable
    specific ports, view port statistics, make configuration changes, and remotely
    reboot.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Switches also offer advanced functionality for handling transmitted packets.
    To be able to communicate directly with specific devices, switches must be able
    to uniquely identify devices based on their MAC addresses, which means that they
    must operate on the data link layer of the OSI model.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Switches store the layer 2 address of every connected device in a *CAM table*,
    which acts as a kind of traffic cop. When a packet is transmitted, the switch
    reads the layer 2 header information in the packet and, using the CAM table as
    reference, determines to which port(s) to send the packet. Switches send packets
    only to specific ports, thus greatly reducing network traffic.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-7](ch01.xhtml#ch01fig7) illustrates traffic flow through a switch.
    In this figure, computer A is sending data to only the intended recipient: computer
    B. Multiple conversations can happen on the network at the same time, but information
    is communicated directly between the switch and intended recipient, not between
    the switch and all connected computers.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f12-02.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-7: The flow of traffic when computer A transmits data to computer
    B through a switch*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Routers**'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *router* is an advanced network device with a much higher level of functionality
    than a switch or a hub. A router can take many shapes and forms, but most devices
    have several LED indicator lights on the front and a few network ports on the
    back, depending on the size of the network. [Figure 1-8](ch01.xhtml#ch01fig8)
    shows an example of a small router.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f13-01.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-8: A low-level Enterasys router suitable for use in a small to midsized
    network*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Routers operate at layer 3 of the OSI model, where they are responsible for
    forwarding packets between two or more networks. The process used by routers to
    direct the flow of traffic among networks is called *routing*. Several types of
    routing protocols dictate how different types of packets are routed to other networks.
    Routers commonly use layer 3 addresses (such as IP addresses) to uniquely identify
    devices on a network.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: A good way to illustrate the concept of routing is to use the analogy of a neighborhood
    with several streets. Think of the houses, with their addresses, as computers.
    Then think of each street as a network segment. [Figure 1-9](ch01.xhtml#ch01fig9)
    illustrates this comparison. From your house, you can easily go visit your neighbors
    in the other houses on the same street by walking in a straight line from your
    front door to theirs. In the same way, a switch allows communication among all
    computers on a network segment.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: However, communicating with a neighbor who lives on another street is like communicating
    with a computer that is not on the same segment. Referring to [Figure 1-9](ch01.xhtml#ch01fig9),
    let’s say that you’re sitting at 502 Vine Street and need to get to 206 Dogwood
    Lane. In order to do this, you must first turn onto Oak Street and then turn onto
    Dogwood Lane. Think of this as crossing network segments. If the device at 192.168.0.3
    needs to communicate with the device at 192.168.0.54, it must cross a router to
    get to the 10.100.1.x network and then cross the destination network segment’s
    router before it can get to the destination network segment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The size and number of routers on a network will typically depend on the network’s
    size and function. Personal and home office networks may have only a small router
    located at the edge of the network. A large corporate network might have several
    routers spread throughout various departments, all connecting to one large central
    router or layer 3 switch (an advanced type of switch that also has built-in functionality
    to act as a router).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f14-01.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-9: Comparison of a routed network to neighborhood streets*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: As you look at more and more network diagrams, you will come to understand how
    data flows through these various points. [Figure 1-10](ch01.xhtml#ch01fig10) shows
    the layout of a very common form of routed network. In this example, two separate
    networks are connected via a single router. If a computer on network A wishes
    to communicate with a computer on network B, the transmitted data must go through
    the router.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f14-02.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-10: The flow of traffic when computer A on one network transmits
    data to computer X on another network through a router*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '**Traffic Classifications**'
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Network traffic can be classified as one of three types: broadcast, multicast,
    and unicast. Each classification has a distinct characteristic that determines
    how packets in that class are handled by networking hardware.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '***Broadcast Traffic***'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *broadcast packet* is a packet that’s sent to all ports on a network segment,
    regardless of whether a given port is a hub or switch.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: There are layer 2 and layer 3 forms of broadcast traffic. On layer 2, the MAC
    address ff:ff:ff:ff:ff:ff is the reserved broadcast address, and any traffic sent
    to this address is broadcast to the entire network segment. Layer 3 also has a
    specific broadcast address, but it varies based on the network address range in
    use.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The highest possible IP address in an IP network range is reserved for use as
    the broadcast address. For example, if your computer has an address of 192.168.0.20
    and a 255.255.255.0 subnet mask, then 192.168.0.255 is the broadcast address (more
    on IP addressing in [Chapter 7](ch07.xhtml#ch07)).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The extent to which broadcast packets can travel is called the *broadcast domain*,
    which is the network segment where any computer can directly transmit to another
    computer without going through a router. In larger networks with multiple hubs
    or switches connected via different media, broadcast packets transmitted from
    one switch reach all the ports on all the other switches on the network, as the
    packets are repeated from switch to switch. [Figure 1-11](ch01.xhtml#ch01fig11)
    shows an example of two broadcast domains on a small network. Because each broadcast
    domain extends until it reaches the router, broadcast packets circulate only within
    this specified broadcast domain.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f15-01.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-11: A broadcast domain extends to everything behind the current routed
    segment.*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Our earlier neighborhood analogy provides good insight into how broadcast domains
    work, too. You can think of a broadcast domain as being like a neighborhood street
    where all your neighbors are sitting on their front porch. If you stand on your
    front porch and yell, the people on your street will be able to hear you. However,
    if you want to talk to someone on a different street, you need to find a way to
    speak to that person directly, rather than broadcasting (yelling) from your front
    porch.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '***Multicast Traffic***'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Multicast* is a means of transmitting a packet from a single source to multiple
    destinations simultaneously. The goal of multicasting is to use as little bandwidth
    as possible. The optimization of this traffic lies in that a stream of data is
    replicated fewer times along its path to its destination. The exact handling of
    multicast traffic is highly dependent on its implementation in individual protocols.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The primary method of implementing multicast traffic is via an addressing scheme
    that joins the packet recipients to a multicast group. This is how IP multicast
    works. This addressing scheme ensures that the packets cannot be transmitted to
    computers to which the packets are not destined. In fact, IP devotes an entire
    range of addresses to multicast. If you see an IP address in the 224.0.0.0 to
    239.255.255.255 range, it is most likely handling multicast traffic because these
    ranges are reserved for that purpose.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '***Unicast Traffic***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *unicast packet* is transmitted from one computer directly to another. The
    details of how unicast functions are dependent on the protocol using it. For example,
    consider a device that wishes to communicate with a web server. This is a one-to-one
    connection, so this communication process would begin with the client device transmitting
    a packet to only the web server.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '**Final Thoughts**'
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter covered the basics of networking that you need as a foundation
    for packet analysis. You *must* understand what is going on at this level of network
    communication before you can begin troubleshooting network issues. In [Chapter
    2](ch02.xhtml#ch02), we will look at multiple techniques for capturing the packets
    you want to analyze.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了你作为数据包分析基础所需的网络基础知识。在开始排查网络问题之前，你*必须*理解这一层次的网络通信发生了什么。在[第二章](ch02.xhtml#ch02)中，我们将探讨多种捕获你需要分析的数据包的技术。
