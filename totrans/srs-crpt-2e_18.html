<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_255" aria-label="255"/>&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch13">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">TLS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="401" height="386"/></figure>&#13;
<p class="TNI1">The <i>Transport Layer Security (TLS) protocol</i> is the workhorse of internet security. TLS protects connections between servers and clients, whether between a website and its visitors, email servers, a mobile application and its servers, or video game servers and players. Without TLS, the internet wouldn’t be very secure.</p>&#13;
<p class="TX">TLS is application agnostic, meaning you can use it for web-based applications that rely on the HTTP protocol, as well as for any system where a client computer or device needs to initiate a connection with a remote server. For example, TLS is widely used for machine-to-machine communications in internet of things (IoT) applications, such as smart refrigerators that communicate with remote servers.</p>&#13;
<p class="TX">This chapter provides an abbreviated view of TLS, which has become increasingly complex over the years. Unfortunately, complexity and bloat brought multiple vulnerabilities, and bugs found in its cluttered <span role="doc-pagebreak" epub:type="pagebreak" id="pg_256" aria-label="256"/>implementations have made headlines—Heartbleed, BEAST, CRIME, and POODLE are all vulnerabilities that impacted millions of web servers.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You may see folks refer to TLS as</i> <span class="note_Italic">Secure Sockets Layer (SSL)</span><i>, which is the name of its predecessor.</i></p>&#13;
<p class="TX">In 2013, engineers started working on TLS 1.3. As you’ll learn in this chapter, TLS 1.3 ditched unnecessary and insecure features and replaced old algorithms with then state-of-the-art ones. The result is a simpler, faster, and more secure protocol.</p>&#13;
<p class="TX">Before we explore how TLS 1.3 works, let’s review the problem that TLS aims to solve and the reason for its existence.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-90"/><samp class="SANS_Futura_Std_Bold_B_11">Target Applications and Requirements</samp></h3>&#13;
<p class="TNI">TLS is the <i>S</i> in HTTPS websites, and the padlock that appears in a browser’s address bar indicates that a page is secure. The primary driver for creating TLS was to enable secure browsing in applications such as e-commerce or e-banking, by authenticating the site and encrypting traffic to protect sensitive information such as personal data, credit card numbers, and user credentials.</p>&#13;
<p class="TX">TLS also helps protect general internet-based communication by establishing a <i>secure channel</i> between a client and a server that ensures the data transferred is confidential, authenticated, and unmodified.</p>&#13;
<p class="TX">One of TLS’s security goals is to prevent man-in-the-middle attacks, wherein an attacker intercepts encrypted traffic from the transmitting party, decrypts the traffic to capture the clear content, and reencrypts it to send to the receiving party. TLS defeats these attacks by authenticating servers (and optionally clients) using certificates and trusted certificate authorities, as we’ll discuss in “<span class="Xref">Certificates and Certificate Authorities</span>” on <span class="Xref"><a href="#sec5">page 258</a></span>.</p>&#13;
<p class="TX">To ensure wide adoption, TLS needed to satisfy four more requirements: efficiency, interoperability, extensibility, and versatility. For TLS, efficiency means minimizing the performance penalty compared with unencrypted connections. This is good for both the server (to reduce the cost of hardware for the service providers) and the clients (to avoid perceptible delays or the reduction of the battery life of mobile devices). The protocol needed to be interoperable so that it would work on any hardware and any operating system. It was to be extensible so that it could support additional features or algorithms. And it had to be versatile—that is, not bound to a specific application. This parallels the Transport Control Protocol (TCP), which doesn’t care about the application protocol used on top of it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H1" id="sec2"><span id="h1-91"/><samp class="SANS_Futura_Std_Bold_B_11">The TLS Protocol Suite</samp></h3>&#13;
<p class="TNI">To protect client-server communications, TLS consists of multiple versions of several protocols that form the TLS protocol <i>suite</i>. TLS is not a transport protocol and usually sits between the transport protocol (TCP) and an <span role="doc-pagebreak" epub:type="pagebreak" id="pg_257" aria-label="257"/>application layer protocol such as HTTP or SMTP, to secure data transmitted over a TCP connection.</p>&#13;
<p class="TX">TLS also works over the <i>User Datagram Protocol (UDP)</i> transport protocol, which is used for “connectionless” transmissions when latency must be minimal, such as audio or video streaming and online gaming. However, unlike TCP, UDP doesn’t guarantee delivery or correct packet ordering. The UDP version of TLS, <i>Datagram Transport Layer Security (DTLS)</i>, is therefore slightly different. For more on TCP and UDP, see Charles Kozierok’s <i>The TCP/IP Guide</i> (No Starch Press, 2005).</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-159"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The TLS and SSL Families of Protocols</samp></h4>&#13;
<p class="TNI">TLS began in 1995 when Netscape developed TLS’s ancestor, the SSL protocol. SSL was far from perfect, and both SSL 2.0 and SSL 3.0 had security flaws. You should never use SSL, and you should always use TLS—what adds to the confusion is that people often refer to TLS as SSL, including security experts.</p>&#13;
<p class="TX">Not all versions of TLS are secure. TLS 1.0 (1999) is the least secure version, though it’s still more secure than SSL 3.0. TLS 1.1 (2006) is better but includes a number of weak algorithms. TLS 1.2 (2008) is better yet, but it’s complex and provides high security only if configured correctly. Also, its complexity increases the risk of bugs in implementations and the risk of incorrect configurations. For example, TLS 1.2 supports AES in CBC mode, which is often vulnerable to padding oracle attacks.</p>&#13;
<p class="TX">TLS 1.2 inherited dozens of features and design choices from earlier versions of TLS that make it suboptimal in terms of security and performance. To clean up this mess, cryptography engineers reinvented TLS—keeping only the good parts and adding security features. The result is TLS 1.3, an overhaul that’s simplified a bloated design and made it more secure, more efficient, and simpler. Essentially, TLS 1.3 is mature TLS.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h4 class="H2" id="sec4"><span id="h2-160"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TLS in a Nutshell</samp></h4>&#13;
<p class="TNI">TLS has two main protocols: the <i>handshake protocol</i> (or just <i>handshake</i>) determines the secret keys shared between the two parties; the <i>record protocol</i> describes how to use these keys to protect data. The data packets TLS processes are called <i>records</i>. TLS defines a packet format for encapsulating data from higher-layer protocols for transmission to another party.</p>&#13;
<p class="TX">The handshake starts with a client that initiates a secure connection with a server. The client sends an initial message called ClientHello with parameters that include the cipher it wants to use. The server checks this message and its parameters and then responds with a ServerHello message. Once the client and the server process each other’s messages, they’re ready to exchange encrypted data using session keys established through the handshake protocol, as you’ll see in “<span class="Xref">The TLS Handshake Protocol</span>” on <span class="Xref"><a href="#sec10">page 263</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_258" aria-label="258"/>&#13;
<h4 class="H2" id="sec5"><span id="h2-161"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Certificates and Certificate Authorities</samp></h4>&#13;
<p class="TNI">The most critical step in the TLS handshake, and the crux of TLS’s security, is the <i>certificate validation step</i>, wherein a server uses a certificate to authenticate itself to a client.</p>&#13;
<p class="TX">A <i>certificate</i> is essentially a public key accompanied by a signature of that key and associated information (including the domain name). For example, when connecting to <i><a href="https://www.google.com">https://<wbr/>www<wbr/>.google<wbr/>.com</a></i>, your browser receives a certificate from some network host and then verifies the certificate’s signature, which reads something like “I am <i>google.com</i>, and my public key is [<i>key</i>].” If the signature is verified, the certificate and its public key are <i>trusted</i>, and the browser proceeds with establishing the connection. (See <span class="Xref"><a href="chapter10.xhtml">Chapters 10</a></span> and <span class="Xref"><a href="chapter12.xhtml">12</a></span> for details regarding signatures.)</p>&#13;
<p class="TX">The browser knows the public key needed to verify the signature through a <i>certificate authority (CA)</i>, which is essentially a public key hardcoded in your browser or operating system. The public key’s private key (that is, its signing capability) belongs to a trusted organization that ensures the public keys in certificates it issues belong to the website or entity that claims them. That is, a CA acts as a <i>trusted third party</i>. Without CAs, there’s no way to verify that the public key served by <i>google.com</i> belongs to Google and not to an eavesdropper performing a man-in-the-middle attack.</p>&#13;
<p class="TX">For example, <a href="chapter13.xhtml#Lis13-1">Listing 13-1</a> shows what happens when you use the OpenSSL command line tool to initiate a TLS connection to <i>www.google.com</i> on port 443, the network port used for TLS-based HTTP connections (HTTPS).</p>&#13;
<span id="Lis13-1"/><pre><code>$ <b>openssl s_client -connect www.google.com:443</b>&#13;
CONNECTED(00000003)&#13;
---&#13;
Certificate chain&#13;
 0 s:CN = www.google.com&#13;
   i:C = US, O = Google Trust Services LLC, CN = GTS CA 1C3&#13;
 1 s:C = US, O = Google Trust Services LLC, CN = GTS CA 1C3&#13;
   i:C = US, O = Google Trust Services LLC, CN = GTS Root R1&#13;
 2 s:C = US, O = Google Trust Services LLC, CN = GTS Root R1&#13;
   i:C = BE, O = GlobalSign nv-sa, OU = Root CA, CN = GlobalSign Root CA&#13;
---&#13;
Server certificate&#13;
-----BEGIN CERTIFICATE-----&#13;
MIIEiDCCA3CgAwIBAgIQNJvIv7ypW9IQHaA7P69MzzANBgkqhkiG9w0BAQsFADBG&#13;
MQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExM&#13;
QzETMBEGA1UEAxMKR1RTIENBIDFDMzAeFw0yMzA5MDQwODIzMjlaFw0yMzExMjcw&#13;
ODIzMjhaMBkxFzAVBgNVBAMTDnd3dy5nb29nbGUuY29tMFkwEwYHKoZIzj0CAQYI&#13;
KoZIzj0DAQcDQgAENEMvWAY0TRTb0w5ZxbUbX/Z+EcviE50SzQzvP/xyyVIaURM4&#13;
A0Jer9IJO/6Iq6o2AfDXUxrdBKpSzlzaeFCaqqOCAmgwggJkMA4GA1UdDwEB/wQE&#13;
AwIHgDATBgNVHSUEDDAKBggrBgEFBQcDATAMBgNVHRMBAf8EAjAAMB0GA1UdDgQW&#13;
BBRnwQnVC8ok1e6YPIbQwjB+XFpPRjAfBgNVHSMEGDAWgBSKdH+vhc3ulc09nNDi&#13;
RhTzcTUdJzBqBggrBgEFBQcBAQReMFwwJwYIKwYBBQUHMAGGG2h0dHA6Ly9vY3Nw&#13;
LnBraS5nb29nL2d0czFjMzAxBggrBgEFBQcwAoYlaHR0cDovL3BraS5nb29nL3Jl&#13;
cG8vY2VydHMvZ3RzMWMzLmRlcjAZBgNVHREEEjAQgg53d3cuZ29vZ2xlLmNvbTAh&#13;
BgNVHSAEGjAYMAgGBmeBDAECATAMBgorBgEEAdZ5AgUDMDwGA1UdHwQ1MDMwMaAv&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_259" aria-label="259"/>oC2GK2h0dHA6Ly9jcmxzLnBraS5nb29nL2d0czFjMy9mVkp4YlYtS3Rtay5jcmww&#13;
ggEFBgorBgEEAdZ5AgQCBIH2BIHzAPEAdgDoPtDaPvUGNTLnVyi8iWvJA9PL0RFr&#13;
7Otp4Xd9bQa9bgAAAYpfgRjOAAAEAwBHMEUCID+BcS984SEh2E2UrKfLvF2fG7qa&#13;
SYkzbELytrDz91wmAiEAlwOPMM26CynmadsqomPMXKdRNMvzdyciHVimh0snrBAA&#13;
dwB6MoxU2LcttiDqOOBSHumEFnAyE4VNO9IrwTpXo1LrUgAAAYpfgRkAAAAEAwBI&#13;
MEYCIQDZf1tULkVCXRc68zJwgp5WFJUbTxFjz6CP+eLb3dgz3gIhAJ9uS7psu2Gl&#13;
HdTXokXTetMY7MCdIcuj60Qm/qTn+1dFMA0GCSqGSIb3DQEBCwUAA4IBAQCIEn0v&#13;
QzaqNCOhiI5TKcRhaR24yKid3F57a/GOM1LDE/v7oCm+3fxtvuK9HVa/Dmnvavqp&#13;
ci7TpMDj/ocXjE4dL4/yHaVx6GhTDKMW/bbBkDaqXoSdb9lAcUZPLRTV4AjFdjmB&#13;
8wZTf95bnfeuKNXWlbo/k/9pRRhFNKKMUI54xLiVdj4wk1EUAsrMTTn+Ol2ZbFeS&#13;
s614abBT5W0hhFkLvjvEht8p3UKQwwyhRjZMBsae/d0QfT8hglVtVhhGd7f1hFqI&#13;
XSERl8EsyDc3urCsa+RjUjCvE9Q+y2X8WVV0HPCjwsANU56qEZmh4kqgg5paW/SL&#13;
maM/8Vny/nKNd6Dj&#13;
-----END CERTIFICATE-----&#13;
subject=CN = www.google.com&#13;
&#13;
issuer=C = US, O = Google Trust Services LLC, CN = GTS CA 1C3&#13;
&#13;
---&#13;
No client certificate CA names sent&#13;
Peer signing digest: SHA256&#13;
Peer signature type: ECDSA&#13;
Server Temp Key: X25519, 253 bits&#13;
---&#13;
SSL handshake has read 4295 bytes and written 396 bytes&#13;
Verification: OK&#13;
---&#13;
New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384&#13;
Server public key is 256 bit&#13;
Secure Renegotiation IS NOT supported&#13;
Compression: NONE&#13;
Expansion: NONE&#13;
No ALPN negotiated&#13;
Early data was not sent&#13;
Verify return code: 0 (ok)</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-1: Establishing a TLS connection with</samp> <samp class="SANS_Futura_Std_Book_11"><a href="http://www.google.com">www<wbr/>.google<wbr/>.com</a></samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and receiving certificates to authenticate the connection</samp></p>&#13;
<p class="TX">The certificate data is between the <samp class="SANS_TheSansMonoCd_W5Regular_11">BEGIN CERTIFICATE</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">END CERTIFICATE</samp> markers. Before this, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Certificate chain</samp> contains a description of the certificate chain, wherein the lines beginning with <samp class="SANS_TheSansMonoCd_W5Regular_11">s:</samp> describe the <i>subject</i> of the certified entity, and the lines beginning with <samp class="SANS_TheSansMonoCd_W5Regular_11">i:</samp> describe the <i>issuer</i> of the signature. Certificate number 0 is received by <i><a href="http://www.google.com">www<wbr/>.google<wbr/>.com</a></i>, certificate 1 belongs to the entity that signed certificate 0, and certificate 2 belongs to the entity that signed certificate 1.</p>&#13;
<p class="TX">The organization that issued certificate 0 is Google (via the Google Trust Services entity, GTS), which authorized the issuance of certificate 0 for the domain name <i><a href="http://www.google.com">www<wbr/>.google<wbr/>.com</a></i> by signing the certificate with the private key GTS CA 1C3. The certificate attesting that this key belongs to the Google key hierarchy is certificate 1, which is signed by the GTS key Root R1, a root certificate within Google. Certificate 2, issued by GlobalSign <span role="doc-pagebreak" epub:type="pagebreak" id="pg_260" aria-label="260"/>(a recognized certification authority), attests that the GTS Root R1 key belongs to the Google organization.</p>&#13;
<p class="TX">In this example, your operating system usually already has certificates 1 and 2, which it considers trusted certificates. In such a case, you just need to check two signatures: Google’s GTS CA 1C3 entity in certificate 0 and Google’s GTS Root R1 entity in certificate 1. If your system doesn’t already include certificate 2 as a trusted certificate but has GlobalSign’s root certificate (GlobalSign Root CA), then you’ll also need to check GlobalSign’s signature in certificate 2.</p>&#13;
<p class="TX">Certificate authority organizations such as Google and GlobalSign must be trustworthy and issue certificates only to trustworthy entities, and they must protect their private keys in order to prevent an attacker from issuing certificates on their behalf (for example, to impersonate a legitimate <i><a href="http://www.google.com">www<wbr/>.google<wbr/>.com</a></i> server).</p>&#13;
<p class="TX">To see what’s in a certificate, enter the command <samp class="SANS_TheSansMonoCd_W7Bold_B_11">openssl x509 -text -noout</samp> in a Unix terminal and then paste the certificate in <a href="chapter13.xhtml#Lis13-1">Listing 13-1</a>. The output appears in <a href="chapter13.xhtml#Lis13-2">Listing 13-2</a>.</p>&#13;
<span id="Lis13-2"/><pre><code>$ <b>openssl x509 –text –noout</b>&#13;
Certificate:&#13;
  Data:&#13;
    Version: 3 (0x2)&#13;
    Serial Number:&#13;
      34:9b:c8:bf:bc:a9:5b:d2:10:1d:a0:3b:3f:af:4c:cf&#13;
    Signature Algorithm: sha256WithRSAEncryption&#13;
    Issuer: C = US, O = Google Trust Services LLC, CN = GTS CA 1C3&#13;
    Validity&#13;
      Not Before: Sep  4 08:23:29 . . .&#13;
      Not After : Nov 27 08:23:28 . . .&#13;
    Subject: CN = www.google.com&#13;
    Subject Public Key Info:&#13;
      Public Key Algorithm: id-ecPublicKey&#13;
        Public-Key: (256 bit)&#13;
        pub:&#13;
          04:34:43:2f:58:06:34:4d:14:db:d3:0e:59:c5:b5:&#13;
          1b:5f:f6:7e:11:cb:e2:13:9d:12:cd:0c:ef:3f:fc:&#13;
          72:c9:52:1a:51:13:38:03:42:5e:af:d2:09:3b:fe:&#13;
          88:ab:aa:36:01:f0:d7:53:1a:dd:04:aa:52:ce:5c:&#13;
          da:78:50:9a:aa&#13;
        ASN1 OID: prime256v1&#13;
        NIST CURVE: P-256&#13;
    X509v3 extensions:&#13;
      X509v3 Key Usage: critical&#13;
        Digital Signature&#13;
      X509v3 Extended Key Usage:&#13;
        TLS Web Server Authentication&#13;
      X509v3 Basic Constraints: critical&#13;
        CA:FALSE&#13;
      X509v3 Subject Key Identifier:&#13;
        67:C1:09:D5:0B:CA:24:D5:EE:98:3C:86:D0:C2:30:7E:5C:5A:4F:46&#13;
      X509v3 Authority Key Identifier:&#13;
        8A:74:7F:AF:85:CD:EE:95:CD:3D:9C:D0:E2:46:14:F3:71:35:1D:27&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_261" aria-label="261"/>      Authority Information Access:&#13;
        OCSP - URI:http://ocsp.pki.goog/gts1c3&#13;
        CA Issuers - URI:http://pki.goog/repo/certs/gts1c3.der&#13;
      X509v3 Subject Alternative Name:&#13;
        DNS:www.google.com&#13;
      X509v3 Certificate Policies:&#13;
        Policy: 2.23.140.1.2.1&#13;
        Policy: 1.3.6.1.4.1.11129.2.5.3&#13;
      X509v3 CRL Distribution Points:&#13;
        Full Name:&#13;
          URI:http://crls.pki.goog/gts1c3/fVJxbV-Ktmk.crl&#13;
      CT Precertificate SCTs:&#13;
        Signed Certificate Timestamp:&#13;
          Version   : v1 (0x0)&#13;
          Log ID    : E8:3E:D0:DA:3E:F5:06:35:32:E7:57:28:BC:89:6B:C9:&#13;
                    03:D3:CB:D1:11:6B:EC:EB:69:E1:77:7D:6D:06:BD:6E&#13;
          Timestamp : Sep  4 09:23:30.638 2023 GMT&#13;
          Extensions: none&#13;
          Signature : ecdsa-with-SHA256&#13;
            30:45:02:20:3F:81:71:2F:7C:E1:21:21:D8:4D:94:AC:&#13;
            A7:CB:BC:5D:9F:1B:BA:9A:49:89:33:6C:42:F2:B6:B0:&#13;
            F3:F7:5C:26:02:21:00:97:03:8F:30:CD:BA:0B:29:E6:&#13;
            69:DB:2A:A2:63:CC:5C:A7:51:34:CB:F3:77:27:22:1D:&#13;
            58:A6:87:4B:27:AC:10&#13;
        Signed Certificate Timestamp:&#13;
          Version   : v1 (0x0)&#13;
          Log ID    : 7A:32:8C:54:D8:B7:2D:B6:20:EA:38:E0:52:1E:E9:84:&#13;
                    16:70:32:13:85:4D:3B:D2:2B:C1:3A:57:A3:52:EB:52&#13;
          Timestamp : Sep  4 09:23:30.688 2023 GMT&#13;
          Extensions: none&#13;
          Signature : ecdsa-with-SHA256&#13;
            30:46:02:21:00:D9:7F:5B:54:2E:45:42:5D:17:3A:F3:&#13;
            32:70:82:9E:56:14:95:1B:4F:11:63:CF:A0:8F:F9:E2:&#13;
            DB:DD:D8:33:DE:02:21:00:9F:6E:4B:BA:6C:BB:61:A5:&#13;
            1D:D4:D7:A2:45:D3:7A:D3:18:EC:C0:9D:21:CB:A3:EB:&#13;
            44:26:FE:A4:E7:FB:57:45&#13;
    Signature Algorithm: sha256WithRSAEncryption&#13;
    Signature Value:&#13;
      88:12:7d:2f:43:36:aa:34:23:a1:88:8e:53:29:c4:61:69:1d:&#13;
      b8:c8:a8:9d:dc:5e:7b:6b:f1:8e:33:52:c3:13:fb:fb:a0:29:&#13;
      be:dd:fc:6d:be:e2:bd:1d:56:bf:0e:69:ef:6a:fa:a9:72:2e:&#13;
      d3:a4:c0:e3:fe:87:17:8c:4e:1d:2f:8f:f2:1d:a5:71:e8:68:&#13;
      53:0c:a3:16:fd:b6:c1:90:36:aa:5e:84:9d:6f:d9:40:71:46:&#13;
      4f:2d:14:d5:e0:08:c5:76:39:81:f3:06:53:7f:de:5b:9d:f7:&#13;
      ae:28:d5:d6:95:ba:3f:93:ff:69:45:18:45:34:a2:8c:50:8e:&#13;
      78:c4:b8:95:76:3e:30:93:51:14:02:ca:cc:4d:39:fe:3a:5d:&#13;
      99:6c:57:92:b3:ad:78:69:b0:53:e5:6d:21:84:59:0b:be:3b:&#13;
      c4:86:df:29:dd:42:90:c3:0c:a1:46:36:4c:06:c6:9e:fd:dd:&#13;
      10:7d:3f:21:82:55:6d:56:18:46:77:b7:f5:84:5a:88:5d:21:&#13;
      11:97:c1:2c:c8:37:37:ba:b0:ac:6b:e4:63:52:30:af:13:d4:&#13;
      3e:cb:65:fc:59:55:74:1c:f0:a3:c2:c0:0d:53:9e:aa:11:99:&#13;
      a1:e2:4a:a0:83:9a:5a:5b:f4:8b:99:a3:3f:f1:59:f2:fe:72:&#13;
      8d:77:a0:e3</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-2: Decoding a certificate received from</samp> <samp class="SANS_Futura_Std_Book_11"><a href="http://www.google.com">www<wbr/>.google<wbr/>.com</a></samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_262" aria-label="262"/>This listing shows the command <samp class="SANS_TheSansMonoCd_W5Regular_11">openssl x509</samp> decoding a certificate, originally provided as a block of base64-encoded data. Because OpenSSL knows the structure of this data, it can tell you what’s inside the certificate, including a serial number and version information, identifying information, validity dates (the <samp class="SANS_TheSansMonoCd_W5Regular_11">Not Before</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Not After</samp> lines), a public key (here as an RSA modulus and its public exponent), and a signature of the preceding information.</p>&#13;
<p class="TX">Although security experts and cryptographers often claim the whole certificate system is inherently broken, it’s one of the best solutions we have, along with the trust-on-first-use (TOFU) policy adopted by SSH, for example.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H2" id="sec6"><span id="h2-162"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Record Protocol</samp></h4>&#13;
<p class="TNI">All data exchanged through TLS 1.3 communications is transmitted as sequences of TLS records, the data packets used by TLS. The TLS record protocol (the <i>record layer</i>) is essentially a transport protocol, agnostic of the transported data’s meaning; this makes TLS suitable for any application.</p>&#13;
<p class="TX">The TLS record protocol first carries the data exchanged during the handshake. Once the handshake is complete and both parties share a secret key, application data is fragmented into chunks that transmit as part of the TLS records.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h5 class="H3" id="sec7"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Structure of a TLS Record</samp></h5>&#13;
<p class="TNI">A TLS record is a chunk of data of at most 16KB with the following structure:</p>&#13;
<ul class="ul">&#13;
<li class="BL">The first byte represents the type of data transmitted and is set to the value <samp class="SANS_TheSansMonoCd_W5Regular_11">22</samp> for handshake data, <samp class="SANS_TheSansMonoCd_W5Regular_11">23</samp> for encrypted data, and <samp class="SANS_TheSansMonoCd_W5Regular_11">21</samp> for alerts. The TLS 1.3 specifications call this value ContentType.</li>&#13;
<li class="BL">The second and third bytes are set to <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>, respectively. These bytes are fixed for historical reasons and aren’t unique to TLS version 1.3. The specifications call this 2-byte value ProtocolVersion.</li>&#13;
<li class="BL">The fourth and fifth bytes encode the length of the data to transmit as a 16-bit integer, which can be no larger than 2<sup>14</sup> bytes (16KB).</li>&#13;
<li class="BL">The rest of the bytes are the data to transmit (or the <i>payload</i>), of a length equal to the value encoded by the record’s fourth and fifth bytes.</li>&#13;
</ul>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>A TLS record has a relatively simple structure. As you’ve seen, a TLS record’s header includes only three fields. For comparison, an IPv4 packet includes 14 fields before its payload, and a TCP segment includes 13 fields.</i></p>&#13;
<p class="TX">When the first byte of a TLS 1.3 record (ContentType) is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">23</samp>, an authenticated cipher encrypts and authenticates its payload. The payload consists of a ciphertext followed by an authentication tag, which the receiving end, respectively, decrypts and verifies. The recipient knows which <span role="doc-pagebreak" epub:type="pagebreak" id="pg_263" aria-label="263"/>cipher and key to decrypt with, thanks to the magic of TLS: if you receive an encrypted TLS record, you already know the cipher and key because executing the handshake protocol establishes them.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h5 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Nonces</samp></h5>&#13;
<p class="TNI">Unlike many other protocols, such as IPsec’s Encapsulating Security Payload (ESP), TLS records don’t specify the nonce the authenticated cipher will use.</p>&#13;
<p class="TX">The nonces that encrypt and decrypt TLS records are derived from 64-bit sequence numbers, maintained locally by each party and incremented for each new record. When the client encrypts data, it derives a nonce by XORing the sequence number with a <samp class="SANS_TheSansMonoCd_W5Regular_11">client_write_iv</samp> value, itself derived from the shared secret. The server uses a similar method to choose nonces when transmitting data, but with a <samp class="SANS_TheSansMonoCd_W5Regular_11">server_write_iv</samp> value.</p>&#13;
<p class="TX">For example, if you transmit three TLS records, you’ll derive a nonce from 0 for the first record, from 1 for the second, and from 2 for the third; if you then receive three records, you’ll also use nonces 0, 1, and 2, in this order. Reusing the same sequence numbers values for encrypting transmitted data and decrypting receiving data isn’t a weakness because they’re XORed with different constants (<samp class="SANS_TheSansMonoCd_W5Regular_11">client_write_iv</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">server_write_iv</samp>) and because you use different secret keys for each direction.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h5 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Zero Padding Feature</samp></h5>&#13;
<p class="TNI">TLS 1.3 records support <i>zero padding</i>, which mitigates traffic analysis attacks. Attackers use <i>traffic analysis</i> to extract information from traffic patterns using timing, volume of data transferred, and so on. For example, because ciphertexts are approximately the same size as plaintexts, even when using strong encryption, attackers can determine the approximate size of messages by simply looking at the length of their ciphertext.</p>&#13;
<p class="TX">Zero padding adds zeros to the plaintext to inflate the ciphertext’s size, fooling observers into thinking that an encrypted message is longer than it really is.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h4 class="H2" id="sec10"><span id="h2-163"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The TLS Handshake Protocol</samp></h4>&#13;
<p class="TNI">The handshake is the crux of the TLS agreement protocol—the process by which a client and a server establish shared secret keys to initiate secure communications. During a TLS handshake, the client and the server play different roles. The client proposes some configurations (the TLS version and a suite of ciphers, in order of preference), and the server chooses the configuration it will use. The server should follow the client’s preferences. To ensure interoperability between implementations and that any server implementing TLS 1.3 will be able to read TLS 1.3 data sent by any client implementing TLS 1.3 (even if it’s using a different library or programming language), the TLS 1.3 specifications also describe the format data should be sent in.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_264" aria-label="264"/><a href="chapter13.xhtml#fig13-1">Figure 13-1</a> shows how the handshake process exchanges data, as the TLS 1.3 specifications describe.</p>&#13;
<figure class="IMG"><img id="fig13-1" class="img1" src="../images/fig13-1.jpg" alt="" width="1137" height="801"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: The TLS 1.3 handshake process</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In the TLS 1.3 handshake, the client sends a message to the server saying, “I want to establish a TLS connection with you. Here are the ciphers that I support to encrypt TLS records, and here is a Diffie–Hellman public key.” The public key must be generated specifically for this TLS session, and the client keeps the associated private key. The message sent by the client also includes a 32-byte random value and optional information (such as additional parameters). This first message, <i>ClientHello</i>, must follow a specific format when transmitted as a series of bytes, as the TLS 1.3 specification defines.</p>&#13;
<p class="TX">The server receives the ClientHello message, verifies that it’s correctly formatted, and responds with a ServerHello message, which is loaded with information. Typically, when connecting to an HTTPS website, it contains the cipher that will encrypt TLS records, a Diffie–Hellman public key, a 32-byte random value (discussed in “<span class="Xref">Downgrade Protection</span>” on <span class="Xref"><a href="#sec13">page 266</a></span>), a certificate, a signature of all the previous information in ClientHello and ServerHello messages (computed using the private key associated with the certificate’s public key), and a MAC of that same information, plus the signature. The MAC is computed using a symmetric key derived from the Diffie–Hellman shared secret, which the server computes from its Diffie–Hellman private key and the client’s public key.</p>&#13;
<p class="TX">When the client receives the ServerHello message, it verifies the certificate’s validity, verifies the signature, computes the shared Diffie–Hellman secret and derives symmetric keys from it, and verifies the MAC sent by the server. Once everything is verified, the client is ready to send encrypted messages to the server.</p>&#13;
<blockquote>&#13;
<p class="Note"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_265" aria-label="265"/><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>TLS 1.3 supports many options and extensions, so it may behave differently. You can, for example, configure the TLS 1.3 handshake to require a client certificate so that the server verifies the identity of the client. TLS 1.3 also supports a handshake with preshared keys.</i></p>&#13;
<p class="TX">Let’s look at this in practice. Say you’ve deployed TLS 1.3 to provide secure access to the website <i><a href="https://www.nostarch.com">https://<wbr/>www<wbr/>.nostarch<wbr/>.com</a></i>. When you point your browser (the client) to this site, your browser sends a ClientHello message to the site’s server that includes the ciphers that it supports. The website responds with a ServerHello message and a certificate that includes a public key associated with the domain <i><a href="http://www.nostarch.com">www<wbr/>.nostarch<wbr/>.com</a></i>. The client verifies the certificate’s validity using one of the certificate authorities embedded in the browser (a trusted certificate authority, whose certificate should be included in the browser’s or the operating system’s certificate store to be validated, should sign the received certificate). Once all checks pass, the browser requests the site’s initial page from the <i><a href="http://www.nostarch.com">www<wbr/>.nostarch<wbr/>.com</a></i> server.</p>&#13;
<p class="TX">Upon a successful TLS 1.3 handshake, all communications between the client and the server are encrypted and authenticated. An eavesdropper can learn that a client at a given IP address is talking to a server at another given IP address and can observe the encrypted content exchanged but can’t learn the underlying plaintext or modify the encrypted messages (if they do, the receiving party will notice that the communication has been tampered with, because messages are authenticated). That’s enough security for many applications.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H2" id="sec11"><span id="h2-164"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">TLS 1.3 Cryptographic Algorithms</samp></h4>&#13;
<p class="TNI">TLS 1.3 uses authenticated encryption algorithms, a key derivation function (a hash function that derives secret keys from a shared secret), as well as a Diffie–Hellman operation—but how exactly do these work, what algorithms are used, and how secure are they?</p>&#13;
<p class="TX">With regard to the choice of authenticated ciphers, TLS 1.3 supports only three algorithms: AES-GCM, AES-CCM (a slightly less efficient mode than GCM), and the ChaCha20 stream cipher combined with the Poly1305 MAC (as defined in RFC 7539). Because TLS 1.3 prevents using an unsafe key length such as 64 or 80 bits, the secret key can be either 128 bits (AES-GCM or AES-CCM) or 256 bits (AES-GCM or ChaCha20-Poly1305).</p>&#13;
<p class="TX">The key derivation operation (KDF) in <a href="chapter13.xhtml#fig13-1">Figure 13-1</a> is based on HKDF, a construction based on HMAC (see <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>) and defined in RFC 5869 that uses either the SHA-256 or the SHA-384 hash function.</p>&#13;
<p class="TX">Your options for performing the Diffie–Hellman operation (the core of the TLS 1.3 handshake) are limited to elliptic curve cryptography and a multiplicative group of integers modulo a prime number (as in traditional Diffie–Hellman). But you can’t use just any elliptic curve or group: the supported curves include three NIST curves as well as Curve25519 (see <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>) and Curve448, both defined in RFC 7748. TLS 1.3 also supports DH over groups of integers, as opposed to elliptic curves. The groups <span role="doc-pagebreak" epub:type="pagebreak" id="pg_266" aria-label="266"/>supported are the five groups defined in RFC 7919: groups of 2,048, 3,072, 4,096, 6,144, and 8,192 bits.</p>&#13;
<p class="TX">The 2,048-bit group may in theory be TLS 1.3’s weakest link. Whereas the other options provide at least 128-bit security, 2,048-bit Diffie–Hellman is believed to provide less than 100-bit security. Supporting a 2,048-bit group can therefore be seen as inconsistent with other TLS 1.3 design choices. In practice, 100-bit security is about as hard to crack as 128-bit—that is, practically impossible.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H1" id="sec12"><span id="h1-92"/><samp class="SANS_Futura_Std_Bold_B_11">TLS 1.3 Improvements over TLS 1.2</samp></h3>&#13;
<p class="TNI">TLS 1.3 is very different from its predecessor. For one, it gets rid of weak algorithms like MD5, SHA-1, RC4, and AES in CBC mode. Also, whereas TLS 1.2 often protected records using a combination of a cipher and a MAC (such as HMAC-SHA-1) within a MAC-then-encrypt construction, TLS 1.3 supports only the more efficient and secure authenticated ciphers. TLS 1.3 also ditches elliptic curve point encoding negotiation and defines a single point format for each curve.</p>&#13;
<p class="TX">TLS 1.3 removed features in 1.2 that weakened the protocol, and it reduced the protocol’s overall complexity and thereby its attack surface. For example, TLS 1.3 ditches optional data compression, a feature that enabled the CRIME attack on TLS 1.2. This attack exploited the fact that the length of the compressed version of a message leaks information on the content of the message.</p>&#13;
<p class="TX">But TLS 1.3 also brings new features that make connections either more secure or more efficient. I’ll discuss three of these features: downgrade protection, the single round-trip handshake, and session resumption.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H2" id="sec13"><span id="h2-165"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Downgrade Protection</samp></h4>&#13;
<p class="TNI">TLS 1.3’s <i>downgrade protection</i> feature is a defense against <i>downgrade attacks</i>, wherein an attacker forces the client and the server to use a weaker version of TLS than 1.3. To carry out a downgrade attack, an attacker forces the server to use a weaker version of TLS by intercepting and modifying the ClientHello message to tell the server that the client doesn’t support TLS 1.3. Now the attacker can exploit vulnerabilities in earlier versions of TLS.</p>&#13;
<p class="TX">In an effort to defeat downgrade attacks, the TLS 1.3 server uses three types of patterns in the 32-byte random value sent within the ServerHello message to identify the type of connection requested. The pattern should match the client’s request for a specific type of TLS connection. If the client receives the wrong pattern, it knows something is up.</p>&#13;
<p class="TX">Specifically, if the client asks for a TLS 1.2 connection, the first 8 of the 32 bytes are set to <samp class="SANS_TheSansMonoCd_W5Regular_11">44 4F 57 4E 47 52 44 01</samp>, and if it asks for a TLS 1.1 connection, they’re set to <samp class="SANS_TheSansMonoCd_W5Regular_11">44 4F 57 4E 47 52 44 00</samp>. However, if the client requests a TLS 1.3 connection, these first 8 bits should be random. For example, if a client sends a ClientHello asking for a TLS 1.3 connection, but an <span role="doc-pagebreak" epub:type="pagebreak" id="pg_267" aria-label="267"/>attacker on the network modifies it to ask for a TLS 1.1 connection, when the client receives the ServerHello with the wrong pattern, it knows that its ClientHello message was modified. (The attacker can’t arbitrarily modify the server’s 32-byte random value because this value is cryptographically signed.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H2" id="sec14"><span id="h2-166"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Single Round-Trip Handshake</samp></h4>&#13;
<p class="TNI">In a typical TLS 1.2 handshake, the client sends some data to the server, waits for a response, and then sends more data and waits for the server’s response before sending encrypted messages. The delay is that of two round-trip times (RTT). In contrast, TLS 1.3’s handshake takes a single round-trip time (see <a href="chapter13.xhtml#fig13-1">Figure 13-1</a>). The time saved can be in the hundreds of milliseconds. This is significant when you consider that servers of popular services handle thousands of connections per second.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H2" id="sec15"><span id="h2-167"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Session Resumption</samp></h4>&#13;
<p class="TNI">TLS 1.3 is faster than TLS 1.2, but it can be made even faster (on the order of hundreds of milliseconds) by completely eliminating the round trips that precede an encrypted session. The trick is to use <i>session resumption</i>, which leverages the preshared key exchanged between the client and the server in a previous session to bootstrap a new session. Session resumption brings two major benefits: the client can start encrypting immediately, and there’s no need to use certificates in subsequent sessions.</p>&#13;
<p class="TX"><a href="chapter13.xhtml#fig13-2">Figure 13-2</a> shows how session resumption works.</p>&#13;
<figure class="IMG"><img id="fig13-2" class="img1" src="../images/fig13-2.jpg" alt="" width="1137" height="531"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: The TLS 1.3 session resumption handshake, wherein the 0-RTT data is the session resumption data sent along with the ClientHello</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">First, the client sends a ClientHello message that includes the identifier of the key already shared (called <i>PSK</i> for <i>preshared key</i>) with the server, along with a fresh DH public key. The client can also include encrypted data in this first message (called <i>0-RTT data</i>). When the server responds to a ClientHello message, it provides a MAC over the data exchange. The client verifies the MAC and knows that it’s talking to the same server as it did previously, thus rendering certificate validation somewhat superfluous. The <span role="doc-pagebreak" epub:type="pagebreak" id="pg_268" aria-label="268"/>client and the server perform a Diffie–Hellman key agreement as in the normal handshake, and subsequent messages are encrypted using keys that depend on both the PSK and the newly computed Diffie–Hellman shared secret.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h3 class="H1" id="sec16"><span id="h1-93"/><samp class="SANS_Futura_Std_Bold_B_11">The Strengths of TLS Security</samp></h3>&#13;
<p class="TNI">We’ll evaluate the strengths of TLS 1.3 with respect to two main security notions from <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>: authentication and forward secrecy.</p>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h4 class="H2" id="sec17"><span id="h2-168"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authentication</samp></h4>&#13;
<p class="TNI">During the TLS 1.3 handshake, the server authenticates to the client using the certificate mechanism. However, the client isn’t authenticated, and clients may authenticate with a server-based application (such as Gmail) by providing a username and password in a TLS record after performing the handshake. If the client’s already established a session with the remote service, it may authenticate by sending a <i>secure cookie</i>, which can be sent only through a TLS connection.</p>&#13;
<p class="TX">In certain cases, clients can authenticate to a server using a certificate-based mechanism similar to what the server uses to authenticate to the client: the client sends a <i>client certificate</i> to the server, which verifies this certificate before authorizing the client. However, you will rarely use client certificates because they complicate things for both clients and the server (that is, the certificate issuer): clients need to perform complex operations to integrate the certificate into their system and to protect its private key, while the issuer needs to make sure that only authorized clients received a certificate, among other requirements.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h4 class="H2" id="sec18"><span id="h2-169"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Forward Secrecy</samp></h4>&#13;
<p class="TNI">Recall from “<span class="Xref">Key Agreement Protocols</span>” in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span> that a key agreement provides forward secrecy if previous sessions aren’t compromised when the present session is compromised. In the data leak model, only temporary secrets are compromised, whereas in the breach model, long-term secrets are exposed.</p>&#13;
<p class="TX">Thankfully, TLS 1.3 forward secrecy holds up in the face of both a data leak and a breach. In the data leak model, the attacker recovers temporary secrets such as the session keys or Diffie–Hellman private keys of a specific session (the values <i>c</i>, <i>s</i>, <i>secret</i>, and <i>keys</i> in <a href="chapter13.xhtml#fig13-1">Figure 13-1</a>). However, they can use these values to decrypt communications from only the present session, not previous sessions, because different values of <i>c</i> and <i>s</i> were used (thus yielding different keys).</p>&#13;
<p class="TX">In the breach model, the attacker also recovers long-term secrets (namely, the private key that corresponds to the public key in the certificate). However, this is no more useful when decrypting previous sessions than temporary secrets, because this private key serves to authenticate only the server, and forward secrecy holds up again.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_269" aria-label="269"/>In practice, if an attacker compromises a client’s machine and gains access to all of its memory, they may recover the client’s TLS session keys and secrets for the current session from memory. But more importantly, if previous keys are still in memory, the attacker may be able to find them and decrypt previous sessions, thereby bypassing the theoretical forward secrecy. Therefore, for a TLS implementation to ensure forward secrecy, it must properly erase keys from memory once they’re no longer used, typically by zeroing out the memory.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h3 class="H1" id="sec19"><span id="h1-94"/><samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp></h3>&#13;
<p class="TNI">TLS 1.3 fits the bill as a general-purpose secure communications protocol, but it’s not bulletproof. Like any security system, it can fail under certain circumstances (for example, when the assumptions made by its designers about real attacks are wrong). Unfortunately, even the latest version of TLS 1.3, configured with the most secure ciphers, can be compromised. For example, TLS 1.3 security relies on the assumption that all three parties (the client, the server, and the certificate authority) will behave honestly, but what if one party is compromised or the TLS implementation itself is poorly implemented?</p>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h4 class="H2" id="sec20"><span id="h2-170"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compromised Certificate Authority</samp></h4>&#13;
<p class="TNI">Root certificate authorities (root CAs) are organizations that browsers trust to validate certificates served by remote hosts. For example, if your browser accepts the certificate provided by <i><a href="http://www.google.com">www<wbr/>.google<wbr/>.com</a></i>, the assumption is that a trusted CA has verified the legitimacy of the certificate owner. The browser verifies the certificate by checking its CA-issued signature. Since only the CA knows the private key required to create this signature, we assume others can’t create valid certificates on behalf of the CA. Very often a website’s certificate won’t be signed by a root CA but by an intermediate CA, which is connected to the root CA through a certificate chain.</p>&#13;
<p class="TX">If a CA’s private key is compromised, the attacker is able to use the CA’s private key to create a certificate for any URLs in, say, the <i>google.com</i> domain without Google’s approval. The attacker can then use those certificates to pretend to host a legitimate server or subdomain like <i>mail.google.com</i> and intercept a user’s credentials and communications. That’s exactly what happened in 2011 when an attacker hacked into the network of the Dutch certificate authority DigiNotar and created seemingly legitimate certificates. The attacker used these fake certificates for several Google services.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h4 class="H2" id="sec21"><span id="h2-171"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compromised Server</samp></h4>&#13;
<p class="TNI">If a server is compromised and fully controlled by an attacker, all is lost: the server holds the session keys, being the termination point of the TLS connection. The attacker can see all transmitted data before it’s encrypted and all received data once it’s decrypted. They’ll also likely get their hands on the server’s private key, which could allow them to impersonate the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_270" aria-label="270"/>legitimate server using their own malicious server. TLS won’t save you in this case.</p>&#13;
<p class="TX">Fortunately, such security disasters are rarely seen in high-profile applications such as Gmail and iCloud, which are well protected and sometimes have their private keys stored in a separate security module, such as a hardware security module (HSM), directly or via a key management system (KMS) application.</p>&#13;
<p class="TX">Attacks on web applications via vulnerabilities such as database query injections and cross-site scripting are more common because they’re mostly independent of TLS’s security and are carried out by attackers over a legitimate TLS connection. Such attacks may compromise usernames, passwords, and so on.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h4 class="H2" id="sec22"><span id="h2-172"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compromised Client</samp></h4>&#13;
<p class="TNI">TLS security is also jeopardized when a client, such as a browser, is compromised by a remote attacker. Having compromised the client, the attacker is able to capture session keys, read any decrypted data, and so on. They could even install a rogue CA certificate in the client’s system to have it silently accept otherwise-invalid certificates, thereby letting attackers intercept TLS connections.</p>&#13;
<p class="TX">The difference between the compromised CA or server scenarios and the compromised client scenario is that in the case of the compromised client, only the targeted client is affected, instead of potentially <i>all</i> clients.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h4 class="H2" id="sec23"><span id="h2-173"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bugs in Implementations</samp></h4>&#13;
<p class="TNI">As with any cryptographic component, TLS can fail when there are bugs in its implementation. The poster child for TLS bugs is Heartbleed (see <a href="chapter13.xhtml#fig13-3">Figure 13-3</a>), a buffer overflow in the OpenSSL implementation of a minor TLS feature called <i>heartbeat</i>. Heartbleed was discovered in 2014, independently by a Google researcher and by the Codenomicon company, and affected millions of TLS servers and clients.</p>&#13;
<figure class="IMG"><img id="fig13-3" class="img1" src="../images/fig13-3.jpg" alt="" width="1389" height="646"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3: The Heartbleed bug in OpenSSL implementations of TLS</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_271" aria-label="271"/>A client first sends a buffer along with a buffer length to the server to check whether the server is online. In this example, the buffer is the string <i>BANANAS</i>, and the client explicitly says that this word is seven letters long. The server reads the seven-letter word and returns it to the client.</p>&#13;
<p class="TX">The problem is that the server doesn’t confirm that the length is correct and attempts to read as many characters as the client tells it to. Consequently, if the client provides a length that is longer than the string’s actual length, the server reads too much data from memory and returns it to the client, together with any extra data that may contain sensitive information, such as private keys or session cookies.</p>&#13;
<p class="TX">The Heartbleed bug came as a shock. To avoid similar future bugs, OpenSSL and other major TLS implementations now perform rigorous code reviews and use automated tools such as fuzzers to identify potential issues.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h3 class="H1" id="sec24"><span id="h1-95"/><samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp></h3>&#13;
<p class="TNI">This chapter isn’t a comprehensive guide to TLS, and you may want to dig deeper into the history of TLS, its previous vulnerabilities, and its latest version. The complete TLS 1.3 specifications, found on the home page of the TLS Working Group (TLSWG) at <i><a href="https://tlswg.org">https://<wbr/>tlswg<wbr/>.org</a></i>, include everything about the protocol (though not necessarily its underlying rationale).</p>&#13;
<p class="TX">I also suggest you learn about major protocols that use TLS, such as QUIC (used in connections between Chrome and Google servers) and SRTP (used for videoconferencing and streaming traffic).</p>&#13;
<p class="TX">In addition, here are two important initiatives related to TLS deployment:</p>&#13;
<ul class="ul">&#13;
<li class="BL">SSL Labs TLS test (<i><a href="https://www.ssllabs.com/ssltest">https://<wbr/>www<wbr/>.ssllabs<wbr/>.com<wbr/>/ssltest</a></i>) is a free service by Qualys that lets you test a browser’s or a server’s TLS configuration, providing a security rating as well as improvement suggestions. If you set up your own TLS server, use this test to make sure everything is safe.</li>&#13;
<li class="BL">Let’s Encrypt (<i><a href="https://letsencrypt.org">https://<wbr/>letsencrypt<wbr/>.org</a></i>) is a nonprofit that offers a service to “automagically” deploy TLS on your HTTP servers. It includes features to automatically generate a certificate and configure the TLS server, and it supports all the common web servers and operating systems.</li>&#13;
</ul>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>