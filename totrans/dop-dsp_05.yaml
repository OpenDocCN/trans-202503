- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controlling User Commands with sudo
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, you have secured access to your VM with a public key and two-factor
    authentication. You have also controlled access to a specific file and directory,
    using group permissions. The next foundational piece is allowing users to run
    elevated commands on the VM. Users typically need access to commands that may
    require administrative permissions, such as restarting a service or installing
    a missing package. As an administrator, you want to keep a tight control on who
    can run which commands. On Linux operating systems, the `sudo` (superuser do)
    command allows users to run specific commands as *root* or another user while
    keeping an audit trail of events.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll use Ansible to install a simple Python Flask web application.
    You’ll also use Ansible to create a *sudoers* security policy, which is configured
    by a file and determines what permissions users have when they invoke the `sudo`
    command. This policy will allow members of the *developers* group to use the `sudo`
    command to start, stop, restart, and edit the sample web application. Although
    this is a made-up example, it follows a typical release workflow that software
    engineers should be accustomed to. By the end of the chapter, you’ll have a good
    grasp of how to automate application deployment and control it with a *sudoers*
    policy.
  prefs: []
  type: TYPE_NORMAL
- en: What Is sudo?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are new to `sudo`, it is a command line tool on most Unix OSs that allows
    a user or group of users to run commands as another user. For example, a software
    engineer may need to restart an Nginx web server that’s owned by the *root* user,
    or a system administrator may need elevated permissions to install some software
    packages. If you have been around Linux long enough, you have likely used `sudo`
    to run a command that requires elevated privileges. Normally, you would not allow
    just anyone to have such privileges, due to various security implications. Regardless
    of your use case, users will need a safe and accountable way to access privileged
    commands to do their jobs.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best features of `sudo` is its ability to leave an audit trail. If
    someone runs a command with `sudo`, you can check the log to see who ran what
    command. Without `sudo`, there is zero accountability if you blindly allow people
    to switch to other users to run commands.
  prefs: []
  type: TYPE_NORMAL
- en: You also can enhance `sudo` with plug-ins. In fact, `sudo` comes with a default
    security policy plug-in called *sudoers*, which determines what permissions users
    have when they invoke the `sudo` command. You’ll implement this policy for your
    user *bender*.
  prefs: []
  type: TYPE_NORMAL
- en: Planning a sudoers Security Policy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you are planning a *sudoers* policy, less is more. You want a user or group
    of users to have just the right amount of permissions on a host. If you have a
    user that can run many privileged commands while administering the company website
    at the same time, you’ll have serious issues if that user is compromised. This
    is because any attackers will inherit the same access that the compromised user
    has.
  prefs: []
  type: TYPE_NORMAL
- en: That said, it is naive to think you can lock down a host completely and still
    get things done. Imagine a software delivery workflow where an application needs
    to be restarted after each deployment. Without proper user permissions, you will
    not be able to automate continuous delivery for that application.
  prefs: []
  type: TYPE_NORMAL
- en: For the example security policy you’ll set up in this chapter, everyone in the
    *developers* group will be able to access the sample web application. They’ll
    also be able to stop, start, and edit the main application file.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Greeting Web Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sample Python web application I have provided is cleverly (and lazily) named
    *Greeting*. This simple web application responds with an enthusiastic “Greetings!”
    when you visit *http://localhost:5000* on the VM. I am providing this application
    so you can focus on learning automation and provisioning; I won’t go over its
    code here.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use Ansible tasks to install the necessary libraries and files to run
    the web application. You’ll also install a *systemd* unit file, the standard service
    manager that manages processes and services on a Linux host, to make it easier
    to start and stop the web application.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible tasks to install the web application (and all the other tasks for
    this chapter) are located in the *ansible/chapter4/* directory. You should navigate
    to that directory and open the task file named *web_application.yml* in your favorite
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'This file contains four individual tasks, named as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Install `python3-flask`, `gunicorn3`, and `nginx`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy Flask Sample Application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy *Systemd* Unit file for Greeting
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start and enable Greeting Application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I’ll go over each of these tasks, starting with the one that installs the web
    application dependencies: `python3-flask`, `gunicorn3`, and `nginx`. It’s the
    first task at the top of the file, and it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The task `name` describes its intent, which is to `Install` some software packages.
    The `apt` module is used again to install the `python3-flask`, the `gunicorn3`,
    and the `nginx` packages from the Ubuntu repository on the VM. This time, however,
    the `apt` module uses some syntactical sugar: a YAML list. This feature allows
    you to install multiple packages (or remove them) in a single task, instead of
    having to create a task for each package you want to install.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second task from the top copies the sample Greeting application over to
    the VM. You need two files to bring the Greeting web application to life, and
    the task should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `copy` module copies the two files from the provided repository to the
    VM. The `src` and `dest` lines are templated (with double curly brackets) and
    replaced by the values from the `loop` module. Here, the `loop` module references
    two files by name: *greeting.py* and *wsgi.py*. The *greeting.py* file is the
    actual Python Flask code, while the *wsgi.py* file contains the application object
    for the HTTP server. During this task’s runtime, the placeholder `{{ item }}`
    will be replaced with each of these two filenames from the `loop`. For example,
    the `src` line will look like `"../ansible/chapter4/greeting.py"` after the first
    pass of the `loop`. The `mode` line sets the permissions on both files to be read
    and to execute for anyone in the *developers* group.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at the task that copies the *systemd* unit file over to the
    VM. This task, located third from the top, should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This task starts with a descriptive `name`, as usual. Then, the familiar Ansible
    `copy` module copies a file from the local host to the VM. In this case, it copies
    the *greeting.service* file to a place on the VM where `systemd` can find it:
    */etc/systemd/system*.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review the *system service* file. Such files can have many options and
    settings, but for this example, I’ve provided a simple one to control the Greeting
    web application’s life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the *ansible/chapter4/greeting.service* file in your editor. It should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `WorkingDirectory` and `ExecStart` lines are the most important in this
    file. The first sets the working directory to */opt/engineering*, since that’s
    where your application code lives. In the `ExecStart` line, the `gunicorn3` application
    calls the *wsgi.py* file to start the web application. You’ll also tell `gunicorn3`
    to log STDOUT (`--access-logfile -` ) and STDERR (`--error-logfile -` ) to the
    *systemd* journal, which is forwarded by default to the */var/log/syslog* file.
    Close the *greeting.service* file for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last task in the *web_application.yml* file ensures that the Greeting web
    application is started and that the `systemd` daemon is reloaded each time a provision
    is run. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `systemd` Ansible module starts the Greeting web application. The
    module requires you to set the `name` and `state`, which in this case are `greeting.service`
    and `started`, respectively. The `enabled` parameter tells `systemd` to start
    the service automatically during startup. Using the `daemon_reload` parameter
    also forces `systemd` to reload all service files and discover the *greeting.service*
    file before doing anything else. It’s equivalent to running `systemctl daemon-reload`.
    The `daemon_reload` parameter is useful on the first provision of a host to make
    sure `systemd` knows about the service. Be sure to use the `daemon_reload` parameter
    so that `systemd` always knows about any changes to the service file.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a sudoers File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *sudoers* file is the place where you configure security policies (for users
    and groups) that invoke the `sudo` command. This type of security file is composed
    of sections called `Defaults`, `User Specifications`, and `Aliases`. A *sudoers*
    file is read from the top down, and since rules are applied in that order, the
    last matching rule always wins.
  prefs: []
  type: TYPE_NORMAL
- en: The `Defaults` syntax allows you to override some *sudoers* options at runtime,
    such as setting environment variables that users have access to when they run
    `sudo`. The `User Specifications` section determines which commands users can
    run and on which host they can run them. For example, you could give the *bender*
    user permission to run the `apt install` command on all web server hosts. The
    `Aliases` syntax references other objects inside the file, and that is useful
    for keeping the configuration clear and concise when there is a lot of duplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The four aliases you can mix and match are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Host_Alias` A host or a group of hosts'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Runas_Alias` A list of users or groups a command can be run as'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Cmnd_Alias` Specifies a command or multiple commands'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`User_Alias` A user or group of users'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this example, you’ll only use `Cmnd_Alias` and `Host_Alias`in your *sudoers*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the sudoers File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create the *sudoers* file, you’ll use the Ansible `template` module and a
    template file. The Ansible `template` module is useful for creating files that
    will require some modification with variables. The `template` module creates files
    using the Jinja2 template engine for Python templates. You’ll keep template files
    in a separate directory called *ansible/templates/* (more on this later).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *ansible/chapter4/* directory, open the task file named *sudoers.yml*
    in your favorite editor. The first thing you should notice, at the top of the
    file, is a new Ansible module called `set_fact`. This module allows you to set
    host variables that can be used in a task or across a playbook. Here, you’ll set
    a variable with it for use in your template file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This creates a variable named `greeting_application_file` and sets its value
    to */opt/engineering/greeting.py* (where the previous tasks will install the web
    application). As noted previously, anyone in the *developers* group can read and
    execute in the */opt/engineering/* directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, locate the task right below the `set_fact` module. This task creates
    the *sudoers* file for the *developers* group and should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Ansible `template` module builds out your *sudoers* file. It requires a
    source file (`src`) and a destination file (`dest`). The source file is your local
    Jinja2 template (*developers.j2*), and the destination file will be the *developers
    sudoers* file on the VM. The `template` module also contains a `validate` step
    to verify whether the template is correct. In this case, the `visudo` command
    edits and validates your *sudoers* file in a safe manner. Adding the `-cf` flag
    to `visudo` makes sure the *sudoers* file is compliant and free of syntax errors.
    The `%s` is a placeholder for the file in the `dest` parameter. If the `validate`
    command fails for any reason, the Ansible task will fail, too. Finally, set the
    owner, group, and permissions of the file to `root`, `root`, and `0440` (respectively).
    This is what *sudoers* is expecting for proper permissions.
  prefs: []
  type: TYPE_NORMAL
- en: The sudoers Template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Ansible `template` module task referenced a source Jinja2 template file
    located in the *ansible/templates/* directory. It has the building blocks of your
    *sudoers* policy for the *developers* group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the *ansible/templates/* directory and open the *developers.j2*
    file in your editor. The *.j2* suffix on the file tells Ansible that it’s a Jinja2
    template. The contents of the file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The file begins with three `Cmnd_Alias` declarations that stop, start, and restart
    the Greeting web application. (In `systemd`, a service can be referred to as either
    `greeting` or `greeting.service`, so this handles both cases.) Next, a `Host_Alias`
    called `LOCAL_VM` is set to the private IP address of the VM. The built-in Ansible
    variable `hostvars` dynamically fetches the IP address of the VM during provision
    runtime. This is useful if you are provisioning many hosts at the same time. Finally,
    this creates a user specification for the *developers* group. (The `%` denotes
    it is a group and not a user.) The user specification rule states that anyone
    in the *developers* group, on the `LOCAL_VM`, can start, stop, restart, and edit
    the Greeting web application without a password, as the *root* user. Notice that
    issuing the `sudoedit` command is allowed only for editing the web application.
    (I’ll discuss `sudoedit` in more detail later.) The `{{ greeting_application_file
    }}` variable will be set during runtime to point to your Greeting web application
    file via `set_fact`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it is safe to close all open files. Next, you’ll configure the
    VM and test *bender*’s `sudo` privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning the VM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run all the tasks for this chapter, you need to uncomment them in the playbook
    like you did in previous chapters. Open the *ansible/site.yml* file in your editor
    and locate the task for installing the web application. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Remove the `#` symbol to uncomment it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, find the task that creates the *developers sudoer* policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Uncomment that line by removing the `#` symbol as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The playbook should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The changes to the playbook for Chapter 4 are added to the changes from Chapter
    3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you’ll run the Ansible tasks using Vagrant. Navigate back to the *vagrant/*
    directory where your *Vagrant* file is located and enter the following command
    to provision the VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The values from the provision output will vary, depending on how many times
    you run the `provision` command, as Ansible makes sure your environment is consistent
    and doesn’t do extra work if it’s not needed. The total task count here has increased
    to `21`. You’ve also changed these six things on the VM:'
  prefs: []
  type: TYPE_NORMAL
- en: Five new tasks from Chapter 4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One task that updates the timestamp on the empty file from Chapter 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again, make sure no actions have failed before you continue.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the VM successfully provisioned, you can now check your security policy
    by testing *bender*’s command access. First, you’ll need to log in to the VM as
    *bender* again. The *sudoers* policy should allow anyone in the *developers* group
    (*bender*, in this case) to start, stop, restart, or edit the web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To log in as *bender*, grab another 2FA token. This time, locate the second
    2FA token from the top in the *ansible/chapter3/google_authenticator* file; it
    should be `68385555`. Once you have it, enter the following command in your terminal
    to log in as *bender*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, you’re using the SSH parameters from Chapter 3 to log in to the VM. When
    prompted for the 2FA token, use the second one you just grabbed. This login process
    should be familiar by now, but if not, revisit Chapter 3 for a refresher.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Web Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll need to make sure the web application is running and responding to requests.
    You’ll test it with the `curl` command, which transfers data to servers (in this
    case, an HTTP server). The Greeting application server listens for requests on
    all interfaces on port 5000\. So, in the terminal, enter the following command
    to send an `HTTP GET` request to the greeting server on port 5000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The output shows the Greeting web application is responding to requests successfully
    on `localhost` in the VM.
  prefs: []
  type: TYPE_NORMAL
- en: Editing greeting.py to Test the sudoers Policy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, you’ll make a small change to the Greeting application using `sudoedit`
    to test *bender*’s permissions. The *sudoers* policy you set earlier in this chapter
    allows the *developers* group members to edit the */opt/engineering/greeting.py*
    file with the `sudoedit` command, which lets users edit a file with any editor.
    It also makes a copy of the file before editing, in case things go awry. Without
    `sudoedit`, you might need to create multiple command aliases for each editor
    a user wants to use.
  prefs: []
  type: TYPE_NORMAL
- en: In a real production system, you probably would not edit a file directly on
    a host. Instead, you would edit the source-controlled version and allow your automation
    to update it with the newest version. However, I’m describing this approach to
    show how to test your *sudoers* policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'While still logged in as *bender*, enter the following command to edit the
    *greeting.py* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should drop you into the Nano text editor (default for Ubuntu).
    Once there, locate the line that looks like this inside the `hello()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `Greetings!` text inside the heading tag to `Greetings and Salutations!`
    so the line looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and exit the Nano text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping and Starting with systemctl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the Greeting string changes to take effect, you’ll need to stop and start
    the web application server using `sudo` and the `systemctl` command (the latter
    of which is a command line application that allows you to control a service governed
    by `systemd`). The `Cmnd_Alias` declarations in your *sudoers* policy allow anyone
    in the *developers* group to run `/bin/systemctl stop greeting` or `/bin/systemctl
    start greeting`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop the already running Greeting application using `systemctl`, enter the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There should be no output from the command, and you should not be prompted for
    a password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, run `curl` again to be sure the web application is stopped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, `curl` responded with a `Connection refused` error since the server is
    not running any longer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restart the stopped Greeting server by entering this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There won’t be any output from this command if it is successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `curl` command again to check whether the web application is running
    with the new code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The Greeting server provides a successful response with the new and improved
    greeting. If, for some reason, your Greeting application isn’t responding like
    this, go back and retrace your steps. Start by looking for errors in the */var/log/syslog*
    file or the */var/log/auth.log* file on the VM.
  prefs: []
  type: TYPE_NORMAL
- en: Audit Logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, one great feature of `sudo` is that it leaves behind
    an audit trail. The events in this trail are typically used in a monitoring framework
    or when doing forensics during an incident response. No matter what, you should
    make sure the audit data is in an accessible area so you can review it.
  prefs: []
  type: TYPE_NORMAL
- en: If you followed along with the testing in this chapter, you ran the `sudo` command
    three different times. Those events were captured in the */var/log/auth.log* file,
    so let’s explore some of the log lines from those `sudo` commands. I have cherry-picked
    a few that are pertinent to this example so you won’t get bogged down in the art
    of log parsing. However, feel free to explore the logfile in more depth on your
    own.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line in *auth.log* you’ll look at pertains to *bender*’s use of `sudoedit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This line provides quite a bit of information, but let’s focus on the `date/time`,
    `USER`, and `COMMAND` columns. You can see that *bender* invoked `sudo` on `July
    23` at `23:17:43`, using the `sudoedit /opt/engineering/greeting.py` command.
    This happened when you changed the *greeting.py* file to alter the greeting text.
  prefs: []
  type: TYPE_NORMAL
- en: 'This log line shows when you used *bender* to stop the Greeting server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: On `July 23` at `23:18:19`, *bender* used `sudo` to execute the `/bin/systemctl
    stop greeting` command as the *root* user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here is the log line showing *bender* starting the Greeting application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: On `July 23` at `23:18:39`, *bender* used `sudo` to execute the command `/bin/systemctl
    start greeting` as the *root* user.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, I have shown log entries that were successful and expected. The following
    line shows *bender* executing an unsuccessful command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: On `July 23` at `23:25:14`, *bender* tried to run the `/usr/bin/tail /var/log/auth.log`
    command, and it was denied. These are the types of log lines you probably want
    to track in an alerting system, as this could be a bad actor trying to navigate
    a host.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter explored the importance of allowing users to run commands with
    elevated privileges. Using Ansible, the `sudo` command, and a *sudoers* file,
    you can restrict command access and log an audit trail for security. You also
    worked with some different Ansible modules like `template`, `systemd`, and `set_fact`,
    which allowed you to automate the installation of your web application and control
    its life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll wrap up this section on provisioning and security.
    You’ll also use some provided Ansible tasks to secure the network and implement
    a firewall for the VM.
  prefs: []
  type: TYPE_NORMAL
