<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 1: A Primer on GraphQL</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c77cce49-9403-4fd1-99ba-33d115574b0c" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_1" title="1"/><a class="XrefDestination" id="1"/><span class="XrefDestination" id="xref-502840c01-001"/>1</span><br/>
<span class="ChapterTitle"><a class="XrefDestination" id="AnIntroductiontoGraphQL"/><span class="XrefDestination" id="xref-502840c01-002"/>A Primer on GraphQL</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">In this chapter, we’ll provide an overview of GraphQL, including why it exists and which of its features make it interesting to many of today’s technology giants. You’ll also explore how it differs from RESTful APIs and send your very first GraphQL query.</p>
<h2 id="h1-502840c01-0001"><a class="XrefDestination" id="WhatIsGraphQL?"/><span class="XrefDestination" id="xref-502840c01-003"/>The Basics</h2>
<p class="BodyFirst"><em>GraphQL</em> is an open source data query and manipulation language for application programming interfaces (APIs). APIs allow two applications to exchange information in the form of requests and responses by following a set of rules that define the way the applications should connect and communicate. Typically, a web browser, like Google Chrome or Mozilla Firefox, acts as the API client, or <em>consumer. </em>This consumer interacts with an application server, via the application’s API, to read or alter certain information on <span epub:type="pagebreak" id="Page_2" title="2"/>the server. API consumers aren’t always browsers; machines, such as other servers on the network, can be GraphQL API consumers too.</p>
<p>Unlike other API formats, GraphQL allows an API consumer to request specific data from an application’s server without also receiving unnecessary information. Contrast this approach with traditional REST API architectures, which provide a fixed data structure and then rely on the clients to filter out any unnecessary information they don’t need. We’ll compare the REST and GraphQL API response structures in <span class="xref" itemid="xref_target_“GraphQL APIs vs. REST APIs” on page 9 ">“GraphQL APIs vs. REST APIs” on page 9 </span>to illustrate the differences between the two.</p>
<p>From a security perspective, GraphQL’s design provides an advantage. Because GraphQL doesn’t return data that the client doesn’t explicitly ask for, its use reduces opportunities for information disclosure issues. Returning more data than a client needs could lead to the unintentional exposure of sensitive data, such as personally identifiable information (PII), which could cause many other problems, especially for companies operating under heavy regulatory rules. However, as you’ll soon see, GraphQL also has security weaknesses that we, as hackers, can exploit.</p>
<h3 id="h2-502840c01-0001"><a class="XrefDestination" id="Origins"/><span class="XrefDestination" id="xref-502840c01-004"/>Origins</h3>
<p class="BodyFirst">Facebook developed GraphQL in 2012 and used it for a few years in its production environments before releasing it as open source software in 2015. That year, Facebook also developed and released the GraphQL specification and a reference implementation named <em>GraphQL.js</em> (<a class="LinkURL" href="https://github.com/graphql/graphql-js">https://github.com/graphql/graphql-js</a>), built using JavaScript.</p>
<p>GraphQL is now maintained by the GraphQL Foundation (<a class="LinkURL" href="https://graphql.org/foundation/">https://graphql.org/foundation/</a>), an organization founded by global technology companies. The foundation funds mentorship and project grants for GraphQL maintainers, manages policies of the GraphQL trademark, provides legal support for projects, and supports community-related infrastructure.</p>
<h3 id="h2-502840c01-0002"><a class="XrefDestination" id="UseCases"/><span class="XrefDestination" id="xref-502840c01-005"/>Use Cases</h3>
<p class="BodyFirst">Just about any application and device can use GraphQL. Companies may consider using it if their clients often request a lot of information at the same time, which would otherwise require making many REST API calls. Using GraphQL could reduce bandwidth usage and improve client performance.</p>
<p>For instance, imagine a website dashboard that consolidates information about the weather from multiple third-party weather websites and that is consumed by mobile clients on slow data networks. If the dashboard had to make a bunch of calls to the various weather networks and filter through the data, this wouldn’t be an optimized process. GraphQL allows the fetching of complex data structures in a single request, significantly reducing the required number of client and server round trips. You’ll learn more about this bandwidth-optimization design later in this chapter.</p>
<p>Today, many large-scale companies, such as Facebook, Atlassian, GitHub, and GitLab, use GraphQL, serving hundreds of millions of customers on <span epub:type="pagebreak" id="Page_3" title="3"/>various platforms, such as mobile phones, desktop computers, and even smart TVs.</p>
<h3 id="h2-502840c01-0003"><a class="XrefDestination" id="TheGraphQLSpecification"/><span class="XrefDestination" id="xref-502840c01-006"/>Specification</h3>
<p class="BodyFirst">In 2015, Facebook publicly released the GraphQL specification document, which defined rules, design principles, and standard practices to which all implementations of GraphQL must adhere. This specification is a reference for implementing GraphQL for multiple languages, similar to request for comments (RFC) documents. You can think of it as a blueprint.</p>
<p>As such, we, as hackers, can use it to better understand how GraphQL is meant to be implemented and verify that the target application we’re hacking conforms to these predefined rules. Because implementations often deviate from the standard for various reasons, chances increase for us to find bugs in them, some of which may have security implications.</p>
<h2 id="h1-502840c01-0002"><a class="XrefDestination" id="HowDoGraphQLCommunicationsWork?"/><span class="XrefDestination" id="xref-502840c01-007"/>How Do Communications Work?</h2>
<p class="BodyFirst">A typical GraphQL implementation incorporates a few components you should become familiar with if you hope to search it for security flaws. <a href="#figure1-1" id="figureanchor1-1">Figure 1-1</a> describes these.</p>
<figure>
<img alt="" class="" src="image_fi/502840c01/f01001.png"/>
<figcaption><p><a id="figure1-1">Figure 1-1</a>: Core GraphQL components</p></figcaption>
</figure>
<p>When a client wants to communicate with a GraphQL server (for example, to read a list of usernames and emails), that client will use the HyperText Transfer Protocol (HTTP) POST method to send the server a GraphQL query. You might already be noticing that this doesn’t follow standard HTTP method conventions, as data reads are more often than not implemented with the HTTP GET method; you will learn more about this later in this chapter.</p>
<p>The server, in turn, will process the query by using a query parser. <em>Query parsers</em> read and validate that the query is properly formatted and that the server can support it. This validation involves checking the query against the application’s GraphQL schema. If the query is deemed valid, it will be handled by resolver functions, which are responsible for generating the response to the client’s query. Talk about many moving pieces! Let’s break down these core components to better explain how they work together.</p>
<h3 id="h2-502840c01-0004"><span epub:type="pagebreak" id="Page_4" title="4"/><a class="XrefDestination" id="TheSchema"/><span class="XrefDestination" id="xref-502840c01-008"/>The Schema</h3>
<p class="BodyFirst">The GraphQL <em>schema</em> represents the type of data a client can query for. Schemas are defined using <em>schema definition language (SDL)</em>. <a href="#listing1-1" id="listinganchor1-1">Listing 1-1</a> shows its syntax for defining two object types.</p>
<pre><code>type User {
   username: String
   email: String
}

type Location {
   latitude: Int
   longitude: Int
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-1">Listing 1-1</a>: Schema definition language</p>
<p><em>Object</em> types are the most basic component of a GraphQL schema; they represent a piece of data you can fetch from the service running GraphQL. Object types have <em>fields</em>, which are object-specific attributes that have a value. In <a href="#listing1-1">Listing 1-1</a>, we define an object type called <code>User</code> and another type called <code>Location</code>. The <code>User</code> type has two fields, named <code>username</code> and <code>email</code>, both of which are of the <code>String</code> scalar type. The <code>Location</code> type also has two fields, named <code>latitude</code> and <code>longitude</code>, which are of <code>Int</code> (integer) scalar type.</p>
<p>So far, the objects and fields in our example schema aren’t connected to each other. However, GraphQL allows us to form links between objects in various ways. To visualize how this works, we can represent our schema as a graph consisting of nodes and edges. In our example, the <code>User</code> and <code>Location</code> object types are <em>nodes</em>, as shown in <a href="#figure1-2" id="figureanchor1-2">Figure 1-2</a>.</p>
<figure>
<img alt="" class="" src="image_fi/502840c01/f01002.png"/>
<figcaption><p><a id="figure1-2">Figure 1-2</a>: Graph nodes</p></figcaption>
</figure>
<p><em>Edges</em> are a way to create a link between multiple nodes. For example, an object could have a field that references another object. Let’s say you have a list of users, as well as a list of physical locations from which they last logged in, and you want to return a user’s location whenever a client queries for that user. <a href="#listing1-2" id="listinganchor1-2">Listing 1-2</a> shows how to do this by using edges.</p>
<pre><code>type User {
    username: String
    email: String
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> location: Location
}

<span epub:type="pagebreak" id="Page_5" title="5"/>  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> type Location {
    latitude: Int
    longitude: Int
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-2">Listing 1-2</a>: The linking of nodes</p>
<p>We added an additional <code>location</code> field to the <code>User</code> object type <span aria-label="annotation1" class="CodeAnnotation">❶</span> and linked it to the <code>Location</code> object type <span aria-label="annotation2" class="CodeAnnotation">❷</span>. In practice, this means that you can request a <code>User</code> object and get its associated location data. However, you won’t be able to query for a username by using the <code>Location</code> object type, because we haven’t defined that edge in our schema. <a href="#figure1-3" id="figureanchor1-3">Figure 1-3</a> illustrates how the two nodes now have a one-way link relationship.</p>
<figure>
<img alt="" class="" src="image_fi/502840c01/f01003.png"/>
<figcaption><p><a id="figure1-3">Figure 1-3</a>: One-way link relationship between nodes</p></figcaption>
</figure>
<p>Edges are not limited to one-way link relationships. In fact, you can create a two-way link relationship between the same objects, as shown in <a href="#figure1-4" id="figureanchor1-4">Figure 1-4</a>. Legitimate use cases exist for connecting two nodes in this way. In the <code>User</code> and <code>Location</code> example, imagine that clients of our API need the ability to fetch usernames and see their locations as part of the returned data. Also, let’s say that clients should be able to fetch specific locations and see which users have logged in at each location. Two-way link relationships allow for this.</p>
<figure>
<img alt="" class="" src="image_fi/502840c01/f01004.png"/>
<figcaption><p><a id="figure1-4">Figure 1-4</a>: Two-way link relationship between nodes</p></figcaption>
</figure>
<p>From a security perspective, two-way link relationships often lead to unwanted denial-of-service (DoS) conditions, which could completely take down a system. When two-way link relationships exist, API developers <span epub:type="pagebreak" id="Page_6" title="6"/>should introduce security controls to mitigate these vulnerabilities, which we’ll explain in more detail in <span class="xref" itemid="xref_target_Chapter 5.">Chapter 5.</span></p>
<h3 id="h2-502840c01-0005"><a class="XrefDestination" id="Queries"/><span class="XrefDestination" id="xref-502840c01-009"/>Queries</h3>
<p class="BodyFirst">Once an API’s schema is defined, clients can fetch information from it by using specially crafted queries written in the declarative GraphQL query language. In GraphQL, all queries begin with a definition of the operation’s <em>root type</em>, which specifies one of the following operations:</p>
<ul class="disc">
<li><em>Queries</em> are used for read-only operations. These operations don’t involve data manipulation.</li>
<li><em>Mutations</em> are used for data manipulation, such as data writes. These operations involve data modifications, data additions, data deletions, and so on. Mutations can be used to write and read data at the same time.</li>
<li><em>Subscriptions </em>are used for real-time communications between clients and GraphQL servers. They allow a GraphQL server to push data to the client when different events occur. Subscriptions typically are used in conjunction with transport protocols such as WebSocket.</li>
</ul>
<p>These three operations are the starting point for each GraphQL query we compose. For example, a query operation uses the <code>query</code> keyword:</p>
<pre><code>query {

}</code></pre>
<p>A mutation operation type uses the <code>mutation</code> keyword:</p>
<pre><code>mutation {

}</code></pre>
<p>Lastly, a subscription operation type uses the <code>subscription</code> keyword:</p>
<pre><code>subscription {

}</code></pre>
<p>Before a client can perform one of these operations, the developer must have defined the operation in the schema and specified the fields that clients can use. For example, <a href="#listing1-3" id="listinganchor1-3">Listing 1-3</a> defines the <code>Query</code> type and establishes the path that allows clients to fetch one of the object types we defined earlier, <code>User</code>.</p>
<pre><code>type User {
   username: String
   email: String
   location: Location
}

<span epub:type="pagebreak" id="Page_7" title="7"/>type Location {
   latitude: Int
   longitude: Int
}

type Query {
  users: [<b>User</b>]
}

schema {
  query: Query
}
</code></pre>
<p class="CodeListingCaption"><a id="listing1-3">Listing 1-3</a>: The full schema, with an entry point to querying the <code>User</code> type</p>
<p>By querying the <code>users</code> field in the <code>Query</code> type, clients can access the <code>User</code> object type we defined. The square brackets <code>[]</code> surrounding the <code>User</code> object type indicate that this query will return an array of <code>User</code> objects. We’ll discuss this syntax in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Notice that, while field names (like <code>users</code>) are lowercase, object names (like <code>User</code>) begin with an uppercase letter. This is the most common naming convention in GraphQL schemas.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><a href="#listing1-4" id="listinganchor1-4">Listing 1-4</a> is an example query that a client might send to a GraphQL server implementing the schema in <a href="#listing1-3">Listing 1-3</a>.</p>
<pre><code>query {
   users {
        username
        email
   }
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-4">Listing 1-4</a>: A GraphQL query</p>
<p>As you can see, GraphQL queries are pretty easy to read: all this query does is get the username and email of all users of the application. We define the query by using the <code>query</code> root operation. Then we request <code>users</code> as the query’s top-level field, specifying the <code>username</code> and <code>email</code> fields we want. Because this query only reads information and doesn’t change any data, we perform a query operation rather than a mutation.</p>
<p>Notice that blank spaces are used to separate components like names and values. The number of spaces used doesn’t matter; whether there’s a single space or multiple spaces, the query will remain the same and return consistent results.</p>
<h3 id="h2-502840c01-0006"><a class="XrefDestination" id="TheQueryParserandResolverFunctions"/><span class="XrefDestination" id="xref-502840c01-010"/>The Query Parser and Resolver Functions</h3>
<p class="BodyFirst">Now, what happens when a GraphQL server receives a query? Well, it makes use of a <em>query parser</em> to read and extract the information it needs to execute <span epub:type="pagebreak" id="Page_8" title="8"/>the incoming query. The query parser is responsible for turning the query string into an <em>abstract syntax tree (AST) </em>and validating it against the schema to ensure that only valid queries are accepted. An AST is a hierarchical object that represents the query. It includes fields, arguments, and other information and can be easily traversed by different language parsers.</p>
<p>GraphQL is <em>strongly typed</em>, which means that when clients use the wrong data types, the server returns an error. For example, if some data is defined as an <code>Int</code>, using a <code>String</code> instead would yield errors. This allows development teams to rely on the API to perform the type validation. We’ll discuss these types in more detail in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>.</p>
<p>To generate a response to the client’s query containing the requested data, the server uses <em>resolver functions</em>, also simply called <em>resolvers</em>. Resolvers are responsible for populating the response with data for each field specified in the client query. To do so, resolvers may implement code logic to take on tasks such as querying relational databases, cache databases, or other servers on the network. Every field has a corresponding resolver function responsible for returning the field’s response.</p>
<p>For example, to fulfill the query we showed in <a href="#listing1-4">Listing 1-4</a>, a resolver function may connect to an external database such as MySQL, and query its users table to get a list of the available username and email entries. Because resolver functions are the GraphQL component responsible for query resolution, this is also where vulnerabilities can exist. If the functions are written poorly, they may contain bugs, which may lead to security flaws.</p>
<p>Resolvers are not limited to reading from a database. They can read data from the local filesystem or make HTTP requests to additional systems over REST APIs. In fact, GraphQL APIs commonly make REST calls behind the scenes, especially when companies are gradually transitioning from using REST to GraphQL. Sometimes GraphQL is used as a consolidator API layer to multiple backend REST services that remain invisible to the client.</p>
<p>In summary, you can think of GraphQL as a query layer that sits between the client (such as a browser running on a user’s mobile phone or laptop) and the application logic. Clients seeking to interact with a GraphQL API could use a variety of available open source GraphQL client libraries, such as Apollo Client (<a class="LinkURL" href="https://www.apollographql.com/docs/react">https://www.apollographql.com/docs/react</a>), currently maintained by Apollo for TypeScript, or Relay (<a class="LinkURL" href="https://relay.dev">https://relay.dev</a>), currently maintained by Facebook for JavaScript. Using dedicated GraphQL clients isn’t required; you can also query GraphQL APIs using command line HTTP clients such as cURL. In <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>, we’ll cover how GraphQL works at the lower levels.</p>
<h2 id="h1-502840c01-0003"><a class="XrefDestination" id="WhatProblemsDoesGraphQLSolve?"/><span class="XrefDestination" id="xref-502840c01-011"/>What Problems Does GraphQL Solve?</h2>
<p class="BodyFirst">GraphQL improves the speed of client-server interactions by saving the client from having to make multiple requests in order to retrieve the complete set of data it needs from an application. Because GraphQL allows clients to define a precise query structure, it avoids costly performance issues such <span epub:type="pagebreak" id="Page_9" title="9"/>as <em>over-fetching</em> (returning data to the client that isn’t used) or <em>under-fetching</em> (returning too little data, forcing the client to make a second request). You’ll learn more about these differences and why they matter for performance in the next section.</p>
<p>GraphQL has additional useful features, such as schema stitching and schema federation. <em>Schema stitching</em> is a way to create a single GraphQL schema from multiple underlying GraphQL services, allowing GraphQL to be used as a unified gateway. Essentially, it packages (stitches) multiple schemas into one big schema, creating a single integration point for clients. Because multiple microservices can define their own GraphQL schemas and have their own GraphQL endpoints, allowing a single GraphQL API gateway to consolidate many schemas into one can make it easier for clients to integrate with an application.</p>
<p><em>Schema federation</em> is similar to schema stitching, except it doesn’t require you to manually stitch schemas together. Instead, schema federation lets you tell the GraphQL API gateway where to look for additional schemas. The gateway then does the stitching automatically. Federation is a lower-maintenance approach for consolidating multiple APIs into a single gateway.</p>
<p>Complex API applications, such as ones that require schema federation or schema stitching, may introduce security vulnerabilities, potentially allowing hackers to access data to which they shouldn’t otherwise have access. In general, the more complex an application is, the higher the chance that its internal complexities could lead to vulnerabilities.</p>
<h2 id="h1-502840c01-0004"><a class="XrefDestination" id="GraphQLAPIsvsRESTAPIs"/><span class="XrefDestination" id="xref-502840c01-012"/>GraphQL APIs vs. REST APIs</h2>
<p class="BodyFirst">In the previous sections, we discussed the challenges of traditional APIs that GraphQL attempts to solve. For example, REST APIs often provide more data than the client needs (over-fetching) or too little data (under-fetching), forcing the client to make additional API requests. In this section, we’ll walk through an example to demonstrate how an application fronted by a REST API compares to one that uses GraphQL.</p>
<p>Consider <a href="#table1-1" id="tableanchor1-1">Table 1-1</a>, a database table with information about an application’s user base. A simple web application might display this information as part of an admin panel that lets the systems administrator list all available accounts and get their state. We’ll call this the Users Administration page.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table1-1">Table 1-1</a>: Users Database Table</p></figcaption>
<table border="1" id="table-502840c01-0001">
<thead>
<tr>
<td><b>User ID</b></td>
<td><b>Username</b></td>
<td><b>Email</b></td>
<td><b>First name</b></td>
<td><b>Last name</b></td>
<td><b>State</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>dsmith</td>
<td><em>david@example.com</em></td>
<td>David</td>
<td>Smith</td>
<td>Disabled</td>
</tr>
<tr>
<td>2</td>
<td>clarry</td>
<td><em>chris@example.com</em></td>
<td>Chris</td>
<td>Larry</td>
<td>Enabled</td>
</tr>
</tbody>
</table>
</figure>
<p>In the following sections, we’ll describe the API requests a client would have to make to retrieve user data if the application were using a REST API, and how it might do the same in an application using GraphQL.</p>
<h3 id="h2-502840c01-0007"><span epub:type="pagebreak" id="Page_10" title="10"/><a class="XrefDestination" id="TheRESTAPIExample"/><span class="XrefDestination" id="xref-502840c01-013"/>The REST Example</h3>
<p class="BodyFirst">In applications that use REST APIs, we define specific <em>endpoints</em>, or <em>routes</em>, at which clients can perform actions such as reading or writing data using specific HTTP methods (such as GET or POST). <a href="#table1-2" id="tableanchor1-2">Table 1-2</a> defines two REST API endpoints for two purposes: one for getting a list of users and another to get information about a user’s login history.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table1-2">Table 1-2</a>: REST API Definitions</p></figcaption>
<table border="1" id="table-502840c01-0002">
<thead>
<tr>
<td><b>HTTP method</b></td>
<td><b>API endpoint</b></td>
<td><b>Endpoint description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td><em>/rest/v1/users</em></td>
<td>Returns a list of all available users and their information</td>
</tr>
<tr>
<td>GET</td>
<td><em>/rest/v1/history/&lt;user_id&gt;</em></td>
<td>Returns a list of the login timestamps for a given user</td>
</tr>
</tbody>
</table>
</figure>
<p>When a systems administrator wants to view the Users Administration page, their web client, such as a web browser, will need to obtain information about all available users through the web application’s API. To retrieve this data using the API endpoints in <a href="#table1-2">Table 1-2</a>, the web browser would need to send a GET request to <em>/rest/v1/users. </em><a href="#listing1-5" id="listinganchor1-5">Listing 1-5</a> shows this request and its response.</p>
<pre><code># <b>curl http://lab.blackhatgraphql.com/rest/v1/users</b>

[
  {
    "email": "david@example.com",
    "first_name": "David",
    "id": 1,
    "last_name": "Smith",
    "state": "disabled",
    "username": "dsmith"
  },
  {
    "email": "chris@example.com",
    "first_name": "Chris",
    "id": 2,
    "last_name": "Larry",
    "state": "enabled",
    "username": "clarry"
  }
]</code></pre>
<p class="CodeListingCaption"><a id="listing1-5">Listing 1-5</a>: GET request to<em> /rest/v1/users </em>that lists all system users</p>
<p>As you can see, this request returns the list of all users in JavaScript Object Notation (JSON) format, along with their emails, names, IDs, and account states.</p>
<p>But what if the system administrator wants to retrieve only certain information about users, such as their email addresses, without returning any other information? Using the API definitions in <a href="#table1-2">Table 1-2</a>, this wouldn’t <span epub:type="pagebreak" id="Page_11" title="11"/>be possible. Instead, the response in <a href="#listing1-5">Listing 1-5</a> would need to be processed in its entirety, and the <code>email</code> field would need to be extracted out of the response. This is an example of the over-fetching problem in REST APIs: the client receives more data than it needs and then has to filter it.</p>
<p>Now, imagine that you are the systems administrator and have been tasked with identifying any intrusion attempts on the network. You plan to write a script that will run every night and check for suspicious behavior. For example, it should flag users who have logged in after normal work hours, which are from 9 AM to 5 PM. To achieve this goal, the script will need to make an API request using the GET method to the <em>/rest/v1/history/&lt;user_id&gt;</em> endpoint. However, if you look closely at the endpoint structure, you’ll notice that it requires the client to supply a specific user ID. How will the script know the ID of the application’s users? The short answer: it won’t, unless it first fetches all of the available user IDs.</p>
<p>In practice, this means that in order for the script to successfully run, read a user’s last login timestamp, and identify a possible intrusion, it first needs to list all user accounts on the system using the API endpoint <em>/rest/v1/users</em>. This should return every user’s username, email, first name, last name, state, and user ID.</p>
<p>Next, it needs to make a second API request to <em>/rest/v1/history/1</em>, where <em>1</em> is the user ID obtained from the first request, as shown in <a href="#listing1-6" id="listinganchor1-6">Listing 1-6</a>.</p>
<pre><code>#<b> curl http://lab.blackhatgraphql.com/rest/v1/history/1</b>

<var>--snip--</var>
["02:03:37", "03:05:55"]
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing1-6">Listing 1-6</a>: Response from <em>/rest/v1/history/1</em></p>
<p>To get the entire list of all historical user logins, the client would need to make additional requests until it had fetched all user IDs. If we have 1,000 users, that will require 1,000 requests. Sounds like an inefficient process, doesn’t it? This is an example of the under-fetching problem that REST APIs tend to have. RESTful APIs can be designed to return specific information, but the complexity required to allow for such querying flexibility across a variety of REST endpoints will make it challenging to maintain over time.</p>
<p>While making two requests to retrieve the login info of a single user may not seem like a big deal at first glance, imagine that the application serves millions of clients simultaneously. At this scale, every request counts; any additional cross-network calls will result in increased latency on the server and impact the client’s experience. This will decrease the overall speed and efficiency of the application.</p>
<p>If you’d like to see these requests in action, you can experiment with this example’s APIs by pointing your web browser to the live lab located at <a class="LinkURL" href="http://lab.blackhatgraphql.com/start">http://lab.blackhatgraphql.com/start</a>. There, click the two links to navigate to the REST from within your web browser, as shown in <a href="#figure1-5" id="figureanchor1-5">Figure 1-5</a>.</p>
<span epub:type="pagebreak" id="Page_12" title="12"/><figure>
<img alt="" class="keyline" src="image_fi/502840c01/f01005.png"/>
<figcaption><p><a id="figure1-5">Figure 1-5</a>: A live REST API example</p></figcaption>
</figure>
<p>We’ve demonstrated the under-fetching and over-fetching problems of REST APIs. How will GraphQL solve these? Let’s explore the exact same scenario in the GraphQL world.</p>
<h3 id="h2-502840c01-0008"><a class="XrefDestination" id="TheGraphQLExample"/><span class="XrefDestination" id="xref-502840c01-014"/>The GraphQL Example</h3>
<p class="BodyFirst">Imagine that our Users Administration web application has scrapped its REST API in favor of GraphQL, and that we’ve established a schema defining a data-graph edge between the users and history nodes. Now, when the systems administrator views the Users Administration page, their web browser will use the application’s GraphQL API endpoint to return all the data needed.</p>
<p>The browser might use the query in <a href="#listing1-7" id="listinganchor1-7">Listing 1-7</a> to retrieve information such as user IDs, emails, first names, last names, historical information such as the timestamp of their last login, and account states:</p>
<pre><code>query {
   users {
       id
       email
       first_name
       last_name
       state
       history {
         last_login_timestamp
       }
   }
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-7">Listing 1-7</a>: GraphQL query to fetch information about the users</p>
<p><span epub:type="pagebreak" id="Page_13" title="13"/>A response to such a query can be seen in <a href="#listing1-8" id="listinganchor1-8">Listing 1-8</a>.</p>
<pre><code>"data": {
  "users": [
    {
      "id":1,
      "email": "david@example.com",
      "first_name": "David",
      "last_name": "Smith",
      "state": "disabled",
      "history": {
          "last_login_timestamp":["02:03:37", "03:05:55"]
      }
    },
    {
      "id": 2,
      "email": "chris@example.com"
<var>--snip--</var>
    }
  ]
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-8">Listing 1-8</a>: GraphQL query response containing all available users and their information</p>
<p>Notice that the response contains a <code>data</code> JSON field, which includes the <code>users</code> field, and that the <code>users</code> field is an array containing all users on the system.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	GraphQL response data does not require a specific serialization format. However, JSON is the most commonly used format for GraphQL.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>At this point, there aren’t any visible differences between the REST and GraphQL APIs. So, how does GraphQL address the over-fetching and under-fetching problems? Well, if we wanted to specifically request a certain field, such as the users’ email addresses, we could omit any irrelevant fields and include only the <code>email</code> field, as shown in <a href="#listing1-9" id="listinganchor1-9">Listing 1-9</a>.</p>
<pre><code>query {
  users {
    email
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-9">Listing 1-9</a>: GraphQL query that returns only email addresses</p>
<p>By explicitly including the fields we’re interested in returning, we limit the response to relevant data, as shown in <a href="#listing1-10" id="listinganchor1-10">Listing 1-10</a>.</p>
<pre><code>"data": {
  "users": [
    {
      "email": "david@example.com"
    },
    {
<span epub:type="pagebreak" id="Page_14" title="14"/>      "email": "chris@example.com"
    }
  ]
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-10">Listing 1-10</a>: GraphQL server response containing only email addresses</p>
<p>As you can see, the response contains only the email addresses, as instructed by the query. If 100 email addresses were stored in the backend database, all of them would have been returned with such a query.</p>
<p>Now, remember when, earlier, we wanted to return users’ last login timestamps for our intrusion detection task? With GraphQL, we can do so using a query similar to the one shown in <a href="#listing1-11" id="listinganchor1-11">Listing 1-11</a>.</p>
<pre><code>query {
   users {
     email
     history {
         last_login_timestamp
     }
   }
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-11">Listing 1-11</a>: GraphQL query that returns the timestamp of the last logins made by users, along with their emails</p>
<p>As expected, we receive only the relevant fields, as shown in <a href="#listing1-12" id="listinganchor1-12">Listing 1-12</a>.</p>
<pre><code>{
  "data":{
     "users":[
         {
          "email": "david@example.com",
          "history": {
             "last_login_timestamp":["02:03:37"]
            }
         },
         {
          "email": "chris@example.com",
          "history": {
             "last_login_timestamp":["02:03:37", "03:05:55"]
            }
         }
    ]
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-12">Listing 1-12</a>: GraphQL response containing only the <code>email</code> and <code>last_login_timestamp</code> fields</p>
<p>Using GraphQL’s powerful declarative language, we can craft very selective queries that fetch only the necessary information. In later chapters, you’ll learn how to leverage this query syntax to attack GraphQL servers.</p>
<h3 id="h2-502840c01-0009"><span epub:type="pagebreak" id="Page_15" title="15"/><a class="XrefDestination" id="OtherDifferencesBetweenRESTandGraphQL"/><span class="XrefDestination" id="xref-502840c01-015"/>Other Differences</h3>
<p class="BodyFirst">This section lists other significant differences between REST APIs and GraphQL APIs that security professionals should be aware of. These include the specific HTTP methods an application should use, which HTTP status codes to return in specific error scenarios, and more. Some of these differences might seem odd to anyone who has performed penetration tests of REST applications, as in certain cases GraphQL strays from the guidance of the HTTP RFC.</p>
<h4 id="h3-502840c01-0001"><a class="XrefDestination" id="HTTPRequestMethods"/><span class="XrefDestination" id="xref-502840c01-016"/>HTTP Request Methods</h4>
<p class="BodyFirst">Earlier in this chapter, we mentioned that GraphQL communications typically happen over the POST method, whether for writing data, deleting data, or simply reading data. By contrast, REST APIs use HTTP methods to indicate the client’s intention. For example, they would use GET for reading data and POST for creating or updating data.</p>
<p>It’s important to note that GraphQL can, in fact, accept queries over the GET method. Even though GraphQL applications mostly use POST, you should test a GraphQL application for the support of the GET method, as it can open up opportunities to identify and abuse vulnerabilities such as cross-site request forgery (CSRF). We’ll discuss CSRF in more detail in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>.</p>
<h4 id="h3-502840c01-0002"><a class="XrefDestination" id="APIEndpointPaths"/><span class="XrefDestination" id="xref-502840c01-017"/>API Endpoint Paths</h4>
<p class="BodyFirst">In GraphQL, the endpoint exposed to the client is usually located at <em>/graphql</em>. Applications may also choose to offer multiple versions of an API, in which case you may see endpoints such as <em>/v1/graphql</em> or <em>/v2/graphql</em>.</p>
<p>No matter which endpoint the API uses, it will remain the same across all client requests. This differs from REST APIs, which expose each resource at a separate endpoint. Every REST endpoint could have its own set of controls and supported methods. For instance, a <em>/history</em> endpoint might allow only GET requests so that clients can fetch historical records, while a <em>/users </em>endpoint might support both GET- and POST-based requests, to allow clients to fetch the list of users as well as add new user accounts.</p>
<p>GraphQL instead defines client intentions in the query payload, through operations such as queries and mutations. The endpoint remains consistent no matter the resource accessed or action performed.</p>
<h4 id="h3-502840c01-0003"><a class="XrefDestination" id="HTTPStatusCodes"/><span class="XrefDestination" id="xref-502840c01-018"/>HTTP Status Codes</h4>
<p class="BodyFirst">HTTP status codes such as <em>200 OK</em>, <em>404 Not Found</em>, and <em>401 Unauthorized</em> play a key role in REST APIs, because they signal to the client the outcome of their request. For example, when a user attempts to log in to a web page with an incorrect username or password, an application with a REST API may return the status code of <em>401 Unauthorized</em> to signal to the client that they aren’t authorized.</p>
<p>In GraphQL APIs, the status code returned by the server will almost exclusively be <em>200 OK</em>, even if the action failed because of authorization <span epub:type="pagebreak" id="Page_16" title="16"/>errors or because the requested resource doesn’t exist on the server. GraphQL indicates errors to the client by returning an <code>errors</code> field as part of the response payload, as shown in <a href="#listing1-13" id="listinganchor1-13">Listing 1-13</a>.</p>
<pre><code>{
    "errors": [
      {
        "message": "Cannot query field "usernam" on type "User". Did you mean "username"?",
        "locations": [
          {
            "line": 3,
            "column": 5
          }
          <var>--snip--</var>
        ]
     }
   ]
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-13">Listing 1-13</a>: The GraphQL response error format</p>
<p>You might see a status code other than<em> 200 OK </em>if the server fails to serve the request completely because of a critical server-side error, such as a database being down or another backend failure. In these cases, GraphQL may return the expected <em>500 Server Error</em> status code.</p>
<h4 id="h3-502840c01-0004"><a class="XrefDestination" id="TheImportanceofRunningGraphQL-TailoredSecurityTools"/><span class="XrefDestination" id="xref-502840c01-019"/>The Importance of Running GraphQL-Tailored Security Tools</h4>
<p class="BodyFirst">These differences in HTTP status codes, request methods, and API endpoint paths necessitate a significant shift in our approach to security analysis, intrusion detection, and penetration testing. During traditional penetration tests, we often rely on hacking tools to handle the heavy lifting when it comes to vulnerability assessment and application scanning. When we test GraphQL applications, these security tools may report false-positive findings if they don’t have GraphQL support built in.</p>
<p>Traditional web application scanners are tailored to the RFC 2616 HTTP standard and assume that applications conform with this RFC when it comes to the status codes they return. For example, a web application vulnerability scanner that conducts a brute-force attack may report that a successful exploitation occurred if it ever receives a <em>200 OK</em> status code from the target server. However, you shouldn’t interpret a <em>200 OK</em> status code in the same way when it is returned from GraphQL-based applications.</p>
<p>When it comes to security analysis, security operators face a challenge when they attempt to interpret the access logs of a GraphQL application, especially if they are used to interacting with REST API applications. Consider the HTTP access log sample shown in <a href="#listing1-14" id="listinganchor1-14">Listing 1-14</a>.</p>
<pre><code>172.17.0.1 - - [04:31:01] "POST /graphql HTTP/1.1" 200 -
172.17.0.1 - - [04:31:05] "POST /graphql HTTP/1.1" 200 -
172.17.0.1 - - [04:31:37] "POST /graphql HTTP/1.1" 200 -</code></pre>
<p class="CodeListingCaption"><a id="listing1-14">Listing 1-14</a>: Access log patterns for a GraphQL application</p>
<p><span epub:type="pagebreak" id="Page_17" title="17"/>If a security operator is analyzing this log data for suspicious patterns, it won’t be particularly insightful if the logs were generated by a GraphQL application. Finding useful information will require implementing specialized tooling and logging infrastructure.</p>
<p>Very often, developers deploy newer technology, such as GraphQL, without customizations or prior research. As hackers, this gives us some leverage. The fact that GraphQL doesn’t comply with standard HTTP status code principles may allow us to evade security controls such as web application firewalls (WAFs), as well as go under the radar when security operators are looking for anomalous patterns in HTTP error codes, especially if those security operators aren’t aware that GraphQL behaves differently than REST.</p>
<h2 id="h1-502840c01-0005"><a class="XrefDestination" id="YourFirstGraphQLQuery"/><span class="XrefDestination" id="xref-502840c01-020"/>Your First Query</h2>
<p class="BodyFirst">Now that you’ve learned about APIs and the differences between GraphQL and REST, it’s time for you to experiment with a real GraphQL application. In this exercise, you’ll use common tools to build your first query and receive a successful response from a GraphQL server.</p>
<p>This exercise doesn’t require you to install any special tools. GraphQL implementations often provide a graphical user interface (GUI) for running queries in the form of an integrated development environment (IDE). A few such tools are out there, including <em>GraphiQL Explorer </em>(pronounced <em>graphical</em>; note the lowercase <em>i</em>) and <em>GraphQL Playground</em>, which are available as either an additional package to install or as part of the base installation, depending on the implementation.</p>
<p>We’ll use GraphiQL Explorer, which allows a user to query GraphQL with auto-completion features, read autogenerated schema documentation, identify syntax errors in queries through error highlighting, see historical queries, and use query variables. These features make it very easy for first-time GraphQL users to interact with an application. As hackers, we can also benefit from access to such tools. You’ll learn more about how we can find and abuse these types of interfaces in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>.</p>
<p>Let’s go ahead and experiment with writing GraphQL queries. Open any browser and navigate to <a class="LinkURL" href="http://lab.blackhatgraphql.com/graphiql">http://lab.blackhatgraphql.com/graphiql</a>. You will be greeted with a screen similar to the one shown in <a href="#figure1-6" id="figureanchor1-6">Figure 1-6</a>.</p>
<p>In the left pane, you can enter queries. The resulting output will display in the right pane. Try entering the simple query shown in <a href="#listing1-15" id="listinganchor1-15">Listing 1-15</a>.</p>
<pre><code><b>query {</b>
<b>  users {</b>
<b>    email</b>
<b>    first_name</b>
<b>    last_name</b>
<b>  }</b>
<b>}</b></code></pre>
<p class="CodeListingCaption"><a id="listing1-15">Listing 1-15</a>: GraphQL query that displays user information</p>
<span epub:type="pagebreak" id="Page_18" title="18"/><figure>
<img alt="" class="keyline" src="image_fi/502840c01/f01006.png"/>
<figcaption><p><a id="figure1-6">Figure 1-6</a>: The GraphiQL Explorer panel</p></figcaption>
</figure>
<p>To send the query to the server, click the play button located at the top-left corner. You should see the result shown in <a href="#figure1-7" id="figureanchor1-7">Figure 1-7</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c01/f01007.png"/>
<figcaption><p><a id="figure1-7">Figure 1-7</a>: GraphQL query result</p></figcaption>
</figure>
<p>You might have noticed a small drop-down menu appear as soon as you start typing a query. This menu provides auto-completion options, as shown in <a href="#figure1-8" id="figureanchor1-8">Figure 1-8</a>.</p>
<span epub:type="pagebreak" id="Page_19" title="19"/><figure>
<img alt="" class="keyline" src="image_fi/502840c01/f01008.png"/>
<figcaption><p><a id="figure1-8">Figure 1-8</a>: GraphiQL Explorer auto-completion suggestions</p></figcaption>
</figure>
<p>The auto-completion feature is useful, especially when you need to interact with GraphQL applications that have complex schemas. Without insight into the schema, it would be fairly challenging to guess what a valid query might look like. The auto-completion feature is available when GraphiQL Explorer is able to query the GraphQL server by using the introspection query, GraphQL’s self-documenting API feature. You will learn more about introspection in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>.</p>
<p>To view additional information about the application’s GraphQL schema, click the<b> Docs</b> tab located in the right pane. This will open up autogenerated documentation, as shown in <a href="#figure1-9" id="figureanchor1-9">Figure 1-9</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c01/f01009.png"/>
<figcaption><p><a id="figure1-9">Figure 1-9</a>: GraphiQL Explorer autogenerated schema documentation</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_20" title="20"/>GraphiQL Explorer also gives you a view of all previously sent queries, as shown in <a href="#figure1-10" id="figureanchor1-10">Figure 1-10</a>. You can click a query to replay it.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c01/f01010.png"/>
<figcaption><p><a id="figure1-10">Figure 1-10</a>: Historical queries in GraphiQL Explorer</p></figcaption>
</figure>
<p>GraphQL servers are unauthenticated by default, which allows graphical interfaces such as GraphiQL Explorer and GraphQL Playground to interact with them freely. Typically, protecting these graphical interfaces doesn’t make a ton of sense, because they are simple frontends to the API, and we could still use other clients, such as cURL, to perform direct API calls to the server. The API server itself should implement protections to avoid unauthorized API queries.</p>
<h2 id="h1-502840c01-0006"><a class="XrefDestination" id="Summary"/><span class="XrefDestination" id="xref-502840c01-021"/>Summary</h2>
<p class="BodyFirst">In this chapter, you received an introduction to GraphQL. We covered what GraphQL is and the problems it attempts to solve. We also walked through examples that demonstrate the fundamental differences between REST and GraphQL APIs, and why it’s important to understand these differences in the context of security. Additionally, you had your first hands-on experience of querying a GraphQL API by using the GraphiQL Explorer tool.</p>
</section>
</body>
</html>