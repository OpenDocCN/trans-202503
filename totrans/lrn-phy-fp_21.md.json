["```\n{-# OPTIONS -Wall #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n\nmodule MultipleObjects where\n\nimport SimpleVec\n    ( Vec, R, (^+^), (^-^), (*^), (^*), (^/), zeroV, magnitude )\nimport Mechanics1D\n    ( RealVectorSpace(..), Diff(..), NumericalMethod, Mass, TimeStep, euler )\nimport Mechanics3D\n    ( OneBodyForce, ParticleState(..), DParticleState(..), HasTime(..)\n    , defaultParticleState, newtonSecondPS )\n\n```", "```\ntype TwoBodyForce\n    =  ParticleState  -- force is produced BY particle with this state\n    -> ParticleState  -- force acts ON particle with this state\n    -> ForceVector\n```", "```\ntype ForceVector = Vec\n```", "```\noneFromTwo :: ParticleState  -- state of particle PRODUCING the force\n           -> TwoBodyForce\n           -> OneBodyForce\noneFromTwo stBy f = f stBy\n```", "```\ngravityMagnitude :: Mass -> Mass -> R -> R\ngravityMagnitude m1 m2 r = let gg = 6.67408e-11  -- N m^2 / kg^2\n                           in gg * m1 * m2 / r**2\n```", "```\nuniversalGravity :: TwoBodyForce\nuniversalGravity st1 st2\n    = let gg = 6.67408e-11  -- N m^2 / kg^2\n          m1 = mass st1\n          m2 = mass st2\n          r1 = posVec st1\n          r2 = posVec st2\n          r21 = r2 ^-^ r1\n      in (-gg) *^ m1 *^ m2 *^ r21 ^/ magnitude r21 ** 3\n```", "```\nconstantRepulsiveForceWrong :: ForceVector -> TwoBodyForce\nconstantRepulsiveForceWrong force = \\_ _ -> force\n```", "```\nconstantRepulsiveForce :: R -> TwoBodyForce\nconstantRepulsiveForce force st1 st2\n    = let r1 = posVec st1\n          r2 = posVec st2\n          r21 = r2 ^-^ r1\n      in force *^ r21 ^/ magnitude r21\n```", "```\nlinearSpring :: R  -- spring constant\n             -> R  -- equilibrium length\n             -> TwoBodyForce\nlinearSpring k re st1 st2\n    = let r1 = posVec st1\n          r2 = posVec st2\n          r21 = r2 ^-^ r1\n          r21mag = magnitude r21\n      in (-k) *^ (r21mag - re) *^ r21 ^/ r21mag\n```", "```\nfixedLinearSpring :: R -> R -> Vec -> OneBodyForce\nfixedLinearSpring k re r1\n    = oneFromTwo (defaultParticleState { posVec = r1 }) (linearSpring k re)\n```", "```\ncentralForce :: (R -> R) -> TwoBodyForce\ncentralForce f st1 st2\n    = let r1 = posVec st1\n          r2 = posVec st2\n          r21 = r2 ^-^ r1\n          r21mag = magnitude r21\n      in f r21mag *^ r21 ^/ r21mag\n```", "```\nlinearSpringCentral :: R  -- spring constant\n                    -> R  -- equilibrium length\n                    -> TwoBodyForce\nlinearSpringCentral k re = centralForce (\\r -> -k * (r - re))\n```", "```\nbilliardForce :: R  -- spring constant\n              -> R  -- threshold center separation\n              -> TwoBodyForce\nbilliardForce k re\n    = centralForce $ \\r -> if r >= re\n                           then 0\n                           else (-k * (r - re))\n```", "```\ndata Force = ExternalForce Int OneBodyForce\n           | InternalForce Int Int TwoBodyForce\n```", "```\nExternalForce 98 (fixedLinearSpring 1 0.5 (vec 100 0 0))\n```", "```\nInternalForce 0 1 universalGravity\n```", "```\nInternalForce 1 0 universalGravity\n```", "```\ndata MultiParticleState\n    = MPS { particleStates :: [ParticleState] } deriving Show\n```", "```\ninstance HasTime MultiParticleState where\n    timeOf (MPS sts) = time (sts !! 0)\n```", "```\ndata DMultiParticleState = DMPS [DParticleState] deriving Show\n```", "```\nnewtonSecondMPS :: [Force]\n                -> MultiParticleState -> DMultiParticleState  -- a diff eqn\n```", "```\nnewtonSecondMPS fs mpst@(MPS sts)\n    = let deriv (n,st) = newtonSecondPS (forcesOn n mpst fs) st\n      in DMPS $ map deriv (zip [0..] sts)\n```", "```\nforcesOn :: Int -> MultiParticleState -> [Force] -> [OneBodyForce]\nforcesOn n mpst = map (forceOn n mpst)\n```", "```\nforceOn :: Int -> MultiParticleState -> Force -> OneBodyForce\nforceOn n _         (ExternalForce n0 fOneBody)\n    | n == n0    = fOneBody\n    | otherwise  = const zeroV\nforceOn n (MPS sts) (InternalForce n0 n1 fTwoBody)\n    | n == n0    = oneFromTwo (sts !! n1) fTwoBody  -- n1 acts on n0\n    | n == n1    = oneFromTwo (sts !! n0) fTwoBody  -- n0 acts on n1\n    | otherwise  = const zeroV\n```", "```\ninstance RealVectorSpace DMultiParticleState where\n    DMPS dsts1 +++ DMPS dsts2 = DMPS $ zipWith (+++) dsts1 dsts2\n    scale w (DMPS dsts) = DMPS $ map (scale w) dsts\n```", "```\ninstance Diff MultiParticleState DMultiParticleState where\n    shift dt (DMPS dsts) (MPS sts) = MPS $ zipWith (shift dt) dsts sts\n```", "```\neulerCromerMPS :: TimeStep        -- dt for stepping\n               -> NumericalMethod MultiParticleState DMultiParticleState\neulerCromerMPS dt deriv mpst0\n    = let mpst1 = euler dt deriv mpst0 sts0 = particleStates mpst0\n          sts1 = particleStates mpst1\n          -- now update positions\n          in MPS $ [ st1 { posVec = posVec st0 ^+^ velocity st1 ^* dt }\n                         | (st0,st1) <- zip sts0 sts1 ]\n```", "```\nupdateMPS :: NumericalMethod MultiParticleState DMultiParticleState\n          -> [Force]\n          -> MultiParticleState -> MultiParticleState\nupdateMPS method = method . newtonSecondMPS\n```", "```\nstatesMPS :: NumericalMethod MultiParticleState DMultiParticleState\n          -> [Force]\n          -> MultiParticleState -> [MultiParticleState]\nstatesMPS method = iterate . method . newtonSecondMPS\n```", "```\nspeed :: ParticleState -> R\nspeed st = undefined st\n```", "```\nuniversalGravity' :: TwoBodyForce\nuniversalGravity' (ParticleState m1 _ _ r1 _) (ParticleState m2 _ _ r2 _)\n    = undefined m1 r1 m2 r2\n```", "```\nuniversalGravityCentral :: TwoBodyForce\nuniversalGravityCentral = undefined\n```", "```\nlennardJones :: R  -- dissociation energy\n             -> R  -- equilibrium length\n             -> TwoBodyForce\nlennardJones de re = centralForce $ \\r -> undefined de re r\n```", "```\nsystemKE :: MultiParticleState -> R\nsystemKE mpst = undefined mpst\n```", "```\nforcesOn' :: Int -> MultiParticleState -> [Force] -> [OneBodyForce]\nforcesOn' n mpst fs = externalForcesOn n fs ++ internalForcesOn n mpst fs\n\nexternalForcesOn :: Int -> [Force] -> [OneBodyForce]\nexternalForcesOn n fs = undefined n fs\n\ninternalForcesOn :: Int -> MultiParticleState -> [Force] -> [OneBodyForce]\ninternalForcesOn n (MPS sts) fs\n    = [oneFromTwo (sts !! n1) f | InternalForce n0 n1 f <- fs, n == n0] ++\n      [oneFromTwo (sts !! n0) f | InternalForce n0 n1 f <- fs, n == n1]\n```"]