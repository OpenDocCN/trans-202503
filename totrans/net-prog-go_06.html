<html><head></head><body>
<section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_73" title="73"/>4</span><br/>&#13;
<span class="ChapterTitle">Sending TCP Data </span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" src="image_fi/book_art/chapterart.png"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Now that you know how to properly establish and gracefully terminate TCP connections in Go, it’s time to put that knowledge to use by transmitting data. This chapter covers various techniques for sending and receiving data over a network using TCP. </p>&#13;
<p>We’ll talk about the most common methods of reading data from network connections. You’ll create a simple messaging protocol that allows you to transmit dynamically sized payloads between nodes. You’ll then explore the networking possibilities afforded by the <code>net.Conn</code> interface. The chapter concludes with a deeper dive into the <code>TCPConn</code> object and insidious TCP networking problems that Go developers may experience.</p>&#13;
<h2 id="h1-500884c04-0001"><span epub:type="pagebreak" id="Page_74" title="74"/>Using the net.Conn Interface</h2>&#13;
<p class="BodyFirst">Most of the network code in this book uses Go’s <code>net.Conn</code> interface whenever possible, because it provides the functionality we need for most cases. You can write powerful network code using the <code>net.Conn</code> interface without having to assert its underlying type, ensuring your code is compatible across operating systems and allowing you to write more robust tests. (You will learn how to access <code>net.Conn</code>’s underlying type to use its more advanced methods later in this chapter.) The methods available on <code>net.Conn</code> cover most use cases. </p>&#13;
<p>The two most useful <code>net.Conn</code> methods are <code>Read</code> and <code>Write</code>. These methods implement the <code>io.Reader</code> and <code>io.Writer</code> interfaces, respectively, which are ubiquitous in the Go standard library and ecosystem. As a result, you can leverage the vast amounts of code written for those interfaces to create incredibly powerful network applications.</p>&#13;
<p>You use <code>net.Conn</code>’s <code>Close</code> method to close the network connection. This method will return <code>nil</code> if the connection successfully closed or an error otherwise. The <code>SetReadDeadline</code> and <code>SetWriteDeadline</code> methods, which accept a <code>time.Time</code> object, set the absolute time after which reads and writes on the network connection will return an error. The <code>SetDeadline</code> method sets both the read and write deadlines at the same time. As discussed in <span class="xref" itemid="xref_target_“Implementing Deadlines” on page 62">“Implementing Deadlines” on page 62</span>, deadlines allow you to control how long a network connection may remain idle and allow for timely detection of network connectivity problems.</p>&#13;
<h2 id="h1-500884c04-0002">Sending and Receiving Data</h2>&#13;
<p class="BodyFirst">Reading data from a network connection and writing data to it is no different from reading and writing to a file object, since <code>net.Conn</code> implements the <code>io.ReadWriteCloser</code> interface used to read and write to files. In this section, you’ll first learn how to read data into a fixed-size buffer. Next, you’ll learn how to use <code>bufio.Scanner</code> to read data from a network connection until it encounters a specific delimiter. You’ll then explore TLV, an encoding method that enables you to define a basic protocol to dynamically allocate buffers for varying payload sizes. Finally, you’ll see how to handle errors when reading from and writing to network connections.</p>&#13;
<h3 id="h2-500884c04-0001">Reading Data into a Fixed Buffer</h3>&#13;
<p class="BodyFirst">TCP connections in Go implement the <code>io.Reader</code> interface, which allows you to read data from the network connection. To read data from a network connection, you need to provide a buffer for the network connection’s <code>Read</code> method to fill. </p>&#13;
<p>The <code>Read</code> method will populate the buffer to its capacity if there is enough data in the connection’s receive buffer. If there are fewer bytes in the receive buffer than the capacity of the buffer you provide, <code>Read</code> will populate the given buffer with the data and return instead of waiting for more <span epub:type="pagebreak" id="Page_75" title="75"/>data to arrive. In other words, <code>Read</code> is not guaranteed to fill your buffer to capacity before it returns. <a href="#listing4-1" id="listinganchor4-1">Listing 4-1</a> demonstrates the process of reading data from a network connection into a byte slice.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "crypto/rand"&#13;
    "io"&#13;
    "net"&#13;
    "testing"&#13;
)&#13;
&#13;
func TestReadIntoBuffer(t *testing.T) {&#13;
    <span class="CodeAnnotationHang">1</span> payload := make([]byte, 1&lt;&lt;24) // 16 MB&#13;
    _, err := rand.Read(payload)   // generate a random payload&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    listener, err := net.Listen("tcp", "127.0.0.1:")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    go func() {&#13;
        conn, err := listener.Accept()&#13;
        if err != nil {&#13;
            t.Log(err)&#13;
            return&#13;
        }&#13;
        defer conn.Close()&#13;
&#13;
        <span class="CodeAnnotationHang">2</span> _, err = conn.Write(payload)&#13;
        if err != nil {&#13;
            t.Error(err)&#13;
        }&#13;
    }()&#13;
&#13;
    conn, err := net.Dial("tcp", listener.Addr().String())&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    buf := make([]byte, <span class="CodeAnnotation">3</span>1&lt;&lt;19) // 512 KB&#13;
&#13;
    for {&#13;
        <span class="CodeAnnotationHang">4</span> n, err := conn.Read(buf)&#13;
        if err != nil {&#13;
            if err != io.EOF {&#13;
                t.Error(err)&#13;
            }&#13;
            break&#13;
<span epub:type="pagebreak" id="Page_76" title="76"/>        }&#13;
&#13;
        t.Logf("read %d bytes", n) // buf[:n] is the data read from conn&#13;
    }&#13;
&#13;
    conn.Close()&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-1">Listing 4-1</a>: Receiving data over a network connection (<em>read_test.go</em>)</p>&#13;
<p>You need something for the client to read, so you create a 16MB payload of random data <span class="CodeAnnotation">1</span>—more data than the client can read in its chosen buffer size of 512KB <span class="CodeAnnotation">3</span> so that it will make at least a few iterations around its <code>for</code> loop. It’s perfectly acceptable to use a larger buffer or a smaller payload and read the entirety of the payload in a single call to <code>Read</code>. Go correctly processes the data regardless of the payload and receive buffer sizes.</p>&#13;
<p>You then spin up the listener and create a goroutine to listen for incoming connections. Once accepted, the server writes the entire payload to the network connection <span class="CodeAnnotation">2</span>. The client then reads up to the first 512KB from the connection <span class="CodeAnnotation">4</span> before continuing around the loop. The client continues to read up to 512KB at a time until either an error occurs or the client reads the entire 16MB payload.</p>&#13;
<h3 id="h2-500884c04-0002">Delimited Reading by Using a Scanner</h3>&#13;
<p class="BodyFirst">Reading data from a network connection by using the method I just showed means your code needs to make sense of the data it receives. Since TCP is a stream-oriented protocol, a client can receive a stream of bytes across many packets. Unlike sentences, binary data doesn’t include inherent punctuation that tells you where one message starts and stops. </p>&#13;
<p>If, for example, your code is reading a series of email messages from a server, your code will have to inspect each byte for delimiters indicating the boundaries of each message in the stream of bytes. Alternatively, your client may have an established protocol with the server whereby the server sends a fixed number of bytes to indicate the payload size the server will send next. Your code can then use this size to create an appropriate buffer for the payload. You’ll see an example of this technique a little later in this chapter.</p>&#13;
<p>However, if you choose to use a delimiter to indicate the end of one message and the beginning of another, writing code to handle edge cases isn’t so simple. For example, you may read 1KB of data from a single <code>Read</code> on the network connection and find that it contains two delimiters. This indicates that you have two complete messages, but you don’t have enough information about the chunk of data following the second delimiter to know whether it is also a complete message. If you read another 1KB of data and find no delimiters, you can conclude that this entire block of data is a continuation of the last message in the previous 1KB you read. But what if you read 1KB of nothing but delimiters? </p>&#13;
<p>If this is starting to sound a bit complex, it’s because you must account for data across multiple <code>Read</code> calls and handle any errors along the way. <span epub:type="pagebreak" id="Page_77" title="77"/>Anytime you’re tempted to roll your own solution to such a problem, check the standard library to see if a tried-and-true implementation already exists. In this case, <code>bufio.Scanner</code> does what you need.</p>&#13;
<p>The <code>bufio.Scanner</code> is a convenient bit of code in Go’s standard library that allows you to read delimited data. The <code>Scanner</code> accepts an <code>io.Reader</code> as its input. Since <code>net.Conn</code> has a <code>Read</code> method that implements the <code>io.Reader</code> interface, you can use the <code>Scanner</code> to easily read delimited data from a network connection. <a href="#listing4-2" id="listinganchor4-2">Listing 4-2</a> sets up a listener to serve up delimited data for later parsing by <code>bufio.Scanner</code>.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "bufio"&#13;
    "net"&#13;
    "reflect"&#13;
    "testing"&#13;
)&#13;
&#13;
const <span class="CodeAnnotation">1</span>payload = "The bigger the interface, the weaker the abstraction."&#13;
&#13;
func TestScanner(t *testing.T) {&#13;
    listener, err := net.Listen("tcp", "127.0.0.1:")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    go func() {&#13;
        conn, err := listener.Accept()&#13;
        if err != nil {&#13;
            t.Error(err)&#13;
            return&#13;
        }&#13;
        defer conn.Close()&#13;
&#13;
        _, err = conn.Write([]byte(payload))&#13;
        if err != nil {&#13;
            t.Error(err)&#13;
        }&#13;
    }()&#13;
&#13;
<var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-2">Listing 4-2</a>: Creating a test to serve up a constant payload (<em>scanner_test.go</em>)</p>&#13;
<p>This listener should look familiar by now. All it’s meant to do is serve up the payload <span class="CodeAnnotation">1</span>. <a href="#listing4-3" id="listinganchor4-3">Listing 4-3</a> uses <code>bufio.Scanner</code> to read a string from the network, splitting each chunk by whitespace.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    conn, err := net.Dial("tcp", listener.Addr().String())&#13;
    if err != nil {&#13;
<span epub:type="pagebreak" id="Page_78" title="78"/>        t.Fatal(err)&#13;
    }&#13;
    defer conn.Close()&#13;
&#13;
    <span class="CodeAnnotationHang">1</span> scanner := bufio.NewScanner(conn)&#13;
    scanner.Split(bufio.ScanWords)&#13;
&#13;
    var words []string&#13;
&#13;
    <span class="CodeAnnotationHang">2</span> for scanner.Scan() {&#13;
        words = append(words, <span class="CodeAnnotation">3</span>scanner.Text())&#13;
    }&#13;
&#13;
    err = scanner.Err()&#13;
    if err != nil {&#13;
        t.Error(err)&#13;
    }&#13;
&#13;
    expected := []string{"The", "bigger", "the", "interface,", "the", &#13;
        "weaker", "the", "abstraction."}&#13;
&#13;
    if !reflect.DeepEqual(words, expected) {&#13;
        t.Fatal("inaccurate scanned word list")&#13;
    }&#13;
    <span class="CodeAnnotationHang">4</span> t.Logf("Scanned words: %#v", words)&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-3">Listing 4-3</a>: Using <var>bufio.Scanner</var> to read whitespace-delimited text from the network (<em>scanner_test.go</em>)</p>&#13;
<p>Since you know you’re reading a string from the server, you start by creating a <code>bufio.Scanner</code> that reads from the network connection <span class="CodeAnnotation">1</span>. By default, the scanner will split data read from the network connection when it encounters a newline character (<code>\n</code>) in the stream of data. Instead, you elect to have the scanner delimit the input at the end of each word by using <code>bufio.ScanWords</code>, which will split the data when it encounters a word border, such as whitespace or sentence-terminating punctuation.</p>&#13;
<p>You keep reading data from the scanner as long as it tells you it’s read data from the connection <span class="CodeAnnotation">2</span>. Every call to <code>Scan</code> can result in multiple calls to the network connection’s <code>Read</code> method until the scanner finds its delimiter or reads an error from the connection. It hides the complexity of searching for a delimiter across one or more reads from the network connection and returning the resulting messages.</p>&#13;
<p>The call to the scanner’s <code>Text</code> method returns the chunk of data as a string—a single word and adjacent punctuation, in this case—that it just read from the network connection <span class="CodeAnnotation">3</span>. The code continues to iterate around the <code>for</code> loop until the scanner receives an <code>io.EOF</code> or other error from the network connection. If it’s the latter, the scanner’s <code>Err</code> method will return a non-<code>nil</code> error. You can view the scanned words <span class="CodeAnnotation">4</span> by adding the <code>-v</code> flag to the <code>go test</code> command.</p>&#13;
<h3 id="h2-500884c04-0003"><span epub:type="pagebreak" id="Page_79" title="79"/>Dynamically Allocating the Buffer Size</h3>&#13;
<p class="BodyFirst">You can read data of variable length from a network connection, provided that both the sender and receiver have agreed on a protocol for doing so. The <em>type-length-value</em><em>(TLV)</em> encoding scheme is a good option. TLV encoding uses a fixed number of bytes to represent the type of data, a fixed number of bytes to represent the value size, and a variable number of bytes to represent the value itself. Our implementation uses a 5-byte header: 1 byte for the type and 4 bytes for the length. The TLV encoding scheme allows you to send a type as a series of bytes to a remote node and constitute the same type on the remote node from the series of bytes.</p>&#13;
<p><a href="#listing4-4" id="listinganchor4-4">Listing 4-4</a> defines the types that our TLV encoding protocol will accept.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "bytes"&#13;
    "encoding/binary"&#13;
    "errors"&#13;
    "fmt"&#13;
    "io"&#13;
)&#13;
&#13;
const (&#13;
    <span class="CodeAnnotationHang">1</span> BinaryType uint8 = iota + 1&#13;
    <span class="CodeAnnotationHang">2</span> StringType&#13;
&#13;
    <span class="CodeAnnotationHang">3</span> MaxPayloadSize uint32 = 10 &lt;&lt; 20 // 10 MB&#13;
)&#13;
&#13;
var ErrMaxPayloadSize = errors.New("maximum payload size exceeded")&#13;
&#13;
type <span class="CodeAnnotation">4</span>Payload interface {&#13;
    fmt.Stringer&#13;
    io.ReaderFrom&#13;
    io.WriterTo&#13;
    Bytes() []byte&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-4">Listing 4-4</a>: The message struct implements a simple protocol (<em>types.go</em>).</p>&#13;
<p>You start by creating constants to represent each type you will define. In this example, you will create a <code>BinaryType</code><span class="CodeAnnotation">1</span> and a <code>StringType</code><span class="CodeAnnotation">2</span>. After digesting the implementation details of each type, you should be able to create types that fit your needs. For security purposes that we’ll discuss in just a moment, you must define a maximum payload size <span class="CodeAnnotation">3</span>.</p>&#13;
<p>You also define an interface named <code>Payload</code><span class="CodeAnnotation">4</span> that describes the methods each type must implement. Each type must have the following methods: <code>Bytes</code>, <code>String</code>, <code>ReadFrom</code>, and <code>WriteTo</code>. The <code>io.ReaderFrom</code> and <code>io.WriterTo</code> interfaces allow your types to read from readers and write to writers, respectively. You have some flexibility in this regard. You could just as easily make the <code/><span epub:type="pagebreak" id="Page_80" title="80"/>Payload implement the <code>encoding.BinaryMarshaler</code> interface to marshal itself to a byte slice and the <code>encoding.BinaryUnmarshaler</code> interface to unmarshal itself from a byte slice. But the byte slice is one level removed from the network connection, so you’ll keep the <code>Payload</code> interface as is. Besides, you’ll use the binary encoding interfaces in the next chapter.</p>&#13;
<p>You now have the foundation built to create TLV-based types. <a href="#listing4-5" id="listinganchor4-5">Listing 4-5</a> details the first type, <code>Binary</code>.</p>&#13;
<pre><code><em>--snip--</em>&#13;
&#13;
type <span class="CodeAnnotation">1</span>Binary []byte&#13;
&#13;
func (m Binary) <span class="CodeAnnotation">2</span>Bytes() []byte  { return m }&#13;
func (m Binary) <span class="CodeAnnotation">3</span>String() string { return string(m) }&#13;
&#13;
func (m Binary) <span class="CodeAnnotation">4</span>WriteTo(w io.Writer) (int64, error) {&#13;
    err := <span class="CodeAnnotation">5</span>binary.Write(w, binary.BigEndian, BinaryType) // 1-byte type&#13;
    if err != nil {&#13;
        return 0, err&#13;
    }&#13;
    var n int64 = 1&#13;
&#13;
    err = <span class="CodeAnnotation">6</span>binary.Write(w, binary.BigEndian, uint32(len(m))) // 4-byte size&#13;
    if err != nil {&#13;
        return n, err&#13;
    }&#13;
    n += 4&#13;
&#13;
    o, err := <span class="CodeAnnotation">7</span>w.Write(m) // payload&#13;
&#13;
    return n + int64(o), err&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-5">Listing 4-5</a>: Creating the <var>Binary</var> type (<em>types.go</em>)</p>&#13;
<p>The <code>Binary</code> type <span class="CodeAnnotation">1</span> is a byte slice; therefore, its <code>Bytes</code> method <span class="CodeAnnotation">2</span> simply returns itself. Its <code>String</code> method <span class="CodeAnnotation">3</span> casts itself as a <code>string</code> before returning. The <code>WriteTo</code> method accepts an <code>io.Writer</code> and returns the number of bytes written to the writer and an <code>error</code> interface <span class="CodeAnnotation">4</span>. The <code>WriteTo</code> method first writes the 1-byte type to the writer <span class="CodeAnnotation">5</span>. It then writes the 4-byte length of the <code>Binary</code> to the writer <span class="CodeAnnotation">6</span>. Finally, it writes the <code>Binary</code> value itself <span class="CodeAnnotation">7</span>.</p>&#13;
<p><a href="#listing4-6" id="listinganchor4-6">Listing 4-6</a> rounds out the <code>Binary</code> type with its <code>ReadFrom</code> method.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func (m *Binary) ReadFrom(r io.Reader) (int64, error) {&#13;
    var typ uint8&#13;
    err := <span class="CodeAnnotation">1</span>binary.Read(r, binary.BigEndian, &amp;typ) // 1-byte type&#13;
    if err != nil {&#13;
        return 0, err&#13;
    }&#13;
    var n int64 = 1&#13;
    if typ != <span class="CodeAnnotation">2</span>BinaryType {&#13;
<span epub:type="pagebreak" id="Page_81" title="81"/>        return n, errors.New("invalid Binary")&#13;
    }&#13;
&#13;
    var size uint32&#13;
    err = <span class="CodeAnnotation">3</span>binary.Read(r, binary.BigEndian, &amp;size) // 4-byte size&#13;
    if err != nil {&#13;
        return n, err&#13;
    }&#13;
    n += 4&#13;
    <span class="CodeAnnotationHang">4</span> if size &gt; MaxPayloadSize {&#13;
        return n, ErrMaxPayloadSize&#13;
    }&#13;
&#13;
    <span class="CodeAnnotationHang">5</span> *m = make([]byte, size)&#13;
    o, err := <span class="CodeAnnotation">6</span>r.Read(*m) // payload&#13;
&#13;
    return n + int64(o), err&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-6">Listing 4-6</a>: Completing the <var>Binary</var> type’s implementation (<em>types.go</em>)</p>&#13;
<p>The <code>ReadFrom</code> method reads <span class="CodeAnnotation">1</span> 1 byte from the reader into the <code>typ</code> variable. It next verifies <span class="CodeAnnotation">2</span> that the type is <code>BinaryType</code> before proceeding. Then it reads <span class="CodeAnnotation">3</span> the next 4 bytes into the <code>size</code> variable, which sizes the new <code>Binary</code> byte slice <span class="CodeAnnotation">5</span>. Finally, it populates the <code>Binary</code> byte slice <span class="CodeAnnotation">6</span>.</p>&#13;
<p>Notice that you enforce a maximum payload size <span class="CodeAnnotation">4</span>. This is because the 4-byte integer you use to designate the payload size has a maximum value of 4,294,967,295, indicating a payload of over 4GB. With such a large payload size, it would be easy for a malicious actor to perform a denial-of-service attack that exhausts all the available random access memory (RAM) on your computer. Keeping the maximum payload size reasonable makes memory exhaustion attacks harder to execute.</p>&#13;
<p><a href="#listing4-7" id="listinganchor4-7">Listing 4-7</a> introduces the <code>String</code> type, which, like <code>Binary</code>, implements the <code>Payload</code> interface.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
type String string&#13;
&#13;
func (m String) <span class="CodeAnnotation">1</span>Bytes() []byte  { return []byte(m) }&#13;
func (m String) <span class="CodeAnnotation">2</span>String() string { return string(m) }&#13;
&#13;
func (m String) <span class="CodeAnnotation">3</span>WriteTo(w io.Writer) (int64, error) {&#13;
    err := <span class="CodeAnnotation">4</span>binary.Write(w, binary.BigEndian, StringType) // 1-byte type&#13;
    if err != nil {&#13;
        return 0, err&#13;
    }&#13;
    var n int64 = 1&#13;
&#13;
    err = binary.Write(w, binary.BigEndian, uint32(len(m))) // 4-byte size&#13;
    if err != nil {&#13;
        return n, err&#13;
    }&#13;
<span epub:type="pagebreak" id="Page_82" title="82"/>    n += 4&#13;
&#13;
    o, err := <span class="CodeAnnotation">5</span>w.Write([]byte(m)) // payload&#13;
&#13;
    return n + int64(o), err&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-7">Listing 4-7</a>: Creating the <var>String</var> type (<em>types.go</em>)</p>&#13;
<p>The <code>String</code> implementation’s <code>Bytes</code> method <span class="CodeAnnotation">1</span> casts the <code>String</code> to a byte slice. The <code>String</code> method <span class="CodeAnnotation">2</span> casts the <code>String</code> type to its base type, <code>string</code>. The <code>String</code> type’s <code>WriteTo</code> method <span class="CodeAnnotation">3</span> is like <code>Binary</code>’s <code>WriteTo</code> method except the first byte written <span class="CodeAnnotation">4</span> is the <code>StringType</code> and it casts the <code>String</code> to a byte slice before writing it to the writer <span class="CodeAnnotation">5</span>.</p>&#13;
<p><a href="#listing4-8" id="listinganchor4-8">Listing 4-8</a> finishes up the <code>String</code> type’s <code>Payload</code> implementation.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func (m *String) ReadFrom(r io.Reader) (int64, error) {&#13;
    var typ uint8&#13;
    err := binary.Read(r, binary.BigEndian, &amp;typ) // 1-byte type&#13;
    if err != nil {&#13;
        return 0, err&#13;
    }&#13;
    var n int64 = 1&#13;
    if typ != <span class="CodeAnnotation">1</span>StringType {&#13;
        return n, errors.New("invalid String")&#13;
    }&#13;
&#13;
    var size uint32&#13;
    err = binary.Read(r, binary.BigEndian, &amp;size) // 4-byte size&#13;
    if err != nil {&#13;
        return n, err&#13;
    }&#13;
    n += 4&#13;
&#13;
    buf := make([]byte, size)&#13;
    o, err := r.Read(buf) // payload&#13;
    if err != nil {&#13;
        return n, err&#13;
    }&#13;
    <span class="CodeAnnotationHang">2</span> *m = String(buf)&#13;
&#13;
    return n + int64(o), nil&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-8">Listing 4-8</a>: Completing the <var>String</var> type’s implementation (<em>types.go</em>)</p>&#13;
<p>Here, too, <code>String</code>’s <code>ReadFrom</code> method is like <code>Binary</code>’s <code>ReadFrom</code> method, with two exceptions. First, the method compares the <code>typ</code> variable against the <code>StringType</code><span class="CodeAnnotation">1</span> before proceeding. Second, the method casts the value read from the reader to a <code>String</code><span class="CodeAnnotation">2</span>.</p>&#13;
<p><span epub:type="pagebreak" id="Page_83" title="83"/>All that’s left to implement is a way to read arbitrary data from a network connection and use it to constitute one of our two types. For that, we turn to <a href="#listing4-9" id="listinganchor4-9">Listing 4-9</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func <span class="CodeAnnotation">1</span>decode(r io.Reader) (Payload, error) {&#13;
    var typ uint8&#13;
    err := <span class="CodeAnnotation">2</span>binary.Read(r, binary.BigEndian, &amp;typ)&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    <span class="CodeAnnotationHang">3</span> var payload Payload&#13;
&#13;
    switch <span class="CodeAnnotation">4</span>typ {&#13;
    case BinaryType:&#13;
        payload = new(Binary)&#13;
    case StringType:&#13;
        payload = new(String)&#13;
    default:&#13;
        return nil, errors.New("unknown type")&#13;
    }&#13;
&#13;
    _, err = payload.ReadFrom(&#13;
        <span class="CodeAnnotationHang">5</span> io.MultiReader(bytes.NewReader([]byte{typ}), r))&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    return payload, nil&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-9">Listing 4-9</a>: Decoding bytes from a reader into a <var>Binary</var> or <var>String</var> type (<em>types.go</em>)</p>&#13;
<p>The <code>decode</code> function <span class="CodeAnnotation">1</span> accepts an <code>io.Reader</code> and returns a <code>Payload</code> interface and an <code>error</code> interface. If <code>decode</code> cannot decode the bytes read from the reader into a <code>Binary</code> or <code>String</code> type, it will return an error along with a nil <code>Payload</code>.</p>&#13;
<p>You must first read a byte from the reader <span class="CodeAnnotation">2</span> to determine the type and create a <code>payload</code> variable <span class="CodeAnnotation">3</span> to hold the decoded type. If the type you read from the reader is an expected type constant <span class="CodeAnnotation">4</span>, you assign the corresponding type to the payload variable.</p>&#13;
<p>You now have enough information to finish decoding the binary data from the reader into the <code>payload</code> variable by using its <code>ReadFrom</code> method. But you have a problem here. You cannot simply pass the reader to the <code>ReadFrom</code> method. You’ve already read a byte from it corresponding to the type, yet the <code>ReadFrom</code> method expects the first byte it reads to be the type as well. Thankfully, the <code>io</code> package has a helpful function you can use: <code>MultiReader</code>. We cover <code>io.MultiReader</code> in more detail later in this chapter, but here you use it to concatenate the byte you’ve already read with the reader <span class="CodeAnnotation">5</span>. From the <code>ReadFrom</code> method’s perspective, it will read the bytes in the sequence it expects.</p>&#13;
<p><span epub:type="pagebreak" id="Page_84" title="84"/>Although the use of <code>io.MultiReader</code> shows you how to inject bytes back into a reader, it isn’t optimal in this use case. The proper fix is to remove each type’s need to read the first byte in its <code>ReadFrom</code> method. Then, the <code>ReadFrom</code> method would read only the 4-byte size and the payload, eliminating the need to inject the type byte back into the reader before passing it on to <code>ReadFrom</code>. As an exercise, I recommend you refactor the code to eliminate the need for <code>io.MultiReader</code>.</p>&#13;
<p>Let’s see the <code>decode</code> function in action in the form of a test. <a href="#listing4-10" id="listinganchor4-10">Listing 4-10</a> illustrates how you can send your two distinct types over a network connection and properly decode them back into their original type on the receiver’s end.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "bytes"&#13;
    "encoding/binary"&#13;
    "net"&#13;
    "reflect"&#13;
    "testing"&#13;
)&#13;
&#13;
func TestPayloads(t *testing.T) {&#13;
    b1 := <span class="CodeAnnotation">1</span>Binary("Clear is better than clever.")&#13;
    b2 := Binary("Don't panic.")&#13;
    s1 := <span class="CodeAnnotation">2</span>String("Errors are values.")&#13;
    payloads := <span class="CodeAnnotation">3</span>[]Payload{&amp;b1, &amp;s1, &amp;b2}&#13;
&#13;
    listener, err := net.Listen("tcp", "127.0.0.1:")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    go func() {&#13;
        conn, err := listener.Accept()&#13;
        if err != nil {&#13;
            t.Error(err)&#13;
            return&#13;
        }&#13;
        defer conn.Close()&#13;
&#13;
        for _, p := range payloads {&#13;
            _, err = <span class="CodeAnnotation">4</span>p.WriteTo(conn)&#13;
            if err != nil {&#13;
                t.Error(err)&#13;
                break&#13;
            }&#13;
        }&#13;
    }()&#13;
&#13;
<var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-10">Listing 4-10</a>: Creating the <var>TestPayloads</var> test (<em>types_test.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_85" title="85"/>Your test should first create at least one of each type. You create two <code>Binary</code> types <span class="CodeAnnotation">1</span> and one <code>String</code> type <span class="CodeAnnotation">2</span>. Next, you create a slice of <code>Payload</code> interfaces and add pointers to the <code>Binary</code> and <code>String</code> types you created <span class="CodeAnnotation">3</span>. You then create a listener that will accept a connection and write each type in the <code>payloads</code> slice to it <span class="CodeAnnotation">4</span>.</p>&#13;
<p>This is a good start. Let’s finish up the client side of the test in <a href="#listing4-11" id="listinganchor4-11">Listing 4-11</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    conn, err := <span class="CodeAnnotation">1</span>net.Dial("tcp", listener.Addr().String())&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer conn.Close()&#13;
&#13;
    for i := 0; i &lt; len(payloads); i++ {&#13;
        actual, err := <span class="CodeAnnotation">2</span>decode(conn)&#13;
        if err != nil {&#13;
            t.Fatal(err)&#13;
        }&#13;
&#13;
        <span class="CodeAnnotationHang">3</span> if expected := payloads[i]; !reflect.DeepEqual(expected, actual) {&#13;
            t.Errorf("value mismatch: %v != %v", expected, actual)&#13;
            continue&#13;
        }&#13;
&#13;
        <span class="CodeAnnotationHang">4</span> t.Logf("[%T] %[1]q", actual)&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-11">Listing 4-11</a>: Completing the <var>TestPayloads</var> test (<em>types_test.go</em>)</p>&#13;
<p>You know how many types to expect in the payloads slice, so you initiate a connection to the listener <span class="CodeAnnotation">1</span> and attempt to decode each one <span class="CodeAnnotation">2</span>. Finally, your test compares the type you decoded with the type the server sent <span class="CodeAnnotation">3</span>. If there’s any discrepancy with the variable type or its contents, the test fails. You can run the test with the <code>-v</code> flag to see the type and its value <span class="CodeAnnotation">4</span>.</p>&#13;
<p>Let’s make sure the <code>Binary</code> type enforces the maximum payload size in <a href="#listing4-12" id="listinganchor4-12">Listing 4-12</a>.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func TestMaxPayloadSize(t *testing.T) {&#13;
    buf := new(bytes.Buffer)&#13;
    err := buf.WriteByte(BinaryType)&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    err = binary.Write(buf, binary.BigEndian, <span class="CodeAnnotation">1</span>uint32(1&lt;&lt;30)) // 1 GB&#13;
    if err != nil {&#13;
<span epub:type="pagebreak" id="Page_86" title="86"/>        t.Fatal(err)&#13;
    }&#13;
&#13;
    var b Binary&#13;
    _, err = b.ReadFrom(buf)&#13;
    <span class="CodeAnnotationHang">2</span> if err != ErrMaxPayloadSize {&#13;
        t.Fatalf("expected ErrMaxPayloadSize; actual: %v", err)&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-12">Listing 4-12</a>: Testing the maximum payload size (<em>types_test.go</em>)</p>&#13;
<p>This test starts with the creation of a <code>bytes.Buffer</code> containing the <code>BinaryType</code> byte and a 4-byte, unsigned integer indicating the payload is 1GB <span class="CodeAnnotation">1</span>. When this buffer is passed to the <code>Binary</code> type’s <code>ReadFrom</code> method, you receive the <code>ErrMaxPayloadSize</code> error in return <span class="CodeAnnotation">2</span>. The test cases in Listings 4-10 and 4-11 should cover the use case of a payload that is less than the maximum size, but I encourage you to modify this test to make sure that’s the case.</p>&#13;
<h3 id="h2-500884c04-0004">Handling Errors While Reading and Writing Data </h3>&#13;
<p class="BodyFirst">Unlike writing to file objects, writing to network connections can be unreliable, especially if your network connection is spotty. Files don’t often return errors while you’re writing to them, but the receiver on the other end of a network connection may abruptly disconnect before you write your entire payload.</p>&#13;
<p>Not all errors returned when reading from or writing to a network connection are permanent. The connection can recover from some errors. For example, writing data to a network connection where adverse network conditions delay the receiver’s ACK packets, and where your connection times out while waiting to receive them, can result in a temporary error. This can occur if someone temporarily unplugs a network cable between you and the receiver. In that case, the network connection is still active, and you can either attempt to recover from the error or gracefully terminate your end of the connection.</p>&#13;
<p><a href="#listing4-13" id="listinganchor4-13">Listing 4-13</a> illustrates how to check for temporary errors while writing data to a network connection.</p>&#13;
<pre><code>var (&#13;
    err error&#13;
    n int&#13;
    i = 7 // maximum number of retries&#13;
)&#13;
&#13;
<span class="CodeAnnotationHang">1</span> for ; i &gt; 0; i-- {&#13;
    n, err = <span class="CodeAnnotation">2</span>conn.Write(<span class="CodeAnnotation">3</span>[]byte("hello world"))&#13;
    if err != nil {&#13;
        if nErr, ok := <span class="CodeAnnotation">4</span>err.(net.Error); ok &amp;&amp; <span class="CodeAnnotation">5</span>nErr.Temporary() {&#13;
            log.Println("temporary error:", nErr)&#13;
<span epub:type="pagebreak" id="Page_87" title="87"/>            time.Sleep(10 * time.Second)&#13;
            continue&#13;
        }&#13;
       <span class="CodeAnnotationHang">6</span> return err&#13;
    }&#13;
    break&#13;
}&#13;
&#13;
if i == 0 {&#13;
    return errors.New("temporary write failure threshold exceeded")&#13;
}&#13;
&#13;
log.Printf("wrote %d bytes to %s\n", n, conn.RemoteAddr())</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-13">Listing 4-13</a>: Sending the string <var>"hello world"</var> over the connection</p>&#13;
<p>Since you might receive a transient error when writing to a network connection, you might need to retry a write operation. One way to account for this is to encapsulate the code in a <code>for</code> loop <span class="CodeAnnotation">1</span>. This makes it easy to retry the write operation, if necessary.</p>&#13;
<p>To write to the connection, you pass a byte slice <span class="CodeAnnotation">3</span> to the connection’s <code>Write</code> method <span class="CodeAnnotation">2</span> as you would to any other <code>io.Writer</code>. This returns the number of bytes written and an <code>error</code> interface. If the <code>error</code> interface is not <code>nil</code>, you check whether the error implements the <code>net.Error</code> interface by using a type assertion <span class="CodeAnnotation">4</span> and check whether the error is temporary <span class="CodeAnnotation">5</span>. If the <code>net.Error</code>’s <code>Temporary</code> method returns <code>true</code>, the code makes another write attempt by iterating around the <code>for</code> loop. If the error is permanent, the code returns the error <span class="CodeAnnotation">6</span>. A successful write breaks out of the loop.</p>&#13;
<h2 id="h1-500884c04-0003">Creating Robust Network Applications by Using the io Package</h2>&#13;
<p class="BodyFirst">In addition to interfaces common in Go code, such as <code>io.Reader</code> and <code>io.Writer</code>, the <code>io</code> package provides several useful functions and utilities that make the creation of robust network applications easy. In this section, you’ll learn how to use the <code>io.Copy</code>, <code>io.MultiWriter</code>, and <code>io.TeeReader</code> functions to proxy data between connections, log network traffic, and ping hosts when firewalls attempt to keep you from doing so.</p>&#13;
<h3 id="h2-500884c04-0005">Proxying Data Between Connections</h3>&#13;
<p class="BodyFirst">One of the most useful functions from the <code>io</code> package, the <code>io.Copy</code> function reads data from an <code>io.Reader</code> and writes it to an <code>io.Writer</code>. This is useful for creating a <em>proxy</em>, which, in this context, is an intermediary that transfers data between two nodes. Since <code>net.Conn</code> includes both <code>io.Reader</code> and <code>io.Writer</code> interfaces, and <code>io.Copy</code> writes whatever it reads from an <code>io.Reader</code> to an <code>io.Writer</code>, you can easily create a proxy between network connections, such <span epub:type="pagebreak" id="Page_88" title="88"/>as the one you define in the <code>proxyConn</code> function in <a href="#listing4-14" id="listinganchor4-14">Listing 4-14</a>. This function copies any data sent from the source node to the destination node, and vice versa.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "io"&#13;
    "net"&#13;
)&#13;
&#13;
func proxyConn(source, destination string) error {&#13;
    connSource, err := <span class="CodeAnnotation">1</span>net.Dial("tcp", source)&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
    defer connSource.Close()&#13;
&#13;
    connDestination, err := <span class="CodeAnnotation">2</span>net.Dial("tcp", destination)&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
    defer connDestination.Close()&#13;
&#13;
    // connDestination replies to connSource&#13;
    <span class="CodeAnnotationHang">3</span> go func() { _, _ = io.Copy(connSource, connDestination) }()&#13;
&#13;
    // connSource messages to connDestination&#13;
    <span class="CodeAnnotationHang">4</span> _, err = io.Copy(connDestination, connSource)&#13;
&#13;
    return err&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-14">Listing 4-14</a>: Proxying data between two network connections (<em>proxy_conn.go</em>)</p>&#13;
<p>The <code>io.Copy</code> function does all the heavy input/output (I/O) lifting for you. It takes an <code>io.Writer</code> as its first argument and an <code>io.Reader</code> as its second argument. It then writes, to the writer, everything it reads from the reader until the reader returns an <code>io.EOF</code>, or, alternately, either the reader or writer returns an error. The <code>io.Copy</code> function returns an error only if a non-<code>io.EOF</code> error occurred during the copy, because <code>io.EOF</code> means it has read all the data from the reader.</p>&#13;
<p>You start by creating a connection to the <code>source</code> node <span class="CodeAnnotation">1</span> and a connection to the <code>destination </code>node <span class="CodeAnnotation">2</span>. Next, you run <code>io.Copy</code> in a goroutine, reading from <code>connDestination</code> and writing to <code>connSource</code><span class="CodeAnnotation">3</span> to handle any replies. You don’t need to worry about leaking this goroutine, since <code>io.Copy</code> will return when either connection is closed. Then, you make another call to <code>io.Copy</code>, reading from <code>connSource</code> and writing to <code>connDestination</code><span class="CodeAnnotation">4</span>. Once this call returns and the function returns, each connection’s <code>Close</code> method runs, <span epub:type="pagebreak" id="Page_89" title="89"/>which causes <code>io.Copy</code> to return, terminating its goroutine <span class="CodeAnnotation">3</span>. As a result, the data is proxied between network connections as if they had a direct connection to one another.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>Since Go version 1.11, if you use <var>io.Copy</var> or <var>io.CopyN</var> when the source and destination are both <var>*net.TCPConn</var> objects, the data never enters the user space on Linux, thereby causing the data transfer to occur more efficiently. Think of it as the Linux kernel reading from one socket and writing to the other without the data needing to interact directly with your Go code. <var>io.CopyN</var> functions like <var>io.Copy</var> except it copies up to <em>n</em> bytes. We’ll use <var>io.CopyN</var> in the next chapter.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p><a href="#listing4-15" id="listinganchor4-15">Listing 4-15</a> illustrates how to use a slight variation of the <code>proxyConn</code> function. Whereas <a href="#listing4-14">Listing 4-14</a>’s <code>proxyConn</code> function established network connections and proxied traffic between them, <a href="#listing4-15">Listing 4-15</a>’s <code>proxy</code> function proxies data between an <code>io.Reader</code> and an <code>io.Writer</code>, making it applicable to more than just network connections and much easier to test.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "io"&#13;
    "net"&#13;
    "sync"&#13;
    "testing"&#13;
)&#13;
&#13;
<span class="CodeAnnotationHang">1</span> func proxy(from io.Reader, to io.Writer) error {&#13;
    fromWriter, fromIsWriter := from.(io.Writer)&#13;
    toReader, toIsReader := to.(io.Reader)&#13;
&#13;
    if toIsReader &amp;&amp; fromIsWriter {&#13;
        // Send replies since "from" and "to" implement the&#13;
        // necessary interfaces.&#13;
        go func() { _, _ = io.Copy(fromWriter, toReader) }()&#13;
    }&#13;
&#13;
    _, err := io.Copy(to, from)&#13;
&#13;
    return err&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-15">Listing 4-15</a>: Proxy data between a reader and writer (<em>proxy_test.go</em>)</p>&#13;
<p>This <code>proxy</code> function <span class="CodeAnnotation">1</span> is a bit more useful in that it accepts the ubiquitous <code>io.Reader</code> and <code>io.Writer</code> interfaces instead of <code>net.Conn</code>. Because of this change, you could proxy data from a network connection to <code>os.Stdout</code>, <code>*bytes.Buffer</code>, <code>*os.File</code>, or any number of objects that implement the <code>io.Writer</code> interface. Likewise, you could read bytes from any object that implements the <code>io.Reader</code> interface and send them to the writer. This implementation of <code>proxy</code> supports replies if the <em>from</em> reader implements the <code>io.Writer</code> interface and the <em>to</em> writer implements the <code>io.Reader</code> interface.</p>&#13;
<p><a href="#listing4-16" id="listinganchor4-16">Listing 4-16</a> creates a test to make sure the proxy functions as you expect.</p>&#13;
<span epub:type="pagebreak" id="Page_90" title="90"/><pre><code><var>--snip--</var>&#13;
&#13;
func TestProxy(t *testing.T) {&#13;
    var wg sync.WaitGroup&#13;
&#13;
    // server listens for a "ping" message and responds with a&#13;
    // "pong" message. All other messages are echoed back to the client.&#13;
    <span class="CodeAnnotationHang">1</span> server, err := net.Listen("tcp", "127.0.0.1:")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    wg.Add(1)&#13;
&#13;
    go func() {&#13;
        defer wg.Done()&#13;
&#13;
        for {&#13;
            conn, err := server.Accept()&#13;
            if err != nil {&#13;
                return&#13;
            }&#13;
&#13;
            go func(c net.Conn) {&#13;
                defer c.Close()&#13;
&#13;
                for {&#13;
                    buf := make([]byte, 1024)&#13;
                    n, err := c.Read(buf)&#13;
                    if err != nil {&#13;
                        if err != io.EOF {&#13;
                            t.Error(err)&#13;
                        }&#13;
&#13;
                        return&#13;
                    }&#13;
&#13;
                    switch msg := string(buf[:n]); msg {&#13;
                    case "ping":&#13;
                        _, err = c.Write([]byte("pong"))&#13;
                    default:&#13;
                        _, err = c.Write(buf[:n])&#13;
                    }&#13;
&#13;
                    if err != nil {&#13;
                        if err != io.EOF {&#13;
                            t.Error(err)&#13;
                        }&#13;
&#13;
                        return&#13;
                    }&#13;
                }&#13;
            }(conn)&#13;
        }&#13;
<span epub:type="pagebreak" id="Page_91" title="91"/>    }()&#13;
&#13;
<var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-16">Listing 4-16</a>: Creating the listener (<em>proxy_test.go</em>)</p>&#13;
<p>You start by initializing a server <span class="CodeAnnotation">1</span> that listens for incoming connections. It reads bytes from each connection, replies with the string <code>"pong"</code> when it receives the string <code>"ping</code>,<code>"</code> and echoes any other message it receives.</p>&#13;
<p><a href="#listing4-17" id="listinganchor4-17">Listing 4-17</a> continues the test implementation.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    // proxyServer proxies messages from client connections to the&#13;
    // destinationServer. Replies from the destinationServer are proxied&#13;
    // back to the clients.&#13;
    <span class="CodeAnnotationHang">1</span> proxyServer, err := net.Listen("tcp", "127.0.0.1:")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    wg.Add(1)&#13;
&#13;
    go func() {&#13;
        defer wg.Done()&#13;
&#13;
        for {&#13;
            conn, err := <span class="CodeAnnotation">2</span>proxyServer.Accept()&#13;
            if err != nil {&#13;
                return&#13;
            }&#13;
&#13;
            go func(from net.Conn) {&#13;
                defer from.Close()&#13;
&#13;
                to, err := <span class="CodeAnnotation">3</span>net.Dial("tcp",&#13;
                    server.Addr().String())&#13;
                if err != nil {&#13;
                    t.Error(err)&#13;
                    return&#13;
                }&#13;
&#13;
                defer to.Close()&#13;
&#13;
                err = <span class="CodeAnnotation">4</span>proxy(from, to)&#13;
                if err != nil &amp;&amp; err != io.EOF {&#13;
                    t.Error(err)&#13;
                }&#13;
            }(conn)&#13;
        }&#13;
    }()&#13;
&#13;
<var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-17">Listing 4-17</a>: Set up the proxy between the client and server (<em>proxy_test.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_92" title="92"/>You then set up a proxy server <span class="CodeAnnotation">1</span> that handles the message passing between the client and the destination server. The proxy server listens for incoming client connections. Once a client connection accepts <span class="CodeAnnotation">2</span>, the proxy establishes a connection to the destination server <span class="CodeAnnotation">3</span> and starts proxying messages <span class="CodeAnnotation">4</span>. Since the proxy server passes two <code>net.Conn</code> objects to <code>proxy</code>, and <code>net.Conn</code> implements the <code>io.ReadWriter</code> interface, the server proxies replies automatically. Then <code>io.Copy</code> writes to the <code>Write</code> method of the destination <code>net.Conn</code> everything it reads from the <code>Read</code> method of the origin <code>net.Conn</code>, and vice versa for replies from the destination to the origin.</p>&#13;
<p><a href="#listing4-18" id="listinganchor4-18">Listing 4-18</a> implements the client portion of the test.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    conn, err := net.Dial("tcp", proxyServer.Addr().String())&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    <span class="CodeAnnotationHang">1</span> msgs := []struct{ Message, Reply string }{&#13;
        {"ping", "pong"},&#13;
        {"pong", "pong"},&#13;
        {"echo", "echo"},&#13;
        {"ping", "pong"},&#13;
    }&#13;
&#13;
    for i, m := range msgs {&#13;
        _, err = conn.Write([]byte(m.Message))&#13;
        if err != nil {&#13;
            t.Fatal(err)&#13;
        }&#13;
&#13;
        buf := make([]byte, 1024)&#13;
&#13;
        n, err := conn.Read(buf)&#13;
        if err != nil {&#13;
            t.Fatal(err)&#13;
        }&#13;
&#13;
        actual := string(buf[:n])&#13;
        t.Logf("%q -&gt; proxy -&gt; %q", m.Message, actual)&#13;
&#13;
        if actual != m.Reply {&#13;
            t.Errorf("%d: expected reply: %q; actual: %q",&#13;
                i, m.Reply, actual)&#13;
        }&#13;
    }&#13;
&#13;
    _ = conn.Close()&#13;
    _ = proxyServer.Close()&#13;
    _ = server.Close()&#13;
&#13;
<span epub:type="pagebreak" id="Page_93" title="93"/>    wg.Wait()&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-18">Listing 4-18</a>: Proxying data from an upstream server to a downstream server (<em>proxy_test.go</em>)</p>&#13;
<p>You run the proxy through a series of tests <span class="CodeAnnotation">1</span> to verify that your ping messages result in pong replies and that the destination echoes anything else you send. The output should look like the following:</p>&#13;
<pre><code>$ <b>go test </b><span class="CodeAnnotation">1</span><b>-race -v proxy_test.go</b>&#13;
=== RUN   TestProxy&#13;
--- PASS: TestProxy (0.00s)&#13;
    proxy_test.go:138: "ping" -&gt; proxy -&gt; "pong"&#13;
    proxy_test.go:138: "pong" -&gt; proxy -&gt; "pong"&#13;
    proxy_test.go:138: "echo" -&gt; proxy -&gt; "echo"&#13;
    proxy_test.go:138: "ping" -&gt; proxy -&gt; "pong"&#13;
PASS&#13;
ok      command-line-arguments  1.018s</code></pre>&#13;
<p>I’m in the habit of running my tests with the <code>-race</code> flag <span class="CodeAnnotation">1</span> to enable the race detector. The race detector can help alert you to data races that need your attention. Although not necessary for this test, enabling it is a good habit.</p>&#13;
<h3 id="h2-500884c04-0006">Monitoring a Network Connection</h3>&#13;
<p class="BodyFirst">The <code>io</code> package includes useful tools that allow you to do more with network data than just send and receive it using connection objects. For example, you could use <code>io.MultiWriter</code> to write a single payload to multiple network connections. You could also use <code>io.TeeReader</code> to log data read from a network connection. <a href="#listing4-19" id="listinganchor4-19">Listing 4-19</a> gives an example of using the <code>io.TeeReader</code> and <code>io.MultiWriter</code> to log all network traffic on a TCP listener.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "io"&#13;
    "log"&#13;
    "net"&#13;
    "os"&#13;
)&#13;
&#13;
// Monitor embeds a log.Logger meant for logging network traffic.&#13;
type Monitor struct {&#13;
    *log.Logger&#13;
}&#13;
&#13;
// Write implements the io.Writer interface.&#13;
func (m *Monitor) <span class="CodeAnnotation">1</span>Write(p []byte) (int, error) {&#13;
    return len(p), m.Output(2, string(p))&#13;
}&#13;
<span epub:type="pagebreak" id="Page_94" title="94"/>&#13;
func ExampleMonitor() {&#13;
    <span class="CodeAnnotationHang">2</span> monitor := &amp;Monitor{Logger: log.New(os.Stdout, "monitor: ", 0)}&#13;
&#13;
    listener, err := net.Listen("tcp", "127.0.0.1:")&#13;
    if err != nil {&#13;
        monitor.Fatal(err)&#13;
    }&#13;
&#13;
    done := make(chan struct{})&#13;
&#13;
    go func() {&#13;
        defer close(done)&#13;
&#13;
        conn, err := listener.Accept()&#13;
        if err != nil {&#13;
            return&#13;
        }&#13;
        defer conn.Close()&#13;
&#13;
        b := make([]byte, 1024)&#13;
        <span class="CodeAnnotationHang">3</span> r := io.TeeReader(conn, monitor)&#13;
&#13;
        n, err := r.Read(b)&#13;
        if err != nil &amp;&amp; err != io.EOF {&#13;
            monitor.Println(err)&#13;
            return&#13;
        }&#13;
&#13;
        <span class="CodeAnnotationHang">4</span> w := io.MultiWriter(conn, monitor)&#13;
&#13;
        _, err = w.Write(b[:n]) // echo the message&#13;
        if err != nil &amp;&amp; err != io.EOF {&#13;
            monitor.Println(err)&#13;
            return&#13;
        }&#13;
    }()&#13;
&#13;
<var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-19">Listing 4-19</a>: Using <var>io.TeeReader</var> and <var>io.MultiWriter</var> to capture a network connection’s input and output (<em>monitor_test.go</em>)</p>&#13;
<p>You create a new struct named <code>Monitor</code> that embeds a <code>log.Logger</code> for the purposes of logging the server’s network traffic. Since the <code>io.TeeReader</code> and the <code>io.MultiWriter</code> expect an <code>io.Writer</code>, the monitor implements the <code>io.Writer</code> interface <span class="CodeAnnotation">1</span>.</p>&#13;
<p>You start by creating an instance of <code>Monitor</code><span class="CodeAnnotation">2</span> that writes to <code>os.Stdout</code>. You use the monitor in conjunction with the connection object in an <code>io.TeeReader</code><span class="CodeAnnotation">3</span>. This results in an <code>io.Reader</code> that will read from the network connection and write all input to the monitor before passing along the input to the caller. Likewise, you log server output by creating an <code>io.MultiWriter</code><span class="CodeAnnotation">4</span>, writing to the network connection and the monitor.</p>&#13;
<p><span epub:type="pagebreak" id="Page_95" title="95"/><a href="#listing4-20" id="listinganchor4-20">Listing 4-20</a> details the client portion of the example and its output.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
    conn, err := net.Dial("tcp", listener.Addr().String())&#13;
    if err != nil {&#13;
        monitor.Fatal(err)&#13;
    }&#13;
&#13;
    _, err = <span class="CodeAnnotation">1</span>conn.Write([]byte("Test\n"))&#13;
    if err != nil {&#13;
        monitor.Fatal(err)&#13;
    }&#13;
&#13;
    _ = conn.Close()&#13;
    &lt;-done&#13;
&#13;
    // <span class="CodeAnnotation">2</span>Output:&#13;
    // monitor: Test&#13;
    // monitor: Test&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-20">Listing 4-20</a>: The client implementation and example output (<em>monitor_test.go</em>)</p>&#13;
<p>When you send the message <code>Test\n</code><em> </em><span class="CodeAnnotation">1</span>, it’s logged to <code>os.Stdout</code> twice <span class="CodeAnnotation">2</span>: once when you read the message from the connection, and again when you echo the message back to the client. If you want to get fancy, you could decorate the log entries to differentiate between incoming and outgoing data. One way to do this would be to create an object that implements the <code>io.Writer</code> interface and embeds the monitor. When its <code>Write</code> method is called, it prepends the data with the prefix before passing the data along to the monitor’s <code>Write</code> method.</p>&#13;
<p>Although using the <code>io.TeeReader</code> and the <code>io.MultiWriter</code> in this fashion is powerful, it isn’t without a few caveats. First, both the <code>io.TeeReader</code> and the <code>io.MultiWriter</code> will block while writing to your writer. Your writer will add latency to the network connection, so be mindful not to block too long. Second, an error returned by your writer will cause the <code>io.TeeReader</code> or <code>io.MultiWriter</code> to return an error as well, halting the flow of network data. If you don’t want your use of these objects to potentially interrupt network data flow, I strongly recommend you implement a reader that always returns a <code>nil</code> error and logs its underlying error in a manner that’s actionable.</p>&#13;
<p>For example, you can modify <code>Monitor</code>’s <code>Write</code> method to always return a <code>nil</code> error:</p>&#13;
<pre><code>func (m *Monitor) Write(p []byte) (int, error) {&#13;
    err := m.Output(2, string(p))&#13;
    if err != nil {&#13;
        log.Println(err) // use the log package’s default Logger&#13;
    }&#13;
&#13;
    return len(p), nil&#13;
}</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_96" title="96"/>The <code>Monitor</code> attempts to write the byte slice to its embedded logger. Failing that, it writes the error to the <code>log</code> package’s default logger and returns a <code>nil</code> error to <code>io.TeeReader</code> and <code>io.MultiWriter</code> in <a href="#listing4-19">Listing 4-19</a> so as not to interrupt the flow of data.</p>&#13;
<h3 id="h2-500884c04-0007">Pinging a Host in ICMP-Filtered Environments</h3>&#13;
<p class="BodyFirst">In <span class="xref" itemid="xref_target_“The Internet Control Message Protocol” on page 31">“The Internet Control Message Protocol” on page 31</span>, you learned that ICMP is a protocol that gives you feedback about local network conditions. One of its most common uses is to determine whether a host is online by issuing a ping request and receiving a pong reply from the host. Most operating systems have a built-in <code>ping</code> command that sends an ICMP echo request to a destination IP address. Once the host responds with an ICMP echo reply, <code>ping</code> prints the duration between sending the ping and receiving the pong.</p>&#13;
<p>Unfortunately, many internet hosts filter or block ICMP echo replies. If a host filters <code>pongs</code>, the <code>ping</code> erroneously reports that the remote system is unavailable. One technique you can use instead is to establish a TCP connection with the remote host. If you know that the host listens for incoming TCP connections on a specific port, you can use this knowledge to confirm that the host is available, because you can establish a TCP connection only if the host is up and completes the handshake process.</p>&#13;
<p><a href="#listing4-21" id="listinganchor4-21">Listing 4-21</a> shows a small application that reports the time it takes to establish a TCP connection with a host on a specific port.</p>&#13;
<pre><code>package main&#13;
&#13;
import (&#13;
    "flag"&#13;
    "fmt"&#13;
    "net"&#13;
    "os"&#13;
    "time"&#13;
)&#13;
&#13;
<span class="CodeAnnotationHang">1</span> var (&#13;
    count    = flag.Int("c", 3, "number of pings: &lt;= 0 means forever")&#13;
    interval = flag.Duration("i", time.Second, "interval between pings")&#13;
    timeout  = flag.Duration("W", 5*time.Second, "time to wait for a reply")&#13;
)&#13;
&#13;
func init() {&#13;
    flag.Usage = func() {&#13;
        fmt.Printf("Usage: %s [options] host:port\nOptions:\n", os.Args[0])&#13;
        flag.PrintDefaults()&#13;
    }&#13;
}&#13;
&#13;
<var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-21">Listing 4-21</a>: The command line flags for the <var>ping</var> command (<em>ping.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_97" title="97"/>This example starts by defining a few command line options <span class="CodeAnnotation">1</span> that mimic a subset of the functionality provided by the <code>ping</code> command on Linux.</p>&#13;
<p><a href="#listing4-22" id="listinganchor4-22">Listing 4-22</a> adds the <code>main</code> function.</p>&#13;
<pre><code><var>--snip--</var>&#13;
&#13;
func main() {&#13;
    flag.Parse()&#13;
&#13;
    if flag.NArg() != 1 {&#13;
        fmt.Print("host:port is required\n\n")&#13;
        flag.Usage()&#13;
        os.Exit(1)&#13;
    }&#13;
&#13;
    target := flag.Arg(0)&#13;
    fmt.Println("PING", target)&#13;
&#13;
    if *count &lt;= 0 {&#13;
        fmt.Println("CTRL+C to stop.")&#13;
    }&#13;
&#13;
    msg := 0&#13;
&#13;
    for (*count &lt;= 0) || (msg &lt; *count) {&#13;
        msg++&#13;
        fmt.Print(msg, " ")&#13;
&#13;
        start := time.Now()&#13;
        <span class="CodeAnnotationHang">1</span> c, err := net.DialTimeout("tcp", target, *timeout)&#13;
        <span class="CodeAnnotationHang">2</span> dur := time.Since(start)&#13;
&#13;
        if err != nil {&#13;
            fmt.Printf("fail in %s: %v\n", dur, err)&#13;
            if nErr, ok := err.(net.Error); !ok || <span class="CodeAnnotation">3</span>!nErr.Temporary() {&#13;
                os.Exit(1)&#13;
            }&#13;
        } else {&#13;
            _ = c.Close()&#13;
            fmt.Println(dur)&#13;
        }&#13;
&#13;
        time.Sleep(*interval)&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-22">Listing 4-22</a>: Reporting the time to establish a TCP socket to a given host and port (<em>ping.go</em>)</p>&#13;
<p>You attempt to establish a connection to a remote host’s TCP port <span class="CodeAnnotation">1</span>, setting a reasonable time-out duration if the remote host doesn’t respond. You keep track of the time it takes to complete the TCP handshake and consider this duration <span class="CodeAnnotation">2</span> the ping interval between your host and the remote <span epub:type="pagebreak" id="Page_98" title="98"/>host. If you encounter a temporary error (for example, a time-out), you’ll continue trying, and you’ll exit if the error is permanent <span class="CodeAnnotation">3</span>. This is handy if you restart a TCP service and want to monitor its progress in restarting. Initially, the code in <a href="#listing4-22">Listing 4-22</a> will report time-out errors, but it will eventually start printing valid results when the service is again listening on the specific port.</p>&#13;
<p>It’s important to understand that system admins could consider the code in <a href="#listing4-22">Listing 4-22</a> abusive, especially if you specify a large ping count. That’s because you aren’t simply asking the remote host to send an echo reply using ICMP. Instead, you’re rapidly establishing and tearing down a TCP connection with every interval. Establishing a TCP connection has more overhead than an ICMP echo request and response. I recommend that you use this method only when intermediate firewalls filter ICMP echo messages and, even then, with the permission of the system admin.</p>&#13;
<h2 id="h1-500884c04-0004">Exploring Go’s TCPConn Object</h2>&#13;
<p class="BodyFirst">For most use cases, the <code>net.Conn</code> interface will provide adequate functionality and the best cross-platform support for TCP sessions between nodes. But accessing the underlying <code>net.TCPConn</code> object allows fine-grained control over the TCP network connection should you need to do such things as modify the read and write buffers, enable keepalive messages, or change the behavior of pending data upon closing the connection. The <code>net.TCPConn</code> object is the concrete object that implements the <code>net.Conn</code> interface. Keep in mind that not all the following functionality may be available on your target operating system.</p>&#13;
<p>The easiest way to retrieve the <code>net.TCPConn</code> object is by using a type assertion. This works for connections where the underlying network is TCP:</p>&#13;
<pre><code>tcpConn, ok := conn.(*net.TCPConn)</code></pre>&#13;
<p>On the server side, you can use the <code>AcceptTCP</code> method on a <code>net.TCPListener</code>, as shown in <a href="#listing4-23" id="listinganchor4-23">Listing 4-23</a>, to retrieve the <code>net.TCPConn</code> object.</p>&#13;
<pre><code>addr, err := net.ResolveTCPAddr("tcp", "127.0.0.1:")&#13;
if err != nil {&#13;
    return err&#13;
}&#13;
&#13;
listener, err := net.ListenTCP("tcp", addr)&#13;
if err != nil {&#13;
    return err&#13;
}&#13;
&#13;
tcpConn, err := listener.AcceptTCP()</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-23">Listing 4-23</a>: Retrieving <var>net.TCPConn</var> from the listener</p>&#13;
<p><span epub:type="pagebreak" id="Page_99" title="99"/>On the client side, use the <code>net.DialTCP</code> function, as shown in <a href="#listing4-24" id="listinganchor4-24">Listing 4-24</a>.</p>&#13;
<pre><code>addr, err := net.ResolveTCPAddr("tcp", "www.google.com:http")&#13;
if err != nil {&#13;
    return err&#13;
}&#13;
&#13;
tcpConn, err := net.DialTCP("tcp", nil, addr)</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-24">Listing 4-24</a>: Using <var>DialTCP</var> to retrieve a <var>net.TCPConn</var> object</p>&#13;
<p>The next few sections cover useful methods on <code>net.TCPConn</code> that are unavailable on <code>net.Conn</code>. Some of these methods may not be available on your target operating system or may have hard limits imposed by the operating system. My advice is to use the following methods only when necessary. Altering these settings on the connection object from the operating system defaults may lead to network behavior that’s difficult to debug. For example, shrinking the read buffer on a network connection may lead to unexpected zero window issues unexplained by checking the operating system’s default read buffer value.</p>&#13;
<h3 id="h2-500884c04-0008">Controlling Keepalive Messages</h3>&#13;
<p class="BodyFirst">A <em>keepalive</em> is a message sent over a network connection to check the connection’s integrity by prompting an acknowledgment of the message from the receiver. After an operating system–specified number of unacknowledged keepalive messages, the operating system will close the connection. </p>&#13;
<p>The operating system configuration dictates whether a connection uses keepalives for TCP sessions by default. If you need to enable keepalives on a <code>net.TCPConn</code> object, pass <code>true</code> to its <code>SetKeepAlive</code> method:</p>&#13;
<pre><code>err := tcpConn.SetKeepAlive(true)</code></pre>&#13;
<p>You also have control over how often the connection sends keepalive messages using the <code>SetKeepAlivePeriod</code> method. This method accepts a <code>time.Duration</code> that dictates the keepalive message interval:</p>&#13;
<pre><code>err := tcpConn.SetKeepAlivePeriod(time.Minute)</code></pre>&#13;
<p>Using deadlines advanced by a heartbeat is usually the better method for detecting network problems. As mentioned earlier in this chapter, deadlines provide better cross-platform support, traverse firewalls better, and make sure your application is actively managing the network connection.</p>&#13;
<h3 id="h2-500884c04-0009">Handling Pending Data on Close</h3>&#13;
<p class="BodyFirst">By default, if you’ve written data to <code>net.Conn</code> but the data has yet to be sent to or acknowledged by the receiver and you close the network connection, <span epub:type="pagebreak" id="Page_100" title="100"/>your operating system will complete the delivery in the background. If you don’t want this behavior, the <code>net.TCPConn</code> object’s <code>SetLinger</code> method allows you to tweak it: </p>&#13;
<pre><code>err := tcpConn.SetLinger(-1) // anything &lt; 0 uses the default behavior</code></pre>&#13;
<p>With the linger disabled, it is possible that the server may receive the last portion of data you send along with your FIN when you close your connection. Since your call to <code>conn.Close</code> doesn’t block, you have no way of knowing whether the server received the data you just sent prior to your FIN. It’s possible the data sat in the server’s receive buffer and then the server crashed, taking your unacknowledged data and FIN with it. Lingering on the connection to give the server time to acknowledge the data may seem tempting. But this won’t solve your problem if the server crashes, as in the example. Also, some developers may argue that using linger for this purpose is a code smell. Your application should instead verify that the server received all data before tearing down its connection if this last bit of unacknowledged data is a concern.</p>&#13;
<p>If you wish to abruptly discard all unsent data and ignore acknowledgments of sent data upon closing the network connection, set the connection’s linger to zero:</p>&#13;
<pre><code>err := tcpConn.SetLinger(0) // immediately discard unsent data on close</code></pre>&#13;
<p>Setting linger to zero will cause your connection to send an RST packet when your code calls your connection’s <code>Close</code> method, aborting the connection and bypassing the normal teardown procedures.</p>&#13;
<p>If you’re looking for a happy medium and your operating system supports it, you can pass a positive integer <em>n</em> to <code>SetLinger</code>. Your operating system will attempt to complete delivery of all outstanding data up to <em>n</em> seconds, after which point your operating system will discard any unsent or unacknowledged data:</p>&#13;
<pre><code>err := tcpConn.SetLinger(10) // discard unsent data after 10 seconds</code></pre>&#13;
<p>If you feel compelled to modify your connection’s linger value, please read up on how your operating system handles lingering on network connections. When in doubt, use the default value.</p>&#13;
<h3 id="h2-500884c04-0010">Overriding Default Receive and Send Buffers</h3>&#13;
<p class="BodyFirst">Your operating system assigns read and write buffers to each network connection you create in your code. For most cases, those values should be enough. But in the event you want greater control over the read or write buffer sizes, you can tweak their value, as demonstrated in <a href="#listing4-25" id="listinganchor4-25">Listing 4-25</a>.</p>&#13;
<pre><code>if err := tcpConn.SetReadBuffer(212992); err != nil {&#13;
    return err&#13;
}&#13;
&#13;
<span epub:type="pagebreak" id="Page_101" title="101"/>if err := tcpConn.SetWriteBuffer(212992); err != nil {&#13;
    return err&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-25">Listing 4-25</a>: Setting read and write buffer sizes on a TCP connection</p>&#13;
<p>The <code>SetReadBuffer</code> method accepts an integer representing the connection’s read buffer size in bytes. Likewise, the <code>SetWriteBuffer</code> method accepts an integer and sets the write buffer size in bytes on the connection. Keep in mind that you can’t exceed your operating system’s maximum value for either buffer size.</p>&#13;
<h2 id="h1-500884c04-0005">Solving Common Go TCP Network Problems</h2>&#13;
<p class="BodyFirst">Go doesn’t hold your hand when working with TCP network connections. As such, it’s possible to introduce bugs in your code that manifest as network errors. This section presents two common TCP networking issues: zero window errors and sockets stuck in the CLOSE_WAIT state.</p>&#13;
<h3 id="h2-500884c04-0011">Zero Window Errors</h3>&#13;
<p class="BodyFirst">We spent a bit of time in <span class="xref" itemid="xref_target_“Receive Buffers and Window Sizes” on page 48">“Receive Buffers and Window Sizes” on page 48</span> discussing TCP’s sliding window and how the window size tells the sender how much data the receiver can accept before the next acknowledgment. A common workflow when reading from a network connection is to read some data from the connection, handle the data, read more data from the connection, handle it, and so on. </p>&#13;
<p>But what happens if you don’t read data from a network connection quickly enough? Eventually, the sender may fill the receiver’s receive buffer, resulting in a zero-window state. The receiver will not be able to receive data until the application reads data from the buffer. This most often happens when the handling of data read from a network connection blocks and the code never makes its way around to reading from the socket again, as shown in <a href="#listing4-26" id="listinganchor4-26">Listing 4-26</a>.</p>&#13;
<pre><code>buf := make([]byte, 1024)&#13;
&#13;
for {&#13;
    <span class="CodeAnnotationHang">1</span> n, err := conn.Read(buf)&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
&#13;
    <span class="CodeAnnotationHang">2</span> handle(buf[:n]) // BLOCKS!&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-26">Listing 4-26</a>: Handling received data blocks preventing iteration around the loop</p>&#13;
<p>Reading data from the network connection <span class="CodeAnnotation">1</span> frees up receive buffer space. If the code blocks for an appreciable amount of time while handling the received data <span class="CodeAnnotation">2</span>, the receive buffer may fill up. A full receive buffer isn’t <span epub:type="pagebreak" id="Page_102" title="102"/>necessarily bad. Zeroing the window is a way to<em> throttle</em>, or slow, the flow of data from the sender by creating backpressure on the sender. But if it’s unintended or prolonged, a zero window may indicate a bug in your code.</p>&#13;
<h3 id="h2-500884c04-0012">Sockets Stuck in the CLOSE_WAIT State</h3>&#13;
<p class="BodyFirst">In <span class="xref" itemid="xref_target_“Gracefully Terminating TCP Sessions” on page 50">“Gracefully Terminating TCP Sessions” on page 50</span>, I mentioned that the server side of a TCP network connection will enter the CLOSE_WAIT state after it receives and acknowledges the FIN packet from the client. If you see TCP sockets on your server that persist in the CLOSE_WAIT state, it’s likely your code is neglecting to properly call the <code>Close</code> method on its network connections, as in <a href="#listing4-27" id="listinganchor4-27">Listing 4-27</a>.</p>&#13;
<pre><code>for {&#13;
    conn, err := listener.Accept()&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
&#13;
    <span class="CodeAnnotationHang">1</span> go func(c net.Conn) { // we never call c.Close() before returning!&#13;
        buf := make([]byte, 1024)&#13;
&#13;
        for {&#13;
            n, err := c.Read(buf)&#13;
            if err != nil {&#13;
               <span class="CodeAnnotation">2</span>  return&#13;
            }&#13;
&#13;
            handle(buf[:n])&#13;
        }&#13;
    }(conn)&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-27">Listing 4-27</a>: Returning from a connection-handling goroutine without properly closing the connection</p>&#13;
<p>The listener handles each connection in its own goroutine <span class="CodeAnnotation">1</span>. However, the goroutine fails to call the connection’s <code>Close</code> method before fully returning from the goroutine <span class="CodeAnnotation">2</span>. Even a temporary error will cause the goroutine to return. And because you never close the connection, this will leave the TCP socket in the CLOSE_WAIT state. If the server attempted to send anything other than a FIN packet to the client, the client would respond with an RST packet, abruptly tearing down the connection. The solution is to make sure to defer a call to the connection’s <code>Close</code> method soon after creating the goroutine <span class="CodeAnnotation">1</span>.</p>&#13;
<h2 id="h1-500884c04-0006">What You’ve Learned</h2>&#13;
<p class="BodyFirst">In this chapter, you first learned several methods of reading data from and writing data to a network connection, including the type-length-value encoding scheme. You built on this knowledge and learned an efficient way <span epub:type="pagebreak" id="Page_103" title="103"/>to proxy data between network connections. Next, you used a few <code>io</code> tools to monitor network traffic. Then, you used your knowledge of TCP handshakes to ping remote hosts in environments where ICMP echo requests and replies are filtered. Finally, the chapter wrapped up by covering the more platform-specific, yet powerful, methods provided by the <code>net.TCPConn</code> object and a few common connection-handling bugs.</p>&#13;
</section>&#13;
</body></html>