["```\nint cond1=1, cond2=1;\nwhile (cond1) {\n    cond1 = 0;\n    do {\n\n    } while(cond2);\n}\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#define MAXPROG 70000\n#define MAXMEM 30000\nint  p, r, q;\nint a[MAXMEM];\nchar f[MAXPROG], b, o, *s=f;\n\nvoid interpret(char *c) {\n    char *d;\n    r++;\n    while( *c ) {\n        switch(o=1,*c++) {\n        case '<': p--;        break;\n        case '>': p++;        break;\n        case '+': a[p]++;     break;\n        case '-': a[p]--;     break;\n        case '.': putchar(a[p]); fflush(stdout); break;\n        case ',': a[p]=getchar();fflush(stdout); break;\n        case '[':\n            for( b=1,d=c; b && *c; c++ )\n                b+=*c=='[', b-=*c==']';\n            if(!b) {\n                c[-1]=0;\n                while( a[p] )\n                 ➊ interpret(d);\n                c[-1]=']';\n                break;\n            }\n        case ']':\n            puts(\"UNBALANCED BRACKETS\"), exit(0);\n        case '#':\n            if(q>2)\n                printf(\"%2d %2d %2d %2d %2d %2d %2d %2d %2d %2d\\n%*s\\n\",\n                       *a,a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],\n                       3*p+2,\"^\");\n            break;\n        default: o=0;\n        }\n        if( p<0 || p>(MAXMEM-1))\n            puts(\"RANGE ERROR\"), exit(0);\n    }\n    r--;\n}\n\nint main(int argc,char *argv[]) {\n    FILE *z; q=argc;\n    if(z=fopen(argv[1],\"r\")) {\n        while( (b=getc(z))>0 )\n            *s++=b;\n        *s=0;\n        interpret(f);\n    }\n}\n```", "```\n> gcc bfi.c -o bfi\n```", "```\n> bfi examples/hello.b\nHello World!\n```", "```\n            MAXPROG = 70000\n            MAXMEM = 30000\n            prog = array('0:' MAXPROG)\n          ➊ mem = array('0:' MAXMEM, 0) jump = table()\n\n            define('parse(name)c,n,pat')      :(eparse)\nparse       pat = break('><+-.,[]')\n            input('reader', 10, 'B,1', name)\nparse_l0    c = reader                        :f(parse_l1)\n            c pat                             :f(parse_l0)\n            prog[n] = c \n            n = ne(n,MAXPROG) n + 1           :s(parse_l0)\nparse_l1    endfile(10)    \n            parse = n                         :(return)\neparse\n```", "```\n            define('closing(pc,plen)n,p')     :(eclosing)\nclosing     n = 1\n            p = pc\nclosing_l0  p = p + 1\n            eq(p,plen)                        :s(bad0)\n            ident(prog[p],']')                :s(closing_l1)\n            ident(prog[p],'[')                :s(closing_l2)\nclosing_l3  eq(n,0)                           :f(closing_l0)\n            closing = p                       :(return)\nclosing_l1  n = n - 1                         :(closing_l3)\nclosing_l2  n = n + 1                         :(closing_l3)\neclosing\n\n            define('buildtable(plen)n,m')     :(ebuildtable)\nbuildtable  n = 0\nbuild_l0    ident(prog[n],'[')                :s(build_l1)\nbuild_l2    n = n + 1\n            eq(n,plen)                        :f(build_l0)s(return)\nbuild_l1    m = closing(n,plen)\n            jump[m] = n\n            jump[n] = m                       :(build_l2)\nebuildtable\n```", "```\n       define('ord(c)v')         :(eord)\nord    &alphabet break(c) . v\n       ord = size(v)             :(return)\neord\n```", "```\n           plen = parse(host(2,2))\n           buildtable(plen)\n           input('cin', 10, 'B,1', '-')\n           output('cout', 11, 'WB,1', '-')\n           pc = 0\n           mp = 0\n           gmp = 0\n   loop    ident(prog[pc],'-')               :s(dec)\n           ident(prog[pc],'+')               :s(inc)\n           ident(prog[pc],'<')               :s(decp)\n           ident(prog[pc],'>')               :s(incp)\n           ident(prog[pc],',')               :s(gchar)\n           ident(prog[pc],'.')               :s(pchar)\n           ident(prog[pc],'[')               :s(begin)\n           ident(prog[pc],']')               :s(again)\n   cont    pc = pc + 1\n           ne(pc,plen)                       :f(pend)s(loop)\n   dec     mem[mp] = mem[mp] - 1             :s(cont)f(bad1)\n   inc     mem[mp] = mem[mp] + 1             :s(cont)f(bad1)\n   decp    mp = mp - 1                       :(cont)\n   incp    mp = mp + 1    \n           gmp = gt(mp,gmp) mp               :(cont)\n   gchar   ch = ord(cin)                     :f(pend)\n        ➊ eq(ch,13)                         :f(gchar0)\n           ch = 10\n           cout = char(ch)\n   gchar0  mem[mp] = ch                      :s(cont)f(bad1)\n   pchar   cout = char(mem[mp])              :s(cont)f(bad1)\n➋ begin   pc = eq(mem[mp],0) jump[pc]       :(cont)\n   again   pc = ne(mem[mp],0) jump[pc]       :(cont)\n```", "```\npc = eq(mem[mp],0) jump[pc]      :(cont)\n```", "```\ndec  mem[mp] = mem[mp] - 1   :s(cont)f(bad1)\n```", "```\nbad1  output = 'memory access error, mp = ' mp  :(end)\n```", "```\npend   ident(host(2,3),'dump')             :f(end)\n       output = output = 'Memory: (mp = ' mp ')'\n       n = 0\nploop  ascii = ''\n       gt(mem[n],31)                       :f(print)\n       lt(mem[n],127)                      :f(print)\n       ascii = '  ' char(mem[n])\nprint  s = dupl(' ', 6 - size(n)) n\n       s = s ':' dupl(' ', 6 - size(mem[n])) mem[n]\n       output = s ascii\n       n = n + 1\n       gt(n,gmp)                           :f(ploop)\n       output =                            :(end)\n```", "```\n> snobol4 bf.sno examples/hello.b dump\nHello World!\n\nMemory: (mp = 6)\n     0:     0\n     1:     0\n     2:    72  H\n     3:   100  d\n     4:    87  W\n     5:    33  !\n     6:    10\n```", "```\n+++++[-]\n```", "```\n,+[-.,+]\n```", "```\n> snobol4 bf.sno examples/cat.b <bf.sno\n```", "```\n,    read a character; mem(0) = ch\n+    inc mem(0)\n[    loop if mem(0) is not zero\n  -  dec mem(0)\n  .  print mem(0) as a character\n  ,  read another character to mem(0)\n  +  inc mem(0)\n]    loop if mem(0) is not zero\n```", "```\n,[.,]\n```", "```\n++++++++++[-.]\n```", "```\n> snobol4 bf.sno examples/countdown0.b | xxd\n00000000: 0908 0706 0504 0302 0100  ..........\n```", "```\n++++++++++    mem(0) = 10\n>             look at mem(1)\n++++++++++    mem(1) = 10\n[             enter loop if mem(1) not zero\n -            decrement mem(1)\n ++++++++++\n ++++++++++\n ++++++++++\n ++++++++++\n ++++++++     add 48\n .            print\n ----------\n ----------\n ----------\n ----------\n --------     sub 48\n <            look at mem(0)\n .            print it\n >            look at mem(1)\n]             loop if mem(1) is not zero\n```", "```\n++++++++[->,<]\n```", "```\ncell   :   0    1    2\nvalue  :   8  0|1    1\npointer:        ^\n```", "```\n++++++++[\n    ->          decrement mem(0); look at mem(1)\n    >+<,        look at mem(2); inc; mem(1); input\n    ----------\n    ----------\n    ----------\n    ----------\n    --------    sub 48\n    [->-<]      if one then dec mem(2)\n    >           look at mem(2)\n    ++++++++++\n    ++++++++++\n    ++++++++++\n    ++++++++++\n    ++++++++.   add 48; print\n    [-]<        zero mem(2); look at mem(1)\n    <           look at mem(0)\n]\n++++++++++.     mem(0) = 10; print newline\n```", "```\n> echo 00001101 | snobol4 bf.sno examples/ones.b dump\n11110010\n\nMemory: (mp = 0)\n     0:    10\n     1:     0\n     2:     0\n```", "```\n+++++++[       mem(0) = 7\n    >,.        mem(1) = input; echo\n    --------------------\n    --------------------\n    --------   sub 48\n    [          inner loop if bit is one\n        -      subtract the bit from mem(1)\n        >+     look at mem(2); increment mem(2)\n        <      look at mem(1)\n    ]          exit loop because mem(1) is zero\n    <-         look at mem(0); decrement mem(0)\n]              loop if mem(0) not zero\n```", "```\n>>             look at mem(2)\n[              loop if mem(2) not zero\n    [          if mem(2) not zero\n        -      subtract one\n        >      look at mem(3)\n        +      increment it\n        >      look at mem(4); which is zero\n    ]          do not loop\n ➊ <<         look back to mem(2)\n    [          if mem(2) not zero\n        -      subtract one\n        >      look at mem(3)\n        -      decrement\n        >      look at mem(4); which is zero\n    ]          do not loop\n    <<         look at mem(2) or mem(0) if sum exhausted\n]              loop if not zero\n```", "```\n>>>                   look at mem(3) or mem(5)\n++++++++++++++++++++\n++++++++++++++++++++\n++++++++.             add 48 and print\n>                     look at the next location which is zero\n++++++++++.           set to 10 and print the newline\n```", "```\n> echo 0000000 | bfi examples/parity.b \n00000000\n> echo 0000010 | bfi examples/parity.b\n00000101\n> echo 0011001 | bfi examples/parity.b\n00110011\n> echo 1111111 | bfi examples/parity.b\n11111111\n```", "```\n,--------------------\n--------------------     mem(0) = input\n--------                 sub 48\n>++++++++++++++++        mem(1) = 32 (space)\n++++++++++++++++.        print\n++++++++++.              add 10; print *\n----------.              sub 10; print space\n,--------------------    mem(1) = input\n--------------------\n--------                 sub 48\n```", "```\nans = 0\nfor i in range(5):\n    for j in range(4):\n        ans += 1\n```", "```\n<[-                 dec mem(0)\n    >[-             look at mem(1); dec\n        >+>+<<      inc mem(2); inc mem(3); look at mem(1)\n    ]               continue until mem(1) is zero >[-<+>]         look at mem(2); copy back to mem(1)\n    <<              look at mem(0)\n]                   loop until mem(0) is zero\n```", "```\ncell   :   0    1    2    3\nvalue  :   4    0    4    4\npointer:        ^\n```", "```\n> snobol4 bf.sno examples/mult.b dump\n3 * 5\n\nMemory: (mp = 0)\n     0:    10\n     1:     5\n     2:     0\n     3:    15\n\n> snobol4 bf.sno examples/mult.b dump\n9 * 8 Memory: (mp = 0)\n     0:    10\n     1:     8\n     2:     0\n     3:    72  H\n```", "```\n>>>                                    move to mem(3)\n>[-]>[-]+>[-]+<                        set n and d to one to start loop\n[                                      loop on 'n'\n    >[-<-                              on the first loop\n        <<[->+>+<<]                    copy V into N (and Z)\n        >[-<+>]>>                      restore V from Z\n    ]\n    ++++++++++>[-]+>[-]>[-]>[-]<<<<<   init for the division by 10\n    [->-[>+>>]>[[-<+>]+>+>>]<<<<<]     full division\n    >>-[-<<+>>]                        store remainder into n\n    <[-]++++++++[-<++++++>]            make it an ASCII digit; clear d\n    >>[-<<+>>]                         move quotient into d\n    <<                                 shuffle; new n is where d was and\n                                         old n is a digit\n    ]                                  end loop when n is zero\n<[.[-]<]                               move to where Z should be and\n                                         output the digits til we find Z\n<                                      back to V\n<++++++++++.                           newline\n```", "```\n> snobol4 bf.sno examples/mult2.b\n3 * 5 = 15\n> snobol4 bf.sno examples/mult2.b\n9 * 8 = 72\n```"]