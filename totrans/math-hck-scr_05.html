<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2-h" id="ch05"><span class="color2"><strong>5</strong></span></h2>&#13;
<h2 class="h2-hd"><span epub:type="pagebreak" id="page_79"/><strong>From Sequences to Arrays</strong></h2>&#13;
<div class="imagec"><img src="../images/common.jpg" alt="Image" width="167" height="189"/></div>&#13;
<p class="noindent">When you ask, “What value comes next?” you’re making an assumption that the values are arranged in one dimension, along a line. One value follows another in a sequence, such that there’s only one way to step from one item to the next. But we live in a world with more than one dimension, and it’s sometimes helpful to use more than one dimension to organize information.</p>&#13;
<p class="indent">For example, an <em>array</em> is a two-dimensional object, a table of values organized in rows and columns. We can still look for patterns in an array of numbers, but now the patterns might show up as we move from row to row, from column to column, or along diagonals. In this chapter, we’ll use Scratch to study some interesting arrays. While Scratch makes it easy to explore one-dimensional sequences with its <code>list</code> data type, it doesn’t have a similar structure for two-dimensional arrays. We’ll have to develop some creative workarounds to represent arrays in Scratch.</p>&#13;
<h3 class="h3" id="ch05lev1"><span epub:type="pagebreak" id="page_80"/>Pascal’s Triangle</h3>&#13;
<p class="noindent"><em>Pascal’s triangle</em> is a two-dimensional array of numbers, rather than a linear sequence. Just as a sequence has entries indexed by the positive integers, entries in Pascal’s triangle are specified by giving two index numbers, corresponding to the row and column numbers for a particular entry. In this case, it’s best to think of the index numbers as starting from 0 rather than 1.</p>&#13;
<p class="indent">The row numbers in Pascal’s triangle are represented with the letter <em>n</em>. For the first row, <em>n</em> = 0, for the second row, <em>n</em> = 1, and so on. Within each row, columns are represented with the letter <em>k</em>, beginning with <em>k</em> = 0 and continuing up to <em>k</em> = <em>n</em>. So the <em>n</em>th row always has <em>n</em> + 1 entries: row 0 has one entry, row 1 has two entries, and so on. Centering the rows when we write them out makes it easy to see how the array expands from one row to the next, giving Pascal’s triangle its distinctive shape:</p>&#13;
<div class="imagec"><img src="../images/pg100_Image_111.jpg" alt="Image" width="443" height="287"/></div>&#13;
<p class="indent">The values of each entry can be determined by adding the two entries immediately above it. For example, the 2 in row <em>n</em> = 2 (the third row from the top) is the sum of the two 1s in the row above it, and each 10 in row <em>n</em> = 5 (the bottom row shown here) is the sum of the 4 and 6 above it. The entries at the edges of the rows, which don’t have two entries above them, are all given a value of 1.</p>&#13;
<h4 class="h4o" id="ch05lev2">Working with Binomials</h4>&#13;
<p class="noindent">Now you know where the values in Pascal’s triangle come from, but what do they mean? They relate to the <em>binomial theorem</em>. This algebraic rule makes it easier to work out the positive integer powers of <em>binomials</em>, expressions that are a sum of two terms. Taking 1 + <em>x</em> as an example binomial, the binomial theorem helps us calculate the value of (1 + <em>x</em>)<sup>0</sup>, (1 + <em>x</em>)<sup>1</sup>, (1 + <em>x</em>)<sup>2</sup>, (1 + <em>x</em>)<sup>3</sup>, and so on. Expanding each of these powers, we get the following:</p>&#13;
<div class="imagec"><img src="../images/pg100_Image_112.jpg" alt="Image" width="473" height="310"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_81"/>Look familiar? The coefficients (the constant multipliers of powers of <em>x</em>) in these expansions are the same as the values in Pascal’s triangle. The 1 in the first row of the triangle (row <em>n</em> = 0) corresponds to (1 + <em>x</em>)<sup>0</sup> = 1. The two 1s in the second row (<em>n</em> = 1) correspond to (1 + <em>x</em>)<sup>1</sup> = 1 + <em>x</em>. (Imagine an invisible 1 in front of the <em>x</em>.) The 1, 2, and 1 in the third row (<em>n</em> = 2) correspond to (1 + <em>x</em>)<sup>2</sup> = 1 + 2<em>x</em> + <em>x</em><sup>2</sup>, and so on.</p>&#13;
<p class="indent">In general, the <em>n</em>th row of Pascal’s triangle shows the coefficients for the <em>n</em>th power of a binomial—that is, (1 + <em>x</em>)<sup><em>n</em></sup>. What’s more, the <em>k</em>th entry in that row holds the coefficient of <em>x</em><sup><em>k</em></sup> in the binomial’s expansion. To see that, it helps to recognize that an expression such as 1 + 2<em>x</em> + <em>x</em><sup>2</sup> is equivalent to the expression 1<em>x</em><sup>0</sup> + 2<em>x</em><sup>1</sup> + 1<em>x</em><sup>2</sup> and to notice how the exponents of <em>x</em> count up from 0 to <em>n</em>.</p>&#13;
<p class="indent">Since the values in Pascal’s triangle represent the coefficients in binomial expansions, they’re known as <em>binomial coefficients</em>. Any given binomial coefficient can be written as <em>C</em>(<em>n</em>, <em>k</em>), where again <em>n</em> and <em>k</em> are the row and column numbers in Pascal’s triangle. So we can write Pascal’s triangle symbolically like this:</p>&#13;
<div class="imagec"><img src="../images/pg101_Image_113.jpg" alt="Image" width="605" height="287"/></div>&#13;
<p class="indent">We’ve represented Pascal’s triangle as a triangular array. But if you look at the pattern of index numbers, it makes just as much sense to see it as a square array, with the upper-right portion of the square either left off or filled with 0s, as shown here:</p>&#13;
<div class="imagec"><img src="../images/pg101_Image_114.jpg" alt="Image" width="628" height="287"/></div>&#13;
<p class="indent">We could find values for <em>C</em>(<em>n</em>, <em>k</em>) by algebra, multiplying out the polynomials (1 + <em>x</em>)<sup><em>n</em></sup> to see what the coefficients turn out to be. (I’ve already done some of that for you, showing you the values up to <em>n</em> = 5.) But that would be a lot of work. To get a more general formula for <em>C</em>(<em>n</em>, <em>k</em>), it helps to interpret the algebra by thinking about a related counting problem.</p>&#13;
<h4 class="h4o" id="ch05lev3"><span epub:type="pagebreak" id="page_82"/>Making Subsets from Sets</h4>&#13;
<p class="noindent">Suppose you have five friends (Albert, Barb, Charley, Deb, and Eve), and you can invite only three of them to come over for pizza. How many different sets of three people could you invite? Let ABC be <em>Albert, Barb, Charley</em>, the first possibility. BAC is the same set of people in a different order, so this shouldn’t really count as different; you’ll still have the same guests at your pizza party. ABD is a different set, though, and so is ABE. You can keep going, one subset at a time, and eventually list 10 different pizza party sets, maybe ending with CDE.</p>&#13;
<p class="indent">How can you confirm that number is correct? Let’s see if we can formulate a general rule. Suppose you have a set with <em>n</em> objects in it (all your friends), and you want to build a subset with <em>k</em> objects in it (the party guests), for some integer <em>k</em> where 0 ≤ <em>k</em> ≤ <em>n</em>. In our example, <em>n</em> = 5 and <em>k</em> = 3. First, think about the situation where the order of the elements selected for the subset <em>does</em> matter. In that case, the first element can be any of the <em>n</em> elements in the set. The second element can be any of the <em>n</em> – 1 elements left over after the first one is chosen, the third element can be any of the remaining <em>n</em> – 2 elements, and so on, until we arrive at the <em>k</em>th element, which can be chosen only in <em>n</em> – (<em>k</em> – 1) = <em>n</em> – <em>k</em> + 1 ways. In our example, we pick any of our five friends (A through E) for the first choice, then any of the four left after that for the second choice, and then any of the three remaining people for the third choice.</p>&#13;
<p class="indent">Multiplying the number of available choices for each spot gives us the total number of possible combinations. In the case of <em>k</em> = 3 spots for <em>n</em> = 5 friends, there are 5 ⋅ 4 ⋅ 3 = 60 possibilities. In general, the formula for the number of possible combinations is:</p>&#13;
<div class="imagec"><img src="../images/pg102_Image_115.jpg" alt="Image" width="388" height="21"/></div>&#13;
<p class="indent">In our example, though, the order of the elements selected for the subset doesn’t matter, so we have to deal with the fact that different orderings of the <em>k</em> choices can lead to the same subset (like the ABC and BAC orderings mentioned earlier). How can we figure out how many different ways there are to order a subset of <em>k</em> elements? We can apply the same logic we just used for <em>n</em> to find out: there are <em>k</em> possibilities for what the first element could be, then <em>k</em> – 1 possibilities for the second element, and so on. So the total number of orderings is:</p>&#13;
<div class="imagec"><img src="../images/pg102_Image_116.jpg" alt="Image" width="343" height="21"/></div>&#13;
<p class="indent">For <em>k</em> = 3, for example, there are 3 ⋅ 2 ⋅ 1 = 6 ways to order a particular set of three elements. This means that if we want to count only the unique subsets, ignoring rearrangements, we should count only one out of every six of the total number of combinations. That is, if there are 5 ⋅ 4 ⋅ 3 ways to pick three elements from a group of five, and there are 3 ⋅ 2 ⋅ 1 ways to order those three elements, there are (5 ⋅ 4 ⋅ 3) / (3 ⋅ 2 ⋅ 1) = 60 / 6 = 10 unique subsets, ignoring order. The general formula is:</p>&#13;
<div class="imagec"><img src="../images/pg102_Image_117.jpg" alt="Image" width="390" height="59"/></div>&#13;
<p class="indent">Notice that we’ve been using the same variables here that we were using to identify the rows and columns in Pascal’s triangle: <em>n</em> and <em>k</em>. That’s because the two <span epub:type="pagebreak" id="page_83"/>problems are related. The formula to calculate a particular term <em>C</em>(<em>n</em>, <em>k</em>) in Pascal’s triangle—and, by extension, the formula to determine a particular binomial coefficient—is the same one we just worked out:</p>&#13;
<div class="imagec"><img src="../images/pg103_Image_118.jpg" alt="Image" width="502" height="59"/></div>&#13;
<p class="indent">There’s a special sequence, the <em>factorial numbers</em>, that lets us write the formula for <em>C</em>(<em>n</em>, <em>k</em>) in a neater way. If <em>n</em> is a positive integer, <em>n</em> factorial (written as <em>n</em>!) is the product of every integer from 1 to <em>n</em>. For example, 3! is 1 ⋅ 2 ⋅ 3 = 6, and 5! is 1 ⋅ 2 ⋅ 3 ⋅ 4 ⋅ 5 = 120. More formally:</p>&#13;
<div class="imagec"><img src="../images/pg103_Image_119.jpg" alt="Image" width="371" height="21"/></div>&#13;
<p class="indent">Looking at the sequences of terms in the formula for <em>C</em>(<em>n</em>, <em>k</em>), it’s clear there’s some kind of factorial logic involved. With a bit of algebra, we can simplify the formula to make factorial notation apply:</p>&#13;
<div class="imagec"><img src="../images/pg103_Image_120.jpg" alt="Image" width="217" height="59"/></div>&#13;
<p class="noindent">Calculating factorials manually gets tedious as <em>n</em> and <em>k</em> get bigger. With Scratch Cat’s help, however, it’s a breeze.</p>&#13;
<h4 class="h4" id="ch05lev4">Project 18: Pick a Number from Pascal’s Triangle</h4>&#13;
<p class="noindent">In this project, we’ll use the factorial definition we just arrived at for <em>C</em>(<em>n</em>, <em>k</em>) to make Scratch calculate the binomial coefficient for any given values of <em>n</em> and <em>k</em>. Put another way, we’ll write a program that calculates the entry at the <em>n</em>th row and <em>k</em>th column of Pascal’s triangle. <a href="ch05.xhtml#ch5fig1">Figure 5-1</a> shows how.</p>&#13;
<div class="image"><img id="ch5fig1" src="../images/pg103_Image_121.jpg" alt="Image" width="865" height="593"/></div>&#13;
<p class="figcap"><em>Figure 5-1: Calculating binomial coefficients with factorials</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_84"/>The main program is the shortest one in this book: it’s just one line, to call the custom block that calculates the binomial coefficient for a given <code>n</code> and <code>k</code>. That block, in turn, calls the <code>factorial</code> calculator block, which takes in a value and calculates its factorial, using a loop to multiply all the numbers from 1 up to that value. The result is held in the <code>product</code> variable, which we set to <code>1</code> at the start of the block.</p>&#13;
<p class="indent">We use the <code>factorial</code> block three times to calculate <code>n</code> factorial, <code>k</code> factorial, and <code>n - k</code> factorial, storing the resulting values of <code>product</code> in the variables <code>x</code>, <code>y</code>, and <code>z</code>. Then, we calculate <code>x / y * z</code> to get the binomial coefficient <span class="ent">❶</span>. This is the equivalent of our formula:</p>&#13;
<div class="imagec"><img src="../images/pg104_Image_122.jpg" alt="Image" width="217" height="59"/></div>&#13;
<p class="indent">This program uses sliders to set the <code>n</code> and <code>k</code> inputs. Sliders are more efficient at receiving input than the <code>ask and wait</code> block in previous projects, and they let us automatically limit the input values to only integers within a certain range, sparing us from having to screen for inappropriate inputs like negative integers, strings, or numbers with decimals. To create a slider for a variable, right-click the variable on the stage and choose <strong>slider</strong> from the drop-down menu, as in <a href="ch05.xhtml#ch5fig2">Figure 5-2</a>.</p>&#13;
<div class="image"><img id="ch5fig2" src="../images/pg104_Image_123.jpg" alt="Image" width="587" height="311"/></div>&#13;
<p class="figcap"><em>Figure 5-2: Using sliders to calculate</em> C<em>(5, 3) = 10</em></p>&#13;
<p class="indent">Dragging the slider’s circle to the left or right changes the associated variable’s value over a range you can specify using the change slider range option from the drop-down menu. I set the slider ranges to be 1 to 50 for <em>n</em> and 0 to 50 for <em>k</em>, but as we’ll discuss, even those ranges might cause trouble for some of the binomial coefficients we calculate.</p>&#13;
<p class="indent">To use the program, set the sliders to your chosen <em>n</em> and <em>k</em> values, then click the green flag to see the resulting binomial coefficient.</p>&#13;
<h5 class="h5" id="ch05lev5">Hacking the Code</h5>&#13;
<p class="noindent">There’s a problem with this program. I set up the pizza party counting scenario with the assumption that <em>k</em> (the number of guests allowed) is less than or equal to <em>n</em> (the total number of people to choose from). But while the sliders limit <em>n</em> and <em>k</em> to integers, there’s nothing stopping us from making <em>k</em> greater than <em>n</em>.</p>&#13;
<p class="indent">If we set the sliders this way, when it comes time to calculate (<em>n</em> – <em>k</em>)!, we’ll end up passing the <code>factorial</code> block a negative number. A <code>repeat</code> loop can’t repeat a negative number of times, so the loop will exit before the first pass and <code>product</code> will be stuck with its initial value of <code>1</code>. This breaks the formula and reports a weird result, as shown in <a href="ch05.xhtml#ch5fig3">Figure 5-3</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_85"/><img id="ch5fig3" src="../images/pg105_Image_124.jpg" alt="Image" width="467" height="132"/></div>&#13;
<p class="figcap"><em>Figure 5-3:</em> C<em>(5, 6) = ???</em></p>&#13;
<p class="indent">The fix is pretty easy: just put a test into the main program to check for <em>k</em> &gt; <em>n</em> and notify the user that the inputs are invalid if this condition is met, as shown in <a href="ch05.xhtml#ch5fig4">Figure 5-4</a>.</p>&#13;
<div class="image"><img id="ch5fig4" src="../images/pg105_Image_125.jpg" alt="Image" width="338" height="337"/></div>&#13;
<p class="figcap"><em>Figure 5-4: Adding a check for</em> k <em>&gt;</em> n</p>&#13;
<p class="indent">Notice that we’re using a variable called <code>C(n, k)</code> <span class="ent">❶</span>, while also using a custom block called <code>C</code> with <code>n</code> and <code>k</code> inputs <span class="ent">➋</span> to calculate a value to assign to that variable. Scratch’s color coding and block shapes help us keep track of which <code>C(n, k)</code> is which.</p>&#13;
<p class="indent">Another problem with this program is that factorials get big quickly: 18! is the largest factorial Scratch can reliably calculate before reaching flintmax. In practice, since <em>n</em>! is always divisible by various powers of 2, the reported value remains correct for a while even after exceeding flintmax, but by the time we get to 171! we’ve exceeded the overall maximum of the IEEE 754 floating-point standard. At that point, Scratch gives up, reporting values involving calculations of 171! or larger as <code>Infinity</code> (see <a href="ch05.xhtml#ch5fig5">Figure 5-5</a>).</p>&#13;
<div class="image"><img id="ch5fig5" src="../images/pg105_Image_126.jpg" alt="Image" width="449" height="126"/></div>&#13;
<p class="figcap"><em>Figure 5-5:</em> C<em>(171, 18) = ???</em></p>&#13;
<p class="indent">Even for smaller values, the rounding in IEEE 754 for integers larger than flintmax can spoil the results and yield a non-integer value, as shown in <a href="ch05.xhtml#ch5fig6">Figure 5-6</a>.</p>&#13;
<div class="image"><img id="ch5fig6" src="../images/pg105_Image_127.jpg" alt="Image" width="452" height="127"/></div>&#13;
<p class="figcap"><em>Figure 5-6:</em> C<em>(49, 23) = ???</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_86"/>In fairness, the true value of <em>C</em>(49, 23) is 58,343,356,817,424, so Scratch is pretty close, but “pretty close” isn’t good enough. To enable Scratch to keep finding the exact binomial coefficients for bigger values of <em>n</em> and <em>k</em>, we need to take a different approach, one that doesn’t involve working with factorials. For this, we can take advantage of the fact that even though the factorials in the formula for <em>C</em>(<em>n</em>, <em>k</em>) quickly get large, the binomial coefficients themselves don’t grow so big so fast. So if we can calculate the binomial coefficients without first calculating any factorials, we’ll be able to get a lot further before hitting flintmax.</p>&#13;
<h3 class="h3" id="ch05lev6">Pascal’s Recurrence</h3>&#13;
<p class="noindent">The value at row <em>n</em> and column <em>k</em> of Pascal’s triangle is the binomial coefficient <em>C</em>(<em>n</em>, <em>k</em>). If we can find a recurrence for Pascal’s triangle—a rule for generating the next value in the array based on the previous values—we’ll be able to calculate binomial coefficients without any need for factorials.</p>&#13;
<p class="indent">With arrays, we have lots of flexibility in deciding which previous elements should be used to specify the recurrence. “Previous element” here can mean a value in an earlier row or an earlier value in the same row. I hinted at a recurrence for Pascal’s triangle in the initial description: each value is the sum of the two adjacent values immediately above it. Here’s how to write that as a recurrence:</p>&#13;
<div class="imagec"><img src="../images/pg106_Image_128.jpg" alt="Image" width="399" height="23"/></div>&#13;
<p class="indent">To see why this works, we can interpret each value <em>C</em>(<em>n</em>, <em>k</em>) in Pascal’s triangle as the answer to a subset counting problem. Instead of thinking about guests at a pizza party, let’s think about counting how many ways there are to pick a set of <em>k</em> of the (1 + <em>x</em>) factors among all of the <em>n</em> factors in (1 + <em>x</em>)<sup><em>n</em></sup>. Every way of picking <em>k</em> factors adds another <em>x</em><sup><em>k</em></sup> to the total.</p>&#13;
<p class="indent">For example, suppose we want to expand (1 + <em>x</em>)<sup>4</sup> and see what the coefficient should be for <em>x</em><sup>3</sup>. That would be the binomial coefficient <em>C</em>(4, 3). When we multiply out (1 + <em>x</em>)(1 + <em>x</em>)(1 + <em>x</em>)(1 + <em>x</em>), in each factor of (1 + <em>x</em>) we can pick either the 1 or the <em>x</em> to multiply. To get a term of <em>x</em><sup>3</sup>, we need to pick 1 once and <em>x</em> three times. We could pick the first factor’s 1, or the second factor’s 1, or the third factor’s 1, or the last factor’s 1, so there are four ways that we could get <em>x</em><sup>3</sup>. That makes <em>C</em>(4, 3) = 4.</p>&#13;
<p class="indent">Now consider only <em>n</em> – 1 repeated (1 + <em>x</em>) factors. The binomial coefficients for (1 + <em>x</em>)<sup><em>n</em> – 1</sup> are listed in row <em>n</em> – 1 of Pascal’s triangle. If we want go to from row <em>n</em> – 1 to row <em>n</em>, we have to multiply by one extra factor of (1 + <em>x</em>). Again, we need to pick either the 1 or the <em>x</em> for the multiplication. There are two possibilities: either we already have <em>k</em> occurrences of <em>x</em> when we pick factors in (1 – <em>x</em>)<sup><em>k</em> – 1</sup>, in which case we multiply by the 1 of the extra factor, or we have <em>k</em> – 1 occurrences of <em>x</em>, in which case we multiply by the <em>x</em> of the extra factor to get <em>k</em> occurrences. That accounting gives the recurrence I just mentioned, which we can use to build the triangle row by row:</p>&#13;
<div class="imagec"><img src="../images/pg106_Image_129.jpg" alt="Image" width="399" height="22"/></div>&#13;
<p class="noindent">Again, all this means is that to get an entry in Pascal’s triangle, we just need to add the two numbers above it.</p>&#13;
<p class="indent">This recurrence helps us make sense of the value 4 that we calculated for <em>C</em>(4, 3). First, we step back a row in the triangle, from row 4 to row 3, to the coefficients <span epub:type="pagebreak" id="page_87"/>for the expansion of (1 + <em>x</em>)<sup>3</sup>. We can then either take the <em>x</em><sup>2</sup> terms in that row that are counted by <em>C</em>(3, 2) and multiply them by <em>x</em>, or take the <em>x</em><sup>3</sup> terms there that are counted by <em>C</em>(3, 3) and multiply them by 1. Those are the only ways to build an <em>x</em><sup>3</sup> term in row 4. That means <em>C</em>(3, 2) + <em>C</em>(3, 3) = <em>C</em>(4, 3).</p>&#13;
<h4 class="h4" id="ch05lev7">Project 19: Pascal’s Triangle, Row by Row</h4>&#13;
<p class="noindent"><a href="ch05.xhtml#ch5fig7">Figure 5-7</a> shows a Scratch program to calculate up to the <em>n</em>th row of Pascal’s triangle using the recurrence we just discussed.</p>&#13;
<div class="image"><img id="ch5fig7" src="../images/pg107_Image_130.jpg" alt="Image" width="892" height="1073"/></div>&#13;
<p class="figcap"><em>Figure 5-7: Calculating Pascal’s triangle, row by row</em></p>&#13;
<p class="indent">First, we ask which row to calculate <span class="ent">❶</span>. Then, we loop that many times to work through all the rows up to that one. We use two lists to keep track of the values: <code>row</code> <span epub:type="pagebreak" id="page_88"/>is the previous row in the array, and <code>newrow</code> is the current row being calculated. We start each new row with a <code>1</code> <span class="ent">➋</span>, then add each adjacent pair of values from <code>row</code> to get the next value in <code>newrow</code> <span class="ent">➌</span>, as specified by our recurrence. At the end of each cycle through the loop, the custom <code>copy newrow to row</code> block copies <code>newrow</code> back to <code>row</code> to get ready for the next iteration.</p>&#13;
<h5 class="h5" id="ch05lev8">The Results</h5>&#13;
<p class="noindent"><a href="ch05.xhtml#ch5fig8">Figure 5-8</a> shows a sample run of the program, for <em>n</em> = 8.</p>&#13;
<div class="image"><img id="ch5fig8" src="../images/pg108_Image_131.jpg" alt="Image" width="446" height="538"/></div>&#13;
<p class="figcap"><em>Figure 5-8: Row 8 of Pascal’s triangle</em></p>&#13;
<p class="indent">Notice that, since Scratch lists are indexed starting with 1 rather than 0, the first element, <em>C</em>(8, 0) = 1, isn’t listed in the output. It <em>was</em> calculated, but we deleted it from the list at the end of the program <span class="ent">➍</span>. This way, Scratch’s index numbers match the values of <em>k</em> for the given row. Just imagine that there’s an extra 1 at the start of the list, at index 0.</p>&#13;
<p class="indent">With this approach, we can go much further with calculating exact binomial coefficients. In fact, we don’t exceed flintmax until we get to row <em>n</em> = 56 of Pascal’s triangle. There, the value for <em>k</em> = 25 is off (but <em>k</em> = 26, 27, and 28 are reported correctly). We also don’t have any binomial coefficients reported as <code>Infinity</code> until we get past row 1,000.</p>&#13;
<h4 class="h4" id="ch05lev9">Project 20: Drawing Pascal’s Triangle</h4>&#13;
<p class="noindent">One way to understand Pascal’s triangle is to think about how the values of the binomial coefficients are distributed in each row. For example, we can observe that the values are symmetric around the center of the row: 1-2-1, 1-3-3-1, 1-4-6-4-1, and so on.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_89"/>Mathematically, we can express each row’s symmetry by noting that the value at column <em>k</em> in row <em>n</em> is the same as the value at column <em>n</em> – k in the same row. In other words, <em>C</em>(<em>n</em>, <em>k</em>) = <em>C</em>(<em>n</em>, <em>n</em> – <em>k</em>). We can verify this observation by thinking about the subset counting interpretation of Pascal’s triangle, discussed earlier in this chapter. To create a subset of <em>k</em> out of <em>n</em> elements, we can say either which <em>k</em> elements should be included or which <em>n</em> – <em>k</em> elements should <em>not</em> be included.</p>&#13;
<p class="indent">Another interesting observation is that the sum of the binomial coefficients in the <em>n</em>th row of Pascal’s triangle is 2<sup><em>n</em></sup>. In row <em>n</em> = 3, for example, 1 + 3 + 3 + 1 = 8, or 2<sup>3</sup>, and in row <em>n</em> = 4, 1 + 4 + 6 + 4 + 1 = 16, or 2<sup>4</sup>. This also connects with the subset counting interpretation: there are a total of 2<sup><em>n</em></sup> subsets of a set with <em>n</em> elements because for each of the <em>n</em> elements, there’s a choice of two possibilities: to include that element in a subset or not.</p>&#13;
<p class="indent">One more feature worth noting is that the values in each row are <em>unimodal</em>, meaning they start small, increase toward a largest value in the middle, and then get small again. We can make observations like these by looking at the numbers themselves, but features like the values’ symmetry and their unimodal structure are even easier to spot if we visualize rows of Pascal’s triangle as bar graphs. Also called a <em>histogram</em>, a <em>bar graph</em> is a chart where the value of each entry is represented by the height of a bar. For example, <a href="ch05.xhtml#ch5fig9">Figure 5-9</a> shows a bar graph representing the values in row <em>n</em> = 10 of Pascal’s triangle. Notice the symmetry of the bar heights.</p>&#13;
<div class="image"><img id="ch5fig9" src="../images/pg109_Image_132.jpg" alt="Image" width="492" height="397"/></div>&#13;
<p class="figcap"><em>Figure 5-9: Row 10 of Pascal’s triangle</em></p>&#13;
<p class="indent">To draw bar graphs like these, start with the program in <a href="ch05.xhtml#ch05lev7">Project 19</a> (<a href="ch05.xhtml#ch5fig7">Figure 5-7</a>) for calculating a row of Pascal’s triangle. Then, add the custom <code>draw histogram</code> block shown in <a href="ch05.xhtml#ch5fig10">Figure 5-10</a>. It uses blocks from the Pen extension to draw a bar for each value in the row. Be sure to insert this custom block <em>before</em> you delete the <code>1</code> at the start of the row (<a href="ch05.xhtml#ch5fig7">Figure 5-7</a> <span class="ent">➍</span>), or the symmetry will be spoiled.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_90"/><img id="ch5fig10" src="../images/pg110_Image_133.jpg" alt="Image" width="619" height="1220"/></div>&#13;
<p class="figcap"><em>Figure 5-10: Drawing a bar graph from a row</em></p>&#13;
<p class="indent">The <code>draw histogram</code> block first takes the <code>row</code> list from the Pascal’s triangle program and finds its maximum entry using the custom <code>find max of row</code> block (shown in <a href="ch05.xhtml#ch5fig11">Figure 5-11</a>). Based on this maximum, we calculate <code>horizontal step size</code> and <code>vertical step size</code> to ensure the drawing will fit on the stage <span class="ent">❶</span>. Then, we use a loop <span class="ent">➋</span> to draw the bar graph one bar at a time, moving up based on the corresponding value in <code>row</code>, across based on the number of bars to draw, and then back down to start on the next bar.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_91"/><img id="ch5fig11" src="../images/pg111_Image_134.jpg" alt="Image" width="517" height="527"/></div>&#13;
<p class="figcap"><em>Figure 5-11: Finding the maximum row element</em></p>&#13;
<p class="indent">The <code>find max of row</code> block simply cycles through all the values in <code>row</code>, updating the <code>max</code> variable each time it finds a higher value.</p>&#13;
<h5 class="h5" id="ch05lev10">The Results</h5>&#13;
<p class="noindent"><a href="ch05.xhtml#ch5fig12">Figure 5-12</a> shows the bar graphs for two more rows of the triangle.</p>&#13;
<div class="image"><img id="ch5fig12" src="../images/pg111_Image_135.jpg" alt="Image" width="997" height="378"/></div>&#13;
<p class="figcap"><em>Figure 5-12: Rows 20 (left) and 50 (right) of Pascal’s triangle</em></p>&#13;
<p class="indent">No matter the row, the shape of the bar graph looks similar. In fact, as <em>n</em> increases, the graph gets closer and closer to the famous bell curve of a normal distribution.</p>&#13;
<h5 class="h5" id="ch05lev11">Hacking the Code</h5>&#13;
<p class="noindent">The new <code>draw histogram</code> block is general enough to draw bar graphs for other datasets besides rows from Pascal’s triangle. For example, the code in <a href="ch05.xhtml#ch5fig13">Figure 5-13</a> prompts the user to enter a series of numbers—similar to what we did in <a href="ch04.xhtml#ch04lev13">Project 17</a> (<a href="ch04.xhtml#ch4fig16">Figure 4-16</a>), when we were working with difference tables—and then calls the <code>draw histogram</code> block to visualize that data.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_92"/><img id="ch5fig13" src="../images/pg112_Image_136.jpg" alt="Image" width="459" height="514"/></div>&#13;
<p class="figcap"><em>Figure 5-13: Creating a bar graph from a dataset</em></p>&#13;
<p class="indent">The <code>draw histogram</code> block expects the data to be in a list called <code>row</code> with a length of <code>n</code>. As long as your program has these features, the bar graph code will work. If all you have is <code>row</code>, you’ll need to supply <code>n</code> before drawing the bar graph <span class="ent">❶</span>.</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib"><span class="blue"><strong>5.1</strong></span> You might notice in a table of values of <em>n</em>! that for larger values of <em>n</em>, the value of <em>n</em>! will end with several zeros. Write a program to predict how many zeros there will be for a given <em>n</em>. In particular, can you predict how many zeros the value of 25! will end with?</p>&#13;
<p class="indentib"><span class="blue"><strong>5.2</strong></span> Write a program to extract sequences from Pascal’s triangle by stepping down along a diagonal. Use it to consider the diagonal in Pascal’s triangle consisting of values of <em>C</em>(<em>n</em>, 2). Identify this sequence in terms of the figurate numbers we discussed in <a href="ch04.xhtml#ch04">Chapter 4</a>.</p>&#13;
<p class="indentib"><span class="blue"><strong>5.3</strong></span> As an integer, the value of a binomial coefficient can be either even or odd. Change the row recurrence program for Pascal’s triangle (<a href="ch05.xhtml#ch05lev7">Project 19</a>) so it shows only 0 or 1, depending on if the binomial coefficient is even or odd. See what kinds of patterns you can find.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch05lev12">Operation Tables Have All the Answers</h3>&#13;
<p class="noindent">An <em>operation table</em> is a table of values showing the result of a mathematical operation, given different combinations of inputs. For example, you probably learned <span epub:type="pagebreak" id="page_93"/>basic multiplication using a multiplication table, or times table. This type of operation table usually has nine rows and nine columns, and it gives the answer to any multiplication problem where the two numbers being multiplied are indicated by the row and column. If you wanted to multiply 6 times 7, for instance, you would go across the top row (the index row) to find 6 and down the left column (the index column) to find 7. The value where column 6 and row 7 intersect is 42.</p>&#13;
<p class="indent">We couldn’t possibly create a complete multiplication table for all the positive integers because there are infinitely many of them. However, the usual nine-by-nine multiplication table for single-digit numbers has all the information we need to calculate products of longer numbers. Compare this situation with the modular arithmetic we discussed in <a href="ch02.xhtml#ch02">Chapter 2</a>. Once you pick a modulus, say <em>n</em>, all that matters is the remainder when a number is divided by <em>n</em>. There are only <em>n</em> possible remainders, 0 through <em>n</em> – 1. That means any operation table based on modular arithmetic will have a finite number of entries, and an <em>n</em>-by-<em>n</em> table will include them all.</p>&#13;
<p class="indent">A finite operation table, with its rows and columns, qualifies as an array. In the next project, we’ll use Scratch to generate operation tables for a given modulus and then see what kinds of patterns we can find.</p>&#13;
<h4 class="h4" id="ch05lev13">Project 21: Infinite Operation Tables with Modular Arithmetic</h4>&#13;
<p class="noindent">Our program will prompt the user for a modulus <em>n</em>, then ask them to choose an operation: addition or multiplication. It will then build an <em>n</em>-by-<em>n</em> table showing all possible outcomes of the chosen operation, mod <em>n</em>. For example, say the modulus is 7. The addition table should show the sum of every possible pair of numbers from 0 to 6, interpreted mod 7. The entry at the intersection of column 6 and row 2, for instance, should show (6 + 2) mod 7, which is 1. The multiplication table does the same for multiplication: the intersection of column 6 and row 2 should show (6 ⋅ 2) mod 7, which is 5.</p>&#13;
<div class="image"><img id="ch5fig14" src="../images/pg113_Image_137.jpg" alt="Image" width="437" height="598"/></div>&#13;
<p class="figcap"><em>Figure 5-14: Asking what modulus and what operation</em></p>&#13;
<p class="indent">We’ll build each row of the table as an entry in a Scratch list called <code>table</code>. First, we need some custom blocks to help us get organized. <a href="ch05.xhtml#ch5fig14">Figure 5-14</a> shows the <code>setup</code> block, which is called at the start of the program.</p>&#13;
<p class="indent">In the <code>setup</code> block, we first delete any previous version of <code>table</code> <span class="ent">❶</span>. Then, we prompt the user for the <code>modulus</code> (an integer) and <code>operation</code> (<code>+</code> or <code>*</code>). Once we have that information, we call the <code>Make index row</code> block <span class="ent">➋</span>, shown in <a href="ch05.xhtml#ch5fig15">Figure 5-15</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_94"/><img id="ch5fig15" src="../images/pg114_Image_138.jpg" alt="Image" width="663" height="869"/></div>&#13;
<p class="figcap"><em>Figure 5-15: Building the index row of the operation table</em></p>&#13;
<p class="indent">The <code>Make index row</code> block adds an index row at the top of the table containing labels for the columns, from 0 up to but not including the modulus, along with a <code>+</code> or <code>*</code> symbol to indicate whether it’s showing addition or multiplication. We build up the contents of the row as a string in the <code>row</code> variable, using a series of <code>join</code> blocks. We also add an extra row consisting of all dashes, to help set off the column index labels from the contents of the table itself.</p>&#13;
<p class="indent">Most of the work in this block goes into making the table look pretty, with the columns evenly spaced regardless of whether they contain one-digit or two-digit numbers. To help, we use the custom <code>pad</code> block <span class="ent">❶</span> (defined in <a href="ch05.xhtml#ch5fig16">Figure 5-16</a>), which puts either one or two spaces in front of a given string, depending on its length, to ensure that all the numbers in each column will be lined up nicely. If we know how many spaces we need to make the numbers line up, we can put them in directly, as we did in the index row <span class="ent">➋</span>, but otherwise it’s better to let the program decide.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The two</em> <span class="codeitalic">set x</span> <em>commands inside the</em> <span class="codeitalic">pad</span> <em>block might look the same, but they’re actually different. The empty space in the first one, which executes when</em> <span class="codeitalic">x</span> <em>has a length of 1, has two spaces in it, whereas the bottom one, which executes when</em> <span class="codeitalic">x</span> <em>has a length of 2, has only one space.</em></p>&#13;
</div>&#13;
<div class="image"><span epub:type="pagebreak" id="page_95"/><img id="ch5fig16" src="../images/pg115_Image_139.jpg" alt="Image" width="613" height="369"/></div>&#13;
<p class="figcap"><em>Figure 5-16: Padding a string with one or two spaces</em></p>&#13;
<p class="indent">Now that we have all these helper blocks, we can build the operation table, nicely formatted, with the main program code in <a href="ch05.xhtml#ch5fig17">Figure 5-17</a>.</p>&#13;
<div class="image"><img id="ch5fig17" src="../images/pg115_Image_140.jpg" alt="Image" width="621" height="988"/></div>&#13;
<p class="figcap"><em>Figure 5-17: Building the operation table, one row at a time</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_96"/>After calling our <code>setup</code> block, we use two nested loops to build the operation table row by row. The outer loop increments the variable <code>i</code>, representing the index number of the current row, while the inner loop increments the variable <code>j</code>, representing the column index number within the row. Each row begins with the row index number itself, followed by a colon <span class="ent">❶</span>. This is necessary because Scratch indexes lists starting from 1, but for our purposes it’s more natural to number the rows and columns from 0.</p>&#13;
<p class="indent">The real work is done in the <code>if...else</code> block inside the inner loop <span class="ent">➋</span>. There, depending on the desired operation, we calculate either <code>i + j</code> or <code>i * j</code> and take the <code>mod</code> of the result, giving us the current entry in the operation table. Once again, we use the <code>pad</code> block to add the appropriate number of spaces before joining the entry to the row being constructed. At the end of each cycle of the outer loop, we have a complete row, which we add to the <code>table</code> list.</p>&#13;
<h5 class="h5" id="ch05lev14">The Results</h5>&#13;
<p class="noindent"><a href="ch05.xhtml#ch5fig18">Figure 5-18</a> shows the resulting addition and multiplication tables for the small modulus <em>n</em> = 7.</p>&#13;
<div class="image"><img id="ch5fig18" src="../images/pg116_Image_141.jpg" alt="Image" width="649" height="407"/></div>&#13;
<p class="figcap"><em>Figure 5-18: Operation tables mod 7</em></p>&#13;
<p class="indent">Notice that each table starts with an index row showing the labels of the columns, from 0 to 6. There’s also an index column along the left side of the table, showing the labels of the rows (again from 0 to 6).</p>&#13;
<p class="indent">Using these tables, we can find the sum or product, mod 7, of any two integers. For example, say we want to find (152 + 263) mod 7. First, we need to take mod 7 of each input: 152 mod 7 is 5, and 263 mod 7 is 4. Next, we look in the addition table for the intersection of column 5 and row 4. The value there is 2, so that’s our answer. In this way, even though the tables have just seven rows and columns, they can give us the answer for any of the infinite number of positive integers. We just have to take mod 7 of the integers first.</p>&#13;
<p class="indent">There are several patterns to observe in these mod 7 operation tables:</p>&#13;
<div class="none">&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> For the addition table (on the left in <a href="ch05.xhtml#ch5fig18">Figure 5-18</a>), the values cycle row by row, shifting one column to the left from one row to the next. The value in the leftmost column of one row wraps back around, becoming the value in the rightmost column of the next row.</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> <span epub:type="pagebreak" id="page_97"/>The values in row 0 of the addition table match the values in the table’s index row. This indicates that 0 is the <em>additive identity</em>: adding 0 to a number doesn’t change the number. As far as 0 is concerned, modular addition works just like ordinary addition.</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> The <em>additive inverse</em> of a number <em>n</em> is the number that needs to be added to <em>n</em> to get 0. In ordinary addition, the additive inverse of a number is that number’s negation. For example, the additive inverse of 3 is –3. We don’t need to use negative numbers to have additive inverses in modular arithmetic, however. Notice that there’s a 0 in every row of the addition table. This means there’s a positive number that we can add to get 0, no matter what we start with. That is, every number has an additive inverse for a given modulus. For instance, row 3 has a 0 in the column 4, so 3 + 4 = 0 mod 7.</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> For the multiplication table (on the right in <a href="ch05.xhtml#ch5fig18">Figure 5-18</a>), the values in row 1 match the values in the index row. That means 1 is the <em>multiplicative identity</em>: multiplying a number by 1 doesn’t change the number. In this sense, modular multiplication is just like regular multiplication.</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> There’s a 1 in every row and column of the multiplication table except for row and column 0. That means every nonzero number can be multiplied by some other number, called the <em>multiplicative inverse</em>, to produce 1 mod 7.</p>&#13;
</div>&#13;
<p class="noindent">These observations don’t just apply to a modulus of 7; they’re true of any modulus. Try running the program for some other moduli and you’ll see the same patterns.</p>&#13;
<h5 class="h5" id="ch05lev15">Hacking the Code</h5>&#13;
<p class="noindent">When you start making operation tables for larger moduli, you’ll find that the entire contents of each row will no longer fit on the Scratch stage. The complete table is still there behind the scenes, though. If you want to see the whole table at once, you can export the <code>table</code> list to a text file and open it in a text editor or other program, as discussed in <a href="ch02.xhtml#ch02">Chapter 2</a>. The table will look best if you view it using a <em>monospaced</em> font like Courier, where every character has the same width, so the columns all line up. For example, <a href="ch05.xhtml#ch5fig19">Figure 5-19</a> shows the exported table for multiplication mod 12.</p>&#13;
<div class="image"><img id="ch5fig19" src="../images/pg117_Image_142.jpg" alt="Image" width="634" height="364"/></div>&#13;
<p class="figcap"><em>Figure 5-19: A multiplication table mod 12</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_98"/>Notice that this table has multiple 0s in some rows and columns. The 0s in row 0 and column 0 are to be expected: multiplication by 0 always yields 0. The other 0s are more interesting. They occur because 12 isn’t a prime number. Every factorization of 12 (in fact, every factorization of any multiple of 12) gives two numbers whose product is divisible by 12, and so whose product is 0 mod 12. For instance, in row 4 we have a 0 in columns 0, 3, 6, and 9. Indeed, 4 ⋅ 3, 4 ⋅ 6, and 4 ⋅ 9 are all examples of two numbers that multiply to be 0 mod 12, even though neither number was 0 mod 12 to begin with. These values are known as <em>zero divisors</em>, and they don’t occur for arithmetic of real numbers. They exist only in modular arithmetic, and only if the modulus isn’t prime.</p>&#13;
<p class="indent">If we cross out all the rows and columns that have extra 0s, as in <a href="ch05.xhtml#ch5fig20">Figure 5-20</a>, the values that aren’t crossed out form a smaller, reduced multiplication table.</p>&#13;
<div class="image"><img id="ch5fig20" src="../images/pg118_Image_143.jpg" alt="Image" width="659" height="382"/></div>&#13;
<p class="figcap"><em>Figure 5-20: A reduced multiplication table mod 12</em></p>&#13;
<p class="indent">We’re left with a 4×4 table of values, with row and column indices of 1, 5, 7, and 11. Every row and column in this smaller table has a 1 in it, meaning the remaining numbers all have a multiplicative inverse.</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib"><span class="blue"><strong>5.4</strong></span> If two numbers have no factors in common other than 1, they’re said to be <em>relatively prime</em>. For example, 6 and 35 are relatively prime, but 35 and 49 are not (they’re both divisible by 7). Rewrite the code for the operation tables so that it will produce a reduced multiplication table for a given modulus <em>n</em> that includes only rows and columns for numbers that are relatively prime to <em>n</em>. For example, for multiplication mod 12, it should produce a table that includes only the four rows and columns that aren’t crossed out in <a href="ch05.xhtml#ch5fig20">Figure 5-20</a>. If the modulus that’s supplied is a prime number <em>p</em>, it should generate a (<em>p</em> – 1)<em>×</em>(<em>p</em> – 1) table, omitting row and column 0.</p>&#13;
<p class="indentib"><span epub:type="pagebreak" id="page_99"/><span class="blue"><strong>5.5</strong></span> The <em>primitive root</em> of a prime number <em>p</em> is a number whose powers mod <em>p</em> generate all the integers from 1 to <em>p</em> – 1. For example, 2 is a primitive root of 11 because:</p>&#13;
<div class="none1">&#13;
<p class="noindenti"><img class="middle" src="../images/common-2.jpg" alt="Image" width="17" height="18"/> 2<sup>10</sup> = 1,024, and 1,024 mod 11 = 1</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-2.jpg" alt="Image" width="17" height="18"/> 2<sup>1</sup> = 2</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-2.jpg" alt="Image" width="17" height="18"/> 2<sup>8</sup> = 256, and 256 mod 11 = 3</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-2.jpg" alt="Image" width="17" height="18"/> 2<sup>2</sup> = 4</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-2.jpg" alt="Image" width="17" height="18"/> 2<sup>4</sup> = 16, and 16 mod 11 = 5</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-2.jpg" alt="Image" width="17" height="18"/> 2<sup>9</sup> = 512, and 512 mod 11 = 6</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-2.jpg" alt="Image" width="17" height="18"/> 2<sup>7</sup> = 128, and 128 mod 11 = 7</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-2.jpg" alt="Image" width="17" height="18"/> 2<sup>3</sup> = 8</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-2.jpg" alt="Image" width="17" height="18"/> 2<sup>6</sup> = 64, and 64 mod 11 = 9</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-2.jpg" alt="Image" width="17" height="18"/> 2<sup>5</sup> = 32, and 32 mod 11 = 10</p>&#13;
</div>&#13;
<p class="indentibp">On the other hand, 2 isn’t a primitive root of 7 because the only powers of 2 mod 7 are 1, 2, and 4. Write a program that asks for a prime number <em>p</em> and returns the first primitive root of <em>p</em> that it finds.</p>&#13;
<p class="indentib"><span class="blue"><strong>5.6</strong></span> Spreadsheet programs such as Excel can import text files easily if the files are in CSV format. This format expects there to be a comma between each entry in each row of the input data. Modify the Scratch code for operation tables so that the exported files are formatted in this way.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch05lev16">Conclusion</h3>&#13;
<p class="noindent">Arrays are two-dimensional tables of numbers, indexed by row and column. The position of an entry in the table provides two pieces of information—the row and column numbers—that you can sometimes use in a formula to determine the table entry. Scratch doesn’t have a built-in <code>array</code> type, but you can represent an array using a list, with each value containing all the array elements for a given row joined together, as we did in building operation tables. Another way to represent an array in Scratch is to build a list for each row of the array, as we did for Pascal’s triangle (a list of lists). The right way to represent an array depends on how you want to use it. Scratch is flexible enough to do whatever you want!<span epub:type="pagebreak" id="page_100"/></p>&#13;
</div>
</div>
</body></html>