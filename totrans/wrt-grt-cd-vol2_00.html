<html><head></head><body>
		<h2 class="h2" id="ch00"><span epub:type="pagebreak" id="page_xix"/><strong>INTRODUCTION</strong></h2>&#13;
		<div class="image1">&#13;
			<img alt="image" src="../images/common01.jpg"/>&#13;
		</div>&#13;
		<p class="noindent">What do we mean by <em>great code</em>? Different programmers will have different opinions. Therefore, it is impossible to provide an all-encompassing definition that will satisfy everyone. Here is the definition this book will use:</p>&#13;
		<div class="bq">&#13;
			<p class="noindent">Great code is software that is written using a consistent and prioritized set of good software characteristics. In particular, great code follows a set of rules that guide the decisions a programmer makes when implementing an algorithm as source code.</p>&#13;
		</div>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_xx"/>However, as I noted in <em>Write Great Code, Volume 1: Understanding the Machine</em> (hereafter, <em>WGC1</em>), there are some attributes of great code that nearly everyone can agree on. Specifically, great code:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Uses the CPU efficiently (that is, it’s fast)</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Uses memory efficiently (that is, it’s small)</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Uses system resources efficiently</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Is easy to read and maintain</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Follows a consistent set of style guidelines</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Uses an explicit design that follows established software engineering conventions</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Is easy to enhance</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Is well tested and robust (that is, it works)</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Is well documented</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">We could easily add dozens of items to this list. Some programmers, for example, may feel that great code must be portable, must follow a given set of programming style guidelines, or must be written in a certain language (or <em>not</em> be written in a certain language). Some may feel that great code must be written as simply as possible, while others believe that it must be written quickly. Still others may feel that great code is created on time and under budget.</p>&#13;
		<p class="indent">Given that there are so many aspects of great code—too many to describe properly in a single book—this second volume of the <em>Write Great Code</em> series concentrates primarily on one: efficient performance. Although efficiency might not always be the primary goal of a software development effort—nor does it have to be for code to qualify as great—people generally agree that inefficient code is <em>not</em> great code. And inefficiency is one of the major problems with modern applications, so it’s an important topic to emphasize.</p>&#13;
		<h3 class="h3" id="ch00lev1sec2"><strong>Performance Characteristics of Great Code</strong></h3>&#13;
		<p class="noindent">As computer system performance has increased from megahertz to hundreds of megahertz to gigahertz, computer software performance has taken a back seat to other concerns. Today, it’s not at all uncommon for software engineers to exclaim, “You should never optimize your code!” Funny, you don’t hear too many software <em>users</em> making such statements.</p>&#13;
		<p class="indent">Although this book describes how to write efficient code, it’s not a book about optimization. <em>Optimization</em> is a phase near the end of the Software Development Life Cycle (SDLC) in which software engineers determine why their code does not meet performance specifications and then refine it accordingly. But unfortunately, if they don’t put any thought into the application’s performance until the optimization phase, it’s unlikely that <span epub:type="pagebreak" id="page_xxi"/>optimization will prove practical. The time to ensure that an application meets reasonable performance benchmarks is at the <em>beginning</em> of the SDLC, during the design and implementation phases. Optimization can fine-tune a system’s performance, but it can rarely deliver a miracle.</p>&#13;
		<p class="indent">Although the quote is often attributed to Donald Knuth, who popularized it, it was Tony Hoare who originally said, “Premature optimization is the root of all evil.” This statement has long been the rallying cry of software engineers who neglect application performance until the very end of the SDLC—at which point optimization is typically ignored for economic or time-to-market reasons. However, Hoare did not say, “Concern about application performance during the early stages of an application’s development is the root of all evil.” He specifically said <em>premature optimization</em>, which, back then, meant counting cycles and instructions in assembly language code—not the type of coding you want to do during initial program design, when the code base is fluid. Thus, Hoare’s comments were on the mark.</p>&#13;
		<p class="indent">The following excerpt from a short essay by Charles Cook (<em><a href="https://bit.ly/38NhZkT">https://bit.ly/38NhZkT</a></em>) further describes the problem with reading too much into Hoare’s statement:</p>&#13;
		<div class="bq">&#13;
			<p class="noindent">I’ve always thought this quote has all too often led software designers into serious mistakes because it has been applied to a different problem domain to what was intended.</p>&#13;
			<p class="noindentt">The full version of the quote is “We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.” and I agree with this. It’s usually not worth spending a lot of time micro-optimizing code before it’s obvious where the performance bottlenecks are. But, conversely, when designing software at a system level, performance issues should always be considered from the beginning. A good software developer will do this automatically, having developed a feel for where performance issues will cause problems. An inexperienced developer will not bother, misguidedly believing that a bit of fine tuning at a later stage will fix any problems.</p>&#13;
		</div>&#13;
		<p class="indent">Indeed, Hoare was saying that software engineers should worry about other issues, like good algorithm design and implementation, before they worry about traditional optimizations, like how many CPU cycles a particular statement requires for execution.</p>&#13;
		<p class="indent">Although you could certainly apply many of this book’s concepts during an optimization phase, most of the techniques here really need to be applied during the initial coding. An experienced software engineer may argue that doing so produces only minor improvements in performance. In some cases, this is true—but keep in mind that these minor effects accumulate. If you put off these ideas until you reach “code complete,” it’s unlikely that they’ll ever find their way into your software. It’s just too much work to implement them after the fact (and too risky to make such changes to otherwise working code).</p>&#13;
		<h3 class="h3" id="ch00lev1sec3"><span epub:type="pagebreak" id="page_xxii"/><strong>The Goal of This Book</strong></h3>&#13;
		<p class="noindent">This book (and <em>WGC1</em>) attempts to fill the gaps in the education of the current generation of programmers so they can write quality code. In particular, it covers the following concepts:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Why it’s important to consider the low-level execution of your high-level programs</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">How compilers generate machine code from high-level language (HLL) statements</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">How compilers represent various data types using low-level, primitive data types</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">How to write your HLL code to help the compiler produce better machine code</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">How to take advantage of a compiler’s optimization facilities</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">How to “think” in assembly language (low-level terms) while writing HLL code</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">This book will teach you how to choose appropriate HLL statements that translate into efficient machine code with a modern optimizing compiler. In most cases, different HLL statements provide many ways to achieve a given result, some of which, at the machine level, are naturally more efficient than others. Though there may be a very good reason for choosing a less efficient statement sequence over a more efficient one (for example, readability), the truth is that most software engineers have no idea about HLL statement runtime costs and thus are unable to make an educated choice. The goal of this book is to change that.</p>&#13;
		<p class="indent">Again, this book is not about choosing the most efficient statement sequence no matter what. It is about understanding the cost of various HLL constructs so that, when faced with multiple options, you can make an informed decision about which sequence is most appropriate to use.</p>&#13;
		<h3 class="h3" id="ch00lev1sec4"><strong>Chapter Organization</strong></h3>&#13;
		<p class="noindent">Though you don’t need to be an expert assembly language programmer in order to write efficient code, you’ll need at least a basic knowledge of it to understand the compiler output in this book. <a href="ch01.xhtml#ch01">Chapters 1</a> and <a href="ch02.xhtml#ch02">2</a> discuss several aspects of learning assembly language, covering common misconceptions, considerations around compilers, and available resources. <a href="ch03.xhtml#ch03">Chapter 3</a> provides a quick primer for 80x86 assembly language. Online appendixes (<em><a href="http://www.randallhyde.com/">http://www.randallhyde.com/</a></em>) provide primers for the PowerPC, ARM, Java bytecode, and Common Intermediate Language (CIL) assembly languages.</p>&#13;
		<p class="indent">In <a href="ch04.xhtml#ch04">Chapters 4</a> and <a href="ch05.xhtml#ch05">5</a>, you’ll learn about determining the quality of your HLL statements by examining compiler output. These chapters describe disassemblers, object code dump tools, debuggers, various HLL compiler options for displaying assembly language code, and other useful software tools.</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_xxiii"/>The remainder of the book, <a href="ch06.xhtml#ch06">Chapters 6</a> through <a href="ch15.xhtml#ch15">15</a>, describes how compilers generate machine code for different HLL statements and data types. Armed with this knowledge, you’ll be able to choose the most appropriate data types, constants, variables, and control structures to produce efficient applications.</p>&#13;
		<h3 class="h3" id="ch00lev1sec5"><strong>Assumptions and Prerequisites</strong></h3>&#13;
		<p class="noindent">This book was written with certain assumptions about your prior knowledge. You’ll reap the greatest benefit from this material if your personal skill set matches the following:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">You should be reasonably competent in at least one imperative (procedural) or object-oriented programming language. This includes C and C++, Pascal, Java, Swift, BASIC, Python, and assembly, as well as languages like Ada, Modula-2, and FORTRAN.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">You should be capable of taking a small problem description and working through the design and implementation of a software solution for that problem. A typical semester or quarter course at a college or university (or several months of experience on your own) should be sufficient preparation.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">You should have a basic grasp of machine organization and data representation. You should know about the hexadecimal and binary numbering systems. You should understand how computers represent various high-level data types such as signed integers, characters, and strings in memory. Although the next couple of chapters provide a primer on machine language, it would help considerably if you’ve picked up this information along the way. <em>WGC1</em> fully covers the subject of machine organization if you feel your knowledge in this area is a little weak.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<h3 class="h3" id="ch00lev1sec6"><strong>The Environment for This Book</strong></h3>&#13;
		<p class="noindent">Although this book presents generic information, parts of the discussion will necessarily be system specific. Because the Intel Architecture PCs are, by far, the most common in use today, that’s the platform I’ll use when discussing specific system-dependent concepts in this book. However, those concepts still apply to other systems and CPUs—such as the PowerPC CPU in the older Power Macintosh systems, ARM CPUs in mobile phones, tablets and single-board computers (SBCs; like the Raspberry Pi or higher-end Arduino boards), and other RISC CPUs in a Unix box—although you may need to research the particular solution for an example on your specific platform.</p>&#13;
		<p class="indent">Most of the examples in this book run under macOS, Windows, and Linux. When creating the examples, I tried to stick with standard library interfaces to the OS wherever possible and make OS-specific calls only when the alternative was to write “less than great” code.</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_xxiv"/>Most of the specific examples in this text will run on a late-model Intel Architecture (including AMD) CPU under Windows, macOS, and Linux, with a reasonable amount of RAM and other system peripherals normally found on a modern PC. The concepts, if not the software itself, will apply to Macs, Unix boxes, SBCs, embedded systems, and even mainframes.</p>&#13;
		<h3 class="h3" id="ch00lev1sec7"><strong>For More Information</strong></h3>&#13;
		<p class="bib">Mariani, Rico. “Designing for Performance.” December 11, 2003. <em><a href="https://docs.microsoft.com/en-us/archive/blogs/ricom/designing-for-performance/">https://docs.microsoft.com/en-us/archive/blogs/ricom/designing-for-performance/</a></em>.</p>&#13;
		<p class="bib">Wikipedia. “Program Optimization.” <em><a href="https://en.wikipedia.org/wiki/Program_optimization/">https://en.wikipedia.org/wiki/Program_optimization/</a></em>.</p>&#13;
	</body></html>